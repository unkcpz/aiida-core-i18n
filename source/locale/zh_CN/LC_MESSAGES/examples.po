# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2019, ECOLE POLYTECHNIQUE FEDERALE DE LAUSANNE (Theory and Simulation of Materials (THEOS) and National Centre for Computational Design and Discovery of Novel Materials (NCCR MARVEL)), Switzerland and ROBERT BOSCH LLC, USA. All rights reserved
# This file is distributed under the same license as the AiiDA package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: AiiDA 1.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-07-16 20:22+0000\n"
"PO-Revision-Date: 2019-05-17 20:01+0000\n"
"Language-Team: Chinese (China) (https://www.transifex.com/aiidateam/teams/98967/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../docs/source/examples/pseudo_tutorial.rst:4
msgid "Introduction: Pseudopotential families"
msgstr ""

#: ../docs/source/examples/pseudo_tutorial.rst:6
msgid ""
"The procedure of attaching a pseudopotential file to each atomic species can"
" easily become tedious. In many situations, you will not produce a different"
" pseudopotential file for every calculation you perform; most likely, when "
"you start a project you will stick to a pseudopotential file that is "
"adequate for what you need. Furthermore, in a high-throughput calculation, "
"you will like to do calculations over several elements while keeping the "
"same functional. That is also part of the reason why there are several "
"projects (like the `PSLibrary <http://qe-"
"forge.org/gf/project/pslibrary/frs/>`_ or `GBRV "
"<http://www.physics.rutgers.edu/gbrv/>`_ to name a few), that intend to "
"develop a set of pseudopotentials that covers most of the periodic table for"
" different functionals."
msgstr ""

#: ../docs/source/examples/pseudo_tutorial.rst:18
msgid ""
"For this reason we introduced the concept of *pseudopotential families*. "
"Each family is a set of pseudopotentials that are grouped together in a "
"special type of `AiiDA Group of nodes`. Within each family, at most one "
"pseudopotential can be present for a given chemical element."
msgstr ""

#: ../docs/source/examples/pseudo_tutorial.rst:23
msgid ""
"A pseudopotential family does not necessarily have to  cover the whole "
"periodic table. This means that you can create a pseudopotential family "
"containing only the pseudopotentials for a few elements that you are "
"interested in."
msgstr ""

#: ../docs/source/examples/pseudo_tutorial.rst:28
msgid ""
"In principle, you can group different kinds of pseudopotentials into the "
"same family. It is your responsibility to group only those with the same "
"type, or obtained using the same functionals, approximations and / or levels"
" of theory."
msgstr ""

#: ../docs/source/examples/pseudo_tutorial.rst:33
msgid "Creating a pseudopotential family"
msgstr ""

#: ../docs/source/examples/pseudo_tutorial.rst:36
msgid ""
"The following commands are specific to the `Quantum ESPRESSO interface "
"<https://github.com/aiidateam/aiida-quantumespresso/>`_. For interfaces to "
"other codes, please refer to the respective plugin documentation."
msgstr ""

#: ../docs/source/examples/pseudo_tutorial.rst:40
msgid ""
"In the following, we will create a pseudopotential family. First, you need "
"to collect the pseudopotential files which should go into the family in a "
"single folder -- we'll call it ``path/to/folder``. You can then add the "
"family to the AiiDA database with ``verdi``::"
msgstr ""

#: ../docs/source/examples/pseudo_tutorial.rst:47
msgid ""
"where ``name_of_the_family`` should be a unique name for the family, and the"
" final parameter is a string that is set in the ``description`` field of the"
" group."
msgstr ""

#: ../docs/source/examples/pseudo_tutorial.rst:50
msgid ""
"If the a pseudopotential family with the same ``name_of_the_family`` exists "
"already, the pseudopotentials in the folder will be added to the existing "
"group. The code will raise an error if you try to add two (different) "
"pseudopotentials for the same element."
msgstr ""

#: ../docs/source/examples/pseudo_tutorial.rst:54
msgid ""
"After the upload (which may take some seconds, so please be patient) the "
"pseudopotential family will be ready for use."
msgstr ""

#: ../docs/source/examples/pseudo_tutorial.rst:58
msgid ""
"If you upload pseudopotentials which are already present in your database, "
"AiiDA will use the existing ``UPFData`` node instead of creating a duplicate"
" one. You can use the optional flag ``--stop-if-existing`` to instead abort "
"(without changing anything in the database) if an existing pseudopotential "
"is found."
msgstr ""

#: ../docs/source/examples/pseudo_tutorial.rst:65
msgid "Getting the list of existing families"
msgstr ""

#: ../docs/source/examples/pseudo_tutorial.rst:66
msgid ""
"To see wich pseudopotential families already exist in the database, type ::"
msgstr ""

#: ../docs/source/examples/pseudo_tutorial.rst:71
msgid ""
"Add a ``-d`` (or ``--with-description``) flag if you also want to read the "
"description of each family."
msgstr ""

#: ../docs/source/examples/pseudo_tutorial.rst:73
msgid ""
"You can also filter the groups to get only a list of those containing a "
"given set of elements using the ``-e`` option. For instance, if you want to "
"get only the families containing the elements ``Ba``, ``Ti`` and ``O``, use "
"::"
msgstr ""

#: ../docs/source/examples/pseudo_tutorial.rst:81
msgid "For more information on the command line options, type ::"
msgstr ""

#: ../docs/source/examples/pseudo_tutorial.rst:88
msgid "Manually adding pseudopotentials"
msgstr ""

#: ../docs/source/examples/pseudo_tutorial.rst:90
msgid ""
"If you do not want to use pseudopotentials from a family, it is also "
"possible to manually add them to the database (even though we discourage "
"this in general)."
msgstr ""

#: ../docs/source/examples/pseudo_tutorial.rst:93
msgid ""
"A possible way of doing it is the following: we start by creating a list of "
"pseudopotential filenames that we need to use::"
msgstr ""

#: ../docs/source/examples/pseudo_tutorial.rst:101
msgid ""
"In this simple example, we expect the pseudopotentials to be in the same "
"folder of the script. Then, we loop over the filenames and add them to the "
"AiiDA database. The ``get_or_create`` method checks if the pseudopotential "
"is already in the database and either stores it, or just returns the node "
"already present in the database. The second value returned is a boolean and "
"tells us if the pseudopotential was already present or not. We also store "
"the returned nodes in a list (``pseudos_to_use``)."
msgstr ""

#: ../docs/source/examples/pseudo_tutorial.rst:118
msgid ""
"As the last step, we make a loop over the pseudopotentials, and attach its "
"pseudopotential object to the calculation::"
msgstr ""

#: ../docs/source/examples/pseudo_tutorial.rst:125
msgid ""
"When the pseudopotential is created, it is parsed and the elements to which "
"it refers is stored in the database and can be accessed using the "
"``pseudo.element`` property, as shown above."
msgstr ""

#: ../docs/source/examples/structure_tutorial.rst:4
msgid "General comments"
msgstr ""

#: ../docs/source/examples/structure_tutorial.rst:6
msgid ""
"This section contains an example of how you can use the "
":py:class:`~aiida.orm.nodes.data.structure.StructureData` object to create "
"complex crystals."
msgstr ""

#: ../docs/source/examples/structure_tutorial.rst:10
msgid ""
"With the :py:class:`~aiida.orm.nodes.data.structure.StructureData` class we "
"did not try to have a full set of features to manipulate crystal structures."
" Indeed, other libraries such as `ASE <https://wiki.fysik.dtu.dk/ase/>`_ "
"exist, and we simply provide easy ways to convert between the ASE and the "
"AiiDA formats. On the other hand, we tried to define a \"standard\" format "
"for structures in AiiDA, that can be used across different codes."
msgstr ""

#: ../docs/source/examples/structure_tutorial.rst:20
msgid "How to use ``StructureData``"
msgstr ""

#: ../docs/source/examples/structure_tutorial.rst:22
msgid "Take a look at the following example::"
msgstr ""

#: ../docs/source/examples/structure_tutorial.rst:33
msgid ""
"With the commands above, we have created a crystal structure ``s`` with a "
"cubic unit cell and lattice parameter of 4 angstrom, and two atoms in the "
"cell: one iron (Fe) atom in the origin, and one oxygen (O) at the center of "
"the cube (this cell has been just chosen as an example and most probably "
"does not exist)."
msgstr ""

#: ../docs/source/examples/structure_tutorial.rst:39
msgid ""
"As you can see in the example above, both the cell coordinates and the atom "
"coordinates are expressed in angstrom, and the position of the atoms are "
"given in a global absolute reference frame."
msgstr ""

#: ../docs/source/examples/structure_tutorial.rst:43
msgid ""
"In this way, any periodic structure can be defined. If you want to import "
"from ASE in order to specify the coordinates, e.g., in terms of the crystal "
"lattice vectors, see the guide on the conversion to/from ASE below."
msgstr ""

#: ../docs/source/examples/structure_tutorial.rst:47
msgid ""
"When using the "
":py:meth:`~aiida.orm.nodes.data.structure.StructureData.append_atom` method,"
" further parameters can be passed. In particular, one can specify the mass "
"of the atom, particularly important if you want e.g. to run a phonon "
"calculation. If no mass is specified, the mass provided by `NIST "
"<http://www.nist.gov/pml/data/index.cfm>`_ (retrieved in October 2014) is "
"going to be used. The list of masses is stored in the module "
":py:mod:`aiida.common.constants`, in the ``elements`` dictionary."
msgstr ""

#: ../docs/source/examples/structure_tutorial.rst:56
msgid ""
"Moreover, in the :py:class:`~aiida.orm.nodes.data.structure.StructureData` "
"class of AiiDA we also support the storage of crystal structures with "
"alloys, vacancies or partial occupancies. In this case, the argument of the "
"parameter ``symbols`` should be a list of symbols, if you want to consider "
"an alloy; moreover, you must pass a ``weights`` list, with the same length "
"as ``symbols``, and with values between 0. (no occupancy) and 1. (full "
"occupancy), to specify the fractional occupancy of that site for each of the"
" symbols specified in the ``symbols`` list. The sum of all occupancies must "
"be lower or equal to one; if the sum is lower than one, it means that there "
"is a given probability of having a vacancy at that specific site position."
msgstr ""

#: ../docs/source/examples/structure_tutorial.rst:69
msgid "As an example, you could use::"
msgstr ""

#: ../docs/source/examples/structure_tutorial.rst:73
msgid ""
"to add a site at the origin of a structure ``s`` consisting of an alloy of "
"90% of Barium and 10% of Calcium (again, just an example)."
msgstr ""

#: ../docs/source/examples/structure_tutorial.rst:76
msgid "The following line instead::"
msgstr ""

#: ../docs/source/examples/structure_tutorial.rst:80
msgid ""
"would create a site with 90% probability of being occupied by Calcium, and "
"10% of being a vacancy."
msgstr ""

#: ../docs/source/examples/structure_tutorial.rst:83
msgid ""
"Utility properties ``s.is_alloy`` and ``s.has_vacancies`` can be used to "
"verify, respectively, if more than one element if given in the symbols list,"
" and if the sum of all weights is smaller than one."
msgstr ""

#: ../docs/source/examples/structure_tutorial.rst:87
msgid ""
"if you pass more than one symbol, the property ``s.is_alloy`` will always be"
" ``True``, even if only one symbol has occupancy 1 and all others have "
"occupancy zero::"
msgstr ""

#: ../docs/source/examples/structure_tutorial.rst:98
msgid "Internals: Kinds and Sites"
msgstr ""

#: ../docs/source/examples/structure_tutorial.rst:99
msgid ""
"Internally, the "
":py:meth:`~aiida.orm.nodes.data.structure.StructureData.append_atom` method "
"works by manipulating the kinds and sites of the current structure. Kinds "
"are instances of the :py:class:`~aiida.orm.nodes.data.structure.Kind` class "
"and represent a chemical species, with given properties (composing element "
"or elements, occupancies, mass, ...) and identified by a label (normally, "
"simply the element chemical symbol)."
msgstr ""

#: ../docs/source/examples/structure_tutorial.rst:106
msgid ""
"Sites are instances of the :py:class:`~aiida.orm.nodes.data.structure.Site` "
"class and represent instead each single site. Each site refers to a "
":py:class:`~aiida.orm.nodes.data.structure.Kind`  to identify its properties"
" (which element it is, the mass, ...) and to its three spatial coordinates."
msgstr ""

#: ../docs/source/examples/structure_tutorial.rst:112
msgid ""
"The :py:meth:`~aiida.orm.nodes.data.structure.StructureData.append_atom` "
"works in the following way:"
msgstr ""

#: ../docs/source/examples/structure_tutorial.rst:115
msgid ""
"It creates a new :py:class:`~aiida.orm.nodes.data.structure.Kind` class with"
" the properties passed as parameters (i.e., all parameters except "
"``position``)."
msgstr ""

#: ../docs/source/examples/structure_tutorial.rst:119
msgid ""
"It tries to identify if an identical Kind already exists in the list of "
"kinds of the structure (e.g., in the same atom with the same mass was "
"already previously added). Comparison of kinds is performed using "
":py:meth:`aiida.orm.nodes.data.structure.Kind.compare_with`, and in "
"particular it returns ``True`` if the mass and the list of symbols and of "
"weights are identical (within a threshold). If an identical kind ``k`` is "
"found, it simply adds a new site referencing to kind ``k`` and with the "
"provided ``position``. Otherwise, it appends ``k`` to the list of kinds of "
"the current structure and then creates the site referencing to ``k``. The "
"name of the kind is chosen, by default, equal to the name of the chemical "
"symbol (e.g., \"Fe\" for iron)."
msgstr ""

#: ../docs/source/examples/structure_tutorial.rst:131
msgid ""
"If you pass more than one species for the same chemical symbol, but e.g. "
"with different masses, a new kind is created and the name is obtained "
"postponing an integer to the chemical symbol name. For instance, the "
"following lines::"
msgstr ""

#: ../docs/source/examples/structure_tutorial.rst:139
msgid ""
"will automatically create three kinds, all for iron, with names ``Fe``, "
"``Fe1`` and ``Fe2``, and masses 55.8, 57. and 59. respecively."
msgstr ""

#: ../docs/source/examples/structure_tutorial.rst:142
msgid ""
"In case of alloys, the kind name is obtained concatenating all chemical "
"symbols names (and a X is the sum of weights is less than one). The same "
"rules as above are used to append a digit to the kind name, if needed."
msgstr ""

#: ../docs/source/examples/structure_tutorial.rst:146
msgid ""
"Finally, you can simply specify the kind_name to automatically generate a "
"new kind with a specific name. This is the case if you want a name different"
" from the automatically generated one, or for instance if you want to create"
" two different species with the same properties (same mass, symbols, ...). "
"This is for instance the case in Quantum ESPRESSO in order to describe an "
"antiferromagnetic cyrstal, with different magnetizations on the different "
"atoms in the unit cell."
msgstr ""

#: ../docs/source/examples/structure_tutorial.rst:154
msgid "In this case, you can for instance use::"
msgstr ""

#: ../docs/source/examples/structure_tutorial.rst:159
msgid ""
"To create two species ``Fe1`` and ``Fe2`` for iron, with the same mass."
msgstr ""

#: ../docs/source/examples/structure_tutorial.rst:161
msgid ""
"You do not need to specify explicitly the mass if the default one is ok for "
"you. However, when you pass explicitly a name and it coincides with the name"
" of an existing species, all properties that you specify must be identical "
"to the ones of the existing species, or the method will raise an exception."
msgstr ""

#: ../docs/source/examples/structure_tutorial.rst:167
msgid ""
"If you prefer to work with the internal "
":py:class:`~aiida.orm.nodes.data.structure.Kind` and "
":py:class:`~aiida.orm.nodes.data.structure.Site` classes, you can obtain the"
" same result of the two lines above with::"
msgstr ""

#: ../docs/source/examples/structure_tutorial.rst:181
msgid "Conversion to/from ASE"
msgstr ""

#: ../docs/source/examples/structure_tutorial.rst:183
msgid ""
"If you have an AiiDA structure ``s``, you can get an ``ase.Atom`` object by "
"just calling the "
":py:class:`~aiida.orm.nodes.data.structure.StructureData.get_ase` method::"
msgstr ""

#: ../docs/source/examples/structure_tutorial.rst:189
msgid ""
"As we support alloys and vacancies in AiiDA, while ``ase.Atom`` does not, it"
" is not possible to export to ASE a structure with vacancies or alloys."
msgstr ""

#: ../docs/source/examples/structure_tutorial.rst:192
msgid ""
"If instead you have as ASE Atoms object and you want to load the structure "
"from it, just pass it when initializing the class::"
msgstr ""

#: ../docs/source/examples/structure_tutorial.rst:201
msgid "Creating multiple species"
msgstr ""

#: ../docs/source/examples/structure_tutorial.rst:203
msgid ""
"We implemented the possibility of specifying different Kinds (species) in "
"the ``ase.atoms`` and then importing them."
msgstr ""

#: ../docs/source/examples/structure_tutorial.rst:206
msgid ""
"In particular, if you specify atoms with different mass in ASE, during the "
"import phase different kinds will be created::"
msgstr ""

#: ../docs/source/examples/structure_tutorial.rst:221
msgid ""
"Moreover, even if the mass is the same, but you want to get different "
"species, you can use the ASE ``tags`` to specify the number to append to the"
" element symbol in order to get the species name::"
msgstr ""

#: ../docs/source/examples/structure_tutorial.rst:237
msgid ""
"in complicated cases (multiple tags, masses, ...), it is possible that "
"exporting a AiiDA structure to ASE and then importing it again will not "
"perfectly preserve the kinds and kind names."
msgstr ""

#: ../docs/source/examples/structure_tutorial.rst:243
msgid "Conversion to/from pymatgen"
msgstr ""

#: ../docs/source/examples/structure_tutorial.rst:245
msgid ""
"AiiDA structure can be converted to pymatgen's `Molecule`_ and `Structure`_ "
"objects by using, accordingly, "
":py:class:`~aiida.orm.nodes.data.structure.StructureData.get_pymatgen_molecule`"
" and "
":py:class:`~aiida.orm.nodes.data.structure.StructureData.get_pymatgen_structure`"
" methods::"
msgstr ""

#: ../docs/source/examples/structure_tutorial.rst:255
msgid ""
"A single method "
":py:class:`~aiida.orm.nodes.data.structure.StructureData.get_pymatgen` can "
"be used for both tasks: converting periodic structures (periodic boundary "
"conditions are met in all three directions) to pymatgen's Structure and "
"other structures to pymatgen's Molecule::"
msgstr ""

#: ../docs/source/examples/structure_tutorial.rst:263
msgid ""
"It is also possible to convert pymatgen's Molecule and Structure objects to "
"AiiDA structures::"
msgstr ""

#: ../docs/source/examples/structure_tutorial.rst:270
msgid "Also in this case, a generic converter is provided::"
msgstr ""

#: ../docs/source/examples/structure_tutorial.rst:276
msgid ""
"Converters work with version 3.0.13 or later of pymatgen. Earlier versions "
"may cause errors."
msgstr ""
