# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2019, ECOLE POLYTECHNIQUE FEDERALE DE LAUSANNE (Theory and Simulation of Materials (THEOS) and National Centre for Computational Design and Discovery of Novel Materials (NCCR MARVEL)), Switzerland and ROBERT BOSCH LLC, USA. All rights reserved
# This file is distributed under the same license as the AiiDA package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Jason.Eu <morty.yu@yahoo.com>, 2019
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: AiiDA 1.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-10-31 22:43+0000\n"
"PO-Revision-Date: 2019-05-17 20:01+0000\n"
"Last-Translator: Jason.Eu <morty.yu@yahoo.com>, 2019\n"
"Language-Team: Chinese (China) (https://www.transifex.com/aiidateam/teams/98967/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../docs/source/concepts/calculations.rst:5
#: ../docs/source/concepts/processes.rst:6
#: ../docs/source/concepts/workflows.rst:5
msgid "Concept"
msgstr ""

#: ../docs/source/concepts/calculations.rst:7
msgid ""
"A calculation is a process (see the :ref:`process "
"section<concepts_processes>` for details) that *creates* new data. "
"Currently, there are two ways of implementing a calculation process:"
msgstr ""
"算例是一个能够创建新数据的例程 (详情参见 :ref:`例程章节<concepts_processes>` ) 。 当前，有两种算例的实现，分别是："

#: ../docs/source/concepts/calculations.rst:10
msgid ":ref:`calculation function<concepts_calcfunctions>`"
msgstr ":ref:`算例函数<concepts_calcfunctions>`"

#: ../docs/source/concepts/calculations.rst:11
msgid ":ref:`calculation job<concepts_calcjobs>`"
msgstr ":ref:`算例任务<concepts_calcjobs>`"

#: ../docs/source/concepts/calculations.rst:13
msgid ""
"The first one is the simplest of the two and is basically a python function "
"that is magically transformed into a process. This is ideal for calculations"
" that are not very computationally intensive and can be easily implemented "
"in a python function. For more taxing calculations, typically performed by "
"external codes that are optionally run on remote computing clusters, the "
"calculation job is the better alternative."
msgstr ""
"前者是简单的将一个python函数转变为一个例程(process)，这适用于计算量不大且易于实现的python函数。对于复杂的计算任务，通常需要外部的计算软件参与，这些代码通常运行在远端的集群上，因此使用"
" 算例任务更为合适。"

#: ../docs/source/concepts/calculations.rst:17
msgid ""
"In the following sections, both concepts will be explained but without going"
" too much into detail on how to implement or run them. For a more detailed "
"exposé, please refer to the respective advanced sections on "
":ref:`calculation functions<working_calcfunctions>` and :ref:`calculation "
"jobs<working_calcjobs>`."
msgstr ""
"下列章节将分别介绍两者，但是这里只是简单介绍概念而不深入详细的实现和使用细节。详细的内容请参考相应的进阶章节 "
":ref:`算例函数<working_calcfunctions>` 和 :ref:`算例任务<working_calcjobs>` 。"

#: ../docs/source/concepts/calculations.rst:24
msgid "Calculation functions"
msgstr "算例函数(Calculation functions)"

#: ../docs/source/concepts/calculations.rst:26
msgid "Consider the following computational task at hand:"
msgstr "以下列计算任务为例："

#: ../docs/source/concepts/calculations.rst:29
msgid ""
"Given three integers, add the first two and then multiply the sum by the "
"third."
msgstr "给定三个整数，将前两者求和后与第三者相乘。"

#: ../docs/source/concepts/calculations.rst:31
msgid ""
"In plain python code, the solution would look something like the following:"
msgstr "常规的python代码如下："

#: ../docs/source/concepts/calculations.rst:36
msgid ""
"This simple code snippet will achieve the goal of getting the desired "
"result, however, the provenance is lost. There is no connection between the "
"output of the functions and their inputs. The remedy to this problem is the "
":py:func:`~aiida.engine.processes.functions.calcfunction`. The "
"``calcfunction`` in AiiDA is a `function decorator "
"<https://docs.python.org/3/glossary.html#term-decorator>`_ that transforms a"
" regular python function in a calculation process, which automatically "
"stores the provenance of its output in the :ref:`provenance "
"graph<concepts_provenance>` when executed. Updating the previous snippet "
"with ``calcfunction`` decorators yields:"
msgstr ""
"这些代码会直接得到想要的结果，但是，并没有关于运算过程的可验证性。结果与输入之间并没有保留运算关系。 为保留运算过程，我们使用 "
":py:meth:`~aiida.engine.processes.functions.calcfunction`。  "
"AiiDA的``calcfunction`` 是一个 `装饰器 <https://docs.python.org/3/glossary.html"
"#term-decorator>`_ 它将一个函数装饰成为一个算例例程，这使得其可以自动将得到结果的计算过程储存为一个 "
":ref:`可验证性图<concepts_provenance>` 。. 使用 ``calcfunction`` 装饰器更性上面代码片段后为:"

#: ../docs/source/concepts/calculations.rst:45
msgid ""
"The only thing we had to do to decorate the two functions was to add the "
"line ``@calcfunction`` just before the function definition. Adding the "
"decorator tells AiiDA that the provenance for this function should be stored"
" in the provenance graph when it is executed. This means linking up the "
"inputs and the outputs for a calculation node, which represents the function"
" that was executed. The final change that has to be performed to make this "
"possible, is to make the inputs and the outputs storable. In the previous "
"snippet, the inputs are plain python integer types, which cannot be "
"automatically stored in the provenance graph as nodes. To solve this, one "
"only has to wrap them in the :py:class:`~aiida.orm.nodes.data.int.Int` node "
"sub class, which makes them storable in the database:"
msgstr ""
"我们只需要简单的在每一个函数前增加 ``@calcfunction`` 装饰器。 增加的装饰器使得 AiiDA "
"知晓被装饰的函数在执行后的可验证性需要被储存进可验证性图中 。 也就是执行函数后将输入和输出与一个算例节点连接。  "
"新的代码块还涉及将输入和输出储存进可验证性图。之前的代码中，输入和输出都是普通的python整型数据结构，是无法作为节点自动存入可验证性图中的。为实现该特性，用户只需要将输入输出封装成"
" :py:class:`~aiida.orm.nodes.data.int.Int`  类即可，这样他们就能够被储存进入数据库中了。"

#: ../docs/source/concepts/calculations.rst:55
msgid ""
"The only difference with the previous snippet is that all inputs have been "
"wrapped in the :py:class:`~aiida.orm.nodes.data.int.Int` class. The result "
"that is returned by the function, is now also an "
":py:class:`~aiida.orm.nodes.data.int.Int` node that can be stored in the "
"provenance graph, and contains the result of the computation."
msgstr ""
"前后函数中的的代码差异就只是输入被封装成了 :py:class:`~aiida.orm.nodes.data.int.Int` 类。 "
"同样返回的结果也被封装成 :py:class:`~aiida.orm.nodes.data.int.Int` "
"包含计算结果的节点，可以储存进可验证性图中。"

#: ../docs/source/concepts/calculations.rst:60
msgid ""
"Since ``x`` and ``y`` inside the ``add`` and ``multiply`` functions are "
"already :py:class:`~aiida.orm.nodes.data.int.Int` instances the sum will "
"also be one. This is true because all arithmetic operators also work on the "
"base AiiDA classes (``Int``, ``Float``, etc.) as they would on the "
"equivalent python types. It is important to realize though that only "
":py:class:`~aiida.orm.nodes.node.Node` instances, or sub classes thereof can"
" be stored. For more information on how to return results from process "
"functions, refer to the :ref:`advanced section<working_calcfunctions>`."
msgstr ""
"因为函数 ``add`` 和 ``multiply`` 中的 ``x`` 和 ``y`` 都已经是 "
":py:class:`~aiida.orm.nodes.data.int.Int` "
"类的实例，因为所有的运算都已经重载，无需类型转换便可以用于AiiDA类( ``Int``, ``Float``, "
"等)，他们等价于python本身的类型。需要清楚的记住只有 :py:class:`~aiida.orm.nodes.node.Node` "
"的实例，或是其子类的实例可以被储存进数据库。有关如何从例程函数中返回可储存的结果，请参考 "
":ref:`进阶章节<working_calcfunctions>`"

#: ../docs/source/concepts/calculations.rst:65
msgid ""
"With these trivial changes, the full provenance of the result produced by "
"running the function is maintained and looks like the following:"
msgstr "在这样简单的修改后，函数运行并产生结果的整个可验证性就被保留下来，如下所示："

#: ../docs/source/concepts/calculations.rst:70
msgid "The provenance generated by the calcfunction example"
msgstr "算例例子生成的可验证性图"

#: ../docs/source/concepts/calculations.rst:72
msgid ""
"The example above already shows how a calcfunction can be run: simply by "
"calling it. The value that is returned is the result returned by the "
"definition of the function. However, sometimes one would also like to have a"
" reference to the calculation node that represents the execution of the "
"function in the provenance graph. The following example shows two additional"
" launch functions that will return a tuple, which in addition to the "
"results, also return the ``pk`` or the node associated with the process"
msgstr ""
"上面的例子展示了如何运行一个算例：简单的调用并运行。算例返回的结果就是对应函数的结果。然而用户可能还会想要得到有关算例节点的信息。下列代码块展示了如何用另外两个函数在运行的同时获得例程的"
" ``pk`` 和节点信息。"

#: ../docs/source/concepts/calculations.rst:80
msgid ""
"This was a very short and limited description of calculation functions. For "
"a more detailed description of launching them, please refer to the section "
"on :ref:`launching processes<working_processes_launching>`. If you want more"
" details on implementing calculation functions and best practices, refer to "
"the section on :ref:`working with calculation "
"functions<working_calcfunctions>`."
msgstr ""
"这是一个关于算例函数的一个简单概述。请从以下链接:ref:`启动例程<working_processes_launching>`` "
"中获得有关如可启动例程的详细细节。如果你想要知晓有关如何实现一个算例函数并找到更为详细的示例，请参考章节:ref:`算例函数的开发`。 "

#: ../docs/source/concepts/calculations.rst:88
msgid "Calculation jobs"
msgstr "算例任务(Calculation jobs)"

#: ../docs/source/concepts/calculations.rst:90
msgid ""
"In the previous section on :ref:`calculation "
"functions<concepts_calcfunctions>`, we showed how a simple python function "
"can be transformed into a process, such that when it is launched, its "
"execution is recorded automatically in the provenance graph. However, not "
"all computations are well suited to be implemented as a python function, but"
" rather are implemented as a separate code, external to AiiDA. To interface "
"an external code with the engine of AiiDA, the "
":py:class:`~aiida.engine.processes.calcjobs.calcjob.CalcJob` process class "
"was introduced. A detailed explanation of how to implement it, the interface"
" and best practices, can be found in a :ref:`later "
"section<working_calcjobs>`. Here, instead, we will focus on the big picture "
"and explain in broad lines how a calculation job models the execution of an "
"external code and what tasks it performs when launched."
msgstr ""
"在前面章节 :ref:`算例函数<concepts_calcfunctions>` "
"，我们展示了如何将简单的python函数转换成一个例程，以使其在启动执行后，其结果能够自动记录在可验证性图中。然而并非所有计算过程都能够通过简单的python函数实现，而是通常涉及外部代码来实现。为了实现外部代码与内部引擎的接口"
" AiiDA 引入了 :py:class:`~aiida.engine.processes.calcjobs.calcjob.CalcJob` "
"process 类 。 可以在 :ref:`后续章节<working_calcjobs>` "
"中找到关于如何实现与外部代码接口的细节和示例。这里，只关注算例任务的整体特征和使用场景，即如何通过算例任务来驱动外部代码的运行。"

#: ../docs/source/concepts/calculations.rst:96
msgid ""
"To illustrate how a calculation job operates, we need an external code. "
"Let's imagine an external code that consists of a bash script that reads an "
"input file containing two integers, sums them and prints the result in the "
"standard output using ``echo``, for example:"
msgstr ""
"为了展示算例任务是如何工作的，我们首先需要一份外部代码样例。我们假设一个外部代码是一个bash脚本，它读入一个包含两个整数的文件，并将他们求和后返回结果，如："

#: ../docs/source/concepts/calculations.rst:107
msgid ""
"When run, this script reads the contents of a file called ``aiida.in`` and "
"expects that it contains two integers. It will parse these into the "
"variables ``x`` and ``y`` and then print their sum. When you want to run "
"this 'code' through AiiDA, you need to tell *how* AiiDA should run it. The "
":py:class:`~aiida.calculations.plugins.arithmetic.add.ArithmeticAddCalculation`"
" is a calculation job implementation that forms an interface to accomplish "
"exactly that for the example bash script. A ``CalcJob`` implementation for a"
" specific code, often referred to as a calculation plugin, essentially "
"instructs the engine how it should be run. This includes how the necessary "
"input files should be created based on the inputs that it receives, how the "
"code executable should be called and what files should be retrieved when the"
" calculation is complete. Note the files should be 'retrieved' because "
"calculation jobs can be run not just on the localhost, but on any "
":ref:`computer that is configured in AiiDA<setup_computer>`, including "
"remote machines accessible over for example SSH."
msgstr ""
"运行后，该脚本会从名为 ``aiida.in`` 的文件中读取数据，数据需要是两整数。脚本会将这两个整数解析成变量 ``x`` 和 ``y`` "
"，并打印求和后的结果。当你要用AiiDA运行这段代码，你需要告诉AiiDA如何运行这段代码。:py:class:`~aiida.calculations.plugins.arithmetic.add.ArithmeticAddCalculation`"
" 就是一个实现与上述脚本接口的算例任务。 一个 ``CalcJob`` "
"就是一个关于特定代码如何运行的接口，通常作为一个计算插件调用，它的功能主要是告知AiiDA如何运行这样一份外部代码。这包括了如何从输入产生需要的输入文件，如何运行外部代码，以及当外部代码运行完成后如何取回运行结果文件。之所以需要"
" ‘取出’ 运行结果，是因为算例任务可能不仅仅在本地运行，还会通过SSH在远端已经 "
":ref:`配置入AiiDA配置文件<setup_computer>` 的集群上运行。"

#: ../docs/source/concepts/calculations.rst:115
msgid ""
"Since a ``CalcJob`` is a process just like the :ref:`calculation "
"functions<concepts_calcfunctions>` described before, they can be run in an "
"identical way."
msgstr ""
"因为 ``CalcJob`` 和前面所述的 :ref:`算例函数<concepts_calcfunctions>` "
"一样是一个例程，所以他们通过相同的方式运行。"

#: ../docs/source/concepts/calculations.rst:120
msgid ""
"the provenance generated by running the calculation job will look something "
"like this:"
msgstr "通过运行算例任务产生的可验证性图如下所示："

#: ../docs/source/concepts/calculations.rst:125
msgid "The provenance generated by the calculation job example"
msgstr "算例任务例子生成的可验证性图"

#: ../docs/source/concepts/calculations.rst:127
msgid ""
"The execution of the calculation job is represented in the provenance graph "
"by a process node, i.e. the pink square labeled `C\\ :sub:`1`` in "
":numref:`fig_calculation_jobs_provenance_arithmetic_add`. The integer data "
"nodes ``x`` and ``y`` that were passed as inputs are linked to the "
"calculation job as such, as well as the third input ``code``. This input is "
"required for *all* calculation jobs as it represents the external code that "
"is actually executed. These code nodes are instances of the "
":py:class:`~aiida.orm.nodes.data.code.Code` class, which is a sub-class of "
":py:class:`~aiida.orm.nodes.data.data.Data`. This means that code instances "
"are a sort of data node. Its function is to record the path to the "
"executable and some other code related attributes defined during the "
":ref:`code setup<setup_code>`."
msgstr ""
"算例任务的执行在可验证性图中表示为一个例程节点，如图所示，图 "
":numref:`fig_calculation_jobs_provenance_arithmetic_add` 中粉色正方形标注 `C\\ "
":sub:`1`` 的节点。输入参数 ``x`` 和 ``y`` 以及使用的 ``code`` 都与例程节点连接。 ``code`` 作为输入参数节点在"
" *所有的* 算例任务中都存在，用以表示真实执行的外部代码。 节点是 "
":py:class:`~aiida.orm.nodes.data.code.Code` 类的实例，该类是 "
":py:class:`~aiida.orm.nodes.data.data.Data` "
"类的子类。因此该节点同样是一个数据节点。该节点的作用是记录外部可执行代码以及代码相关的信息 这写信息是在 :ref:`计算代码（code） "
"设置<setup_code>` 中提供的。"

#: ../docs/source/concepts/calculations.rst:134
msgid ""
"The calculation job produced two outputs, an integer node, containing the "
"sum of ``x`` and ``y`` and a "
":py:class:`~aiida.orm.nodes.data.folder.FolderData` node, containing the "
"output files that were retrieved. Note that all outputs of calculation jobs "
"(except for the ``retrieved`` node) are technically not created by the "
"calculation job itself, but rather by an implementation of the "
":py:class:`~aiida.parsers.parser.Parser` class. In principle, this step is "
"optional, and so a calculation job is therefore not required to produce any "
"outputs, except for the ``retrieved`` folder data node, which will always be"
" there. How the parser fits into the concept of calculation jobs will be "
"addressed in :ref:`this section<concepts_calcjobs_parsers>`."
msgstr ""
"这个算例任务生成两个输出，一个是包含了 ``x`` 和 ``y`` 求和结果的整数数据节点，和一个数据类型为 "
":py:class:`~aiida.orm.nodes.data.folder.FolderData`  "
"的节点，该节点包含了存放计算结果的文件夹。需要注意到的是，（除了 ``retrieved`` "
"节点）所有的算例任务的计算结果都不是由其自身产生的，而是通过 :py:class:`~aiida.parsers.parser.Parser` "
"类解析产生的。原则上解析的步骤不是必须的因此算例任务可以没有输出，但一定会有 ``retrieved``` "
"数据节点。有关算例任务中结果解析器概念的详细内容请参考 :ref:`这里<concepts_calcjobs_parsers>`。"

#: ../docs/source/concepts/calculations.rst:142
msgid "Transport tasks"
msgstr "传输任务"

#: ../docs/source/concepts/calculations.rst:144
msgid ""
"To arrive at the provenance graph shown above in "
":numref:`fig_calculation_jobs_provenance_arithmetic_add`, the engine "
"performed quite some tasks. When a calculation job is launched, the engine "
"will take it roughly through the following steps:"
msgstr ""
"AiiDA内部引擎执行了一系列工作，以实现可验证性图 "
":numref:`fig_calculation_jobs_provenance_arithmetic_add` 。 "
"。当一个算例任务启动时，AiiDA内部引擎执行下列步骤："

#: ../docs/source/concepts/calculations.rst:147
msgid ""
"**Upload**: the calculation job implementation is used to transform the "
"input nodes into the required input files, which are uploaded to a 'working'"
" directory on the target machine"
msgstr "**上传** : 算例任务会从输入节点得到输入文件，再将输入文件上传到目标计算机器的工作目录中"

#: ../docs/source/concepts/calculations.rst:148
msgid ""
"**Submit**: to execute the calculation, a job is submitted to the scheduler "
"of the computer on which the input `code` is configured."
msgstr "**提交** : 提交一个作业到作业调度工具到配置文件中 `code` 所在的计算机。 "

#: ../docs/source/concepts/calculations.rst:149
msgid ""
"**Update**: the engine will query the scheduler to check for the status of "
"the calculation job"
msgstr "**更新**: 内部引擎会不断查询作业系统以返回算例任务的状态。"

#: ../docs/source/concepts/calculations.rst:150
msgid ""
"**Retrieve**: once the job has finished, the engine will retrieve the output"
" files, specified by the plugin and store them in a node attached as an "
"output node to the calculation"
msgstr "**获取**: 一旦作业结束，引擎会取回输出文件，依据插件中定义的方式将输出结果储存在可验证性图的节点中。"

#: ../docs/source/concepts/calculations.rst:152
msgid ""
"All of these tasks require the engine to interact with the computer, or "
"machine, that will actually run the external code. Since the "
":py:class:`~aiida.orm.nodes.data.code.Code` that is used as an input for the"
" calculation job, which is configured for a specific "
":py:class:`~aiida.orm.computers.Computer`, the engine knows exactly how to "
"execute all these tasks. The ``CalcJob`` implementation itself then is "
"completely independent of the machine the code will be run on. To run the "
"calculation job on a different machine, all you have to do is change the "
"``code`` input to one that is configured for that machine. If the machine is"
" *not* the localhost, the engine will need a way to connect to the remote "
"machine in order to perform each of the four tasks listed above. The "
"mechanism that allows the engine to connect to the remote machine is called "
"a *transport* and therefore the tasks it performs using this transport are "
"called *transport tasks*."
msgstr ""
"以上的所有任务都需要AiiDA内部引擎与计算资源间的交互。因为将 :py:class:`~aiida.orm.nodes.data.code.Code`"
" "
"配置为与特定计算资源:py:class:`~aiida.orm.computers.Computer`关联并作为算例任务的输入，引擎会知晓如何运行这些任务。"
" ``CalcJob`` 的实现是独立的，因此在内部代码中不依赖 `code` "
"和计算资源信息。因此要在另外的计算资源中运行这个算例任务，用户只需要改变对特定计算资源配置的 ``code`` "
"输入即可。之前提到，算例任务不但可以运行在AiiDA引擎运行的机器上，还能运行在远端的机器上。通过输入参数 ``code`` "
"就能指定要运行的机器，因为计算代码（code）中包含了运行代码的特定机器的信息。如果机器不是在本地，AiiDA引擎需要连接远端机器以执行上面四个任务。引擎连接远端计算资源的操作称作"
" *transport* (传输)，因此完成该操作的任务称作 *传输任务* 。"

#: ../docs/source/concepts/calculations.rst:163
msgid "Exponential backoff mechanism"
msgstr "反复退让机制"

#: ../docs/source/concepts/calculations.rst:165
msgid ""
"In the case of calculation jobs being executed on a remote machine, the "
"engine will have to connect to the machine for each of the transport tasks. "
"In connecting to the remote, a whole host of potential problems may occur "
"that would cause the calculation job to fail. For example, the remote "
"machine may be down and as a result unreachable, or the engine itself may "
"lose its internet connection. However, these problems are often temporary. "
"To prevent the calculation job from excepting and it being lost forever, an "
"*exponential backoff mechanism* has been implemented. Whenever the engine "
"performs a transport task but encounters an exception, instead of letting "
"the calculation job fail, it will reschedule the same task to be executed "
"again at a later time. The task will be automatically rescheduled until it "
"finishes successfully, where the interval between tries increases "
"exponentially. If after 5 consecutive tries, the task still fails, instead "
"of rescheduling it, the engine will simply pause the calculation job. The "
"output of ``verdi process list`` will give more information on why the task "
"failed:"
msgstr ""
"当在远端机器执行算例的过程中，AiiDA引擎需要为每一个传输任务建立一条链接。当连接远端服务器时，所有服务器端的潜在问题都可能发生，这会导致算例任务失败。比如，远端计算资源可能宕机而导致结果无法获得，或者引擎所在的本地端可能无法连接网络。然而，这些问题都是不确定的。为了防止算例任务异常或一直无法连接，AiiDA使用了"
" *反复退让策略* "
"。当引擎执行了一个传输任务时遇到异常，算例任务不会直接失败，而是提交一个相同的任务后续重新执行。任务会自动重新加入作业系统直到其顺利结束。在连续5次尝试后，若任务还是失败，引擎会单纯的暂停算例任务而不是重新提交。``verdi"
" process list`` 能够输出有关任务失败的更多信息："

#: ../docs/source/concepts/calculations.rst:184
msgid ""
"When there are calculation jobs that have been paused because the transport "
"tasks have failed multiple times, the user has the time to investigate the "
"problem. If the problem is determined to be temporary and it has been "
"resolved, one can use ``verdi process play`` to resume the paused processes."
" The engine will then automatically reschedule the task that failed last and"
" the calculation job will continue where it left off."
msgstr ""
"当算例任务因为传输任务失败后且反复重试后依旧无法连接而暂停后，用户可以查看问题。如果发现问题是临时发生的，且问题被解决后，用户可以重新使用 "
"``verdi process play`` 来恢复暂停的任务。AiiDA引擎会自动重新提交之前失败的任务，且暂停的算例任务会继续在停止的地方恢复执行。"

#: ../docs/source/concepts/calculations.rst:188
msgid ""
"This exponential backoff mechanism makes the engine very robust with respect"
" to calculation jobs, reducing the loss of computational resources due to "
"temporary problems to an absolute minimum."
msgstr "该反复退让机制是的AiiDA内部引擎对于算例任务的稳健性提高，将临时问题发生所导致的计算资源浪费减少到最小。"

#: ../docs/source/concepts/calculations.rst:192
msgid ""
"The parameters, such as the delays between retries and the maximum number of"
" retries, are currently not configurable, but they might be in the future."
msgstr "当前有关该策略的设置参数如重试间隔延时和最大重试次数都不能够修改，但在未来可能会支持修改。"

#: ../docs/source/concepts/calculations.rst:197
msgid "Parsers"
msgstr "解析器"

#: ../docs/source/concepts/calculations.rst:198
msgid ""
"The previous section explained how the ``CalcJob`` class functions as an "
"interface between AiiDA's engine and an external piece of code. The "
"calculation job plugin will instruct the engine how the :ref:`transport "
"tasks<concepts_calcjobs_transport_tasks>` should be accomplished. However, "
"as mentioned before, those tasks stop after the output files have been "
"retrieved, which the engine will attach as a "
":py:class:`~aiida.orm.nodes.data.folder.FolderData` node with the label "
"``'retrieved'`` to the calculation job node. As far as the calculation job "
"goes that is all that is absolutely required. However, often one wants to "
"parse those output files into some specific outputs that should be "
"represented as individual nodes in the provenance graph. This can be "
"accomplished by implementing the :py:class:`~aiida.parsers.parser.Parser` "
"class and specifying it in the inputs of the calculation job. In that case, "
"the engine will call the parser after the output files created by the job "
"have been successfully retrieved. In the parser implementation, the "
"retrieved files can then be parsed and converted into output nodes. For "
"technical details on how to implement a parser for a calculation job and how"
" to specify it in the inputs, please refer to the :ref:`detailed parser "
"section<working_calcjobs_parsers>`,"
msgstr ""
"前面章节阐述了 ``CalcJob`` 类函数接口连接AiiDA引擎和外部运行代码。算例任务插件还会告知引擎 "
":ref:`传输任务<concepts_calcjobs_transport_tasks>` "
"该如何结束。如前所述，任务在输出文件获取后停止，这时引擎会在算例任务节点后增加标记为 ``retrieved`` 的 "
":py:class:`~aiida.orm.nodes.data.folder.FolderData`  "
"节点。这样算例任务就顺利完成了。然而用户通常还会想要将输出文件解析为特定的输出并表示为可验证性图中的节点。这可以通过 "
":py:class:`~aiida.parsers.parser.Parser` "
"类来实现并在算例任务的输入中指定。这样，引擎就会在任务成功结束并创建输出文件后调用解析器。解析器通过以下方式实现，在获取文件后解析并转换成输出节点。有关解析器的实现细节以及如何在算例任务输入中指定解析器，请参考"
" :ref:`解析器详情章节<working_calcjobs_parsers>` 。"

#: ../docs/source/concepts/processes.rst:8
msgid ""
"Anything that runs in AiiDA is an instance of the "
":py:class:`~aiida.engine.processes.process.Process` class. The ``Process`` "
"class contains all the information and logic to tell, whoever is handling "
"it, how to run it to completion. Typically the one responsible for running "
"the processes is an instance of a :py:class:`~aiida.engine.runners.Runner`. "
"This can be a local runner or one of the daemon runners in case of the "
"daemon running the process."
msgstr ""
"所有可以通过AiiDA运行的事件都是:py:class:`~aiida.engine.processes.process.Process` 类的实例。 "
"``Process`` 类包含了有关运行用户，运行方法，运行逻辑的所有信息。特别的，运行该例程的用户属于类 "
":py:class:`~aiida.engine.runners.Runner` 的实例。该运行者可以是本地用户，也可是守护进程的的持有者。"

#: ../docs/source/concepts/processes.rst:13
msgid ""
"In addition to those run instructions, any ``Process`` that has been "
"executed needs some sort of record in the database to store what happened "
"during its execution. For example it needs to record what its exact inputs "
"were, the log messages that were reported and what the final outputs were. "
"For this purpose, every process will utilize an instance of a sub class of "
"the :py:class:`~aiida.orm.nodes.process.ProcessNode` class. This "
"``ProcessNode`` class is a sub class of :py:class:`~aiida.orm.nodes.Node` "
"and serves as the record of the process' execution in the database and by "
"extension the provenance graph."
msgstr ""
"除了以上相关的运行信息，所有被运行的 ``Process`` 还需要在数据库中储存运行时所发生的事件。 "
"例如，它的真实输入是什么，运行时的日志信息是什么，或者最后的输出是什么等。为实现该目的，所有的例程都被设计成为  "
":py:class:`~aiida.orm.nodes.process.ProcessNode` 类的子类.  ``ProcessNode`` 类是 "
":py:class:`~aiida.orm.nodes.Node` 类的子类，并用于在数据库中记录例程的运行时信息以及在可验证性图中记录额外信息。"

#: ../docs/source/concepts/processes.rst:18
msgid ""
"It is very important to understand this division of labor. A ``Process`` "
"describes how something should be run, and the ``ProcessNode`` serves as a "
"mere record in the database of what actually happened during execution. A "
"good thing to remember is that while it is running, we are dealing with the "
"``Process`` and when it is finished we interact with the ``ProcessNode``."
msgstr ""
"其父类的分工是非常明确的。``Process`` 类描述了任务该如何运行，``ProcessNode`` "
"类则用于在数据库中记录当时间运行时真实发生的过程。也就是说当事件运行时用户面对``Process``类，而事件运行结束后使用``ProcessNode``"
" 进行交互。"

#: ../docs/source/concepts/processes.rst:25
msgid "Process types"
msgstr "例程类别"

#: ../docs/source/concepts/processes.rst:27
msgid "Processes in AiiDA come in two flavors:"
msgstr "AiiDA中的例程主要有以下两类："

#: ../docs/source/concepts/processes.rst:29
msgid "Calculation-like"
msgstr "算例类型"

#: ../docs/source/concepts/processes.rst:30
msgid "Workflow-like"
msgstr "工作流类型"

#: ../docs/source/concepts/processes.rst:32
msgid ""
"The calculation-like processes have the capability to *create* data, whereas"
" the workflow-like processes orchestrate other processes and have the "
"ability to *return* data produced by calculations. Again, this is a "
"distinction that plays a big role in AiiDA and is crucial to understand. For"
" this reason, these different types of processes also get a different sub "
"class of the ``ProcessNode`` class. The hierarchy of these node classes and "
"the link types that are allowed between them and ``Data`` nodes, is "
"explained in detail in the :ref:`provenance "
"implementation<concepts_provenance_implementation>` documentation."
msgstr ""
"算例类型的例程能够 *创建* 新的数据，而工作流类型的例程能够组合其他例程形成一个例程并 *返回* "
"由其中的算例例程创建的数据。这两者在AiiDA中扮演了重要的作用，因此有必要分清两者的区别。 因此这两个不同类型的例程是两种不同的 "
"``ProcessNode`` 的子类。这些节点的继承关系和它们与 ``Data`` 节点之间的连接类型将在章节 "
":ref:`可验证性图的实现<concepts_provenance_implementation>` 中详述。"

#: ../docs/source/concepts/processes.rst:37
msgid ""
"Currently, there are four types of processes in ``aiida-core`` and the "
"following table shows with which node class it is represented in the "
"provenance graph and what the process is used for."
msgstr "当前， ``aiida-core`` 中有如下表中四类例程，表中还展示了不同的例程表示在可验证性图中的具体节点类型和例程的具体使用场景。"

#: ../docs/source/concepts/processes.rst:40
msgid "Process class"
msgstr "Process 类"

#: ../docs/source/concepts/processes.rst:40
msgid "Node class"
msgstr "Node 类"

#: ../docs/source/concepts/processes.rst:40
msgid "Used for"
msgstr "使用场景"

#: ../docs/source/concepts/processes.rst:42
msgid ":py:class:`~aiida.engine.processes.calcjobs.calcjob.CalcJob`"
msgstr ":py:class:`~aiida.engine.processes.calcjobs.calcjob.CalcJob`"

#: ../docs/source/concepts/processes.rst:42
msgid ":py:class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode`"
msgstr ":py:class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode`"

#: ../docs/source/concepts/processes.rst:42
msgid "Calculations performed by external codes"
msgstr "外部软件代码执行的算例"

#: ../docs/source/concepts/processes.rst:43
msgid ":py:class:`~aiida.engine.processes.workchains.workchain.WorkChain`"
msgstr ":py:class:`~aiida.engine.processes.workchains.workchain.WorkChain`"

#: ../docs/source/concepts/processes.rst:43
msgid ":py:class:`~aiida.orm.nodes.process.workflow.workchain.WorkChainNode`"
msgstr ":py:class:`~aiida.orm.nodes.process.workflow.workchain.WorkChainNode`"

#: ../docs/source/concepts/processes.rst:43
msgid "Workflows that run multiple calculations"
msgstr "多个算例组成的工作流"

#: ../docs/source/concepts/processes.rst:44
#: ../docs/source/concepts/processes.rst:45
msgid ":py:class:`~aiida.engine.processes.functions.FunctionProcess`"
msgstr ":py:class:`~aiida.engine.processes.functions.FunctionProcess`"

#: ../docs/source/concepts/processes.rst:44
msgid ""
":py:class:`~aiida.orm.nodes.process.calculation.calcfunction.CalcFunctionNode`"
msgstr ""
":py:class:`~aiida.orm.nodes.process.calculation.calcfunction.CalcFunctionNode`"

#: ../docs/source/concepts/processes.rst:44
msgid "Python functions decorated with the ``@calcfunction`` decorator"
msgstr "``@calculation`` 装饰器装饰的python 函数"

#: ../docs/source/concepts/processes.rst:45
msgid ""
":py:class:`~aiida.orm.nodes.process.workflow.workfunction.WorkFunctionNode`"
msgstr ""
":py:class:`~aiida.orm.nodes.process.workflow.workfunction.WorkFunctionNode`"

#: ../docs/source/concepts/processes.rst:45
msgid "Python functions decorated with the ``@workfunction`` decorator"
msgstr "``@workfunction`` 装饰器装饰的python 函数"

#: ../docs/source/concepts/processes.rst:48
msgid ""
"For basic information on the concept of a ``CalcJob`` or ``calcfunction``, "
"refer to the :ref:`calculations concept<concepts_calculations>` and the same"
" for the ``WorkChain`` and ``workfunction`` is described in the "
":ref:`workflows concept<concepts_workflows>`. After having read and "
"understood the basic concept of calculation and workflow processes, detailed"
" information on how to implement and use them can be found in the dedicated "
"developing sections for :ref:`calculations<working_calculations>` and "
":ref:`workflows<working_workflows>`, respectively."
msgstr ""
"有关 ``CalcJob`` 和 ``calcfunction`` 的描述，请参考 "
":ref:`算例的概念<concepts_calculations>` ，有关 ``WorkChain`` 和 ``workfunction`` 请参考"
" :ref:`工作流的概念<concepts_workflows>` 。 关于它们的实现和使用等更加细致的讨论请分别参考 "
":ref:`算例<working_calculations>`  和 :ref:`工作流<working_workflows>` 。"

#: ../docs/source/concepts/processes.rst:51
msgid ""
"A ``FunctionProcess`` is never explicitly implemented but will be generated "
"dynamically by the engine when a python function decorated with a "
":py:func:`~aiida.engine.processes.functions.calcfunction` or "
":py:func:`~aiida.engine.processes.functions.workfunction` is run."
msgstr ""
"``FunctionProcess`` 不需要直接实现，而是通过在python函数前添加装饰器来动态的通过AiiDA引擎创建。比如创建 "
":py:func:`~aiida.engine.processes.functions.calcfunction`  "
":py:func:`~aiida.engine.processes.functions.workfunction` 。"

#: ../docs/source/concepts/processes.rst:57
msgid "Process state"
msgstr "例程的状态"

#: ../docs/source/concepts/processes.rst:58
msgid ""
"Each instance of a ``Process`` class that is being executed has a process "
"state. This property tells you about the current status of the process. It "
"is stored in the instance of the ``Process`` itself and the workflow engine,"
" the ``plumpy`` library, operates only on that value. However, the "
"``Process`` instance 'dies' as soon as it is terminated, therefore the "
"process state is also written to the calculation node that the process uses "
"as its database record, under the ``process_state`` attribute. The process "
"can be in one of six states:"
msgstr ""
"每个被执行的 ``Process`` 实例都有其不同时刻的状态。该性质告诉用户当前例程所处于的运行时状态。这个信息被储存在 ``Process`` "
"实例中或工作流引擎中，这些状态通过 ``plumpy`` 库来变换。然而当 ``Process`` "
"实例运行结束时他就‘死亡’了，因此我们这时还会将算例节点的状态信息按照 ``process_state`` 属性记录进数据库中。算例的状态有以下六种 :"

#: ../docs/source/concepts/processes.rst:65
msgid "*Active*"
msgstr "*Active*"

#: ../docs/source/concepts/processes.rst:65
msgid "*Terminated*"
msgstr "*Terminated*"

#: ../docs/source/concepts/processes.rst:67
msgid "Created"
msgstr "Created"

#: ../docs/source/concepts/processes.rst:67
msgid "Killed"
msgstr "Killed"

#: ../docs/source/concepts/processes.rst:68
msgid "Running"
msgstr "Running"

#: ../docs/source/concepts/processes.rst:68
msgid "Excepted"
msgstr "Excepted"

#: ../docs/source/concepts/processes.rst:69
msgid "Waiting"
msgstr "Waiting"

#: ../docs/source/concepts/processes.rst:69
msgid "Finished"
msgstr "Finished"

#: ../docs/source/concepts/processes.rst:72
msgid ""
"The three states in the left column are 'active' states, whereas the right "
"column displays the three 'terminal' states. Once a process reaches a "
"terminal state, it will never leave it; its execution is permanently "
"terminated. When a process is first created, it is put in the ``Created`` "
"state. As soon as it is picked up by a runner and it is active, it will be "
"in the ``Running`` state. If the process is waiting for another process, "
"that it called, to be finished, it will be in the ``Waiting`` state. If a "
"process is in the ``Killed`` state, it means the user issued a command to "
"kill it, or its parent process was killed. The ``Excepted`` state indicates "
"that during execution an exception occurred that was not caught and the "
"process was unexpectedly terminated. The final option is the ``Finished`` "
"state, which means that the process was successfully executed, and the "
"execution was nominal. Note that this does not automatically mean that the "
"result of the process can also be considered to be successful, it was just "
"executed without any problems."
msgstr ""
"左边列是三个‘激活’状态，右边列时三个‘结束’状态。一旦一个例程到达结束状态之一，其状态就会始终停留在那里。当例程被创建时，自动将其状态设置为 "
"``Created`` 状态。一旦其被运行器选中并处于激活的状态，它就被转向 ``Running`` "
"状态。如果一个例程等待其他的例程完成，也就是说，它等待完成时，它处于 ``Waiting`` 状态。 如果例程处于 ``Killed`` "
"状态，说明用户通过指令终止了它的运行，也可能时父例程终止了它的运行。 ``Excepted`` "
"状态则表示运行过程中抛出了没有捕获的异常，或例程没有如预期正常结束。 最后是 ``Finished`` "
"状态，该状态表示例程成功运行。注意，这个状态并不代表例程的运行结果是正确可靠的，它只是代表了运行顺利结束，没有出错。"

#: ../docs/source/concepts/processes.rst:82
msgid ""
"To distinguish between a successful and a failed execution, there is the "
":ref:`exit status<concepts_process_exit_codes>`. This is another attribute "
"that is stored in the node of the process and is an integer that can be set "
"by the process. A ``0`` (zero) means that the result of the process was "
"successful, and a non-zero value indicates a failure. All the process nodes "
"used by the various processes are sub-classes of "
":py:class:`~aiida.orm.nodes.process.ProcessNode`, which defines handy "
"properties to query the process state and exit status."
msgstr ""
"为了区分成功和失败的结束状态，AiiDA引擎使用 :ref:`退出状态（exit "
"status）<concepts_process_exit_codes>` 标签。这是一个储存在例程节点中的整型信息，可以被例程设置。 数值 ``0``"
" （零） 表示例程结果成功，非零表示例程失败。所有以上例程的节点类型都是 "
":py:class:`~aiida.orm.nodes.process.ProcessNode` 的子类，其定义了可用于查询例程当前状态和结束状态的属性"
" 。"

#: ../docs/source/concepts/processes.rst:88
msgid "Property"
msgstr "属性"

#: ../docs/source/concepts/processes.rst:88
msgid "Meaning"
msgstr "含义"

#: ../docs/source/concepts/processes.rst:90
msgid "``process_state``"
msgstr "``process_state``"

#: ../docs/source/concepts/processes.rst:90
msgid "Returns the current process state"
msgstr "返回当前例程状态"

#: ../docs/source/concepts/processes.rst:91
msgid "``exit_status``"
msgstr "``exit_status``"

#: ../docs/source/concepts/processes.rst:91
msgid "Returns the exit status, or None if not set"
msgstr "返回例程结束时的具体退出状态，如果没有设置则是 ``None``"

#: ../docs/source/concepts/processes.rst:92
msgid "``exit_message``"
msgstr "``exit_message``"

#: ../docs/source/concepts/processes.rst:92
msgid "Returns the exit message, or None if not set"
msgstr "返回退出信息，如果没有设置则为 ``None``"

#: ../docs/source/concepts/processes.rst:93
msgid "``is_terminated``"
msgstr "``is_terminated``"

#: ../docs/source/concepts/processes.rst:93
msgid ""
"Returns ``True`` if the process was either ``Killed``, ``Excepted``, or "
"``Finished``"
msgstr "如果例程是 ``Killed`` ， ``Excepted`` 或 ``Finished`` 状态之一，则返回 ``True``"

#: ../docs/source/concepts/processes.rst:94
msgid "``is_killed``"
msgstr "``is_killed``"

#: ../docs/source/concepts/processes.rst:94
msgid "Returns ``True`` if the process is ``Killed``"
msgstr "返回 ``True`` 如果例程的状态是 ``Killed``"

#: ../docs/source/concepts/processes.rst:95
msgid "``is_excepted``"
msgstr "``is_excepted``"

#: ../docs/source/concepts/processes.rst:95
msgid "Returns ``True`` if the process is ``Excepted``"
msgstr "返回 ``True`` 如果例程的状态是 ``Excepted``"

#: ../docs/source/concepts/processes.rst:96
msgid "``is_finished``"
msgstr "``is_finished``"

#: ../docs/source/concepts/processes.rst:96
msgid "Returns ``True`` if the process is ``Finished``"
msgstr "返回 ``True`` 如果例程的状态是 ``Finished``"

#: ../docs/source/concepts/processes.rst:97
msgid "``is_finished_ok``"
msgstr "``is_finished_ok``"

#: ../docs/source/concepts/processes.rst:97
msgid ""
"Returns ``True`` if the process is ``Finished`` and the ``exit_status`` is "
"equal to zero"
msgstr "返回 ``True`` 如果例程的状态是 ``Finished`` 且 ``exit_status`` 的值为 ``0`` (零)"

#: ../docs/source/concepts/processes.rst:98
msgid "``is_failed``"
msgstr "``is_failed``"

#: ../docs/source/concepts/processes.rst:98
msgid ""
"Returns ``True`` if the process is ``Finished`` and the ``exit_status`` is "
"non-zero"
msgstr "返回 ``True`` 如果例程的状态是 ``Finished`` 且 ``exit_status`` 的值非零"

#: ../docs/source/concepts/processes.rst:101
msgid ""
"When you load a calculation node from the database, you can use these "
"property methods to inquire about its state and exit status."
msgstr "当用户从数据库中加载这些算例节点，可以使用这些属性方法来查询算例的当前状态和退出状态。"

#: ../docs/source/concepts/processes.rst:107
msgid "Process exit codes"
msgstr "例程结束代码"

#: ../docs/source/concepts/processes.rst:108
msgid ""
"The previous section about the process state showed that a process that is "
"``Finished`` does not say anything about whether the result is 'successful' "
"or 'failed'. The ``Finished`` state means nothing more than that the engine "
"succeeded in running the process to the end of execution, without it "
"encountering exceptions or being killed. To distinguish between a "
"'successful' and 'failed' process, an 'exit status' can be defined. The "
"`exit status is a common concept in programming "
"<https://en.wikipedia.org/wiki/Exit_status>`_ and is a small integer, where "
"zero means that the result of the process was successful, and a non-zero "
"value indicates a failure. By default a process that terminates nominally "
"will get a ``0`` (zero) exit status. To mark a process as failed, one can "
"return an instance of the "
":py:class:`~aiida.engine.processes.exit_code.ExitCode` named tuple, which "
"allows to set an integer ``exit_status`` and a string message as "
"``exit_message``. When the engine receives such an ``ExitCode`` as the "
"return value from a process, it will set the exit status and message on the "
"corresponding attributes of the process node representing the process in the"
" provenance graph. How exit codes can be defined and returned depends on the"
" process type and will be documented in detail in the respective "
":ref:`calculation<working_calculations>` and "
":ref:`workflow<working_workflows>` development sections."
msgstr ""
"上面章节提到，例程的状态为 ``Finished`` 并不代表任务的结果是正确的。``Finished`` "
"状态仅仅表示例程运行到结束时没有碰到异常或被杀死。要区分例程的成功和失败的状态，需要用到‘结束状态’ （exit status） 。 "
"在软件编程中结束状态<https://en.wikipedia.org/wiki/Exit_status>`_是一个普遍的概念，它是一个整数，``0``"
" （零）表示正常结束，非零表示出错。 为标记例程运行出错，用户通过返回类型为 "
":py:class:`~aiida.engine.processes.exit_code.ExitCode` 的命名元组(named tuple) "
"来表示，该元组整数元素表示结束状态，字符串信息 ``exit_message`` 描述错误原因。当AiiDA引擎从例程接收到 ``ExitCode`` "
"，它会将该例程节点设置上结束码和结束信息，用以产生可验证性图。 关于结束码如何定义和返回，其详细信息参考 "
":ref:`算例<working_calculations>` 和 :ref:`工作流<working_workflows>` 开发章节."

#: ../docs/source/concepts/processes.rst:121
msgid "Process lifetime"
msgstr "例程运行的生命周期"

#: ../docs/source/concepts/processes.rst:123
msgid ""
"The lifetime of a process is defined as the time from the moment it is "
"launched until it reaches a :ref:`terminal state<concepts_process_state>`."
msgstr "例程的生命周期被定义为从例程启动的时刻到它到达 :ref:`终止状态<concepts_process_state>` 的时刻。"

#: ../docs/source/concepts/processes.rst:128
msgid "Process and node distinction"
msgstr "例程和其节点的区别"

#: ../docs/source/concepts/processes.rst:129
msgid ""
"As explained in the :ref:`introduction of this section<concepts_processes>`,"
" there is a clear and important distinction between the 'process' and the "
"'node' that represents its execution in the provenance graph. When a process"
" is launched, an instance of the ``Process`` class is created in memory "
"which will be propagated to completion by the responsible runner. This "
"'process' instance only exists in the memory of the python interpreter that "
"it is running in, for example that of a daemon runner, and so we cannot "
"directly inspect its state. That is why the process will write any of its "
"state changes to the corresponding node representing it in the provenance "
"graph. In this way, the node acts as a 'proxy' or a mirror image that "
"reflects the state of the process in memory. This means that the output of "
"many of the ``verdi`` commands, such as ``verdi process list``, do not "
"actually show the state of the process instances, but rather the state of "
"the node to which they have last written their state."
msgstr ""
"如本章节 :ref:`引言<concepts_processes>` 所描述的， '例程' 及其在可验证性图中表示运行状态的节点 '例程节点' "
"之间有明确的区别。当例程启动，内存中会创建一个 ``Process`` "
"的实例并将其传入对应的运行器等待其完成。该例程实例只存在其运行的与python解释器中。比如对于一个运行着的守护进程，我们不能够直接获取其状态。这就是为什么例程需要将其当前状态写入可验证性图中的原因。"
" 通过这种方式，节点充当了表示例程内存中状态的一个‘代理’或镜像。这表明大部分 ``verdi`` 指令如 ``verdi process list``"
" 中输出的并非例程的真实状态，而是其刚刚写入节点中的状态。"

#: ../docs/source/concepts/processes.rst:137
msgid "Process tasks"
msgstr "例程任务"

#: ../docs/source/concepts/processes.rst:138
msgid ""
"The previous section explained how launching a process means creating an "
"instance of the ``Process`` class in memory. When the process is being 'ran'"
" (see the section on :ref:`launching processes<working_processes_launch>` "
"for more details) that is to say in a local interpreter, the particular "
"process instance will die as soon as the interpreter dies. This is what "
"often makes 'submitting' the preferred method of launching a process. When a"
" process is 'submitted', an instance of the ``Process`` is created, along "
"with the node that represents it in the database, and its state is then "
"persisted to the database. This is called a 'process checkpoint', more "
"information on which :ref:`will follow later<concepts_process_checkpoints>`."
" Subsequently, the process instance is shutdown and a 'continuation task' is"
" sent to the process queue of RabbitMQ. This task is simply a small message "
"that just contains an identifier for the process."
msgstr ""
"前面章节解释了启动一个例程（process）就是在内存中创建一个 ``Process`` 类的实例。 当例程被‘运行’(详情参见章节 "
":ref:`启动例程<working_processes_launch>` )，也就是在本地解释器中，例程实例将会随着解释器的终止而终止。 这使得通过 "
"'提交（submit）' 的方式来开启一个例程成为更推荐的启动方式。当一个例程被提交（submitting），内存中同时创建了一个 "
"``Process`` 的实例，同样，在数据库中创建一个持久的例程节点来代表这个例程。这个实例及其节点被称作例程检查点，有关检查点的更多信息请参考 "
":ref:`检查点<concepts_process_checkpoints>` 。 紧接着算例 实例被关闭且一个 'continuation "
"task' 被发送到 RabbitMQ的算例队列。 该任务是一个包含算例特征信息的一个信息。"

#: ../docs/source/concepts/processes.rst:146
msgid ""
"All the daemon runners, when they are launched, subscribe to the process "
"queue and RabbitMQ will distribute the continuation tasks to them as they "
"come in, making sure that each task is only sent to one runner at a time. "
"The receiving daemon runner can restore the process instance in memory from "
"the checkpoint that was stored in the database and continue the execution. "
"As soon as the process reaches a terminal state, the daemon runner will "
"acknowledge to RabbitMQ that the task has been completed. Until the runner "
"has confirmed that a task is completed, RabbitMQ will consider the task as "
"incomplete. If a daemon runner is shutdown or dies before it got the chance "
"to finish running a process, the task will automatically be requeued by "
"RabbitMQ and sent to another daemon runner. Together with the fact that all "
"the tasks in the process queue are persisted to disk by RabbitMQ, guarantees"
" that once a continuation task has been sent to RabbitMQ, it will at some "
"point be finished, while allowing the machine to be shutdown."
msgstr ""
"当所有的运行器守护进程运行时，会产生一个例程队列（process "
"queue），RabbitMQ会将可继续任务负载均衡的分配到运行器中，且保证每次向一个运行器发送一个任务。运行器守护进程可以向内存中从数据库以持续任务的形式加载例程实例的检查点。一旦例程达到终止状态，守护进程消息处理者会通知RabbitMQ该任务成功完成。如果运行器守护进程在结束一个运行的例程之前被关闭或异常退出，任务会被自动重新发送到RabbitMQ中。所有的任务都在通过RabbitMQ的例程队列中持久保留在硬盘上，这保证了当一个持久任务被发送到RabbitMQ时，机器可以关闭和重启。"

#: ../docs/source/concepts/processes.rst:153
msgid ""
"Each daemon runner has a maximum number of tasks that it can run "
"concurrently, which means that if there are more active tasks than available"
" slots, some of the tasks will remain queued. Processes, whose task is in "
"the queue and not with any runner, though technically 'active' as they are "
"not terminated, are not actually being run at the moment. While a process is"
" not actually being run, i.e. it is not in memory with a runner, one cannot "
"interact with it. Similarly, as soon as the task disappears, either because "
"the process was intentionally terminated (or unintentionally), the process "
"will never continue running again."
msgstr ""
"每一个运行器守护进程有一个可并发任务数上限，该上限约束了同时可运行的任务数量，当一些任务运行时，其他任务处于队列中等待被执行。当一个例程的实际任务处于等待被执行的队列中时，尽管它的状态时"
" activate "
"且没有终止，它也没有被实际运行。这时，因为例程并没有被实际运行，也就是在内存中并没有一个运行器运行它，用户这时不能与其交互。同样的，当例程中的任务退出（有意或无意的），这个例程将不会继续运行。"

#: ../docs/source/concepts/processes.rst:162
msgid "Process checkpoints"
msgstr "例程检查点"

#: ../docs/source/concepts/processes.rst:163
msgid ""
"A process checkpoint is a complete representation of a ``Process`` instance "
"in memory that can be stored in the database. Since it is a complete "
"representation, the ``Process`` instance can also be fully reconstructed "
"from such a checkpoint. At any state transition of a process, a checkpoint "
"will be created, by serializing the process instance and storing it as an "
"attribute on the corresponding process node. This mechanism is the final cog"
" in the machine, together with the persisted process queue of RabbitMQ as "
"explained in the previous section, that allows processes to continue after "
"the machine they were running on, has been shutdown and restarted."
msgstr ""
"例程检查点是 ``Process`` 实例在内存中的完整表示，可以被储存在数据库中。因为它是一个完整表示，因此 ``Process`` "
"实例可以从该检查点重新创建。在任何例程发生状态转移时都会通过记录完整的例程的各种属性和信息创建一个检查点。这个机制用来使机器能够通过上面章节提到的RabbitMQ持久队列来记录例程，从而允许例程在机器关闭和重启后可以继续执行。"

#: ../docs/source/concepts/processes.rst:172
msgid "Process sealing"
msgstr ""

#: ../docs/source/concepts/processes.rst:173
msgid ""
"One of the cardinal rules of AiiDA is that once a node is *stored*, it is "
"immutable, which means that its attributes can no longer be changed. This "
"rule is a problem for processes, however, since in order to be able to start"
" running it, its corresponding process node first has to be stored. However,"
" at that point its attributes, such as the process state or other mutable "
"attributes, can no longer be changed by the engine throughout the lifetime "
"of the corresponding process. To overcome this limitation, the concept of "
"*updatable* attributes is introduced. These are special attributes that are "
"allowed to be changed *even* when the process node is already stored *and* "
"the corresponding process is still active. To mark the point where a process"
" is terminated and even the updatable attributes on the process node are to "
"be considered immutable, the node is *sealed*. A sealed process node behaves"
" exactly like a normal stored node, as in *all* of its attributes are "
"immutable. In addition, once a process node is sealed, no more incoming or "
"outgoing links can be attached to it. Unsealed process nodes can also not be"
" exported, because they belong to processes that are still active. Note that"
" the sealing concept does not apply to data nodes and they are exportable as"
" soon as they are stored. To determine whether a process node is sealed, one"
" can use the property :py:meth:`~aiida.orm.utils.mixins.Sealable.is_sealed`."
msgstr ""

#: ../docs/source/concepts/provenance.rst:4
msgid "Graph concept"
msgstr "可验证性图概念"

#: ../docs/source/concepts/provenance.rst:7
msgid "Nodes and links"
msgstr "节点和连接"

#: ../docs/source/concepts/provenance.rst:9
msgid ""
"The two most important concepts in AiiDA are **data** and **processes**. The"
" former are pieces of data, such as a simple integer or float, all the way "
"to more complex data concepts such as a dictionary of parameters, a folder "
"of files or a crystal structure. Processes operate on this data in order to "
"produce new data."
msgstr ""
"在AiiDA **数据** 和 **例程** "
"是两个最为重要的概念。前者不仅代表了简单的数据结构如整型浮点型，还代表了更为复杂的数据结构如参数字典或文件的文件夹信息或者晶体结构数据。例程则能作用于这些数据并产生新的数据。"

#: ../docs/source/concepts/provenance.rst:13
msgid "Processes come in two different forms:"
msgstr "例程（process）有两种形式："

#: ../docs/source/concepts/provenance.rst:15
msgid ""
"**Calculations** are processes that are able to **create** new data. This is"
" the case, for instance, for externals simulation codes, that generate new "
"data"
msgstr "**算例（Calculations）** 是能够 **产生** 新的数据的的例程，比如，使用外部代码，该类型例程能够产生新的结果数据"

#: ../docs/source/concepts/provenance.rst:16
msgid ""
"**Workflows** are processes that **orchestrate** other workflows and "
"calculations, i.e. they manage the logical flow, being able to **call** "
"other processes. Workflows have data inputs, but cannot generate new data. "
"They can only return data that is already in the database (one typical case "
"is to return data created by a calculation they called)."
msgstr ""
"**工作流（Workflows）** "
"是**组合**了其他工作流或者其他算例的i例程，它是能够以逻辑流方式组合并调用其他例程的例程。工作流有数据输入，但不能够产生新的数据输出，它只能够返回已经储存在数据库中的数据（典型的情况是调用算例型例程并返回由其创建的数据）。"
" "

#: ../docs/source/concepts/provenance.rst:18
msgid ""
"Data and processes are represented in the AiiDA provenance graph as the "
"**nodes** of that graph. The graph edges are referred to as **links** and "
"come in different forms:"
msgstr "数据和例程在AiiDA的可验证性图中以 **节点** 的形式表示。图中的边被称作 **连接** ，有以下几种形式 :"

#: ../docs/source/concepts/provenance.rst:21
msgid ""
"**input** links: connect data nodes to the process nodes that used them as "
"input, both calculations and workflows"
msgstr "**输入(input)** 连接 : 从数据节点连接到例程节点，数据节点作为例程节点的输入，算例和工作流均支持该连接"

#: ../docs/source/concepts/provenance.rst:22
msgid ""
"**create** links: connect calculation nodes to the data nodes that they "
"created"
msgstr "**创建(create)** 连接: 从算例节点连接到数据节点，来表示其创建的数据来源"

#: ../docs/source/concepts/provenance.rst:23
msgid ""
"**return** links: connect workflow nodes to the data nodes that they "
"returned"
msgstr "**返回(return)** 连接: 从工作流节点连接到数据节点，表示工作流返回的数据"

#: ../docs/source/concepts/provenance.rst:24
msgid ""
"**call** links: connecting workflow nodes to the process nodes that they "
"directly called, be it calculations or workflows"
msgstr ""
"**调用(call)** 连接: "
"从工作流节点连接到例程节点用以表示工作流调用的例程，调用的例程可以是算例(calculations)也可是工作流(workflows)"

#: ../docs/source/concepts/provenance.rst:26
msgid ""
"Note that the **create** and **return** links are often collectively "
"referred to as **output** links."
msgstr "**创建(create)** 和 **返回(return)** 连接通常统称为 **输出(output)** 连接。"

#: ../docs/source/concepts/provenance.rst:30
msgid "Data provenance and logical provenance"
msgstr "数据可验证性和逻辑可验证性"

#: ../docs/source/concepts/provenance.rst:32
msgid ""
"AiiDA automatically stores entities in its database and links them forming a"
" **directed graph**. This directed graph automatically tracks the "
"**provenance** of all data produced by calculations or returned by "
"workflows. By tracking the provenance in this way, one can always fully "
"retrace how a particular piece of data came into existence, thus ensuring "
"its reproducibility."
msgstr ""
"AiiDA自动将流程实体储存在数据库中，并将实体连接成为有向图。有向图自动跟踪了数据如何从算例产生或从工作流中返回。通过跟踪数据的流向，用户总是可以清楚的回溯特定的数据是如何产生的，这保证了该数据的可重复性。"

#: ../docs/source/concepts/provenance.rst:36
msgid "In particular, we define two types of provenance:"
msgstr "特别的，我们定义了两种类型的可验证性："

#: ../docs/source/concepts/provenance.rst:38
msgid ""
"The **data provenance**, consisting of the part of the graph that *only* "
"consists of data and calculations (i.e. without considering workflows), and "
"only the **input** and **create** links that connect them. The data "
"provenance records the full history of how data has been generated. Due to "
"the causality principle, the data provenance part of the graph is a "
"**directed acyclic graph** (DAG), i.e. its nodes are connected by directed "
"edges and it does not contain any cycles."
msgstr ""
"其一为 **数据可验证性(data provenance)** ，考察图中只包含数据和算例的部分（不包含工作流），以及考察只有 "
"**输入(input)** 和 **创建(create)** "
"连接的部分。数据可验证性记录了关于该数据如何产生的整个完整流程。根据因果关系，数据的可验证性部分在图中是一个有向无环图 **directed "
"acyclic graph** (DAG)，也就是说节点和节点之间直接通过有向边连接，且图中没有环。"

#: ../docs/source/concepts/provenance.rst:39
msgid ""
"The **logical provenance** which consists of workflow and data nodes, "
"together with the **input**, **return** and **call** links that connect "
"them. The logical provenance is *not* acyclic, e.g. a workflow that acts as "
"a filter can return one of its own inputs, directly introducing a cycle."
msgstr ""
"**逻辑可验证性(logical provenance)** 是图中只包含工作流和数据节点的部分，包含了 **输入** , **返回** , 和 "
"**调用** 连接。逻辑可验证性部分是有环图，比如一个表示过滤器的工作流会返回它自身，这自动导致在图中引入了环。"

#: ../docs/source/concepts/provenance.rst:41
msgid ""
"The data provenance is essentially a log of which calculation generated what"
" data using certain inputs. The data provenance alone already guarantees "
"reproducibility (one could run again one by one the calculations with the "
"provided input and would obtain the same outputs). The logical provenance "
"gives additional information on why a specific calculation was run. Imagine "
"the case in which you start from 100 structures, you have a filter operation"
" that picks one, and then you run a simulation on it. The data provenance "
"only shows the simulation you run on the structure that was picked, while "
"the logical provenance can also show that the specific structure was not "
"picked at random but via a specific workflow logic."
msgstr ""
"数据可验证性就是有关算例如何用特定输入产生数据的日志信息。单纯的数据可验证性就已经保证了流程的可重复性（用户可以使用算例的输入来产生完全相同的输出结果）。而逻辑可验证性提供了关于如何运行一个特定的算例的附加信息。想象这样一个情景，开始时你有100个晶体结构，你需要以一定条件筛选出一个，然后将其加入模拟。数据可验证性仅仅表示了你如何对选出的结构进行计算模拟，而逻辑可验证性添加了关于如何筛选该晶体构型的信息，因为该构型不是随机挑选，而是通过一定的工作逻辑和条件筛选得到。"

#: ../docs/source/concepts/provenance.rst:48
msgid "Other entities"
msgstr "其他实体"

#: ../docs/source/concepts/provenance.rst:50
msgid ""
"Beside nodes (data and processes), AiiDA defines a few more entities, like a"
" :py:class:`~aiida.orm.computers.Computer` (representing a computer, "
"supercomputer or computer cluster where calculations are run or data is "
"stored), a :py:class:`~aiida.orm.groups.Group` (that group nodes together "
"for organizational purposes) and the :py:class:`~aiida.orm.users.User` (to "
"keep track of the user who first generated a given node, computer or group)."
msgstr ""
"除了上述节点（数据和例程），AiiDA还定义了一些其他相关实体比如  :py:class:`~aiida.orm.computers.Computer`"
" （表示执行运算或储存数据的计算机，超算或者集群）， :py:class:`~aiida.orm.groups.Group` "
"（用于组织数据的节点类型），和  :py:class:`~aiida.orm.users.User` "
"（跟踪数据等节点的创建者，或组和用户节点的拥有者）。"

#: ../docs/source/concepts/provenance.rst:52
msgid ""
"In the following section we describe in more detail how the general "
"provenance concepts above are actually implemented in AiiDA, with specific "
"reference to the python classes that implement them and the class-"
"inheritance relationships."
msgstr "下列章节我们更加详细讲解上述提到的可验证性的概念在AiiDA中如何通过引用和继承特定的python类型来实现的。"

#: ../docs/source/concepts/provenance.rst:57
#: ../docs/source/concepts/workflows.rst:119
msgid "Implementation"
msgstr "实现"

#: ../docs/source/concepts/provenance.rst:60
msgid "Graph nodes"
msgstr "图的节点"

#: ../docs/source/concepts/provenance.rst:62
msgid ""
"The **nodes** of the AiiDA provenance graph can be grouped into two main "
"**types**: **process nodes** (``ProcessNode``), that represent the execution"
" of calculations or workflows, and **data nodes** (``Data``), that represent"
" pieces of data."
msgstr ""
"AiiDA可验证图中的 **节点** 可以分类两大类：第一类是表示例程执行的 **例程节点** ( ``ProcessNode`` )， 和表示数据的 "
"**数据节点**( ``Data`` )。"

#: ../docs/source/concepts/provenance.rst:64
msgid "In particular, **process nodes** are divided into two sub categories:"
msgstr "**例程节点** 被细分为两个小类："

#: ../docs/source/concepts/provenance.rst:66
msgid ""
"**calculation nodes** (``CalculationNode``): Represent code execution that "
"creates new data. These are further subdivided in two subclasses:"
msgstr "**算例节点** ( ``CalculationNode`` )： 用以表示创建数据的和储存用来运行的代码的信息。又被分为两个小类："

#: ../docs/source/concepts/provenance.rst:68
msgid ""
":py:class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode`: "
"Represents the execution of a calculation external to AiiDA, typically via a"
" job batch scheduler (see the concept of :ref:`calculation "
"jobs<concepts_calcjobs>`)."
msgstr ""
":py:class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode`: "
"通过作业调度系统来执行AiiDA以外的软件的例程节点 (参考 :ref:`算例任务<concepts_calcjobs>`)."

#: ../docs/source/concepts/provenance.rst:69
msgid ""
":py:class:`~aiida.orm.nodes.process.calculation.calcfunction.CalcFunctionNode`:"
" Represents the execution of a python function (see the concept of "
":ref:`calculation functions<concepts_calcfunctions>`)."
msgstr ""
":py:class:`~aiida.orm.nodes.process.calculation.calcfunction.CalcFunctionNode`:"
" 表示执行python函数的例程的节点 (参考 :ref:`算例函数<concepts_calcfunctions>` )."

#: ../docs/source/concepts/provenance.rst:71
msgid ""
"**workflow nodes** (``WorkflowNode``): Represent python code that "
"orchestrates the execution of other workflows and calculations, that "
"optionally return the data created by the processes they called. These are "
"further subdivided in two subclasses:"
msgstr ""
"**工作流节点** (``WorkflowNode``) "
":表示了则和其他工作流或其他算例的一段python代码所代表的节点，该节点可以返回由其中调用的例程创建的数据。其又被细分为两个小类 :"

#: ../docs/source/concepts/provenance.rst:73
msgid ""
":py:class:`~aiida.orm.nodes.process.workflow.workchain.WorkChainNode`: "
"Represents the execution of a python class instance with built-in "
"checkpoints, such that the process may be paused/stopped/resumed (see the "
"concept of :ref:`work chains<concepts_workchains>`)."
msgstr ""
":py:class:`~aiida.orm.nodes.process.workflow.workchain.WorkChainNode`: "
"用以表示含有内置检查点可同例程执行的python类的实例，因此它可以暂停/停止/重载 (参见 "
":ref:`工作链<concepts_workchains>` 这一概念)."

#: ../docs/source/concepts/provenance.rst:74
msgid ""
":py:class:`~aiida.orm.nodes.process.workflow.workfunction.WorkFunctionNode`:"
" Represents the execution of a python function calling other processes (see "
"the concept of :ref:`work functions<concepts_workfunctions>`)."
msgstr ""
":py:class:`~aiida.orm.nodes.process.workflow.workfunction.WorkFunctionNode`:"
" 表示了可以调用其他例程的python函数的例程 (参考 :ref:`工作函数<concepts_workfunctions>`)."

#: ../docs/source/concepts/provenance.rst:76
msgid "The class hierarchy of the process nodes is shown in the figure below."
msgstr "上述例程节点类的继承关系如下图所示。"

#: ../docs/source/concepts/provenance.rst:81
msgid ""
"The hierarchy of the ORM classes for the process nodes. Only instances of "
"the lowest level of classes will actually enter into the provenance graph. "
"The two upper levels have a mostly taxonomical purpose as they allow us to "
"refer to multiple classes at once when reasoning about the graph as well as "
"a place to define common functionality (see section on :ref:`processes "
"<concepts_processes>`)."
msgstr ""
"例程节点ORM类的继承关系。只有最下层的类会实际写入可验证性图中。上面两层的父类只要用于分类不同的例程节点，使得在开发中能够更容易的定义不同的节点名，为不同的节点指定通用的方法（详情参考"
" :ref:`例程`<concepts_processes>）."

#: ../docs/source/concepts/provenance.rst:84
msgid ""
"For what concerns data nodes, the base class (``Data``) is subclassed to "
"provide functionalities specific to the data type and python methods to "
"operate on it. Often, the name of the subclass contains the word “Data” "
"appended to it, but this is not a requirement. A few examples:"
msgstr ""
"对于数据节点，基础的数据类 ``Data`` "
"被继承为能够提供数据操作和数据储存方式的子类。通常，这些子类的命名需要包含”Data“作为后缀，但这并非必须的，比如："

#: ../docs/source/concepts/provenance.rst:87
msgid ""
":py:class:`~aiida.orm.nodes.data.float.Float`, "
":py:class:`~aiida.orm.nodes.data.int.Int`, "
":py:class:`~aiida.orm.nodes.data.bool.Bool`, "
":py:class:`~aiida.orm.nodes.data.str.Str`, "
":py:class:`~aiida.orm.nodes.data.list.List`, ..."
msgstr ""
":py:class:`~aiida.orm.nodes.data.float.Float`, "
":py:class:`~aiida.orm.nodes.data.int.Int`, "
":py:class:`~aiida.orm.nodes.data.bool.Bool`, "
":py:class:`~aiida.orm.nodes.data.str.Str`, "
":py:class:`~aiida.orm.nodes.data.list.List`, ..."

#: ../docs/source/concepts/provenance.rst:88
msgid ""
":py:class:`~aiida.orm.nodes.data.dict.Dict`: represents a dictionary of key-"
"value pairs - these are parameters of a general nature that do not need to "
"belong to more specific data sub-classes"
msgstr ""
":py:class:`~aiida.orm.nodes.data.dict.Dict`: "
"表示字典型的键值对，这些都是基础类型，并不需要被继承为其他的子类来使用"

#: ../docs/source/concepts/provenance.rst:89
msgid ""
":py:class:`~aiida.orm.nodes.data.structure.StructureData`: represents "
"crystal structure data (containing chemical symbols, atomic positions of the"
" atoms, periodic cell for periodic structures, …)"
msgstr ""
":py:class:`~aiida.orm.nodes.data.structure.StructureData`:  "
"用以表示i晶体的结构数据（包含有元素符号，原子位置，对于周期性体系还有晶胞信息等）"

#: ../docs/source/concepts/provenance.rst:90
msgid ""
":py:class:`~aiida.orm.nodes.data.array.array.ArrayData`: represents generic "
"numerical arrays of data (python numpy arrays)"
msgstr ""
":py:class:`~aiida.orm.nodes.data.array.array.ArrayData`: "
"用以表示常规的数值数组（也就是python中的numpy数组）"

#: ../docs/source/concepts/provenance.rst:91
msgid ""
":py:class:`~aiida.orm.nodes.data.array.kpoints.KpointsData`: represents a "
"numerical array of k-points data, is a sub-class of ``ArrayData``"
msgstr ""
":py:class:`~aiida.orm.nodes.data.array.kpoints.KpointsData`: 用以表示k点数据的数组，是 "
"``ArrayData`` 的子类"

#: ../docs/source/concepts/provenance.rst:93
msgid "For more detailed information see :ref:`AiiDA data types <DataTypes>`."
msgstr "更多相关信息请参考 :ref:`AiiDA 数据类型 <DataTypes>` 。"

#: ../docs/source/concepts/provenance.rst:95
msgid ""
"In the next section we introduce the links between nodes, creating the AiiDA"
" graph, and then we show some examples to clarify what we introduced up to "
"now."
msgstr "接下来的章节，我们将介绍连接节点的连接，这样就创建了完整的AiiDA可验证性图，在往后，我们给出一些上述内容的例子。"

#: ../docs/source/concepts/provenance.rst:98
msgid "Graph links"
msgstr "图的连接"

#: ../docs/source/concepts/provenance.rst:100
msgid ""
"Process nodes are connected to their input and output data nodes through "
"directed links. Calculation processes can *create* data, while workflow "
"processes can *call* calculations and *return* their outputs. Consider the "
"following graph example, where we represent **data nodes** with circles, "
"**calculation nodes** with squares and **workflow nodes** with diamond "
"shapes."
msgstr ""
"例程节点与输入输出数据节点之间通过有向边连接。算例例程（calculation process）可以 *创建* 数据，而工作流例程（workflow "
"process）只能调用例程并返回其创建的输出。请看以下图作为例子，我们将 **数据节点** 用圈来表示，**算例节点** 用正方形来表示 "
"**工作流节点** 使用菱形表示。"

#: ../docs/source/concepts/provenance.rst:107
msgid ""
"Simple provenance graph for a workflow (W\\ :sub:`1`) *calling* a "
"calculation (C\\ :sub:`1`). The workflow takes a single **data node** (D\\ "
":sub:`1`\\) as input, and passes it to the calculation when *calling* it. "
"The calculation *creates* a new **data node** (D\\ :sub:`2`\\) that is also "
"*returned* by the **workflow node**."
msgstr ""
"一个工作流的简单可验证性图 (W\\ :sub:`1`) *调用* 算例 (C\\ :sub:`1`。 该工作流将一个 **数据节点** (D\\ "
":sub:`1`\\) 作为输入，当算例调用时将其传入算例。该算例 **创建** 了一个新的 **数据节点**  (D\\ :sub:`2`\\) "
"该节点被 **工作流节点** *返回* 。"

#: ../docs/source/concepts/provenance.rst:109
msgid ""
"Notice that the different style and names for the two links coming into D\\ "
":sub:`2` is intentional, because it was the calculation that *created* the "
"new data, whereas the workflow merely *returned* it. This subtle distinction"
" has big consequences. By allowing workflow processes to *return* data, it "
"can also *return* data that was among its inputs."
msgstr ""
"注意这里用不同类型的线段和命名区别两种到达 D\\ :sub:`2` 上的有向连接是有意的。因为算例 *创建* "
"了新的数据，而工作流仅仅只是返回了数据。这个潜在的区别有重要的意义。因为工作流流程能够 *返回* 数据，它同样能够 *返回* 它的输入。"

#: ../docs/source/concepts/provenance.rst:116
msgid ""
"Provenance graph example of a **workflow node** that receives three **data "
"nodes** as input and *returns* one of those inputs. The input link from D\\ "
":sub:`3` to W\\ :sub:`1` and the return link from W\\ :sub:`1` to D\\ "
":sub:`3` introduce a cycle in the graph."
msgstr ""
"**工作流节点** 的可验证性图例中有三个 **数据节点** 作为输入，并*返回* 了其中一个输入。从输入 D\\ :sub:`3` 到 W\\ "
":sub:`1` 的输入连接和从 W\\ :sub:`1` 到 D\\ :sub:`3` 的返回连接使得图形成了环。"

#: ../docs/source/concepts/provenance.rst:118
msgid ""
"A scenario like this, represented in :numref:`fig_provenance_cycle`, would "
"create a cycle in the provenance graph, breaking the “acyclicity” of the "
"DAG. To restore the directed acyclic graph, we separate the entire "
"provenance graph into two planes as described above: the **data provenance**"
" and the **logical provenance**. With this division, the acyclicity of the "
"graph is restored in the data provenance plane."
msgstr ""
"图中所示的情景 :numref:`fig_provenance_cycle` "
"在可验证性图中引入了环，打破了DAG有向无环的特征。为了还能够储存有向无环图 （DAG）我们将整个图分割成两个部分: **数据可验证性** 和 "
"**逻辑可验证性** 。 按照这种约定，无环图被保存在数据可验证性部分。"

#: ../docs/source/concepts/provenance.rst:122
msgid ""
"An additional benefit of thinking of the provenance graph in these two "
"planes, is that it allows you to inspect it with different layers of "
"granularity. Imagine a high level workflow that calls a large number of "
"calculations and sub-workflows, that each may also call more sub-processes, "
"to finally produce and return one or more data nodes as its result."
msgstr ""
"另外一个将可验证图分成这样两个部分的好处是，对于一个复杂的工作流，用户可以以不同的粒度来查看不同的部分。比有一个高度聚合的工作流，它调用了非常多的算例和子工作流，子工作流有可能调用许多的子流程，这些子流程返回一个或多个数据节点作为其结果，"

#: ../docs/source/concepts/provenance.rst:127
msgid "Graph examples"
msgstr "可验证图的例子"

#: ../docs/source/concepts/provenance.rst:129
msgid ""
"With these basic definitions of AiiDA’s provenance graph in place, let’s "
"take a look at some examples. Consider the sequence of computations that "
"adds two numbers `x` and `y`, and then multiplies the result with a third "
"number `z`. This sequence as represented in the provenance graph would look "
"something like what is shown in :numref:`fig_provenance_add_multiply_data`."
msgstr ""
"通过以上对AiiDA可验证性图的基础定义，我们来看以下例子。考虑这样一系列运算，首先将 两个数 `x` 和 `y` 相加，在将结果成上第三个数 `z` "
"。这个运算过程表示成可验证性图如下图所示 :numref:`fig_provenance_add_multiply_data` 。"

#: ../docs/source/concepts/provenance.rst:136
msgid ""
"The DAG for computing `(x+y)*z`. We have two simple calculations: C\\ "
":sub:`1` represents the addition and C\\ :sub:`2` the multiplication. The "
"two data nodes D\\ :sub:`1` and D\\ :sub:`2` are the inputs of C\\ :sub:`1`,"
" which *creates* the data node D\\ :sub:`4`\\. Together with D\\ :sub:`3`, "
"D\\ :sub:`4` then forms the input of C\\ :sub:`2`, which multiplies their "
"values that *creates* the product, represented by D\\ :sub:`5`."
msgstr ""
"DAG 计算 `(x+y)*z`. 我们有两个简单的算例： C\\ :sub:`1` 表示求和而 C\\ :sub:`2` 表示乘法运算。两个数据节点 "
"D\\ :sub:`1` 和 D\\ :sub:`2` 是 C\\ :sub:`1` 的输入，它会 *创建* 数据节点 D\\ :sub:`4`\\ 。"
" 与数据节点 D\\ :sub:`3` 进行运算， D\\ :sub:`4` 成为算例 C\\ :sub:`2` 的输入，两者相乘并 *创建* "
"乘积，表示为 D\\ :sub:`5` 数据节点。"

#: ../docs/source/concepts/provenance.rst:140
msgid ""
"In this simple example, there was no external process that controlled the "
"exact sequence of these operations. This may be imagined however, by adding "
"a workflow that calls the two calculations in succession, as shown in "
":numref:`fig_provenance_add_multiply_full`."
msgstr ""
"在这个简单的例子中，没有外部流程来控制这些运算的顺序。而当引入工作流后，这两个算例按照顺序调用，我们得到如图所示的可验证性图 "
":numref:`fig_provenance_add_multiply_full`."

#: ../docs/source/concepts/provenance.rst:146
msgid ""
"The same calculation `(x+y)*z` is performed using a workflow. Here the data "
"nodes D\\ :sub:`1`, D\\ :sub:`2`, and D\\ :sub:`3` are the inputs of the "
"workflow W\\ :sub:`1`, which *calls* calculation C\\ :sub:`1` with inputs "
"D\\ :sub:`1` and D\\ :sub:`2`. It then *calls* calculation C\\ :sub:`2`, "
"using as inputs D\\ :sub:`3` and D\\ :sub:`4` (which was *created* by C\\ "
":sub:`2`\\). Calculation C\\ :sub:`2` *creates* data node D\\ :sub:`5`, "
"which is finally *returned* by workflow W\\ :sub:`1`\\."
msgstr ""
"工作流执行了同样的运算 `(x+y)*z` 。此处，输入节点 D\\ :sub:`1`, D\\ :sub:`2` 和 D\\ :sub:`3` "
"是工作流 W\\ :sub:`1` 的输入，该工作流节点使用 D\\ :sub:`1` and D\\ :sub:`2` *调用* 算例 C\\ "
":sub:`1` 然后 *调用* 算例 C\\ :sub:`2` 使用 D\\ :sub:`3` 和 D\\ :sub:`4` (被 C\\ "
":sub:`2`\\ *创建*)。 算例 C\\ :sub:`2` *创建* 数据节点 D\\ :sub:`5` ，最终作为返回值被工作流 W\\ "
":sub:`1`\\ *返回* ."

#: ../docs/source/concepts/provenance.rst:150
msgid ""
"Notice that if we were to omit the workflow nodes and all its links from the"
" provenance graph in :numref:`fig_provenance_add_multiply_full`, one would "
"end up with the exact same graph as shown in "
":numref:`fig_provenance_add_multiply_data` (the **data provenance** graph)."
msgstr ""
"注意到，如果我们忽略图 :numref:`fig_provenance_add_multiply_full` "
"中，工作流节点和与其相连的所有连接，将会得到与 :numref:`fig_provenance_add_multiply_data` "
"完全相同的可验证性图（ **数据可验证** 图）。"

#: ../docs/source/concepts/provenance.rst:156
msgid "Consistency"
msgstr ""

#: ../docs/source/concepts/provenance.rst:158
msgid ""
"Because of the very nature of scientific research, it becomes indispensable "
"to be able to both delete parts of a database (e.g., if errors are made, "
"inputs are misspelled, or useless calculations are performed) or export it "
"(for collaboration or publication purposes). Both these features, which are "
"provided by AiiDA, have one aspect in common: they can easily lead to a "
"provenance graph with incomplete information. To better understand why, "
"let's take a look at the following basic provenance graph:"
msgstr ""

#: ../docs/source/concepts/provenance.rst:165
msgid ""
"Even in this simple case, if we were to export only the calculation node and"
" the output data node (or, equivalently, delete just the input data node), "
"then we would have lost part of the critical information needed to run the "
"calculation (the |D_1| node), thus losing the reproducibility of the "
"calculation |C_1|. In this simple case, therefore, in order to have a "
"consistent provenance, whenever you export a calculation node you must also "
"import *all* of its input nodes (or, symmetrically, whenever you delete a "
"data node you must also delete all calculations that used it as an input)."
msgstr ""

#: ../docs/source/concepts/provenance.rst:168
msgid ""
"This is just one of the many rules that must be considered when trying to "
"manually edit a provenance database. The key message to remember is that "
"AiiDA will not only delete or export the nodes explicitly targeted by the "
"user, but will also include any other nodes that are needed for keeping a "
"consistent provenance in the resulting database."
msgstr ""

#: ../docs/source/concepts/provenance.rst:171
msgid ""
"It is also worth noting that if you do successive exports of partial "
"information, AiiDA will be able to reconstruct links that might have been "
"broken when dividing the data for export. So if you first where to export "
"the previous graph, and then you exported the next section of your full "
"database:"
msgstr ""

#: ../docs/source/concepts/provenance.rst:177
msgid ""
"Then AiiDA will be able to automatically identify the shared node |D_2| and "
"connect both sections back together during the import process. For this kind"
" of recognition it doesn't matter which sub-graph was exported first."
msgstr ""

#: ../docs/source/concepts/provenance.rst:180
msgid ""
"In the following section we will explain in more detail the criteria for "
"including other nodes and the corresponding traversal rules."
msgstr ""

#: ../docs/source/concepts/provenance.rst:184
msgid "Traversal Rules"
msgstr ""

#: ../docs/source/concepts/provenance.rst:186
msgid ""
"When you run ``verdi node delete [NODE_IDS]`` or ``verdi export create -N "
"[NODE_IDS]``, AiiDA will look at the links incoming or outgoing from the "
"nodes that you specified and decide if there are other nodes that are "
"critical to keep."
msgstr ""

#: ../docs/source/concepts/provenance.rst:188
msgid ""
"For this decision, it is not only important to consider the type of link, "
"but also if we are following it along its direction (we will call this "
"``forward`` direction) or in the reversed direction (``backward`` "
"direction). To clarify this, in the example above, when deleting data node "
"|D_1|, AiiDA will follow the ``input_calc`` link in the ``forward`` "
"direction (in this case, it will decide that the linked node (|C_1|) must "
"then also be deleted). If the initial target node was, instead, |C_1| the "
"``input_calc`` link would be followed in the ``backward`` direction (and in "
"this case the node |D_1| will not be deleted, as we will explain below)."
msgstr ""

#: ../docs/source/concepts/provenance.rst:192
msgid ""
"This process will be repeated recursively for every node that has just been "
"included for deletion or export, until no more nodes need to be added. The "
"rules defining whether a linked node should be added or not to the "
"delete/export list (based on the kind and direction of the link) are called "
"*traversal rules*. In the following section we will describe these rules "
"both for the export and delete procedures."
msgstr ""

#: ../docs/source/concepts/provenance.rst:196
msgid ""
"The tables below are grouped according to the type of nodes and links "
"involved. We also provide illustrations of the cases considered, where the "
"encircled node is the one being targeted, and the other node (to which the "
"red arrow is pointing) is the one that is being considered for addition into"
" the delete/export list."
msgstr ""

#: ../docs/source/concepts/provenance.rst:200
msgid "Data and Calculation Nodes"
msgstr ""

#: ../docs/source/concepts/provenance.rst:202
msgid ""
"The first example above already discusses the case of deleting an input "
"node: in this case, it is necessary to also delete any calculation that uses"
" it as an input."
msgstr ""

#: ../docs/source/concepts/provenance.rst:204
msgid ""
"In AiiDA, we apply the same criterion also when deleting an output: in this "
"case, we follow the ``create`` link in the ``backward`` direction and we "
"mark for deletion also the calculation that created it. The reason for this "
"is that a calculation with missing outputs could be misleading. For "
"instance, some calculations produce optional outputs depending on the "
"combination of input flags that are used. A missing output might be "
"interpreted as if that piece of information was not computed by the "
"calculation. In the case of export, the rules are typically the reverse of "
"those used for deletion. Therefore, in this case, the following rule "
"applies: when exporting a calculation node, all its input data nodes and "
"created output nodes must be exported as well."
msgstr ""

#: ../docs/source/concepts/provenance.rst:210
msgid ""
"On the other hand, when exporting a data node, users typically do not need "
"to also export all the calculations that used it as an input. These may "
"represent further work that, by default, does not need to be exported as "
"well (unless explicitly specified by the user in the list of nodes). "
"Equivalently, when deleting a calculation, one typically wants to keep its "
"inputs, as they might be used by other unrelated calculations."
msgstr ""

#: ../docs/source/concepts/provenance.rst:214
msgid ""
"What should happen instead for the outputs of a calculation to be deleted? "
"Often, one might want to delete (recursively) all the outputs generated by "
"it. However, we leave the option to users to just delete the calculation, "
"keeping its outputs in the database. While we emphasize that this operation "
"removes all provenance information for the output nodes, there are cases in "
"which this is useful or even needed (removal of inputs that are protected by"
" copyright, or creating a smaller export file to transfer to collaborators "
"who want to work with the output data)."
msgstr ""

#: ../docs/source/concepts/provenance.rst:220
#: ../docs/source/concepts/provenance.rst:251
#: ../docs/source/concepts/provenance.rst:287
msgid "Illustrative diagram (explicitly targeted node is encircled)"
msgstr ""

#: ../docs/source/concepts/provenance.rst:220
#: ../docs/source/concepts/provenance.rst:251
#: ../docs/source/concepts/provenance.rst:287
msgid "Name of Rule"
msgstr ""

#: ../docs/source/concepts/provenance.rst:220
#: ../docs/source/concepts/provenance.rst:251
#: ../docs/source/concepts/provenance.rst:287
msgid "Behavior when exporting target node"
msgstr ""

#: ../docs/source/concepts/provenance.rst:220
#: ../docs/source/concepts/provenance.rst:251
#: ../docs/source/concepts/provenance.rst:287
msgid "Behavior when deleting target node"
msgstr ""

#: ../docs/source/concepts/provenance.rst:223
msgid "``input_calc_forward``"
msgstr ""

#: ../docs/source/concepts/provenance.rst:223
#: ../docs/source/concepts/provenance.rst:254
msgid "Default Value: ``False``"
msgstr ""

#: ../docs/source/concepts/provenance.rst:224
#: ../docs/source/concepts/provenance.rst:255
#: ../docs/source/concepts/provenance.rst:264
msgid "Linked node **won't** be exported **by default**."
msgstr ""

#: ../docs/source/concepts/provenance.rst:223
#: ../docs/source/concepts/provenance.rst:226
#: ../docs/source/concepts/provenance.rst:229
#: ../docs/source/concepts/provenance.rst:232
#: ../docs/source/concepts/provenance.rst:254
#: ../docs/source/concepts/provenance.rst:257
#: ../docs/source/concepts/provenance.rst:260
#: ../docs/source/concepts/provenance.rst:263
#: ../docs/source/concepts/provenance.rst:290
#: ../docs/source/concepts/provenance.rst:293
#: ../docs/source/concepts/provenance.rst:296
#: ../docs/source/concepts/provenance.rst:299
msgid "Fixed Value: ``True``"
msgstr ""

#: ../docs/source/concepts/provenance.rst:224
#: ../docs/source/concepts/provenance.rst:233
#: ../docs/source/concepts/provenance.rst:255
#: ../docs/source/concepts/provenance.rst:264
#: ../docs/source/concepts/provenance.rst:294
#: ../docs/source/concepts/provenance.rst:300
msgid "Linked node **will always** be deleted."
msgstr ""

#: ../docs/source/concepts/provenance.rst:226
msgid "``input_calc_backward``"
msgstr ""

#: ../docs/source/concepts/provenance.rst:227
#: ../docs/source/concepts/provenance.rst:230
#: ../docs/source/concepts/provenance.rst:258
#: ../docs/source/concepts/provenance.rst:261
#: ../docs/source/concepts/provenance.rst:291
#: ../docs/source/concepts/provenance.rst:297
msgid "Linked node **will always** be exported."
msgstr ""

#: ../docs/source/concepts/provenance.rst:226
msgid "Fixed Value: ``False`` [#f01]_"
msgstr ""

#: ../docs/source/concepts/provenance.rst:227
#: ../docs/source/concepts/provenance.rst:258
#: ../docs/source/concepts/provenance.rst:261
msgid "Linked node **will never** be deleted."
msgstr ""

#: ../docs/source/concepts/provenance.rst:229
msgid "``create_forward``"
msgstr ""

#: ../docs/source/concepts/provenance.rst:229
#: ../docs/source/concepts/provenance.rst:290
#: ../docs/source/concepts/provenance.rst:293
#: ../docs/source/concepts/provenance.rst:296
msgid "Default Value: ``True``"
msgstr ""

#: ../docs/source/concepts/provenance.rst:230
#: ../docs/source/concepts/provenance.rst:291
#: ../docs/source/concepts/provenance.rst:297
msgid "Linked node **will** be deleted **by default**."
msgstr ""

#: ../docs/source/concepts/provenance.rst:232
msgid "``create_backward``"
msgstr ""

#: ../docs/source/concepts/provenance.rst:232
#: ../docs/source/concepts/provenance.rst:299
msgid "Default Value: ``True``."
msgstr ""

#: ../docs/source/concepts/provenance.rst:233
#: ../docs/source/concepts/provenance.rst:294
#: ../docs/source/concepts/provenance.rst:300
msgid "Linked node **will** be exported **by default**."
msgstr ""

#: ../docs/source/concepts/provenance.rst:237
msgid ""
"Although we provide the option to automatically export all calculations that"
" use as input any targeted data node (by specifying "
"``input_calc_forward=True``) we *currently* do not provide the reciprocal "
"option to delete all the data node inputs when targeting calculation nodes. "
"This is mainly for the potential danger that would imply automatically "
"enabling upwards traversal of the data provenance when deleting, which would"
" make it extremely hard to predict or control the nodes that will be "
"ultimately affected."
msgstr ""

#: ../docs/source/concepts/provenance.rst:242
msgid "Data and Workflow Nodes"
msgstr ""

#: ../docs/source/concepts/provenance.rst:244
msgid ""
"The behavior when considering ``input_work`` links is exactly the same as "
"when considering ``input_calc`` links for the same reasons. The case for "
"``return`` links is partially similar to the one for ``create`` one. Indeed,"
" it isn't desirable to have a resulting database with missing outputs, so "
"when exporting a workflow the returned data nodes will also be included (and"
" when deleting a data node, the returning workflow will also be removed). "
"However, when exporting a returned node, the default behavior is *not* to "
"traverse backwards through the ``return`` links, since a data node might be "
"returned by several unrelated workflows (representing selection procedures "
"for other studies, for example) that are unrelated to its creation. The "
"workflow responsible for coordinating its creation will be included in the "
"export, not directly, but through the chain effect of including the creating"
" calculation (through ``create_backward``) and then including its calling "
"workflows (through ``call_calc_backward`` and ``call_work_backward``, see "
"next sections)."
msgstr ""

#: ../docs/source/concepts/provenance.rst:254
msgid "``input_work_forward``"
msgstr ""

#: ../docs/source/concepts/provenance.rst:257
msgid "``input_work_backward``"
msgstr ""

#: ../docs/source/concepts/provenance.rst:257
msgid "Fixed Value: ``False``"
msgstr ""

#: ../docs/source/concepts/provenance.rst:260
msgid "``return_forward``"
msgstr ""

#: ../docs/source/concepts/provenance.rst:260
msgid "Fixed Value: ``False`` [#f02]_"
msgstr ""

#: ../docs/source/concepts/provenance.rst:263
msgid "``return_backward``"
msgstr ""

#: ../docs/source/concepts/provenance.rst:263
msgid "Default Value: ``False``."
msgstr ""

#: ../docs/source/concepts/provenance.rst:268
msgid ""
"The reason to prevent the deletion of returned data nodes is that, since the"
" logical provenance can be cyclical, this might end up deleting inputs and "
"thus propagating the deletion process to other unrelated parts of the "
"database. In most cases where you will want to delete a returned data node, "
"you will be able to do so by setting ``call_calc_forward=True`` (see below) "
"and ``create_forward=True`` (which is the default value)."
msgstr ""

#: ../docs/source/concepts/provenance.rst:274
msgid "Workflows and Calculation Nodes"
msgstr ""

#: ../docs/source/concepts/provenance.rst:276
msgid ""
"Finally, we will consider the possible (call) links between processes. The "
"results of a parent workflow depend critically on the sub-workflows or "
"calculations launched by it. When exporting a workflow node, we therefore "
"always traverse its ``call`` links (both ``call_calc`` and ``call_work``) in"
" the ``forward`` direction to include all children processes (i.e. processes"
" directly called by it). Since the traversal rules are applied recursively, "
"this means that also the children processes of any workflow that was a child"
" of the targeted one will be exported as well, and so on. Analogously, when "
"deleting a process the same applies but in the opposite direction "
"(``backward``), including the parent workflow of the targeted node (if there"
" is one), and the parent of that parent, etc."
msgstr ""

#: ../docs/source/concepts/provenance.rst:282
msgid ""
"Since ``call`` links are followed backward by default, targeting one process"
" for either export or deletion results in selecting not only all of its "
"child processes but also all children of any of its parent processes. As a "
"result of all ``call`` links being traversed in both directions, targeting "
"any of the process nodes in a workflow will mean the inclusion of the other "
"processes of that workflow as well. Users can disable the traversal of "
"``call`` links in one of the directions (``forward`` for deletion, "
"``backward`` for export) for fine-grained control (see examples below)."
msgstr ""

#: ../docs/source/concepts/provenance.rst:290
msgid "``call_calc_forward``"
msgstr ""

#: ../docs/source/concepts/provenance.rst:293
msgid "``call_calc_backward``"
msgstr ""

#: ../docs/source/concepts/provenance.rst:296
msgid "``call_work_forward``"
msgstr ""

#: ../docs/source/concepts/provenance.rst:299
msgid "``call_work_backward``"
msgstr ""

#: ../docs/source/concepts/provenance.rst:305
msgid "Cascading rules: an example"
msgstr ""

#: ../docs/source/concepts/provenance.rst:307
msgid ""
"In the previous sections we have described the basic rules used by AiiDA to "
"decide which nodes should also be included from an initial list of nodes to "
"delete or export. These rules are applied recursively: as new nodes are "
"included in the deletion (or export)list, the rules are applied to them as "
"well until no new nodes are included. Therefore, the consequence of using "
"these features on a given set of nodes may not always be straightforward, "
"and the final set might include more nodes than naively expected."
msgstr ""

#: ../docs/source/concepts/provenance.rst:311
msgid ""
"Let us first focus on the data provenance only (i.e., only ``input_calc`` "
"and ``create`` links). The following two rules apply when going in the "
"``forward`` direction:"
msgstr ""

#: ../docs/source/concepts/provenance.rst:313
msgid ""
"If you delete a data node, any calculation that uses it as input will "
"*always* be deleted as well (``input_calc_forward=True``)."
msgstr ""

#: ../docs/source/concepts/provenance.rst:314
msgid ""
"If you delete a calculation node, any output data node will be deleted *by "
"default* (``create_forward=True``)."
msgstr ""

#: ../docs/source/concepts/provenance.rst:316
msgid ""
"The consequence of these two together is a \"chain reaction\" in which every"
" node that can be traced back through the data provenance to any of the "
"initial targeted nodes will end up being deleted as well. The reciprocal is "
"true for the export: the default behavior is that every ancestor will also "
"be exported by default (because ``create_backward`` is ``True`` by default "
"and ``input_calc_backward`` is always ``True``)."
msgstr ""

#: ../docs/source/concepts/provenance.rst:319
msgid ""
"In regards to the connection between data provenance and logical provenance,"
" the most important thing to understand is how the default behavior of the "
"program treats the highest-level workflows as the units to be handled. The "
"logic behind this is the assumption that the typical user of the program "
"will be dealing with it mostly in an interactive way, running pre-defined "
"workflows through the verdi command line without needing a detailed "
"knowledge of their internal procedures. The default behavior then was "
"designed to reproduce the most intuitive outcomes for this type of usage."
msgstr ""

#: ../docs/source/concepts/provenance.rst:323
msgid ""
"This behavior is basically the result of the settings of "
"``call_calc_forward=True`` and ``call_work_forward=True``, which makes that "
"the inclusion of a process node will also imply the inclusion of any child "
"or parent process node as well. Following this rules in a recursive way "
"leads to the command affecting all the processes within any given workflow: "
"in this way, nodes that are sub-processes of a given highest-level workflow "
"will end up grouped together, in the sense that (by default) they will all "
"be affected in the same way when deleting or exporting."
msgstr ""

#: ../docs/source/concepts/provenance.rst:326
msgid ""
"More freedom to further customize the selection of sections to export or "
"delete is available through the specific switchable flags for each "
"functionality (although the final sections must always comply with the non-"
"switchable rules, see above). However, this usually requires a deeper "
"understanding of the traversal rules and may imply a more thorough analysis "
"of the particular graph. To better illustrate this, we will now consider the"
" application of the deletion procedure to the following graph:"
msgstr ""

#: ../docs/source/concepts/provenance.rst:334
msgid ""
"As you can see, |W_1| and |W_2| describe two similar but independent "
"procedures that were launched by a single parent workflow |W_0|. A typical "
"user would have obtained this by directly running this workflow |W_0| to "
"obtain the results |D_3| and |D_4| from the inputs |D_1| and |D_2|, and may "
"even be unaware of the internal division of |W_0| into two sub-Workflows "
"|W_1| and |W_2|. Hence, if the user considers the workflow (meaning, the "
"whole set of nodes produced by it) no longer necessary, the intuitive thing "
"to do in order to remove it from its database would be by targeting the "
"workflow node |W_0| for deletion. Indeed, this would produce the desired "
"result:"
msgstr ""

#: ../docs/source/concepts/provenance.rst:343
msgid ""
"The nodes |W_1| and |W_2| would be included because |W_0| is being targeted "
"(``call_work_forward=True``), then the nodes |C_1| and |C_2| would also be "
"included (``call_calc_forward=True``), and finally the nodes |D_3| and |D_4|"
" would end up being included as well (``create_forward=True``). In the end, "
"only the inputs |D_1| and |D_2| remain (since ``input_work_backward=False`` "
"always and ``input_calc_backward=False`` by default)."
msgstr ""

#: ../docs/source/concepts/provenance.rst:346
msgid ""
"The same result would occur if the user were to target the output nodes "
"instead (intending to delete everything associated with the obtention of "
"those results). It is important to notice that even if the user deletes only"
" one of the outputs, the whole set of nodes generated by the workflow would "
"be deleted, and not just the ones associated to the targeted data node. As "
"the results |D_3| and |D_4| where obtained from the same high-level process "
"|W_0|, then the default behavior has the underlying assumption that they are"
" interconnected and not independent from one another (as if they were two "
"different outputs of a single calculation)."
msgstr ""

#: ../docs/source/concepts/provenance.rst:354
msgid ""
"In this case, the node |C_1| would first be included because the data node "
"|D_3| is being targeted (``create_reverse=True``), and this in turn would "
"include the node |W_1| (``call_calc_reverse=True``) and then its parent "
"workflow |W_0| (``call_work_reverse=True``). Then nodes |W_2|, |C_2| and "
"|D_4| will be included because |W_0| was included, for the same reasons that"
" were explained in the paragraphs above."
msgstr ""

#: ../docs/source/concepts/provenance.rst:359
msgid "Customizing the graph traversal (for deletion or export)"
msgstr ""

#: ../docs/source/concepts/provenance.rst:361
msgid ""
"This dependency between nodes becomes particularly relevant when, for "
"example, a user with more knowledge of the internal procedures of the parent"
" workflow |W_0| wants to only delete the calculations and results associated"
" to workflow |W_1|. The intuitive action of targeting |W_1| does not produce"
" the desired outcome:"
msgstr ""

#: ../docs/source/concepts/provenance.rst:368
msgid ""
"Indeed |C_1| and |D_4| will be deleted (through ``call_calc_forward`` from "
"|W_1| to |C_1| and ``create_forward`` from |C_1| to |D_3|), but so will "
"|W_0| (through ``call_work_reverse`` from |W_1|), |W_2| "
"(``call_work_forward`` from |W_0|), |C_2| (``call_calc_forward`` from |W_2|)"
" and |D_4| (``create_forward`` from |C_2|). The way to achieve the desired "
"outcome is not trivial, although in some situations like this, one could "
"propose case-specific solutions such as targeting |W_1| with the switchable "
"flag ``call_work_forward=False`` (preventing the traversal from |W_0| to "
"|W_2|):"
msgstr ""

#: ../docs/source/concepts/provenance.rst:375
msgid ""
"However, this approach is not generally applicable, and wouldn't work if "
"|W_1| had sub-workflows that needed to be deleted as well. A more general "
"approach is to first sever the connection to |W_2| by deleting node |W_0| "
"with all switchable traversal rules turned off. Then, once the independence "
"of |W_1| and |W_2| is explicitly reflected in the graph, node |W_1| can be "
"deleted with the default settings."
msgstr ""

#: ../docs/source/concepts/provenance.rst:383
msgid ""
"It is worth noting that if the workflow |W_0| was itself part of a higher-"
"level workflow, all that higher-level logic would be deleted due to the non-"
"switchable rule ``call_work_reverse=True``. This is an inevitable outcome of"
" deleting part of a workflow, since due to the loss of that information it "
"has become incomplete and it makes no sense to keep it."
msgstr ""

#: ../docs/source/concepts/workflows.rst:7
msgid ""
"A workflow in AiiDA is a process (see the :ref:`process "
"section<concepts_processes>` for details) that calls other workflows and "
"calculations and optionally *returns* data and as such can encode the logic "
"of a typical scientific workflow. Currently, there are two ways of "
"implementing a workflow process:"
msgstr ""
"AiiDA中的工作流是一个例程（process） (详情参见 :ref:`例程章节<concepts_processes>` ) "
"它能够调用其他工作流和其他算例并可以 *返回* 数据，因此能够编码特定的科学工作流逻辑。当前，有两类工作流流程的实现"

#: ../docs/source/concepts/workflows.rst:10
msgid ":ref:`work functions<concepts_workfunctions>`"
msgstr ":ref:`工作函数（work functions）<concepts_workfunctions>`"

#: ../docs/source/concepts/workflows.rst:11
msgid ":ref:`work chains<concepts_workchains>`"
msgstr ":ref:`工作链（work chains）<concepts_workchains>`"

#: ../docs/source/concepts/workflows.rst:13
msgid ""
"The first one is the simplest of the two and is basically a python function "
"that is magically transformed into a process. This is ideal for workflows "
"that are not very computationally intensive and can be easily implemented in"
" a python function. For more complex workflows, the work chain is a better "
"alternative. By chaining work chains and work functions together, that each "
"can run other sub processes, we can define a workflow. For simplicity, from "
"here on out, we will use the terms, workflows, work chains, and work "
"functions interchangeably, as a *pars pro toto* and *totum pro parte*."
msgstr ""
"前一种较为简单，仅仅是对python函数的封装变换。这对那些并不是非常耗费计算量的工作流非常合适并且它能够容易的通过python函数实现。对于更为复杂的工作流，工作链（work"
" chain）是更好的选择。通过将工作函数和工作链将流程连接，我们就定义出了作为的工作流。为了简单起见，我们这里在使用特定术语时对三者不作明显区分，好比"
" *石头剪刀布* 和 *剪刀石头布* 。"

#: ../docs/source/concepts/workflows.rst:19
msgid ""
"In the following sections, both concepts will be explained but without going"
" too much into detail on how to implement or run them. For a more detailed "
"exposé, please refer to the respective advanced sections on :ref:`work "
"functions<working_workfunctions>` and :ref:`work "
"chains<working_workchains>`."
msgstr ""
"在下面章节中，每个概念都会被解释，但是不会深入关于实现和运行的细节。详细内容请参见各自的进阶章节 :ref:`工作函数` and "
":ref:`工作链<working_workchains>`."

#: ../docs/source/concepts/workflows.rst:26
msgid "Work functions"
msgstr "工作函数"

#: ../docs/source/concepts/workflows.rst:28
msgid ""
"A work function is implemented just as a :ref:`calculation "
"function<concepts_calcfunctions>`, however, they have very distinct use "
"cases. Since the work function is a 'workflow-like' process, it can only "
"*return* existing data, whereas the calculation function creates a "
"'calculation-like' process which can only *create* new data. This difference"
" is addressed in greater detail in the "
":ref:`process<concepts_process_types>` section and it is very important that"
" one understands this distinction."
msgstr ""
"工作流可以如果 :ref:`算例函数<concepts_calcfunctions>` 一样实现，然而他们的使用场景时不同的。应为工作函数是一个 "
"'工作型' 流程，它只能*返回*以有的数据，而算例函数时一个 '算例型' 流程，它只能 *创建* 新的数据。这个区别在 "
":ref:`流程<concepts_process_types>` 章节中以被详述，这个区别是非常重要的。"

#: ../docs/source/concepts/workflows.rst:32
msgid ""
"To explain the use of the ``@workfunction``, we will continue with the "
"example of the :ref:`calculation functions<concepts_calcfunctions>`, so "
"before continuing, read that section first. The example showed how the "
"``@calcfunction`` decorator can be used to create two functions that, for "
"three given integers, computes the sum of the first two, which is then "
"multiplied with the third, all the while keeping the provenance. Even though"
" the calculation functions ensured that the provenance of the data was kept,"
" the logic of *who* called these functions was not explicitly kept. From the"
" provenance graph generated by the calculation functions, it is impossible "
"to deduce whether the functions were called straight after another in a "
"single script, or whether first the ``add`` function was called and a long "
"time later, the output was used as an input for the ``multiply`` function. "
"Capturing this logical provenance of the *sequence of calls* of processes is"
" exactly what workflow-like processes, such as the ``workfunction`` are "
"designed for."
msgstr ""
"为解释 ``@workfunction`` 的用法，我们将继续 :ref:`算例函数<concepts_calcfunctions>` "
"的例子。因此在开始之前，请阅读该章节。例子中展示了如何使用 ``@calcfunction`` "
"装饰器来创建能够计算给定三个整数的求和前两个数后乘第三个数的算式的函数，并能够保证可验证性。,然而，尽管算例函数保证了数据的可验证性，但是关于何者调用这些函数的逻辑信息没有保留。从算例函数创建的可验证性图中，不能够推导出其中一个函数在另一个函数之前被调用，也无从知晓第一个"
" ``add`` 函数是否在被调用很长时间之后，其输出才作为输入被 ``multiply`` 函数调用。捕捉这些 *调用序列* "
"的逻辑可验证性就是工作型流程所设计的目标。"

#: ../docs/source/concepts/workflows.rst:38
msgid ""
"Consider the following example, where we implement a function called "
"``add_and_multiply`` that we decorate with the ``@workfunction`` decorator."
msgstr ""
"考虑下列例子，我们实现了一个叫做 ``add_and_multiply`` 的函数并使用 ``@workfunction`` 装饰器装饰它。"

#: ../docs/source/concepts/workflows.rst:43
msgid ""
"Instead of calling the calculation functions directly in the script, we call"
" the work function, which then consecutively calls the calculation "
"functions, passing the intermediate result from the first to the second. If "
"we look at the provenance graph generated by this example, we would see "
"something like the following:"
msgstr ""
"不同于直接使用脚本来调用算例函数，此处我们通过工作流算例来调用算例函数，这会将第一个算例的结果作为中间结果传递给第二个算例。可以从这个例子的可验证性图中发现以下特点："

#: ../docs/source/concepts/workflows.rst:49
msgid "The full provenance generated by the work function example"
msgstr "所有的可验证性都被工作函数的例子中创建"

#: ../docs/source/concepts/workflows.rst:51
msgid ""
"It is clear that this provenance graph contains a lot more information than "
"the one for the calculation function example. Whether this information is "
"actually necessary or useful depends on the situation and is entirely up to "
"the user, but there is a big advantage. The strict separation between "
"calculation-like and workflow-like processes and the different allowed links"
" between them, as codified in the :ref:`provenance graph "
"implementation<concepts_provenance_implementation>`, may seem a bit "
"excessive at a first glance and to new users. However, the addition of this "
"parallel yet distinct workflow layer that represents the logical provenance,"
" allows one to ignore all the details of the computation. This is "
"demonstrated by the provenance graph below, which is the exact same as the "
"one before, except only data and workflow nodes are shown:"
msgstr ""
"可以清除的发现，该可验证性图包含了比算例函数的例子更多的信息。这些信息是否真的有需要，还是取决于使用情景和用户，但是更多的信息总是更号的。如章节 "
":ref:`可验证性图的实现<concepts_provenance_implementation>` 中， "
"关于算例型流程和工作流型流程之间严格的区分第一眼看来对于新用户来说显得过于冗长。 然而附加的代表逻辑可验证性的工作流部分使得用户能够忽略计算的细节。 "
"这个部分如下面的可验证性图所示，和前面的完整的可验证性图相同，但只显示了数据和工作流节点 : "

#: ../docs/source/concepts/workflows.rst:60
msgid ""
"The 'logical' provenance generated by the work function example, where only "
"the workflow and data nodes, with their links, are shown"
msgstr "工作函数例子中创建的“逻辑” 可验证性，只包含工作流节点和数据节点及其节点间的连接"

#: ../docs/source/concepts/workflows.rst:62
msgid ""
"With this reduced representation, the big picture of how the original inputs"
" led to the final result becomes immediately clear. Conversely, none of the "
"actual data provenance is lost. In the figure below, all the workflow nodes "
"are omitted and what we end up with is the exact same provenance graph as in"
" :numref:`fig_calculation_functions_provenance_add_multiply` of the "
":ref:`original example<concepts_calcfunctions>` that only used calculation "
"functions."
msgstr ""
"根据这个简化的示意图，有关如何从原始输入到结果的整体路线一目了然。因此，不会有任何关于数据可验证性的信息丢失。下图中，隐去了所有关于工作流节点的信息，之后得到了和只用算例函数的"
" :ref:`原始例子` 图 :numref:`fig_calculation_functions_provenance_add_multiply` "
"完全相同的结果。"

#: ../docs/source/concepts/workflows.rst:69
msgid ""
"The 'data' provenance generated by the work function example, where only the"
" calculation and data nodes, with their links, are shown"
msgstr "工作函数例子中的 ‘数据’ 可验证性图，图中只有算例节点和数据节点及其连线。"

#: ../docs/source/concepts/workflows.rst:71
msgid ""
"In this simple example, the power of being able to select what part of the "
"provenance graph one is interested in is obviously limited. But workflows "
"can quickly become complex and deeply nested, at which point the ability to "
"group parts of the provenance graph together under a single node and "
"effectively 'hide' its internal parts in a transparent way, becomes "
"invaluable."
msgstr ""
"在这个简单的例子中，选择可验证性图中所关注部分的强大功能用途并不明显。但是工作流可能变得及其复杂，并有许多嵌套，这时，将可验证性图中的某些部分组合成组，并有效的"
" ‘隐藏’ 可验证性图中的部分就变得非常有用。"

#: ../docs/source/concepts/workflows.rst:74
msgid ""
"In addition to the orchestration role that the work function can fullfill, "
"it can also be used as a filter or selection function. Imagine that you want"
" to write a process function that takes a set of input integer nodes and "
"returns the one with the highest value. We cannot employ the "
"``calcfunction`` for this, because it would have to return one of its input "
"nodes, which is explicitly forbidden. However, for the ``workfunction``, "
"returning existing nodes, even one of its inputs, is perfectly fine. An "
"example implementation might look like the following:"
msgstr ""
"工作函数除了拥有组合流程的功能，它还能用作过滤和选择函数。假设你想要执行从三个整数中选出并返回最大值的流程。我们不能使用算例 "
"``calculation`` 来完成这个流程。因为这个流程返回了其中的输入节点，而没有创建新的数据，这在算例型中是禁止的。这时可以使用工作函数 "
"``workfunction`` 返回已经存在的节点，即使这个节点是输入节点也无妨。例子如下："

#: ../docs/source/concepts/workflows.rst:83
msgid ""
"The work function above will return the input node ``x`` as one of its "
"outputs as it has the highest value. The provenance of the execution of this"
" select work function will look like the following:"
msgstr "上述的工作函数返回输入节点中最大值 ``x`` 作为它的返回值。可验证性图则如下所示："

#: ../docs/source/concepts/workflows.rst:89
msgid ""
"The provenance generated by the work function that selects one of its input "
"nodes"
msgstr "选择并返回其输入节点的工作函数产生的可验证性图"

#: ../docs/source/concepts/workflows.rst:92
msgid ""
"It is important to realize once again that in the work function examples "
"given above, all the nodes returned by the work functions are *already "
"stored*. That is to say, they were either created by a calculation function "
"called by the work function or were passed in as one of the inputs. This is "
"no accident, as the work function **can** only return stored nodes. Trying "
"to return a node that was created by the work function itself, will raise an"
" exception. You can find a more detailed explanation for the reasoning "
"behind this design choice in the documentation on the various :ref:`process "
"types<concepts_process_types>` present in AiiDA and the :ref:`implementation"
" of the provenance graph<concepts_provenance_implementation>`."
msgstr ""
"需要重申，上述的工作函数中，所有的返回节点，都是 *事先存储* "
"的。也就是说，这些节点要么是由调用的算例函数创建，要么是作为输入传入工作函数。这并非偶然，因为工作函数 **只能** "
"返回已经储存的节点。若试图返回由工作函数创建的节点，将会引发一个异常。有关该设计模式背后的深层原因请参考文档中 "
":ref:`流程类型<concepts_process_types>` 部分和 "
":ref:`可验证性图的实现<concepts_provenance_implementation>` 部分。"

#: ../docs/source/concepts/workflows.rst:102
msgid "Work chains"
msgstr "工作链"

#: ../docs/source/concepts/workflows.rst:105
msgid "Why?"
msgstr "为什么？"

#: ../docs/source/concepts/workflows.rst:107
msgid ""
"Now that we have demonstrated how easily ``workfunctions`` can be used to "
"write your workflow that automatically keeps the provenance, it is time to "
"confess that work functions are not perfect and have their shortcomings. In "
"the simple example of adding and multiplying numbers, the time to execute "
"the functions is very short, but imagine that you are performing a more "
"costly calculation, e.g. you want to run an actual ``CalcJob`` that will be "
"submitted to the scheduler and may run for a long time. If anywhere during "
"the chain, the workflow is interrupted, for whatever reason, all progress is"
" lost. There are no 'checkpoints', so to speak, by simply chaining work "
"functions together."
msgstr ""
"现在，我们展示了如何简单使用 ``workfunctions`` "
"来编写能够自动保留可验证性的工作流。不得不承认工作函数并不完美，且有其缺点。在求和后乘积这个简单的例子中，函数的运行时间非常短，但若有一个非常耗费资源和时间的计算，比如当你要运行一个真实的"
" ``CalcJob`` "
"，它会向作业调度工具提交任务并运行很长时间。在整个过程中的任何阶段因为任何原因工作流中断，则所有的流程都会丢失。单纯的将工作函数连接在一起，则整个过程中没有"
" ‘检查点’。"

#: ../docs/source/concepts/workflows.rst:112
msgid ""
"But fret not! To tackle this problem, AiiDA defines the concept of the work "
"chain. As the name suggests, this construct is a way to chain multiple "
"logical steps of a workflow together in a way that allows to save the "
"progress between those steps as soon as they are successfully completed. The"
" work chain is therefore the preferred solution for parts of the workflow "
"that involve more expensive and complex calculations. To define a work "
"chain, AiiDA provides the "
":py:class:`~aiida.engine.processes.workchains.workchain.WorkChain` class."
msgstr ""
"但不要担心！为了解决这一问题，AiiDA定义了工作链的概念。正如其名所述，该结构能够将工作流中的多个逻辑步骤以某种方式连接起来以保证在每个步骤成功完成后保存流程。因此，工作链是构建时间复杂计算任务的最好选择。为定义工作链，AiiDA提供了"
" :py:class:`~aiida.engine.processes.workchains.workchain.WorkChain`  类。"

#: ../docs/source/concepts/workflows.rst:121
msgid ""
"If we were to reimplement our work function solution of the simple example "
"problem of the previous section, but this time using a work chain, it would "
"look something like the following:"
msgstr "若我们用工作链来重新实现前面章节中通过工作函数构建的简单例子，我们将会由以下代码："

#: ../docs/source/concepts/workflows.rst:126
msgid ""
"Don't be intimidated by all the code in this snippet. The point of this "
"example is not to explain the exact syntax, which will be done in greater "
"detail in the :ref:`advanced workflows<working_workchains>` section, but to "
"merely introduce the concept of the work chain. The core attributes of a "
"work chain are defined by its :ref:`process "
"specification<working_processes_spec>` which is setup in the "
":py:meth:`~aiida.engine.processes.process.Process.define` method. The only "
"thing you need to notice here, is that it defines the *inputs* that the work"
" chain takes, its logical *outline* and the *outputs* that it will produce. "
"The steps of the outline are implemented as class methods of the work chain."
" The ``add`` step will add the first two integers by calling the ``add`` "
"calculation function, and store the sum temporarily in the "
":ref:`context<working_workchains_context>`. The next step in the outline, "
"``multiply``, will take the sum stored in the context that was computed in "
"the first outline step and call the ``multiply`` calculation function with "
"the third input integer. Finally, the ``result`` step will take the product "
"produced by the previous step and record it as an output of the work chain. "
"The resulting provenance when we run this work chain looks like the "
"following:"
msgstr ""
"不要被代码块中的大量代码吓倒。这个例子不会解释详细的语法，详细的实现细节请参考 :ref:`工作流进阶<working_workchains>` "
"章节，这里我们仅仅介绍工作链的概念。工作链中的核心属性通过 :ref:`process "
"specification（流程规格）<working_processes_spec>` 定义，规格是在 "
":py:meth:`~aiida.engine.processes.process.Process.define` "
"方法中定义的。现在你只需要注意到工作链的 *输入* 是在这里定义的，同时还定义了其逻辑运行流提纲 *outline* 和其会产生的 *输出* "
"。.运行流提纲中的小步骤是作为类方法在工作链中实现的。 ``add`` 步骤会调用 ``add`` 算例函数来求和两个整数，并将求和结果临时存入 "
":ref:`context<working_workchains_context>` 中。提纲中下一个步骤 ``multiply`` 会调用 "
"``multiply`` 算例函数将第一部中求和的结果与第三个输入整数相乘。最后， ``result`` "
"步骤将会将上述步骤的乘积产生并记录为该工作链的结果。运行该工作链得到的可验证性图如下："

#: ../docs/source/concepts/workflows.rst:139
msgid ""
"The provenance generated by the work chain example calling calculation "
"functions to perform the addition and multiplication."
msgstr "调用算例函数执行加法和乘法的工作链产生的可验证性图。"

#: ../docs/source/concepts/workflows.rst:141
msgid ""
"As you can see, the produced provenance graph is identical to that of "
":numref:`fig_work_functions_provenance_add_multiply_full` that was produced "
"by the work function solution, except that the workflow node is a work chain"
" instead of a work function node. Full data provenance is kept as the "
"calculation of the sum and the product through the work chain are "
"represented explicitly by the calculation nodes of the ``add`` and "
"``multiply`` calculation functions that are called."
msgstr ""
"正如你看到的，这里产生的可验证性图和用工作函数产生的图 "
":numref:`fig_work_functions_provenance_add_multiply_full` "
"是完全相同的，除了工作流节点上是工作链而不是工作函数。所有的数据可验证性都被工作链以加法算例和乘法算例的算例节点保留，算例节点是调用的 ``add`` "
"和 ``multiply`` 算例函数。"

#: ../docs/source/concepts/workflows.rst:146
msgid ""
"The usage of calculation functions for the computation of the sum and the "
"product is not an accident, but a concious design choice. Since work chains "
"are workflow-like processes and as such cannot *create* data, performing the"
" calculations directly in the work chain outline steps itself, would result "
"in a loss in the data provenance."
msgstr ""
"使用算例函数来计算加法和乘法并非意外而是有意为之。因为工作链是一个 “工作流型” 例程，它不能够 “创建” "
"数据，如果只是在工作链的步骤中单纯调用python函数则会造成数据可验证性的丢失。"

#: ../docs/source/concepts/workflows.rst:149
msgid ""
"To illustrate what it means for worklow processes not being able to *create*"
" new data and how doing so causes a loss of data provenance, let's change "
"the previous implementation to perform the sum and product in the work chain"
" outline steps itself, instead of calling the calculation functions."
msgstr ""
"为展示有关工作流流程不能够 *创建* "
"数据和为何这样做会造成数据可验证性的丢失，我们将上述工作链中的步骤改为不调用和执行加法和乘法算例，而是直接在工作链中实现这两个步骤。"

#: ../docs/source/concepts/workflows.rst:154
msgid "The resulting provenance would look like the following:"
msgstr "可验证性的结果将如下所示："

#: ../docs/source/concepts/workflows.rst:159
msgid ""
"The provenance generated by the work chain example that computes the sum and"
" product directly in its outline steps, instead of delegating it to "
"calculation functions"
msgstr "工作链生成的可验证性图，该工作链直接在内部实现并执行了流程提纲(outline) 中的加法和乘法步骤，而不是将他们作为算例函数来调用。"

#: ../docs/source/concepts/workflows.rst:161
msgid ""
"Note how, in contrast with the provenance of the previous correct solution "
"from :numref:`fig_work_chains_provenance_add_multiply_workchain_full`, there"
" are no explicit calculation nodes representing the computation of the sum "
"and the product. Instead, all that computation is abstracted and represented"
" by the single workflow node that represents the execution of the work "
"chain. The logic inside of those outline steps is then 'hidden' or "
"'encapsulated' in the provenance graph by a single workflow node. "
"Additionally, the output node representing the final product, only has a "
"``return`` link, even though it was *created* by the work chain. This is "
"because :ref:`workflow processes do not have the capacity to create new "
"nodes<working_workfunctions_returning_data>`, and therefore in this example,"
" the data provenance is lost."
msgstr ""
"注意到，与前述正确的可验证性图 "
":numref:`fig_work_chains_provenance_add_multiply_workchain_full` "
"不同，这里没有算例节点表示加法和乘法。而是所有的算例都被省略细节和表示成为一个用以表示工作链的工作流节点。可验证性图中的表示不同步骤的逻辑部分，此时通过工作流节点"
" “隐藏” 或 “封装”。 另外，表示最后乘积的输出节点只有一个 ``return`` 连接，尽管该节点是在该工作链 *创建* 的。 这是因为 "
":ref:`工作流例程不能创建新节点<working_workfunctions_returning_data>` "
"，因此在这个例子中，数据的可验证性丢失了。"

#: ../docs/source/concepts/workflows.rst:167
msgid ""
"An important thing to remember is that *any computation* that happens in the"
" body of outline steps of a work chain, will not be explicitly represented, "
"but will be encapsulated by a single node in the graph that represents that "
"work chain execution. Whether that loss of data provenance is relevant "
"depends on the use case and is left to the developer of the workflow to "
"determine. These two examples demonstrate that AiiDA does not force any "
"particular method, but allows the user to choose exactly what level of "
"granularity they would like to maintain in the provenance. However, the rule"
" of thumb is that if you want to reduce the loss, or 'hiding' of provenance "
"to a minimum, one should keep real computation within the body of work "
"functions and work chains to a minimum and delegate that to calculations. "
"For any real computational work that is relevant to the data provenance, it "
"is better to implement it in explicit calculation processes, usually a "
"separate calculation function."
msgstr ""
"需要记住，工作链中存在于流程提纲outline中的*任何算例* "
"，都不会在可验证性图中展示，而是缩略成一个单一节点。丢失的数据可验证性是否相关则取决于使用场景和工作流的开发者。这两个例子阐释了AiiDA并不强制限制保留这些信息，而是允许用户选择在可验证性图中保留特定的可验证性。但是，宗旨是，若你希望尽量减少信息损失，并最少的隐藏可验证细节，则需要将运算步骤作为算例来指点再放置在工作函数或工作链中。对于真实的与数据可验证性相关的计算工作，通过算例例程来实现运算通常更为合理。"

#: ../docs/source/concepts/workflows.rst:174
msgid "Advantages"
msgstr "进阶"

#: ../docs/source/concepts/workflows.rst:175
msgid ""
"The work chain solution to the add-multiply problem requires significantly "
"more code, compared to the work function solution presented in the beginning"
" of this section. Why should one then bother using the work chain? The "
"advantages for this trivial example may be difficult to see, but imagine the"
" logic of the workflow becomes more complicated and the calculations become "
"more intensive. The process specification of the work chain provides a "
"central way of defining the inputs and outputs, making it easy to see at a "
"glance how the work chain operates. In addition, the ``outline`` can give a "
"succinct summary of the logical steps that the work chain will perform, all "
"of which a work function does not have. The outline in this example was "
"trivially simple, but the :ref:`advanced work chain development "
"section<working_workchains>` will show how complex logic can be implemented "
"directly in the process specification. The process specification also makes "
"it easy to 'wrap' existing work chains into more complex work chains through"
" the :ref:`expose functionality<working_workchains_expose_inputs_outputs>`."
msgstr ""
"在处理文中加法乘法问题时，工具链方法需要用到比工作函数实现更多的代码。那么为什么用户还是要选择工具链呢？工作链的好处在这个平凡的简单例子中可能难以体现，但试想工作流的逻辑变得越来越复杂，并且算例变得越来越内聚。这时工作链中的例程规格信息使得定义输入和输出变得非常集中，使得能够非常容易看到工作链时如何工作的。另外，``outline``"
" 能够给出一个简介的有关工作链运行的逻辑流程概览，这时工作函数没有的功能。这个平凡例子中的流程提纲非常简单，但 "
":ref:`进阶工作链开发章节<working_workchains>` "
"中展示了更加复杂的逻辑如何直接通过流程规格信息实现。流程规格信息还使得在新的复杂的工作链中“包裹”已有的工作链变得简单，这主要通过 "
":ref:`自曝功能<working_workchains_expose_inputs_outputs>` 实现。"

#: ../docs/source/concepts/workflows.rst:183
msgid ""
"Finally, as mentioned before, the work chain provides the possibility of "
"checkpoints, i.e. to save progress at certain points from which the "
"computation can be continued after it had been interrupted. The state of the"
" work chain is saved after each outline step. If expensive calculation jobs "
"are performed in an individual outline step, they will be saved as soon as "
"they finish. This is impossible for work functions, and if it were to be "
"interrupted before *all* the computations had been completed, all "
"intermediate progress would be lost. The rule of thumb therefore is, as soon"
" as the worfklow becomes only slightly complex or computationally intensive,"
" preference should be given to :ref:`work chains<concepts_workchains>` and "
":ref:`calculation jobs<concepts_calcjobs>`."
msgstr ""
"最后，如前所述，工作链还提供了检查点功能，也就是，将例程在特定状态保存下来，从该保存点，计算可以在中断后继续。工作链的状态在每个流程提纲步骤后保存。如果一个非常耗时的计算在提纲中的某个步骤中执行，其将会在结束后立刻被保存。这在工作函数中时不可能实现的，并且如果工作函数在"
" *所有* 计算都结束前中断，所有的中间例程都会丢失。选择使用工作链的法则是，一旦工作流变得有些复杂或耗费资源，则选择 "
":ref:`工作链<concepts_workchains>` 和 :ref:`算例任务<concepts_calcjobs>` 。"

#: ../docs/source/concepts/workflows.rst:189
msgid ""
"This was a very quick overview of the intended use of work chains and how "
"they work, but of course they have a lot more features. To learn how to "
"write work chains for real life problems, continue reading at the :ref:`work"
" chain development<working_workchains>` section, but before you do, read the"
" following part on when to use a work function and when it is better to use "
"a work chain."
msgstr ""
"这是关于工作链如何工作和什么时候使用的一个概览。显然它有更多的特性。要学习如何编写现实世界中可用的工作链，请继续阅读 "
":ref:`工作链开发<working_workchains>` 章节，在开始之前，请县阅读下列关于何时需要使用工具链以及何时使用工具链更好的相关章节。"

#: ../docs/source/concepts/workflows.rst:194
msgid "When to use which"
msgstr "When to use which"

#: ../docs/source/concepts/workflows.rst:195
msgid ""
"Now that we know how the two workflow components, work functions and work "
"chains, work in AiiDA, you might wonder: when should I use which one? For "
"simple operations that do not take long, the simplicity of the work function"
" may be all you need, so by all means use it. However, a good rule of thumb "
"is that as soon as the code is expected to take longer, for example when you"
" want to launch a :ref:`calculation job<concepts_calcjobs>` or another "
"complex workflow, it is always best to go for the work chain. The automatic "
"checkpointing, which guarantees that work between steps is saved, becomes "
"very important. But the work chain offers a lot more features than just "
"checkpointing that may make it more preferable over the work function, which"
" you can read about in the advanced :ref:`work chain development "
"<working_workchains>` section."
msgstr ""
"现在，我们已经知道工作流函数和工作链这两个工作流组建如何在AiiDA中工作。你可能会向：如何选择什么时候使用其中的哪一个？对于耗时不长的简单运算，工作函数的简洁可能是你需要的，那么无论如何请使用工作函数。但有时，整个i运算会耗费大量时间，比如你想要开启一个"
" :ref:`算例任务<concepts_calcjobs>` "
"或者另一个复杂的工作流，此时工作链都是更好的选择。它自动含有检查点，能够保证在不同的执行步骤之间保存状态。而且工作链还提供了除此之外比工作函数更多的特性，"
" 你可以参考 :ref:`工作链开发 <working_workchains>` 章节。"
