# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2019, ECOLE POLYTECHNIQUE FEDERALE DE LAUSANNE (Theory and Simulation of Materials (THEOS) and National Centre for Computational Design and Discovery of Novel Materials (NCCR MARVEL)), Switzerland and ROBERT BOSCH LLC, USA. All rights reserved
# This file is distributed under the same license as the AiiDA package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Jason.Eu <morty.yu@yahoo.com>, 2019
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: AiiDA 1.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-06-24 09:00+0000\n"
"PO-Revision-Date: 2019-05-17 20:01+0000\n"
"Last-Translator: Jason.Eu <morty.yu@yahoo.com>, 2019\n"
"Language-Team: Chinese (China) (https://www.transifex.com/aiidateam/teams/98967/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../docs/source/concepts/calculations.rst:5
msgid "Calculations"
msgstr "算例"

#: ../docs/source/concepts/calculations.rst:7
msgid ""
"A calculation is a process (see the :ref:`process "
"section<concepts_processes>` for details) that *creates* new data. "
"Currently, there are two ways of implementing a calculation process:"
msgstr ""
"算例是一个能够创建新数据的例程 (详情参见 :ref:`例程章节<concepts_processes>` ) 。 当前，有两种算例的实现，分别是："

#: ../docs/source/concepts/calculations.rst:10
msgid ":ref:`calculation function<concepts_calcfunctions>`"
msgstr ":ref:`算例函数<concepts_calcfunctions>`"

#: ../docs/source/concepts/calculations.rst:11
msgid ":ref:`calculation job<concepts_calcjobs>`"
msgstr ":ref:`算例任务<concepts_calcjobs>`"

#: ../docs/source/concepts/calculations.rst:13
msgid ""
"The first one is the simplest of the two and is basically a python function "
"that is magically transformed into a process. This is ideal for calculations"
" that are not very computationally intensive and can be easily implemented "
"in a python function. For more taxing calculations, typically performed by "
"external codes that are optionally run on remote computing clusters, the "
"calculation job is the better alternative."
msgstr ""
"前者是简单的将一个python函数转变为一个例程，这适用于计算量不大且易于实现的python函数。对于复杂的计算任务，通常需要外部的计算软件参与，这些代码通常运行在远端的集群上，因此使用"
" 算例任务更为合适。"

#: ../docs/source/concepts/calculations.rst:17
msgid ""
"In the following sections, both concepts will be explained but without going"
" too much into detail on how to implement or run them. For a more detailed "
"exposé, please refer to the respective advanced sections on "
":ref:`calculation functions<working_calcfunctions>` and :ref:`calculation "
"jobs<working_calcjobs>`."
msgstr ""
"下列章节将分别介绍两者，但是这里只是简单介绍概念而不深入详细的实现和使用细节。详细的内容请参考相应的进阶章节 "
":ref:`算例函数<working_calcfunctions>` 和 :ref:`算例任务<working_calcjobs>` 。"

#: ../docs/source/concepts/calculations.rst:24
msgid "Calculation functions"
msgstr "算例函数"

#: ../docs/source/concepts/calculations.rst:26
msgid "Consider the following computational task at hand:"
msgstr "以下列计算任务为例："

#: ../docs/source/concepts/calculations.rst:29
msgid ""
"Given three integers, add the first two and then multiply the sum by the "
"third."
msgstr "给定三个整数，将前两者求和后与第三者相乘。"

#: ../docs/source/concepts/calculations.rst:31
msgid ""
"In plain python code, the solution would look something like the following:"
msgstr "常规的python代码如下："

#: ../docs/source/concepts/calculations.rst:36
msgid ""
"This simple code snippet will achieve the goal of getting the desired "
"result, however, the provenance is lost. There is no connection between the "
"output of the functions and their inputs. The remedy to this problem is the "
":py:func:`~aiida.engine.processes.functions.calcfunction`. The "
"``calcfunction`` in AiiDA is a `function decorator "
"<https://docs.python.org/3/glossary.html#term-decorator>`_ that transforms a"
" regular python function in a calculation process, which automatically "
"stores the provenance of its output in the :ref:`provenance "
"graph<concepts_provenance>` when executed. Updating the previous snippet "
"with ``calcfunction`` decorators yields:"
msgstr ""
"这些代码会直接得到想要的结果，但是，并没有关于运算过程的可验证性。结果与输入之间并没有保留运算关系。 为保留运算过程，我们使用 "
":py:meth:`~aiida.engine.processes.functions.calcfunction`。  "
"AiiDA的``calcfunction`` 是一个 `装饰器 <https://docs.python.org/3/glossary.html"
"#term-decorator>`_ 它将一个函数装饰成为一个算例例程，这使得其可以自动将得到结果的计算过程储存为一个 "
":ref:`可验证性图<concepts_provenance>` 。. 使用 ``calcfunction`` 装饰器更性上面代码片段后为:"

#: ../docs/source/concepts/calculations.rst:45
msgid ""
"The only thing we had to do to decorate the two functions was to add the "
"line ``@calcfunction`` just before the function definition. Adding the "
"decorator tells AiiDA that the provenance for this function should be stored"
" in the provenance graph when it is executed. This means linking up the "
"inputs and the outputs for a calculation node, which represents the function"
" that was executed. The final change that has to be performed to make this "
"possible, is to make the inputs and the outputs storable. In the previous "
"snippet, the inputs are plain python integer types, which cannot be "
"automatically stored in the provenance graph as nodes. To solve this, one "
"only has to wrap them in the :py:class:`~aiida.orm.nodes.data.int.Int` node "
"sub class, which makes them storable in the database:"
msgstr ""
"我们只需要简单的在每一个函数前增加 ``@calcfunction`` 装饰器。 增加的装饰器使得 AiiDA "
"知晓被装饰的函数在执行后的可验证性需要被储存进可验证性图中 。 也就是执行函数后将输入和输出与一个算例节点连接。  "
"新的代码块还涉及将输入和输出储存进可验证性图。之前的代码中，输入和输出都是普通的python整型数据结构，是无法作为节点自动存入可验证性图中的。为实现该特性，用户只需要将输入输出封装成"
" :py:class:`~aiida.orm.nodes.data.int.Int`  类即可，这样他们就能够被储存进入数据库中了。"

#: ../docs/source/concepts/calculations.rst:55
msgid ""
"The only difference with the previous snippet is that all inputs have been "
"wrapped in the :py:class:`~aiida.orm.nodes.data.int.Int` class. The result "
"that is returned by the function, is now also an "
":py:class:`~aiida.orm.nodes.data.int.Int` node that can be stored in the "
"provenance graph, and contains the result of the computation."
msgstr ""
"前后函数中的的代码差异就只是输入被封装成了 :py:class:`~aiida.orm.nodes.data.int.Int` 类。 "
"同样返回的结果也被封装成 :py:class:`~aiida.orm.nodes.data.int.Int` "
"包含计算结果的节点，可以储存进可验证性图中。"

#: ../docs/source/concepts/calculations.rst:60
msgid ""
"Since ``x`` and ``y`` inside the ``add`` and ``multiply`` functions are "
"already :py:class:`~aiida.orm.nodes.data.int.Int` instances the sum will "
"also be one. This is true because all arithmetic operators also work on the "
"base AiiDA classes (``Int``, ``Float``, etc.) as they would on the "
"equivalent python types. It is important to realize though that only "
":py:class:`~aiida.orm.nodes.node.Node` instances, or sub classes thereof can"
" be stored. For more information on how to return results from process "
"functions, refer to the :ref:`advanced section<working_calcfunctions>`."
msgstr ""
"因为函数 ``add`` 和 ``multiply`` 中的 ``x`` 和 ``y`` 都已经是 "
":py:class:`~aiida.orm.nodes.data.int.Int` "
"类的实例，因为所有的运算都已经重载，无需类型转换便可以用于AiiDA类( ``Int``, ``Float``, "
"等)，他们等价于python本身的类型。需要清楚的记住只有 :py:class:`~aiida.orm.nodes.node.Node` "
"的实例，或是其子类的实例可以被储存进数据库。有关如何从例程函数中返回可储存的结果，请参考 "
":ref:`进阶章节<working_calcfunctions>`"

#: ../docs/source/concepts/calculations.rst:65
msgid ""
"With these trivial changes, the full provenance of the result produced by "
"running the function is maintained and looks like the following:"
msgstr "在这样简单的修改后，函数运行并产生结果的整个可验证性就被保留下来，如下所示："

#: ../docs/source/concepts/calculations.rst:70
msgid "The provenance generated by the calcfunction example"
msgstr "算例例子生成的可验证性图"

#: ../docs/source/concepts/calculations.rst:72
msgid ""
"The example above already shows how a calcfunction can be run: simply by "
"calling it. The value that is returned is the result returned by the "
"definition of the function. However, sometimes one would also like to have a"
" reference to the calculation node that represents the execution of the "
"function in the provenance graph. The following example shows two additional"
" launch functions that will return a tuple, which in addition to the "
"results, also return the ``pk`` or the node associated with the process"
msgstr ""
"上面的例子展示了如何运行一个算例：简单的调用并运行。算例返回的结果就是对应函数的结果。然而用户可能还会想要得到有关算例节点的信息。下列代码块展示了如何用另外两个函数在运行的同时获得例程的"
" ``pk`` 和节点信息。"

#: ../docs/source/concepts/calculations.rst:80
msgid ""
"This was a very short and limited description of calculation functions. For "
"a more detailed description of launching them, please refer to the section "
"on :ref:`launching processes<working_processes_launching>`. If you want more"
" details on implementing calculation functions and best practices, refer to "
"the section on :ref:`working with calculation "
"functions<working_calcfunctions>`."
msgstr ""
"这是一个关于算例函数的一个简单概述。请从以下链接:ref:`启动例程<working_processes_launching>`` "
"中获得有关如可启动例程的详细细节。如果你想要知晓有关如何实现一个算例函数并找到更为详细的示例，请参考章节:ref:`算例函数的开发`。 "

#: ../docs/source/concepts/calculations.rst:88
msgid "Calculation jobs"
msgstr "算例任务"

#: ../docs/source/concepts/calculations.rst:90
msgid ""
"In the previous section on :ref:`calculation "
"functions<concepts_calcfunctions>`, we showed how a simple python function "
"can be transformed into a process, such that when it is launched, its "
"execution is recorded automatically in the provenance graph. However, not "
"all computations are well suited to be implemented as a python function, but"
" rather are implemented as a separate code, external to AiiDA. To interface "
"an external code with the engine of AiiDA, the "
":py:class:`~aiida.engine.processes.calcjobs.calcjob.CalcJob` process class "
"was introduced. A detailed explanation of how to implement it, the interface"
" and best practices, can be found in a :ref:`later "
"section<working_calcjobs>`. Here, instead, we will focus on the big picture "
"and explain in broad lines how a calculation job models the execution of an "
"external code and what tasks it performs when launched."
msgstr ""
"在前面章节 :ref:`算例函数<concepts_calcfunctions>` "
"，我们展示了如何将简单的python函数转换成一个例程，以使其在启动执行后，其结果能够自动记录在可验证性图中。然而并非所有计算过程都能够通过简单的python函数实现，而是通常涉及外部代码来实现。为了实现外部代码与内部引擎的接口"
" AiiDA 引入了 :py:class:`~aiida.engine.processes.calcjobs.calcjob.CalcJob` "
"process 类 。 可以在 :ref:`后续章节<working_calcjobs>` "
"中找到关于如何实现与外部代码接口的细节和示例。这里，只关注算例任务的整体特征和使用场景，即如何通过算例任务来驱动外部代码的运行。"

#: ../docs/source/concepts/calculations.rst:96
msgid ""
"To illustrate how a calculation job operates, we need an external code. "
"Let's imagine an external code that consists of a bash script that reads an "
"input file containing two integers, sums them and prints the result in the "
"standard output using ``echo``, for example:"
msgstr ""
"为了展示算例任务是如何工作的，我们首先需要一份外部代码样例。我们假设一个外部代码是一个bash脚本，它读入一个包含两个整数的文件，并将他们求和后返回结果，如："

#: ../docs/source/concepts/calculations.rst:107
msgid ""
"When run, this script reads the contents of a file called ``aiida.in`` and "
"expects that it contains two integers. It will parse these into the "
"variables ``x`` and ``y`` and then print their sum. When you want to run "
"this 'code' through AiiDA, you need to tell *how* AiiDA should run it. The "
":py:class:`~aiida.calculations.plugins.arithmetic.add.ArithmeticAddCalculation`"
" is a calculation job implementation that forms an interface to accomplish "
"exactly that for the example bash script. A ``CalcJob`` implementation for a"
" specific code, often referred to as a calculation plugin, essentially "
"instructs the engine how it should be run. This includes how the necessary "
"input files should be created based on the inputs that it receives, how the "
"code executable should be called and what files should be retrieved when the"
" calculation is complete. Note the files should be 'retrieved' because "
"calculation jobs can be run not just on the localhost, but on any "
":ref:`computer that is configured in AiiDA<setup_computer>`, including "
"remote machines accessible over for example SSH."
msgstr ""
"运行后，该脚本会从名为 ``aiida.in`` 的文件中读取数据，数据需要是两整数。脚本会将这两个整数解析成变量 ``x`` 和 ``y`` "
"，并打印求和后的结果。当你要用AiiDA运行这段代码，你需要告诉AiiDA如何运行这段代码。:py:class:`~aiida.calculations.plugins.arithmetic.add.ArithmeticAddCalculation`"
" 就是一个实现与上述脚本接口的算例任务。 一个 ``CalcJob`` "
"就是一个关于特定代码如何运行的接口，通常作为一个计算插件调用，它的功能主要是告知AiiDA如何运行这样一份外部代码。这包括了如何从输入产生需要的输入文件，如何运行外部代码，以及当外部代码运行完成后如何取回运行结果文件。之所以需要"
" ‘取出’ 运行结果，是因为算例任务可能不仅仅在本地运行，还会通过SSH在远端已经 "
":ref:`配置入AiiDA配置文件<setup_computer>` 的集群上运行。"

#: ../docs/source/concepts/calculations.rst:115
msgid ""
"Since a ``CalcJob`` is a process just like the :ref:`calculation "
"functions<concepts_calcfunctions>` described before, they can be run in an "
"identical way."
msgstr ""
"因为 ``CalcJob`` 和前面所述的 :ref:`算例函数<concepts_calcfunctions>` "
"一样是一个例程，所以他们通过相同的方式运行。"

#: ../docs/source/concepts/calculations.rst:120
msgid ""
"the provenance generated by running the calculation job will look something "
"like this:"
msgstr "通过运行算例任务产生的可验证性图如下所示："

#: ../docs/source/concepts/calculations.rst:125
msgid "The provenance generated by the calculation job example"
msgstr "算例任务例子生成的可验证性图"

#: ../docs/source/concepts/calculations.rst:127
msgid ""
"The execution of the calculation job is represented in the provenance graph "
"by a process node, i.e. the pink square labeled `C\\ :sub:`1`` in "
":numref:`fig_calculation_jobs_provenance_arithmetic_add`. The integer data "
"nodes ``x`` and ``y`` that were passed as inputs are linked to the "
"calculation job as such, as well as the third input ``code``. This input is "
"required for *all* calculation jobs as it represents the external code that "
"is actually executed. These code nodes are instances of the "
":py:class:`~aiida.orm.nodes.data.code.Code` class, which is a sub-class of "
":py:class:`~aiida.orm.nodes.data.data.Data`. This means that code instances "
"are a sort of data node. Its function is to record the path to the "
"executable and some other code related attributes defined during the "
":ref:`code setup<setup_code>`."
msgstr ""
"算例任务的执行在可验证性图中表示为一个例程节点，如图所示，图 "
":numref:`fig_calculation_jobs_provenance_arithmetic_add` 中粉色正方形标注 `C\\ "
":sub:`1`` 的节点。输入参数 ``x`` 和 ``y`` 以及使用的 ``code`` 都与例程节点连接。 ``code`` 作为输入参数节点在"
" *所有的* 算例任务中都存在，用以表示真实执行的外部代码。 节点是 "
":py:class:`~aiida.orm.nodes.data.code.Code` 类的实例，该类是 "
":py:class:`~aiida.orm.nodes.data.data.Data` "
"类的子类。因此该节点同样是一个数据节点。该节点的作用是记录外部可执行代码以及代码相关的信息 这写信息是在 :ref:`code "
"设置<setup_code>` 中提供的。"

#: ../docs/source/concepts/calculations.rst:134
msgid ""
"The calculation job produced two outputs, an integer node, containing the "
"sum of ``x`` and ``y`` and a "
":py:class:`~aiida.orm.nodes.data.folder.FolderData` node, containing the "
"output files that were retrieved. Note that all outputs of calculation jobs "
"(except for the ``retrieved`` node) are technically not created by the "
"calculation job itself, but rather by an implementation of the "
":py:class:`~aiida.parsers.parser.Parser` class. In principle, this step is "
"optional, and so a calculation job is therefore not required to produce any "
"outputs, except for the ``retrieved`` folder data node, which will always be"
" there. How the parser fits into the concept of calculation jobs will be "
"addressed in :ref:`this section<concepts_calcjobs_parsers>`."
msgstr ""
"这个 calculation job生成两个输出，一个是包含了 ``x`` 和 ``y`` 求和结果的整数数据节点，和一个数据类型为 "
":py:class:`~aiida.orm.nodes.data.folder.FolderData`  "
"的节点，该节点包含了存放计算结果的文件夹。需要注意到的是，（除了 ``retrieved`` node）所有的calculation "
"job的计算结果都不是由其自身产生的，而是通过 :py:class:`~aiida.parsers.parser.Parser` "
"类解析产生的。原则上解析的步骤不是必须的因此calculation job可以没有输出，但一定会有 ``retrieved``` 数据节点。，How "
"the parser fits into the concept of calculation jobs will be addressed "
"in有关calculation job中结果解析器概念的详细内容请参考 :ref:`这里<concepts_calcjobs_parsers>`。"

#: ../docs/source/concepts/calculations.rst:142
msgid "Transport tasks"
msgstr "传输任务"

#: ../docs/source/concepts/calculations.rst:144
msgid ""
"To arrive at the provenance graph shown above in "
":numref:`fig_calculation_jobs_provenance_arithmetic_add`, the engine "
"performed quite some tasks. When a calculation job is launched, the engine "
"will take it roughly through the following steps:"
msgstr ""
"AiiDA内部引擎执行了一系列工作，以实现provenance图 "
":numref:`fig_calculation_jobs_provenance_arithmetic_add` 。 。当一个calculation "
"job启动时，AiiDA内部引擎执行下列步骤："

#: ../docs/source/concepts/calculations.rst:147
msgid ""
"**Upload**: the calculation job implementation is used to transform the "
"input nodes into the required input files, which are uploaded to a 'working'"
" directory on the target machine"
msgstr "上传 :: calculation job会从输入节点得到输入文件，再将输入文件上传到目标计算机器的工作目录中"

#: ../docs/source/concepts/calculations.rst:148
msgid ""
"**Submit**: to execute the calculation, a job is submitted to the scheduler "
"of the computer on which the input `code` is configured."
msgstr "提交 :: 提交一个作业到作业调度工具到配置文件中 `code` 所在的计算机。 "

#: ../docs/source/concepts/calculations.rst:149
msgid ""
"**Update**: the engine will query the scheduler to check for the status of "
"the calculation job"
msgstr "**更新**: 内部引擎会不断查询作业系统以返回calculation job的状态。"

#: ../docs/source/concepts/calculations.rst:150
msgid ""
"**Retrieve**: once the job has finished, the engine will retrieve the output"
" files, specified by the plugin and store them in a node attached as an "
"output node to the calculation"
msgstr "**获取**: 一旦作业结束，引擎会取回输出文件，依据插件中定义的方式将输出结果储存在provenance图的节点中。"

#: ../docs/source/concepts/calculations.rst:152
msgid ""
"All of these tasks require the engine to interact with the computer, or "
"machine, that will actually run the external code. Since the "
":py:class:`~aiida.orm.nodes.data.code.Code` that is used as an input for the"
" calculation job, which is configured for a specific "
":py:class:`~aiida.orm.computers.Computer`, the engine knows exactly how to "
"execute all these tasks. The ``CalcJob`` implementation itself then is "
"completely independent of the machine the code will be run on. To run the "
"calculation job on a different machine, all you have to do is change the "
"``code`` input to one that is configured for that machine. If the machine is"
" *not* the localhost, the engine will need a way to connect to the remote "
"machine in order to perform each of the four tasks listed above. The "
"mechanism that allows the engine to connect to the remote machine is called "
"a *transport* and therefore the tasks it performs using this transport are "
"called *transport tasks*."
msgstr ""
"以上的所有任务都需要AiiDA内部引擎与计算资源间的交互。 Since the 因为将 "
":py:class:`~aiida.orm.nodes.data.code.Code` "
"配置为与特定计算资源:py:class:`~aiida.orm.computers.Computer`关联并作为calculation job "
"的输入，引擎会知晓如何运行这些任务。 ``CalcJob`` 的实现是独立的，因此在内部代码中不依赖 `code` "
"和计算资源信息。因此要在另外的计算资源中运行这个calculation job，用户只需要改变对特定计算资源配置的 ``code`` "
"输入即可。之前提到，calculation job不但可以运行在AiiDA引擎运行的机器上，还能运行在远端的机器上。通过输入参数 ’code' "
"就能指定要运行的机器，因为code中包含了运行代码的特定机器的信息。如果机器不是在本地，AiiDA引擎需要连接远端机器以执行上面四个任务。引擎连接远端计算资源的操作称作"
" ’transport' (传输)，因此完成该操作的任务称作'传输任务' 。"

#: ../docs/source/concepts/calculations.rst:163
msgid "Exponential backoff mechanism"
msgstr "反复退让机制"

#: ../docs/source/concepts/calculations.rst:165
msgid ""
"In the case of calculation jobs being executed on a remote machine, the "
"engine will have to connect to the machine for each of the transport tasks. "
"In connecting to the remote, a whole host of potential problems may occur "
"that would cause the calculation job to fail. For example, the remote "
"machine may be down and as a result unreachable, or the engine itself may "
"lose its internet connection. However, these problems are often temporary. "
"To prevent the calculation job from excepting and it being lost forever, an "
"*exponential backoff mechanism* has been implemented. Whenever the engine "
"performs a transport task but encounters an exception, instead of letting "
"the calculation job fail, it will reschedule the same task to be executed "
"again at a later time. The task will be automatically rescheduled until it "
"finishes successfully, where the interval between tries increases "
"exponentially. If after 5 consecutive tries, the task still fails, instead "
"of rescheduling it, the engine will simply pause the calculation job. The "
"output of ``verdi process list`` will give more information on why the task "
"failed:"
msgstr ""
"当远端机器协作执行calculation "
"job的过程中，AiiDA引擎需要为每一个传输任务建立一条链接。当连接远端服务器时，所有服务器端的潜在问题都可能发生，这会导致calculation "
"job失败。比如，远端计算资源可能宕机而导致结果无法获得，或者引擎所在的本地端可能无法连接网络。然而，这些问题都是不确定的。为了防止calculation"
" job异常或持续无法连接，AiiDA使用了 *反复退让策略* 。当引擎执行了一个传输任务时遇到异常，calculation "
"job不会直接失败，而是提交一个相同的任务后续重新执行。任务会自动重新加入作业系统直到其顺利结束。在连续5次尝试后，若任务还是失败，引擎会单纯的暂停calculation"
" job而不是重新提交。``verdi process list`` 能够输出有关任务失败的更多信息："

#: ../docs/source/concepts/calculations.rst:184
msgid ""
"When there are calculation jobs that have been paused because the transport "
"tasks have failed multiple times, the user has the time to investigate the "
"problem. If the problem is determined to be temporary and it has been "
"resolved, one can use ``verdi process play`` to resume the paused processes."
" The engine will then automatically reschedule the task that failed last and"
" the calculation job will continue where it left off."
msgstr ""
"当calculation "
"job因为传输任务失败后且反复重试后依旧无法连接而暂停后，用户可以查看问题。如果发现问题是临时发生的，且问题被解决后，用户可以重新使用 ``verdi "
"process play`` 来恢复暂停的任务。AiiDA引擎会自动重新提交之前失败的任务，且暂停的calculation "
"job会继续在停止的地方恢复执行。"

#: ../docs/source/concepts/calculations.rst:188
msgid ""
"This exponential backoff mechanism makes the engine very robust with respect"
" to calculation jobs, reducing the loss of computational resources due to "
"temporary problems to an absolute minimum."
msgstr ""

#: ../docs/source/concepts/calculations.rst:192
msgid ""
"The parameters, such as the delays between retries and the maximum number of"
" retries, are currently not configurable, but they might be in the future."
msgstr ""

#: ../docs/source/concepts/calculations.rst:197
msgid "Parsers"
msgstr "解析器"

#: ../docs/source/concepts/calculations.rst:198
msgid ""
"The previous section explained how the ``CalcJob`` class functions as an "
"interface between AiiDA's engine and an external piece of code. The "
"calculation job plugin will instruct the engine how the :ref:`transport "
"tasks<concepts_calcjobs_transport_tasks>` should be accomplished. However, "
"as mentioned before, those tasks stop after the output files have been "
"retrieved, which the engine will attach as a "
":py:class:`~aiida.orm.nodes.data.folder.FolderData` node with the label "
"``'retrieved'`` to the calculation job node. As far as the calculation job "
"goes that is all that is absolutely required. However, often one wants to "
"parse those output files into some specific outputs that should be "
"represented as individual nodes in the provenance graph. This can be "
"accomplished by implementing the :py:class:`~aiida.parsers.parser.Parser` "
"class and specifying it in the inputs of the calculation job. In that case, "
"the engine will call the parser after the output files created by the job "
"have been successfully retrieved. In the parser implementation, the "
"retrieved files can then be parsed and converted into output nodes. For "
"technical details on how to implement a parser for a calculation job and how"
" to specify it in the inputs, please refer to the :ref:`detailed parser "
"section<working_calcjobs_parsers>`,"
msgstr ""

#: ../docs/source/concepts/processes.rst:5
msgid "Processes"
msgstr "例程"

#: ../docs/source/concepts/processes.rst:7
msgid ""
"Anything that runs in AiiDA is an instance of the "
":py:class:`~aiida.engine.processes.process.Process` class. The ``Process`` "
"class contains all the information and logic to tell, whoever is handling "
"it, how to run it to completion. Typically the one responsible for running "
"the processes is an instance of a :py:class:`~aiida.engine.runners.Runner`. "
"This can be a local runner or one of the daemon runners in case of the "
"daemon running the process."
msgstr ""
"所有可以通过AiiDA运行的事件都是:py:class:`~aiida.engine.processes.process.Process` 类的实例。 "
"``Process`` 类包含了有关运行用户，运行方法，运行逻辑的所有信息。特别的，运行该Process的用户属于类 "
":py:class:`~aiida.engine.runners.Runner` 的实例。该运行者可以是本地用户，也可是守护进程的的持有者。"

#: ../docs/source/concepts/processes.rst:12
msgid ""
"In addition to those run instructions, any ``Process`` that has been "
"executed needs some sort of record in the database to store what happened "
"during its execution. For example it needs to record what its exact inputs "
"were, the log messages that were reported and what the final outputs were. "
"For this purpose, every process will utilize an instance of a sub class of "
"the :py:class:`~aiida.orm.nodes.process.ProcessNode` class. This "
"``ProcessNode`` class is a sub class of :py:class:`~aiida.orm.nodes.Node` "
"and serves as the record of the process' execution in the database and by "
"extension the provenance graph."
msgstr ""
"除了以上相关的运行信息，所有被运行的 ``Process`` 还需要在数据库中储存运行时所发生的事件。 "
"例如，它的真实输入是什么，运行时的日志信息是什么，或者最后的输出是什么等。为实现该目的，所有的process都被设计成为  "
":py:class:`~aiida.orm.nodes.process.ProcessNode` 类的子类.  ``ProcessNode`` 类是 "
":py:class:`~aiida.orm.nodes.Node` "
"类的子类，并用于在数据库中记录process的运行时信息以及在provenance图中记录额外信息。"

#: ../docs/source/concepts/processes.rst:17
msgid ""
"It is very important to understand this division of labor. A ``Process`` "
"describes how something should be run, and the ``ProcessNode`` serves as a "
"mere record in the database of what actually happened during execution. A "
"good thing to remember is that while it is running, we are dealing with the "
"``Process`` and when it is finished we interact with the ``ProcessNode``."
msgstr ""
"其父类的分工是非常明确的。``Process`` 类描述了任务该如何运行，``ProcessNode`` "
"类则用于在数据库中记录当时间运行时真实发生的过程。也就是说当事件运行时用户面对``Process``类，而事件运行结束后使用``ProcessNode``"
" 进行交互。"

#: ../docs/source/concepts/processes.rst:24
msgid "Process types"
msgstr "Process 类别"

#: ../docs/source/concepts/processes.rst:26
msgid "Processes in AiiDA come in two flavors:"
msgstr "AiiDA中的Process主要有以下两类："

#: ../docs/source/concepts/processes.rst:28
msgid "Calculation-like"
msgstr "算例类型"

#: ../docs/source/concepts/processes.rst:29
msgid "Workflow-like"
msgstr "工作流类型"

#: ../docs/source/concepts/processes.rst:31
msgid ""
"The calculation-like processes have the capability to *create* data, whereas"
" the workflow-like processes orchestrate other processes and have the "
"ability to *return* data produced by calculations. Again, this is a "
"distinction that plays a big role in AiiDA and is crucial to understand. For"
" this reason, these different types of processes also get a different sub "
"class of the ``ProcessNode`` class. The hierarchy of these node classes and "
"the link types that are allowed between them and ``Data`` nodes, is "
"explained in detail in the :ref:`provenance "
"implementation<concepts_provenance_implementation>` documentation."
msgstr ""

#: ../docs/source/concepts/processes.rst:36
msgid ""
"Currently, there are four types of processes in ``aiida-core`` and the "
"following table shows with which node class it is represented in the "
"provenance graph and what the process is used for."
msgstr ""
"当前， ``aiida-core`` "
"中有如下表中四类processes，表中还展示了不同的process表示在provenance图中的具体节点类型和process的具体使用场景。"

#: ../docs/source/concepts/processes.rst:39
msgid "Process class"
msgstr "Process 类"

#: ../docs/source/concepts/processes.rst:39
msgid "Node class"
msgstr "Node 类"

#: ../docs/source/concepts/processes.rst:39
msgid "Used for"
msgstr "使用场景"

#: ../docs/source/concepts/processes.rst:41
msgid ":py:class:`~aiida.engine.processes.calcjobs.calcjob.CalcJob`"
msgstr ":py:class:`~aiida.engine.processes.calcjobs.calcjob.CalcJob`"

#: ../docs/source/concepts/processes.rst:41
msgid ":py:class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode`"
msgstr ":py:class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode`"

#: ../docs/source/concepts/processes.rst:41
msgid "Calculations performed by external codes"
msgstr "外部软件代码执行的算例"

#: ../docs/source/concepts/processes.rst:42
msgid ":py:class:`~aiida.engine.processes.workchains.workchain.WorkChain`"
msgstr ":py:class:`~aiida.engine.processes.workchains.workchain.WorkChain`"

#: ../docs/source/concepts/processes.rst:42
msgid ":py:class:`~aiida.orm.nodes.process.workflow.workchain.WorkChainNode`"
msgstr ":py:class:`~aiida.orm.nodes.process.workflow.workchain.WorkChainNode`"

#: ../docs/source/concepts/processes.rst:42
msgid "Workflows that run multiple calculations"
msgstr "多个算例组成的工作流"

#: ../docs/source/concepts/processes.rst:43
#: ../docs/source/concepts/processes.rst:44
msgid ":py:class:`~aiida.engine.processes.functions.FunctionProcess`"
msgstr ":py:class:`~aiida.engine.processes.functions.FunctionProcess`"

#: ../docs/source/concepts/processes.rst:43
msgid ""
":py:class:`~aiida.orm.nodes.process.calculation.calcfunction.CalcFunctionNode`"
msgstr ""
":py:class:`~aiida.orm.nodes.process.calculation.calcfunction.CalcFunctionNode`"

#: ../docs/source/concepts/processes.rst:43
msgid "Python functions decorated with the ``@calcfunction`` decorator"
msgstr ""

#: ../docs/source/concepts/processes.rst:44
msgid ""
":py:class:`~aiida.orm.nodes.process.workflow.workfunction.WorkFunctionNode`"
msgstr ""
":py:class:`~aiida.orm.nodes.process.workflow.workfunction.WorkFunctionNode`"

#: ../docs/source/concepts/processes.rst:44
msgid "Python functions decorated with the ``@workfunction`` decorator"
msgstr ""

#: ../docs/source/concepts/processes.rst:47
msgid ""
"For basic information on the concept of a ``CalcJob`` or ``calcfunction``, "
"refer to the :ref:`calculations concept<concepts_calculations>` and the same"
" for the ``WorkChain`` and ``workfunction`` is described in the "
":ref:`workflows concept<concepts_workflows>`. After having read and "
"understood the basic concept of calculation and workflow processes, detailed"
" information on how to implement and use them can be found in the dedicated "
"developing sections for :ref:`calculations<working_calculations>` and "
":ref:`workflows<working_workflows>`, respectively."
msgstr ""
"有关 ``CalcJob`` 和 ``calcfunction`` 的描述，请参考 :ref:`calculations "
"concept<concepts_calculations>` ，有关 ``WorkChain`` 和 ``workfunction`` 请参考 "
":ref:`workflows concept<concepts_workflows>` 。 关于它们的实现和使用等更加细致的讨论请分别参考 "
":ref:`calculations<working_calculations>`  和 "
":ref:`workflows<working_workflows>` 。"

#: ../docs/source/concepts/processes.rst:50
msgid ""
"A ``FunctionProcess`` is never explicitly implemented but will be generated "
"dynamically by the engine when a python function decorated with a "
":py:func:`~aiida.engine.processes.functions.calcfunction` or "
":py:func:`~aiida.engine.processes.functions.workfunction` is run."
msgstr ""

#: ../docs/source/concepts/processes.rst:56
msgid "Process state"
msgstr "Process 状态"

#: ../docs/source/concepts/processes.rst:57
msgid ""
"Each instance of a ``Process`` class that is being executed has a process "
"state. This property tells you about the current status of the process. It "
"is stored in the instance of the ``Process`` itself and the workflow engine,"
" the ``plumpy`` library, operates only on that value. However, the "
"``Process`` instance 'dies' as soon as it is terminated, therefore the "
"process state is also written to the calculation node that the process uses "
"as its database record, under the ``process_state`` attribute. The process "
"can be in one of six states:"
msgstr ""

#: ../docs/source/concepts/processes.rst:64
msgid "*Active*"
msgstr "*Active*"

#: ../docs/source/concepts/processes.rst:64
msgid "*Terminated*"
msgstr "*Terminated*"

#: ../docs/source/concepts/processes.rst:66
msgid "Created"
msgstr "Created"

#: ../docs/source/concepts/processes.rst:66
msgid "Killed"
msgstr "Killed"

#: ../docs/source/concepts/processes.rst:67
msgid "Running"
msgstr "Running"

#: ../docs/source/concepts/processes.rst:67
msgid "Excepted"
msgstr "Excepted"

#: ../docs/source/concepts/processes.rst:68
msgid "Waiting"
msgstr "Waiting"

#: ../docs/source/concepts/processes.rst:68
msgid "Finished"
msgstr "Finished"

#: ../docs/source/concepts/processes.rst:71
msgid ""
"The three states in the left column are 'active' states, whereas the right "
"column displays the three 'terminal' states. Once a process reaches a "
"terminal state, it will never leave it; its execution is permanently "
"terminated. When a process is first created, it is put in the ``Created`` "
"state. As soon as it is picked up by a runner and it is active, it will be "
"in the ``Running`` state. If the process is waiting for another process, "
"that it called, to be finished, it will be in the ``Waiting`` state. If a "
"process is in the ``Killed`` state, it means the user issued a command to "
"kill it, or its parent process was killed. The ``Excepted`` state indicates "
"that during execution an exception occurred that was not caught and the "
"process was unexpectedly terminated. The final option is the ``Finished`` "
"state, which means that the process was successfully executed, and the "
"execution was nominal. Note that this does not automatically mean that the "
"result of the process can also be considered to be successful, it was just "
"executed without any problems."
msgstr ""

#: ../docs/source/concepts/processes.rst:81
msgid ""
"To distinguish between a successful and a failed execution, there is the "
":ref:`exit status<concepts_process_exit_codes>`. This is another attribute "
"that is stored in the node of the process and is an integer that can be set "
"by the process. A ``0`` (zero) means that the result of the process was "
"successful, and a non-zero value indicates a failure. All the process nodes "
"used by the various processes are sub-classes of "
":py:class:`~aiida.orm.nodes.process.ProcessNode`, which defines handy "
"properties to query the process state and exit status."
msgstr ""

#: ../docs/source/concepts/processes.rst:87
msgid "Property"
msgstr "属性"

#: ../docs/source/concepts/processes.rst:87
msgid "Meaning"
msgstr "含义"

#: ../docs/source/concepts/processes.rst:89
msgid "``process_state``"
msgstr "``process_state``"

#: ../docs/source/concepts/processes.rst:89
msgid "Returns the current process state"
msgstr "返回当前process状态"

#: ../docs/source/concepts/processes.rst:90
msgid "``exit_status``"
msgstr "``exit_status``"

#: ../docs/source/concepts/processes.rst:90
msgid "Returns the exit status, or None if not set"
msgstr "返回process结束时的具体退出状态，如果没有设置则是 ``None``"

#: ../docs/source/concepts/processes.rst:91
msgid "``exit_message``"
msgstr "``exit_message``"

#: ../docs/source/concepts/processes.rst:91
msgid "Returns the exit message, or None if not set"
msgstr "返回退出信息，如果没有设置则为 ``None``"

#: ../docs/source/concepts/processes.rst:92
msgid "``is_terminated``"
msgstr "``is_terminated``"

#: ../docs/source/concepts/processes.rst:92
msgid ""
"Returns ``True`` if the process was either ``Killed``, ``Excepted``, or "
"``Finished``"
msgstr ""

#: ../docs/source/concepts/processes.rst:93
msgid "``is_killed``"
msgstr "``is_killed``"

#: ../docs/source/concepts/processes.rst:93
msgid "Returns ``True`` if the process is ``Killed``"
msgstr "返回 ``True`` 如果process的状态时 ``Killed``"

#: ../docs/source/concepts/processes.rst:94
msgid "``is_excepted``"
msgstr "``is_excepted``"

#: ../docs/source/concepts/processes.rst:94
msgid "Returns ``True`` if the process is ``Excepted``"
msgstr "返回 ``True`` 如火process的状态时 ``Excepted``"

#: ../docs/source/concepts/processes.rst:95
msgid "``is_finished``"
msgstr "``is_finished``"

#: ../docs/source/concepts/processes.rst:95
msgid "Returns ``True`` if the process is ``Finished``"
msgstr "返回 ``True`` 如果process的状态时 ``Finished``"

#: ../docs/source/concepts/processes.rst:96
msgid "``is_finished_ok``"
msgstr "``is_finished_ok``"

#: ../docs/source/concepts/processes.rst:96
msgid ""
"Returns ``True`` if the process is ``Finished`` and the ``exit_status`` is "
"equal to zero"
msgstr "返回 ``True`` 如果process的状态是 ``Finished`` 且 ``exit_status`` 的值为0"

#: ../docs/source/concepts/processes.rst:97
msgid "``is_failed``"
msgstr "``is_failed``"

#: ../docs/source/concepts/processes.rst:97
msgid ""
"Returns ``True`` if the process is ``Finished`` and the ``exit_status`` is "
"non-zero"
msgstr "返回 ``True`` 如果process的状态是 ``Finished`` 且 ``exit_status`` 的值非零"

#: ../docs/source/concepts/processes.rst:100
msgid ""
"When you load a calculation node from the database, you can use these "
"property methods to inquire about its state and exit status."
msgstr "当用户从数据库中加载这些算例节点，可以使用这些属性方法来查询算例的当前状态和退出状态。"

#: ../docs/source/concepts/processes.rst:106
msgid "Process exit codes"
msgstr "Process结束代码"

#: ../docs/source/concepts/processes.rst:107
msgid ""
"The previous section about the process state showed that a process that is "
"``Finished`` does not say anything about whether the result is 'successful' "
"or 'failed'. The ``Finished`` state means nothing more than that the engine "
"succeeded in running the process to the end of execution, without it "
"encountering exceptions or being killed. To distinguish between a "
"'successful' and 'failed' process, an 'exit status' can be defined. The "
"`exit status is a common concept in programming "
"<https://en.wikipedia.org/wiki/Exit_status>`_ and is a small integer, where "
"zero means that the result of the process was successful, and a non-zero "
"value indicates a failure. By default a process that terminates nominally "
"will get a ``0`` (zero) exit status. To mark a process as failed, one can "
"return an instance of the "
":py:class:`~aiida.engine.processes.exit_code.ExitCode` named tuple, which "
"allows to set an integer ``exit_status`` and a string message as "
"``exit_message``. When the engine receives such an ``ExitCode`` as the "
"return value from a process, it will set the exit status and message on the "
"corresponding attributes of the process node representing the process in the"
" provenance graph. How exit codes can be defined and returned depends on the"
" process type and will be documented in detail in the respective "
":ref:`calculation<working_calculations>` and "
":ref:`workflow<working_workflows>` development sections."
msgstr ""

#: ../docs/source/concepts/processes.rst:120
msgid "Process lifetime"
msgstr "Process 生命周期"

#: ../docs/source/concepts/processes.rst:122
msgid ""
"The lifetime of a process is defined as the time from the moment it is "
"launched until it reaches a :ref:`terminal state<concepts_process_state>`."
msgstr ""
"process的生命周期被定义为从process启动的时刻到它到达 :ref:`结束状态<concepts_process_state>` 的时刻。"

#: ../docs/source/concepts/processes.rst:127
msgid "Process and node distinction"
msgstr "Process及其节点的区别"

#: ../docs/source/concepts/processes.rst:128
msgid ""
"As explained in the :ref:`introduction of this section<concepts_processes>`,"
" there is a clear and important distinction between the 'process' and the "
"'node' that represents its execution in the provenance graph. When a process"
" is launched, an instance of the ``Process`` class is created in memory "
"which will be propagated to completion by the responsible runner. This "
"'process' instance only exists in the memory of the python interpreter that "
"it is running in, for example that of a daemon runner, and so we cannot "
"directly inspect its state. That is why the process will write any of its "
"state changes to the corresponding node representing it in the provenance "
"graph. In this way, the node acts as a 'proxy' or a mirror image that "
"reflects the state of the process in memory. This means that the output of "
"many of the ``verdi`` commands, such as ``verdi process list``, do not "
"actually show the state of the process instances, but rather the state of "
"the node to which they have last written their state."
msgstr ""
"如本章节 :ref:`引言<concepts_processes>` 所描述的， 'process' 及其在provenance图中表示运行状态的节点 "
"'process node' 之间有清晰明确的不同。当Process启动，内存中会创建一个 ``Process`` "
"的实例并将其传入对应的运行器等待其完成。该process实例只存在其运行的与python解释器中。比如对于一个运行着的守护进程，我们不能够直接获取其状态。这就是为什么process需要将其当前状态写入provenance图中的原因。"
" 通过这种方式，节点充当了表示process内存中状态的一个‘代理’或镜像。这表明大部分 ``verdi`` 指令如 ``verdi process "
"list`` 中输出的并非process的真实状态，而是其刚刚写入节点中的状态。"

#: ../docs/source/concepts/processes.rst:136
msgid "Process tasks"
msgstr "Process 任务"

#: ../docs/source/concepts/processes.rst:137
msgid ""
"The previous section explained how launching a process means creating an "
"instance of the ``Process`` class in memory. When the process is being 'ran'"
" (see the section on :ref:`launching processes<working_processes_launch>` "
"for more details) that is to say in a local interpreter, the particular "
"process instance will die as soon as the interpreter dies. This is what "
"often makes 'submitting' the preferred method of launching a process. When a"
" process is 'submitted', an instance of the ``Process`` is created, along "
"with the node that represents it in the database, and its state is then "
"persisted to the database. This is called a 'process checkpoint', more "
"information on which :ref:`will follow later<concepts_process_checkpoints>`."
" Subsequently, the process instance is shutdown and a 'continuation task' is"
" sent to the process queue of RabbitMQ. This task is simply a small message "
"that just contains an identifier for the process."
msgstr ""

#: ../docs/source/concepts/processes.rst:145
msgid ""
"All the daemon runners, when they are launched, subscribe to the process "
"queue and RabbitMQ will distribute the continuation tasks to them as they "
"come in, making sure that each task is only sent to one runner at a time. "
"The receiving daemon runner can restore the process instance in memory from "
"the checkpoint that was stored in the database and continue the execution. "
"As soon as the process reaches a terminal state, the daemon runner will "
"acknowledge to RabbitMQ that the task has been completed. Until the runner "
"has confirmed that a task is completed, RabbitMQ will consider the task as "
"incomplete. If a daemon runner is shutdown or dies before it got the chance "
"to finish running a process, the task will automatically be requeued by "
"RabbitMQ and sent to another daemon runner. Together with the fact that all "
"the tasks in the process queue are persisted to disk by RabbitMQ, guarantees"
" that once a continuation task has been sent to RabbitMQ, it will at some "
"point be finished, while allowing the machine to be shutdown."
msgstr ""

#: ../docs/source/concepts/processes.rst:152
msgid ""
"Each daemon runner has a maximum number of tasks that it can run "
"concurrently, which means that if there are more active tasks than available"
" slots, some of the tasks will remain queued. Processes, whose task is in "
"the queue and not with any runner, though technically 'active' as they are "
"not terminated, are not actually being run at the moment. While a process is"
" not actually being run, i.e. it is not in memory with a runner, one cannot "
"interact with it. Similarly, as soon as the task disappears, either because "
"the process was intentionally terminated (or unintentionally), the process "
"will never continue running again."
msgstr ""

#: ../docs/source/concepts/processes.rst:161
msgid "Process checkpoints"
msgstr "Process检查点"

#: ../docs/source/concepts/processes.rst:162
msgid ""
"A process checkpoint is a complete representation of a ``Process`` instance "
"in memory that can be stored in the database. Since it is a complete "
"representation, the ``Process`` instance can also be fully reconstructed "
"from such a checkpoint. At any state transition of a process, a checkpoint "
"will be created, by serializing the process instance and storing it as an "
"attribute on the corresponding process node. This mechanism is the final cog"
" in the machine, together with the persisted process queue of RabbitMQ as "
"explained in the previous section, that allows processes to continue after "
"the machine they were running on, has been shutdown and restarted."
msgstr ""
"Process检查点是 ``Process`` 实例在内存中的完整表示，可以被储存在数据库中。因为它是一个完整表示，因此 ``Process`` "
"实例可以从该检查点重新创建。在任何process发生状态转移时都会通过记录完整的process的各种属性和信息创建一个检查点。这个机制用来使机器能够通过上面章节提到的RabbitMQ持久队列来记录process，从而允许process在机器关闭和重启后可以继续执行。"

#: ../docs/source/concepts/provenance.rst:5
msgid "Provenance"
msgstr "Provenance"

#: ../docs/source/concepts/provenance.rst:8
msgid "Graph concept"
msgstr "Provenance图概念"

#: ../docs/source/concepts/provenance.rst:11
msgid "Nodes and links"
msgstr "节点和连接"

#: ../docs/source/concepts/provenance.rst:13
msgid ""
"The two most important concepts in AiiDA are **data** and **processes**. The"
" former are pieces of data, such as a simple integer or float, all the way "
"to more complex data concepts such as a dictionary of parameters, a folder "
"of files or a crystal structure. Processes operate on this data in order to "
"produce new data."
msgstr ""
"在AiiDA **数据** 和 **process** "
"是两个最为重要的概念。前者不仅代表了简单的数据结构如整型浮点型，还代表了更为复杂的数据结构如参数字典或文件的文件夹信息或者晶体结构数据。Process则能作用于这些数据并产生新的数据。"

#: ../docs/source/concepts/provenance.rst:17
msgid "Processes come in two different forms:"
msgstr "Process有两种形式："

#: ../docs/source/concepts/provenance.rst:19
msgid ""
"**Calculations** are processes that are able to **create** new data. This is"
" the case, for instance, for externals simulation codes, that generate new "
"data"
msgstr ""
"**Calculations** 是能够**产生**新的数据的的process，比如，使用外部代码，该类型process能够产生新的结果数据"

#: ../docs/source/concepts/provenance.rst:20
msgid ""
"**Workflows** are processes that **orchestrate** other workflows and "
"calculations, i.e. they manage the logical flow, being able to **call** "
"other processes. Workflows have data inputs, but cannot generate new data. "
"They can only return data that is already in the database (one typical case "
"is to return data created by a calculation they called)."
msgstr ""
"**工作流** "
"是**组合**了其他工作流或者其他calculation的process，它是能够以逻辑流方式组合并调用其他process的process。工作流有数据输入，但不能够产生新的数据输出，它只能够返回已经储存在数据库中的数据（典型的情况是调用calculation"
" process并返回由其创建的数据）。 "

#: ../docs/source/concepts/provenance.rst:22
msgid ""
"Data and processes are represented in the AiiDA provenance graph as the "
"**nodes** of that graph. The graph edges are referred to as **links** and "
"come in different forms:"
msgstr "数据和process在AiiDA的provenance图中以**节点**的形式表示。图中的边被称作**连接**，有以下几种形式："

#: ../docs/source/concepts/provenance.rst:25
msgid ""
"**input** links: connect data nodes to the process nodes that used them as "
"input, both calculations and workflows"
msgstr ""
"**input** 连接：从数据节点连接到process节点，数据节点作为process节点的输入，calculations和工作流均支持该连接"

#: ../docs/source/concepts/provenance.rst:26
msgid ""
"**create** links: connect calculation nodes to the data nodes that they "
"created"
msgstr "**create** 连接：从calculation节点连接到数据节点，来表示其创建的数据来源"

#: ../docs/source/concepts/provenance.rst:27
msgid ""
"**return** links: connect workflow nodes to the data nodes that they "
"returned"
msgstr "**return** 连接：从工作流节点连接到数据节点，表示工作流返回的数据"

#: ../docs/source/concepts/provenance.rst:28
msgid ""
"**call** links: connecting workflow nodes to the process nodes that they "
"directly called, be it calculations or workflows"
msgstr ""
"**call** "
"连接：从工作流节点连接到process节点用以表示工作流调用的process，调用的process可以是calculation也可是一个工作流"

#: ../docs/source/concepts/provenance.rst:30
msgid ""
"Note that the **create** and **return** links are often collectively "
"referred to as **output** links."
msgstr "**create** 和 **return** 连接通常统称为 **output** 输出连接。"

#: ../docs/source/concepts/provenance.rst:34
msgid "Data provenance and logical provenance"
msgstr "数据可验证性和逻辑可验证性"

#: ../docs/source/concepts/provenance.rst:36
msgid ""
"AiiDA automatically stores entities in its database and links them forming a"
" **directed graph**. This directed graph automatically tracks the "
"**provenance** of all data produced by calculations or returned by "
"workflows. By tracking the provenance in this way, one can always fully "
"retrace how a particular piece of data came into existence, thus ensuring "
"its reproducibility."
msgstr ""
"AiiDA自动将流程实体储存在数据库中，并将实体连接成为有向图。有向图自动跟踪了数据如何从calculation产生或从工作流中返回。通过跟踪数据的流向，用户总是可以清楚的回溯特定的数据是如何产生的，这保证了该数据的可重复性。"

#: ../docs/source/concepts/provenance.rst:40
msgid "In particular, we define two types of provenance:"
msgstr "特别的，我们定义了两种类型的可验证性："

#: ../docs/source/concepts/provenance.rst:42
msgid ""
"The **data provenance**, consisting of the part of the graph that *only* "
"consists of data and calculations (i.e. without considering workflows), and "
"only the **input** and **create** links that connect them. The data "
"provenance records the full history of how data has been generated. Due to "
"the causality principle, the data provenance part of the graph is a "
"**directed acyclic graph** (DAG), i.e. its nodes are connected by directed "
"edges and it does not contain any cycles."
msgstr ""
"其一为 **数据可验证性**(data provenance)，考察图中只包含数据和calculation的部分（不包含工作流），以及考察只有 "
"**input** 和 **create** "
"连接的部分。数据可验证性记录了关于该数据如何产生的整个完整流程。根据因果关系，数据的可验证性部分在图中是一个有向无环图**directed "
"acyclic graph**(DAG)，也就是说节点和节点之间直接通过有向边连接，且图中没有环。"

#: ../docs/source/concepts/provenance.rst:43
msgid ""
"The **logical provenance** which consists of workflow and data nodes, "
"together with the **input**, **return** and **call** links that connect "
"them. The logical provenance is *not* acyclic, e.g. a workflow that acts as "
"a filter can return one of its own inputs, directly introducing a cycle."
msgstr ""
"**逻辑可验证性** (logical provenance)是图中只包含工作流和数据节点的部分，包含了 **input** , **return**,"
" 和 **call** 连接。逻辑可验证性部分是有环图，比如一个表示过滤器的工作流会返回它自身，这自动导致在图中引入了环。"

#: ../docs/source/concepts/provenance.rst:45
msgid ""
"The data provenance is essentially a log of which calculation generated what"
" data using certain inputs. The data provenance alone already guarantees "
"reproducibility (one could run again one by one the calculations with the "
"provided input and would obtain the same outputs). The logical provenance "
"gives additional information on why a specific calculation was run. Imagine "
"the case in which you start from 100 structures, you have a filter operation"
" that picks one, and then you run a simulation on it. The data provenance "
"only shows the simulation you run on the structure that was picked, while "
"the logical provenance can also show that the specific structure was not "
"picked at random but via a specific workflow logic."
msgstr ""
"数据可验证性就是有关calculation如何用特定输入产生数据的日志信息。单纯的数据可验证性就已经保证了流程的可重复性（用户可以使用calculation的输入来产生完全相同的输出结果）。而逻辑可验证性提供了关于如何运行一个特定的calculation的附加信息。想象这样一个情景，开始时你有100个晶体结构，你需要以一定条件筛选出一个，然后将其加入模拟。数据可验证性仅仅表示了你如何对选出的结构进行计算模拟，而逻辑可验证性添加了关于如何筛选该晶体构型的信息，因为该构型不是随机挑选，而是通过一定的工作逻辑和条件筛选得到。"

#: ../docs/source/concepts/provenance.rst:52
msgid "Other entities"
msgstr "其他实体"

#: ../docs/source/concepts/provenance.rst:54
msgid ""
"Beside nodes (data and processes), AiiDA defines a few more entities, like a"
" :py:class:`~aiida.orm.computers.Computer` (representing a computer, "
"supercomputer or computer cluster where calculations are run or data is "
"stored), a :py:class:`~aiida.orm.groups.Group` (that group nodes together "
"for organizational purposes) and the :py:class:`~aiida.orm.users.User` (to "
"keep track of the user who first generated a given node, computer or group)."
msgstr ""
"除了上述节点（数据和process），AiiDA还定义了一些其他相关实体比如  "
":py:class:`~aiida.orm.computers.Computer`  （表示执行运算或储存数据的计算机，超算或者集群）， "
":py:class:`~aiida.orm.groups.Group`  （用于组织数据的节点类型），和  "
":py:class:`~aiida.orm.users.User`  （跟踪数据等节点的创建者，或group和user节点的拥有者）。"

#: ../docs/source/concepts/provenance.rst:56
msgid ""
"In the following section we describe in more detail how the general "
"provenance concepts above are actually implemented in AiiDA, with specific "
"reference to the python classes that implement them and the class-"
"inheritance relationships."
msgstr "下列章节我们更加详细讲解上述提到的可验证性的概念在AiiDA中如何通过引用和继承特定的python类型来实现的。"

#: ../docs/source/concepts/provenance.rst:61
#: ../docs/source/concepts/workflows.rst:119
msgid "Implementation"
msgstr "实现"

#: ../docs/source/concepts/provenance.rst:64
msgid "Graph nodes"
msgstr "图的节点"

#: ../docs/source/concepts/provenance.rst:66
msgid ""
"The **nodes** of the AiiDA provenance graph can be grouped into two main "
"**types**: **process nodes** (``ProcessNode``), that represent the execution"
" of calculations or workflows, and **data nodes** (``Data``), that represent"
" pieces of data."
msgstr ""
"AiiDA可验证图中的**节点**可以分类两大类：第一类是表示process执行的 **process 节点** (``ProcessNode``)， "
"和表示数据的 **数据节点**(``Data``)。"

#: ../docs/source/concepts/provenance.rst:68
msgid "In particular, **process nodes** are divided into two sub categories:"
msgstr "**process节点** 被细分为两个小类："

#: ../docs/source/concepts/provenance.rst:70
msgid ""
"**calculation nodes** (``CalculationNode``): Represent code execution that "
"creates new data. These are further subdivided in two subclasses:"
msgstr ""
"**calculation 节点** (``CalculationNode``)： 用以表示创建数据的和储存用来运行的代码的信息。又被分为两个小类："

#: ../docs/source/concepts/provenance.rst:72
msgid ""
":py:class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode`: "
"Represents the execution of a calculation external to AiiDA, typically via a"
" job batch scheduler (see the concept of :ref:`calculation "
"jobs<concepts_calcjobs>`)."
msgstr ""

#: ../docs/source/concepts/provenance.rst:73
msgid ""
":py:class:`~aiida.orm.nodes.process.calculation.calcfunction.CalcFunctionNode`:"
" Represents the execution of a python function (see the concept of "
":ref:`calculation functions<concepts_calcfunctions>`)."
msgstr ""

#: ../docs/source/concepts/provenance.rst:75
msgid ""
"**workflow nodes** (``WorkflowNode``): Represent python code that "
"orchestrates the execution of other workflows and calculations, that "
"optionally return the data created by the processes they called. These are "
"further subdivided in two subclasses:"
msgstr ""
"**工作流节点** "
"(``WorkflowNode``)：表示了则和其他工作流或其他calculation的一段python代码所代表的节点，该节点可以返回由其中调用的process创建的数据。其又被细分为两个小类："

#: ../docs/source/concepts/provenance.rst:77
msgid ""
":py:class:`~aiida.orm.nodes.process.workflow.workchain.WorkChainNode`: "
"Represents the execution of a python class instance with built-in "
"checkpoints, such that the process may be paused/stopped/resumed (see the "
"concept of :ref:`work chains<concepts_workchains>`)."
msgstr ""

#: ../docs/source/concepts/provenance.rst:78
msgid ""
":py:class:`~aiida.orm.nodes.process.workflow.workfunction.WorkFunctionNode`:"
" Represents the execution of a python function calling other processes (see "
"the concept of :ref:`work functions<concepts_workfunctions>`)."
msgstr ""

#: ../docs/source/concepts/provenance.rst:80
msgid "The class hierarchy of the process nodes is shown in the figure below."
msgstr "上述process节点类的继承关系如下图所示。"

#: ../docs/source/concepts/provenance.rst:85
msgid ""
"The hierarchy of the ORM classes for the process nodes. Only instances of "
"the lowest level of classes will actually enter into the provenance graph. "
"The two upper levels have a mostly taxonomical purpose as they allow us to "
"refer to multiple classes at once when reasoning about the graph as well as "
"a place to define common functionality (see section on :ref:`processes "
"<concepts_processes>`)."
msgstr ""
"process节点ORM类的继承关系。只有最下层的类会实际写入可验证性图中。上面两层的父类只要用于分类不同的process节点，使得在开发中能够更容易的定义不同的节点名，为不同的节点指定通用的方法（详情参考"
" :ref:`processes`<concepts_processes>）."

#: ../docs/source/concepts/provenance.rst:88
msgid ""
"For what concerns data nodes, the base class (``Data``) is subclassed to "
"provide functionalities specific to the data type and python methods to "
"operate on it. Often, the name of the subclass contains the word “Data” "
"appended to it, but this is not a requirement. A few examples:"
msgstr ""
"对于数据节点，基础的数据类 ``Data`` "
"被继承为能够提供数据操作和数据储存方式的子类。通常，这些子类的命名需要包含”Data“作为后缀，但这并非必须的，比如："

#: ../docs/source/concepts/provenance.rst:91
msgid ""
":py:class:`~aiida.orm.nodes.data.float.Float`, "
":py:class:`~aiida.orm.nodes.data.int.Int`, "
":py:class:`~aiida.orm.nodes.data.bool.Bool`, "
":py:class:`~aiida.orm.nodes.data.str.Str`, "
":py:class:`~aiida.orm.nodes.data.list.List`, ..."
msgstr ""

#: ../docs/source/concepts/provenance.rst:92
msgid ""
":py:class:`~aiida.orm.nodes.data.dict.Dict`: represents a dictionary of key-"
"value pairs - these are parameters of a general nature that do not need to "
"belong to more specific data sub-classes"
msgstr ""

#: ../docs/source/concepts/provenance.rst:93
msgid ""
":py:class:`~aiida.orm.nodes.data.structure.StructureData`: represents "
"crystal structure data (containing chemical symbols, atomic positions of the"
" atoms, periodic cell for periodic structures, …)"
msgstr ""

#: ../docs/source/concepts/provenance.rst:94
msgid ""
":py:class:`~aiida.orm.nodes.data.array.array.ArrayData`: represents generic "
"numerical arrays of data (python numpy arrays)"
msgstr ""

#: ../docs/source/concepts/provenance.rst:95
msgid ""
":py:class:`~aiida.orm.nodes.data.array.kpoints.KpointsData`: represents a "
"numerical array of k-points data, is a sub-class of ``ArrayData``"
msgstr ""

#: ../docs/source/concepts/provenance.rst:97
msgid "For more detailed information see :ref:`AiiDA data types <DataTypes>`."
msgstr "更多相关信息请参考 :ref:`AiiDA 数据类型 <DataTypes>` 。"

#: ../docs/source/concepts/provenance.rst:99
msgid ""
"In the next section we introduce the links between nodes, creating the AiiDA"
" graph, and then we show some examples to clarify what we introduced up to "
"now."
msgstr "接下来的章节，我们将介绍连接节点的连接，这样就创建了完整的AiiDA可验证性图，在往后，我们给出一些上述内容的例子。"

#: ../docs/source/concepts/provenance.rst:102
msgid "Graph links"
msgstr "图的连接"

#: ../docs/source/concepts/provenance.rst:104
msgid ""
"Process nodes are connected to their input and output data nodes through "
"directed links. Calculation processes can *create* data, while workflow "
"processes can *call* calculations and *return* their outputs. Consider the "
"following graph example, where we represent **data nodes** with circles, "
"**calculation nodes** with squares and **workflow nodes** with diamond "
"shapes."
msgstr ""
"Process节点与输入输出数据节点之间通过有向边连接。Calculation process可以 *创建* "
"数据，而工作流process只能调用calculations并返回其创建的输出。请看以下图作为例子，我们将 **数据节点** "
"用圈来表示，**calculation节点** 用正方形来表示 **工作流节点** 使用菱形表示。"

#: ../docs/source/concepts/provenance.rst:111
msgid ""
"Simple provenance graph for a workflow (W\\ :sub:`1`) *calling* a "
"calculation (C\\ :sub:`1`). The workflow takes a single **data node** (D\\ "
":sub:`1`\\) as input, and passes it to the calculation when *calling* it. "
"The calculation *creates* a new **data node** (D\\ :sub:`2`\\) that is also "
"*returned* by the **workflow node**."
msgstr ""
"一个工作流的简单可验证性图 (W\\ :sub:`1`) *调用* 算例 (C\\ :sub:`1`。 该工作流将一个 **数据节点** (D\\ "
":sub:`1`\\) 作为输入，当算例调用时将其传入算例。该算例 **创建** 了一个新的 **数据节点**  (D\\ :sub:`2`\\) "
"该节点被 **工作流节点** *返回* 。"

#: ../docs/source/concepts/provenance.rst:113
msgid ""
"Notice that the different style and names for the two links coming into D\\ "
":sub:`2` is intentional, because it was the calculation that *created* the "
"new data, whereas the workflow merely *returned* it. This subtle distinction"
" has big consequences. By allowing workflow processes to *return* data, it "
"can also *return* data that was among its inputs."
msgstr ""
"注意这里用不同类型的线段和命名区别两种到达 D\\ :sub:`2` 上的有向连接是有意的。因为算例 *创建* "
"了新的数据，而工作流仅仅只是返回了数据。这个潜在的区别有重要的意义。因为工作流流程能够 *返回* 数据，它同样能够 *返回* 它的输入。"

#: ../docs/source/concepts/provenance.rst:120
msgid ""
"Provenance graph example of a **workflow node** that receives three **data "
"nodes** as input and *returns* one of those inputs. The input link from D\\ "
":sub:`3` to W\\ :sub:`1` and the return link from W\\ :sub:`1` to D\\ "
":sub:`3` introduce a cycle in the graph."
msgstr ""
"**工作流节点** 的可验证性图例中有三个 **数据节点** 作为输入，并*返回* 了其中一个输入。从输入 D\\ :sub:`3` 到 W\\ "
":sub:`1` 的输入连接和从 W\\ :sub:`1` 到 D\\ :sub:`3` 的返回连接使得图形成了环。"

#: ../docs/source/concepts/provenance.rst:122
msgid ""
"A scenario like this, represented in :numref:`fig_provenance_cycle`, would "
"create a cycle in the provenance graph, breaking the “acyclicity” of the "
"DAG. To restore the directed acyclic graph, we separate the entire "
"provenance graph into two planes as described above: the **data provenance**"
" and the **logical provenance**. With this division, the acyclicity of the "
"graph is restored in the data provenance plane."
msgstr ""

#: ../docs/source/concepts/provenance.rst:126
msgid ""
"An additional benefit of thinking of the provenance graph in these two "
"planes, is that it allows you to inspect it with different layers of "
"granularity. Imagine a high level workflow that calls a large number of "
"calculations and sub-workflows, that each may also call more sub-processes, "
"to finally produce and return one or more data nodes as its result."
msgstr ""

#: ../docs/source/concepts/provenance.rst:131
msgid "Graph examples"
msgstr "可验证图的例子"

#: ../docs/source/concepts/provenance.rst:133
msgid ""
"With these basic definitions of AiiDA’s provenance graph in place, let’s "
"take a look at some examples. Consider the sequence of computations that "
"adds two numbers `x` and `y`, and then multiplies the result with a third "
"number `z`. This sequence as represented in the provenance graph would look "
"something like what is shown in :numref:`fig_provenance_add_multiply_data`."
msgstr ""

#: ../docs/source/concepts/provenance.rst:140
msgid ""
"The DAG for computing `(x+y)*z`. We have two simple calculations: C\\ "
":sub:`1` represents the addition and C\\ :sub:`2` the multiplication. The "
"two data nodes D\\ :sub:`1` and D\\ :sub:`2` are the inputs of C\\ :sub:`1`,"
" which *creates* the data node D\\ :sub:`4`\\. Together with D\\ :sub:`3`, "
"D\\ :sub:`4` then forms the input of C\\ :sub:`2`, which multiplies their "
"values that *creates* the product, represented by D\\ :sub:`5`."
msgstr ""

#: ../docs/source/concepts/provenance.rst:144
msgid ""
"In this simple example, there was no external process that controlled the "
"exact sequence of these operations. This may be imagined however, by adding "
"a workflow that calls the two calculations in succession, as shown in "
":numref:`fig_provenance_add_multiply_full`."
msgstr ""

#: ../docs/source/concepts/provenance.rst:150
msgid ""
"The same calculation `(x+y)*z` is performed using a workflow. Here the data "
"nodes D\\ :sub:`1`, D\\ :sub:`2`, and D\\ :sub:`3` are the inputs of the "
"workflow W\\ :sub:`1`, which *calls* calculation C\\ :sub:`1` with inputs "
"D\\ :sub:`1` and D\\ :sub:`2`. It then *calls* calculation C\\ :sub:`2`, "
"using as inputs D\\ :sub:`3` and D\\ :sub:`4` (which was *created* by C\\ "
":sub:`2`\\). Calculation C\\ :sub:`2` *creates* data node D\\ :sub:`5`, "
"which is finally *returned* by workflow W\\ :sub:`1`\\."
msgstr ""
"工作流执行了同样的运算 `(x+y)*z` 。此处，输入节点 D\\ :sub:`1`, D\\ :sub:`2` 和 D\\ :sub:`3` "
"是工作流 W\\ :sub:`1` 的输入，该工作流节点使用 D\\ :sub:`1` and D\\ :sub:`2` *调用* 算例 C\\ "
":sub:`1` 然后 *调用* 算例 C\\ :sub:`2` 使用 D\\ :sub:`3` 和 D\\ :sub:`4` (被 C\\ "
":sub:`2`\\ *创建*)。 算例 C\\ :sub:`2` *创建* 数据节点 D\\ :sub:`5` ，最终作为返回值被工作流 W\\ "
":sub:`1`\\ *返回* ."

#: ../docs/source/concepts/provenance.rst:154
msgid ""
"Notice that if we were to omit the workflow nodes and all its links from the"
" provenance graph in :numref:`fig_provenance_add_multiply_full`, one would "
"end up with the exact same graph as shown in "
":numref:`fig_provenance_add_multiply_data` (the **data provenance** graph)."
msgstr ""

#: ../docs/source/concepts/workflows.rst:5
msgid "Workflows"
msgstr "工作流"

#: ../docs/source/concepts/workflows.rst:7
msgid ""
"A workflow in AiiDA is a process (see the :ref:`process "
"section<concepts_processes>` for details) that calls other workflows and "
"calculations and optionally *returns* data and as such can encode the logic "
"of a typical scientific workflow. Currently, there are two ways of "
"implementing a workflow process:"
msgstr ""
"AiiDA中的工作刘是一个流程（process） (详情参见 :ref:`流程章节<concepts_processes>` ) "
"它能够调用其他工作流和其他算例并可以 *返回* 数据因此能够编码特定的科学工作流逻辑。当前，有两类工作流流程的实现。"

#: ../docs/source/concepts/workflows.rst:10
msgid ":ref:`work functions<concepts_workfunctions>`"
msgstr ":ref:`工作函数（work functions）<concepts_workfunctions>`"

#: ../docs/source/concepts/workflows.rst:11
msgid ":ref:`work chains<concepts_workchains>`"
msgstr ":ref:`工作链（work chains）<concepts_workchains>`"

#: ../docs/source/concepts/workflows.rst:13
msgid ""
"The first one is the simplest of the two and is basically a python function "
"that is magically transformed into a process. This is ideal for workflows "
"that are not very computationally intensive and can be easily implemented in"
" a python function. For more complex workflows, the work chain is a better "
"alternative. By chaining work chains and work functions together, that each "
"can run other sub processes, we can define a workflow. For simplicity, from "
"here on out, we will use the terms, workflows, work chains, and work "
"functions interchangeably, as a *pars pro toto* and *totum pro parte*."
msgstr ""

#: ../docs/source/concepts/workflows.rst:19
msgid ""
"In the following sections, both concepts will be explained but without going"
" too much into detail on how to implement or run them. For a more detailed "
"exposé, please refer to the respective advanced sections on :ref:`work "
"functions<working_workfunctions>` and :ref:`work "
"chains<working_workchains>`."
msgstr ""
"在下面章节中，每个概念都会被解释，但是不会深入关于实现和运行的细节。详细内容请参见各自的进阶章节 :ref:`工作函数` and "
":ref:`工作链<working_workchains>`."

#: ../docs/source/concepts/workflows.rst:26
msgid "Work functions"
msgstr "工作函数"

#: ../docs/source/concepts/workflows.rst:28
msgid ""
"A work function is implemented just as a :ref:`calculation "
"function<concepts_calcfunctions>`, however, they have very distinct use "
"cases. Since the work function is a 'workflow-like' process, it can only "
"*return* existing data, whereas the calculation function creates a "
"'calculation-like' process which can only *create* new data. This difference"
" is addressed in greater detail in the "
":ref:`process<concepts_process_types>` section and it is very important that"
" one understands this distinction."
msgstr ""

#: ../docs/source/concepts/workflows.rst:32
msgid ""
"To explain the use of the ``@workfunction``, we will continue with the "
"example of the :ref:`calculation functions<concepts_calcfunctions>`, so "
"before continuing, read that section first. The example showed how the "
"``@calcfunction`` decorator can be used to create two functions that, for "
"three given integers, computes the sum of the first two, which is then "
"multiplied with the third, all the while keeping the provenance. Even though"
" the calculation functions ensured that the provenance of the data was kept,"
" the logic of *who* called these functions was not explicitly kept. From the"
" provenance graph generated by the calculation functions, it is impossible "
"to deduce whether the functions were called straight after another in a "
"single script, or whether first the ``add`` function was called and a long "
"time later, the output was used as an input for the ``multiply`` function. "
"Capturing this logical provenance of the *sequence of calls* of processes is"
" exactly what workflow-like processes, such as the ``workfunction`` are "
"designed for."
msgstr ""

#: ../docs/source/concepts/workflows.rst:38
msgid ""
"Consider the following example, where we implement a function called "
"``add_and_multiply`` that we decorate with the ``@workfunction`` decorator."
msgstr ""

#: ../docs/source/concepts/workflows.rst:43
msgid ""
"Instead of calling the calculation functions directly in the script, we call"
" the work function, which then consecutively calls the calculation "
"functions, passing the intermediate result from the first to the second. If "
"we look at the provenance graph generated by this example, we would see "
"something like the following:"
msgstr ""
"不同于直接使用脚本来调用算例函数，此处我们通过工作流算例来调用算例函数，这会将第一个算例的结果作为中间结果传递给第二个算例。可以从这个例子的可验证性图中发现以下特点："

#: ../docs/source/concepts/workflows.rst:49
msgid "The full provenance generated by the work function example"
msgstr "所有的可验证性都被工作函数的例子中创建"

#: ../docs/source/concepts/workflows.rst:51
msgid ""
"It is clear that this provenance graph contains a lot more information than "
"the one for the calculation function example. Whether this information is "
"actually necessary or useful depends on the situation and is entirely up to "
"the user, but there is a big advantage. The strict separation between "
"calculation-like and workflow-like processes and the different allowed links"
" between them, as codified in the :ref:`provenance graph "
"implementation<concepts_provenance_implementation>`, may seem a bit "
"excessive at a first glance and to new users. However, the addition of this "
"parallel yet distinct workflow layer that represents the logical provenance,"
" allows one to ignore all the details of the computation. This is "
"demonstrated by the provenance graph below, which is the exact same as the "
"one before, except only data and workflow nodes are shown:"
msgstr ""

#: ../docs/source/concepts/workflows.rst:60
msgid ""
"The 'logical' provenance generated by the work function example, where only "
"the workflow and data nodes, with their links, are shown"
msgstr "工作函数例子中创建的“逻辑” 可验证性，只包含工作流节点和数据节点及其节点间的连接"

#: ../docs/source/concepts/workflows.rst:62
msgid ""
"With this reduced representation, the big picture of how the original inputs"
" led to the final result becomes immediately clear. Conversely, none of the "
"actual data provenance is lost. In the figure below, all the workflow nodes "
"are omitted and what we end up with is the exact same provenance graph as in"
" :numref:`fig_calculation_functions_provenance_add_multiply` of the "
":ref:`original example<concepts_calcfunctions>` that only used calculation "
"functions."
msgstr ""

#: ../docs/source/concepts/workflows.rst:69
msgid ""
"The 'data' provenance generated by the work function example, where only the"
" calculation and data nodes, with their links, are shown"
msgstr "工作函数例子中的 ‘数据’ 可验证性图，图中只有算例节点和数据节点及其连线。"

#: ../docs/source/concepts/workflows.rst:71
msgid ""
"In this simple example, the power of being able to select what part of the "
"provenance graph one is interested in is obviously limited. But workflows "
"can quickly become complex and deeply nested, at which point the ability to "
"group parts of the provenance graph together under a single node and "
"effectively 'hide' its internal parts in a transparent way, becomes "
"invaluable."
msgstr ""

#: ../docs/source/concepts/workflows.rst:74
msgid ""
"In addition to the orchestration role that the work function can fullfill, "
"it can also be used as a filter or selection function. Imagine that you want"
" to write a process function that takes a set of input integer nodes and "
"returns the one with the highest value. We cannot employ the "
"``calcfunction`` for this, because it would have to return one of its input "
"nodes, which is explicitly forbidden. However, for the ``workfunction``, "
"returning existing nodes, even one of its inputs, is perfectly fine. An "
"example implementation might look like the following:"
msgstr ""

#: ../docs/source/concepts/workflows.rst:83
msgid ""
"The work function above will return the input node ``x`` as one of its "
"outputs as it has the highest value. The provenance of the execution of this"
" select work function will look like the following:"
msgstr "上述的工作函数返回输入节点中最大值 ``x`` 作为它的返回值。可验证性图则如下所示："

#: ../docs/source/concepts/workflows.rst:89
msgid ""
"The provenance generated by the work function that selects one of its input "
"nodes"
msgstr "选择并返回其输入节点的工作函数产生的可验证性图"

#: ../docs/source/concepts/workflows.rst:92
msgid ""
"It is important to realize once again that in the work function examples "
"given above, all the nodes returned by the work functions are *already "
"stored*. That is to say, they were either created by a calculation function "
"called by the work function or were passed in as one of the inputs. This is "
"no accident, as the work function **can** only return stored nodes. Trying "
"to return a node that was created by the work function itself, will raise an"
" exception. You can find a more detailed explanation for the reasoning "
"behind this design choice in the documentation on the various :ref:`process "
"types<concepts_process_types>` present in AiiDA and the :ref:`implementation"
" of the provenance graph<concepts_provenance_implementation>`."
msgstr ""

#: ../docs/source/concepts/workflows.rst:102
msgid "Work chains"
msgstr "工作链"

#: ../docs/source/concepts/workflows.rst:105
msgid "Why?"
msgstr "为什么？"

#: ../docs/source/concepts/workflows.rst:107
msgid ""
"Now that we have demonstrated how easily ``workfunctions`` can be used to "
"write your workflow that automatically keeps the provenance, it is time to "
"confess that work functions are not perfect and have their shortcomings. In "
"the simple example of adding and multiplying numbers, the time to execute "
"the functions is very short, but imagine that you are performing a more "
"costly calculation, e.g. you want to run an actual ``CalcJob`` that will be "
"submitted to the scheduler and may run for a long time. If anywhere during "
"the chain, the workflow is interrupted, for whatever reason, all progress is"
" lost. There are no 'checkpoints', so to speak, by simply chaining work "
"functions together."
msgstr ""
"现在，我们展示了如何简单使用 ``workfunctions`` "
"来编写能够自动保留可验证性的工作流。不得不承认工作函数并不完美，且有其缺点。在求和后乘积这个简单的例子中，函数的运行时间非常短，但若有一个非常耗费资源和时间的计算，比如当你要运行一个真实的"
" ``CalcJob`` "
"，它会向作业调度工具提交任务并运行很长时间。在整个过程中的任何阶段因为任何原因工作流中断，则所有的流程都会丢失。单纯的将工作函数连接在一起，则整个过程中没有"
" ‘检查点’。"

#: ../docs/source/concepts/workflows.rst:112
msgid ""
"But fret not! To tackle this problem, AiiDA defines the concept of the work "
"chain. As the name suggests, this construct is a way to chain multiple "
"logical steps of a workflow together in a way that allows to save the "
"progress between those steps as soon as they are successfully completed. The"
" work chain is therefore the preferred solution for parts of the workflow "
"that involve more expensive and complex calculations. To define a work "
"chain, AiiDA provides the "
":py:class:`~aiida.engine.processes.workchains.workchain.WorkChain` class."
msgstr ""
"但不要担心！为了解决这一问题，AiiDA定义了工作链的概念。正如其名所述，该结构能够将工作流中的多个逻辑步骤以某种方式连接起来以保证在每个步骤成功完成后保存流程。因此，工作链是构建时间复杂计算任务的最好选择。为定义工作链，AiiDA提供了"
" :py:class:`~aiida.engine.processes.workchains.workchain.WorkChain`  类。"

#: ../docs/source/concepts/workflows.rst:121
msgid ""
"If we were to reimplement our work function solution of the simple example "
"problem of the previous section, but this time using a work chain, it would "
"look something like the following:"
msgstr "若我们用工作链来重新实现前面章节中通过工作函数构建的简单例子，我们将会由以下代码："

#: ../docs/source/concepts/workflows.rst:126
msgid ""
"Don't be intimidated by all the code in this snippet. The point of this "
"example is not to explain the exact syntax, which will be done in greater "
"detail in the :ref:`advanced workflows<working_workchains>` section, but to "
"merely introduce the concept of the work chain. The core attributes of a "
"work chain are defined by its :ref:`process "
"specification<working_processes_spec>` which is setup in the "
":py:meth:`~aiida.engine.processes.process.Process.define` method. The only "
"thing you need to notice here, is that it defines the *inputs* that the work"
" chain takes, its logical *outline* and the *outputs* that it will produce. "
"The steps of the outline are implemented as class methods of the work chain."
" The ``add`` step will add the first two integers by calling the ``add`` "
"calculation function, and store the sum temporarily in the "
":ref:`context<working_workchains_context>`. The next step in the outline, "
"``multiply``, will take the sum stored in the context that was computed in "
"the first outline step and call the ``multiply`` calculation function with "
"the third input integer. Finally, the ``result`` step will take the product "
"produced by the previous step and record it as an output of the work chain. "
"The resulting provenance when we run this work chain looks like the "
"following:"
msgstr ""

#: ../docs/source/concepts/workflows.rst:139
msgid ""
"The provenance generated by the work chain example calling calculation "
"functions to perform the addition and multiplication."
msgstr "调用算例函数执行加法和乘法的工作链产生的可验证性图。"

#: ../docs/source/concepts/workflows.rst:141
msgid ""
"As you can see, the produced provenance graph is identical to that of "
":numref:`fig_work_functions_provenance_add_multiply_full` that was produced "
"by the work function solution, except that the workflow node is a work chain"
" instead of a work function node. Full data provenance is kept as the "
"calculation of the sum and the product through the work chain are "
"represented explicitly by the calculation nodes of the ``add`` and "
"``multiply`` calculation functions that are called."
msgstr ""

#: ../docs/source/concepts/workflows.rst:146
msgid ""
"The usage of calculation functions for the computation of the sum and the "
"product is not an accident, but a concious design choice. Since work chains "
"are workflow-like processes and as such cannot *create* data, performing the"
" calculations directly in the work chain outline steps itself, would result "
"in a loss in the data provenance."
msgstr ""

#: ../docs/source/concepts/workflows.rst:149
msgid ""
"To illustrate what it means for worklow processes not being able to *create*"
" new data and how doing so causes a loss of data provenance, let's change "
"the previous implementation to perform the sum and product in the work chain"
" outline steps itself, instead of calling the calculation functions."
msgstr ""

#: ../docs/source/concepts/workflows.rst:154
msgid "The resulting provenance would look like the following:"
msgstr "可验证性的结果将如下所示："

#: ../docs/source/concepts/workflows.rst:159
msgid ""
"The provenance generated by the work chain example that computes the sum and"
" product directly in its outline steps, instead of delegating it to "
"calculation functions"
msgstr ""

#: ../docs/source/concepts/workflows.rst:161
msgid ""
"Note how, in contrast with the provenance of the previous correct solution "
"from :numref:`fig_work_chains_provenance_add_multiply_workchain_full`, there"
" are no explicit calculation nodes representing the computation of the sum "
"and the product. Instead, all that computation is abstracted and represented"
" by the single workflow node that represents the execution of the work "
"chain. The logic inside of those outline steps is then 'hidden' or "
"'encapsulated' in the provenance graph by a single workflow node. "
"Additionally, the output node representing the final product, only has a "
"``return`` link, even though it was *created* by the work chain. This is "
"because :ref:`workflow processes do not have the capacity to create new "
"nodes<working_workfunctions_returning_data>`, and therefore in this example,"
" the data provenance is lost."
msgstr ""

#: ../docs/source/concepts/workflows.rst:167
msgid ""
"An important thing to remember is that *any computation* that happens in the"
" body of outline steps of a work chain, will not be explicitly represented, "
"but will be encapsulated by a single node in the graph that represents that "
"work chain execution. Whether that loss of data provenance is relevant "
"depends on the use case and is left to the developer of the workflow to "
"determine. These two examples demonstrate that AiiDA does not force any "
"particular method, but allows the user to choose exactly what level of "
"granularity they would like to maintain in the provenance. However, the rule"
" of thumb is that if you want to reduce the loss, or 'hiding' of provenance "
"to a minimum, one should keep real computation within the body of work "
"functions and work chains to a minimum and delegate that to calculations. "
"For any real computational work that is relevant to the data provenance, it "
"is better to implement it in explicit calculation processes, usually a "
"separate calculation function."
msgstr ""

#: ../docs/source/concepts/workflows.rst:174
msgid "Advantages"
msgstr "进阶"

#: ../docs/source/concepts/workflows.rst:175
msgid ""
"The work chain solution to the add-multiply problem requires significantly "
"more code, compared to the work function solution presented in the beginning"
" of this section. Why should one then bother using the work chain? The "
"advantages for this trivial example may be difficult to see, but imagine the"
" logic of the workflow becomes more complicated and the calculations become "
"more intensive. The process specification of the work chain provides a "
"central way of defining the inputs and outputs, making it easy to see at a "
"glance how the work chain operates. In addition, the ``outline`` can give a "
"succinct summary of the logical steps that the work chain will perform, all "
"of which a work function does not have. The outline in this example was "
"trivially simple, but the :ref:`advanced work chain development "
"section<working_workchains>` will show how complex logic can be implemented "
"directly in the process specification. The process specification also makes "
"it easy to 'wrap' existing work chains into more complex work chains through"
" the :ref:`expose functionality<working_workchains_expose_inputs_outputs>`."
msgstr ""

#: ../docs/source/concepts/workflows.rst:183
msgid ""
"Finally, as mentioned before, the work chain provides the possibility of "
"checkpoints, i.e. to save progress at certain points from which the "
"computation can be continued after it had been interrupted. The state of the"
" work chain is saved after each outline step. If expensive calculation jobs "
"are performed in an individual outline step, they will be saved as soon as "
"they finish. This is impossible for work functions, and if it were to be "
"interrupted before *all* the computations had been completed, all "
"intermediate progress would be lost. The rule of thumb therefore is, as soon"
" as the worfklow becomes only slightly complex or computationally intensive,"
" preference should be given to :ref:`work chains<concepts_workchains>` and "
":ref:`calculation jobs<concepts_calcjobs>`."
msgstr ""

#: ../docs/source/concepts/workflows.rst:189
msgid ""
"This was a very quick overview of the intended use of work chains and how "
"they work, but of course they have a lot more features. To learn how to "
"write work chains for real life problems, continue reading at the :ref:`work"
" chain development<working_workchains>` section, but before you do, read the"
" following part on when to use a work function and when it is better to use "
"a work chain."
msgstr ""

#: ../docs/source/concepts/workflows.rst:194
msgid "When to use which"
msgstr "When to use which"

#: ../docs/source/concepts/workflows.rst:195
msgid ""
"Now that we know how the two workflow components, work functions and work "
"chains, work in AiiDA, you might wonder: when should I use which one? For "
"simple operations that do not take long, the simplicity of the work function"
" may be all you need, so by all means use it. However, a good rule of thumb "
"is that as soon as the code is expected to take longer, for example when you"
" want to launch a :ref:`calculation job<concepts_calcjobs>` or another "
"complex workflow, it is always best to go for the work chain. The automatic "
"checkpointing, which guarantees that work between steps is saved, becomes "
"very important. But the work chain offers a lot more features than just "
"checkpointing that may make it more preferable over the work function, which"
" you can read about in the advanced :ref:`work chain development "
"<working_workchains>` section."
msgstr ""
"现在，我们已经知道工作流函数和工作链这两个工作流组建如何在AiiDA中工作。你可能会向：如何选择什么时候使用其中的哪一个？对于耗时不长的简单运算，工作函数的简洁可能是你需要的，那么无论如何请使用工作函数。但有时，整个i运算会耗费大量时间，比如你想要开启一个"
" :ref:`calculation job<concepts_calcjobs>` "
"或者另一个复杂的工作流，此时工作链都是更好的选择。它自动含有检查点，能够保证在不同的执行步骤之间保存状态。而且工作链还提供了除此之外比工作函数更多的特性，"
" 你可以参考 :ref:`工作链开发 <working_workchains>` 章节。"
