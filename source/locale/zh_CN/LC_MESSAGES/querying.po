# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2019, ECOLE POLYTECHNIQUE FEDERALE DE LAUSANNE (Theory and Simulation of Materials (THEOS) and National Centre for Computational Design and Discovery of Novel Materials (NCCR MARVEL)), Switzerland and ROBERT BOSCH LLC, USA. All rights reserved
# This file is distributed under the same license as the AiiDA package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: AiiDA 1.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-07-16 20:22+0000\n"
"PO-Revision-Date: 2019-05-17 20:01+0000\n"
"Language-Team: Chinese (China) (https://www.transifex.com/aiidateam/teams/98967/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../docs/source/querying/backend.rst:2
msgid "Directly querying in Django"
msgstr ""

#: ../docs/source/querying/backend.rst:3
msgid ""
"If you know how AiiDA stores the data internally in the database, you can "
"directly use Django to query the database (or even use directly SQL "
"commands, if you really feel the urge to do so). Documentation on how "
"queries work in Django can be found on the `official Django documentation "
"<https://docs.djangoproject.com/en/1.7/topics/db/queries/>`_. The models can"
" be found in :py:mod:`aiida.backends.djsite.db.models` and is directly "
"accessible as ``models`` in the ``verdi shell`` via ``verdi run``."
msgstr ""

#: ../docs/source/querying/backend.rst:11
msgid "Directly querying in SQLAlchemy"
msgstr ""

#: ../docs/source/querying/backend.rst:13
msgid ""
"Check out the documentation on <http://www.sqlalchemy.org/>. Models  are in "
":py:mod:`aiida.backends.sqlalchemy.models`"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:4
msgid "The appender method"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:7
msgid "Selecting entities"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:9
msgid ""
"Let's suppose you want to query for calculation nodes in your database::"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:16
msgid ""
"Calculations are more tricky than Data, since they have both a run-time "
"``Process`` that steers them and a ``Node`` that stores their metadata in "
"the database. The QueryBuilder allows you to pass either the ``Node`` class "
"(e.g. ``CalcJobNode``) or the ``Process`` class (e.g. ``CalcJob``, "
"``PwCalculation``), which will automatically apply the correct filters for "
"the type of calculation."
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:22
msgid ""
"If you are interested in instances of different classes, you can also pass a"
" tuple, list or set of classes. However, they have to be of the same ORM-"
"type (e.g. all have to be subclasses of Node)::"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:31
msgid "Retrieving results"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:33
msgid ""
"Let's suppose that's what we want to query for (all job calculations in the "
"database). The question is how to get the results from the query::"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:56
msgid ""
"Generators are useful if you have to retrieve a very large (>10000) number "
"of results. This will retrieve the data in batches, and you can start "
"working with the data before the query has completely finished. Be aware "
"that if using generators, you should never commit (store) anything while "
"iterating. The query is still going on, and might be compromised by new data"
" in the database."
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:64
msgid "Filtering"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:67
msgid ""
"Since we now know how to set an entity, we can start to filter by properties"
" of that entity. Suppose we do not want to all CalcJobNodes, but only the "
"ones in state 'FINISHED'::"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:79
msgid ""
"How, can we have multiple filters? Suppose you are interested in all "
"calculations in your database that are in state 'FINISHED' and were created "
"in the last *n* days::"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:99
msgid ""
"Let's go through the above example. We have instantiated QueryBuilder "
"instance. We appended to its path a CalcJobNode (a remote calculation), and "
"specified that we are only interested in  calculations that have finished "
"**and** that were created in the last *n* days."
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:105
msgid ""
"What if we want calculations that have finished **or** were created in the "
"last *n* days::"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:120
msgid ""
"If we had written *and* instead of *or*, we would have created the exact "
"same query as in the first query, because *and* is the default behavior if "
"you attach several filters. What if you want calculation in state 'FINISHED'"
" or 'EXCEPTED'? This will be the next example::"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:135
msgid ""
"In order to negate a filter, that is to apply the not operator, precede the "
"filter keyword with an exclamation mark. So, to ask for all calculations "
"that are not in 'FINISHED' or 'EXCEPTED'::"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:149
msgid ""
"The above rule applies strictly! You check a non-equality with !==, since "
"this is the equality operator (==) with a negation prepended."
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:152
msgid "This is a list of all implemented operators:"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:155
#: ../docs/source/querying/querybuilder/append.rst:185
msgid "**Operator**"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:155
#: ../docs/source/querying/querybuilder/append.rst:185
msgid "**Datatype**"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:155
#: ../docs/source/querying/querybuilder/append.rst:185
msgid "**Example**"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:155
#: ../docs/source/querying/querybuilder/append.rst:185
msgid "Explanation"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:157
msgid "=="
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:157
#: ../docs/source/querying/querybuilder/append.rst:159
msgid "All"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:157
msgid "'id':{'==':123}"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:157
msgid "Checks equality"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:159
msgid "in"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:159
msgid "'name':{'in':['foo', 'bar']}"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:159
msgid "equal to any element"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:161
msgid ">,<,<=,>="
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:161
msgid "floats, integers, dates"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:161
msgid "'ctime':{'<':datetime(2016, 03, 03)}"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:161
msgid "lower/greater (equal)"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:165
msgid "like"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:165
#: ../docs/source/querying/querybuilder/append.rst:170
msgid "Strings"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:165
msgid "'name':{'like':'lovely_calc%'}"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:165
msgid ""
"substring (% and _ are wildcards. To use % and _ as part of the string "
"prepend it with \\\\)"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:170
msgid "ilike"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:170
msgid "'name':{'ilike':'loVely_Calc%'}"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:170
msgid "case insensitive 'like'"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:172
msgid "or"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:172
#: ../docs/source/querying/querybuilder/append.rst:175
msgid "list of expressions"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:172
msgid "'id':{'or':[{'<':12}, {'==':199}]}"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:175
msgid "and"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:175
msgid "'id':{'and':[{'<':12}, {'>':1 }]}"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:179
msgid "There are also some advanced operators:"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:187
msgid "has_key"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:187
msgid "dicts"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:0
msgid "'attributes.mykey':{'has_key': 'foo'}"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:0
msgid "'extras':{'has_key': 'my_extra'}"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:187
msgid ""
"Check that a dictionary (typically stored in the attributes or in the "
"extras) has a given key. This can also be used to check if a given attribute"
" or extra exists."
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:194
msgid "of_type"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:194
msgid "any"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:0
msgid "'attributes.mykey':{'of_type': 'bool'}"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:194
msgid ""
"Check that an attribute or an extra is of a given type. Valid types are: "
"``object`` (meaning a dictionary), ``array`` (meaning a list), ``string``, "
"``number`` (both for integers and floats), ``boolean`` or ``null``) "
"**(currently implemented only in the SQLA backend)**"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:204
msgid "of_length"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:204
#: ../docs/source/querying/querybuilder/append.rst:210
#: ../docs/source/querying/querybuilder/append.rst:217
#: ../docs/source/querying/querybuilder/append.rst:224
msgid "lists"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:0
msgid "'attributes.mylist': {'of_length': 4}"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:204
msgid ""
"Check that a list (typically stored in the attributes or in the extras) has "
"a given length **(currently implemented only in the SQLA backend)**"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:210
msgid "shorter"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:0
msgid "'attributes.mylist': {'shorter': 4}"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:210
msgid ""
"Check that a list (typically stored in the attributes or in the extras) has "
"a length shorter than the specified value **(currently implemented only in "
"the SQLA backend)**"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:217
msgid "longer"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:0
msgid "'attributes.mylist': {'longer': 4}"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:217
msgid ""
"Check that a list (typically stored in the attributes or in the extras) has "
"a length longer than the specified value **(currently implemented only in "
"the SQLA backend)**"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:224
msgid "contains"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:0
msgid "'attributes.mykey': {'contains': ['a','b']}"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:224
msgid ""
"Check that a list (typically stored in the attributes or in the extras) "
"contains some specific elements or values **(currently implemented only in "
"the SQLA backend)**"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:233
msgid ""
"This showed you how to 'filter' by properties of a node. So far we can do "
"that for a single a single node in the database."
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:238
msgid "Joining entities"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:240
msgid ""
"But we sometimes need to query relationships in graph-like database. Let's "
"join a node to its output, e.g. StructureData and CalcJobNode (as output)::"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:247
msgid ""
"In above example we are querying structures and calculations, with the "
"predicate that the calculation is an output of the structure (the same as "
"saying that the structure is an input to the calculation) In the above "
"example, we have first appended StructureData to the path. So that we can "
"refer to that vertice later, we *tag* it with a unique keyword of our "
"choice, which can be used only once. When we append another vertice to the "
"path, we specify the relationship to a previous entity by using one of the "
"keywords in the above table and as a value the tag of the vertice that it "
"has a relationship with. There are several relationships that entities in "
"Aiida can have:"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:258
msgid "**Entity from**"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:258
msgid "**Entity to**"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:258
msgid "**Relationship**"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:258
msgid "**Explanation**"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:260
#: ../docs/source/querying/querybuilder/append.rst:260
#: ../docs/source/querying/querybuilder/append.rst:262
#: ../docs/source/querying/querybuilder/append.rst:262
#: ../docs/source/querying/querybuilder/append.rst:264
#: ../docs/source/querying/querybuilder/append.rst:264
#: ../docs/source/querying/querybuilder/append.rst:266
#: ../docs/source/querying/querybuilder/append.rst:266
#: ../docs/source/querying/querybuilder/append.rst:268
#: ../docs/source/querying/querybuilder/append.rst:270
#: ../docs/source/querying/querybuilder/append.rst:272
#: ../docs/source/querying/querybuilder/append.rst:274
#: ../docs/source/querying/querybuilder/append.rst:276
#: ../docs/source/querying/querybuilder/append.rst:278
#: ../docs/source/querying/querybuilder/append.rst:284
#: ../docs/source/querying/querybuilder/append.rst:289
msgid "Node"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:260
msgid "*with_outgoing*"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:260
msgid "One node as input of another node"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:262
msgid "*with_incoming*"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:262
msgid "One node as output of another node"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:264
msgid "*with_descendants*"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:264
msgid "One node as the ancestor of another node (Path)"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:266
msgid "*with_ancestors*"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:266
msgid "One node as descendant of another node (Path)"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:268
#: ../docs/source/querying/querybuilder/append.rst:270
#: ../docs/source/querying/querybuilder/append.rst:280
#: ../docs/source/querying/querybuilder/append.rst:282
msgid "Group"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:268
#: ../docs/source/querying/querybuilder/append.rst:272
#: ../docs/source/querying/querybuilder/append.rst:276
#: ../docs/source/querying/querybuilder/append.rst:284
msgid "*with_node*"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:268
msgid "The group of a node"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:270
#: ../docs/source/querying/querybuilder/append.rst:282
msgid "*with_group*"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:270
msgid "The node is a member of a group"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:272
#: ../docs/source/querying/querybuilder/append.rst:274
msgid "Computer"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:272
msgid "The computer of a node"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:274
msgid "*with_computer*"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:274
msgid "The node of a computer"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:276
#: ../docs/source/querying/querybuilder/append.rst:278
#: ../docs/source/querying/querybuilder/append.rst:280
#: ../docs/source/querying/querybuilder/append.rst:282
#: ../docs/source/querying/querybuilder/append.rst:291
#: ../docs/source/querying/querybuilder/append.rst:293
msgid "User"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:276
msgid "The creator of a node is a user"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:278
#: ../docs/source/querying/querybuilder/append.rst:280
#: ../docs/source/querying/querybuilder/append.rst:291
msgid "*with_user*"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:278
#: ../docs/source/querying/querybuilder/append.rst:280
#: ../docs/source/querying/querybuilder/append.rst:282
msgid "The node was created by a user"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:284
msgid "Log"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:284
msgid "The log of a node"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:286
msgid "Log Node"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:286
msgid "Node Comment"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:286
msgid "*with_log* *with_node*"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:286
msgid "The node has a log The comment of a node"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:289
#: ../docs/source/querying/querybuilder/append.rst:291
#: ../docs/source/querying/querybuilder/append.rst:293
msgid "Comment"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:289
#: ../docs/source/querying/querybuilder/append.rst:293
msgid "*with_comment*"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:289
msgid "The node has a comment"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:291
msgid "The comment was created by a user"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:293
msgid "The creator of a comment is a user"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:297
msgid "Some more examples::"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:320
msgid ""
"The above QueryBuilder will join a structure to all its descendants via the "
"transitive closure table."
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:326
msgid "Defining the projections"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:328
msgid ""
"But what will the query return exactly? If you try any of the examples, you "
"will find that the instances of the last appended vertice appear! That is "
"the default behavior if nothing else was specified. We usually do not want "
"everything returned because it might lead to a big overhead. You need to "
"specify what you want to return using the keyword *project*."
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:334
msgid "Let's stick to the previous example::"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:350
msgid ""
"In the above example, executing the query returns the type and the id of all"
" Node that are descendants of the structure::"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:382
msgid "results in the following output::"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:405
msgid ""
"Asking only for the properties that you are interested in can result in much"
" faster queries. If you want the Aiida-ORM instance, add '*' to your list of"
" projections::"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:436
#: ../docs/source/querying/querybuilder/append.rst:474
msgid "Output::"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:460
msgid ""
"Be aware that, for consistency, QueryBuilder.all / iterall always returns a "
"list of lists, and first always a list, even if you project on one entity!"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:465
msgid ""
"If you are not sure which keys to ask for, you can project with '**', and "
"the QueryBuilder instance will return all column properties::"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:494
msgid "Attributes and extras"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:496
msgid ""
"You should know by now that you can define additional properties of nodes in"
" the *attributes* and the *extras* of a node. There will be many cases where"
" you will either want to filter or project on those entities. The following "
"example gives us a PwCalculation where the cutoff for the wavefunctions has "
"a value above 30.0 Ry::"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:515
msgid ""
"The above examples filters by a certain attribute. Notice how you expand "
"into the dictionary using the dot (.). That works the same for the extras."
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:520
msgid ""
"Comparisons in the attributes (extras) are also implicitly done by type."
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:522
msgid ""
"Filtering or projecting on lists works similar to dictionaries. You expand "
"into the list using the dot (.) and afterwards adding the list-index. The "
"example below filters KpointsData by the first index in the mesh of "
"KpointsData=instance, and returns that same index in the list::"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:533
msgid ""
"Let's do a last example. You are familiar with the Quantum Espresso PWscf "
"tutorial? Great, because this will be our use case here. (If not, you can "
"find it on the `documentation of the aiida-quantumespresso package <http"
"://aiida-"
"quantumespresso.readthedocs.io/en/latest/user_guide/get_started/examples/pw_tutorial.html>`_."
" We will query for calculations that were done on a certain structure "
"(*mystructure*), that fulfill certain requirements, such as a cutoff above "
"30.0. In our case, we have a structure (an instance of StructureData) and an"
" instance of Dict that are both inputs to a PwCalculation. You need to tell "
"the QueryBuilder that::"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:564
msgid "Cheats"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:567
msgid "A few cheats to save some typing:"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:569
msgid ""
"The default edge specification, if no keyword is provided, is always "
"*with_incoming* the previous vertice."
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:571
msgid "Equality filters ('==') can be shortened, as will be shown below."
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:572
msgid ""
"Tags are not necessary, you can simply use the class as a label. This works "
"as long as the same Aiida-class is not used again"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:575
msgid "A shorter version of the previous example::"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:594
msgid "Advanced usage"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:596
msgid ""
"Let's proceed to some more advanced stuff. If you've understood everything "
"so far you're in good shape to query the database, so you can skip the rest "
"if you want."
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:700
msgid "Working with edges"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:702
msgid ""
"Another feature that had to be added are projections, filters and labels on "
"the edges of the graphs, that is to say links or paths between nodes. It "
"works the same way, just that the keyword is preceeded by '*link*'. Let's "
"take the above example, but put a filter on the label of the link and "
"project the link label::"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:723
msgid "Ordering results"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:726
msgid ""
"You can also order by properties of the node, although ordering by "
"attributes or extras is not implemented yet. Assuming you want to order the "
"above example by the time of the calculations::"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:745
msgid "Limiting the number of results"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:747
msgid ""
"You can also limit the number of rows returned with the method *limit*::"
msgstr ""

#: ../docs/source/querying/querybuilder/append.rst:766
msgid ""
"The above query returns the latest 10 calculation that produced a final "
"energy above -5.0."
msgstr ""

#: ../docs/source/querying/querybuilder/intro.rst:4
msgid "About the QueryBuilder"
msgstr ""

#: ../docs/source/querying/querybuilder/intro.rst:9
msgid ""
"The QueryBuilder lets you query your AiiDA database independently of the "
"backend used under the hood. Before starting to write a query, it helps to:"
msgstr ""

#: ../docs/source/querying/querybuilder/intro.rst:12
msgid ""
"know what you want to query for. In database-speek, you need to tell the "
"backend what to *project*. For example, you might be interested in the label"
" of a calculation and the pks of all its outputs."
msgstr ""

#: ../docs/source/querying/querybuilder/intro.rst:15
msgid ""
"know the relationships between entities you are interested in. Nodes of an "
"AiiDA graph (vertices) are connected with links (edges). A *Node* can be "
"either input or output of another *Node*, but also an ancestor or a "
"descendant."
msgstr ""

#: ../docs/source/querying/querybuilder/intro.rst:19
msgid "know what how you want to filter the result."
msgstr ""

#: ../docs/source/querying/querybuilder/intro.rst:21
msgid ""
"Once you are clear about what you want and how you can get it, the "
"QueryBuilder will build an SQL-query for you."
msgstr ""

#: ../docs/source/querying/querybuilder/intro.rst:24
msgid "There are two ways of using the QueryBuilder:"
msgstr ""

#: ../docs/source/querying/querybuilder/intro.rst:26
msgid ""
"In the :ref:`appender method <QueryBuilderAppend>`, you construct your query"
" step by step using `QueryBuilder.append()`"
msgstr ""

#: ../docs/source/querying/querybuilder/intro.rst:27
msgid ""
"In the :ref:`queryhelp approach <QueryBuilderQueryhelp>`, you construct a "
"dictionary first and pass it to the QueryBuilder"
msgstr ""

#: ../docs/source/querying/querybuilder/intro.rst:29
msgid ""
"Both APIs provide the same functionality - the appender method may be more "
"suitable for everyday use in the ``verdi shell``, while the queryhelp method"
" can be useful in scripting."
msgstr ""

#: ../docs/source/querying/querybuilder/queryhelp.rst:4
msgid "The queryhelp"
msgstr ""

#: ../docs/source/querying/querybuilder/queryhelp.rst:6
msgid ""
"As mentioned above, there are two possibilities to tell the QueryBuilder "
"what to do. The second uses one big dictionary that we can call the "
"queryhelp in the following. It has the same functionalities as the appender "
"method. But you could save this dictionary in a JSON or in the database and "
"use it over and over. Using the queryhelp, you have to specify the path, the"
" filter and projections beforehand and instantiate the QueryBuilder with "
"that dictionary::"
msgstr ""

#: ../docs/source/querying/querybuilder/queryhelp.rst:15
msgid "What do you have to specify:"
msgstr ""

#: ../docs/source/querying/querybuilder/queryhelp.rst:17
msgid ""
"Specifying the path: Here, the user specifies the path along which to join "
"tables as a list, each list item being a vertice in your path. You can "
"define the vertice in two ways: The first is to give the Aiida-class::"
msgstr ""

#: ../docs/source/querying/querybuilder/queryhelp.rst:35
msgid ""
"Another way is to give the polymorphic identity of this class, in our case "
"stored in type::"
msgstr ""

#: ../docs/source/querying/querybuilder/queryhelp.rst:44
msgid ""
"In Aiida, polymorphism is not strictly enforced, but done with *type* "
"specification. Type-discrimination when querying is achieved by attaching a "
"filter on the type every time a subclass of Node is given."
msgstr ""

#: ../docs/source/querying/querybuilder/queryhelp.rst:49
msgid ""
"Each node has to have a unique tag. If not given, the tag is chosen to be "
"equal to the name of the class. This will not work if the user chooses the "
"same class twice. In this case he has to provide the tag::"
msgstr ""

#: ../docs/source/querying/querybuilder/queryhelp.rst:67
msgid ""
"There also has to be some information on the edges, in order to join "
"correctly. There are several redundant ways this can be done:"
msgstr ""

#: ../docs/source/querying/querybuilder/queryhelp.rst:71
msgid ""
"You can specify that this node is an input or output of another node "
"preceding the current one in the list. That other node can be specified by "
"an integer or the class or type. The following examples are all valid "
"joining instructions, assuming there is a structure defined at index 2 of "
"the path with tag \"struc1\"::"
msgstr ""

#: ../docs/source/querying/querybuilder/queryhelp.rst:87
msgid "queryhelp_item['direction'] = integer"
msgstr ""

#: ../docs/source/querying/querybuilder/queryhelp.rst:89
msgid ""
"If any of the above specs (\"with_outgoing\", \"with_incoming\") were not "
"specified, the key \"direction\" is looked for. Directions are defined as "
"distances in the tree. 1 is defined as one step down the tree along a link. "
"This means that 1 joins the node specified in this dictionary to the node "
"specified on list-item before **as an output**. Direction defaults to 1, "
"which is why, if nothing is specified, this node is joined to the previous "
"one as an output by default. A minus sign reverse the direction of the link."
" The absolute value of the direction defines the table to join to with "
"respect to your own position in the list. An absolute value of 1 joins one "
"table above, a value of 2 to the table defined 2 indices above. The two "
"following queryhelps yield the same  query::"
msgstr ""

#: ../docs/source/querying/querybuilder/queryhelp.rst:146
msgid "Project: Determing which columns the query will return::"
msgstr ""

#: ../docs/source/querying/querybuilder/queryhelp.rst:155
msgid ""
"If you are using JSONB columns, you can also project a value stored inside "
"the json::"
msgstr ""

#: ../docs/source/querying/querybuilder/queryhelp.rst:168
msgid ""
"Returns the state and the id of all instances of Relax where a structures is"
" linked as output of a relax-calculation. The strings that you pass have to "
"be name of the columns. If you pass a star ('*'), the query will return the "
"instance of the AiidaClass."
msgstr ""

#: ../docs/source/querying/querybuilder/queryhelp.rst:174
msgid ""
"Filters: What if you want not every structure, but only the ones that were "
"added after a certain time `t` and have an id higher than 50::"
msgstr ""

#: ../docs/source/querying/querybuilder/queryhelp.rst:309
msgid ""
"If you want to include filters and projections on links between nodes, you "
"will have to add these to filters and projections in the queryhelp. Let's "
"take an example that we had and add a few filters on the link::"
msgstr ""

#: ../docs/source/querying/querybuilder/queryhelp.rst:335
msgid ""
"Notice that the tag for the link, by default, is the tag of the two "
"connecting nodes delimited by two dashes '--'. The order does not matter, "
"the following queryhelp would results in the same query::"
msgstr ""

#: ../docs/source/querying/querybuilder/queryhelp.rst:361
msgid ""
"If you dislike that way to tag the link, you can choose the tag for the edge"
" in the path when definining the entity to join using ``edge_tag``::"
msgstr ""

#: ../docs/source/querying/querybuilder/queryhelp.rst:391
msgid "You can set a limit and an offset in the queryhelp::"
msgstr ""

#: ../docs/source/querying/querybuilder/queryhelp.rst:399
msgid ""
"That queryhelp would tell the QueryBuilder to return 10 rows after the first"
" 20 have been skipped."
msgstr ""
