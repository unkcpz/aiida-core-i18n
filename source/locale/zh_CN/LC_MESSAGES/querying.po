# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2019, ECOLE POLYTECHNIQUE FEDERALE DE LAUSANNE (Theory and Simulation of Materials (THEOS) and National Centre for Computational Design and Discovery of Novel Materials (NCCR MARVEL)), Switzerland and ROBERT BOSCH LLC, USA. All rights reserved
# This file is distributed under the same license as the AiiDA package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Jianxing Huang <jx.huang.x@gmail.com>, 2019
# Jason.Eu <morty.yu@yahoo.com>, 2019
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: AiiDA 1.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-07-16 20:22+0000\n"
"PO-Revision-Date: 2019-05-17 20:01+0000\n"
"Last-Translator: Jason.Eu <morty.yu@yahoo.com>, 2019\n"
"Language-Team: Chinese (China) (https://www.transifex.com/aiidateam/teams/98967/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../docs/source/querying/backend.rst:2
msgid "Directly querying in Django"
msgstr "直接用Django查询"

#: ../docs/source/querying/backend.rst:3
msgid ""
"If you know how AiiDA stores the data internally in the database, you can "
"directly use Django to query the database (or even use directly SQL "
"commands, if you really feel the urge to do so). Documentation on how "
"queries work in Django can be found on the `official Django documentation "
"<https://docs.djangoproject.com/en/1.7/topics/db/queries/>`_. The models can"
" be found in :py:mod:`aiida.backends.djsite.db.models` and is directly "
"accessible as ``models`` in the ``verdi shell`` via ``verdi run``."
msgstr ""
"若你知道AiiDA是如何将数据存储在数据库中的话，你可以直接使用Django来查询数据（如有必要，也可以更进一步直接使用SQL命令来访问）。相关的操作方法可以在"
" `Django官方文档 <https://docs.djangoproject.com/en/1.7/topics/db/queries/>` "
"中找到。涉及的模块可以在 :py:mod:`aiida.backends.djsite.db.models` 中找到，可以直接通过 ``verdi "
"run`` 命令调用 ``verdi shell`` 来访问 ``models``  。"

#: ../docs/source/querying/backend.rst:11
msgid "Directly querying in SQLAlchemy"
msgstr "直接用SQLAlchemy查询"

#: ../docs/source/querying/backend.rst:13
msgid ""
"Check out the documentation on <http://www.sqlalchemy.org/>. Models  are in "
":py:mod:`aiida.backends.sqlalchemy.models`"
msgstr ""
"请参阅 <http://www.sqlalchemy.org/> 网站上的文档。涉及的模块包含在 "
":py:mod:`aiida.backends.sqlalchemy.models` 中。"

#: ../docs/source/querying/querybuilder/append.rst:4
msgid "The appender method"
msgstr "附加器（appender）方法"

#: ../docs/source/querying/querybuilder/append.rst:7
msgid "Selecting entities"
msgstr "选取实体"

#: ../docs/source/querying/querybuilder/append.rst:9
msgid ""
"Let's suppose you want to query for calculation nodes in your database::"
msgstr "假设你的需求是在数据库中查询算例节点（calculation nodes）。"

#: ../docs/source/querying/querybuilder/append.rst:16
msgid ""
"Calculations are more tricky than Data, since they have both a run-time "
"``Process`` that steers them and a ``Node`` that stores their metadata in "
"the database. The QueryBuilder allows you to pass either the ``Node`` class "
"(e.g. ``CalcJobNode``) or the ``Process`` class (e.g. ``CalcJob``, "
"``PwCalculation``), which will automatically apply the correct filters for "
"the type of calculation."
msgstr ""
"由于算例会比数据更难处理，因为前者有一个运行时的``Process`` 控制它们、还有一个 ``Node`` "
"将它们的元数据存储在数据库中。一个QueryBuilder可以允许用户传入``Node`` 类（例如 ``CalcJobNode``）或者 "
"``Process`` 类 （例如 ``CalcJob`` 、 ``PwCalculation`` ），其可以自动应用正确的过滤器选取正确种类的计算。"

#: ../docs/source/querying/querybuilder/append.rst:22
msgid ""
"If you are interested in instances of different classes, you can also pass a"
" tuple, list or set of classes. However, they have to be of the same ORM-"
"type (e.g. all have to be subclasses of Node)::"
msgstr "若你需要查询不同类的实例，你也可以传入一个类的元组、列表或集合。然而，这些类需要具有相同的ORM类型（比如他们都是Node的子类）。"

#: ../docs/source/querying/querybuilder/append.rst:31
msgid "Retrieving results"
msgstr "处理查询结果"

#: ../docs/source/querying/querybuilder/append.rst:33
msgid ""
"Let's suppose that's what we want to query for (all job calculations in the "
"database). The question is how to get the results from the query::"
msgstr "假设现在我们已经得到了所需要查询的（数据库中所有的算例工作），那么问题来了，如何从查询中得到所需要的结果呢？"

#: ../docs/source/querying/querybuilder/append.rst:56
msgid ""
"Generators are useful if you have to retrieve a very large (>10000) number "
"of results. This will retrieve the data in batches, and you can start "
"working with the data before the query has completely finished. Be aware "
"that if using generators, you should never commit (store) anything while "
"iterating. The query is still going on, and might be compromised by new data"
" in the database."
msgstr ""
"若你需要处理非常大量的数据（>10000条），生成器是很好用的工具。它将分批处理所有的数据，从而使用户可以在查询全部完成前使用工作所需的数据。但需注意，若使用生成器，在迭代过程中请不要提交（或储存）任何新的数据。因为查询仍在进行中，可能会受到数据库中新数据的影响。"

#: ../docs/source/querying/querybuilder/append.rst:64
msgid "Filtering"
msgstr "过滤"

#: ../docs/source/querying/querybuilder/append.rst:67
msgid ""
"Since we now know how to set an entity, we can start to filter by properties"
" of that entity. Suppose we do not want to all CalcJobNodes, but only the "
"ones in state 'FINISHED'::"
msgstr ""
"由于我们已经知道如何定义一个实例，我们可以根据其属性来过滤所需的实例。假设我们只希望得到处在完成（即 'FINISHED' "
"）状态的算例节点（CalcJobNodes）::"

#: ../docs/source/querying/querybuilder/append.rst:79
msgid ""
"How, can we have multiple filters? Suppose you are interested in all "
"calculations in your database that are in state 'FINISHED' and were created "
"in the last *n* days::"
msgstr "如何实现多条件过滤呢？假设你现在想要查询数据库中所有处在 'FINISHED' 状态下、且在最近 *n* 天内创建的任务 ::"

#: ../docs/source/querying/querybuilder/append.rst:99
msgid ""
"Let's go through the above example. We have instantiated QueryBuilder "
"instance. We appended to its path a CalcJobNode (a remote calculation), and "
"specified that we are only interested in  calculations that have finished "
"**and** that were created in the last *n* days."
msgstr ""
"我们来回顾一下上面所提到的例子。我们实例化了一个QueryBuilder，添加了CalcJobNode（即一个远程算例）的路径，并指定了已完成 "
"**且** 在近 *n* 天内创建的条件来进行筛选。"

#: ../docs/source/querying/querybuilder/append.rst:105
msgid ""
"What if we want calculations that have finished **or** were created in the "
"last *n* days::"
msgstr "那么我们该怎样查询已完成 **或** 在近 *n* 天内创建的算例呢？"

#: ../docs/source/querying/querybuilder/append.rst:120
msgid ""
"If we had written *and* instead of *or*, we would have created the exact "
"same query as in the first query, because *and* is the default behavior if "
"you attach several filters. What if you want calculation in state 'FINISHED'"
" or 'EXCEPTED'? This will be the next example::"
msgstr ""
"若我们把 *or* 替换成 *and* "
"，我们将得到与第一个查询完全一致的结果，因为*and*是对添加多个过滤条件时的默认处理方式。而如果所需的算例是'FINISHED'状态或'EXCEPTED'状态的呢？请看接下来的例子::"

#: ../docs/source/querying/querybuilder/append.rst:135
msgid ""
"In order to negate a filter, that is to apply the not operator, precede the "
"filter keyword with an exclamation mark. So, to ask for all calculations "
"that are not in 'FINISHED' or 'EXCEPTED'::"
msgstr ""
"为了得到相反的查询筛选结果，需要使用否定操作符，即使用一个感叹号来排除过滤词。例如查询未处于'FINISHED'或'EXCEPTED'状态的算例::"

#: ../docs/source/querying/querybuilder/append.rst:149
msgid ""
"The above rule applies strictly! You check a non-equality with !==, since "
"this is the equality operator (==) with a negation prepended."
msgstr "以上的规则需严格应用！查询时使用的不等号写作!==，即相当于在等于号（==）前加一个否定符号。"

#: ../docs/source/querying/querybuilder/append.rst:152
msgid "This is a list of all implemented operators:"
msgstr "以下是全部可以使用的操作符::"

#: ../docs/source/querying/querybuilder/append.rst:155
#: ../docs/source/querying/querybuilder/append.rst:185
msgid "**Operator**"
msgstr "**操作符**"

#: ../docs/source/querying/querybuilder/append.rst:155
#: ../docs/source/querying/querybuilder/append.rst:185
msgid "**Datatype**"
msgstr "**适用数据类型**"

#: ../docs/source/querying/querybuilder/append.rst:155
#: ../docs/source/querying/querybuilder/append.rst:185
msgid "**Example**"
msgstr "**用法举例**"

#: ../docs/source/querying/querybuilder/append.rst:155
#: ../docs/source/querying/querybuilder/append.rst:185
msgid "Explanation"
msgstr "释义"

#: ../docs/source/querying/querybuilder/append.rst:157
msgid "=="
msgstr "=="

#: ../docs/source/querying/querybuilder/append.rst:157
#: ../docs/source/querying/querybuilder/append.rst:159
msgid "All"
msgstr "全部"

#: ../docs/source/querying/querybuilder/append.rst:157
msgid "'id':{'==':123}"
msgstr "'id':{'==':123}"

#: ../docs/source/querying/querybuilder/append.rst:157
msgid "Checks equality"
msgstr "检查等同性"

#: ../docs/source/querying/querybuilder/append.rst:159
msgid "in"
msgstr "in"

#: ../docs/source/querying/querybuilder/append.rst:159
msgid "'name':{'in':['foo', 'bar']}"
msgstr "'name':{'in':['foo', 'bar']}"

#: ../docs/source/querying/querybuilder/append.rst:159
msgid "equal to any element"
msgstr "等于任意元素"

#: ../docs/source/querying/querybuilder/append.rst:161
msgid ">,<,<=,>="
msgstr ">,<,<=,>="

#: ../docs/source/querying/querybuilder/append.rst:161
msgid "floats, integers, dates"
msgstr "浮点型、整型、日期"

#: ../docs/source/querying/querybuilder/append.rst:161
msgid "'ctime':{'<':datetime(2016, 03, 03)}"
msgstr "'ctime':{'<':datetime(2016, 03, 03)}"

#: ../docs/source/querying/querybuilder/append.rst:161
msgid "lower/greater (equal)"
msgstr "大于或小于（等于）"

#: ../docs/source/querying/querybuilder/append.rst:165
msgid "like"
msgstr "like"

#: ../docs/source/querying/querybuilder/append.rst:165
#: ../docs/source/querying/querybuilder/append.rst:170
msgid "Strings"
msgstr "字符串"

#: ../docs/source/querying/querybuilder/append.rst:165
msgid "'name':{'like':'lovely_calc%'}"
msgstr "'name':{'like':'lovely_calc%'}"

#: ../docs/source/querying/querybuilder/append.rst:165
msgid ""
"substring (% and _ are wildcards. To use % and _ as part of the string "
"prepend it with \\\\)"
msgstr "子字符串（%和_是通配符，若%和_是包含在查询字符串中，请用前置\\\\转义）"

#: ../docs/source/querying/querybuilder/append.rst:170
msgid "ilike"
msgstr "ilike"

#: ../docs/source/querying/querybuilder/append.rst:170
msgid "'name':{'ilike':'loVely_Calc%'}"
msgstr "'name':{'ilike':'loVely_Calc%'}"

#: ../docs/source/querying/querybuilder/append.rst:170
msgid "case insensitive 'like'"
msgstr "大小写不敏感的 'like'"

#: ../docs/source/querying/querybuilder/append.rst:172
msgid "or"
msgstr "or"

#: ../docs/source/querying/querybuilder/append.rst:172
#: ../docs/source/querying/querybuilder/append.rst:175
msgid "list of expressions"
msgstr "条件列表"

#: ../docs/source/querying/querybuilder/append.rst:172
msgid "'id':{'or':[{'<':12}, {'==':199}]}"
msgstr "'id':{'or':[{'<':12}, {'==':199}]}"

#: ../docs/source/querying/querybuilder/append.rst:175
msgid "and"
msgstr "and"

#: ../docs/source/querying/querybuilder/append.rst:175
msgid "'id':{'and':[{'<':12}, {'>':1 }]}"
msgstr "'id':{'and':[{'<':12}, {'>':1 }]}"

#: ../docs/source/querying/querybuilder/append.rst:179
msgid "There are also some advanced operators:"
msgstr "还有一些高级操作符 :"

#: ../docs/source/querying/querybuilder/append.rst:187
msgid "has_key"
msgstr "has_key"

#: ../docs/source/querying/querybuilder/append.rst:187
msgid "dicts"
msgstr "字典"

#: ../docs/source/querying/querybuilder/append.rst:0
msgid "'attributes.mykey':{'has_key': 'foo'}"
msgstr "'attributes.mykey':{'has_key': 'foo'}"

#: ../docs/source/querying/querybuilder/append.rst:0
msgid "'extras':{'has_key': 'my_extra'}"
msgstr "'extras':{'has_key': 'my_extra'}"

#: ../docs/source/querying/querybuilder/append.rst:187
msgid ""
"Check that a dictionary (typically stored in the attributes or in the "
"extras) has a given key. This can also be used to check if a given attribute"
" or extra exists."
msgstr "检查一个字典（典型的是存储在属性（attributes）或者额外信息（extras）中的）是否具有指定的key。"

#: ../docs/source/querying/querybuilder/append.rst:194
msgid "of_type"
msgstr "of_type"

#: ../docs/source/querying/querybuilder/append.rst:194
msgid "any"
msgstr "任意"

#: ../docs/source/querying/querybuilder/append.rst:0
msgid "'attributes.mykey':{'of_type': 'bool'}"
msgstr "'attributes.mykey':{'of_type': 'bool'}"

#: ../docs/source/querying/querybuilder/append.rst:194
msgid ""
"Check that an attribute or an extra is of a given type. Valid types are: "
"``object`` (meaning a dictionary), ``array`` (meaning a list), ``string``, "
"``number`` (both for integers and floats), ``boolean`` or ``null``) "
"**(currently implemented only in the SQLA backend)**"
msgstr ""
"检查属性或例外是否是给定的类型。有效的类型包括：``object`` （字典）、``array`` （列表）、``string`` 、 "
"``number`` （既包括整型也包括浮点型）、 ``boolean`` or ``null`` ）**（目前只包括SQLA后端提到的类型）**"

#: ../docs/source/querying/querybuilder/append.rst:204
msgid "of_length"
msgstr "of_length"

#: ../docs/source/querying/querybuilder/append.rst:204
#: ../docs/source/querying/querybuilder/append.rst:210
#: ../docs/source/querying/querybuilder/append.rst:217
#: ../docs/source/querying/querybuilder/append.rst:224
msgid "lists"
msgstr "列表"

#: ../docs/source/querying/querybuilder/append.rst:0
msgid "'attributes.mylist': {'of_length': 4}"
msgstr "'attributes.mylist': {'of_length': 4}"

#: ../docs/source/querying/querybuilder/append.rst:204
msgid ""
"Check that a list (typically stored in the attributes or in the extras) has "
"a given length **(currently implemented only in the SQLA backend)**"
msgstr "检查一个列表（典型的是存储在属性或额外信息中的）是否具有给定的长度 **（目前只包括SQLA后端提到的类型）**"

#: ../docs/source/querying/querybuilder/append.rst:210
msgid "shorter"
msgstr "shorter"

#: ../docs/source/querying/querybuilder/append.rst:0
msgid "'attributes.mylist': {'shorter': 4}"
msgstr "'attributes.mylist': {'shorter': 4}"

#: ../docs/source/querying/querybuilder/append.rst:210
msgid ""
"Check that a list (typically stored in the attributes or in the extras) has "
"a length shorter than the specified value **(currently implemented only in "
"the SQLA backend)**"
msgstr "检查一个列表（典型的是存储在属性或额外信息中的）是否短于给定的长度 **（目前只包括SQLA后端提到的类型）**"

#: ../docs/source/querying/querybuilder/append.rst:217
msgid "longer"
msgstr "longer"

#: ../docs/source/querying/querybuilder/append.rst:0
msgid "'attributes.mylist': {'longer': 4}"
msgstr "'attributes.mylist': {'longer': 4}"

#: ../docs/source/querying/querybuilder/append.rst:217
msgid ""
"Check that a list (typically stored in the attributes or in the extras) has "
"a length longer than the specified value **(currently implemented only in "
"the SQLA backend)**"
msgstr "检查一个列表（典型的是存储在属性或额外信息中的）是否长于给定的长度 **（目前只包括SQLA后端提到的类型）**"

#: ../docs/source/querying/querybuilder/append.rst:224
msgid "contains"
msgstr "contains"

#: ../docs/source/querying/querybuilder/append.rst:0
msgid "'attributes.mykey': {'contains': ['a','b']}"
msgstr "'attributes.mykey': {'contains': ['a','b']}"

#: ../docs/source/querying/querybuilder/append.rst:224
msgid ""
"Check that a list (typically stored in the attributes or in the extras) "
"contains some specific elements or values **(currently implemented only in "
"the SQLA backend)**"
msgstr "检查一个列表（典型的是存储在属性或额外信息中的）是否包含特定的元素或值 **（目前只包括SQLA后端提到的类型）**"

#: ../docs/source/querying/querybuilder/append.rst:233
msgid ""
"This showed you how to 'filter' by properties of a node. So far we can do "
"that for a single a single node in the database."
msgstr "以上展示了如何根据属性“过滤”节点，至此你可以对数据库中的单一节点执行此操作。"

#: ../docs/source/querying/querybuilder/append.rst:238
msgid "Joining entities"
msgstr "加入实体"

#: ../docs/source/querying/querybuilder/append.rst:240
msgid ""
"But we sometimes need to query relationships in graph-like database. Let's "
"join a node to its output, e.g. StructureData and CalcJobNode (as output)::"
msgstr ""
"但我们有时需要在类图形数据库中查询关系，因此需要在输出中加入节点，例如结构数据（StructureData）或算例节点（CalcJobNode，作为输出）::"

#: ../docs/source/querying/querybuilder/append.rst:247
msgid ""
"In above example we are querying structures and calculations, with the "
"predicate that the calculation is an output of the structure (the same as "
"saying that the structure is an input to the calculation) In the above "
"example, we have first appended StructureData to the path. So that we can "
"refer to that vertice later, we *tag* it with a unique keyword of our "
"choice, which can be used only once. When we append another vertice to the "
"path, we specify the relationship to a previous entity by using one of the "
"keywords in the above table and as a value the tag of the vertice that it "
"has a relationship with. There are several relationships that entities in "
"Aiida can have:"
msgstr ""
"在以上的例子中我们查询了结构和算例，其中算例是结构的输出（或者说结构是算例的输入）。在例子中，我们先在路径中引入了StructureData，因而可以稍后指定这个顶点，即用独特的关键词*标记*进而可再次使用。当我们指定另一个顶点时，我们可以上表中的一个关键词指定与前一实体的关系、或以标记指定对应的条件。以下是AiiDA中的实体支持的几种关系"
" ::"

#: ../docs/source/querying/querybuilder/append.rst:258
msgid "**Entity from**"
msgstr "**实体来源**"

#: ../docs/source/querying/querybuilder/append.rst:258
msgid "**Entity to**"
msgstr "**实体去向**"

#: ../docs/source/querying/querybuilder/append.rst:258
msgid "**Relationship**"
msgstr "**关系**"

#: ../docs/source/querying/querybuilder/append.rst:258
msgid "**Explanation**"
msgstr "**释义**"

#: ../docs/source/querying/querybuilder/append.rst:260
#: ../docs/source/querying/querybuilder/append.rst:260
#: ../docs/source/querying/querybuilder/append.rst:262
#: ../docs/source/querying/querybuilder/append.rst:262
#: ../docs/source/querying/querybuilder/append.rst:264
#: ../docs/source/querying/querybuilder/append.rst:264
#: ../docs/source/querying/querybuilder/append.rst:266
#: ../docs/source/querying/querybuilder/append.rst:266
#: ../docs/source/querying/querybuilder/append.rst:268
#: ../docs/source/querying/querybuilder/append.rst:270
#: ../docs/source/querying/querybuilder/append.rst:272
#: ../docs/source/querying/querybuilder/append.rst:274
#: ../docs/source/querying/querybuilder/append.rst:276
#: ../docs/source/querying/querybuilder/append.rst:278
#: ../docs/source/querying/querybuilder/append.rst:284
#: ../docs/source/querying/querybuilder/append.rst:289
msgid "Node"
msgstr "Node"

#: ../docs/source/querying/querybuilder/append.rst:260
msgid "*with_outgoing*"
msgstr "*with_outgoing*"

#: ../docs/source/querying/querybuilder/append.rst:260
msgid "One node as input of another node"
msgstr "一个节点作为另一个节点的输入"

#: ../docs/source/querying/querybuilder/append.rst:262
msgid "*with_incoming*"
msgstr "*with_incoming*"

#: ../docs/source/querying/querybuilder/append.rst:262
msgid "One node as output of another node"
msgstr "一个节点作为另一个节点的输出"

#: ../docs/source/querying/querybuilder/append.rst:264
msgid "*with_descendants*"
msgstr "*with_descendants*"

#: ../docs/source/querying/querybuilder/append.rst:264
msgid "One node as the ancestor of another node (Path)"
msgstr "一个节点作为另一个节点的始祖（Path）"

#: ../docs/source/querying/querybuilder/append.rst:266
msgid "*with_ancestors*"
msgstr "*with_ancestors*"

#: ../docs/source/querying/querybuilder/append.rst:266
msgid "One node as descendant of another node (Path)"
msgstr "一个节点作为另一个节点的后代（Path）"

#: ../docs/source/querying/querybuilder/append.rst:268
#: ../docs/source/querying/querybuilder/append.rst:270
#: ../docs/source/querying/querybuilder/append.rst:280
#: ../docs/source/querying/querybuilder/append.rst:282
msgid "Group"
msgstr "Group"

#: ../docs/source/querying/querybuilder/append.rst:268
#: ../docs/source/querying/querybuilder/append.rst:272
#: ../docs/source/querying/querybuilder/append.rst:276
#: ../docs/source/querying/querybuilder/append.rst:284
msgid "*with_node*"
msgstr "*with_node*"

#: ../docs/source/querying/querybuilder/append.rst:268
msgid "The group of a node"
msgstr "节点所在的组"

#: ../docs/source/querying/querybuilder/append.rst:270
#: ../docs/source/querying/querybuilder/append.rst:282
msgid "*with_group*"
msgstr "*with_group*"

#: ../docs/source/querying/querybuilder/append.rst:270
msgid "The node is a member of a group"
msgstr "组的成员节点"

#: ../docs/source/querying/querybuilder/append.rst:272
#: ../docs/source/querying/querybuilder/append.rst:274
msgid "Computer"
msgstr "Computer"

#: ../docs/source/querying/querybuilder/append.rst:272
msgid "The computer of a node"
msgstr "节点对应的计算机器"

#: ../docs/source/querying/querybuilder/append.rst:274
msgid "*with_computer*"
msgstr "*with_computer*"

#: ../docs/source/querying/querybuilder/append.rst:274
msgid "The node of a computer"
msgstr "计算机器包含的节点"

#: ../docs/source/querying/querybuilder/append.rst:276
#: ../docs/source/querying/querybuilder/append.rst:278
#: ../docs/source/querying/querybuilder/append.rst:280
#: ../docs/source/querying/querybuilder/append.rst:282
#: ../docs/source/querying/querybuilder/append.rst:291
#: ../docs/source/querying/querybuilder/append.rst:293
msgid "User"
msgstr "User"

#: ../docs/source/querying/querybuilder/append.rst:276
msgid "The creator of a node is a user"
msgstr "节点的创建用户"

#: ../docs/source/querying/querybuilder/append.rst:278
#: ../docs/source/querying/querybuilder/append.rst:280
#: ../docs/source/querying/querybuilder/append.rst:291
msgid "*with_user*"
msgstr "*with_user*"

#: ../docs/source/querying/querybuilder/append.rst:278
#: ../docs/source/querying/querybuilder/append.rst:280
#: ../docs/source/querying/querybuilder/append.rst:282
msgid "The node was created by a user"
msgstr "由用户创建的节点"

#: ../docs/source/querying/querybuilder/append.rst:284
msgid "Log"
msgstr "Log"

#: ../docs/source/querying/querybuilder/append.rst:284
msgid "The log of a node"
msgstr "节点的日志"

#: ../docs/source/querying/querybuilder/append.rst:286
msgid "Log Node"
msgstr "Log Node"

#: ../docs/source/querying/querybuilder/append.rst:286
msgid "Node Comment"
msgstr "Node Comment"

#: ../docs/source/querying/querybuilder/append.rst:286
msgid "*with_log* *with_node*"
msgstr "*with_log* *with_node*"

#: ../docs/source/querying/querybuilder/append.rst:286
msgid "The node has a log The comment of a node"
msgstr "包含日志的节点 节点的注释"

#: ../docs/source/querying/querybuilder/append.rst:289
#: ../docs/source/querying/querybuilder/append.rst:291
#: ../docs/source/querying/querybuilder/append.rst:293
msgid "Comment"
msgstr "Comment"

#: ../docs/source/querying/querybuilder/append.rst:289
#: ../docs/source/querying/querybuilder/append.rst:293
msgid "*with_comment*"
msgstr "*with_comment*"

#: ../docs/source/querying/querybuilder/append.rst:289
msgid "The node has a comment"
msgstr "包含注释的节点"

#: ../docs/source/querying/querybuilder/append.rst:291
msgid "The comment was created by a user"
msgstr "用户创建的注释"

#: ../docs/source/querying/querybuilder/append.rst:293
msgid "The creator of a comment is a user"
msgstr "创建注释的用户"

#: ../docs/source/querying/querybuilder/append.rst:297
msgid "Some more examples::"
msgstr "一些其他例子::"

#: ../docs/source/querying/querybuilder/append.rst:320
msgid ""
"The above QueryBuilder will join a structure to all its descendants via the "
"transitive closure table."
msgstr "以上的QueryBuilder将通过传递闭包表将结构信息加入到其所有的后代。"

#: ../docs/source/querying/querybuilder/append.rst:326
msgid "Defining the projections"
msgstr "定义映射"

#: ../docs/source/querying/querybuilder/append.rst:328
msgid ""
"But what will the query return exactly? If you try any of the examples, you "
"will find that the instances of the last appended vertice appear! That is "
"the default behavior if nothing else was specified. We usually do not want "
"everything returned because it might lead to a big overhead. You need to "
"specify what you want to return using the keyword *project*."
msgstr ""
"但查询准确地会返回什么呢？如果你尝试任何一个例子，你都会发现最后加入的顶点会出现！这便是没有其他指定的情况下的默认信息。我们通常不需要返回全部信息，因为那实在是太多了。我们需要用关键词*映射*来指定返回的结果。"

#: ../docs/source/querying/querybuilder/append.rst:334
msgid "Let's stick to the previous example::"
msgstr "回到前面的例子::"

#: ../docs/source/querying/querybuilder/append.rst:350
msgid ""
"In the above example, executing the query returns the type and the id of all"
" Node that are descendants of the structure::"
msgstr "在以上的例子中，执行查询返回的结果是结构信息的所有后代节点的类型和id::"

#: ../docs/source/querying/querybuilder/append.rst:382
msgid "results in the following output::"
msgstr "以下输出的结果::"

#: ../docs/source/querying/querybuilder/append.rst:405
msgid ""
"Asking only for the properties that you are interested in can result in much"
" faster queries. If you want the Aiida-ORM instance, add '*' to your list of"
" projections::"
msgstr "只指定感兴趣的性质可以更快地得到查询的结果。如果你想要Aiida-ORM的实例，在映射列表中加入'*' 符号 ::"

#: ../docs/source/querying/querybuilder/append.rst:436
#: ../docs/source/querying/querybuilder/append.rst:474
msgid "Output::"
msgstr "输出 ::"

#: ../docs/source/querying/querybuilder/append.rst:460
msgid ""
"Be aware that, for consistency, QueryBuilder.all / iterall always returns a "
"list of lists, and first always a list, even if you project on one entity!"
msgstr ""
"需要清醒地知道，为了一致性，QueryBuilder.all / iterall "
"通常会返回一个列表的列表，并且首先通常是一个列表，即使你指定了同一个映射！"

#: ../docs/source/querying/querybuilder/append.rst:465
msgid ""
"If you are not sure which keys to ask for, you can project with '**', and "
"the QueryBuilder instance will return all column properties::"
msgstr "如果你对需要查询的key不确定，你可以用 '**' 符号来映射，QueryBuilder实例可以返回全部属性的列 ::"

#: ../docs/source/querying/querybuilder/append.rst:494
msgid "Attributes and extras"
msgstr "属性（Attributes）和额外信息（extras）"

#: ../docs/source/querying/querybuilder/append.rst:496
msgid ""
"You should know by now that you can define additional properties of nodes in"
" the *attributes* and the *extras* of a node. There will be many cases where"
" you will either want to filter or project on those entities. The following "
"example gives us a PwCalculation where the cutoff for the wavefunctions has "
"a value above 30.0 Ry::"
msgstr ""
"需要知道，通过编辑 *attributes* 和 *extras* "
"，你可以定义节点的补充信息。有许多情况下你需要过滤或者映射这些实体。以下的例子给出了一个波函数截断半径在30.0 "
"Ry以上的PwCalculation::"

#: ../docs/source/querying/querybuilder/append.rst:515
msgid ""
"The above examples filters by a certain attribute. Notice how you expand "
"into the dictionary using the dot (.). That works the same for the extras."
msgstr "以上的例子显示了如何根据一个具体的属性来过滤结果。注意到你可以利用点符号（.）来扩展字典，并且这对于额外信息也是一样的。"

#: ../docs/source/querying/querybuilder/append.rst:520
msgid ""
"Comparisons in the attributes (extras) are also implicitly done by type."
msgstr "属性（或者额外信息）中的比较也被隐含在类型之中。"

#: ../docs/source/querying/querybuilder/append.rst:522
msgid ""
"Filtering or projecting on lists works similar to dictionaries. You expand "
"into the list using the dot (.) and afterwards adding the list-index. The "
"example below filters KpointsData by the first index in the mesh of "
"KpointsData=instance, and returns that same index in the list::"
msgstr ""
"过滤或映射操作对列表类似于对字典。你可以用点符号（.）来扩展列表然后增长列表索引。以下的例子展示了如何通过KpointsData=instance的网格的第一个索引过滤出特定KpointsData，然后返回列表的对应索引::"

#: ../docs/source/querying/querybuilder/append.rst:533
msgid ""
"Let's do a last example. You are familiar with the Quantum Espresso PWscf "
"tutorial? Great, because this will be our use case here. (If not, you can "
"find it on the `documentation of the aiida-quantumespresso package <http"
"://aiida-"
"quantumespresso.readthedocs.io/en/latest/user_guide/get_started/examples/pw_tutorial.html>`_."
" We will query for calculations that were done on a certain structure "
"(*mystructure*), that fulfill certain requirements, such as a cutoff above "
"30.0. In our case, we have a structure (an instance of StructureData) and an"
" instance of Dict that are both inputs to a PwCalculation. You need to tell "
"the QueryBuilder that::"
msgstr ""
"最后再举一例，该例子与Quantum Espresso PWscf教程中的使用案例息息相关（如果你还没有看过，请参阅  `aiida-"
"quantumespresso软件包文档 <http://aiida-"
"quantumespresso.readthedocs.io/en/latest/user_guide/get_started/examples/pw_tutorial.html>`_的相关内容）。我们将根据特定的要求查询完全满足需求的具有特定结构（*mystructure*）的计算，例如截断半径在30.0以上的。在我们的案例中，存在一个结构（StructureData的一个实例）和Dict的一个实例作为PwCalculation的输入。你需要告知QueryBuilder以下的信息::"

#: ../docs/source/querying/querybuilder/append.rst:564
msgid "Cheats"
msgstr "技巧"

#: ../docs/source/querying/querybuilder/append.rst:567
msgid "A few cheats to save some typing:"
msgstr "一些可以节省输入的技巧:"

#: ../docs/source/querying/querybuilder/append.rst:569
msgid ""
"The default edge specification, if no keyword is provided, is always "
"*with_incoming* the previous vertice."
msgstr "如果没有其他关键词，对与前一顶点间的边默认的关系是 *with_incoming* 。"

#: ../docs/source/querying/querybuilder/append.rst:571
msgid "Equality filters ('==') can be shortened, as will be shown below."
msgstr "等于（'=='）这一过滤条件可以被缩写，以下部分将会展示。"

#: ../docs/source/querying/querybuilder/append.rst:572
msgid ""
"Tags are not necessary, you can simply use the class as a label. This works "
"as long as the same Aiida-class is not used again"
msgstr "标记不是必要的，你可以简单地使用类作为标签。这一点是有效的，但对于同一Aiida-class不能被重复使用。"

#: ../docs/source/querying/querybuilder/append.rst:575
msgid "A shorter version of the previous example::"
msgstr "前述例子的简写版本 ::"

#: ../docs/source/querying/querybuilder/append.rst:594
msgid "Advanced usage"
msgstr "高级使用"

#: ../docs/source/querying/querybuilder/append.rst:596
msgid ""
"Let's proceed to some more advanced stuff. If you've understood everything "
"so far you're in good shape to query the database, so you can skip the rest "
"if you want."
msgstr "让我们进一步地来看一些高级应用。若你已经理解了以上的所有内容并已很擅长在数据库中查询，你可以跳过本节的剩余部分。"

#: ../docs/source/querying/querybuilder/append.rst:700
msgid "Working with edges"
msgstr "利用边"

#: ../docs/source/querying/querybuilder/append.rst:702
msgid ""
"Another feature that had to be added are projections, filters and labels on "
"the edges of the graphs, that is to say links or paths between nodes. It "
"works the same way, just that the keyword is preceeded by '*link*'. Let's "
"take the above example, but put a filter on the label of the link and "
"project the link label::"
msgstr ""
"另一个需要添加的特性是图的边的映射、过滤器、标签，即节点间的关联。这与 '*link*' "
"关键词的功能是一致的。我们回顾上面的例子，但这次增加link标签的过滤和映射::"

#: ../docs/source/querying/querybuilder/append.rst:723
msgid "Ordering results"
msgstr "排序结果"

#: ../docs/source/querying/querybuilder/append.rst:726
msgid ""
"You can also order by properties of the node, although ordering by "
"attributes or extras is not implemented yet. Assuming you want to order the "
"above example by the time of the calculations::"
msgstr ""
"你也可以根据属性函数排序节点，尽管根据属性（attributes）和额外信息（extras）的功能尚未支持。假设你需要根据算例的时间来排序以上的例子 "
"::"

#: ../docs/source/querying/querybuilder/append.rst:745
msgid "Limiting the number of results"
msgstr "限定结果数"

#: ../docs/source/querying/querybuilder/append.rst:747
msgid ""
"You can also limit the number of rows returned with the method *limit*::"
msgstr "你可用 *limit* 方法来限定结果的行数 ::"

#: ../docs/source/querying/querybuilder/append.rst:766
msgid ""
"The above query returns the latest 10 calculation that produced a final "
"energy above -5.0."
msgstr "以上的查询会返回最近的10个最终能量大于-5.0的算例。"

#: ../docs/source/querying/querybuilder/intro.rst:4
msgid "About the QueryBuilder"
msgstr "关于查询构建器（QueryBuilder）"

#: ../docs/source/querying/querybuilder/intro.rst:9
msgid ""
"The QueryBuilder lets you query your AiiDA database independently of the "
"backend used under the hood. Before starting to write a query, it helps to:"
msgstr "查询构建器可使你在不使用后端的情况下查询AiiDA的数据库。在我们开始写查询条件前，先来看它的功能:"

#: ../docs/source/querying/querybuilder/intro.rst:12
msgid ""
"know what you want to query for. In database-speek, you need to tell the "
"backend what to *project*. For example, you might be interested in the label"
" of a calculation and the pks of all its outputs."
msgstr "得到你想要查询的。用数据库的术语来说，你需要告诉后端需要 *映射* 什么。例如，你可能对算例的标签和其输出的pk号感兴趣。"

#: ../docs/source/querying/querybuilder/intro.rst:15
msgid ""
"know the relationships between entities you are interested in. Nodes of an "
"AiiDA graph (vertices) are connected with links (edges). A *Node* can be "
"either input or output of another *Node*, but also an ancestor or a "
"descendant."
msgstr ""
"知道你感兴趣的实体之间的关系。AiiDA图中的节点（顶点，即vertices）是由链接连结的（边，即edges）。一个 *节点* 可以作为另一个 "
"*节点* 的输入或输出，也可以是始祖或者后代。"

#: ../docs/source/querying/querybuilder/intro.rst:19
msgid "know what how you want to filter the result."
msgstr "知道你要怎样过滤结果。"

#: ../docs/source/querying/querybuilder/intro.rst:21
msgid ""
"Once you are clear about what you want and how you can get it, the "
"QueryBuilder will build an SQL-query for you."
msgstr "一旦你清楚地知道你需要什么、要怎样得到，查询构建器会帮助你建立一个SQL查询。"

#: ../docs/source/querying/querybuilder/intro.rst:24
msgid "There are two ways of using the QueryBuilder:"
msgstr "有两种使用查询构建器的方式:"

#: ../docs/source/querying/querybuilder/intro.rst:26
msgid ""
"In the :ref:`appender method <QueryBuilderAppend>`, you construct your query"
" step by step using `QueryBuilder.append()`"
msgstr ""
"在 :ref:`附加器方法 <QueryBuilderAppend>` 一节，你将利用`QueryBuilder.append()` "
"一步步地建立起你的查询"

#: ../docs/source/querying/querybuilder/intro.rst:27
msgid ""
"In the :ref:`queryhelp approach <QueryBuilderQueryhelp>`, you construct a "
"dictionary first and pass it to the QueryBuilder"
msgstr ""
"在 :ref:`查询助手方法 <QueryBuilderQueryhelp>` 一节，你将首先建立一个字典并把它传递给QueryBuilder。"

#: ../docs/source/querying/querybuilder/intro.rst:29
msgid ""
"Both APIs provide the same functionality - the appender method may be more "
"suitable for everyday use in the ``verdi shell``, while the queryhelp method"
" can be useful in scripting."
msgstr ""
"以上两种API都可以提供相同的功能——appender方法会更适用于通过 ``verdi shell`` "
"日常使用而queryhelp方法更适于写成脚本。"

#: ../docs/source/querying/querybuilder/queryhelp.rst:4
msgid "The queryhelp"
msgstr "查询助手（queryhelp）"

#: ../docs/source/querying/querybuilder/queryhelp.rst:6
msgid ""
"As mentioned above, there are two possibilities to tell the QueryBuilder "
"what to do. The second uses one big dictionary that we can call the "
"queryhelp in the following. It has the same functionalities as the appender "
"method. But you could save this dictionary in a JSON or in the database and "
"use it over and over. Using the queryhelp, you have to specify the path, the"
" filter and projections beforehand and instantiate the QueryBuilder with "
"that dictionary::"
msgstr ""
"正如上文所提到的那样，有两种方式可以告诉QueryBuilder你的需求。第二种方式则是用一个被称为查询助手（queryhelp）的比较大的字典。它与前文所述的appender有着相同的功能。但你可以将字典存在一个JSON或数据库中，从而可以多次使用。使用查询助手时，你必须预先指定路径、过滤器和映射并用这个字典将查询构建器实例化。"

#: ../docs/source/querying/querybuilder/queryhelp.rst:15
msgid "What do you have to specify:"
msgstr "你需要指定的内容如下 :"

#: ../docs/source/querying/querybuilder/queryhelp.rst:17
msgid ""
"Specifying the path: Here, the user specifies the path along which to join "
"tables as a list, each list item being a vertice in your path. You can "
"define the vertice in two ways: The first is to give the Aiida-class::"
msgstr ""
"指定路径: 用户可以一个列表的形式指定所需的路径，列表中每一个元素均是一个顶点。你可以两种方式定义顶点: 第一种是给定AiiDA-class ::"

#: ../docs/source/querying/querybuilder/queryhelp.rst:35
msgid ""
"Another way is to give the polymorphic identity of this class, in our case "
"stored in type::"
msgstr "第二种方式是给定有相同多态的类，在我们的例子中是存储数据的类型::"

#: ../docs/source/querying/querybuilder/queryhelp.rst:44
msgid ""
"In Aiida, polymorphism is not strictly enforced, but done with *type* "
"specification. Type-discrimination when querying is achieved by attaching a "
"filter on the type every time a subclass of Node is given."
msgstr "在AiiDA中，多态性并不是被严格强制要求的，而是以 *类型* 来指定的。每次添加类型的过滤器时来建立查询时，会给出节点的一个子类。"

#: ../docs/source/querying/querybuilder/queryhelp.rst:49
msgid ""
"Each node has to have a unique tag. If not given, the tag is chosen to be "
"equal to the name of the class. This will not work if the user chooses the "
"same class twice. In this case he has to provide the tag::"
msgstr "每个节点都须有一个独特的标记。若未给出，标记即为类的名字。若指定同一个类两次，这一特性会消失。例如在以下例子中，用户须提供标记 ::"

#: ../docs/source/querying/querybuilder/queryhelp.rst:67
msgid ""
"There also has to be some information on the edges, in order to join "
"correctly. There are several redundant ways this can be done:"
msgstr "对edges，需要提供信息以便正确连接。有几种多余的方法可以做到这一点:"

#: ../docs/source/querying/querybuilder/queryhelp.rst:71
msgid ""
"You can specify that this node is an input or output of another node "
"preceding the current one in the list. That other node can be specified by "
"an integer or the class or type. The following examples are all valid "
"joining instructions, assuming there is a structure defined at index 2 of "
"the path with tag \"struc1\"::"
msgstr ""
"你可以在列表中的当前节点前指定该节点作为另一个节点的输入或输出，被指定的节点可由一个整数或其类、类型来确定。以下的例子均为成功的连接操作，假设存在一个结构被定义为标记为“struc1”的结构的索引2"
" ::"

#: ../docs/source/querying/querybuilder/queryhelp.rst:87
msgid "queryhelp_item['direction'] = integer"
msgstr "queryhelp_item['direction'] = 整数"

#: ../docs/source/querying/querybuilder/queryhelp.rst:89
msgid ""
"If any of the above specs (\"with_outgoing\", \"with_incoming\") were not "
"specified, the key \"direction\" is looked for. Directions are defined as "
"distances in the tree. 1 is defined as one step down the tree along a link. "
"This means that 1 joins the node specified in this dictionary to the node "
"specified on list-item before **as an output**. Direction defaults to 1, "
"which is why, if nothing is specified, this node is joined to the previous "
"one as an output by default. A minus sign reverse the direction of the link."
" The absolute value of the direction defines the table to join to with "
"respect to your own position in the list. An absolute value of 1 joins one "
"table above, a value of 2 to the table defined 2 indices above. The two "
"following queryhelps yield the same  query::"
msgstr ""
"若以上的 (\"with_outgoing\", \"with_incoming\") 均未被指定，键 \"direction\" "
"是一个解决方案。Direction被定义为树中的距离。1被定义为沿着链接向下走一步，这意味着1将字典中指定的节点作为输出连接到list-"
"item上指定的节点。Direction的值默认为1，因此如果未指定任何内容，默认情况下此节点将作为输出连接到前一个节点。减号可反转链接的方向。 "
"Direction的绝对值定义要连接到的表相对于指定的节点在列表中的位置。 "
"绝对值为1表示连接上面的一个表，2则表示连接到节点以上2个索引指定的表。接下来的两个queryhelp可以得到相同的查询 ::"

#: ../docs/source/querying/querybuilder/queryhelp.rst:146
msgid "Project: Determing which columns the query will return::"
msgstr "映射：指定查询返回的列 ::"

#: ../docs/source/querying/querybuilder/queryhelp.rst:155
msgid ""
"If you are using JSONB columns, you can also project a value stored inside "
"the json::"
msgstr "若你在使用JSONB列表，你也可以将存储在json中的数据映射::"

#: ../docs/source/querying/querybuilder/queryhelp.rst:168
msgid ""
"Returns the state and the id of all instances of Relax where a structures is"
" linked as output of a relax-calculation. The strings that you pass have to "
"be name of the columns. If you pass a star ('*'), the query will return the "
"instance of the AiidaClass."
msgstr ""
"返回结构信息作为relax算例的输出的Relax类各个实例的状态和id。这一任务中，你需要传入列的名字。若你传入一个星号（’*‘），查询会返回AiidaClass的实例。"

#: ../docs/source/querying/querybuilder/queryhelp.rst:174
msgid ""
"Filters: What if you want not every structure, but only the ones that were "
"added after a certain time `t` and have an id higher than 50::"
msgstr "过滤器：若你不需求所有的结构，而只有特定时间 `t` 之后的并且其id大于50 ::"

#: ../docs/source/querying/querybuilder/queryhelp.rst:309
msgid ""
"If you want to include filters and projections on links between nodes, you "
"will have to add these to filters and projections in the queryhelp. Let's "
"take an example that we had and add a few filters on the link::"
msgstr "若你需要引入在节点间的链接中引入过滤器和映射，你需要向queryhelp中添加它们。我们举一个已经提到例子并对链接添加几个过滤器::"

#: ../docs/source/querying/querybuilder/queryhelp.rst:335
msgid ""
"Notice that the tag for the link, by default, is the tag of the two "
"connecting nodes delimited by two dashes '--'. The order does not matter, "
"the following queryhelp would results in the same query::"
msgstr ""
"注意到链接的标记，在默认情况下，是由两根短线'--'连接的两个相互连接的节点的标签。与顺序无关，以下的queryhelp可以得到相同的查询::"

#: ../docs/source/querying/querybuilder/queryhelp.rst:361
msgid ""
"If you dislike that way to tag the link, you can choose the tag for the edge"
" in the path when definining the entity to join using ``edge_tag``::"
msgstr "若你不喜欢这种标记链接的方式，当定义实体连接时你也可以用 ``edge_tag`` 为路径中的边选取标记 ::"

#: ../docs/source/querying/querybuilder/queryhelp.rst:391
msgid "You can set a limit and an offset in the queryhelp::"
msgstr "你也可以为queryhelp设置一个上限和偏移 ::"

#: ../docs/source/querying/querybuilder/queryhelp.rst:399
msgid ""
"That queryhelp would tell the QueryBuilder to return 10 rows after the first"
" 20 have been skipped."
msgstr "例如以上的queryhelp可令查询构建器返回最前面20行之后的10行。"
