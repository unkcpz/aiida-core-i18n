# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2019, ECOLE POLYTECHNIQUE FEDERALE DE LAUSANNE (Theory and Simulation of Materials (THEOS) and National Centre for Computational Design and Discovery of Novel Materials (NCCR MARVEL)), Switzerland and ROBERT BOSCH LLC, USA. All rights reserved
# This file is distributed under the same license as the AiiDA package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: AiiDA 1.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-06-24 09:00+0000\n"
"PO-Revision-Date: 2019-05-17 20:00+0000\n"
"Language-Team: Chinese (China) (https://www.transifex.com/aiidateam/teams/98967/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../docs/source/datatypes/bands.rst:4
#: ../docs/source/datatypes/functionality.rst:91
#: ../docs/source/datatypes/index.rst:127
msgid "BandsData"
msgstr ""

#: ../docs/source/datatypes/bands.rst:6
msgid ""
"``BandsData`` object is dedicated to store bands object of different types "
"(electronic bands, phonons). In this section we describe the usage of the "
"``BandsData`` to store the  electronic band structure of silicon and some "
"logic behind its methods."
msgstr ""

#: ../docs/source/datatypes/bands.rst:11
msgid ""
"To start working with ``BandsData`` we should import it using the "
"``DataFactory`` and create an object of type ``BandsData``::"
msgstr ""

#: ../docs/source/datatypes/bands.rst:18
msgid ""
"To import the bands we need to make sure to have two arrays: one containing "
"kpoints and another containing bands. The shape of the kpoints object should"
" be ``nkpoints * 3``, while the shape of the bands should be ``nkpoints * "
"nstates``. Let's assume the number of kpoints is 12, and the number of "
"states is 5. So the kpoints and the bands array will look as follows::"
msgstr ""

#: ../docs/source/datatypes/bands.rst:53
msgid ""
"To insert kpoints and bands in the ``bs`` object we should employ "
"``set_kpoints()`` and ``set_bands()`` methods::"
msgstr ""

#: ../docs/source/datatypes/bands.rst:61
msgid ""
"From now the band structure can be visualized. Last thing that we may want "
"to add is the array of kpoint labels::"
msgstr ""

#: ../docs/source/datatypes/bands.rst:72
msgid "The resulting band structure will look as follows"
msgstr ""

#: ../docs/source/datatypes/bands.rst:76
msgid ""
"Once the ``bs`` object is stored (``bs.store()``) -- it won't accept any "
"modifications."
msgstr ""

#: ../docs/source/datatypes/bands.rst:81
msgid "Plotting the band structure"
msgstr ""

#: ../docs/source/datatypes/bands.rst:83
msgid ""
"You may notice that depending on how you assign the kpoints labels the "
"output of the ``show_mpl()`` method looks different. Please compare::"
msgstr ""

#: ../docs/source/datatypes/bands.rst:98
msgid ""
"In the first case two neighboring kpoints with ``X`` and ``Y`` labels will "
"look like ``X|Y``, while in the second case they will be separated by a "
"certain distance. The logic behind such a difference is the following. In "
"the first case the plotting method discovers the two neighboring kpoints and"
" assumes them to be a discontinuity point in the band structure (e.g. "
"Gamma-X|Y-U). In the second case the kpoints labelled ``X`` and ``Y`` are "
"not neighbors anymore, so they are plotted with a certain distance between "
"them. The intervals between the kpoints on the X axis are proportional to "
"the cartesian distance between them."
msgstr ""

#: ../docs/source/datatypes/bands.rst:108
msgid "Dealing with spins"
msgstr ""

#: ../docs/source/datatypes/bands.rst:110
msgid ""
"The ``BandsData`` object can also deal with the results of spin-polarized "
"calculations. Two provide different bands for two different spins you should"
" just merge them in one array and import them again using the "
"``set_bands()`` method::"
msgstr ""

#: ../docs/source/datatypes/bands.rst:118
msgid ""
"Now the shape of the bands array becomes ``nspins * nkpoints * nstates``"
msgstr ""

#: ../docs/source/datatypes/functionality.rst:4
msgid "Export data nodes to various formats"
msgstr ""

#: ../docs/source/datatypes/functionality.rst:5
msgid ""
"Each data node has a :py:meth:`~aiida.orm.nodes.data.data.Data.export()` "
"method that allows to export the given data node to file in a variety of "
"available formats, e.g. to pass it to a visualization software."
msgstr ""

#: ../docs/source/datatypes/functionality.rst:9
msgid ""
"The :py:meth:`~aiida.orm.nodes.data.data.Data.export()` method asks for a "
"filename, and it will write to file the result. It is possible that more "
"than one file is written (for example, if you produce a gnuplot script, the "
"data will typically be in a different .dat file). The return value of the "
"function is a list of files that have been created."
msgstr ""

#: ../docs/source/datatypes/functionality.rst:14
msgid ""
"The list of export formats depends on the specific Data plugin. The export "
"format is typically inferred from the file extension, but if this is not "
"possible (or you want to specify a given format), you can pass an additional"
" ``fileformat`` parameter to "
":py:meth:`~aiida.orm.nodes.data.data.Data.export()`. The list of all valid "
"export formats can be obtained calling ``Data.get_export_formats()`` method,"
" that returns a list of strings with all valid formats."
msgstr ""

#: ../docs/source/datatypes/functionality.rst:22
msgid ""
"If you don't want to export directly to a file, but want to get simply the "
"content of the file as a string, then you can call the "
":py:meth:`~aiida.orm.nodes.data.data.Data._exportcontent()` method, passing "
"also a ``fileformat`` parameter. The return value is a tuple of length 2: "
"the first element is a string with the content of the \"main\" file, while "
"the second is a dictionary (possibly empty) with a list of additional files "
"that should be created/needed: the keys are filenames, and the values are "
"the files content."
msgstr ""

#: ../docs/source/datatypes/functionality.rst:31
msgid "Exporting from the command line"
msgstr ""

#: ../docs/source/datatypes/functionality.rst:32
msgid "Most data types expose the export functionality on the command line."
msgstr ""

#: ../docs/source/datatypes/functionality.rst:34
msgid ""
"For instance, if you want to export a ``StructureData`` object with given "
"``PK``, you can run on the command line::"
msgstr ""

#: ../docs/source/datatypes/functionality.rst:39
msgid ""
"that will export the node with the corresponding  ``PK`` value in the format"
" ``FORMAT_NAME``. This will print on screen the file content; a few command "
"line options allow to change this behaviour:"
msgstr ""

#: ../docs/source/datatypes/functionality.rst:43
msgid ""
"``-o FILENAME`` asks to write directly on a file named ``FILENAME``. This is"
" compulsory in some cases, e.g. if more than one file needs to be created."
msgstr ""

#: ../docs/source/datatypes/functionality.rst:45
msgid ""
"``-y`` asks to overwrite the file(s), if present. If not specified, the call"
" will fail if any of the files to create are present."
msgstr ""

#: ../docs/source/datatypes/functionality.rst:48
msgid ""
"Additional options (often format-specific) exist, and can be discovered "
"passing the ``-h`` option to the command line. For instance:"
msgstr ""

#: ../docs/source/datatypes/functionality.rst:51
msgid ""
"``verdi data structure export`` accepts a number of formats including "
"``xsf``, ``cif`` and  ``xyz``, and additional parameters like ``--no-reduce-"
"symmetry`` (to be used in combination with the ``tcod`` format to tell AiiDA"
" not to try to reduce simmetry in the output CIF file, etc."
msgstr ""

#: ../docs/source/datatypes/functionality.rst:55
msgid ""
"``verdi data trajectory export`` accepts a number of formats including "
"``xsf`` and  ``cif``, and additional parameters like ``--step NUM`` (to "
"choose to export only a given trajectory step)."
msgstr ""

#: ../docs/source/datatypes/functionality.rst:59
msgid ""
"``verdi data bands export`` accepts a number of formats including (see also "
"below) and additional parameters like ``--prettify-format FORMATNAME``, see "
"valid formats below, or ``--y-min-lim``, ``--y-max-lim`` to specify the "
"``y``-axis limits."
msgstr ""

#: ../docs/source/datatypes/functionality.rst:66
msgid "Export formats for specific Data types"
msgstr ""

#: ../docs/source/datatypes/functionality.rst:67
msgid ""
"As the formats are specific to the data types, here is a list of some of the"
" export formats available for some of the AiiDA data classes."
msgstr ""

#: ../docs/source/datatypes/functionality.rst:71
#: ../docs/source/datatypes/index.rst:64
msgid "StructureData"
msgstr ""

#: ../docs/source/datatypes/functionality.rst:72
#: ../docs/source/datatypes/functionality.rst:83
#: ../docs/source/datatypes/functionality.rst:92
msgid "The following export formats are available:"
msgstr ""

#: ../docs/source/datatypes/functionality.rst:74
#: ../docs/source/datatypes/functionality.rst:85
msgid ""
"``xsf`` (format supported by e.g. XCrySDen and other visualization software;"
" supports periodic cells)"
msgstr ""

#: ../docs/source/datatypes/functionality.rst:76
msgid ""
"``xyz`` (classical xyz format, does not typically support periodic cells "
"(even if the cell is indicated in the comment line)"
msgstr ""

#: ../docs/source/datatypes/functionality.rst:78
msgid ""
"``cif`` (export to CIF format, without symmetry reduction, i.e. always "
"storing the structure as P1 symmetry)"
msgstr ""

#: ../docs/source/datatypes/functionality.rst:82
#: ../docs/source/datatypes/index.rst:98
msgid "TrajectoryData"
msgstr ""

#: ../docs/source/datatypes/functionality.rst:87
msgid ""
"``cif`` (export to CIF format, without symmetry reduction, i.e. always "
"storing the structures as P1 symmetry)"
msgstr ""

#: ../docs/source/datatypes/functionality.rst:94
msgid "``agr``: export a Xmgrace .agr file with the band plot"
msgstr ""

#: ../docs/source/datatypes/functionality.rst:95
msgid ""
"``agr_batch``: export a Xmgrace batch file together with an independent .dat"
" file"
msgstr ""

#: ../docs/source/datatypes/functionality.rst:96
msgid ""
"``dat_blocks``: export a .dat file, where each line has a data point (xy) "
"and bands are separated in blocks with empty lines"
msgstr ""

#: ../docs/source/datatypes/functionality.rst:98
msgid ""
"``dat_multicolumn``: export a .dat file, where each line has all the values "
"for a given x coordinate: ``x y1 y2 y3 y4 ...`` (``x`` being a linear "
"coordinate along the band path and ``yN`` being the band energies)"
msgstr ""

#: ../docs/source/datatypes/functionality.rst:101
msgid "``gnuplot``: export a gnuplot file, together with a .dat file"
msgstr ""

#: ../docs/source/datatypes/functionality.rst:102
msgid "``json``: export a json file with the bands divided into segments"
msgstr ""

#: ../docs/source/datatypes/functionality.rst:103
msgid ""
"``mpl_singlefile``: export a python file that when executed shows a plot "
"using the ``matplotlib`` module. All data is included in the same python "
"file as a multiline string containing the data in json format."
msgstr ""

#: ../docs/source/datatypes/functionality.rst:106
msgid ""
"``mpl_withjson``: As above, but the json data is stored separately in a "
"different file"
msgstr ""

#: ../docs/source/datatypes/functionality.rst:107
msgid ""
"``mpl_pdf``: As above, but after creating the .py file it runs it to export "
"the band structure in a PDF file (vectorial). **NOTE**: it requires that you"
" have the python ``matplotlib`` module installed. If ``use_latex`` is true, "
"it requires that you have LaTeX installed on your system to typeset the "
"labels, as well as the ``dvipng`` binary."
msgstr ""

#: ../docs/source/datatypes/functionality.rst:111
msgid ""
"``mpl_png``: As above, but after creating the .py file it runs it to export "
"the band structure in a PDF file (vectorial). **NOTE**: this format has the "
"same dependencies as the ``mpl_pdf`` format above."
msgstr ""

#: ../docs/source/datatypes/functionality.rst:116
msgid "Label prettifiers"
msgstr ""

#: ../docs/source/datatypes/functionality.rst:117
msgid ""
"AiiDA provides a number of functions to \"prettify\" the labels of band "
"structures (if labels are present in the data node), i.e., replace ``GAMMA``"
" with :math:`\\Gamma` or ``K_1`` with :math:`K_{1}` for instance. This makes"
" sense for some output formats (e.g. Xmgrace, Gnuplot, matplotlib)."
msgstr ""

#: ../docs/source/datatypes/functionality.rst:123
msgid ""
"The prettifier functions are defined as methods of the "
":py:class:`~aiida.common.utils.Prettifier` class. and can be obtained "
"calling "
":py:meth:`Prettifier.get_prettifiers()<aiida.common.utils.Prettifier.get_prettifiers>`."
msgstr ""

#: ../docs/source/datatypes/functionality.rst:128
msgid "The prettifiers should be chosen depending on two aspects:"
msgstr ""

#: ../docs/source/datatypes/functionality.rst:130
msgid ""
"how the raw labels are stored in the database. Two types exist currently: "
"``seekpath``, as used in the ``seekpath`` module, where Greek letters are "
"written explicitly (e.g. ``GAMMA``) and underscores are used to indicate a "
"subscript (``K_1``); and the \"old\" ``simple`` format, where "
":math:`\\Gamma` is indicated with ``G`` and there is no underscore symbol)."
msgstr ""

#: ../docs/source/datatypes/functionality.rst:136
msgid ""
"depending on the output format: xmgrace has a specific syntax for Greek "
"letters and subscripts, matplotlib uses LaTeX syntax, etc."
msgstr ""

#: ../docs/source/datatypes/functionality.rst:139
msgid ""
"Most export formats already decide which prettifier is best to use, but if "
"you need to change it, you can do it passing the ``prettify_format`` "
"parameter to the :py:meth:`~aiida.orm.nodes.data.data.Data.export()` method."
" Valid prettifiers include:"
msgstr ""

#: ../docs/source/datatypes/functionality.rst:143
msgid ""
"``agr_seekpath``: format for Xmgrace, using ``seekpath`` raw label syntax"
msgstr ""

#: ../docs/source/datatypes/functionality.rst:144
msgid "``agr_simple``: format for Xmgrace, using ``simple`` raw label syntax"
msgstr ""

#: ../docs/source/datatypes/functionality.rst:145
msgid ""
"``latex_simple``: format for LaTeX (including dollar signs), using "
"``seekpath`` raw label syntax"
msgstr ""

#: ../docs/source/datatypes/functionality.rst:146
msgid ""
"``latex_seekpath``: format for LaTeX (including dollar signs), using "
"``simple`` raw label syntax"
msgstr ""

#: ../docs/source/datatypes/functionality.rst:147
msgid ""
"``gnuplot_simple``: format for GNUPlot (Unicode for Greek letters, LaTeX "
"syntax `without` dollar signs for underscores), using ``seekpath`` raw label"
" syntax"
msgstr ""

#: ../docs/source/datatypes/functionality.rst:148
msgid ""
"``gnuplot_seekpath``: format for GNUPlot (Unicode for Greek letters, LaTeX "
"syntax `without` dollar signs for underscores), using ``simple`` raw label "
"syntax"
msgstr ""

#: ../docs/source/datatypes/functionality.rst:149
msgid ""
"``pass``: no-op prettifier: leaves all strings unchanged to their raw value"
msgstr ""

#: ../docs/source/datatypes/index.rst:5
msgid "AiiDA data types"
msgstr ""

#: ../docs/source/datatypes/index.rst:7
msgid "There are a number of data types distributed with AiiDA."
msgstr ""

#: ../docs/source/datatypes/index.rst:9
msgid ""
"We summarize here the most common, and some useful features/functionalities "
"to work with them."
msgstr ""

#: ../docs/source/datatypes/index.rst:13
msgid "Most common datatypes"
msgstr ""

#: ../docs/source/datatypes/index.rst:15
msgid ""
"Here follows a short summary of common datatypes already provided with "
"AiiDA. This list is not complete, see also inside "
":py:mod:`aiida.orm.nodes.data` for the list of all available plugins."
msgstr ""

#: ../docs/source/datatypes/index.rst:18
msgid ""
"We also mention, when relevant, what is stored in the database (as "
"attributes, so that it can be easily queried e.g. with the "
":ref:`QueryBuilder <UsingQueryBuilder>`) and what is stored in the file "
"repository (providing access to the file contents, but not efficiently "
"queryable: this is useful for e.g. big data files that don't need to be "
"queried for)."
msgstr ""

#: ../docs/source/datatypes/index.rst:23
msgid ""
"For all data types, you can follow the link to the data class to read more "
"about the methods provided, how to access them, and so on."
msgstr ""

#: ../docs/source/datatypes/index.rst:26
msgid ""
"If you need to work with some specific type of data, first check the list of"
" data types/plugins below, and if you don't find what you need, give a look "
"to :ref:`how to write a new data plugin <DevelopDataPluginTutorialFloat>`."
msgstr ""

#: ../docs/source/datatypes/index.rst:31
msgid "Base types"
msgstr ""

#: ../docs/source/datatypes/index.rst:32
msgid ""
"In the :py:mod:`aiida.orm.nodes.data.base` module there are a number of "
"useful classes that wrap base python datatypes (like "
":py:class:`~aiida.orm.nodes.data.int.Int`, "
":py:class:`~aiida.orm.nodes.data.float.Float`, "
":py:class:`~aiida.orm.nodes.data.str.Str`, ...). These are automatically "
"loaded with the verdi shell, and also directly exposed from "
":py:mod:`aiida.orm`. These classes are particularly useful when you need to "
"provide a single parameter to e.g. a "
":py:class:`~aiida.engine.processes.functions.workfunction`."
msgstr ""

#: ../docs/source/datatypes/index.rst:39
msgid ""
"Each of these classes can most often be used transparently (e.g. you can sum"
" two :py:class:`~aiida.orm.nodes.data.int.Int` objects, etc.). If you need "
"to access the bare value and not the whole AiiDA class, use the ``.value`` "
"property."
msgstr ""

#: ../docs/source/datatypes/index.rst:43
msgid ""
"In the same module, there is also a "
":py:class:`~aiida.orm.nodes.data.list.List` class to store a list of base "
"data types."
msgstr ""

#: ../docs/source/datatypes/index.rst:46
msgid ""
"The different datatypes can be accessed through the "
":py:func:`~aiida.plugins.factories.DataFactory` function (also exposed from "
":py:mod:`aiida.plugins`) by passing an entry point to it as an argument. A "
"list of all the data entry points can be obtain running the command ``verdi "
"plugin list aiida.data``."
msgstr ""

#: ../docs/source/datatypes/index.rst:51
msgid "Dict"
msgstr ""

#: ../docs/source/datatypes/index.rst:53
msgid "**Class**: :py:class:`~aiida.orm.nodes.data.dict.Dict`"
msgstr ""

#: ../docs/source/datatypes/index.rst:54
msgid ""
"**String to pass to the** :py:func:`~aiida.plugins.factories.DataFactory`: "
"``dict``"
msgstr ""

#: ../docs/source/datatypes/index.rst:55
msgid ""
"**Aim**: store a dictionary of python base types in the database. It can "
"store any dictionary where elements can be a base python type (strings, "
"floats, integers, booleans, None type, datetime objects) and lists or "
"dictionaries of them, at any depth level (e.g. a dictionary where a value is"
" a list of dictionaries of strings and floats)."
msgstr ""

#: ../docs/source/datatypes/index.rst:60
msgid "**What is stored in the database**: all key/values pairs as attributes"
msgstr ""

#: ../docs/source/datatypes/index.rst:61 ../docs/source/datatypes/index.rst:70
#: ../docs/source/datatypes/index.rst:176
msgid "**What is stored in the file repository**: ---"
msgstr ""

#: ../docs/source/datatypes/index.rst:66
msgid "**Class**: :py:class:`~aiida.orm.nodes.data.structure.StructureData`"
msgstr ""

#: ../docs/source/datatypes/index.rst:67
msgid ""
"**String to pass to the** :py:func:`~aiida.plugins.factories.DataFactory`: "
"``structure``"
msgstr ""

#: ../docs/source/datatypes/index.rst:68
msgid "**Aim**: store a crystal structure to be used by atomistic codes"
msgstr ""

#: ../docs/source/datatypes/index.rst:69
msgid ""
"**What is stored in the database**: all atomic positions, species, kinds,"
msgstr ""

#: ../docs/source/datatypes/index.rst:71
#: ../docs/source/datatypes/index.rst:107
#: ../docs/source/datatypes/index.rst:122
#: ../docs/source/datatypes/index.rst:134
msgid "**Additional functionality**:"
msgstr ""

#: ../docs/source/datatypes/index.rst:73
#: ../docs/source/datatypes/index.rst:109
msgid ":ref:`Export to a number of formats (xsf, cif, ...)<ExportDataNodes>`"
msgstr ""

#: ../docs/source/datatypes/index.rst:76
msgid "UpfData"
msgstr ""

#: ../docs/source/datatypes/index.rst:78
msgid "**Class**: :py:class:`~aiida.orm.nodes.data.upf.UpfData`"
msgstr ""

#: ../docs/source/datatypes/index.rst:79
msgid ""
"**String to pass to the** :py:func:`~aiida.plugins.factories.DataFactory`: "
"``upf``"
msgstr ""

#: ../docs/source/datatypes/index.rst:80
msgid ""
"**Aim**: store a pseudopotential in the .UPF format (e.g. used by `Quantum "
"ESPRESSO`_ - see also the `AiiDA Quantum ESPRESSO plugin`_)"
msgstr ""

#: ../docs/source/datatypes/index.rst:81
msgid ""
"**What is stored in the database**: the MD5 of the UPF; the element the "
"pseudopotential is associated to"
msgstr ""

#: ../docs/source/datatypes/index.rst:83
msgid "**What is stored in the file repository**: the pseudopotential file"
msgstr ""

#: ../docs/source/datatypes/index.rst:89
msgid "ArrayData"
msgstr ""

#: ../docs/source/datatypes/index.rst:91
msgid "**Class**: :py:class:`~aiida.orm.nodes.data.array.ArrayData`"
msgstr ""

#: ../docs/source/datatypes/index.rst:92
msgid ""
"**String to pass to the** :py:func:`~aiida.plugins.factories.DataFactory`: "
"``array``"
msgstr ""

#: ../docs/source/datatypes/index.rst:93
msgid "**Aim**: store generic numeric arrays"
msgstr ""

#: ../docs/source/datatypes/index.rst:94
msgid ""
"**What is stored in the database**: the shape of the arrays and the name of "
"the arrays"
msgstr ""

#: ../docs/source/datatypes/index.rst:95
msgid ""
"**What is stored in the file repository**: the array data in numpy format"
msgstr ""

#: ../docs/source/datatypes/index.rst:99
msgid ""
"**Class**: :py:class:`~aiida.orm.nodes.data.array.trajectory.TrajectoryData`"
msgstr ""

#: ../docs/source/datatypes/index.rst:100
msgid ""
"**String to pass to the** :py:func:`~aiida.plugins.factories.DataFactory`: "
"``array.trajectory``"
msgstr ""

#: ../docs/source/datatypes/index.rst:101
msgid ""
"**Aim**: store molecular trajectories (i.e. sequences of StructureData "
"objects, where then number of atomic kinds and sites does not change over "
"time). beside the coordinates, it can also optionally store velocities."
msgstr ""

#: ../docs/source/datatypes/index.rst:104
msgid "**What is stored in the database**: like ``ArrayData``"
msgstr ""

#: ../docs/source/datatypes/index.rst:105
msgid ""
"**What is stored in the file repository**: the array data in numpy format: "
"cells over time, integer indices over time, atomic positions over time, the "
"list of kinds, ..."
msgstr ""

#: ../docs/source/datatypes/index.rst:112
msgid "KpointsData"
msgstr ""

#: ../docs/source/datatypes/index.rst:114
msgid "**Class**: :py:class:`~aiida.orm.nodes.data.array.kpoints.KpointsData`"
msgstr ""

#: ../docs/source/datatypes/index.rst:115
msgid ""
"**String to pass to the** :py:func:`~aiida.plugins.factories.DataFactory`: "
"``array.kpoints``"
msgstr ""

#: ../docs/source/datatypes/index.rst:116
msgid ""
"**Aim**: store grids of k-points (in reciprocal space, for crystal "
"structures), or explicit list of k-points (optionally with a weight "
"associated to each one). Can also associate labels to (some of the) points, "
"which is very useful for later plottings band structures (and store them in "
"``BandsData`` objects)."
msgstr ""

#: ../docs/source/datatypes/index.rst:120
#: ../docs/source/datatypes/index.rst:132
#: ../docs/source/datatypes/index.rst:144
msgid ""
"**What is stored in the database**: like ``ArrayData``, the shape of the "
"arrays and the name of the arrays"
msgstr ""

#: ../docs/source/datatypes/index.rst:121
#: ../docs/source/datatypes/index.rst:133
#: ../docs/source/datatypes/index.rst:145
msgid ""
"**What is stored in the file repository**:  like ``ArrayData``, the array "
"data in numpy format"
msgstr ""

#: ../docs/source/datatypes/index.rst:124
msgid ""
":ref:`Automatically compute k-points path given a crystal "
"structure<AutomaticKpoints>`"
msgstr ""

#: ../docs/source/datatypes/index.rst:129
msgid "**Class**: :py:class:`~aiida.orm.nodes.data.array.bands.BandsData`"
msgstr ""

#: ../docs/source/datatypes/index.rst:130
msgid ""
"**String to pass to the** :py:func:`~aiida.plugins.factories.DataFactory`: "
"``array.bands``"
msgstr ""

#: ../docs/source/datatypes/index.rst:131
msgid "**Aim**: store electronic structure bands (of phonon bands)"
msgstr ""

#: ../docs/source/datatypes/index.rst:136
msgid ""
":ref:`Export to a number of formats (xmgrace, gnuplot, png, pdf, "
"...)<ExportDataNodes>`"
msgstr ""

#: ../docs/source/datatypes/index.rst:139
msgid "XyData"
msgstr ""

#: ../docs/source/datatypes/index.rst:141
msgid "**Class**: :py:class:`~aiida.orm.nodes.data.array.xy.XyData`"
msgstr ""

#: ../docs/source/datatypes/index.rst:142
msgid ""
"**String to pass to the** :py:func:`~aiida.plugins.factories.DataFactory`: "
"``array.xy``"
msgstr ""

#: ../docs/source/datatypes/index.rst:143
msgid "**Aim**: store data for a 2D (xy) plot"
msgstr ""

#: ../docs/source/datatypes/index.rst:148
msgid "FolderData"
msgstr ""

#: ../docs/source/datatypes/index.rst:150
msgid "**Class**: :py:class:`~aiida.orm.nodes.data.folder.FolderData`"
msgstr ""

#: ../docs/source/datatypes/index.rst:151
msgid ""
"**String to pass to the** :py:func:`~aiida.plugins.factories.DataFactory`: "
"``folder``"
msgstr ""

#: ../docs/source/datatypes/index.rst:152
msgid ""
"**Aim**: store a set of files/folders (with possibly a folder/subfolder "
"structure)"
msgstr ""

#: ../docs/source/datatypes/index.rst:153
msgid "**What is stored in the database**: ---"
msgstr ""

#: ../docs/source/datatypes/index.rst:154
msgid "**What is stored in the file repository**: all files and folders"
msgstr ""

#: ../docs/source/datatypes/index.rst:157
msgid "SinglefileData"
msgstr ""

#: ../docs/source/datatypes/index.rst:158
msgid "**Class**: :py:class:`~aiida.orm.nodes.data.singlefile.SinglefileData`"
msgstr ""

#: ../docs/source/datatypes/index.rst:159
msgid ""
"**String to pass to the** :py:func:`~aiida.plugins.factories.DataFactory`: "
"``singlefile``"
msgstr ""

#: ../docs/source/datatypes/index.rst:160
msgid ""
"**Aim**: the same as ``FolderData``, but allows to store only one single "
"file."
msgstr ""

#: ../docs/source/datatypes/index.rst:161
msgid "**What is stored in the database**: the filename"
msgstr ""

#: ../docs/source/datatypes/index.rst:162
msgid "**What is stored in the file repository**: the file"
msgstr ""

#: ../docs/source/datatypes/index.rst:165
msgid "RemoteData"
msgstr ""

#: ../docs/source/datatypes/index.rst:167
msgid "**Class**: :py:class:`~aiida.orm.nodes.data.remote.RemoteData`"
msgstr ""

#: ../docs/source/datatypes/index.rst:168
msgid ""
"**String to pass to the** :py:func:`~aiida.plugins.factories.DataFactory`: "
"``remote``"
msgstr ""

#: ../docs/source/datatypes/index.rst:169
msgid ""
"**Aim**: this basically represents a \"symbolic link\" to a specific folder "
"on a remote computer. Its main use is to allow users to persist the "
"provenance when e.g. a calculation produces data in a raw/scratch folder, "
"and the whole folder needs to be provided to restart/continue."
msgstr ""

#: ../docs/source/datatypes/index.rst:174
msgid ""
"**What is stored in the database**: the path of the folder (and the remote "
"computer as a `.computer` property, not as an attribute)"
msgstr ""

#: ../docs/source/datatypes/kpoints.rst:4
msgid "Automatic computation of k-point paths"
msgstr ""

#: ../docs/source/datatypes/kpoints.rst:5
msgid ""
"AiiDA provides a number of tools and wrappers to automatically compute "
"k-point paths given a cell or a crystal structure."
msgstr ""

#: ../docs/source/datatypes/kpoints.rst:8
msgid ""
"The main interface is provided by the two methods "
":py:func:`aiida.tools.data.array.kpoints.get_kpoints_path` and "
":py:func:`aiida.tools.data.array.kpoints.get_explicit_kpoints_path`."
msgstr ""

#: ../docs/source/datatypes/kpoints.rst:11
msgid ""
"These methods are also conveniently exported directly as, e.g., "
"``aiida.tools.get_kpoints_path``."
msgstr ""

#: ../docs/source/datatypes/kpoints.rst:13
msgid "The difference between the two methods is the following:"
msgstr ""

#: ../docs/source/datatypes/kpoints.rst:15
msgid ""
":py:func:`~aiida.tools.data.array.kpoints.get_kpoints_path` returns a "
"dictionary of k-point coordinates (e.g. ``{'GAMMA': [0. ,0. ,0. ], 'X': "
"[0.5, 0., 0.], 'L': [0.5, 0.5, 0.5]}``, and then a list of tuples of "
"endpoints of each segment, e.g. ``[('GAMMA', 'X'), ('X', 'L'), ('L', "
"'GAMMA')]`` for the :math:`\\Gamma-X-L-\\Gamma` path."
msgstr ""

#: ../docs/source/datatypes/kpoints.rst:19
msgid ""
":py:func:`~aiida.tools.data.array.kpoints.get_explicit_kpoints_path`, "
"instead, returns a list of kpoints that follow that path, with some "
"predefined (but user-customizable) distance between points, e.g. something "
"like ``[[0., 0., 0.], [0.05, 0., 0.], [0.1, 0., 0.], ...]``."
msgstr ""

#: ../docs/source/datatypes/kpoints.rst:23
msgid ""
"Depending on how the underlying code works, one method might be preferred on"
" the other."
msgstr ""

#: ../docs/source/datatypes/kpoints.rst:25
msgid ""
"The docstring of the methods describes the expected parameters. The general "
"interface requires always a ``StructureData`` as the first parameter "
"``structure``, as well as a string for the method to use (by default this is"
" `seekpath <https://github.com/giovannipizzi/seekpath/>`_, but also the "
"``legacy`` method implemented in earlier versions of AiiDA is available; see"
" description below)."
msgstr ""

#: ../docs/source/datatypes/kpoints.rst:30
msgid ""
"Additional parameters are passed as ``kwargs`` to the underlying "
"implementation, that often accepts a different number of parameters."
msgstr ""

#: ../docs/source/datatypes/kpoints.rst:34
msgid "Seekpath implementation"
msgstr ""

#: ../docs/source/datatypes/kpoints.rst:35
msgid ""
"When specifying ``method='seekpath'``, the `seekpath "
"<https://github.com/giovannipizzi/seekpath/>`_ library is used to generate "
"the path. Note that this requires  ``seekpath`` to be installed (this is not"
" available by default, in order to reduce the dependencies of AiiDA core, "
"but can be easily installed using ``pip install seekpath``)."
msgstr ""

#: ../docs/source/datatypes/kpoints.rst:39
msgid ""
"For a full description of the accepted parameters, we refer to the docstring"
" of the underlying methods "
":py:func:`aiida.tools.data.array.kpoints.seekpath.get_explicit_kpoints_path`"
" and :py:func:`aiida.tools.data.array.kpoints.seekpath.get_kpoints_path`, "
"and for more general information to the `seekpath documentation "
"<https://seekpath.readthedocs.io/>`_."
msgstr ""

#: ../docs/source/datatypes/kpoints.rst:44
msgid ""
"If you use this implementation, please cite the `Hinuma paper "
"<https://doi.org/10.1016/j.commatsci.2016.10.015>`_::"
msgstr ""

#: ../docs/source/datatypes/kpoints.rst:52
msgid "Legacy implementation"
msgstr ""

#: ../docs/source/datatypes/kpoints.rst:53
msgid ""
"This refers to the implementation that has been available since the early "
"versions of AiiDA."
msgstr ""

#: ../docs/source/datatypes/kpoints.rst:55
msgid ""
"In the 3D case (all three directions have periodic boundary conditions), "
"this implementation expects that the structure is already standardized "
"according to the Setyawan paper. If this is not the case, the kpoints and "
"band structure returned will be incorrect. The only case that is dealt "
"correctly by the library is the case when axes are swapped, where the "
"library correctly takes this swapping/rotation into account to assign kpoint"
" labels and coordinates."
msgstr ""

#: ../docs/source/datatypes/kpoints.rst:61
msgid ""
"We therefore suggest that you use the seekpath implementation, that is able "
"to automatically correctly identify the standardized crystal structure "
"(primitive and conventional) as described in the `Hinuma paper "
"<https://doi.org/10.1016/j.commatsci.2016.10.015>`_."
msgstr ""

#: ../docs/source/datatypes/kpoints.rst:65
msgid ""
"For a full description of the accepted parameters, we refer to the docstring"
" of the underlying methods "
":py:func:`aiida.tools.data.array.kpoints.legacy.get_explicit_kpoints_path` "
"and :py:func:`aiida.tools.data.array.kpoints.legacy.get_kpoints_path`, and "
"for more general information to the `seekpath documentation "
"<https://seekpath.readthedocs.io/>`_."
msgstr ""

#: ../docs/source/datatypes/kpoints.rst:70
msgid ""
"If you use this implementation, please cite the correct reference from the "
"following ones:"
msgstr ""

#: ../docs/source/datatypes/kpoints.rst:72
msgid ""
"The 3D implementation is based on the `Setyawan paper "
"<https://doi.org/10.1016/j.commatsci.2010.05.010>`_::"
msgstr ""

#: ../docs/source/datatypes/kpoints.rst:79
msgid ""
"The 2D implementation is based on the `Ramirez paper "
"<https://doi.org/10.1002/qua.560300306>`_::"
msgstr ""

#: ../docs/source/datatypes/kpoints.rst:88
msgid "Deprecated methods"
msgstr ""

#: ../docs/source/datatypes/kpoints.rst:89
msgid ""
"Originally, the ``legacy`` implementation was implemented directly into the "
":py:class:`~aiida.orm.nodes.data.array.kpoints.KpointsData` class."
msgstr ""

#: ../docs/source/datatypes/kpoints.rst:92
msgid ""
"In order to implement more than one method, to simplify the "
":py:class:`~aiida.orm.nodes.data.array.kpoints.KpointsData` class, and to "
"decouple the underlying logic from AiiDA, we have deprecated those methods "
"and factored out the logic into the "
":py:class:`~aiida.tools.data.array.kpoints.legacy` module. The methods are "
"currently still available, but will be removed in future versions of AiiDA; "
"plese use directly the wrappers "
":py:func:`aiida.tools.data.array.kpoints.get_kpoints_path` and "
":py:func:`aiida.tools.data.array.kpoints.get_explicit_kpoints_path` instead,"
" passing as option ``method='legacy'``."
msgstr ""

#: ../docs/source/datatypes/kpoints.rst:100
msgid "The list of deprecated methods include:"
msgstr ""

#: ../docs/source/datatypes/kpoints.rst:102
msgid ""
":py:meth:`~aiida.orm.nodes.data.array.kpoints.KpointsData.bravais_lattice`"
msgstr ""

#: ../docs/source/datatypes/kpoints.rst:104
msgid ""
":py:meth:`~aiida.orm.nodes.data.array.kpoints.KpointsData._get_or_create_bravais_lattice`"
msgstr ""

#: ../docs/source/datatypes/kpoints.rst:106
msgid ""
":py:meth:`~aiida.orm.nodes.data.array.kpoints.KpointsData.set_kpoints_path`"
msgstr ""

#: ../docs/source/datatypes/kpoints.rst:108
msgid ""
":py:meth:`~aiida.orm.nodes.data.array.kpoints.KpointsData._find_bravais_info`"
msgstr ""

#: ../docs/source/datatypes/kpoints.rst:110
msgid ""
":py:meth:`~aiida.orm.nodes.data.array.kpoints.KpointsData.find_bravais_lattice`"
msgstr ""

#: ../docs/source/datatypes/kpoints.rst:112
msgid ""
":py:meth:`~aiida.orm.nodes.data.array.kpoints.KpointsData.get_special_points`"
msgstr ""
