# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2019, ECOLE POLYTECHNIQUE FEDERALE DE LAUSANNE (Theory and Simulation of Materials (THEOS) and National Centre for Computational Design and Discovery of Novel Materials (NCCR MARVEL)), Switzerland and ROBERT BOSCH LLC, USA. All rights reserved
# This file is distributed under the same license as the AiiDA package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Jianxing Huang <jx.huang.x@gmail.com>, 2019
# Jason.Eu <morty.yu@yahoo.com>, 2019
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: AiiDA 1.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-07-16 20:22+0000\n"
"PO-Revision-Date: 2019-05-17 20:00+0000\n"
"Last-Translator: Jason.Eu <morty.yu@yahoo.com>, 2019\n"
"Language-Team: Chinese (China) (https://www.transifex.com/aiidateam/teams/98967/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../docs/source/datatypes/bands.rst:4
#: ../docs/source/datatypes/functionality.rst:91
#: ../docs/source/datatypes/index.rst:128
msgid "BandsData"
msgstr "BandsData"

#: ../docs/source/datatypes/bands.rst:6
msgid ""
"``BandsData`` object is dedicated to store bands object of different types "
"(electronic bands, phonons). In this section we describe the usage of the "
"``BandsData`` to store the  electronic band structure of silicon and some "
"logic behind its methods."
msgstr ""
"``BandsData`` 对象用于存储不同类型的能带对象（电子、声子能带等）。在这一部分中，我们将介绍 ``BandsData`` "
"在存储硅的能带结构方面的用法和方法以及背后的一些逻辑。"

#: ../docs/source/datatypes/bands.rst:11
msgid ""
"To start working with ``BandsData`` we should import it using the "
"``DataFactory`` and create an object of type ``BandsData``::"
msgstr ""
"为用 ``BandsData`` 进行工作，我们需要先用 ``DataFactory`` 导入并创建 ``BandsData`` 类型的对象 ::"

#: ../docs/source/datatypes/bands.rst:18
msgid ""
"To import the bands we need to make sure to have two arrays: one containing "
"kpoints and another containing bands. The shape of the kpoints object should"
" be ``nkpoints * 3``, while the shape of the bands should be ``nkpoints * "
"nstates``. Let's assume the number of kpoints is 12, and the number of "
"states is 5. So the kpoints and the bands array will look as follows::"
msgstr ""
"为导入能带，我们需要确保有两个数组，一个包含kpoints对象，另一个包含能带信息。kpoints对象的大小须为 ``nkpoints * 3`` "
"，而能带结构对象的大小须为 ``nkpoints * nstates`` "
"。假设kpoints数量为12，状态数为5，则kpoints和能带序列应如下所示 ::"

#: ../docs/source/datatypes/bands.rst:53
msgid ""
"To insert kpoints and bands in the ``bs`` object we should employ "
"``set_kpoints()`` and ``set_bands()`` methods::"
msgstr ""
"为在 ``bs`` 对象中插入kpoints和能带，我们需要使用 ``set_kpoints()`` 和 ``set_bands()`` 方法::"

#: ../docs/source/datatypes/bands.rst:61
msgid ""
"From now the band structure can be visualized. Last thing that we may want "
"to add is the array of kpoint labels::"
msgstr "从现在开始，能带结构被可视化。我们最后要加入的是表示kpoint的标签数组 ::"

#: ../docs/source/datatypes/bands.rst:72
msgid "The resulting band structure will look as follows"
msgstr "得到的能带结构如下所示"

#: ../docs/source/datatypes/bands.rst:76
msgid ""
"Once the ``bs`` object is stored (``bs.store()``) -- it won't accept any "
"modifications."
msgstr "一旦 ``bs`` 对象被存储（ ``bs.store()`` ），它将不能再接受任何修改。"

#: ../docs/source/datatypes/bands.rst:81
msgid "Plotting the band structure"
msgstr "绘制能带结构图"

#: ../docs/source/datatypes/bands.rst:83
msgid ""
"You may notice that depending on how you assign the kpoints labels the "
"output of the ``show_mpl()`` method looks different. Please compare::"
msgstr "你可能注意到， ``show_mpl()`` 的输出有所不同，这取决于你设置kpoints的方式。请比较以下内容 ::"

#: ../docs/source/datatypes/bands.rst:98
msgid ""
"In the first case two neighboring kpoints with ``X`` and ``Y`` labels will "
"look like ``X|Y``, while in the second case they will be separated by a "
"certain distance. The logic behind such a difference is the following. In "
"the first case the plotting method discovers the two neighboring kpoints and"
" assumes them to be a discontinuity point in the band structure (e.g. "
"Gamma-X|Y-U). In the second case the kpoints labelled ``X`` and ``Y`` are "
"not neighbors anymore, so they are plotted with a certain distance between "
"them. The intervals between the kpoints on the X axis are proportional to "
"the cartesian distance between them."
msgstr ""
"第一种情形下，两个相邻的被分别标记为 ``X`` 和 ``Y`` 的k点看起来如同 ``X|Y`` "
"；而第二种情形下，两者被分开到一定距离。这种距离的产生的原因如下。第一种情形下，绘图的方法发现了两个相邻的k点，并假设它们是能带结构中两个不连续的点（例如Gamma-X|Y-U）；第二种情形下，被标记为"
" ``X`` 和 ``Y`` 的k点不再相邻，因而可以一确定距离被绘制出来。X轴上k点的间隔与它们笛卡尔坐标间的距离是等比例的。"

#: ../docs/source/datatypes/bands.rst:108
msgid "Dealing with spins"
msgstr "自旋的处理"

#: ../docs/source/datatypes/bands.rst:110
msgid ""
"The ``BandsData`` object can also deal with the results of spin-polarized "
"calculations. Two provide different bands for two different spins you should"
" just merge them in one array and import them again using the "
"``set_bands()`` method::"
msgstr ""
" ``BandsData`` 对象也可以处理自旋极化计算的结果。对于两种不同自旋得到的两种不同能带，你应当把他们合并在同一个数组中并用 "
"``set_bands()`` 方法再次导入 ::"

#: ../docs/source/datatypes/bands.rst:118
msgid ""
"Now the shape of the bands array becomes ``nspins * nkpoints * nstates``"
msgstr "现在能带数组的大小变为 ``nspins * nkpoints * nstates`` "

#: ../docs/source/datatypes/functionality.rst:4
msgid "Export data nodes to various formats"
msgstr "导出数据节点到不同格式"

#: ../docs/source/datatypes/functionality.rst:5
msgid ""
"Each data node has a :py:meth:`~aiida.orm.nodes.data.data.Data.export()` "
"method that allows to export the given data node to file in a variety of "
"available formats, e.g. to pass it to a visualization software."
msgstr ""
"每种数据节点都有一个 :py:meth:`~aiida.orm.nodes.data.data.Data.export()` "
"方法，允许将给定的数据节点导出为多种多样的文件格式，例如传递给视图软件。"

#: ../docs/source/datatypes/functionality.rst:9
msgid ""
"The :py:meth:`~aiida.orm.nodes.data.data.Data.export()` method asks for a "
"filename, and it will write to file the result. It is possible that more "
"than one file is written (for example, if you produce a gnuplot script, the "
"data will typically be in a different .dat file). The return value of the "
"function is a list of files that have been created."
msgstr ""
":py:meth:`~aiida.orm.nodes.data.data.Data.export()` "
"方法需要一个文件名，并将结果写入该文件中。写入多于一个文件是可行的（例如若你需要生成gnuplot脚本，数据通常会导出为另一个不同的 .dat "
"文件）。函数的返回值是创建文件的列表。"

#: ../docs/source/datatypes/functionality.rst:14
msgid ""
"The list of export formats depends on the specific Data plugin. The export "
"format is typically inferred from the file extension, but if this is not "
"possible (or you want to specify a given format), you can pass an additional"
" ``fileformat`` parameter to "
":py:meth:`~aiida.orm.nodes.data.data.Data.export()`. The list of all valid "
"export formats can be obtained calling ``Data.get_export_formats()`` method,"
" that returns a list of strings with all valid formats."
msgstr ""
"导出文件的列表取决于具体的数据插件。导出格式通常由文件扩展名推测，但若不可用（或你希望选定特定的文件格式），则你可向 "
":py:meth:`~aiida.orm.nodes.data.data.Data.export()` 传入一个附加的 ``fileformat`` "
"参数。全部有效的格式可通过调用 ``Data.get_export_formats()`` 获得，这将返回一个包含全部有效格式的字符串列表。"

#: ../docs/source/datatypes/functionality.rst:22
msgid ""
"If you don't want to export directly to a file, but want to get simply the "
"content of the file as a string, then you can call the "
":py:meth:`~aiida.orm.nodes.data.data.Data._exportcontent()` method, passing "
"also a ``fileformat`` parameter. The return value is a tuple of length 2: "
"the first element is a string with the content of the \"main\" file, while "
"the second is a dictionary (possibly empty) with a list of additional files "
"that should be created/needed: the keys are filenames, and the values are "
"the files content."
msgstr ""
"若你不希望直接导出到文件，而是以字符串的形式得到文件内容，你可以调用 "
":py:meth:`~aiida.orm.nodes.data.data.Data._exportcontent()` 方法，同样需要传入 "
"``fileformat`` "
"参数。返回值会是一个长度为2的元组：第一个元素是一个包含“主要”文件内容的字符串，第二个元素则是一个包含应被创建的附加文件列表的字典（可能为空），其键是文件名，值是文件内容。"

#: ../docs/source/datatypes/functionality.rst:31
msgid "Exporting from the command line"
msgstr "使用命令行导出文件"

#: ../docs/source/datatypes/functionality.rst:32
msgid "Most data types expose the export functionality on the command line."
msgstr "许多数据类型提供导出功能的命令行接口。"

#: ../docs/source/datatypes/functionality.rst:34
msgid ""
"For instance, if you want to export a ``StructureData`` object with given "
"``PK``, you can run on the command line::"
msgstr "例如，若你希望导出指定 ``PK`` 的 ``StructureData`` 对象，则你可以运行如下命令 ::"

#: ../docs/source/datatypes/functionality.rst:39
msgid ""
"that will export the node with the corresponding  ``PK`` value in the format"
" ``FORMAT_NAME``. This will print on screen the file content; a few command "
"line options allow to change this behaviour:"
msgstr ""
"这将以 ``FORMAT_NAME`` 对应的文件格式导出相应 ``PK`` 号的节点。该功能会将文件内容输出到屏幕显示，一些命令行选项可以改变此行为:"

#: ../docs/source/datatypes/functionality.rst:43
msgid ""
"``-o FILENAME`` asks to write directly on a file named ``FILENAME``. This is"
" compulsory in some cases, e.g. if more than one file needs to be created."
msgstr ""
"``-o FILENAME`` 请求直接写入文件以 ``FILENAME`` 之名。在一些条件下该选项是必要的，例如多余一个文件需要被创建的情况。"

#: ../docs/source/datatypes/functionality.rst:45
msgid ""
"``-y`` asks to overwrite the file(s), if present. If not specified, the call"
" will fail if any of the files to create are present."
msgstr "``-y`` 选项请求在使用的情况下覆盖文件。若未指定，则若要创建文件已经存在，命令会失效。"

#: ../docs/source/datatypes/functionality.rst:48
msgid ""
"Additional options (often format-specific) exist, and can be discovered "
"passing the ``-h`` option to the command line. For instance:"
msgstr "可能存在附加选项（通常是指定文件），并可以通过命令行传入 ``-h`` 选项获取。例如:"

#: ../docs/source/datatypes/functionality.rst:51
msgid ""
"``verdi data structure export`` accepts a number of formats including "
"``xsf``, ``cif`` and  ``xyz``, and additional parameters like ``--no-reduce-"
"symmetry`` (to be used in combination with the ``tcod`` format to tell AiiDA"
" not to try to reduce simmetry in the output CIF file, etc."
msgstr ""
"``verdi data structure export`` 接受多种文件格式，包括 ``xsf``, ``cif`` 和 ``xyz`` "
"等，并且其附加参数包含如 ``--no-reduce-symmetry`` （可与 ``tcod`` "
"文件格式结合使用，以告知AiiDA不尝试在输出的CIF文件中减少对称性）等。"

#: ../docs/source/datatypes/functionality.rst:55
msgid ""
"``verdi data trajectory export`` accepts a number of formats including "
"``xsf`` and  ``cif``, and additional parameters like ``--step NUM`` (to "
"choose to export only a given trajectory step)."
msgstr ""
"``verdi data trajectory export`` 接受多种文件格式，包括 ``xsf`` 和 ``cif`` 等，其附加参数包括 "
"``--step NUM`` （用于选取导出构象的步数）。"

#: ../docs/source/datatypes/functionality.rst:59
msgid ""
"``verdi data bands export`` accepts a number of formats including (see also "
"below) and additional parameters like ``--prettify-format FORMATNAME``, see "
"valid formats below, or ``--y-min-lim``, ``--y-max-lim`` to specify the "
"``y``-axis limits."
msgstr ""
"``verdi data bands export`` 接受多种文件格式（请参阅下文），其附加参数包括 ``--prettify-format "
"FORMATNAME`` （可用格式见下文），``--y-min-lim`` 、 ``--y-max-lim`` （确定 ``y`` 轴上的限制）等。"

#: ../docs/source/datatypes/functionality.rst:66
msgid "Export formats for specific Data types"
msgstr "将特定数据类型导出为文件"

#: ../docs/source/datatypes/functionality.rst:67
msgid ""
"As the formats are specific to the data types, here is a list of some of the"
" export formats available for some of the AiiDA data classes."
msgstr "由于文件格式可由数据类型确定，以下列出一些AiiDA数据类可用的文件格式。"

#: ../docs/source/datatypes/functionality.rst:71
#: ../docs/source/datatypes/index.rst:64
msgid "StructureData"
msgstr "结构数据（StructureData）"

#: ../docs/source/datatypes/functionality.rst:72
#: ../docs/source/datatypes/functionality.rst:83
#: ../docs/source/datatypes/functionality.rst:92
msgid "The following export formats are available:"
msgstr "有以下可用导出文件类型:"

#: ../docs/source/datatypes/functionality.rst:74
#: ../docs/source/datatypes/functionality.rst:85
msgid ""
"``xsf`` (format supported by e.g. XCrySDen and other visualization software;"
" supports periodic cells)"
msgstr "``xsf`` （被诸如XCrySDen等可视化软件支持的文件格式，支持周期性晶胞）"

#: ../docs/source/datatypes/functionality.rst:76
msgid ""
"``xyz`` (classical xyz format, does not typically support periodic cells "
"(even if the cell is indicated in the comment line)"
msgstr "``xyz`` （经典的xyz格式，通常不支持周期性晶胞（即使在命令行中已指定了周期性））"

#: ../docs/source/datatypes/functionality.rst:78
msgid ""
"``cif`` (export to CIF format, without symmetry reduction, i.e. always "
"storing the structure as P1 symmetry)"
msgstr "``cif`` （导出为CIF文件格式，不会损失对称性，即通常把结构以P1空间群来保存）"

#: ../docs/source/datatypes/functionality.rst:82
#: ../docs/source/datatypes/index.rst:99
msgid "TrajectoryData"
msgstr "构象数据（TrajectoryData）"

#: ../docs/source/datatypes/functionality.rst:87
msgid ""
"``cif`` (export to CIF format, without symmetry reduction, i.e. always "
"storing the structures as P1 symmetry)"
msgstr "``cif`` （导出为CIF文件格式，不会推倒还原对称性，即通常把结构以P1空间群来保存）"

#: ../docs/source/datatypes/functionality.rst:94
msgid "``agr``: export a Xmgrace .agr file with the band plot"
msgstr "``agr`` : 导出一个包含能带图的Xmgrace .agr文件"

#: ../docs/source/datatypes/functionality.rst:95
msgid ""
"``agr_batch``: export a Xmgrace batch file together with an independent .dat"
" file"
msgstr "``agr_batch``: 导出一个Xmgrace批处理文件以及一个独立的 .dat 文件"

#: ../docs/source/datatypes/functionality.rst:96
msgid ""
"``dat_blocks``: export a .dat file, where each line has a data point (xy) "
"and bands are separated in blocks with empty lines"
msgstr "``dat_blocks``: 导出一个 .dat 文件，其每一行都包含一个数据点（xy），能带用空行分块"

#: ../docs/source/datatypes/functionality.rst:98
msgid ""
"``dat_multicolumn``: export a .dat file, where each line has all the values "
"for a given x coordinate: ``x y1 y2 y3 y4 ...`` (``x`` being a linear "
"coordinate along the band path and ``yN`` being the band energies)"
msgstr ""
"``dat_multicolumn``: 导出一个 .dat 文件，其每一行都包含全部给定的x坐标值：``x y1 y2 y3 y4 ...`` （ "
"``x`` 是一个沿能带路径的线性坐标， ``yN`` 是对应能级的能量）"

#: ../docs/source/datatypes/functionality.rst:101
msgid "``gnuplot``: export a gnuplot file, together with a .dat file"
msgstr " ``gnuplot``: 导出一个gnuplot文件和一个 .dat 文件"

#: ../docs/source/datatypes/functionality.rst:102
msgid "``json``: export a json file with the bands divided into segments"
msgstr "``json``: 导出一个包含分段的能带信息的json文件"

#: ../docs/source/datatypes/functionality.rst:103
msgid ""
"``mpl_singlefile``: export a python file that when executed shows a plot "
"using the ``matplotlib`` module. All data is included in the same python "
"file as a multiline string containing the data in json format."
msgstr ""
"``mpl_singlefile``: 导出一个python文件，执行后可由 ``matplotlib`` "
"模块显示图线。全部的数据都存储为json格式并以一个多行字符串的形式被包含在同一个python文件中。"

#: ../docs/source/datatypes/functionality.rst:106
msgid ""
"``mpl_withjson``: As above, but the json data is stored separately in a "
"different file"
msgstr "``mpl_withjson``: 同上，但json数据分开到一个不同的文件中"

#: ../docs/source/datatypes/functionality.rst:107
msgid ""
"``mpl_pdf``: As above, but after creating the .py file it runs it to export "
"the band structure in a PDF file (vectorial). **NOTE**: it requires that you"
" have the python ``matplotlib`` module installed. If ``use_latex`` is true, "
"it requires that you have LaTeX installed on your system to typeset the "
"labels, as well as the ``dvipng`` binary."
msgstr ""
"``mpl_pdf``: 同上，但创建 .py 文件后将自动运行并将能带结构（以矢量图的形式）导出到一个 PDF 文件。**注意**：这需要你预先安装好"
" ``matplotlib`` 模块。若 ``use_latex`` 为真，则需要预先将 LaTeX 和 ``dvipng`` "
"二进制文件安装在系统中以排版其中的标签。"

#: ../docs/source/datatypes/functionality.rst:111
msgid ""
"``mpl_png``: As above, but after creating the .py file it runs it to export "
"the band structure in a PDF file (vectorial). **NOTE**: this format has the "
"same dependencies as the ``mpl_pdf`` format above."
msgstr ""
"``mpl_png``: 同上，但在创建 .py 文件后将自动运行并将能带结构（以矢量图的形式）导出到一个 PDF 文件。**注意**：此格式与上述的 "
"``mpl_pdf`` 格式具有相同的依赖要求。"

#: ../docs/source/datatypes/functionality.rst:116
msgid "Label prettifiers"
msgstr "标签美化"

#: ../docs/source/datatypes/functionality.rst:117
msgid ""
"AiiDA provides a number of functions to \"prettify\" the labels of band "
"structures (if labels are present in the data node), i.e., replace ``GAMMA``"
" with :math:`\\Gamma` or ``K_1`` with :math:`K_{1}` for instance. This makes"
" sense for some output formats (e.g. Xmgrace, Gnuplot, matplotlib)."
msgstr ""
"AiiDA提供一系列函数用于“美化”标签和能带结构（如果标签在数据节点中出现），举例的话也就是说，可以将 ``GAMMA`` 替换为 "
":math:`\\Gamma` ，将 ``K_1`` 替换为 :math:`K_{1}` 。这对于一些文件输出格式生效（例如Xmgrace, "
"Gnuplot, matplotlib等）。"

#: ../docs/source/datatypes/functionality.rst:123
msgid ""
"The prettifier functions are defined as methods of the "
":py:class:`~aiida.common.utils.Prettifier` class. and can be obtained "
"calling "
":py:meth:`Prettifier.get_prettifiers()<aiida.common.utils.Prettifier.get_prettifiers>`."
msgstr ""
"美化函数被定义为 :py:class:`~aiida.common.utils.Prettifier` 类的方法，并可通过 "
":py:meth:`Prettifier.get_prettifiers()<aiida.common.utils.Prettifier.get_prettifiers>`"
" 调用。"

#: ../docs/source/datatypes/functionality.rst:128
msgid "The prettifiers should be chosen depending on two aspects:"
msgstr "美化应依据两个方面选取："

#: ../docs/source/datatypes/functionality.rst:130
msgid ""
"how the raw labels are stored in the database. Two types exist currently: "
"``seekpath``, as used in the ``seekpath`` module, where Greek letters are "
"written explicitly (e.g. ``GAMMA``) and underscores are used to indicate a "
"subscript (``K_1``); and the \"old\" ``simple`` format, where "
":math:`\\Gamma` is indicated with ``G`` and there is no underscore symbol)."
msgstr ""
"标签是如何被存储在数据库中的。目前有两种类型：一种是 ``seekpath`` ，被应用在 ``seekpath`` "
"模块中，其中希腊字母被明确地写出（例如 ``GAMMA`` ）并且下划线被用于指示下标（如 ``K_1`` ）；另一种是“旧的”  ``simple``"
"  格式，其中 :math:`\\Gamma` 由 ``G`` 表示，并且不包含下划线。"

#: ../docs/source/datatypes/functionality.rst:136
msgid ""
"depending on the output format: xmgrace has a specific syntax for Greek "
"letters and subscripts, matplotlib uses LaTeX syntax, etc."
msgstr "取决于输出文件的格式：xmgrace有一套特别的希腊字母和下标的书写语法，而matplotlib则使用LaTeX语法等。"

#: ../docs/source/datatypes/functionality.rst:139
msgid ""
"Most export formats already decide which prettifier is best to use, but if "
"you need to change it, you can do it passing the ``prettify_format`` "
"parameter to the :py:meth:`~aiida.orm.nodes.data.data.Data.export()` method."
" Valid prettifiers include:"
msgstr ""
"大多数导出文件格式已预先确定最佳的美化方法，但若你需要将其修改，你可以向 "
":py:meth:`~aiida.orm.nodes.data.data.Data.export()` 方法传入 ``prettify_format``"
" 参数。有效的美化方法包括:"

#: ../docs/source/datatypes/functionality.rst:143
msgid ""
"``agr_seekpath``: format for Xmgrace, using ``seekpath`` raw label syntax"
msgstr "``agr_seekpath``: Xmgrace格式，使用 ``seekpath`` 原始标签语法"

#: ../docs/source/datatypes/functionality.rst:144
msgid "``agr_simple``: format for Xmgrace, using ``simple`` raw label syntax"
msgstr "``agr_simple``: Xmgrace格式，使用 ``simple`` 原始标签语法"

#: ../docs/source/datatypes/functionality.rst:145
msgid ""
"``latex_simple``: format for LaTeX (including dollar signs), using "
"``seekpath`` raw label syntax"
msgstr "``latex_simple``: LaTeX格式（包含美元符号），使用 ``seekpath`` 原始标签语法"

#: ../docs/source/datatypes/functionality.rst:146
msgid ""
"``latex_seekpath``: format for LaTeX (including dollar signs), using "
"``simple`` raw label syntax"
msgstr "``latex_seekpath``: LaTeX格式（包含美元符号），使用 ``simple`` 原始标签语法"

#: ../docs/source/datatypes/functionality.rst:147
msgid ""
"``gnuplot_simple``: format for GNUPlot (Unicode for Greek letters, LaTeX "
"syntax `without` dollar signs for underscores), using ``seekpath`` raw label"
" syntax"
msgstr ""
"``gnuplot_simple``: GNUPlot格式（用Unicode表示希腊字母，采用 `不含` 美元符号的LaTeX语法处理下划线），采用 "
"``seekpath`` 原始标签语法"

#: ../docs/source/datatypes/functionality.rst:148
msgid ""
"``gnuplot_seekpath``: format for GNUPlot (Unicode for Greek letters, LaTeX "
"syntax `without` dollar signs for underscores), using ``simple`` raw label "
"syntax"
msgstr ""
"``gnuplot_seekpath``: GNUPlot格式（用Unicode表示希腊字母，采用 `不含` 美元符号的LaTeX语法处理下划线），采用"
" ``simple`` 原始标签语法"

#: ../docs/source/datatypes/functionality.rst:149
msgid ""
"``pass``: no-op prettifier: leaves all strings unchanged to their raw value"
msgstr "``pass``: 不进行美化操作：以字符串形式保留全部原始值"

#: ../docs/source/datatypes/index.rst:5
msgid "AiiDA data types"
msgstr "AiiDA数据类型"

#: ../docs/source/datatypes/index.rst:7
msgid "There are a number of data types distributed with AiiDA."
msgstr "AiiDA包含多种多样的数据类型。"

#: ../docs/source/datatypes/index.rst:9
msgid ""
"We summarize here the most common, and some useful features/functionalities "
"to work with them."
msgstr "以下总结最常用的部分，并介绍它们一些有用的特性/功能。"

#: ../docs/source/datatypes/index.rst:13
msgid "Most common datatypes"
msgstr "最常用的数据类型"

#: ../docs/source/datatypes/index.rst:15
msgid ""
"Here follows a short summary of common datatypes already provided with "
"AiiDA. This list is not complete, see also inside "
":py:mod:`aiida.orm.nodes.data` for the list of all available plugins."
msgstr ""
"以下小结AiiDA已经提供的常用数据类型。这一列表尚未完成，也可访问 :py:mod:`aiida.orm.nodes.data` 获取全部可用插件。"

#: ../docs/source/datatypes/index.rst:18
msgid ""
"We also mention, when relevant, what is stored in the database (as "
"attributes, so that it can be easily queried e.g. with the "
":ref:`QueryBuilder <UsingQueryBuilder>`) and what is stored in the file "
"repository (providing access to the file contents, but not efficiently "
"queryable: this is useful for e.g. big data files that don't need to be "
"queried for)."
msgstr ""
"我们也提到过，对于相关数据，哪些被存储在数据库中（例如属性（attributes），则它们可被容易地访问，例如通过 :ref:`QueryBuilder"
" <UsingQueryBuilder>` "
"），哪些会被存储在文件仓库中（提供对文件内容的直接访问，但不便于查询，便于存储诸如较大的不需被访问的数据文件）。"

#: ../docs/source/datatypes/index.rst:23
msgid ""
"For all data types, you can follow the link to the data class to read more "
"about the methods provided, how to access them, and so on."
msgstr "对于全部的数据类型，你都可以点击数据类的链接以获取更多信息如提供的方法、如何访问等等。"

#: ../docs/source/datatypes/index.rst:26
msgid ""
"If you need to work with some specific type of data, first check the list of"
" data types/plugins below, and if you don't find what you need, give a look "
"to :ref:`how to write a new data plugin <DevelopDataPluginTutorialFloat>`."
msgstr ""
"若你需要使用特定的数据类型，首先检查如下的数据类型和插件列表，若你未找到所需，请参阅 :ref:`how to write a new data "
"plugin <DevelopDataPluginTutorialFloat>` 。"

#: ../docs/source/datatypes/index.rst:31
msgid "Base types"
msgstr "基础类型"

#: ../docs/source/datatypes/index.rst:32
msgid ""
"In the :py:mod:`aiida.orm.nodes.data.base` module there are a number of "
"useful classes that wrap base python datatypes (like "
":py:class:`~aiida.orm.nodes.data.int.Int`, "
":py:class:`~aiida.orm.nodes.data.float.Float`, "
":py:class:`~aiida.orm.nodes.data.str.Str`, ...). These are automatically "
"loaded with the verdi shell, and also directly exposed from "
":py:mod:`aiida.orm`. These classes are particularly useful when you need to "
"provide a single parameter to e.g. a "
":py:class:`~aiida.engine.processes.functions.workfunction`."
msgstr ""
"在 :py:mod:`aiida.orm.nodes.data.base` 模块中包含了多种包含基本python数据类型的类（比如 "
":py:class:`~aiida.orm.nodes.data.int.Int`, "
":py:class:`~aiida.orm.nodes.data.float.Float`, "
":py:class:`~aiida.orm.nodes.data.str.Str`, ...）。这些数据类型会被verdi shell自动加载，并可由 "
":py:mod:`aiida.orm` 直接访问。这些类在你需要提供单独的参数时特别有用，例如提供参数给 "
":py:class:`~aiida.engine.processes.functions.workfunction` 。"

#: ../docs/source/datatypes/index.rst:39
msgid ""
"Each of these classes can most often be used transparently (e.g. you can sum"
" two :py:class:`~aiida.orm.nodes.data.int.Int` objects, etc.). If you need "
"to access the bare value and not the whole AiiDA class, use the ``.value`` "
"property."
msgstr ""
"这些类中的每一个都可以被透明地调用（例如你可以将两个 :py:class:`~aiida.orm.nodes.data.int.Int` "
"对象直接加和）。若你需要访问其实际值而不是AiiDA类，你可以使用 ``.value`` 性质。"

#: ../docs/source/datatypes/index.rst:43
msgid ""
"In the same module, there is also a "
":py:class:`~aiida.orm.nodes.data.list.List` class to store a list of base "
"data types."
msgstr "在同一模块中，也同样有 :py:class:`~aiida.orm.nodes.data.list.List` 类存储基本数据类型的列表。"

#: ../docs/source/datatypes/index.rst:46
msgid ""
"The different datatypes can be accessed through the "
":py:func:`~aiida.plugins.factories.DataFactory` function (also exposed from "
":py:mod:`aiida.plugins`) by passing an entry point to it as an argument. A "
"list of all the data entry points can be obtain running the command ``verdi "
"plugin list aiida.data``."
msgstr ""
"不同的数据类型可由 :py:func:`~aiida.plugins.factories.DataFactory` 函数（同样可由 "
":py:mod:`aiida.plugins` 直接访问）访问，传入的参数是一个入口。包含全部数据入口的列表可通过运行 ``verdi plugin "
"list aiida.data`` 命令得到。"

#: ../docs/source/datatypes/index.rst:51
msgid "Dict"
msgstr "字典（Dict）"

#: ../docs/source/datatypes/index.rst:53
msgid "**Class**: :py:class:`~aiida.orm.nodes.data.dict.Dict`"
msgstr "**类**: :py:class:`~aiida.orm.nodes.data.dict.Dict`"

#: ../docs/source/datatypes/index.rst:54
msgid ""
"**String to pass to the** :py:func:`~aiida.plugins.factories.DataFactory`: "
"``dict``"
msgstr ""
"**须传入** :py:func:`~aiida.plugins.factories.DataFactory` **的字符串**: ``dict``"

#: ../docs/source/datatypes/index.rst:55
msgid ""
"**Aim**: store a dictionary of python base types in the database. It can "
"store any dictionary where elements can be a base python type (strings, "
"floats, integers, booleans, None type, datetime objects) and lists or "
"dictionaries of them, at any depth level (e.g. a dictionary where a value is"
" a list of dictionaries of strings and floats)."
msgstr ""
"**功能**: "
"在数据库中存储一个python基本数据类型中的字典。其可以存储任何包含任何层次的字典，其中元素可以是一个python基本数据类型（字符串、浮点数、整数、布尔型、空类型、日期等）或它们构成的列表和字典（例如一个值为一个包含字符串和浮点数的字典的列表）。"

#: ../docs/source/datatypes/index.rst:60
msgid "**What is stored in the database**: all key/values pairs as attributes"
msgstr "**数据库中存储的信息**: 以属性方式存储其全部键值对"

#: ../docs/source/datatypes/index.rst:61 ../docs/source/datatypes/index.rst:70
#: ../docs/source/datatypes/index.rst:177
msgid "**What is stored in the file repository**: ---"
msgstr "**文件仓库中存储的信息**: ---"

#: ../docs/source/datatypes/index.rst:66
msgid "**Class**: :py:class:`~aiida.orm.nodes.data.structure.StructureData`"
msgstr "**类**: :py:class:`~aiida.orm.nodes.data.structure.StructureData`"

#: ../docs/source/datatypes/index.rst:67
msgid ""
"**String to pass to the** :py:func:`~aiida.plugins.factories.DataFactory`: "
"``structure``"
msgstr ""
"**须传入**:py:func:`~aiida.plugins.factories.DataFactory` **的字符串**: "
"``structure``"

#: ../docs/source/datatypes/index.rst:68
msgid "**Aim**: store a crystal structure to be used by atomistic codes"
msgstr "**功能**: 存储晶体结构信息"

#: ../docs/source/datatypes/index.rst:69
msgid ""
"**What is stored in the database**: all atomic positions, species, kinds,"
msgstr "**数据库中存储的信息**: 全部原子的坐标、元素、种类等"

#: ../docs/source/datatypes/index.rst:71
#: ../docs/source/datatypes/index.rst:108
#: ../docs/source/datatypes/index.rst:123
#: ../docs/source/datatypes/index.rst:135
msgid "**Additional functionality**:"
msgstr "**额外功能** :"

#: ../docs/source/datatypes/index.rst:73
msgid ":ref:`Examples of usage<structure_tutorial>`"
msgstr ":ref:`使用案例<structure_tutorial>`"

#: ../docs/source/datatypes/index.rst:74
#: ../docs/source/datatypes/index.rst:110
msgid ":ref:`Export to a number of formats (xsf, cif, ...)<ExportDataNodes>`"
msgstr ":ref:`导出为多种文件格式 (xsf, cif, ...)<ExportDataNodes>`"

#: ../docs/source/datatypes/index.rst:77
msgid "UpfData"
msgstr "UpfData"

#: ../docs/source/datatypes/index.rst:79
msgid "**Class**: :py:class:`~aiida.orm.nodes.data.upf.UpfData`"
msgstr "**类**: :py:class:`~aiida.orm.nodes.data.upf.UpfData`"

#: ../docs/source/datatypes/index.rst:80
msgid ""
"**String to pass to the** :py:func:`~aiida.plugins.factories.DataFactory`: "
"``upf``"
msgstr ""
"**须传入**:py:func:`~aiida.plugins.factories.DataFactory` **的字符串**: ``upf``"

#: ../docs/source/datatypes/index.rst:81
msgid ""
"**Aim**: store a pseudopotential in the .UPF format (e.g. used by `Quantum "
"ESPRESSO`_ - see also the `AiiDA Quantum ESPRESSO plugin`_)"
msgstr ""
"**功能**: 存储 .UPF格式的赝势文件（例如 `Quantum ESPRESSO`_ 使用的文件，请参阅 `AiiDA Quantum "
"ESPRESSO plugin`_）"

#: ../docs/source/datatypes/index.rst:82
msgid ""
"**What is stored in the database**: the MD5 of the UPF; the element the "
"pseudopotential is associated to"
msgstr "**数据库中存储的信息**: UPF的MD5，赝势文件对应的元素类型"

#: ../docs/source/datatypes/index.rst:84
msgid "**What is stored in the file repository**: the pseudopotential file"
msgstr "**文件仓库中存储的信息**: 赝势文件"

#: ../docs/source/datatypes/index.rst:90
msgid "ArrayData"
msgstr "数组结构（ArrayData）"

#: ../docs/source/datatypes/index.rst:92
msgid "**Class**: :py:class:`~aiida.orm.nodes.data.array.ArrayData`"
msgstr "**类**: :py:class:`~aiida.orm.nodes.data.array.ArrayData`"

#: ../docs/source/datatypes/index.rst:93
msgid ""
"**String to pass to the** :py:func:`~aiida.plugins.factories.DataFactory`: "
"``array``"
msgstr ""
"**须传入**:py:func:`~aiida.plugins.factories.DataFactory` **的字符串**: ``array``"

#: ../docs/source/datatypes/index.rst:94
msgid "**Aim**: store generic numeric arrays"
msgstr "**功能**: 存储通用数组"

#: ../docs/source/datatypes/index.rst:95
msgid ""
"**What is stored in the database**: the shape of the arrays and the name of "
"the arrays"
msgstr "**数据库中存储的信息**: 数组的形状和命名"

#: ../docs/source/datatypes/index.rst:96
msgid ""
"**What is stored in the file repository**: the array data in numpy format"
msgstr "**文件仓库中存储的信息**: 以numpy格式存储的数组信息"

#: ../docs/source/datatypes/index.rst:100
msgid ""
"**Class**: :py:class:`~aiida.orm.nodes.data.array.trajectory.TrajectoryData`"
msgstr ""
"**类**: :py:class:`~aiida.orm.nodes.data.array.trajectory.TrajectoryData`"

#: ../docs/source/datatypes/index.rst:101
msgid ""
"**String to pass to the** :py:func:`~aiida.plugins.factories.DataFactory`: "
"``array.trajectory``"
msgstr ""
"**须传入**:py:func:`~aiida.plugins.factories.DataFactory` **的字符串**: "
"``array.trajectory``"

#: ../docs/source/datatypes/index.rst:102
msgid ""
"**Aim**: store molecular trajectories (i.e. sequences of StructureData "
"objects, where then number of atomic kinds and sites does not change over "
"time). beside the coordinates, it can also optionally store velocities."
msgstr ""
"**功能**: "
"存储分子构象（也就是StructureData对象的序列，StructureData对象中各个原子的元素种类、位置不随时间而改变）。除了坐标，速度信息也可以被选择性存储。"

#: ../docs/source/datatypes/index.rst:105
msgid "**What is stored in the database**: like ``ArrayData``"
msgstr "**数据库中存储的信息**: 类似 ``ArrayData``"

#: ../docs/source/datatypes/index.rst:106
msgid ""
"**What is stored in the file repository**: the array data in numpy format: "
"cells over time, integer indices over time, atomic positions over time, the "
"list of kinds, ..."
msgstr "**文件仓库中存储的信息**: 以numpy格式存储的数组信息：包括随时间变化的晶胞信息、晶面指数、原子位置和元素种类等等……"

#: ../docs/source/datatypes/index.rst:113
msgid "KpointsData"
msgstr "KpointsData"

#: ../docs/source/datatypes/index.rst:115
msgid "**Class**: :py:class:`~aiida.orm.nodes.data.array.kpoints.KpointsData`"
msgstr "**类**: :py:class:`~aiida.orm.nodes.data.array.kpoints.KpointsData`"

#: ../docs/source/datatypes/index.rst:116
msgid ""
"**String to pass to the** :py:func:`~aiida.plugins.factories.DataFactory`: "
"``array.kpoints``"
msgstr ""
"**须传入**:py:func:`~aiida.plugins.factories.DataFactory` **的字符串**: "
"``array.kpoints``"

#: ../docs/source/datatypes/index.rst:117
msgid ""
"**Aim**: store grids of k-points (in reciprocal space, for crystal "
"structures), or explicit list of k-points (optionally with a weight "
"associated to each one). Can also associate labels to (some of the) points, "
"which is very useful for later plottings band structures (and store them in "
"``BandsData`` objects)."
msgstr ""
"**功能**: "
"存储k点的网格（对于晶体结构来说是在倒易空间中），或者明确的k点列表（可选包含每一个的权重）。也可以与（一些）点的标签联系，这对于之后的能带结构作图很有用（在"
" ``BandsData`` 对象中存储）。"

#: ../docs/source/datatypes/index.rst:121
#: ../docs/source/datatypes/index.rst:133
#: ../docs/source/datatypes/index.rst:145
msgid ""
"**What is stored in the database**: like ``ArrayData``, the shape of the "
"arrays and the name of the arrays"
msgstr "**数据库中存储的信息**: 类似 ``ArrayData``，包含数组的形状和命名"

#: ../docs/source/datatypes/index.rst:122
#: ../docs/source/datatypes/index.rst:134
#: ../docs/source/datatypes/index.rst:146
msgid ""
"**What is stored in the file repository**:  like ``ArrayData``, the array "
"data in numpy format"
msgstr "**文件仓库中存储的信息**: 类似 ``ArrayData`` ，以numpy格式存储的数组信息"

#: ../docs/source/datatypes/index.rst:125
msgid ""
":ref:`Automatically compute k-points path given a crystal "
"structure<AutomaticKpoints>`"
msgstr ":ref:`通过晶格结构自动计算k点路径给出晶格结构<AutomaticKpoints>`"

#: ../docs/source/datatypes/index.rst:130
msgid "**Class**: :py:class:`~aiida.orm.nodes.data.array.bands.BandsData`"
msgstr "**类**: :py:class:`~aiida.orm.nodes.data.array.bands.BandsData`"

#: ../docs/source/datatypes/index.rst:131
msgid ""
"**String to pass to the** :py:func:`~aiida.plugins.factories.DataFactory`: "
"``array.bands``"
msgstr ""
"**须传入**:py:func:`~aiida.plugins.factories.DataFactory` **的字符串**: "
"``array.bands``"

#: ../docs/source/datatypes/index.rst:132
msgid "**Aim**: store electronic structure bands (of phonon bands)"
msgstr "**功能**: 存储一些电子结构能带（或者声子能带）"

#: ../docs/source/datatypes/index.rst:137
msgid ""
":ref:`Export to a number of formats (xmgrace, gnuplot, png, pdf, "
"...)<ExportDataNodes>`"
msgstr ":ref:`导出为多种文件格式 (xmgrace, gnuplot, png, pdf, ...)<ExportDataNodes>`"

#: ../docs/source/datatypes/index.rst:140
msgid "XyData"
msgstr "XyData"

#: ../docs/source/datatypes/index.rst:142
msgid "**Class**: :py:class:`~aiida.orm.nodes.data.array.xy.XyData`"
msgstr "**类**: :py:class:`~aiida.orm.nodes.data.array.xy.XyData`"

#: ../docs/source/datatypes/index.rst:143
msgid ""
"**String to pass to the** :py:func:`~aiida.plugins.factories.DataFactory`: "
"``array.xy``"
msgstr ""
"**须传入**:py:func:`~aiida.plugins.factories.DataFactory` **的字符串**: "
"``array.xy``"

#: ../docs/source/datatypes/index.rst:144
msgid "**Aim**: store data for a 2D (xy) plot"
msgstr "**功能**: 为一张2D (xy) 图存储数据"

#: ../docs/source/datatypes/index.rst:149
msgid "FolderData"
msgstr "文件夹数据（FolderData）"

#: ../docs/source/datatypes/index.rst:151
msgid "**Class**: :py:class:`~aiida.orm.nodes.data.folder.FolderData`"
msgstr "**类**:  :py:class:`~aiida.orm.nodes.data.folder.FolderData`"

#: ../docs/source/datatypes/index.rst:152
msgid ""
"**String to pass to the** :py:func:`~aiida.plugins.factories.DataFactory`: "
"``folder``"
msgstr ""
"**须传入**:py:func:`~aiida.plugins.factories.DataFactory` **的字符串**: ``folder``"

#: ../docs/source/datatypes/index.rst:153
msgid ""
"**Aim**: store a set of files/folders (with possibly a folder/subfolder "
"structure)"
msgstr "**功能**: 存储一系列文件或文件夹（可能包含子文件夹结构）"

#: ../docs/source/datatypes/index.rst:154
msgid "**What is stored in the database**: ---"
msgstr "**数据库中存储的信息**: ---"

#: ../docs/source/datatypes/index.rst:155
msgid "**What is stored in the file repository**: all files and folders"
msgstr "**文件仓库中存储的信息**: 所有的文件和文件夹"

#: ../docs/source/datatypes/index.rst:158
msgid "SinglefileData"
msgstr "单一文件信息（SinglefileData）"

#: ../docs/source/datatypes/index.rst:159
msgid "**Class**: :py:class:`~aiida.orm.nodes.data.singlefile.SinglefileData`"
msgstr "**类**: :py:class:`~aiida.orm.nodes.data.singlefile.SinglefileData`"

#: ../docs/source/datatypes/index.rst:160
msgid ""
"**String to pass to the** :py:func:`~aiida.plugins.factories.DataFactory`: "
"``singlefile``"
msgstr ""
"**须传入**:py:func:`~aiida.plugins.factories.DataFactory` **的字符串**: "
"``singlefile``"

#: ../docs/source/datatypes/index.rst:161
msgid ""
"**Aim**: the same as ``FolderData``, but allows to store only one single "
"file."
msgstr "**功能**: 与 ``FolderData`` 一致，但只允许存储一个文件。"

#: ../docs/source/datatypes/index.rst:162
msgid "**What is stored in the database**: the filename"
msgstr "**数据库中存储的信息**: 文件名"

#: ../docs/source/datatypes/index.rst:163
msgid "**What is stored in the file repository**: the file"
msgstr "**文件仓库中存储的信息**: 文件"

#: ../docs/source/datatypes/index.rst:166
msgid "RemoteData"
msgstr "远程数据（RemoteData）"

#: ../docs/source/datatypes/index.rst:168
msgid "**Class**: :py:class:`~aiida.orm.nodes.data.remote.RemoteData`"
msgstr "**类**:  :py:class:`~aiida.orm.nodes.data.remote.RemoteData`"

#: ../docs/source/datatypes/index.rst:169
msgid ""
"**String to pass to the** :py:func:`~aiida.plugins.factories.DataFactory`: "
"``remote``"
msgstr ""
"**须传入**:py:func:`~aiida.plugins.factories.DataFactory` **的字符串**: ``remote``"

#: ../docs/source/datatypes/index.rst:170
msgid ""
"**Aim**: this basically represents a \"symbolic link\" to a specific folder "
"on a remote computer. Its main use is to allow users to persist the "
"provenance when e.g. a calculation produces data in a raw/scratch folder, "
"and the whole folder needs to be provided to restart/continue."
msgstr ""
"**功能**: "
"主要代表与远程计算机上的一个具体目录间的“符号连接”。主要功能是允许用户保存可验证性，当比如说一个算例在原始或者草稿文件夹产生数据、且整个文件夹需要提供以便重启或继续任务。"

#: ../docs/source/datatypes/index.rst:175
msgid ""
"**What is stored in the database**: the path of the folder (and the remote "
"computer as a `.computer` property, not as an attribute)"
msgstr "**数据库中存储的信息**: 文件夹的路径（以及以 `.computer` 属性函数保存的远程计算机信息，而不是属性）"

#: ../docs/source/datatypes/kpoints.rst:4
msgid "Automatic computation of k-point paths"
msgstr "K-point路径的自动计算"

#: ../docs/source/datatypes/kpoints.rst:5
msgid ""
"AiiDA provides a number of tools and wrappers to automatically compute "
"k-point paths given a cell or a crystal structure."
msgstr "AiiDA提供一系列工具和包装以自动完成对给定晶格或者晶体结构的k-point路径的计算。"

#: ../docs/source/datatypes/kpoints.rst:8
msgid ""
"The main interface is provided by the two methods "
":py:func:`aiida.tools.data.array.kpoints.get_kpoints_path` and "
":py:func:`aiida.tools.data.array.kpoints.get_explicit_kpoints_path`."
msgstr ""
"主要接口由以下两个方法所提供：:py:func:`aiida.tools.data.array.kpoints.get_kpoints_path` 和 "
":py:func:`aiida.tools.data.array.kpoints.get_explicit_kpoints_path`。"

#: ../docs/source/datatypes/kpoints.rst:11
msgid ""
"These methods are also conveniently exported directly as, e.g., "
"``aiida.tools.get_kpoints_path``."
msgstr "这些方法对我们来说也都可以很方便地访问，例如 ``aiida.tools.get_kpoints_path`` 。"

#: ../docs/source/datatypes/kpoints.rst:13
msgid "The difference between the two methods is the following:"
msgstr "两种方法的不同之处在于:"

#: ../docs/source/datatypes/kpoints.rst:15
msgid ""
":py:func:`~aiida.tools.data.array.kpoints.get_kpoints_path` returns a "
"dictionary of k-point coordinates (e.g. ``{'GAMMA': [0. ,0. ,0. ], 'X': "
"[0.5, 0., 0.], 'L': [0.5, 0.5, 0.5]}``, and then a list of tuples of "
"endpoints of each segment, e.g. ``[('GAMMA', 'X'), ('X', 'L'), ('L', "
"'GAMMA')]`` for the :math:`\\Gamma-X-L-\\Gamma` path."
msgstr ""
":py:func:`~aiida.tools.data.array.kpoints.get_kpoints_path` 返回一个k-"
"point坐标的字典（例如 ``{'GAMMA': [0. ,0. ,0. ], 'X': [0.5, 0., 0.], 'L': [0.5, 0.5,"
" 0.5]}`` ），和一个包含了多个元组的列表，元组中包含了每个片段的截止点，例如对于 :math:`\\Gamma-X-L-\\Gamma` "
"路径来说有 ``[('GAMMA', 'X'), ('X', 'L'), ('L', 'GAMMA')]`` 。"

#: ../docs/source/datatypes/kpoints.rst:19
msgid ""
":py:func:`~aiida.tools.data.array.kpoints.get_explicit_kpoints_path`, "
"instead, returns a list of kpoints that follow that path, with some "
"predefined (but user-customizable) distance between points, e.g. something "
"like ``[[0., 0., 0.], [0.05, 0., 0.], [0.1, 0., 0.], ...]``."
msgstr ""
":py:func:`~aiida.tools.data.array.kpoints.get_explicit_kpoints_path` "
"则会返回一个沿着该路径的kpoints的列表，同时还有一些预先定义（或者用户自定义）的点间距离，比如 ``[[0., 0., 0.], [0.05, "
"0., 0.], [0.1, 0., 0.], ...]`` 。"

#: ../docs/source/datatypes/kpoints.rst:23
msgid ""
"Depending on how the underlying code works, one method might be preferred on"
" the other."
msgstr "方法各自的优势取决于以下的代码如何工作。"

#: ../docs/source/datatypes/kpoints.rst:25
msgid ""
"The docstring of the methods describes the expected parameters. The general "
"interface requires always a ``StructureData`` as the first parameter "
"``structure``, as well as a string for the method to use (by default this is"
" `seekpath <https://github.com/giovannipizzi/seekpath/>`_, but also the "
"``legacy`` method implemented in earlier versions of AiiDA is available; see"
" description below)."
msgstr ""
"方法的文档字符串描述了各自所需要的参数。全局接口通常需求 ``StructureData`` 作为第一个参数 ``structure`` "
"，同时需要一个定义使用方法的字符串（默认为 `seekpath "
"<https://github.com/giovannipizzi/seekpath/>`_ ，但早期版本的AiiDA默认为 ``legacy`` "
"方法，请参阅下文描述）。"

#: ../docs/source/datatypes/kpoints.rst:30
msgid ""
"Additional parameters are passed as ``kwargs`` to the underlying "
"implementation, that often accepts a different number of parameters."
msgstr "附加参数在下文中以 ``kwargs`` 形式传入，通常接受不同数目的参数。"

#: ../docs/source/datatypes/kpoints.rst:34
msgid "Seekpath implementation"
msgstr "Seekpath实现"

#: ../docs/source/datatypes/kpoints.rst:35
msgid ""
"When specifying ``method='seekpath'``, the `seekpath "
"<https://github.com/giovannipizzi/seekpath/>`_ library is used to generate "
"the path. Note that this requires  ``seekpath`` to be installed (this is not"
" available by default, in order to reduce the dependencies of AiiDA core, "
"but can be easily installed using ``pip install seekpath``)."
msgstr ""
"当指定 ``method='seekpath'`` ，  `seekpath "
"<https://github.com/giovannipizzi/seekpath/>`_ 库被用于生成路径。注意到这需要预先安装 "
"``seekpath`` （为了减少 AiiDA core 的依赖默认是不提供的，但可以通过 ``pip install seekpath`` "
"命令来快速安装）。"

#: ../docs/source/datatypes/kpoints.rst:39
msgid ""
"For a full description of the accepted parameters, we refer to the docstring"
" of the underlying methods "
":py:func:`aiida.tools.data.array.kpoints.seekpath.get_explicit_kpoints_path`"
" and :py:func:`aiida.tools.data.array.kpoints.seekpath.get_kpoints_path`, "
"and for more general information to the `seekpath documentation "
"<https://seekpath.readthedocs.io/>`_."
msgstr ""
"对各个接受参数的详细解释，请参阅以下方法的文档字符串：:py:func:`aiida.tools.data.array.kpoints.seekpath.get_explicit_kpoints_path`"
" 和 :py:func:`aiida.tools.data.array.kpoints.seekpath.get_kpoints_path`, and "
"for more general information to the `seekpath documentation "
"<https://seekpath.readthedocs.io/>`_ 。"

#: ../docs/source/datatypes/kpoints.rst:44
msgid ""
"If you use this implementation, please cite the `Hinuma paper "
"<https://doi.org/10.1016/j.commatsci.2016.10.015>`_::"
msgstr ""
"若你使用了这一实现，请引用  `Hinuma paper "
"<https://doi.org/10.1016/j.commatsci.2016.10.015>`_::"

#: ../docs/source/datatypes/kpoints.rst:52
msgid "Legacy implementation"
msgstr "Legacy实现"

#: ../docs/source/datatypes/kpoints.rst:53
msgid ""
"This refers to the implementation that has been available since the early "
"versions of AiiDA."
msgstr "这一实现从早期版本的AiiDA开始便被支持。"

#: ../docs/source/datatypes/kpoints.rst:55
msgid ""
"In the 3D case (all three directions have periodic boundary conditions), "
"this implementation expects that the structure is already standardized "
"according to the Setyawan paper. If this is not the case, the kpoints and "
"band structure returned will be incorrect. The only case that is dealt "
"correctly by the library is the case when axes are swapped, where the "
"library correctly takes this swapping/rotation into account to assign kpoint"
" labels and coordinates."
msgstr ""
"在3维的情况下（全部三个方向都包含周期边界条件），这一实现需要结构已经根据Setyawan的文章标准化。如果不是这样，kpoints和能带结构会有错误。唯一可以被该库正确处理的情况是轴被交换的情况，此时库可以正确地考虑交换和旋转，从而排布kpoint标签和坐标。"

#: ../docs/source/datatypes/kpoints.rst:61
msgid ""
"We therefore suggest that you use the seekpath implementation, that is able "
"to automatically correctly identify the standardized crystal structure "
"(primitive and conventional) as described in the `Hinuma paper "
"<https://doi.org/10.1016/j.commatsci.2016.10.015>`_."
msgstr ""
"我们因此建议用户使用seekpath实现，因为此实现可以自动正确识别标准化的晶体结构（元胞或常规），正如 `Hinuma paper "
"<https://doi.org/10.1016/j.commatsci.2016.10.015>`_ 所描述的那样。"

#: ../docs/source/datatypes/kpoints.rst:65
msgid ""
"For a full description of the accepted parameters, we refer to the docstring"
" of the underlying methods "
":py:func:`aiida.tools.data.array.kpoints.legacy.get_explicit_kpoints_path` "
"and :py:func:`aiida.tools.data.array.kpoints.legacy.get_kpoints_path`, and "
"for more general information to the `seekpath documentation "
"<https://seekpath.readthedocs.io/>`_."
msgstr ""
"对于接受参数的完整描述，请参阅以下方法的文档字符串： "
":py:func:`aiida.tools.data.array.kpoints.legacy.get_explicit_kpoints_path` 和"
" :py:func:`aiida.tools.data.array.kpoints.legacy.get_kpoints_path`, and for "
"more general information to the `seekpath documentation "
"<https://seekpath.readthedocs.io/>`_ 。"

#: ../docs/source/datatypes/kpoints.rst:70
msgid ""
"If you use this implementation, please cite the correct reference from the "
"following ones:"
msgstr "若你使用此实现，请正确引用以下的参考文献: "

#: ../docs/source/datatypes/kpoints.rst:72
msgid ""
"The 3D implementation is based on the `Setyawan paper "
"<https://doi.org/10.1016/j.commatsci.2010.05.010>`_::"
msgstr ""
"The 3D implementation is based on the `Setyawan paper "
"<https://doi.org/10.1016/j.commatsci.2010.05.010>`_::"

#: ../docs/source/datatypes/kpoints.rst:79
msgid ""
"The 2D implementation is based on the `Ramirez paper "
"<https://doi.org/10.1002/qua.560300306>`_::"
msgstr ""
"The 2D implementation is based on the `Ramirez paper "
"<https://doi.org/10.1002/qua.560300306>`_::"
