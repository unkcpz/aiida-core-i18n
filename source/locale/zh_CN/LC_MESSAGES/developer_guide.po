# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2019, ECOLE POLYTECHNIQUE FEDERALE DE LAUSANNE (Theory and Simulation of Materials (THEOS) and National Centre for Computational Design and Discovery of Novel Materials (NCCR MARVEL)), Switzerland and ROBERT BOSCH LLC, USA. All rights reserved
# This file is distributed under the same license as the AiiDA package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: AiiDA 1.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-10-31 22:43+0000\n"
"PO-Revision-Date: 2019-05-17 20:00+0000\n"
"Language-Team: Chinese (China) (https://www.transifex.com/aiidateam/teams/98967/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../docs/source/developer_guide/core.rst:3
msgid "Core development"
msgstr ""

#: ../docs/source/developer_guide/core/caching.rst:2
msgid "Caching: implementation details"
msgstr ""

#: ../docs/source/developer_guide/core/caching.rst:4
msgid ""
"This section covers some details of the caching mechanism which are not "
"discussed in the :ref:`user guide <caching>`. If you are developing a plugin"
" and want to modify the caching behavior of your classes, we recommend you "
"read :ref:`this section <caching_matches>` first."
msgstr ""

#: ../docs/source/developer_guide/core/caching.rst:10
msgid "Controlling hashing"
msgstr ""

#: ../docs/source/developer_guide/core/caching.rst:12
msgid ""
"Below are some methods you can use to control how the hashes of calculation "
"and data classes are computed:"
msgstr ""

#: ../docs/source/developer_guide/core/caching.rst:14
msgid ""
"To ignore specific attributes, a :py:class:`~aiida.orm.nodes.Node` subclass "
"can have a ``_hash_ignored_attributes`` attribute. This is a list of "
"attribute names, which are ignored when creating the hash."
msgstr ""

#: ../docs/source/developer_guide/core/caching.rst:16
msgid ""
"For calculations, the ``_hash_ignored_inputs`` attribute lists inputs that "
"should be ignored when creating the hash."
msgstr ""

#: ../docs/source/developer_guide/core/caching.rst:17
msgid ""
"To add things which should be considered in the hash, you can override the "
":meth:`~aiida.orm.nodes.Node._get_objects_to_hash` method. Note that doing "
"so overrides the behavior described above, so you should make sure to use "
"the ``super()`` method."
msgstr ""

#: ../docs/source/developer_guide/core/caching.rst:18
msgid ""
"Pass a keyword argument to :meth:`~aiida.orm.nodes.Node.get_hash`. These are"
" passed on to :meth:`~aiida.common.hashing.make_hash`."
msgstr ""

#: ../docs/source/developer_guide/core/caching.rst:24
msgid "Controlling caching"
msgstr ""

#: ../docs/source/developer_guide/core/caching.rst:26
msgid ""
"There are two methods you can use to disable caching for particular nodes:"
msgstr ""

#: ../docs/source/developer_guide/core/caching.rst:28
msgid ""
"The :meth:`~aiida.orm.nodes.Node.is_valid_cache` property determines whether"
" a particular node can be used as a cache. This is used for example to "
"disable caching from failed calculations."
msgstr ""

#: ../docs/source/developer_guide/core/caching.rst:29
msgid ""
"Node classes have a ``_cachable`` attribute, which can be set to ``False`` "
"to completely switch off caching for nodes of that class. This avoids "
"performing queries for the hash altogether."
msgstr ""

#: ../docs/source/developer_guide/core/caching.rst:32
msgid "The ``WorkflowNode`` example"
msgstr ""

#: ../docs/source/developer_guide/core/caching.rst:34
msgid ""
"As discussed in the :ref:`user guide <caching_limitations>`, nodes which can"
" have ``RETURN`` links cannot be cached. This is enforced on two levels:"
msgstr ""

#: ../docs/source/developer_guide/core/caching.rst:37
msgid ""
"The ``_cachable`` property is set to ``False`` in the "
":class:`~aiida.orm.nodes.process.ProcessNode`, and only re-enabled in "
":class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode` and "
":class:`~aiida.orm.nodes.process.calculation.calcfunction.CalcFunctionNode`."
" This means that a "
":class:`~aiida.orm.nodes.process.workflow.workflow.WorkflowNode` will not be"
" cached."
msgstr ""

#: ../docs/source/developer_guide/core/caching.rst:39
msgid ""
"The ``_store_from_cache`` method, which is used to \"clone\" an existing "
"node, will raise an error if the existing node has any ``RETURN`` links. "
"This extra safe-guard prevents cases where a user might incorrectly override"
" the ``_cachable`` property on a ``WorkflowNode`` subclass."
msgstr ""

#: ../docs/source/developer_guide/core/caching.rst:43
#: ../docs/source/developer_guide/plugins/basics.rst:41
msgid "Design guidelines"
msgstr ""

#: ../docs/source/developer_guide/core/caching.rst:45
msgid ""
"When modifying the hashing/caching behaviour of your classes, keep in mind "
"that cache matches can go wrong in two ways:"
msgstr ""

#: ../docs/source/developer_guide/core/caching.rst:47
msgid ""
"False negatives, where two nodes *should* have the same hash but do not"
msgstr ""

#: ../docs/source/developer_guide/core/caching.rst:48
msgid ""
"False positives, where two different nodes get the same hash by mistake"
msgstr ""

#: ../docs/source/developer_guide/core/caching.rst:50
msgid ""
"False negatives are **highly preferrable** because they only increase the "
"runtime of your calculations, while false positives can lead to wrong "
"results."
msgstr ""

#: ../docs/source/developer_guide/core/extend_restapi.rst:6
msgid "How to extend the AiiDA REST API"
msgstr ""

#: ../docs/source/developer_guide/core/extend_restapi.rst:8
msgid "The AiIDA REST API is made of two main classes:"
msgstr ""

#: ../docs/source/developer_guide/core/extend_restapi.rst:10
msgid ""
"``App``, inheriting ``flask.Flask``. The latter represents any Flask web "
"app, including REST APIs."
msgstr ""

#: ../docs/source/developer_guide/core/extend_restapi.rst:12
msgid ""
"``Api``, inheriting ``flask_restful.Api``. This represents the API itself."
msgstr ""

#: ../docs/source/developer_guide/core/extend_restapi.rst:14
msgid ""
"Once instanciated both ``Api`` and ``App`` classes into, say, ``app`` and "
"``api``, these two objects have to be coupled by adding ``app`` as one of "
"the attributes of ``api``. As we will see in a moment, we provide a function"
" that, besides other things, does exactly this."
msgstr ""

#: ../docs/source/developer_guide/core/extend_restapi.rst:18
msgid ""
"In a Flask API the resources, e.g. *Nodes*, *ProcessNodes*, etc., are "
"represented by ``flask_restful.Resource``-derived classes."
msgstr ""

#: ../docs/source/developer_guide/core/extend_restapi.rst:21
msgid ""
"If you need to include additional endpoints besides those built in the AiiDA"
" REST API you should:"
msgstr ""

#: ../docs/source/developer_guide/core/extend_restapi.rst:23
msgid "create the resource classes that will be bound to the new endpoints;"
msgstr ""

#: ../docs/source/developer_guide/core/extend_restapi.rst:24
msgid ""
"extend the class ``Api`` into a user-defined class to register the new "
"endpoints."
msgstr ""

#: ../docs/source/developer_guide/core/extend_restapi.rst:25
msgid ""
"(Optional) Extend ``App`` into a user-defined class for finer customization."
msgstr ""

#: ../docs/source/developer_guide/core/extend_restapi.rst:28
msgid ""
"Let's provide a minimal example through which we add the endpoint ``/new-"
"endpoint`` supporting two HTTP methods:"
msgstr ""

#: ../docs/source/developer_guide/core/extend_restapi.rst:31
msgid ""
"*GET*: retrieves the latest created Dict object and returns its ``id``, "
"``ctime`` in ISO 8601 format, and ``attributes``."
msgstr ""

#: ../docs/source/developer_guide/core/extend_restapi.rst:33
msgid ""
"*POST*: creates a ``Dict`` object with placeholder attributes, stores it, "
"and returns its ``id``."
msgstr ""

#: ../docs/source/developer_guide/core/extend_restapi.rst:36
msgid "Let's assume you've put the code in the file ``example.py``, reading:"
msgstr ""

#: ../docs/source/developer_guide/core/extend_restapi.rst:131
msgid ""
"Let us dissect the previous code explaining each part. First things first: "
"the imports."
msgstr ""

#: ../docs/source/developer_guide/core/extend_restapi.rst:139
msgid ""
"To start with, we import the base classes to be extended/employed: "
"``AiidaApi`` and ``App``. For simplicity, it is advisable to import the "
"method ``run_api``, as it provides an interface to configure the Api, parse "
"command-line arguments, and couple the two classes representing the Api and "
"the App. However, you can refer to the documentation of `flask_restful "
"<https://flask-restful.readthedocs.io/>`_ to configure and hook-up an Api "
"through its built-in methods."
msgstr ""

#: ../docs/source/developer_guide/core/extend_restapi.rst:146
msgid "Then we define a class representing the additional resource:"
msgstr ""

#: ../docs/source/developer_guide/core/extend_restapi.rst:186
msgid ""
"The class ``NewResource`` contains two methods: ``get`` and ``post``. The "
"names chosen for these functions are not arbitrary but fixed by ``Flask`` to"
" individuate the functions that respond to HTTP request of type GET and "
"POST, respectively. In other words, when the API receives a GET (POST) "
"request to the URL ``new-endpoint``, the function ``NewResource.get()`` "
"(``NewResource.post()``) will be executed. The HTTP response is constructed "
"around the data returned by these functions. The data, which are packed as "
"dictionaries, are serialized by Flask as a JSON stream of data. All the "
"Python built-in types can be serialized by Flask (e.g. ``int``, ``float``, "
"``str``, etc.), whereas for serialization of custom types we let you refer "
"to the `Flask documentation <http://flask.pocoo.org/docs/>`_ . The "
"documentation of Flask is the main source of information also for topics "
"such as customization of HTTP responses, construction of custom URLs (e.g. "
"accepting parameters), and more advanced serialization issues."
msgstr ""

#: ../docs/source/developer_guide/core/extend_restapi.rst:202
msgid ""
"Whenever you face the need to handle errors, consider to use the AiiDA REST "
"API-specific exceptions already defined in  "
":py:class:`aiida.restapi.common.exceptions`. The reason will become clear "
"slightly later in this section."
msgstr ""

#: ../docs/source/developer_guide/core/extend_restapi.rst:206
msgid ""
"Once the new resource is defined, we have to register it to the API by "
"assigning it one (or more) endpoint(s). This is done in the ``__init__()`` "
"of ``NewApi`` by means of the method ``add_resource()``:"
msgstr ""

#: ../docs/source/developer_guide/core/extend_restapi.rst:223
msgid ""
"In our original intentions, the main (if not the only) purpose of overriding"
" the ``__init__()`` method is to register new resources to the API. In fact,"
" the general form of ``__init__()`` is meant to be:"
msgstr ""

#: ../docs/source/developer_guide/core/extend_restapi.rst:241
msgid ""
"In the example, indeed, the only characteristic line is "
":python:`self.add_resource(NewResource, '/new-endpoint/', "
"strict_slashes=False)`. Anyway, the method ``add_resource()`` is defined and"
" documented in `Flask <http://flask.pocoo.org/docs/>`_."
msgstr ""

#: ../docs/source/developer_guide/core/extend_restapi.rst:245
msgid "Finally, the ``main`` code configures and runs the API:"
msgstr ""

#: ../docs/source/developer_guide/core/extend_restapi.rst:285
msgid ""
"The `click package <https://click.palletsprojects.com/en/7.x/>`_ is used to "
"provide a a nice command line interface to process the options and handle "
"the default values to pass to the ``newendpoint`` function."
msgstr ""

#: ../docs/source/developer_guide/core/extend_restapi.rst:289
msgid ""
"The method ``run_api()`` accomplishes several functions: it couples the API "
"to an instance of ``flask.Flask``, namely, the Flask fundamental class "
"representing a web app. Consequently, the app is configured and, if "
"required, hooked up. The spirit of ``run_api`` is to take all the "
"ingredients to setup an API and use them to build up a command-line utility "
"that serves to hook it up."
msgstr ""

#: ../docs/source/developer_guide/core/extend_restapi.rst:295
msgid "It requires as inputs:"
msgstr ""

#: ../docs/source/developer_guide/core/extend_restapi.rst:297
msgid ""
"the classes representing the Api and the App. We strongly suggest to pass to"
" ``run_api()`` the :py:class:`aiida.restapi.api.App` class, inheriting from "
"``flask.Flask``, as it handles correctly AiiDA RESTApi-specific exceptions."
msgstr ""

#: ../docs/source/developer_guide/core/extend_restapi.rst:301
msgid ""
"positional arguments representing the command-line arguments/options, passed"
" by the click function. Types, defaults and help strings can be set in the "
"``@click.option`` definitions, and will be handled by the command line call."
msgstr ""

#: ../docs/source/developer_guide/core/extend_restapi.rst:306
msgid "You should know few more things before using the script:"
msgstr ""

#: ../docs/source/developer_guide/core/extend_restapi.rst:308
msgid ""
"If you want to customize further the error handling, you can take "
"inspiration by looking at the definition of ``App`` and create your derived "
"class ``NewApp(App)``."
msgstr ""

#: ../docs/source/developer_guide/core/extend_restapi.rst:311
msgid ""
"The option ``hookup`` of the configuration dictionary must be set to "
"``True`` to use the script  to start the API from command line. Below, we "
"will show when it is appropriate to set ``hookup=False``."
msgstr ""

#: ../docs/source/developer_guide/core/extend_restapi.rst:315
msgid ""
"the supported command line options are identical to those of ``verdi "
"restapi``. Use ``verdi restapi --help`` for their full documentation. If you"
" want to add more options or modify the existing ones, create you custom "
"runner taking inspiration from ``run_api``."
msgstr ""

#: ../docs/source/developer_guide/core/extend_restapi.rst:320
msgid "It is time to run ``example.py``. Type in a terminal"
msgstr ""

#: ../docs/source/developer_guide/core/extend_restapi.rst:327
msgid "You should read the message"
msgstr ""

#: ../docs/source/developer_guide/core/extend_restapi.rst:333
msgid ""
"To route a request to the API from a terminal you can employ ``curl``. "
"Alternatively, you can use any REST client providing a GUI. Let us first ask"
" for the latest created node through the GET method:"
msgstr ""

#: ../docs/source/developer_guide/core/extend_restapi.rst:341
msgid "The form of the output (and only the form) should resemble"
msgstr ""

#: ../docs/source/developer_guide/core/extend_restapi.rst:354
msgid ""
"whereas the actual values of the response dictionary as well as the internal"
" structure of the attributes field will be in general very different."
msgstr ""

#: ../docs/source/developer_guide/core/extend_restapi.rst:357
msgid ""
"Now, let us create a node through the POST method, and check it again "
"through GET:"
msgstr ""

#: ../docs/source/developer_guide/core/extend_restapi.rst:373
msgid ""
"The POST request triggers the creation of a new ``Dict`` node, as confirmed "
"by the response to the GET request."
msgstr ""

#: ../docs/source/developer_guide/core/extend_restapi.rst:376
msgid ""
"As a final remark, there might be circumstances in which you do not want to "
"hook up the API from command line. For example, you might want to expose the"
" API through Apache for production, rather than the built-in Flask server. "
"In this case, you can invoke ``run_api`` to return two custom objects "
"``app`` and ``api``:"
msgstr ""

#: ../docs/source/developer_guide/core/extend_restapi.rst:385
msgid ""
"Additionally, set ``hookup=False`` and create an additional click option for"
" the variable ``catch_internal_server`` to be ``False``. This snippet of "
"code becomes the fundamental block of a *wsgi* file used by Apache as "
"documented in  :ref:`restapi_apache`. Moreover, we recommend to consult the "
"documentation of `mod_wsgi <https://modwsgi.readthedocs.io/>`_."
msgstr ""

#: ../docs/source/developer_guide/core/extend_restapi.rst:392
msgid ""
"The hookup value is set to ``False``, as the app is no longer required to be"
" hooked up, i.e. Apache will do the job for us. The second option, instead, "
"is not mandatory but potentially useful; it lets the exceptions thrown "
"during the execution of the apps propagate all the way through until they "
"reach the logger of Apache. Especially when the app is not entirely stable "
"yet, one would like to read the full python error traceback in the Apache "
"error log."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:3
msgid "AiiDA internals"
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:6
msgid "Node"
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:8
msgid ""
"All nodes in an AiiDA provenance graph inherit from the "
":py:class:`~aiida.orm.nodes.node.Node` class. Among those are the "
":py:class:`~aiida.orm.nodes.data.data.Data` class, the "
":py:class:`~aiida.orm.nodes.process.process.ProcessNode` class representing "
"computations that transform data, and the "
":py:class:`~aiida.orm.nodes.data.code.Code` class representing executables "
"(and file collections that are used by calculations)."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:13
msgid "Immutability concept"
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:14
msgid ""
"A node can store information in attributes. Since AiiDA guarantees a certain"
" level of provenance, these attributes become immutable as soon as the node "
"is stored. This means that as soon as a node is stored, any attempt to alter"
" its attributes, changing its value or deleting it altogether, shall be met "
"with a raised exception. Certain subclasses of nodes need to adapt this "
"behavior however, as for example in the case of the "
":py:class:`~aiida.orm.nodes.process.process.ProcessNode` class (see "
"`calculation updatable attributes`_), but since the immutability of stored "
"nodes is a core concept of AiiDA, this behavior is nonetheless enforced on "
"the node level. This guarantees that any subclasses of the Node class will "
"respect this behavior unless it is explicitly overriden."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:21
msgid "Node methods"
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:22
msgid ""
":py:meth:`~aiida.orm.utils.node.clean_value` takes a value and returns an "
"object which can be serialized for storage in the database. Such an object "
"must be able to be subsequently deserialized without changing value. If a "
"simple datatype is passed (integer, float, etc.), a check is performed to "
"see if it has a value of ``nan`` or ``inf``, as these cannot be stored. "
"Otherwise, if a list, tuple, dictionary, etc., is  passed, this check is "
"performed for each value it contains. This is done recursively, "
"automatically handling the case of nested objects. It is important to note "
"that iterable type objects are converted to lists during this process, and "
"mappings are converted to normal dictionaries. For efficiency reasons, the "
"cleaning of attribute values is delayed to the last moment possible. This "
"means that for an unstored node, new attributes are not cleaned but simply "
"set in the cache of the underlying database model. When the node is then "
"stored, all attributes are cleaned in one fell swoop and if successful the "
"values are flushed to the database. Once a node is stored, there no longer "
"is such a cache and so the attribute values are cleaned straight away for "
"each call. The same mechanism holds for the cleaning of the values of "
"extras."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:36
msgid "Node methods & properties"
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:37
msgid ""
"In the following sections, the most important methods and properties of the "
":py:class:`~aiida.orm.nodes.node.Node` class will be described."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:40
msgid "Node subclasses organization"
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:41
msgid ""
"The :py:class:`~aiida.orm.nodes.node.Node` class has two important "
"attributes:"
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:43
msgid ""
":py:attr:`~aiida.orm.nodes.node.Node._plugin_type_string` characterizes the "
"class of the object."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:45
msgid ""
":py:attr:`~aiida.orm.nodes.node.Node._query_type_string` characterizes the "
"class and all its subclasses (by pointing to the package or Python file that"
" contain the class)."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:47
msgid ""
"The convention for all the :py:class:`~aiida.orm.nodes.node.Node` subclasses"
" is that if a ``class B`` is inherited by a ``class A`` then there should be"
" a package ``A`` under ``aiida/orm`` that has a file ``__init__.py`` and a "
"``B.py`` in that directory (or a ``B`` package with the corresponding "
"``__init__.py``)"
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:49
msgid ""
"An example of this is the :py:class:`~aiida.orm.nodes.data.array.ArrayData` "
"and the :py:class:`~aiida.orm.nodes.data.array.kpoints.KpointsData`. "
":py:class:`~aiida.orm.nodes.data.array.ArrayData` is placed in "
"``aiida/orm/data/array/__init__.py`` and "
":py:class:`~aiida.orm.nodes.data.array.kpoints.KpointsData` which inherits "
"from :py:class:`~aiida.orm.nodes.data.array.ArrayData` is placed in "
"``aiida/orm/data/array/kpoints.py``"
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:52
msgid ""
"This is an implicit & quick way to check the inheritance of the "
":py:class:`~aiida.orm.nodes.node.Node` subclasses."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:55
msgid "General purpose methods"
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:56
msgid ""
":py:meth:`~aiida.orm.nodes.node.Node.__init__`: Will construct a new "
"unstored ``Node``. Note that this cannot be used to load an existing node "
"from the database."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:59
msgid ""
":py:meth:`~aiida.orm.nodes.node.Node.ctime` and "
":py:meth:`~aiida.orm.nodes.node.Node.mtime` provide the creation and the "
"modification time of the node."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:61
msgid ""
":py:meth:`~aiida.orm.nodes.node.Node.computer` returns the computer "
"associated to this node."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:63
msgid ""
":py:meth:`~aiida.orm.nodes.node.Node._validate` does a validation check for "
"the node. This is important for :py:class:`~aiida.orm.nodes.node.Node` "
"subclasses where various attributes should be checked for consistency before"
" storing."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:66
msgid ""
":py:meth:`~aiida.orm.nodes.node.Node.user` returns the user that created the"
" node."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:68
msgid ""
":py:meth:`~aiida.orm.nodes.node.Node.uuid` returns the universally unique "
"identifier (UUID) of the node."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:72
msgid "Annotation methods"
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:73
msgid ""
"The :py:class:`~aiida.orm.nodes.node.Node` can be annotated with labels, "
"description and comments. The following methods can be used for the "
"management of these properties."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:76
msgid "*Label management:*"
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:78
msgid ""
":py:attr:`~aiida.orm.nodes.node.Node.label` returns the label of the node. "
"It can also be used to *change* the label, e.g. ``mynode.label = \"new "
"label\"``."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:81
msgid "*Description management:*"
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:83
msgid ""
":py:attr:`~aiida.orm.nodes.node.Node.description`: returns the description "
"of the node (more detailed than the label). It can also be used to *change* "
"the description, e.g. ``mynode.description = \"new description\"``."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:86
msgid "*Comment management:*"
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:88
msgid ":py:meth:`~aiida.orm.nodes.node.Node.add_comment` adds a comment."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:90
msgid ""
":py:meth:`~aiida.orm.nodes.node.Node.get_comments` returns a sorted list of "
"the comments."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:92
msgid ""
":py:meth:`~aiida.orm.nodes.node.Node.update_comment` updates the node "
"comment. It can also be accessed through the CLI: ``verdi comment update``."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:95
msgid ""
":py:meth:`~aiida.orm.nodes.node.Node.remove_comment` removes the node "
"comment. It can also be accessed through the CLI: ``verdi comment remove``."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:101
msgid "Link management methods"
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:102
msgid ""
":py:class:`~aiida.orm.nodes.node.Node` objects and objects of its subclasses"
" can have ancestors and descendants. These are connected with links. The "
"following methods exist for the management of these links."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:106
msgid ""
":py:meth:`~aiida.orm.nodes.node.Node.has_cached_links` shows if there are "
"cached links to other nodes."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:108
msgid ""
":py:meth:`~aiida.orm.nodes.node.Node.add_incoming` adds a link to the "
"current node from the 'src' node with the given link label and link type. "
"Depending on whether the nodes are stored or not, the link is written to the"
" database or to the cache."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:111
msgid ""
":py:meth:`~aiida.orm.nodes.node.Node.get_incoming` returns the iterator of "
"input nodes"
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:113
msgid "*Methods to get the output data*"
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:115
msgid ""
":py:meth:`~aiida.orm.nodes.node.Node.get_outgoing` returns the iterator of "
"output nodes."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:117
msgid "*Listing links example*"
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:119
msgid ""
"Assume that the user wants to see the available links of a node in order to "
"understand the structure of the graph and maybe traverse it. In the "
"following example, we load a specific node and we list its incoming and "
"outgoing links::"
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:150
msgid ""
"The :py:meth:`~aiida.orm.nodes.node.Node.get_incoming` and "
":py:meth:`~aiida.orm.nodes.node.Node.get_outgoing` methods return a manager "
"object that contains a collection of the incoming and outgoing links from "
"the target node. The collection consists of all the neighboring nodes "
"matched in the query. Each neighbor is defined by the node, the link label "
"and link type. This set of three properties is referred to as a `link "
"triple` and is implemented by the "
":py:class:`~aiida.orm.utils.links.LinkTriple` named tuple. Through various "
"methods on the link manager, these link triples can be returned."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:158
msgid "Attributes related methods"
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:159
msgid ""
"Each :py:meth:`~aiida.orm.nodes.node.Node` object can have attributes which "
"are properties that characterize the node. Such properties can be the "
"energy, the atom symbols or the lattice vectors. The following methods can "
"be used for the management of the attributes."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:163
msgid ""
":py:meth:`~aiida.orm.nodes.node.Node.set_attribute` and "
":py:meth:`~aiida.orm.nodes.node.Node.set_attribute_many` adds one or many "
"new attributes to the node. The key of the attribute is the property name "
"(e.g. ``energy``, ``lattice_vectors`` etc) and the value of the attribute is"
" the value of that property."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:166
msgid ""
":py:meth:`~aiida.orm.nodes.node.Node.reset_attributes` will replace all "
"existing attributes with a new set of attributes."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:168
msgid ""
":py:meth:`~aiida.orm.nodes.node.Node.attributes` is a property that returns "
"all attributes."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:170
msgid ""
":py:meth:`~aiida.orm.nodes.node.Node.get_attribute` and "
":py:meth:`~aiida.orm.nodes.node.Node.get_attribute_many` can be used to "
"return a single or many specific attributes."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:172
msgid ""
":py:meth:`~aiida.orm.nodes.node.Node.delete_attribute` & "
":py:meth:`~aiida.orm.nodes.node.Node.delete_attribute_many` delete one or "
"multiple specific attributes."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:174
msgid ""
":py:meth:`~aiida.orm.nodes.node.Node.clear_attributes` will delete all "
"existing attributes."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:178
msgid "Extras related methods"
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:179
msgid ""
"`Extras` are additional information that can be added to a node. In contrast"
" to repository files and attributes, extras are information added by the "
"user and are not immutable, even when the node is stored."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:182
msgid ""
":py:meth:`~aiida.orm.nodes.node.Node.set_extra` and "
":py:meth:`~aiida.orm.nodes.node.Node.set_extra_many` adds one or many new "
"extras to the node. The key of the extra is the property name (e.g. "
"``energy``, ``lattice_vectors`` etc) and the value of the extra is the value"
" of that property."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:185
msgid ""
":py:meth:`~aiida.orm.nodes.node.Node.reset_extras` will replace all existing"
" extras with a new set of extras."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:187
msgid ""
":py:meth:`~aiida.orm.nodes.node.Node.extras` is a property that returns all "
"extras."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:189
msgid ""
":py:meth:`~aiida.orm.nodes.node.Node.get_extra` and "
":py:meth:`~aiida.orm.nodes.node.Node.get_extra_many` can be used to return a"
" single or many specific extras."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:191
msgid ""
":py:meth:`~aiida.orm.nodes.node.Node.delete_extra` & "
":py:meth:`~aiida.orm.nodes.node.Node.delete_extra_many` delete one or "
"multiple specific extras."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:193
msgid ""
":py:meth:`~aiida.orm.nodes.node.Node.clear_extras` will delete all existing "
"extras."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:197
msgid "Folder management"
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:198
msgid ""
"``Folder`` objects represent directories on the disk (virtual or not) where "
"extra information for the node are stored. These folders can be temporary or"
" permanent."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:203
msgid "Store & deletion"
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:204
msgid ""
":py:meth:`~aiida.orm.nodes.node.Node.store_all` stores all the input "
"``nodes``, then it stores the current ``node`` and in the end, it stores the"
" cached input links."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:206
msgid ""
":py:meth:`~aiida.orm.nodes.node.Node.verify_are_parents_stored` checks that "
"the parents are stored."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:208
msgid ""
":py:meth:`~aiida.orm.nodes.node.Node.store` method checks that the ``node`` "
"data is valid, then check if ``node``'s parents are stored, then moves the "
"contents of the temporary folder to the repository folder and in the end, it"
" stores in the database the information that are in the cache. The latter "
"happens with a database transaction. In case this transaction fails, then "
"the data transfered to the repository folder are moved back to the temporary"
" folder."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:213
msgid "Folders"
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:214
msgid ""
"AiiDA uses :py:class:`~aiida.common.folders.Folder` and its subclasses to "
"add an abstraction layer between the functions and methods working directly "
"on the file-system and AiiDA. This is particularly useful when we want to "
"easily change between different folder options (temporary, permanent etc) "
"and storage options (plain local directories, compressed files, remote files"
" & directories etc)."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:218
msgid ":py:class:`~aiida.common.folders.Folder`"
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:219
msgid ""
"This is the main class of the available ``Folder`` classes. Apart from the "
"abstraction provided to the OS operations needed by AiiDA, one of its main "
"features is that it can restrict all the available operations within a given"
" folder limit. The available methods are:"
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:223
msgid ""
":py:meth:`~aiida.common.folders.Folder.mode_dir` and "
":py:meth:`~aiida.common.folders.Folder.mode_file` return the mode with which"
" folders and files should be writable."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:225
msgid ""
":py:meth:`~aiida.common.folders.Folder.get_subfolder` returns the subfolder "
"matching the given name"
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:227
msgid ""
":py:meth:`~aiida.common.folders.Folder.get_content_list` returns the "
"contents matching a pattern."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:229
msgid ""
":py:meth:`~aiida.common.folders.Folder.insert_path` adds a file/folder to a "
"specific location and :py:meth:`~aiida.common.folders.Folder.remove_path` "
"removes a file/folder"
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:231
msgid ""
":py:meth:`~aiida.common.folders.Folder.get_abs_path` returns the absolute "
"path of a file/folder under a given folder and "
":py:meth:`~aiida.common.folders.Folder.abspath` returns the absolute path of"
" the folder."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:233
msgid ""
":py:meth:`~aiida.common.folders.Folder.create_symlink` creates a symlink "
"pointing the given location inside the ``folder``."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:235
msgid ""
":py:meth:`~aiida.common.folders.Folder.create_file_from_filelike` creates a "
"file from the given contents."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:237
msgid ""
":py:meth:`~aiida.common.folders.Folder.open` opens a file in the ``folder``."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:239
msgid ""
":py:meth:`~aiida.common.folders.Folder.folder_limit` returns the limit under"
" which the creation of files/folders is restrained."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:241
msgid ""
":py:meth:`~aiida.common.folders.Folder.exists` returns true or false "
"depending whether a folder exists or not."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:243
msgid ""
":py:meth:`~aiida.common.folders.Folder.isfile` and "
"py:meth:`~aiida.common.folders.Folder.isdir` return true or false depending "
"on the existence of the given file/folder."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:245
msgid ""
":py:meth:`~aiida.common.folders.Folder.create` creates the ``folder``, "
":py:meth:`~aiida.common.folders.Folder.erase` deletes the ``folder`` and "
":py:meth:`~aiida.common.folders.Folder.replace_with_folder` copies/moves a "
"given folder."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:248
msgid ":py:class:`~aiida.common.folders.RepositoryFolder`"
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:249
msgid ""
"Objects of this class correspond to the repository folders. The "
":py:class:`~aiida.common.folders.RepositoryFolder` specific methods are:"
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:252
msgid ""
":py:meth:`~aiida.common.folders.RepositoryFolder.__init__` initializes the "
"object with the necessary folder names and limits."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:254
msgid ""
":py:meth:`~aiida.common.folders.RepositoryFolder.get_topdir` returns the top"
" directory."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:256
msgid ""
":py:meth:`~aiida.common.folders.RepositoryFolder.section` returns the "
"section to which the ``folder`` belongs. This can be for the moment only  "
"``node``."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:258
msgid ""
":py:meth:`~aiida.common.folders.RepositoryFolder.subfolder` returns the "
"subfolder within the section/uuid folder."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:260
msgid ""
":py:meth:`~aiida.common.folders.RepositoryFolder.uuid` the UUID of the "
"corresponding ``node``."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:264
msgid ":py:class:`~aiida.common.folders.SandboxFolder`"
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:265
msgid ""
":py:class:`~aiida.common.folders.SandboxFolder` objects correspond to "
"temporary (\"sandbox\") folders. The main methods are:"
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:268
msgid ""
":py:meth:`~aiida.common.folders.SandboxFolder.__init__` creates a new "
"temporary folder"
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:270
msgid ""
":py:meth:`~aiida.common.folders.SandboxFolder.__exit__` destroys the folder "
"on exit."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:274
msgid "Data"
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:277
#: ../docs/source/developer_guide/core/internals.rst:285
#: ../docs/source/developer_guide/core/internals.rst:292
#: ../docs/source/developer_guide/core/internals.rst:368
msgid "Navigating inputs and outputs"
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:278
msgid ""
":py:meth:`~aiida.orm.nodes.data.Data.creator` returns either the "
":py:class:`~aiida.orm.nodes.process.calculation.CalculationNode` that "
"created it or ``None`` if it was not created by a calculation."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:282
msgid "ProcessNode"
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:286
msgid ""
":py:meth:`~aiida.orm.nodes.process.ProcessNode.caller` returns either the "
"caller :py:class:`~aiida.orm.nodes.process.workflow.WorkflowNode` or "
"``None`` if it was not called by any process."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:289
msgid "CalculationNode"
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:293
msgid ""
":py:meth:`~aiida.orm.nodes.process.calculation.CalculationNode.inputs` "
"returns a :py:meth:`~aiida.orm.utils.managers.NodeLinksManager` object that "
"can be used to access the node's incoming ``INPUT_CALC`` links."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:295
msgid ""
"The ``NodeLinksManager`` can be used to quickly go from a node to a "
"neighboring node. For example::"
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:348
msgid ""
"The ``.inputs`` manager for ``WorkflowNode`` and the ``.outputs`` manager "
"both for ``CalculationNode`` and ``WorkflowNode`` work in the same way (see "
"below)."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:350
msgid ""
":py:meth:`~aiida.orm.nodes.process.calculation.CalculationNode.outputs` "
"returns a :py:meth:`~aiida.orm.utils.managers.NodeLinksManager` object that "
"can be used to access the node's outgoing ``CREATE`` links."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:356
msgid "Updatable attributes"
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:357
msgid ""
"The :py:class:`~aiida.orm.nodes.process.ProcessNode` class is a subclass of "
"the :py:class:`~aiida.orm.nodes.node.Node` class, which means that its "
"attributes become immutable once stored. However, for a ``Calculation`` to "
"be runnable it needs to be stored, but that would mean that its state, which"
" is stored in an attribute can no longer be updated. To solve this issue the"
" :py:class:`~aiida.orm.utils.mixins.Sealable` mixin is introduced. This "
"mixin can be used for subclasses of ``Node`` that need to have updatable "
"attributes even after the node has been stored in the database. The mixin "
"defines the ``_updatable_attributes`` tuple, which defines the attributes "
"that are considered to be mutable even when the node is stored. It also "
"allows the node to be *sealed*, after which even the updatable attributes "
"become immutable."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:365
msgid "WorkflowNode"
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:369
msgid ""
":py:meth:`~aiida.orm.nodes.process.workflow.WorkflowNode.inputs` returns a "
":py:meth:`~aiida.orm.utils.managers.NodeLinksManager` object that can be "
"used to access the node's incoming ``INPUT_WORK`` links."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:371
msgid ""
":py:meth:`~aiida.orm.nodes.process.workflow.WorkflowNode.outputs` returns a "
":py:meth:`~aiida.orm.utils.managers.NodeLinksManager` object that can be "
"used to access the node's outgoing ``RETURN`` links."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:375
msgid "Deprecated features, renaming, and adding new methods"
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:376
msgid ""
"In case a method is renamed or removed, this is the procedure to follow:"
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:378
msgid ""
"(If you want to rename) move the code to the new function name. Then, in the"
" docstring, add something like::"
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:384
msgid ""
"Don't remove directly the old function, but just change the code to use the "
"new function, and add in the docstring::"
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:390
msgid "Moreover, at the beginning of the function, add something like::"
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:400
msgid ""
"(of course replace the parts between ``< >`` symbols with the correct "
"strings)."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:402
msgid "The advantage of the method above is:"
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:404
msgid "pycharm will still show the method crossed out"
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:405
msgid ""
"Our ``AiidaDeprecationWarning`` does not inherit from "
"``DeprecationWarning``, so it will not be \"hidden\" by python"
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:406
msgid ""
"User can disable our warnings (and only those) by using AiiDA properties "
"with::"
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:411
msgid "Changing the config.json structure"
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:413
msgid ""
"In general, changes to ``config.json`` should be avoided if possible. "
"However, if there is a need to modify it, the following procedure should be "
"used to create a migration:"
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:416
msgid ""
"Determine whether the change will be backwards-compatible. This means that "
"an older version of AiiDA will still be able to run with the new "
"``config.json`` structure. It goes without saying that it's preferable to "
"change ``config.json`` in a backwards-compatible way."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:420
msgid ""
"In ``aiida/manage/configuration/migrations/migrations.py``, increase the "
"``CURRENT_CONFIG_VERSION`` by one. If the change is **not** backwards-"
"compatible, set ``OLDEST_COMPATIBLE_CONFIG_VERSION`` to the same value."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:423
msgid ""
"Write a function which transforms the old config dict into the new version. "
"It is possible that you need user input for the migration, in which case "
"this should also be handled in that function."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:426
msgid ""
"Add an entry in ``_MIGRATION_LOOKUP`` where the key is the version "
"**before** the migration, and the value is a ``ConfigMigration`` object. The"
" ``ConfigMigration`` is constructed from your migration function, and the "
"**hard-coded** values of ``CURRENT_CONFIG_VERSION`` and "
"``OLDEST_COMPATIBLE_CONFIG_VERSION``. If these values are not hard-coded, "
"the migration will break as soon as the values are changed again."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:430
msgid ""
"Add tests for the migration, in "
"``aiida/backends/tests/manage/configuration/migrations/test_migrations.py``."
" You can add two types of tests:"
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:433
msgid ""
"Tests that run the entire migration, using the ``check_and_migrate_config`` "
"function. Make sure to run it with ``store=False``, otherwise it will "
"overwrite your ``config.json`` file. For these tests, you will have to "
"update the reference files."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:436
msgid ""
"Tests that run a single step in the migration, using the "
"``ConfigMigration.apply`` method. This can be used if you need to test "
"different edge cases of the migration."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:439
msgid "There are examples for both types of tests."
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:442
msgid "Daemon and signal handling"
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:444
msgid ""
"While the AiiDA daemon is running, interrupt signals (``SIGINT`` and "
"``SIGTERM``) are captured so that the daemon can shut down gracefully. This "
"is implemented using Python's ``signal`` module, as shown in the following "
"dummy example:"
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:456
msgid ""
"You should be aware of this while developing code which runs in the daemon. "
"In particular, it's important when creating subprocesses. When a signal is "
"sent, the whole process group receives that signal. As a result, the "
"subprocess can be killed even though the Python main process captures the "
"signal. This can be avoided by creating a new process group for the "
"subprocess, meaning that it will not receive the signal. To do this, you "
"need to pass ``preexec_fn=os.setsid`` to the ``subprocess`` function:"
msgstr ""

#: ../docs/source/developer_guide/core/internals.rst:472
msgid ""
"When dropping python 2.7 support, ``preexec_fn=os.setsid`` should be "
"replaced by the thread safe ``start_new_session=True`` introduced in python "
"3.2."
msgstr ""

#: ../docs/source/developer_guide/core/modifying_the_schema.rst:2
msgid "Modifying the schema"
msgstr ""

#: ../docs/source/developer_guide/core/modifying_the_schema.rst:5
msgid "Django"
msgstr ""

#: ../docs/source/developer_guide/core/modifying_the_schema.rst:7
msgid ""
"The Django database schema can be found in "
":py:mod:`aiida.backends.djsite.db.models`. If you need to change the "
"database schema follow these steps:"
msgstr ""

#: ../docs/source/developer_guide/core/modifying_the_schema.rst:10
msgid ""
"Make all the necessary changes to :py:mod:`aiida.backends.djsite.db.models`"
msgstr ""

#: ../docs/source/developer_guide/core/modifying_the_schema.rst:11
msgid "Create a new migration file by running::"
msgstr ""

#: ../docs/source/developer_guide/core/modifying_the_schema.rst:15
msgid ""
"This will create the migration file in "
"``aiida/backends/djsite/db/migrations`` whose name begins with a number "
"followed by some description. If the description is not appropriate then "
"change it to something better but retain the number."
msgstr ""

#: ../docs/source/developer_guide/core/modifying_the_schema.rst:18
msgid "Open the generated file and make the following changes::"
msgstr ""

#: ../docs/source/developer_guide/core/modifying_the_schema.rst:32
msgid ""
"The migration file now contains some migrations steps that were generated "
"automatically. Please make sure that they are correct. Also, if you want to "
"add some changes that affect the content of the database -- you should do it"
" \"manually\" by adding some sql commands that will run directly on your "
"database::"
msgstr ""

#: ../docs/source/developer_guide/core/modifying_the_schema.rst:56
msgid ""
"As you can see here, you should not only provide the sql commands to upgrade"
" your database, but also the commands to revert these changes in case you "
"want to perform a downgrade (see: ``sql=forward_sql``, "
"``reverse_sql=reverse_sql``)"
msgstr ""

#: ../docs/source/developer_guide/core/modifying_the_schema.rst:58
msgid ""
"Change the ``LATEST_MIGRATION`` variable in "
"``aiida/backends/djsite/db/migrations/__init__.py`` to the name of your "
"migration file::"
msgstr ""

#: ../docs/source/developer_guide/core/modifying_the_schema.rst:62
msgid ""
"This allows AiiDA to get the version number from your migration and make "
"sure the database and the code are in sync."
msgstr ""

#: ../docs/source/developer_guide/core/modifying_the_schema.rst:64
#: ../docs/source/developer_guide/core/modifying_the_schema.rst:164
msgid ""
"Migrate your database to the new version using ``verdi`` and specifying the "
"correct profile::"
msgstr ""

#: ../docs/source/developer_guide/core/modifying_the_schema.rst:68
msgid ""
"In case you want to (and, most probably, you should) test the downgrade "
"operation, please check the list of available versions of the database::"
msgstr ""

#: ../docs/source/developer_guide/core/modifying_the_schema.rst:73
msgid "The output will look something like the following::"
msgstr ""

#: ../docs/source/developer_guide/core/modifying_the_schema.rst:95
msgid "Choose the previous migration step and migrate to it::"
msgstr ""

#: ../docs/source/developer_guide/core/modifying_the_schema.rst:99
msgid ""
"Check that both: upgrade and downgrade changes are succesfull and if yes, go"
" to the next step."
msgstr ""

#: ../docs/source/developer_guide/core/modifying_the_schema.rst:101
msgid ""
"Add tests for your migrations to the ``aiida-"
"core/aiida/backends/djsite/db/subtests/migrations`` module."
msgstr ""

#: ../docs/source/developer_guide/core/modifying_the_schema.rst:105
msgid ""
"Such a test can only be applied to the migration of the database content. "
"For example, you can **not** test modifications of the database column "
"names."
msgstr ""

#: ../docs/source/developer_guide/core/modifying_the_schema.rst:111
msgid "SQLAlchemy"
msgstr ""

#: ../docs/source/developer_guide/core/modifying_the_schema.rst:113
msgid ""
"The SQLAlchemy database schema can be found in "
":py:mod:`aiida.backends.sqlalchemy.models`. If you need to change the "
"database schema follow these steps:"
msgstr ""

#: ../docs/source/developer_guide/core/modifying_the_schema.rst:116
msgid ""
"Make all the necessary changes to the model than you would like to modify "
"located in the ``aiida/backends/sqlalchemy/models`` directory."
msgstr ""

#: ../docs/source/developer_guide/core/modifying_the_schema.rst:118
msgid ""
"Create new migration file by going to ``aiida/backends/sqlalchemy`` and "
"executing::"
msgstr ""

#: ../docs/source/developer_guide/core/modifying_the_schema.rst:122
msgid ""
"This will create a new migration file in "
"``aiida/backends/sqlalchemy/migrations/versions`` whose names begins with an"
" automatically generated hash and the provided message for this new "
"migration. Modify the migration message to accurately describe the purpose "
"of the migration."
msgstr ""

#: ../docs/source/developer_guide/core/modifying_the_schema.rst:125
msgid ""
"Have a look at the generated migration file and ensure that migration is "
"correct. The file should contain automatically generated hashes that point "
"to the previous and to the current revision::"
msgstr ""

#: ../docs/source/developer_guide/core/modifying_the_schema.rst:131
msgid ""
"Also ``upgrade()`` and ``downgrade()`` function definitions should be "
"present in the file::"
msgstr ""

#: ../docs/source/developer_guide/core/modifying_the_schema.rst:138
msgid ""
"If you want to add some changes that affect the content of the database -- "
"you should do it \"manually\" by adding some sql commands that will run "
"directly on your database. Learn the following example and adapt it for your"
" needs::"
msgstr ""

#: ../docs/source/developer_guide/core/modifying_the_schema.rst:162
msgid ""
"If you want to learn more about the migration operations, you can have a "
"look at the Alembic documentation."
msgstr ""

#: ../docs/source/developer_guide/core/modifying_the_schema.rst:168
msgid ""
"Add tests for your migrations to ``aiida-"
"core/aiida/backends/sqlalchemy/tests/test_migrations.py``"
msgstr ""

#: ../docs/source/developer_guide/core/modifying_the_schema.rst:172
msgid "Overview of ``manage.py`` commands"
msgstr ""

#: ../docs/source/developer_guide/core/modifying_the_schema.rst:173
msgid ""
"The alembic_manage.py provides several options to control your SQLAlchemy "
"migrations. By executing::"
msgstr ""

#: ../docs/source/developer_guide/core/modifying_the_schema.rst:178
msgid ""
"you will get a full list of the available arguments that you can pass and "
"commands. Briefly, the available commands are:"
msgstr ""

#: ../docs/source/developer_guide/core/modifying_the_schema.rst:181
msgid "**upgrade** This command allows you to upgrade to the later version."
msgstr ""

#: ../docs/source/developer_guide/core/modifying_the_schema.rst:182
msgid ""
"**downgrade** This command allows you to downgrade the version of your "
"database."
msgstr ""

#: ../docs/source/developer_guide/core/modifying_the_schema.rst:183
msgid ""
"**history** This command lists the available migrations in chronological "
"order."
msgstr ""

#: ../docs/source/developer_guide/core/modifying_the_schema.rst:184
msgid "**current** This command displays the current version of the database."
msgstr ""

#: ../docs/source/developer_guide/core/modifying_the_schema.rst:185
msgid ""
"**revision** This command creates a new migration file based on the model "
"changes."
msgstr ""

#: ../docs/source/developer_guide/core/modifying_the_schema.rst:190
msgid "Debugging Alembic"
msgstr ""

#: ../docs/source/developer_guide/core/modifying_the_schema.rst:191
msgid ""
"Alembic migrations should work automatically and migrate your database to "
"the latest version. However, if you were using SQLAlchemy before we "
"introduced Alembic, you may get a message like to following during the first"
" migration::"
msgstr ""

#: ../docs/source/developer_guide/core/modifying_the_schema.rst:203
msgid ""
"In this case, you should create manually the Alembic table in your database "
"and add a line with the database version number. To do so, use psql to "
"connect to the desired database::"
msgstr ""

#: ../docs/source/developer_guide/core/modifying_the_schema.rst:208
msgid ""
"where you should replace ``aiidadb_sqla`` with the name of the database that"
" you would like to modify. Then, execute the following commands::"
msgstr ""

#: ../docs/source/developer_guide/core/plugin_system.rst:2
msgid "Developing the plugin system"
msgstr ""

#: ../docs/source/developer_guide/core/plugin_system.rst:4
msgid ""
"this page is intended for people wanting to contribute to the plugin system "
"in ``aiida-core`` and is not needed for people who just want to contribute a"
" plugin."
msgstr ""

#: ../docs/source/developer_guide/core/plugin_system.rst:7
msgid "Design Principles"
msgstr ""

#: ../docs/source/developer_guide/core/plugin_system.rst:9
msgid "Only restrict plugin developers when really necessary;"
msgstr ""

#: ../docs/source/developer_guide/core/plugin_system.rst:11
msgid "Avoid schema changes whenever reasonably possible;"
msgstr ""

#: ../docs/source/developer_guide/core/plugin_system.rst:13
msgid ""
"Finding and loading plugins must be as fast as the plugin allows, especially"
" for command line interface (CLI) commands. In other words, directly "
"importing a plugin class should not be noticeably faster than using the "
"plugin loader/factory;"
msgstr ""

#: ../docs/source/developer_guide/core/plugin_system.rst:15
msgid ""
"Implement as a drop-in replacement, provide backwards compatibility at "
"first, think about changing interfaces if/when the old system is dropped;"
msgstr ""

#: ../docs/source/developer_guide/core/plugin_system.rst:17
msgid ""
"Plugin management should be as user friendly from ipython as from the CLI."
msgstr ""

#: ../docs/source/developer_guide/core/plugin_system.rst:20
msgid "Mini-Spec"
msgstr ""

#: ../docs/source/developer_guide/core/plugin_system.rst:23
msgid "Terms"
msgstr ""

#: ../docs/source/developer_guide/core/plugin_system.rst:29
msgid "``plugin_name``"
msgstr ""

#: ../docs/source/developer_guide/core/plugin_system.rst:25
msgid "A unique name identifying the plugin. Suggested naming scheme is"
msgstr ""

#: ../docs/source/developer_guide/core/plugin_system.rst:27
msgid "pypi distribution / repo name: aiida-<plugin_name>"
msgstr ""

#: ../docs/source/developer_guide/core/plugin_system.rst:28
msgid "import name: aiida_<plugin_name>"
msgstr ""

#: ../docs/source/developer_guide/core/plugin_system.rst:29
msgid "entry point names: <plugin_name>.name"
msgstr ""

#: ../docs/source/developer_guide/core/plugin_system.rst:36
msgid "``name`` (entry point)"
msgstr ""

#: ../docs/source/developer_guide/core/plugin_system.rst:32
msgid "The entry point for a plugin class looks as follows::"
msgstr ""

#: ../docs/source/developer_guide/core/plugin_system.rst:36
msgid ""
"Therefore within a plugin category the name allows us to find a specific "
"plugin (as well as a typestring) The name is recommended to contain the "
"plugin name (as detailed under ``plugin_name``."
msgstr ""

#: ../docs/source/developer_guide/core/plugin_system.rst:56
msgid "``category``"
msgstr ""

#: ../docs/source/developer_guide/core/plugin_system.rst:39
msgid "A name given to each area extensible via plugins, one of"
msgstr ""

#: ../docs/source/developer_guide/core/plugin_system.rst:41
#: ../docs/source/developer_guide/plugins/basics.rst:61
msgid "calculations"
msgstr ""

#: ../docs/source/developer_guide/core/plugin_system.rst:42
msgid "cmdline.computer.configure"
msgstr ""

#: ../docs/source/developer_guide/core/plugin_system.rst:43
msgid "cmdline.data"
msgstr ""

#: ../docs/source/developer_guide/core/plugin_system.rst:44
msgid "data"
msgstr ""

#: ../docs/source/developer_guide/core/plugin_system.rst:45
#: ../docs/source/developer_guide/plugins/basics.rst:62
msgid "parsers"
msgstr ""

#: ../docs/source/developer_guide/core/plugin_system.rst:46
#: ../docs/source/developer_guide/plugins/basics.rst:64
msgid "schedulers"
msgstr ""

#: ../docs/source/developer_guide/core/plugin_system.rst:47
#: ../docs/source/developer_guide/plugins/basics.rst:65
msgid "transports"
msgstr ""

#: ../docs/source/developer_guide/core/plugin_system.rst:48
msgid "tools.calculations"
msgstr ""

#: ../docs/source/developer_guide/core/plugin_system.rst:49
msgid "tools.data.orbitals"
msgstr ""

#: ../docs/source/developer_guide/core/plugin_system.rst:50
msgid "tools.dbexporters"
msgstr ""

#: ../docs/source/developer_guide/core/plugin_system.rst:51
msgid "tools.dbimporters"
msgstr ""

#: ../docs/source/developer_guide/core/plugin_system.rst:52
msgid "workflows"
msgstr ""

#: ../docs/source/developer_guide/core/plugin_system.rst:54
msgid "Each category maps to an entry point group called::"
msgstr ""

#: ../docs/source/developer_guide/core/plugin_system.rst:59
msgid "Interfaces"
msgstr ""

#: ../docs/source/developer_guide/core/plugin_system.rst:62
msgid "Pluginloader"
msgstr ""

#: ../docs/source/developer_guide/core/plugin_system.rst:63
msgid ""
"The plugin loading functionality is defined in "
":py:mod:`aiida.plugins.entry_point` and relies on the `reentry PyPI package "
"<https://github.com/dropd/reentry>`_ to find and load entry points. The "
"``reentry`` package is part of the build requirements of ``aiida-core`` as "
"defined in the ``pyproject.toml`` file. This enables the scanning for "
"existing plugins when AiiDA is installed. If for some reason ``reentry`` is "
"uninstalled or is not found, the plugin system will fall back on "
"``pkg_resources`` from setuptools, which is slower."
msgstr ""

#: ../docs/source/developer_guide/core/plugin_system.rst:69
msgid "Registry Tools"
msgstr ""

#: ../docs/source/developer_guide/core/plugin_system.rst:70
msgid "See the API documentation in :py:mod:`aiida.plugins`."
msgstr ""

#: ../docs/source/developer_guide/core/transport.rst:2
msgid "Transport plugins"
msgstr ""

#: ../docs/source/developer_guide/core/transport.rst:7
msgid ""
"The term `transport` in AiiDA refers to a class that the engine uses to "
"perform operations on local or remote machines where its "
":py:class:`~aiida.engine.processes.calcjobs.calcjob.CalcJob` are submitted. "
"The base class :py:class:`~aiida.transports.transport.Transport` defines an "
"interface for these operations, such as copying files and executing "
"commands. A `transport plugin` is a class that implements this base class "
"for a specific connection method. The ``aiida-core`` package ships with two "
"transport plugins: the "
":py:class:`~aiida.transports.plugins.local.LocalTransport` and "
":py:class:`~aiida.transports.plugins.ssh.SshTransport` classes. The "
"``local`` transport can be used to connect with the `localhost` and makes "
"use only of some standard python modules like ``os`` and ``shutil``. The "
"``ssh`` transport, which can be used for machines that can be connected to "
"over ssh, is simply a wrapper around the library `paramiko "
"<https://www.paramiko.org/>`_ that is installed as a required dependency of "
"``aiida-core``."
msgstr ""

#: ../docs/source/developer_guide/core/transport.rst:16
msgid "Developing a plugin"
msgstr ""

#: ../docs/source/developer_guide/core/transport.rst:18
msgid ""
"The transport class is actually almost never used directly by the user. It "
"is mostly utilized by the engine that uses the transport plugin to connect "
"to the machine where the calculation job, that it is managing, is running. "
"The engine has to be able to use always the same methods regardless of which"
" kind of transport is required to connect to the computer in question."
msgstr ""

#: ../docs/source/developer_guide/core/transport.rst:22
msgid ""
"The generic transport class contains a set of minimal methods that an "
"implementation must support in order to be fully compatible with the other "
"plugins. If not, a ``NotImplementedError`` will be raised, interrupting the "
"managing of the calculation or whatever is using the transport plugin."
msgstr ""

#: ../docs/source/developer_guide/core/transport.rst:25
msgid ""
"As for the general functioning of the plugin, the "
":py:meth:`~aiida.transports.transport.Transport.__init__` method is used "
"only to initialize the class instance, without actually opening the "
"transport channel. The connection must be opened only by the "
":py:meth:`~aiida.transports.transport.Transport.__enter__` method, (and "
"closed by :py:meth:`~aiida.transports.transport.Transport.__exit__`). The "
":py:meth:`~aiida.transports.transport.Transport.__enter__` method lets you "
"use the transport class using the ``with`` statement (see `python docs "
"<https://docs.python.org/3/reference/compound_stmts.html#with>`_), in a way "
"similar to the following::"
msgstr ""

#: ../docs/source/developer_guide/core/transport.rst:32
msgid ""
"To ensure this, for example, the local plugin uses a hidden boolean variable"
" ``_is_open`` that is set when the "
":py:meth:`~aiida.transports.transport.Transport.__enter__` and "
":py:meth:`~aiida.transports.transport.Transport.__exit__` methods are "
"called. The ``ssh`` logic is instead given by the property sftp."
msgstr ""

#: ../docs/source/developer_guide/core/transport.rst:35
msgid ""
"The other functions that require some care are the copying functions, called"
" using the following terminology:"
msgstr ""

#: ../docs/source/developer_guide/core/transport.rst:37
msgid "``put``: from local source to remote destination"
msgstr ""

#: ../docs/source/developer_guide/core/transport.rst:38
msgid "``get``: from remote source to local destination"
msgstr ""

#: ../docs/source/developer_guide/core/transport.rst:39
msgid "``copy``: copying files from remote source to remote destination"
msgstr ""

#: ../docs/source/developer_guide/core/transport.rst:41
msgid ""
"Note that these functions must accept both files and folders and internally "
"they will fallback to functions like ``putfile`` or ``puttree``."
msgstr ""

#: ../docs/source/developer_guide/core/transport.rst:43
msgid ""
"The last function requiring care is "
":py:meth:`~aiida.transports.transport.Transport.exec_command_wait`, which is"
" an analogue to the `subprocess "
"<http://docs.python.org/3/library/subprocess.html>`_ python module. The "
"function gives the freedom to execute a string as a remote command, thus it "
"could produce nasty effects if not written with care."
msgstr ""

#: ../docs/source/developer_guide/core/transport.rst:48
msgid "Be sure to escape any strings for bash!"
msgstr ""

#: ../docs/source/developer_guide/core/transport.rst:50
msgid ""
"Download :download:`this template <transport_template.py>` as a starting "
"point to implementing a new transport plugin. It contains the interface with"
" all the methods that need to be implemented, including docstrings that will"
" work with Sphinx documentation."
msgstr ""

#: ../docs/source/developer_guide/design/changes.rst:2
msgid "Design evolution"
msgstr ""

#: ../docs/source/developer_guide/design/changes.rst:4
msgid ""
"This document records the evolution of the design and architecture of AiiDA,"
" including the underlying reasoning."
msgstr ""

#: ../docs/source/developer_guide/design/changes.rst:7
msgid "Version 1.0.0"
msgstr ""

#: ../docs/source/developer_guide/design/changes.rst:13
msgid "The provenance redesign"
msgstr ""

#: ../docs/source/developer_guide/design/changes.rst:15
msgid ""
"In the early stages of AiiDA, the concept of its provenance graph was "
"simple. Data is used as input for calculations, that in turn create new data"
" as output. The data and calculations, produced and ran by AiiDA, were "
"stored as nodes in a graph. Due to the causality principle, the resulting "
"graph was naturally acyclic, as no piece of data could possibly also have "
"been an input to its own creation. The directed acyclic graph that stored "
"the data provenance in AiiDA was well defined and all was good."
msgstr ""

#: ../docs/source/developer_guide/design/changes.rst:21
msgid ""
"However, as AiiDA matured, its use cases became more complex and soon there "
"was a need to be able to define and run workflows. Workflows allow the user "
"to define a sequence of calculations, that ultimately produce a result. In "
"order to be able to retrieve the final result directly from the workflow, it"
" needed to be able to return the data created by the calculations that it "
"ran. \"Easy peasy: we simply add a ``return`` link from the workflow node in"
" the graph to the created data node\". But what seemed like an easy solution"
" brought a host of unforeseen problems with it. By introducing the concept "
"of a ``return`` link, the acyclicity of the graph was broken, and with it, "
"much of AiiDA's graph traversal API that assumed this property."
msgstr ""

#: ../docs/source/developer_guide/design/changes.rst:28
msgid ""
"After more than a year of discussion, AiiDA developers and users concluded "
"that the concept of the ``return`` link was absolutely crucial. Without it, "
"the results of complicated and heavily nested workflows will be buried deep "
"within their call stack and difficult to retrieve. The alternative was to "
"redesign the provenance graph architecture such that acyclicity would be "
"returned to part of the provenance graph, while keeping the utility of the "
"``return`` link. The AiiDA development team, in close collaboration with "
"advanced users, spent a year and a half, redesigning the provenance "
"architecture and implementing the changes into AiiDA's API. As always, we "
"have tried our best to allow early adopters of AiiDA to migrate their "
"existing databases to newer versions as easy as possible, by providing "
"automatic migration. This time around is no different, except for the fact "
"that the migration was a lot more complicated and unfortunately this time "
"some backwards-incompatible changes had to be introduced in the API."
msgstr ""

#: ../docs/source/developer_guide/design/changes.rst:35
msgid ""
"A more detailed explanation of the new provenance design and the motivation "
"can be found :ref:`here <concepts_provenance>`."
msgstr ""

#: ../docs/source/developer_guide/design/changes.rst:41
msgid "The calculation job redesign"
msgstr ""

#: ../docs/source/developer_guide/design/changes.rst:43
msgid ""
"The calculation job has been one of the most used and important components "
"of AiiDA as it represents a calculation that is submitted to a scheduler, "
"often on a remote cluster. From its earliest conception, the class that "
"implemented this feature, the ``JobCalculation``, fulfilled two major but "
"very distinct tasks. On one side, it provided the means to the user to "
"specify what inputs the calculation required, how the actual input files "
"should be constructed, and what files should be retrieved after completion. "
"In addition to that, since it was a sub class of the ``Node`` class, it also"
" functioned as a record in the provenance graph of an actual calculation "
"that was executed. This double role was leading to problems with the "
"``Node`` class becoming too complicated as well as inconsistent. For "
"example, an instance representing an already completed calculation would "
"also still have the methods on how to run it again."
msgstr ""

#: ../docs/source/developer_guide/design/changes.rst:50
msgid ""
"This problem was solved with the introduction of the ``WorkChain`` in "
"``aiida-core`` version ``0.7.0``. Like the ``JobCalculation``, the "
"``WorkChain`` was a process that takes certain inputs and then performs "
"operations on those in order to produce outputs. However, unlike the "
"``JobCalculation``, the ``WorkChain`` class was only concerned with "
"knowledge of *how* the process should be run. To represent the execution of "
"the ``WorkChain`` in the provenance graph, a different class was used, "
"namely the ``WorkChainNode``. This separation of responsibilities leads to "
"two entities with a clearer interface and behavior."
msgstr ""

#: ../docs/source/developer_guide/design/changes.rst:56
msgid ""
"For quite a few versions, the old and new way of defining and running "
"processes were kept functional alongside one another, but slowly the old way"
" was adapted to use the new mechanism. In ``aiida-core`` version ``1.0.0`` "
"we fully deprecate the old way and all calculations now use the process/node"
" duality. As a result the ``JobCalculation`` class has disappeared. Now, "
"instead, a ``CalcJobNode`` is created in the provenance graph to represent "
"the execution of a calculation through a scheduler. Moreover, to implement "
"the plugin for a calculation job, one now subclasses the ``Process`` "
"subclass ``CalcJob``, whose interface is the same as that of the "
"``WorkChain``."
msgstr ""

#: ../docs/source/developer_guide/design/changes.rst:62
msgid ""
"Inputs, outputs and potentially exit codes are simply implemented in the "
"``define`` class method, just as you would for the ``WorkChain``. Unlike the"
" ``WorkChain``, however, the ``CalcJob`` does not have an outline, but "
"instead just has a single method that should be implemented, namely "
"``prepare_for_submission``. This method takes a single argument ``folder`` "
"which will point to a temporary folder to which the required input files for"
" the calculation can be written. From a plugin developer standpoint, the "
"rest works exactly as before, and the ``prepare_for_submission`` method "
"should return a ``CalcInfo`` object, containing information for the engine "
"on what files to copy over and to retrieve."
msgstr ""

#: ../docs/source/developer_guide/design/changes.rst:67
msgid ""
"A more detailed explanation about the new ``CalcJob`` and best practices for"
" writing ``Parser`` implementations can be found :ref:`here "
"<working_calcjobs>`."
msgstr ""

#: ../docs/source/developer_guide/design/changes.rst:73
msgid "The module hierarchy and importing"
msgstr ""

#: ../docs/source/developer_guide/design/changes.rst:75
msgid ""
"AiiDA has been developed and used since 2013 and in the past six years we "
"have tried, as much as possible, to reduce the changes to the python API "
"over time to a minimum. At the same time, a lot of new functionality has "
"been added to the code, with a potentially complex submodule structure for "
"the AiiDA python package, that had started to become too complex even just "
"to remember where to find a given function or class."
msgstr ""

#: ../docs/source/developer_guide/design/changes.rst:78
msgid ""
"With ``aiida-core`` version ``1.0.0``, we have decided to restructure the "
"package module hierarchy, moving functions and classes to more intuitive "
"locations, and exposing functionality that is commonly used by users at "
"higher levels (e.g. now one can do ``from aiida.orm import CalcJobNode`` in "
"addition to ``from aiida.orm.nodes.process.calculation.calcjob import "
"CalcJobNode``)."
msgstr ""

#: ../docs/source/developer_guide/design/changes.rst:80
msgid ""
"Albeit this change was essential to increase usability, we want to guarantee"
" a high-degree of stability for users for the components that are intended "
"to be public. To facilitiate this, we explain here first the module "
"hierarchy of ``aiida-core``, what parts of its API are intended to be public"
" and how those should be preferentially imported."
msgstr ""

#: ../docs/source/developer_guide/design/changes.rst:83
msgid ""
"The first level of the package hierarchy is the ``aiida`` module. It "
"contains many other packages within it, such as ``orm`` and ``engine``, "
"which we will refer to as second-level packages, each of which can have a "
"much deeper hierarchy within it. Since this internal structure is mostly to "
"simplify development and for organizational purposes, the components of the "
"``aiida`` package that should be usable are exposed on the second-level "
"packages at most. Practically this means that anything that is intended to "
"be used should be importable from a second-level package, for example::"
msgstr ""

#: ../docs/source/developer_guide/design/changes.rst:91
msgid ""
"With the definition of public components of the ``aiida-core`` package in "
"place, from ``1.0.0`` we will maintain a standard deprecation policy to "
"minimize the amount of breaking changes for plugins and users. In particular"
" we will strive to:"
msgstr ""

#: ../docs/source/developer_guide/design/changes.rst:94
msgid "not change the API of public components as much as possible"
msgstr ""

#: ../docs/source/developer_guide/design/changes.rst:95
msgid ""
"if we are forced to change it anyway, deprecate a signifcant amount of time "
"in advance"
msgstr ""

#: ../docs/source/developer_guide/design/changes.rst:96
msgid "for backwards incompatible changes, increase the major version"
msgstr ""

#: ../docs/source/developer_guide/design/changes.rst:98
msgid ""
"For better clarity, we are :ref:`curating a list of classes and "
"functions<python_api_public_list>` (exposed at the second level) that are "
"intended to be public and for which the above policy will be enforced"
msgstr ""

#: ../docs/source/developer_guide/plugins.rst:3
msgid "Plugin development"
msgstr ""

#: ../docs/source/developer_guide/plugins/basics.rst:4
msgid "Basics"
msgstr ""

#: ../docs/source/developer_guide/plugins/basics.rst:8
msgid "What a plugin Is"
msgstr ""

#: ../docs/source/developer_guide/plugins/basics.rst:10
msgid ""
"An AiiDA plugin is a `python package <packages>`_ that provides a set of "
"extensions to AiiDA."
msgstr ""

#: ../docs/source/developer_guide/plugins/basics.rst:12
msgid ""
"AiiDA plugins can use :ref:`entry points <plugins.entry_points>` in order to"
" make the ``aiida-core`` package aware of the extensions."
msgstr ""

#: ../docs/source/developer_guide/plugins/basics.rst:16
msgid ""
"In the python community, the term 'package' is used rather loosely. "
"Depending on context, it can refer to a collection of python modules or it "
"may, in addition, include the files necessary for building and installing "
"the package."
msgstr ""

#: ../docs/source/developer_guide/plugins/basics.rst:23
msgid "Goals"
msgstr ""

#: ../docs/source/developer_guide/plugins/basics.rst:25
msgid "The plugin system was designed with the following goals in mind."
msgstr ""

#: ../docs/source/developer_guide/plugins/basics.rst:27
msgid ""
"**Sharing of workflows and extensions**: a workflow or extension is written "
"as a python package, distributed as a zip source archive, python ``egg`` or "
"PyPI package. There is extensive documentation available for how to "
"distribute python packages `here <https://packaging.python.org/>`_."
msgstr ""

#: ../docs/source/developer_guide/plugins/basics.rst:29
msgid ""
"**Ease of use**: plugins can be found in an online curated list of plugins "
"and installed with one simple command. This process is familiar to every "
"regular python user."
msgstr ""

#: ../docs/source/developer_guide/plugins/basics.rst:31
msgid ""
"**Decouple development and update cycles of AiiDA and plugins**: since "
"plugins are separate python packages, they can be developed in a separate "
"code repository and updated when the developer sees fit without a need to "
"update AiiDA. Similarly, if AiiDA is updated, plugins may not need to "
"release a new version."
msgstr ""

#: ../docs/source/developer_guide/plugins/basics.rst:33
msgid ""
"**Promote modular design in AiiDA development**: separating plugins into "
"their own python packages ensures that plugins can not (easily) access parts"
" of the AiiDA code which are not part of the public API, enabling AiiDA "
"development to stay agile. The same applies to plugins relying on other "
"plugins."
msgstr ""

#: ../docs/source/developer_guide/plugins/basics.rst:35
msgid ""
"**Low overhead for developers**: plugin developers can write their "
"extensions the same way they would write any python code meant for "
"distribution."
msgstr ""

#: ../docs/source/developer_guide/plugins/basics.rst:37
msgid ""
"**Automatic AiiDA setup and testing of plugins**: installation of complete "
"python environments consisting of many packages can be automated, provided "
"all packages use ``setuptools`` as a distribution tool. This enables use of "
"AiiDA in a service-based way using, e.g., docker images. At the same it "
"becomes possible to create automated tests for any combination of plugins, "
"as long as the plugins provide test entry points."
msgstr ""

#: ../docs/source/developer_guide/plugins/basics.rst:43
msgid ""
"**Start simple.**: make use of existing classes like "
":py:class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode`, "
":py:class:`~aiida.orm.nodes.data.dict.Dict`, "
":py:class:`~aiida.orm.nodes.data.singlefile.SinglefileData`, ... Write only "
"what is necessary to pass information from and to AiiDA."
msgstr ""

#: ../docs/source/developer_guide/plugins/basics.rst:45
msgid ""
"**Don't break data provenance.**: store *at least* what is needed for full "
"reproducibility."
msgstr ""

#: ../docs/source/developer_guide/plugins/basics.rst:47
msgid ""
"**Parse what you want to query for.**: make a list of which information to:"
msgstr ""

#: ../docs/source/developer_guide/plugins/basics.rst:49
msgid ""
"parse into the database for querying "
"(:py:class:`~aiida.orm.nodes.data.dict.Dict`, ...)"
msgstr ""

#: ../docs/source/developer_guide/plugins/basics.rst:50
msgid ""
"store in files for safe-keeping "
"(:py:class:`~aiida.orm.nodes.data.singlefile.SinglefileData`, ...)"
msgstr ""

#: ../docs/source/developer_guide/plugins/basics.rst:51
msgid ""
"leave on the remote computer "
"(:py:class:`~aiida.orm.nodes.data.remote.RemoteData`, ...)"
msgstr ""

#: ../docs/source/developer_guide/plugins/basics.rst:53
msgid ""
"**Expose the full functionality.**: standardization is good but don't "
"artificially limit the power of a code you are wrapping - or your users will"
" get frustrated. If the code can do it, there should be *some* way to do it "
"with your plugin."
msgstr ""

#: ../docs/source/developer_guide/plugins/basics.rst:57
msgid "What a plugin can do"
msgstr ""

#: ../docs/source/developer_guide/plugins/basics.rst:59
msgid "Add new classes to AiiDA's unified interface, including:"
msgstr ""

#: ../docs/source/developer_guide/plugins/basics.rst:63
msgid "data types"
msgstr ""

#: ../docs/source/developer_guide/plugins/basics.rst:66
msgid "db importers"
msgstr ""

#: ../docs/source/developer_guide/plugins/basics.rst:67
msgid "db exporters"
msgstr ""

#: ../docs/source/developer_guide/plugins/basics.rst:68
msgid "subcommands to some ``verdi`` commands"
msgstr ""

#: ../docs/source/developer_guide/plugins/basics.rst:69
msgid "tests to be run using ``verdi devel tests``"
msgstr ""

#: ../docs/source/developer_guide/plugins/basics.rst:71
msgid ""
"This typically involves subclassing the respective base class AiiDA provides"
" for that purpose."
msgstr ""

#: ../docs/source/developer_guide/plugins/basics.rst:72
msgid "Install separate commandline and/or GUI executables"
msgstr ""

#: ../docs/source/developer_guide/plugins/basics.rst:73
msgid ""
"Depend on any number of other plugins (the required versions must not clash "
"with AiiDA's requirements)"
msgstr ""

#: ../docs/source/developer_guide/plugins/basics.rst:79
msgid "What a plugin should not do"
msgstr ""

#: ../docs/source/developer_guide/plugins/basics.rst:81
msgid "An AiiDA plugin should not:"
msgstr ""

#: ../docs/source/developer_guide/plugins/basics.rst:83
msgid "Change the database schema AiiDA uses"
msgstr ""

#: ../docs/source/developer_guide/plugins/basics.rst:84
msgid ""
"Use protected functions, methods or classes of AiiDA (those starting with an"
" underscore ``_``)"
msgstr ""

#: ../docs/source/developer_guide/plugins/basics.rst:85
msgid ""
"Monkey patch anything within the ``aiida`` namespace (or the namespace "
"itself)"
msgstr ""

#: ../docs/source/developer_guide/plugins/basics.rst:87
msgid ""
"Failure to comply will likely prevent your plugin from being listed on the "
"official `AiiDA plugin registry <registry>`_."
msgstr ""

#: ../docs/source/developer_guide/plugins/basics.rst:89
msgid ""
"If you find yourself tempted to do any of the above, please open an issue on"
" the `AiiDA repository <core>`_ and explain why. We will advise on how to "
"proceed."
msgstr ""

#: ../docs/source/developer_guide/plugins/basics.rst:98
msgid "Limitations"
msgstr ""

#: ../docs/source/developer_guide/plugins/basics.rst:100
msgid "The chosen approach to plugins has some limitations:"
msgstr ""

#: ../docs/source/developer_guide/plugins/basics.rst:102
msgid ""
"In the current version the interface for entry point objects is enforced "
"implicitly by the way the object is used. It is the responsibility of the "
"plugin developer to test for compliance, especially if the object is not "
"derived from the recommended base classes provided by AiiDA. This is to be "
"clearly communicated in the documentation for plugin developers;"
msgstr ""

#: ../docs/source/developer_guide/plugins/basics.rst:103
msgid ""
"The freedom of the plugin developer to name and rename classes ends where "
"the information in question is stored in the database as, e.g., node "
"attributes."
msgstr ""

#: ../docs/source/developer_guide/plugins/basics.rst:104
msgid ""
"The system is designed with the possibility of plugin versioning in mind, "
"however this is not implemented yet."
msgstr ""

#: ../docs/source/developer_guide/plugins/basics.rst:105
msgid ""
"In principle, two different plugins can give the same name to an entry "
"point, creating ambiguity when trying to load the associated objects. Plugin"
" development guidelines in the documentation will advise on how to avoid "
"this problem, and this is addressed via the use of a centralized registry of"
" known AiiDA plugins."
msgstr ""

#: ../docs/source/developer_guide/plugins/basics.rst:106
msgid ""
"Plugins can potentially contain malicious or otherwise dangerous code. In "
"the registry of AiiDA plugins, we try to flag plugins that we know are safe "
"to be used."
msgstr ""

#: ../docs/source/developer_guide/plugins/documenting.rst:3
msgid "Documenting a plugin"
msgstr ""

#: ../docs/source/developer_guide/plugins/documenting.rst:5
msgid ""
"If you used the `AiiDA plugin cutter`_,  your plugin already comes with a "
"basic documentation that just needs to be adjusted to your needs."
msgstr ""

#: ../docs/source/developer_guide/plugins/documenting.rst:8
msgid "Install the ``docs`` extra::"
msgstr ""

#: ../docs/source/developer_guide/plugins/documenting.rst:12
msgid "Populate, delete, or add to the individual documentation pages::"
msgstr ""

#: ../docs/source/developer_guide/plugins/documenting.rst:20
msgid "Use `Sphinx`_ to generate the html documentation::"
msgstr ""

#: ../docs/source/developer_guide/plugins/documenting.rst:25
msgid "Check the result by opening ``build/html/index.html`` in your browser."
msgstr ""

#: ../docs/source/developer_guide/plugins/documenting.rst:27
msgid ""
"Host your documentation online on ReadTheDocs_. Simply sign up and import "
"your project.  Make sure to add the path to the requirements file "
"``docs/requirements_for_rtd.txt`` and the Python configuration file "
"``docs/source/conf.py`` in Admin => Advanced settings."
msgstr ""

#: ../docs/source/developer_guide/plugins/documenting.rst:32
msgid ""
"Note: When updating the plugin to a new version, remember to update the "
"version number both in ``setup.json`` and ``aiida_mycode/__init__.py``."
msgstr ""

#: ../docs/source/developer_guide/plugins/documenting.rst:43
msgid "Sphinx extension"
msgstr ""

#: ../docs/source/developer_guide/plugins/documenting.rst:45
msgid ""
"AiiDA defines a Sphinx extension to simplify documenting some of its "
"features. To use this extension, you need to add  ``aiida.sphinxext`` to the"
" ``extensions`` list in your Sphinx ``conf.py`` file."
msgstr ""

#: ../docs/source/developer_guide/plugins/documenting.rst:48
msgid "WorkChain directive"
msgstr ""

#: ../docs/source/developer_guide/plugins/documenting.rst:50
msgid "The following directive can be used to auto-document AiiDA workchains:"
msgstr ""

#: ../docs/source/developer_guide/plugins/documenting.rst:58
msgid ""
"The argument ``MyWorkChain`` is the name of the workchain, and ``:module:`` "
"is the module from which it can be imported. By default, the inputs which "
"are not stored in the database are also shown. This can be disabled by "
"passing the ``:hide-unstored-inputs:`` flag."
msgstr ""

#: ../docs/source/developer_guide/plugins/documenting.rst:60
msgid ""
"The ``aiida-workchain`` directive is also hooked into "
"``sphinx.ext.autodoc``, so if you use the corresponding directives "
"(``automodule``, ``autoclass``), it will automatically use the ``aiida-"
"workchain`` command for ``WorkChain`` classes."
msgstr ""

#: ../docs/source/developer_guide/plugins/entry_points.rst:4
msgid "Entry Points"
msgstr ""

#: ../docs/source/developer_guide/plugins/entry_points.rst:8
msgid "What is an Entry Point?"
msgstr ""

#: ../docs/source/developer_guide/plugins/entry_points.rst:10
msgid ""
"The ``setuptools`` package to which ``pip`` is a frontend has a feature "
"called `entry points`_. When a distribution which registers entry points is "
"installed, the entry point specifications are written to a file inside the "
"distribution's ``.egg-info`` folder. ``setuptools`` provides a package "
"``pkg_resources`` which can find these entry points by distribution, group "
"and/or name and load the data structure to which it points."
msgstr ""

#: ../docs/source/developer_guide/plugins/entry_points.rst:18
msgid "This is the way AiiDA finds and loads classes provided by plugins."
msgstr ""

#: ../docs/source/developer_guide/plugins/entry_points.rst:23
msgid "AiiDA Entry Points"
msgstr ""

#: ../docs/source/developer_guide/plugins/entry_points.rst:27
msgid ""
"This document contains a list of entry point groups AiiDA uses, with an "
"example usage for each. In the following, we assume the following folder "
"structure::"
msgstr ""

#: ../docs/source/developer_guide/plugins/entry_points.rst:55
msgid ""
"For a plugin that uses this folder structure, see the  `aiida plugin "
"template`_."
msgstr ""

#: ../docs/source/developer_guide/plugins/entry_points.rst:57
msgid ""
"Note, however, that the folder structure inside ``aiida-mycode/`` is "
"entirely up to you. A very simple plugin might look like::"
msgstr ""

#: ../docs/source/developer_guide/plugins/entry_points.rst:68
msgid ""
"The plugin has to tell AiiDA where to look for the classes to be used as "
"calculations, parsers, transports, etc. This is done inside ``setup.json`` "
"by way of the ``entry_points`` keyword::"
msgstr ""

#: ../docs/source/developer_guide/plugins/entry_points.rst:80
msgid ""
"It is given as a dictionary containing entry point group names as keywords. "
"The list for each entry point group contains entry point specifications."
msgstr ""

#: ../docs/source/developer_guide/plugins/entry_points.rst:82
msgid ""
"A specification in turn is given as a string and consists of two parts, a "
"name and an import path describing where the class is to be imported from. "
"The two parts are sparated by an `=` sign::"
msgstr ""

#: ../docs/source/developer_guide/plugins/entry_points.rst:86
msgid ""
"We *strongly* suggest to start the name of each entry point with the name of"
" the plugin, ommitting the leading 'aiida-'. In our example this leads to "
"entry specifications like ``\"mycode.<any.you.want> = "
"<module.path:class>\"``, just like the above example. Exceptions to this "
"rule are schedulers, transports and potentially data ones. Further "
"exceptions can be tolerated in order to provide backwards compatibility if "
"the plugin was in use before aiida-0.9 and its modules were installed in "
"locations which does not make it possible to follow this rule."
msgstr ""

#: ../docs/source/developer_guide/plugins/entry_points.rst:91
msgid "Below, a list of valid entry points recognized by AiiDA follows."
msgstr ""

#: ../docs/source/developer_guide/plugins/entry_points.rst:94
msgid "``aiida.calculations``"
msgstr ""

#: ../docs/source/developer_guide/plugins/entry_points.rst:96
msgid ""
"Entry points in this group are expected to be subclasses of "
":py:class:`aiida.orm.JobCalculation "
"<aiida.orm.nodes.process.calculation.calcjob.CalcJobNode>`. This replaces "
"the previous method of placing a python module with the class in question "
"inside the ``aiida/orm/calculation/job`` subpackage."
msgstr ""

#: ../docs/source/developer_guide/plugins/entry_points.rst:98
msgid "Example entry point specification::"
msgstr ""

#: ../docs/source/developer_guide/plugins/entry_points.rst:106
msgid "``aiida_mycode/calcs/mycode.py``::"
msgstr ""

#: ../docs/source/developer_guide/plugins/entry_points.rst:112
msgid "Will lead to usage::"
msgstr ""

#: ../docs/source/developer_guide/plugins/entry_points.rst:118
msgid "``aiida.parsers``"
msgstr ""

#: ../docs/source/developer_guide/plugins/entry_points.rst:120
msgid ""
"Aiida expects a subclass of ``Parser``. Replaces the previous approach "
"consisting in placing a parser module under ``aiida/parsers/plugins``."
msgstr ""

#: ../docs/source/developer_guide/plugins/entry_points.rst:122
msgid "Example spec::"
msgstr ""

#: ../docs/source/developer_guide/plugins/entry_points.rst:130
msgid "``aida_mycode/parsers/myparser.py``::"
msgstr ""

#: ../docs/source/developer_guide/plugins/entry_points.rst:136
#: ../docs/source/developer_guide/plugins/entry_points.rst:160
#: ../docs/source/developer_guide/plugins/entry_points.rst:184
#: ../docs/source/developer_guide/plugins/entry_points.rst:299
msgid "Usage::"
msgstr ""

#: ../docs/source/developer_guide/plugins/entry_points.rst:142
msgid "``aiida.data``"
msgstr ""

#: ../docs/source/developer_guide/plugins/entry_points.rst:144
msgid ""
"Group for :py:class:`~aiida.orm.nodes.data.data.Data` subclasses. Previously"
" located in a subpackage of ``aiida/orm/data``."
msgstr ""

#: ../docs/source/developer_guide/plugins/entry_points.rst:146
#: ../docs/source/developer_guide/plugins/entry_points.rst:170
#: ../docs/source/developer_guide/plugins/entry_points.rst:202
#: ../docs/source/developer_guide/plugins/entry_points.rst:264
#: ../docs/source/developer_guide/plugins/entry_points.rst:285
msgid "Spec::"
msgstr ""

#: ../docs/source/developer_guide/plugins/entry_points.rst:154
msgid "``aiida_mycode/data/mydat.py``::"
msgstr ""

#: ../docs/source/developer_guide/plugins/entry_points.rst:166
msgid "``aiida.workflows``"
msgstr ""

#: ../docs/source/developer_guide/plugins/entry_points.rst:168
msgid ""
"For AiiDA workflows. Instead of putting a workflow somewhere under the "
"``aiida.workflows`` package, it can now be packaged as a plugin and exposed "
"to aiida as follows:"
msgstr ""

#: ../docs/source/developer_guide/plugins/entry_points.rst:178
msgid "``aiida_mycode/workflows/mywf.py``::"
msgstr ""

#: ../docs/source/developer_guide/plugins/entry_points.rst:189
msgid ""
"For old-style workflows the entry point mechanism of the plugin system is "
"not supported. Therefore one cannot load these workflows with the "
"``WorkflowFactory``. The only way to run these, is to store their source "
"code in the ``aiida/workflows/user`` directory and use normal python imports"
" to load the classes."
msgstr ""

#: ../docs/source/developer_guide/plugins/entry_points.rst:195
msgid "``aiida.cmdline``"
msgstr ""

#: ../docs/source/developer_guide/plugins/entry_points.rst:197
msgid ""
"For subcommands to verdi commands like ``verdi data mydata``. Plugin support"
" for commands is possible due to using `click`_. AiiDA expects each entry "
"point to be either a ``click.Command`` or ``click.CommandGroup``."
msgstr ""

#: ../docs/source/developer_guide/plugins/entry_points.rst:210
msgid "``aiida_mycode/commands/mydata.py``::"
msgstr ""

#: ../docs/source/developer_guide/plugins/entry_points.rst:224
msgid "Usage:"
msgstr ""

#: ../docs/source/developer_guide/plugins/entry_points.rst:231
msgid "``aiida.tools.dbexporters``"
msgstr ""

#: ../docs/source/developer_guide/plugins/entry_points.rst:233
msgid ""
"If your plugin adds support for exporting to an external database, use this "
"entry point to have aiida find the module where you define the necessary "
"functions."
msgstr ""

#: ../docs/source/developer_guide/plugins/entry_points.rst:245
msgid "``aiida.tools.dbimporters``"
msgstr ""

#: ../docs/source/developer_guide/plugins/entry_points.rst:247
msgid ""
"If your plugin adds support for importing from an external database, use "
"this entry point to have aiida find the module where you define the "
"necessary functions."
msgstr ""

#: ../docs/source/developer_guide/plugins/entry_points.rst:260
msgid "``aiida.schedulers``"
msgstr ""

#: ../docs/source/developer_guide/plugins/entry_points.rst:262
msgid ""
"For scheduler plugins. Note that the entry point name is not prefixed by the"
" plugin name. This is because typically a scheduler should be distributed in"
" a plugin on its own, and only one plugin per scheduler should be necessary."
msgstr ""

#: ../docs/source/developer_guide/plugins/entry_points.rst:272
msgid "``aiida_myscheduler/myscheduler.py``::"
msgstr ""

#: ../docs/source/developer_guide/plugins/entry_points.rst:278
msgid ""
"Usage: The scheduler is used in the familiar way by entering 'myscheduler' "
"as the scheduler option when setting up a computer."
msgstr ""

#: ../docs/source/developer_guide/plugins/entry_points.rst:281
msgid "``aiida.transports``"
msgstr ""

#: ../docs/source/developer_guide/plugins/entry_points.rst:283
msgid ""
"Like schedulers, transports are supposed to be distributed in a separate "
"plugin. Therefore we will again omit the plugin's name in the entry point "
"name."
msgstr ""

#: ../docs/source/developer_guide/plugins/entry_points.rst:293
msgid "``aiida_mytransport/mytransport.py``::"
msgstr ""

#: ../docs/source/developer_guide/plugins/entry_points.rst:304
msgid ""
"Jus like one would expect, when a computer is setup, ``mytransport`` can be "
"given as the transport option."
msgstr ""

#: ../docs/source/developer_guide/plugins/plugin_tests.rst:4
msgid "Testing AiiDA plugins"
msgstr ""

#: ../docs/source/developer_guide/plugins/plugin_tests.rst:6
msgid ""
"When developing a plugin it is important to write tests. We recommend using "
"the `pytest`_ framework, while the `unittest`_ framework is also supported."
msgstr ""

#: ../docs/source/developer_guide/plugins/plugin_tests.rst:9
msgid ""
"One concern when running tests for AiiDA plugins is to separate the test "
"environment from your production environment. Depending on the kind of test,"
" each should even be run against a fresh AiiDA database."
msgstr ""

#: ../docs/source/developer_guide/plugins/plugin_tests.rst:12
msgid "AiiDA ships with tools that take care of this for you. They will:"
msgstr ""

#: ../docs/source/developer_guide/plugins/plugin_tests.rst:14
msgid "start a temporary postgres server"
msgstr ""

#: ../docs/source/developer_guide/plugins/plugin_tests.rst:15
msgid "create a new database"
msgstr ""

#: ../docs/source/developer_guide/plugins/plugin_tests.rst:16
msgid "create a temporary ``.aiida`` folder"
msgstr ""

#: ../docs/source/developer_guide/plugins/plugin_tests.rst:17
msgid "create a test profile"
msgstr ""

#: ../docs/source/developer_guide/plugins/plugin_tests.rst:18
msgid "(optional) reset the AiiDA database before every individual test"
msgstr ""

#: ../docs/source/developer_guide/plugins/plugin_tests.rst:20
msgid ""
"thus letting you focus on testing the functionality of your plugin without "
"having to worry about this separation."
msgstr ""

#: ../docs/source/developer_guide/plugins/plugin_tests.rst:23
msgid ""
"The overhead for setting up the temporary environment is of the order of a "
"few seconds and occurs only once per test session. You can control the "
"database backend for the temporary profile by setting the "
"``AIIDA_TEST_BACKEND`` environment variable, e.g. ``export "
"AIIDA_TEST_BACKEND=sqlalchemy``."
msgstr ""

#: ../docs/source/developer_guide/plugins/plugin_tests.rst:27
msgid ""
"If you prefer to run tests on an existing profile, say ``test_profile``, "
"simply set the following environment variable before running your tests::"
msgstr ""

#: ../docs/source/developer_guide/plugins/plugin_tests.rst:33
msgid ""
"In order to prevent accidental data loss, AiiDA only allows to run tests on "
"profiles whose name starts with ``test_``."
msgstr ""

#: ../docs/source/developer_guide/plugins/plugin_tests.rst:42
msgid "Using the pytest framework"
msgstr ""

#: ../docs/source/developer_guide/plugins/plugin_tests.rst:44
msgid "We recommend the `pytest`_ framework for testing AiiDA plugins."
msgstr ""

#: ../docs/source/developer_guide/plugins/plugin_tests.rst:47
msgid "AiiDA's fixtures"
msgstr ""

#: ../docs/source/developer_guide/plugins/plugin_tests.rst:49
msgid ""
"Many tests require input data to be set up before the test starts, e.g. some"
" AiiDA data nodes. pytest has the concept of a `fixture`_, which can be a "
"predefined object that the test acts on or just some code you want to run "
"before the test starts."
msgstr ""

#: ../docs/source/developer_guide/plugins/plugin_tests.rst:52
msgid ""
"AiiDA ships with a number of fixtures in "
":py:mod:`aiida.manage.tests.pytest_fixtures` for you to use."
msgstr ""

#: ../docs/source/developer_guide/plugins/plugin_tests.rst:54
msgid "For example:"
msgstr ""

#: ../docs/source/developer_guide/plugins/plugin_tests.rst:56
msgid ""
"The :py:func:`~aiida.manage.tests.pytest_fixtures.aiida_profile` fixture "
"initializes the :py:class:`~aiida.manage.tests.TestManager` and yields it to"
" the test function. Its parameters ``scope='session', autouse=True`` cause "
"this fixture to automatically run once per test session, even if you don't "
"explicitly require it."
msgstr ""

#: ../docs/source/developer_guide/plugins/plugin_tests.rst:58
msgid ""
"The :py:func:`~aiida.manage.tests.pytest_fixtures.clear_database` fixture "
"depends on the :py:func:`~aiida.manage.tests.pytest_fixtures.aiida_profile` "
"fixture and tells the received :py:class:`~aiida.manage.tests.TestManager` "
"instance to reset the database. This fixture lets each test start in a fresh"
" AiiDA environment."
msgstr ""

#: ../docs/source/developer_guide/plugins/plugin_tests.rst:60
msgid ""
"The :py:func:`~aiida.manage.tests.pytest_fixtures.temp_dir` fixture returns "
"a temporary directory for file operations and deletes it after the test is "
"finished."
msgstr ""

#: ../docs/source/developer_guide/plugins/plugin_tests.rst:61
msgid ""
"... you may want to add your own fixtures tailored for your plugin to set up"
" specific ``Data`` nodes & more."
msgstr ""

#: ../docs/source/developer_guide/plugins/plugin_tests.rst:63
msgid ""
"In order to make these fixtures available to your tests, add them to your "
"``conftest.py`` file at the root level of your plugin as follows::"
msgstr ""

#: ../docs/source/developer_guide/plugins/plugin_tests.rst:74
msgid ""
"Your custom fixtures would typically also go inside the ``conftest.py``. For"
" more information on the ``conftest.py``, see `here <conftest>`_."
msgstr ""

#: ../docs/source/developer_guide/plugins/plugin_tests.rst:77
msgid ""
"You can now start writing tests e.g. in a ``test_calculations.py`` file::"
msgstr ""

#: ../docs/source/developer_guide/plugins/plugin_tests.rst:95
msgid "Feel free to check out the tests of the `aiida-diff`_ demo plugin."
msgstr ""

#: ../docs/source/developer_guide/plugins/plugin_tests.rst:102
msgid "Running tests"
msgstr ""

#: ../docs/source/developer_guide/plugins/plugin_tests.rst:104
msgid "Simply type::"
msgstr ""

#: ../docs/source/developer_guide/plugins/plugin_tests.rst:108
msgid "in the folder where your ``conftest.py`` resides."
msgstr ""

#: ../docs/source/developer_guide/plugins/plugin_tests.rst:110
msgid ""
"pytest will automatically discover files, classes and function names "
"starting with the word ``test``."
msgstr ""

#: ../docs/source/developer_guide/plugins/plugin_tests.rst:114
msgid "Using the unittest framework"
msgstr ""

#: ../docs/source/developer_guide/plugins/plugin_tests.rst:117
msgid ""
"The ``unittest`` package is included in the python standard library and is "
"widely used despite its limitations. It is also still used for testing "
"``aiida-core``."
msgstr ""

#: ../docs/source/developer_guide/plugins/plugin_tests.rst:120
msgid ""
"In analogy to the fixtures of ``pytest``, for ``unittest`` we provide a "
":py:class:`aiida.manage.tests.unittest_classes.PluginTestCase` class that "
"your test cases can inherit from."
msgstr ""

#: ../docs/source/developer_guide/plugins/plugin_tests.rst:122
msgid ""
"Due to limitations of ``unittest``, tests written using the "
":py:class:`~aiida.manage.tests.unittest_classes.PluginTestCase` need to be "
"run through a special "
":py:class:`~aiida.manage.tests.unittest_classes.TestRunner` (i.e. ``python "
"-m unittest discover`` will *not* work). To actually the tests, prepare a "
"script ``run_tests.py``::"
msgstr ""

#: ../docs/source/developer_guide/plugins/plugin_tests.rst:131
msgid "and then run the tests using::"
msgstr ""

#: ../docs/source/developer_guide/plugins/plugin_tests.rst:138
msgid "Migrating from ``AiidaTestCase`` to pytest"
msgstr ""

#: ../docs/source/developer_guide/plugins/plugin_tests.rst:140
msgid ""
"The slightly outdated testing framework of ``aiida-core`` defined an "
":py:class:`~aiida.backends.testbase.AiidaTestCase` class plus some "
"functionality around it."
msgstr ""

#: ../docs/source/developer_guide/plugins/plugin_tests.rst:142
msgid ""
"Below, we give an example of how to convert tests written for the "
":py:class:`~aiida.backends.testbase.AiidaTestCase` to work with ``pytest``. "
"In the process, we'll take advantage of the fact that the ``pytest`` "
"framework can also run test cases using the ``unittest`` classes, in order "
"to maintain the class-style layout."
msgstr ""

#: ../docs/source/developer_guide/plugins/plugin_tests.rst:145
msgid ""
"Below is a typical test class based on the "
":py:class:`~aiida.backends.testbase.AiidaTestCase`::"
msgstr ""

#: ../docs/source/developer_guide/plugins/plugin_tests.rst:179
msgid ""
"If you enable the AiiDA fixtures in your ``conftest.py`` as explained above,"
" they will also act on test functions defined in ``unittest`` test classes! "
"Thus, the conversion to ``pytest`` can look as follows:"
msgstr ""

#: ../docs/source/developer_guide/plugins/plugin_tests.rst:216
msgid ""
"For more details on running ``unittest`` cases through pytest, see the "
"`pytest documentation`_."
msgstr ""

#: ../docs/source/developer_guide/plugins/plugin_tests.rst:219
msgid ""
"This modification will break the compatibility with aiida-core's testing "
"framework and the ``verdi devel tests`` interface. If you were using this "
"interface, do not forget to remove the corresponding entry points from your "
"``setup.json``."
msgstr ""

#: ../docs/source/developer_guide/plugins/publish.rst:3
msgid "Publishing a plugin"
msgstr ""

#: ../docs/source/developer_guide/plugins/publish.rst:8
msgid "1. Choose a name"
msgstr ""

#: ../docs/source/developer_guide/plugins/publish.rst:10
msgid ""
"The naming convention for AiiDA plugins is ``aiida-mycode`` for the plugin "
"and ``aiida_mycode`` for the corresponding python package, leading to the "
"following folder structure::"
msgstr ""

#: ../docs/source/developer_guide/plugins/publish.rst:18
msgid ""
"This marks your plugin as an AiiDA package and makes it easy to find on "
"package indices like `PyPI`_."
msgstr ""

#: ../docs/source/developer_guide/plugins/publish.rst:20
msgid "**Note:** Python packages cannot contain dashes, thus the underscore."
msgstr ""

#: ../docs/source/developer_guide/plugins/publish.rst:24
msgid "2. Get Your Plugin Listed"
msgstr ""

#: ../docs/source/developer_guide/plugins/publish.rst:26
msgid ""
"AiiDA plugins should be listed on the AiiDA plugin `registry`_ to avoid "
"name-clashes with other plugins."
msgstr ""

#: ../docs/source/developer_guide/plugins/publish.rst:29
msgid ""
"If you wish to get your plugin listed on the official registry for AiiDA "
"plugins, you will provide the following keyword arguments as key-value pairs"
" in a ``setup.json`` or ``setup.yaml``. It is recommended to have setup.py "
"read the keyword arguments from that file::"
msgstr ""

#: ../docs/source/developer_guide/plugins/publish.rst:40
msgid "``name``"
msgstr ""

#: ../docs/source/developer_guide/plugins/publish.rst:41
msgid "``author``"
msgstr ""

#: ../docs/source/developer_guide/plugins/publish.rst:42
msgid "``author_email``"
msgstr ""

#: ../docs/source/developer_guide/plugins/publish.rst:43
msgid "``description``"
msgstr ""

#: ../docs/source/developer_guide/plugins/publish.rst:44
msgid "``url``"
msgstr ""

#: ../docs/source/developer_guide/plugins/publish.rst:45
msgid "``license``"
msgstr ""

#: ../docs/source/developer_guide/plugins/publish.rst:46
msgid "``classifiers`` (optional)"
msgstr ""

#: ../docs/source/developer_guide/plugins/publish.rst:47
msgid "``version``"
msgstr ""

#: ../docs/source/developer_guide/plugins/publish.rst:48
msgid "``install_requires``"
msgstr ""

#: ../docs/source/developer_guide/plugins/publish.rst:49
msgid "``entry_points``"
msgstr ""

#: ../docs/source/developer_guide/plugins/publish.rst:50
msgid "``scripts`` (optional)"
msgstr ""

#: ../docs/source/developer_guide/plugins/publish.rst:52
msgid ""
"Now, fork the plugin `registry`_ repository, fill in your plugin's "
"information in the same fashion as the plugins already registered, and "
"create a pull request. The registry will allow users to discover your plugin"
" using ``verdi plugin search`` (note: the latter verdi command is not yet "
"implemented in AiiDA)."
msgstr ""

#: ../docs/source/developer_guide/plugins/publish.rst:59
msgid "3. Get Your Plugin On PyPI"
msgstr ""

#: ../docs/source/developer_guide/plugins/publish.rst:61
msgid ""
"For packaging and distributing AiiDA plugins, we recommend to follow "
"existing `guidelines for packaging python <packaging>`_, which include "
"making the plugin available on the `python package index <PyPI>`_. This "
"makes it possible for users to simply ``pip install aiida-myplugin``."
msgstr ""

#: ../docs/source/developer_guide/plugins/publish.rst:66
msgid "Our suggested layout::"
msgstr ""

#: ../docs/source/developer_guide/plugins/publish.rst:77
msgid ""
"Note: In principle, ``aiida-compute`` could contain and install multiple "
"packages."
msgstr ""

#: ../docs/source/developer_guide/plugins/publish.rst:79
msgid ""
"Incidentally a distribution can contain and install more than one package at"
" a time."
msgstr ""

#: ../docs/source/developer_guide/plugins/publish.rst:81
msgid ""
"The most user-friendly way to distribute a package is to create such a "
"distribution and uploading it to `PyPI`_. Users then can simply install the "
"package(s) by running ``pip <distribution-name>``."
msgstr ""

#: ../docs/source/developer_guide/plugins/quickstart.rst:3
msgid "Quickstart"
msgstr ""

#: ../docs/source/developer_guide/plugins/quickstart.rst:5
msgid ""
"You have a code and would like to use it from AiiDA? You need a special data"
" type, parser, scheduler, ... that is not available? Then you'll need to "
"write an **AiiDA plugin**."
msgstr ""

#: ../docs/source/developer_guide/plugins/quickstart.rst:9
msgid "Let's get started with creating a new plugin ``aiida-mycode``."
msgstr ""

#: ../docs/source/developer_guide/plugins/quickstart.rst:11
msgid ""
"At least once, :ref:`install an existing aiida plugin <plugins>` to make "
"sure this works."
msgstr ""

#: ../docs/source/developer_guide/plugins/quickstart.rst:13
msgid ""
"Check on the `aiida plugin registry <https://aiidateam.github.io/aiida-"
"registry/>`_ that your desired plugin name is still available"
msgstr ""

#: ../docs/source/developer_guide/plugins/quickstart.rst:16
msgid ""
"Use the `AiiDA plugin cutter <https://github.com/aiidateam/aiida-plugin-"
"cutter>`_ to jumpstart your plugin::"
msgstr ""

#: ../docs/source/developer_guide/plugins/quickstart.rst:23
msgid "Install your new plugin::"
msgstr ""

#: ../docs/source/developer_guide/plugins/quickstart.rst:29
msgid ""
"That's it - now you can ``import aiida_mycode`` and start developing your "
"plugin"
msgstr ""

#: ../docs/source/developer_guide/plugins/quickstart.rst:34
msgid "A few things to keep in mind:"
msgstr ""

#: ../docs/source/developer_guide/plugins/quickstart.rst:32
msgid ""
"Be sure to update the `setup.json`_, in particular the license and version "
"number"
msgstr ""

#: ../docs/source/developer_guide/plugins/quickstart.rst:33
msgid ""
":ref:`Get your plugin listed <plugins.get_listed>` as soon as possible to "
"reserve your plugin name and to inform others of your ongoing development"
msgstr ""

#: ../docs/source/developer_guide/plugins/update_plugin.rst:2
msgid "Updating an Existing Plugin"
msgstr ""

#: ../docs/source/developer_guide/plugins/update_plugin.rst:4
msgid ""
"This document describes the process of updating an AiiDA plugin written "
"using the old plugin system (pre AiiDA version 0.8) to the current plugin "
"system."
msgstr ""

#: ../docs/source/developer_guide/plugins/update_plugin.rst:7
msgid ""
"Once the update is complete, make sure to :ref:`get your plugin listed "
"<plugins.get_listed>`."
msgstr ""

#: ../docs/source/developer_guide/plugins/update_plugin.rst:10
msgid "Folder structure"
msgstr ""

#: ../docs/source/developer_guide/plugins/update_plugin.rst:12
msgid "Old plugin system::"
msgstr ""

#: ../docs/source/developer_guide/plugins/update_plugin.rst:38
msgid "Turns into::"
msgstr ""

#: ../docs/source/developer_guide/plugins/update_plugin.rst:59
msgid "Entry points"
msgstr ""

#: ../docs/source/developer_guide/plugins/update_plugin.rst:61
msgid ""
"If you are converting a plugin from the old system to new new system, the "
"name of your entry points must correspond to where your plugin module was "
"installed inside the AiiDA package. *Otherwise, your plugin will not be "
"backwards compatible*. For example, if you were using a calculation as::"
msgstr ""

#: ../docs/source/developer_guide/plugins/update_plugin.rst:70
msgid "Then in ``setup.py``::"
msgstr ""

#: ../docs/source/developer_guide/plugins/update_plugin.rst:83
msgid ""
"As you see, the name of the entry point matches the argument to the factory "
"method."
msgstr ""

#: ../docs/source/developer_guide/plugins/update_plugin.rst:86
msgid "import statements"
msgstr ""

#: ../docs/source/developer_guide/plugins/update_plugin.rst:88
msgid ""
"If you haven't done so already, now would be a good time to search and "
"replace any import statements that refer to the old locations of your "
"modules inside AiiDA. We recommend to change them to absolute imports from "
"your top-level package:"
msgstr ""

#: ../docs/source/developer_guide/plugins/update_plugin.rst:93
msgid "old::"
msgstr ""

#: ../docs/source/developer_guide/plugins/update_plugin.rst:97
msgid "new::"
msgstr ""

#: ../docs/source/developer_guide/tools/sphinx_cheatsheet.rst:2
msgid "Sphinx cheatsheet"
msgstr ""

#: ../docs/source/developer_guide/tools/sphinx_cheatsheet.rst:4
msgid "A collection of some Sphinx features used in the AiiDA documentation."
msgstr ""

#: ../docs/source/developer_guide/tools/sphinx_cheatsheet.rst:7
msgid "Terminal and Code Formatting"
msgstr ""

#: ../docs/source/developer_guide/tools/sphinx_cheatsheet.rst:9
msgid "Something to be run in the command line can be formatted like this::"
msgstr ""

#: ../docs/source/developer_guide/tools/sphinx_cheatsheet.rst:14
msgid "Code formatting, but now with python syntax highlighting::"
msgstr ""

#: ../docs/source/developer_guide/tools/sphinx_cheatsheet.rst:19
msgid "Another way of explicitly doing this is:"
msgstr ""

#: ../docs/source/developer_guide/tools/sphinx_cheatsheet.rst:26
msgid ""
"`Here <https://www.sphinx-"
"doc.org/en/latest/usage/restructuredtext/directives.html#directive-code-"
"block>`_ is an external link to the Sphinx doc on this. Note also the "
"keyword ``highlight`` (`Sphinx documentation here <https://www.sphinx-"
"doc.org/en/latest/usage/restructuredtext/directives.html#directive-"
"highlight>`_), which may also be used to achieve a similar result."
msgstr ""

#: ../docs/source/developer_guide/tools/sphinx_cheatsheet.rst:30
msgid "Notes"
msgstr ""

#: ../docs/source/developer_guide/tools/sphinx_cheatsheet.rst:32
msgid "Notes can be added like this."
msgstr ""

#: ../docs/source/developer_guide/tools/sphinx_cheatsheet.rst:36
msgid "A multi-line note can be added like this. Hello, world!"
msgstr ""

#: ../docs/source/developer_guide/tools/sphinx_cheatsheet.rst:41
msgid "Links, Code Display, Cross References"
msgstr ""

#: ../docs/source/developer_guide/tools/sphinx_cheatsheet.rst:44
msgid "Code Download"
msgstr ""

#: ../docs/source/developer_guide/tools/sphinx_cheatsheet.rst:46
msgid "Code can be downloaded like this."
msgstr ""

#: ../docs/source/developer_guide/tools/sphinx_cheatsheet.rst:48
msgid ""
"Download: :download:`this example script "
"<../../concepts/include/snippets/calculations/calcfunctions/add_multiply_plain_python.py>`"
msgstr ""

#: ../docs/source/developer_guide/tools/sphinx_cheatsheet.rst:51
msgid "Code Display"
msgstr ""

#: ../docs/source/developer_guide/tools/sphinx_cheatsheet.rst:53
msgid ""
"Can be done like this. This entire document can be seen unformatted at :ref"
":`this-page` using the keyword ``literalinclude``. For more details, see the"
" `Sphinx documentation <https://www.sphinx-"
"doc.org/en/latest/usage/restructuredtext/directives.html#directive-"
"literalinclude>`_."
msgstr ""

#: ../docs/source/developer_guide/tools/sphinx_cheatsheet.rst:62
msgid "Math"
msgstr ""

#: ../docs/source/developer_guide/tools/sphinx_cheatsheet.rst:64
msgid ""
"Math formulas can be added as follows :math:`<g_i|`, see `the Sphinx "
"documentation on math <http://www.sphinx-doc.org/latest/ext/math.html"
"#module-sphinx.ext.mathbase>`_."
msgstr ""

#: ../docs/source/developer_guide/tools/sphinx_cheatsheet.rst:67
msgid "Cross Reference Docs"
msgstr ""

#: ../docs/source/developer_guide/tools/sphinx_cheatsheet.rst:69
msgid ""
"Here is an example of a reference to :ref:`concepts_provenance` which is on "
"*another page*."
msgstr ""

#: ../docs/source/developer_guide/tools/sphinx_cheatsheet.rst:71
msgid ""
"Here, :ref:`self-reference`, is an example of a reference to something on "
"the same page."
msgstr ""

#: ../docs/source/developer_guide/tools/sphinx_cheatsheet.rst:73
msgid ""
"References within the same document need a reference label, see `.. _self-"
"reference:` used in this section for an example."
msgstr ""

#: ../docs/source/developer_guide/tools/sphinx_cheatsheet.rst:76
msgid "Cross Reference Classes and Methods"
msgstr ""

#: ../docs/source/developer_guide/tools/sphinx_cheatsheet.rst:78
msgid ""
"Reference to the :py:class:`aiida.orm.nodes.data.structure.StructureData` "
"class, showing the full path."
msgstr ""

#: ../docs/source/developer_guide/tools/sphinx_cheatsheet.rst:80
msgid ""
"Reference to the :py:class:`~aiida.orm.nodes.data.structure.StructureData` "
"class (with preceding tilde), showing only the class name."
msgstr ""

#: ../docs/source/developer_guide/tools/sphinx_cheatsheet.rst:82
msgid ""
"Always point to the actual definition of a class, e.g. "
"``aiida.orm.nodes.data.structure.StructureData``, **not** an alias like "
"``aiida.orm.StructureData`` (or Sphinx will complain)."
msgstr ""

#: ../docs/source/developer_guide/tools/sphinx_cheatsheet.rst:84
msgid ""
"Reference to the "
":py:meth:`~aiida.orm.nodes.data.structure.StructureData.append_atom` method."
msgstr ""

#: ../docs/source/developer_guide/tools/sphinx_cheatsheet.rst:86
msgid ""
"Reference to the :py:attr:`~aiida.orm.nodes.Node.label` attribute/property."
msgstr ""

#: ../docs/source/developer_guide/tools/sphinx_cheatsheet.rst:90
msgid "Table of Contents for Code"
msgstr ""

#: ../docs/source/developer_guide/tools/sphinx_cheatsheet.rst:92
msgid ""
"Table of contents that cross reference code, can be done very similarly to "
"how it is done for documents. For example the parser docs can be indexed "
"like this:"
msgstr ""

#: ../docs/source/developer_guide/tools/sphinx_cheatsheet.rst:102
msgid "Automodules Example"
msgstr ""

#: ../../../../env/lib/python3.6/site-packages/aiida/common/warnings.pydocstring
#: of aiida.common.warnings:1
msgid "Define warnings that can be thrown by AiiDA."
msgstr ""

#: ../../../../env/lib/python3.6/site-packages/aiida/common/warnings.pydocstring
#: of aiida.common.warnings.AiidaDeprecationWarning:1
msgid "Class for AiiDA deprecations."
msgstr ""

#: ../../../../env/lib/python3.6/site-packages/aiida/common/warnings.pydocstring
#: of aiida.common.warnings.AiidaDeprecationWarning:3
msgid ""
"It does *not* inherit, on purpose, from `DeprecationWarning` as this would "
"be filtered out by default. Enabled by default, you can disable it by "
"running in the shell::"
msgstr ""

#: ../../../../env/lib/python3.6/site-packages/aiida/common/warnings.pydocstring
#: of aiida.common.warnings.AiidaEntryPointWarning:1
msgid "Class for warnings concerning AiiDA entry points."
msgstr ""

#: ../../../../env/lib/python3.6/site-packages/aiida/common/warnings.pydocstring
#: of aiida.common.warnings.AiidaTestWarning:1
msgid "Class for warnings concerning the AiiDA testing infrastructure."
msgstr ""

#: ../docs/source/developer_guide/tools/sphinx_cheatsheet.rst:111
msgid ""
"A ``:noindex:`` directive was added to avoid duplicate object description "
"for this example."
msgstr ""

#: ../docs/source/developer_guide/tools/sphinx_cheatsheet.rst:114
msgid "How To Format Docstrings"
msgstr ""

#: ../docs/source/developer_guide/tools/sphinx_cheatsheet.rst:116
msgid ""
"Much of the work will be done automatically by Sphinx, just format the "
"docstrings with the same syntax used here, a few extra examples of use would"
" include:"
msgstr ""

#: ../docs/source/developer_guide/tools/sphinx_cheatsheet.rst:139
msgid ""
"In the docstring of a class, you can `refer to a method of the same class "
"<http://www.sphinx-doc.org/en/stable/domains.html>`_ using "
"``:meth:`.name_of_method```."
msgstr ""

#: ../docs/source/developer_guide/tools/sphinx_cheatsheet.rst:144
msgid "This Page"
msgstr ""

#: ../docs/source/developer_guide/tools/visual_aids.rst:2
msgid "Visual Aids"
msgstr ""

#: ../docs/source/developer_guide/tools/visual_aids.rst:4
msgid ""
"This section is dedicated to tools that facilitate the generation of visual "
"aids for the different aspects of AiiDA (such as provenance graphs)."
msgstr ""

#: ../docs/source/developer_guide/tools/visual_aids.rst:9
msgid "Graph Easy"
msgstr ""

#: ../docs/source/developer_guide/tools/visual_aids.rst:11
msgid ""
"This software might be useful for producing simple provenance graphs in "
"ascii format (or some other formats as well). The code can be downloaded "
"from `this site <https://metacpan.org/pod/release/SHLOMIF/Graph-"
"Easy-0.76/bin/graph-easy>`_ and can be installed by untaring and following "
"the instructions in the INSTALL file. The manual for the code is also "
"available `here <hhttp://bloodgate.com/perl/graph/manual>`_, but it is a "
"little difficult to follow. For simple cases uses, it sufices to write and "
"input file such as this:"
msgstr ""

#: ../docs/source/developer_guide/tools/visual_aids.rst:24
msgid "And then process it by running:"
msgstr ""

#: ../docs/source/developer_guide/tools/visual_aids.rst:30
msgid ""
"which will in turn produce the following output (that can be easily "
"redirectioned to a file if you prefer):"
msgstr ""

#: ../docs/source/developer_guide/tools/visual_aids.rst:36
msgid ""
"Although this graph is not as ordered as one should want, it might be easier"
" to generate it that way and then re-arrange it a bit:"
msgstr ""
