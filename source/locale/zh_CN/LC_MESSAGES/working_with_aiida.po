# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2019, ECOLE POLYTECHNIQUE FEDERALE DE LAUSANNE (Theory and Simulation of Materials (THEOS) and National Centre for Computational Design and Discovery of Novel Materials (NCCR MARVEL)), Switzerland and ROBERT BOSCH LLC, USA. All rights reserved
# This file is distributed under the same license as the AiiDA package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Jason.Eu <morty.yu@yahoo.com>, 2019
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: AiiDA 1.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-10-31 22:43+0000\n"
"PO-Revision-Date: 2019-05-17 20:00+0000\n"
"Last-Translator: Jason.Eu <morty.yu@yahoo.com>, 2019\n"
"Language-Team: Chinese (China) (https://www.transifex.com/aiidateam/teams/98967/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../docs/source/working_with_aiida/caching.rst:5
#: ../docs/source/working_with_aiida/index.rst:154
msgid "Caching"
msgstr "缓存"

#: ../docs/source/working_with_aiida/caching.rst:8
msgid "Enabling caching"
msgstr ""

#: ../docs/source/working_with_aiida/caching.rst:10
msgid ""
"There are numerous reasons why you may need to re-run calculations you’ve "
"already done before. Since AiiDA stores the full provenance of each "
"calculation, it can detect whether a calculation has been run before and "
"reuse its outputs without wasting computational resources. This is what we "
"mean by **caching** in AiiDA."
msgstr ""

#: ../docs/source/working_with_aiida/caching.rst:14
msgid ""
"Caching is **not enabled by default**. In order to enable caching for your "
"AiiDA profile (here called ``aiida2``), place the following "
"``cache_config.yml`` file in your ``.aiida`` configuration folder:"
msgstr ""

#: ../docs/source/working_with_aiida/caching.rst:22
msgid ""
"From this point onwards, when you launch a new calculation, AiiDA will "
"compare its hash (depending both on the type of calculation and its inputs, "
"see :ref:`caching_matches`) against other calculations already present in "
"your database. If another calculation with the same hash is found, AiiDA "
"will reuse its results without repeating the actual calculation."
msgstr ""

#: ../docs/source/working_with_aiida/caching.rst:25
msgid ""
"In order to ensure that the provenance graph with and without caching is the"
" same, AiiDA creates both a new calculation node and a copy of the output "
"data nodes as shown in :numref:`fig_caching`."
msgstr ""

#: ../docs/source/working_with_aiida/caching.rst:32
msgid ""
"When reusing the results of a calculation **C** for a new calculation "
"**C'**, AiiDA simply makes a copy of the result nodes and links them up as "
"usual."
msgstr ""

#: ../docs/source/working_with_aiida/caching.rst:36
msgid ""
"AiiDA uses the *hashes* of the input nodes **D1** and **D2** when searching "
"the calculation cache. I.e. if the input of **C'** were new nodes **D1'** "
"and **D2'** with the same content (hash) as **D1**, **D2**, the cache would "
"trigger as well."
msgstr ""

#: ../docs/source/working_with_aiida/caching.rst:40
msgid ""
"Caching is **not** implemented at the WorkChain/workfunction level (see "
":ref:`caching_limitations` for details)."
msgstr ""

#: ../docs/source/working_with_aiida/caching.rst:46
msgid "How are nodes hashed?"
msgstr ""

#: ../docs/source/working_with_aiida/caching.rst:48
msgid ""
"*Hashing* is turned on by default, i.e. all nodes in AiiDA are hashed (see "
"also :ref:`devel_controlling_hashing`). The hash of a ``Data`` node is "
"computed from:"
msgstr ""

#: ../docs/source/working_with_aiida/caching.rst:51
msgid ""
"all attributes of the node, except the ``_updatable_attributes`` and "
"``_hash_ignored_attributes``"
msgstr ""

#: ../docs/source/working_with_aiida/caching.rst:52
msgid "the ``__version__`` of the package which defined the node class"
msgstr ""

#: ../docs/source/working_with_aiida/caching.rst:53
msgid "the content of the repository folder of the node"
msgstr "节点的repository文件夹的内容"

#: ../docs/source/working_with_aiida/caching.rst:54
msgid "the UUID of the computer, if the node is associated with one"
msgstr ""

#: ../docs/source/working_with_aiida/caching.rst:56
msgid ""
"The hash of a :class:`~aiida.orm.ProcessNode` includes, on top of this, the "
"hashes of all of its input ``Data`` nodes."
msgstr ""

#: ../docs/source/working_with_aiida/caching.rst:58
msgid ""
"Once a node is stored in the database, its hash is stored in the "
"``_aiida_hash`` extra, and this extra is used to find matching nodes. If a "
"node of the same class with the same hash already exists in the database, "
"this is considered a cache match."
msgstr ""

#: ../docs/source/working_with_aiida/caching.rst:61
msgid ""
"Use the :meth:`~aiida.orm.nodes.Node.get_hash` method to check the hash of "
"any node."
msgstr ""

#: ../docs/source/working_with_aiida/caching.rst:63
msgid ""
"In order to figure out why a calculation is *not* being reused, the "
":meth:`~aiida.orm.nodes.Node._get_objects_to_hash` method may be useful:"
msgstr ""

#: ../docs/source/working_with_aiida/caching.rst:88
msgid "Configuration"
msgstr "配置"

#: ../docs/source/working_with_aiida/caching.rst:91
msgid "Class level"
msgstr ""

#: ../docs/source/working_with_aiida/caching.rst:93
msgid ""
"Besides an on/off switch per profile, the ``.aiida/cache_config.yml`` "
"provides control over caching at the level of specific calculations using "
"their corresponding entry point strings (see the output of ``verdi plugin "
"list aiida.calculations``):"
msgstr ""

#: ../docs/source/working_with_aiida/caching.rst:104
msgid ""
"In this example, caching is disabled by default, but explicitly enabled for "
"calculaions of the ``PwCalculation`` class, identified by the "
"``aiida.calculations:quantumespresso.pw`` entry point string. It also shows "
"how to disable caching for particular calculations (which has no effect here"
" due to the profile-wide default)."
msgstr ""

#: ../docs/source/working_with_aiida/caching.rst:108
msgid "Instance level"
msgstr ""

#: ../docs/source/working_with_aiida/caching.rst:110
msgid ""
"Even when caching is turned off for a given calculation type, you can enable"
" it on a case-by-case basis by using the "
":class:`~aiida.manage.caching.enable_caching` context manager for testing "
"purposes:"
msgstr ""

#: ../docs/source/working_with_aiida/caching.rst:121
msgid ""
"This affects only the current python interpreter and won't change the "
"behavior of the daemon workers. This means that this technique is only "
"useful when using :py:class:`~aiida.engine.run`, and **not** with "
":py:class:`~aiida.engine.submit`."
msgstr ""

#: ../docs/source/working_with_aiida/caching.rst:124
msgid ""
"If you suspect a node is being reused in error (e.g. during development), "
"you can also manually *prevent* a specific node from being reused:"
msgstr ""

#: ../docs/source/working_with_aiida/caching.rst:126
msgid ""
"Load one of the nodes you suspect to be a clone. Check that "
":meth:`~aiida.orm.nodes.Node.get_cache_source` returns a UUID. If it returns"
" `None`, the node was not cloned."
msgstr ""

#: ../docs/source/working_with_aiida/caching.rst:129
msgid ""
"Clear the hashes of all nodes that are considered identical to this node:"
msgstr ""

#: ../docs/source/working_with_aiida/caching.rst:135
msgid ""
"Run your calculation again. The node in question should no longer be reused."
msgstr ""

#: ../docs/source/working_with_aiida/caching.rst:141
msgid "Limitations"
msgstr ""

#: ../docs/source/working_with_aiida/caching.rst:143
msgid ""
"Workflow nodes are not cached. In the current design this follows from the "
"requirement that the provenance graph be independent of whether caching is "
"enabled or not:"
msgstr ""

#: ../docs/source/working_with_aiida/caching.rst:145
msgid ""
"**Calculation nodes:** Calculation nodes can have data inputs and create new"
" data nodes as outputs. In order to make it look as if a cloned calculation "
"produced its own outputs, the output nodes are copied and linked as well."
msgstr ""

#: ../docs/source/working_with_aiida/caching.rst:147
msgid ""
"**Workflow nodes:** Workflows differ from calculations in that they can "
"*return* an input node or an output node created by a calculation. Since "
"caching does not care about the *identity* of input nodes but only their "
"*content*, it is not straightforward to figure out which node to return in a"
" cached workflow."
msgstr ""

#: ../docs/source/working_with_aiida/caching.rst:150
msgid ""
"For the moment, this limitation is acceptable since the runtime of AiiDA "
"WorkChains is usually dominated by expensive calculations, which are covered"
" by the current caching mechanism."
msgstr ""

#: ../docs/source/working_with_aiida/caching.rst:152
msgid ""
"The caching mechanism for calculations *should* trigger only when the inputs"
" and the calculation to be performed are exactly the same. While AiiDA's "
"hashes include the version of the python package containing the "
"calculation/data classes, it cannot detect cases where the underlying python"
" code was changed without increasing the version number. Another edge case "
"would be if the parser lives in a different python package than the "
"calculation (calculation nodes store the name of the parser used but not the"
" version of the package containing the parser)."
msgstr ""

#: ../docs/source/working_with_aiida/caching.rst:156
msgid ""
"Finally, while caching saves unnecessary computations, it does not save disk"
" space: The output nodes of the cached calculation are full copies of the "
"original outputs. The plan is to add data deduplication as a global feature "
"at the repository and database level (independent of caching)."
msgstr ""

#: ../docs/source/working_with_aiida/cookbook.rst:2
msgid "AiiDA cookbook (useful code snippets)"
msgstr "AiiDA cookbook (有用的代码片段)"

#: ../docs/source/working_with_aiida/cookbook.rst:4
msgid ""
"This cookbook is intended to be a collection of useful short scripts and "
"code snippets that may be useful in the everyday usage of AiiDA. Please read"
" carefully the notes (if any) before running the scripts!"
msgstr ""
"cookbook旨在收集有用的简短脚本和代码片段，这些脚本和代码片段可能在AiiDA的日常使用中很有用。在运行脚本之前，请仔细阅读注释(如果有的话)!"

#: ../docs/source/working_with_aiida/cookbook.rst:9
msgid "Checking the queued jobs on a scheduler"
msgstr "检查调度程序上排队的作业"

#: ../docs/source/working_with_aiida/cookbook.rst:11
msgid ""
"If you want to know if which jobs are currently on the scheduler (e.g. to "
"dynamically decide on which computer to submit, or to delay submission, "
"etc.) you can use a modification of the following script::"
msgstr "如果您想知道当前调度程序上有哪些作业(例如，动态决定提交哪台计算机，或延迟提交等)，可以使用以下脚本的修改::"

#: ../docs/source/working_with_aiida/cookbook.rst:67
msgid "Use ``verdi run`` to execute it::"
msgstr "使用 ``verdi run`` 运行它::"

#: ../docs/source/working_with_aiida/cookbook.rst:71
msgid ""
"Every time you call the function, an ssh connection is executed! So be "
"careful and run this function sparsely, or your supercomputer centre might "
"block your account."
msgstr "每次调用该函数时，都会执行ssh连接!因此，请小心谨慎地运行这个函数，否则您的超级计算机中心可能会阻塞您的帐户。"

#: ../docs/source/working_with_aiida/cookbook.rst:75
msgid ""
"Another alternative if you want to call many times the function is to pass "
"the transport as a parameter, and keep it open from the outside."
msgstr "如果您想多次调用该函数，另一种选择是将传输作为参数传递，并保持它从外部打开。"

#: ../docs/source/working_with_aiida/cookbook.rst:78
msgid "An example output would be::"
msgstr "一个输出样例是::"

#: ../docs/source/working_with_aiida/cookbook.rst:100
msgid "Getting an AuthInfo knowing the computer and the user"
msgstr ""

#: ../docs/source/working_with_aiida/cookbook.rst:102
msgid ""
"If you have an ORM ``Computer`` and and ORM ``User``, the way to get an "
"``AuthInfo`` object is the following::"
msgstr ""

#: ../docs/source/working_with_aiida/cookbook.rst:107
msgid ""
"This might be useful, for instance, to then get a transport to connect to "
"the computer."
msgstr ""

#: ../docs/source/working_with_aiida/cookbook.rst:110
msgid "Here is, as an example, an useful utility function::"
msgstr ""

#: ../docs/source/working_with_aiida/cookbook.rst:122
msgid "that you can then use, for instance, as follows::"
msgstr ""

#: ../docs/source/working_with_aiida/daemon_service.rst:2
msgid "Daemon as system service"
msgstr "将守护进程作为系统服务"

#: ../docs/source/working_with_aiida/daemon_service.rst:4
msgid ""
"If you would like the AiiDA daemon to run at startup of your linux system, "
"you can set up a `systemd service "
"<https://www.freedesktop.org/software/systemd/man/systemd.service.html>`_ "
"for it."
msgstr ""
"如果你希望 AiiDA 守护进程在你启动linux系统的时候运行，你可以为其配置一个 `systemd service "
"<https://www.freedesktop.org/software/systemd/man/systemd.service.html>`_ 。"

#: ../docs/source/working_with_aiida/daemon_service.rst:9
msgid ""
"Create a file ``aiida-daemon@.service`` using the template below, replacing "
"``{{ venv_dir }}``, ``{{ home_dir }}`` and  ``{{ user }}`` by appropriate "
"values::"
msgstr ""
"使用下面的模板创建文件 ``aiida-daemon@.service`` 并用合适的值替换 ``{{ venv_dir }}``, ``{{ "
"home_dir }}`` 和  ``{{ user }}`` ::"

#: ../docs/source/working_with_aiida/daemon_service.rst:39
msgid "Install the service like so::"
msgstr "如下安装服务::"

#: ../docs/source/working_with_aiida/daemon_service.rst:44
msgid "Start the AiiDA daemon service for a profile ``profile``::"
msgstr "对 ``profile`` 配置文件开启AiiDA守护进程服务::"

#: ../docs/source/working_with_aiida/daemon_service.rst:48
msgid ""
"After this, the AiiDA daemon should start together with your system. To "
"remove the service again::"
msgstr "在此之后，AiiDA守护进程应该与您的系统一起启动。删除服务::"

#: ../docs/source/working_with_aiida/deleting_nodes.rst:4
msgid "Usage"
msgstr ""

#: ../docs/source/working_with_aiida/deleting_nodes.rst:6
msgid "In order to delete a given set of nodes, you just need to run::"
msgstr ""

#: ../docs/source/working_with_aiida/deleting_nodes.rst:11
msgid ""
"For this you can use any valid AiiDA node identification number (id, uuid, "
"pk, etc.). The important thing to take into account is that, in order to "
"keep a consistent provenance, AiiDA will not only delete the nodes "
"explicitly requested, but other linked nodes as well. To understand how the "
"procedure works and the criteria for node inclusion, please read the "
":ref:`corresponding subsection<consistency>` of the :ref:`Provenance "
"section<concepts_provenance>`."
msgstr ""

#: ../docs/source/working_with_aiida/groups.rst:2
msgid "About Groups"
msgstr ""

#: ../docs/source/working_with_aiida/groups.rst:4
msgid ""
"Groups are a tool to organize the nodes of the provenance graph into sub "
"sets. Any number of groups can be created and each group can contain any "
"number of nodes of any type."
msgstr ""

#: ../docs/source/working_with_aiida/groups.rst:7
msgid ""
"Typically, you want to put multiple nodes into a group because they share "
"some common property, and through the group they can easily be referenced. "
"Unlike nodes, groups can be modified at any time. Here we profide a list of "
"typical operations that may be performed with groups:"
msgstr ""

#: ../docs/source/working_with_aiida/groups.rst:12
msgid ""
"Any deletion operation related to groups won't affect the nodes themselves. "
"For example if you delete a group, the nodes that belonged to the group will"
" remain in the database. The same happens if you delete nodes from the group"
" -- they will remain in the database but won't belong to the group anymore."
msgstr ""

#: ../docs/source/working_with_aiida/groups.rst:19
msgid "Create a new Group"
msgstr ""

#: ../docs/source/working_with_aiida/groups.rst:21
#: ../docs/source/working_with_aiida/groups.rst:45
#: ../docs/source/working_with_aiida/groups.rst:68
#: ../docs/source/working_with_aiida/groups.rst:89
#: ../docs/source/working_with_aiida/groups.rst:107
#: ../docs/source/working_with_aiida/groups.rst:121
#: ../docs/source/working_with_aiida/groups.rst:135
#: ../docs/source/working_with_aiida/groups.rst:150
msgid "From the command line interface::"
msgstr ""

#: ../docs/source/working_with_aiida/groups.rst:25
#: ../docs/source/working_with_aiida/groups.rst:49
#: ../docs/source/working_with_aiida/groups.rst:73
#: ../docs/source/working_with_aiida/groups.rst:112
#: ../docs/source/working_with_aiida/groups.rst:126
#: ../docs/source/working_with_aiida/groups.rst:155
msgid "From the python interface::"
msgstr ""

#: ../docs/source/working_with_aiida/groups.rst:35
msgid "List available Groups"
msgstr ""

#: ../docs/source/working_with_aiida/groups.rst:37
msgid "Example::"
msgstr ""

#: ../docs/source/working_with_aiida/groups.rst:41
msgid ""
"By default ``verdi group list`` only shows groups of the type *user*. In "
"case you want to show groups of another type use ``-t/--type`` option. If "
"you want to show groups of all types, use the ``-a/--all-types`` option."
msgstr ""

#: ../docs/source/working_with_aiida/groups.rst:64
msgid "Add nodes to a Group"
msgstr ""

#: ../docs/source/working_with_aiida/groups.rst:66
msgid ""
"Once the ``test_group`` has been created, we can add nodes to it. To add the"
" node with ``pk=1`` to the group we need to do the following."
msgstr ""

#: ../docs/source/working_with_aiida/groups.rst:87
msgid "Show information about a Group"
msgstr ""

#: ../docs/source/working_with_aiida/groups.rst:105
msgid "Remove nodes from a Group"
msgstr ""

#: ../docs/source/working_with_aiida/groups.rst:119
msgid "Rename Group"
msgstr ""

#: ../docs/source/working_with_aiida/groups.rst:133
msgid "Delete Group"
msgstr ""

#: ../docs/source/working_with_aiida/groups.rst:144
msgid "Copy one group into another"
msgstr ""

#: ../docs/source/working_with_aiida/groups.rst:146
msgid ""
"This operation will copy the nodes of the source group into the destination "
"group. Moreover, if the destination group did not exist before, it will be "
"created automatically."
msgstr ""

#: ../docs/source/working_with_aiida/index.rst:5
msgid "Getting started"
msgstr ""

#: ../docs/source/working_with_aiida/index.rst:18
msgid "Command line interface"
msgstr "命令行接口"

#: ../docs/source/working_with_aiida/index.rst:20
msgid ""
"One way of interacting with AiiDA is through the ``verdi`` command line "
"interface (CLI)."
msgstr ""

#: ../docs/source/working_with_aiida/index.rst:22
msgid ""
"Before checking out the individual commands below, start with a brief look "
"at the :ref:`general concepts<cli_concepts>` that apply across all commands."
msgstr ""

#: ../docs/source/working_with_aiida/index.rst:32
msgid ":ref:`calcjob<verdi_calcjob>`:  Inspect and manage calcjobs."
msgstr ":ref:`calcjob<verdi_calcjob>`:  检查和管理算例任务（calcjobs）。"

#: ../docs/source/working_with_aiida/index.rst:33
msgid ":ref:`code<verdi_code>`:  Setup and manage codes."
msgstr ":ref:`code<verdi_code>`:  设置和管理计算代码。"

#: ../docs/source/working_with_aiida/index.rst:34
msgid ""
":ref:`comment<verdi_comment>`:  Inspect, create and manage node comments."
msgstr ":ref:`comment<verdi_comment>`:  检查，创建和管理节点注释。"

#: ../docs/source/working_with_aiida/index.rst:35
msgid ""
":ref:`completioncommand<verdi_completioncommand>`:  Return the code to "
"activate bash completion."
msgstr ""

#: ../docs/source/working_with_aiida/index.rst:36
msgid ":ref:`computer<verdi_computer>`:  Setup and manage computers."
msgstr ":ref:`computer<verdi_computer>`:  设置和管理计算资源。"

#: ../docs/source/working_with_aiida/index.rst:37
msgid ""
":ref:`config<verdi_config>`:  Configure profile-specific or global AiiDA "
"options."
msgstr ""

#: ../docs/source/working_with_aiida/index.rst:38
msgid ":ref:`daemon<verdi_daemon>`:  Inspect and manage the daemon."
msgstr ":ref:`daemon<verdi_daemon>`:  检查和管理守护进程。"

#: ../docs/source/working_with_aiida/index.rst:39
msgid ":ref:`data<verdi_data>`:  Inspect, create and manage data nodes."
msgstr ":ref:`data<verdi_data>`:  检查，创建和管理数据节点。"

#: ../docs/source/working_with_aiida/index.rst:40
msgid ":ref:`database<verdi_database>`:  Inspect and manage the database."
msgstr ":ref:`database<verdi_database>`:  检查和管理数据库。"

#: ../docs/source/working_with_aiida/index.rst:41
msgid ":ref:`devel<verdi_devel>`:  Commands for developers."
msgstr ":ref:`devel<verdi_devel>`:  开发者相关的命令。"

#: ../docs/source/working_with_aiida/index.rst:42
msgid ":ref:`export<verdi_export>`:  Create and manage export archives."
msgstr ":ref:`export<verdi_export>`:  创建和管理输出的存档"

#: ../docs/source/working_with_aiida/index.rst:43
msgid ""
":ref:`graph<verdi_graph>`:  Create visual representations of the provenance "
"graph."
msgstr ""

#: ../docs/source/working_with_aiida/index.rst:44
msgid ""
":ref:`group<verdi_group>`:  Create, inspect and manage groups of nodes."
msgstr ""

#: ../docs/source/working_with_aiida/index.rst:45
msgid ":ref:`help<verdi_help>`:  Show help for given command."
msgstr ""

#: ../docs/source/working_with_aiida/index.rst:46
msgid ":ref:`import<verdi_import>`:  Import data from an AiiDA archive file."
msgstr ""

#: ../docs/source/working_with_aiida/index.rst:47
msgid ":ref:`node<verdi_node>`:  Inspect, create and manage nodes."
msgstr ":ref:`node<verdi_node>`:  检查，创建和管理节点。"

#: ../docs/source/working_with_aiida/index.rst:48
msgid ":ref:`plugin<verdi_plugin>`:  Inspect AiiDA plugins."
msgstr ""

#: ../docs/source/working_with_aiida/index.rst:49
msgid ":ref:`process<verdi_process>`:  Inspect and manage processes."
msgstr ":ref:`process<verdi_process>`:  检查和管理例程。"

#: ../docs/source/working_with_aiida/index.rst:50
msgid ""
":ref:`profile<verdi_profile>`:  Inspect and manage the configured profiles."
msgstr ":ref:`profile<verdi_profile>`:  检查和管理配置信息。"

#: ../docs/source/working_with_aiida/index.rst:51
msgid ""
":ref:`quicksetup<verdi_quicksetup>`:  Setup a new profile in a fully "
"automated fashion."
msgstr ""

#: ../docs/source/working_with_aiida/index.rst:52
msgid ""
":ref:`rehash<verdi_rehash>`:  Recompute the hash for nodes in the database."
msgstr ""

#: ../docs/source/working_with_aiida/index.rst:53
msgid ":ref:`restapi<verdi_restapi>`:  Run the AiiDA REST API server."
msgstr ""

#: ../docs/source/working_with_aiida/index.rst:54
msgid ""
":ref:`run<verdi_run>`:  Execute scripts with preloaded AiiDA environment."
msgstr ""

#: ../docs/source/working_with_aiida/index.rst:55
msgid ":ref:`setup<verdi_setup>`:  Setup a new profile."
msgstr ":ref:`setup<verdi_setup>`:  设置一个新的配置信息。"

#: ../docs/source/working_with_aiida/index.rst:56
msgid ""
":ref:`shell<verdi_shell>`:  Start a python shell with preloaded AiiDA "
"environment."
msgstr ":ref:`shell<verdi_shell>`:  开启一个会预先加载AiiDA环境的python shell。"

#: ../docs/source/working_with_aiida/index.rst:57
msgid ":ref:`status<verdi_status>`:  Print status of AiiDA services."
msgstr ":ref:`status<verdi_status>`:  打印AiiDA服务状态。"

#: ../docs/source/working_with_aiida/index.rst:58
msgid ":ref:`user<verdi_user>`:  Inspect and manage users."
msgstr ":ref:`user<verdi_user>`:  检查和管理用户。"

#: ../docs/source/working_with_aiida/index.rst:66
msgid "Python interface"
msgstr ""

#: ../docs/source/working_with_aiida/index.rst:68
msgid ""
"While the ``verdi`` CLI provides shortcuts for many common tasks, the AiiDA "
"python API provides full access to the underlying AiiDA python objects and "
"their methods. This is possible via the interactive ``verdi shell`` and via "
"python scripts:"
msgstr ""

#: ../docs/source/working_with_aiida/index.rst:81
msgid "Manage data"
msgstr ""

#: ../docs/source/working_with_aiida/index.rst:84
msgid "Data types"
msgstr "数据类型"

#: ../docs/source/working_with_aiida/index.rst:95
msgid "Groups"
msgstr "组"

#: ../docs/source/working_with_aiida/index.rst:103
msgid "Querying data"
msgstr "查询数据"

#: ../docs/source/working_with_aiida/index.rst:114
msgid "Result manager"
msgstr "结果管理器"

#: ../docs/source/working_with_aiida/index.rst:122
msgid "Deleting Nodes"
msgstr ""

#: ../docs/source/working_with_aiida/index.rst:129
msgid "Provenance Graphs"
msgstr ""

#: ../docs/source/working_with_aiida/index.rst:136
msgid "Backups"
msgstr "备份"

#: ../docs/source/working_with_aiida/index.rst:144
msgid "Import and Export"
msgstr ""

#: ../docs/source/working_with_aiida/index.rst:164
msgid "Schedulers"
msgstr "任务调度程序"

#: ../docs/source/working_with_aiida/index.rst:166
msgid ""
"Instances of ``CalcJobNode`` instances are submitted by the daemon to an "
"external scheduler. For this functionality to work, AiiDA needs to be able "
"to interact with these schedulers. Interfaces have been written for some of "
"the most used schedulers."
msgstr ""

#: ../docs/source/working_with_aiida/index.rst:177
msgid "Troubleshooting"
msgstr "故障排除"

#: ../docs/source/working_with_aiida/index.rst:186
msgid "Cookbook"
msgstr "Cookbook"

#: ../docs/source/working_with_aiida/python_api.rst:4
msgid "Public resources"
msgstr "公共资源"

#: ../docs/source/working_with_aiida/python_api.rst:6
msgid ""
"The main package of ``aiida-core`` is called ``aiida``, which contains "
"various sub-packages that we refer to as \"second-level packages\". These "
"second level packages can have further nested hierarchies. Certain resources"
" within these packages, for example modules, classes, functions and "
"variables, are intended for internal use, whereas others *are meant* to be "
"used by users of the ``aiida-core`` package. To make it easier for users to "
"locate these resources that are intended for external use, as well as to "
"distinguish them from internal resources *that are not supposed to be used*,"
" they are exposed directly on the second-level package. This means that any "
"resource that can be directly imported from a second-level package, *is "
"intended for external use*. Below we provide a list of the resources per "
"second-level package that are exposed in this way. If a module is mentioned,"
" then all the resources defined in its ``__all__`` are included"
msgstr ""
"``aiida-core`` 的主包称为 ``aiida`` ，其中包含各种子包，我们称之为 ``二级包`` "
"。这些第二级包可以有进一步嵌套的层次结构。这些包中的某些资源，例如模块、类、函数和变量，是供内部使用的，而其他的 *是设计为* 提供给 ``aida "
"-core`` 包的用户使用的。为了使用户更容易地找到这些资源，这些资源是用于外部使用的，并将它们与 *不应该使用的内部资源* "
"区分开来，它们直接暴露在第二层包中。这意味着任何可以直接从第二级包 *导入的资源都将用于外部使用* "
"。下面我们提供了以这种方式公开的每个二级包的资源列表。如果提到一个模块，那么它的 ``_all__`` 中定义的所有资源都包括在内"

#: ../docs/source/working_with_aiida/python_api.rst:16
msgid "``aiida.cmdline``"
msgstr "``aiida.cmdline``"

#: ../docs/source/working_with_aiida/python_api.rst:28
msgid "``aiida.common``"
msgstr "``aiida.common``"

#: ../docs/source/working_with_aiida/python_api.rst:40
msgid "``aiida.engine``"
msgstr "``aiida.engine``"

#: ../docs/source/working_with_aiida/python_api.rst:64
msgid "``aiida.orm``"
msgstr "``aiida.orm``"

#: ../docs/source/working_with_aiida/python_api.rst:108
msgid "``aiida.parsers``"
msgstr "``aiida.parsers``"

#: ../docs/source/working_with_aiida/python_api.rst:116
msgid "``aiida.plugins``"
msgstr "``aiida.plugins``"

#: ../docs/source/working_with_aiida/python_api.rst:131
msgid "``aiida.scheduler``"
msgstr "``aiida.scheduler``"

#: ../docs/source/working_with_aiida/python_api.rst:139
msgid "``aiida.tools``"
msgstr "``aiida.tools``"

#: ../docs/source/working_with_aiida/python_api.rst:152
msgid "``aiida.transport``"
msgstr "``aiida.transport``"

#: ../docs/source/working_with_aiida/resultmanager.rst:3
msgid "Retrieving results"
msgstr "结果检索"

#: ../docs/source/working_with_aiida/resultmanager.rst:5
msgid ""
"In this section, we describe how to get the results of a calculation after "
"it has been parsed by AiiDA, or the input and output of a generic Node. When"
" a calculation is done on the remote computer, AiiDA will retrieve the "
"results and try to parse the results with the default parser, if one is "
"available for the given calculation. These results are stored in new nodes, "
"and connected as output of the calculation. Of course, it is possible to "
":ref:`directly check the output nodes <db_input_output>` for a given "
"calculation and get their content. However, AiiDA provides a way to directly"
" access the results, using the "
":py:class:`CalcJobResultManager<aiida.orm.utils.calcjob.CalcJobResultManager>`"
" class, described in the next section."
msgstr ""
"在本节中，我们将描述如何在AiiDA解析计算结果(或一般节点的输入和输出)之后获得计算结果。当在远程计算机上完成计算时，AiiDA将检索结果，并尝试使用默认解析器解析结果(如果给定计算有可用的解析器)。这些结果存储在新节点中，并连接为计算的输出。当然，对于给定的计算，可以"
" :ref:`直接检查输出节点<db_input_output>` 并获取它们的内容。不过，AiiDA提供了一种直接访问结果的方法，使用 "
":py:class:`CalcJobResultManager<aiida.orm.utils.calcjob.CalcJobResultManager>`"
"  ，将在下一节中描述。"

#: ../docs/source/working_with_aiida/resultmanager.rst:9
msgid "The CalcJobResultManager"
msgstr "CalcJobResultManager"

#: ../docs/source/working_with_aiida/resultmanager.rst:12
msgid "Prerequisites"
msgstr "准备工作"

#: ../docs/source/working_with_aiida/resultmanager.rst:14
msgid ""
"Before getting the calculation results, we need a correctly finished and "
"parsed "
":class:`CalcJobNode<aiida.orm.nodes.process.calculation.calcjob.CalcJobNode>`."
" For example this can be a Quantum ESPRESSO ``pw.x`` calculation. You can "
"load such a calculation -- we'll call it ``calc`` -- with the command"
msgstr ""
"在获取算例的结果之前，我们需要正确结束并解析 "
":class:`CalcJobNode<aiida.orm.nodes.process.calculation.calcjob.CalcJobNode>`"
" 。例如这可能是一个Quantum ESPRESSO ``pw.x`` 算例。你可以载入该算例 —— 我们将该算例叫做 ``calc`` —— "
"使用命令:"

#: ../docs/source/working_with_aiida/resultmanager.rst:24
msgid ""
"either in ``verdi shell``, or in a python script (as described :doc:`here "
"<../working_with_aiida/scripting>`). ``YOURPK`` should be substituted by a "
"valid calculation ``PK`` in your database."
msgstr ""

#: ../docs/source/working_with_aiida/resultmanager.rst:28
msgid "Using the CalcJobResultManager instance"
msgstr "使用 CalcJobResultManager 实例"

#: ../docs/source/working_with_aiida/resultmanager.rst:30
msgid ""
"Each "
":class:`CalcJobNode<aiida.orm.nodes.process.calculation.calcjob.CalcJobNode>`"
" has a ``res`` attribute that is a "
":class:`~aiida.orm.utils.calcjob.CalcJobResultManager` instance and gives "
"direct access to parsed data. You can access it as ::"
msgstr ""
"每一个 "
":class:`CalcJobNode<aiida.orm.nodes.process.calculation.calcjob.CalcJobNode>`"
" 有 ``res`` 属性，是一个:class:`~aiida.orm.utils.calcjob.CalcJobResultManager` "
"实例，并可直接访问解析后数据。你可以这样访问 ::"

#: ../docs/source/working_with_aiida/resultmanager.rst:37
msgid ""
"To get all the possible keys that were parsed, you can convert the instance "
"into a list. For instance, if you type ::"
msgstr "要获得已解析的所有可能键，可以将实例转换为列表。例如，如果您键入::"

#: ../docs/source/working_with_aiida/resultmanager.rst:43
msgid "you will get something like this::"
msgstr "你会得到这样的结果::"

#: ../docs/source/working_with_aiida/resultmanager.rst:47
msgid ""
"(the list of keys has been cut for clarity: you will get many more keys)."
msgstr "(为了更加清晰，列表中的键只有部分显示：你会得到更多的键)。"

#: ../docs/source/working_with_aiida/resultmanager.rst:50
msgid ""
"Once you know which keys have been parsed, you can access the parsed value "
"simply as an attribute of the ``res`` "
":class:`~aiida.orm.utils.calcjob.CalcJobResultManager`. For instance, to get"
" the final total energy, you can use ::"
msgstr ""
"一旦知道已经解析了哪些键，就可以简单地将解析后的值作为 ``res`` 的属性访问 "
":class:`~aiida.orm.utils.calcjob.CalcJobResultManager` 。例如要获得最后的总能，你可以::"

#: ../docs/source/working_with_aiida/resultmanager.rst:56
msgid ""
"that will print the total energy in units of eV, as also stated in the "
"``energy_units`` key ::"
msgstr "会打印以eV为单位的总能，如 ``energy_units`` 键中所指示的::"

#: ../docs/source/working_with_aiida/resultmanager.rst:61
msgid ""
"Similarly, you can get any other parsed value, for any code that provides a "
"parser."
msgstr "类似地，对于提供解析器的任何计算代码，都可以获得任何其他解析值。"

#: ../docs/source/working_with_aiida/resultmanager.rst:65
msgid ""
"The :class:`~aiida.orm.utils.calcjob.CalcJobResultManager` is also "
"integrated with the iPython/verdi shell completion mechanism: if ``calc`` is"
" a valid "
":class:`CalcJobNode<aiida.orm.nodes.process.calculation.calcjob.CalcJobNode>`,"
" you can type ::"
msgstr ""
":class:`~aiida.orm.utils.calcjob.CalcJobResultManager` 也整合进 iPython/verdi "
"shell 补齐机制: 如果 ``calc`` 是一个有效的 "
":class:`CalcJobNode<aiida.orm.nodes.process.calculation.calcjob.CalcJobNode>`"
" ，你可以键入 ::"

#: ../docs/source/working_with_aiida/resultmanager.rst:70
msgid ""
"and then press the ``TAB`` key of the keyboard to get/complete the list of "
"valid parsed properties for the calculation ``calc``."
msgstr ""

#: ../docs/source/working_with_aiida/resultmanager.rst:75
msgid "Calculations and workflows inputs and outputs"
msgstr "算例和工作流的输入和输出"

#: ../docs/source/working_with_aiida/resultmanager.rst:77
msgid ""
"In the following, we will show the methods to access the input and output "
"nodes of a given calculation or workflow."
msgstr "在下面，我们将展示访问给定算例或工作流的输入和输出节点的方法。"

#: ../docs/source/working_with_aiida/resultmanager.rst:79
msgid ""
"Again, we start by loading a node from the database. Unlike before, this can"
" be any type of node. For example, if we have a the node with ``PK`` 17::"
msgstr ""

#: ../docs/source/working_with_aiida/resultmanager.rst:85
msgid ""
"Now, we want to find the nodes which have a direct input or output link to "
"this node. The node has several methods to extract this information: "
":meth:`get_outgoing() <aiida.orm.nodes.Node.get_outgoing>`, "
":meth:`get_incoming() <aiida.orm.nodes.Node.get_incoming>`."
msgstr ""

#: ../docs/source/working_with_aiida/resultmanager.rst:89
msgid ""
"The most practical way to access this information for a calculation (or "
"workflow), when limiting solely to ``INPUT_CALC`` and ``CREATE`` (or "
"``INPUT_WORK`` and ``RETURN``, respectively), especially when working on the"
" ``verdi shell``, is by means of the ``.inputs`` and ``.outputs`` "
"attributes."
msgstr ""

#: ../docs/source/working_with_aiida/resultmanager.rst:93
msgid ""
"The ``.inputs`` attribute can be used to list and access the input nodes. "
"The names of the input links can be printed by ``list(calc.inputs)`` or "
"interactively by ``calc.inputs. + TAB``. As an example, suppose that "
"``calc`` has an input ``KpointsData`` object under the linkname ``kpoints``."
" The command ::"
msgstr ""
"``.inputs`` 属性可用于列出并访问input节点。input链接的名称可以使用 ``list(calc.inputs)`` "
"答应，或者交互式地输入 ``calc.inputs. + TAB`` 。 例子，假设 ``calc`` 有输入 ``KpointsData`` "
"对象在链接 ``kpoints`` 中。命令为 ::"

#: ../docs/source/working_with_aiida/resultmanager.rst:101
msgid "returns the ``KpointsData`` object."
msgstr "返回 ``KpointsData`` 对象。"

#: ../docs/source/working_with_aiida/resultmanager.rst:103
msgid ""
"Similarly the ``.outputs`` attribute can be used to display the outputs of "
"``calc``. Suppose that ``calc`` has an output ``FolderData`` with linkname "
"``retrieved``, then the command ::"
msgstr ""
"同样的 ``.outputs`` 属性用于显示 ``calc`` 的输出。假设 ``calc`` 有输出节点 ``FolderData`` 链接名为 "
"``retrieved`` ,使用下面命令 ::"

#: ../docs/source/working_with_aiida/resultmanager.rst:109
msgid "returns the ``FolderData`` object."
msgstr "返回 ``FolderData`` 对象。"

#: ../docs/source/working_with_aiida/scripting.rst:2
msgid "Verdi shell"
msgstr "Verdi shell"

#: ../docs/source/working_with_aiida/scripting.rst:3
msgid ""
"By running ``verdi shell`` on the terminal, a new interactive `IPython "
"<http://ipython.org/>`_ shell will be opened (this requires that IPython is "
"installed on your computer)."
msgstr ""
"通过在终端上运行 ``verdi shell`` ，将打开一个新的交互式 `IPython <http://ipython.org/>`_  "
"shell(这需要在您的计算机上安装IPython)。"

#: ../docs/source/working_with_aiida/scripting.rst:7
msgid ""
"Note that simply opening IPython and loading the AiiDA modules will not work"
" (unless you perform the operations described in the :ref:`following section"
" <writing_python_scripts_for_aiida>`) because the database settings are not "
"loaded by default and AiiDA does not know how to access the database."
msgstr ""
"注意，简单地打开IPython并加载AiiDA模块将不起作用(除非执行 "
":ref:`下列章节<writing_python_scripts_for_aiida>` "
"中描述的操作)，因为默认情况下没有加载数据库设置，AiiDA不知道如何访问数据库。"

#: ../docs/source/working_with_aiida/scripting.rst:13
msgid ""
"Moreover, by calling ``verdi shell``, you have the additional advantage that"
" some classes and modules are automatically loaded. In particular the "
"following modules/classes are already loaded and available::"
msgstr "此外，通过调用 ``verdi shell`` ，还可以自动加载一些类和模块。特别是以下模块/类已经加载并可用::"

#: ../docs/source/working_with_aiida/scripting.rst:20
msgid ""
"It is possible to customize the shell by adding modules to be loaded "
"automatically, thanks to the ``verdi config verdishell.modules`` command."
msgstr "通过添加要自动加载的模块，可以自定义shell，这要归功于 ``verdi config verdishell.modules`` 命令。"

#: ../docs/source/working_with_aiida/scripting.rst:23
msgid ""
"A further advantage is that bash completion is enabled, allowing to press "
"the ``TAB`` key to see available submethods of a given object (see for "
"instance the documentation of the :doc:`ResultManager "
"<../working_with_aiida/resultmanager>`)."
msgstr ""
"另一个优点是启用了bash补全，允许按 ``TAB`` 键查看给定对象的可用子方法(例如，请参阅文档 :doc:`ResultManager "
"<../working_with_aiida/resultmanager>` )。"

#: ../docs/source/working_with_aiida/scripting.rst:30
msgid "Python scripts"
msgstr "Python 脚本"

#: ../docs/source/working_with_aiida/scripting.rst:31
msgid ""
"Alternatively, if you do not need an interactive shell but you prefer to "
"write a script and then launch it from the command line, you can just write "
"a standard python ``.py`` file. The only modification that you need to do is"
" to add, at the beginning of the file and before loading any other AiiDA "
"module, the following two lines::"
msgstr ""
"或者，如果你不需要交互式shell，而更愿意编写一个脚本，然后从命令行启动它，那么您可以编写一个标准的python ``py`` "
"文件。您需要做的惟一修改是在文件的开头和加载任何其他AiiDA模块之前添加以下两行::"

#: ../docs/source/working_with_aiida/scripting.rst:40
msgid ""
"that will load the database settings and allow AiiDA to reach your database."
" Then, you can load as usual python and AiiDA modules and classes, and use "
"them. If you want to have the same environment of the ``verdi shell`` "
"interactive shell, you can also add (below the ``load_profile`` call) the "
"following lines::"
msgstr ""
"这将加载数据库设置，并允许AiiDA访问你的数据库。然后，你可以像往常一样加载python和AiiDA的模块和类，并使用它们。如果您想拥有与 "
"``verdi shell`` 交互式 shell相同的环境，还可以添加(在``load_profile`` 调用之后)以下行::"

#: ../docs/source/working_with_aiida/scripting.rst:49
msgid "or simply import the only modules that you will need in the script."
msgstr "或者只导入脚本中需要的模块。"

#: ../docs/source/working_with_aiida/scripting.rst:51
msgid ""
"While this method will work, we strongly suggest to use instead the ``verdi "
"run`` command, described here below."
msgstr "虽然这个方法可以工作，但是我们强烈建议使用下面描述的 ``verdi run`` 命令来代替。"

#: ../docs/source/working_with_aiida/scripting.rst:55
msgid "The ``verdi run`` command and the ``runaiida`` executable"
msgstr "``verdi run`` 命令和 ``runaiida`` 可执行文件"

#: ../docs/source/working_with_aiida/scripting.rst:57
msgid ""
"In order to simplify the procedure described above, it is possible to "
"execute a python file using ``verdi run``: this command will accept as "
"parameter the name of a file, and will execute it after having loaded the "
"modules described above."
msgstr ""
"为了简化上面描述的过程，可以使用 ``verdi run`` 执行python文件:这个命令将接受文件的名称作为参数，并在加载了上面描述的模块后执行。"

#: ../docs/source/working_with_aiida/scripting.rst:62
msgid ""
"The command ``verdi run`` has the additional advantage of adding all stored "
"nodes to suitable special groups, of type ``auto.run``, for later usage. You"
" can get the list of all these groups with the command::"
msgstr ""
"命令 ``verdi run`` 的另一个优点是将所有存储的节点添加到适当的特殊组中，类型为 ``auto.run`` "
"，供以后使用。您可以使用以下命令获得所有这些组的列表::"

#: ../docs/source/working_with_aiida/scripting.rst:69
msgid ""
"Some further command line options of ``verdi run`` allow the user to fine-"
"tune the autogrouping behavior; for more details, refer to the output of "
"``verdi run -h``. Note also that further command line parameters to ``verdi "
"run`` are passed to the script as ``sys.argv``."
msgstr ""
"``verdi run`` 的一些命令行选项允许用户微调自动分组行为;有关详细信息，请参考 ``verdi run -h`` "
"的输出。还要注意，``verdi run`` 的其他命令行参数将作为 ``sys.argv`` 传递给脚本。"

#: ../docs/source/working_with_aiida/scripting.rst:75
msgid ""
"Finally, we also defined a ``runaiida`` command, that simply will pass all "
"its parameters to ``verdi run``. The reason for this is that one can define "
"a new script to be run with ``verdi run``, add as the first line the shebang"
" command ``#!/usr/bin/env runaiida``, and give to the file execution "
"permissions, and the file will become an executable that is run using AiiDA."
" A simple example could be::"
msgstr ""
"最后，我们还定义了一个 ``runaiida`` 命令，它将把所有参数传递给 ``verdi run`` 。这样做的原因是，可以定义一个新的脚本运行 "
"``verdi run`` ，添加作为第一行shebang命令 ``#!/usr/bin/env runaiida`` "
"，并赋予文件执行权限，该文件将成为使用AiiDA运行的可执行文件。一个简单的例子可以是::"

#: ../docs/source/working_with_aiida/troubleshooting.rst:2
msgid "Some tricks"
msgstr "一些小技巧"

#: ../docs/source/working_with_aiida/troubleshooting.rst:11
msgid "Increasing the debug level"
msgstr "增加调试输出层次"

#: ../docs/source/working_with_aiida/troubleshooting.rst:13
msgid ""
"By default, the logging level of AiiDA is minimal to avoid filling logfiles."
" Only warnings and errors are logged to the daemon log files, while info and"
" debug messages are discarded."
msgstr "默认情况下，AiiDA的日志级别是最小的，以避免塞满日志文件。只有警告和错误被记录到守护进程日志文件中，而信息和调试消息被丢弃。"

#: ../docs/source/working_with_aiida/troubleshooting.rst:17
msgid ""
"If you are experiencing a problem, you can change the default minimum "
"logging level of AiiDA messages::"
msgstr "如果遇到问题，可以更改AiiDA消息的默认最低日志记录级别::"

#: ../docs/source/working_with_aiida/troubleshooting.rst:22
msgid ""
"You might also be interested in circus log messages (the ``circus`` library "
"is the daemonizer that manages the daemon runners) but most often it is used"
" by AiiDA developers::"
msgstr ""
"您可能还对 ``circus`` 日志消息感兴趣( ``circus`` 库是管理守护进程运行器的后台进程)，但是通常只有AiiDA开发人员使用它::"

#: ../docs/source/working_with_aiida/troubleshooting.rst:27
msgid ""
"For each profile that runs a daemon, there will be two unique logfiles, one "
"for AiiDA log messages (named ``aiida-<profile_name>.log``) and one for the "
"circus logs (named ``circus-<profile_name>.log``). Those files can be found "
"in the ``~/.aiida/daemon/log`` folder."
msgstr ""
"对于每个运行守护进程的概要文件，将有两个惟一的日志文件，一个用于AiiDA日志消息(名为' ``aiida-<profile_name>.log`` "
")，另一个用于 circus日志(名为 ``circus-<profile_name>.log`` )。这些文件可以在 "
"``~/.aiida/daemon/log`` 文件夹找到。"

#: ../docs/source/working_with_aiida/troubleshooting.rst:31
msgid ""
"After rebooting the daemon (``verdi daemon restart``), the number of "
"messages logged will increase significantly and may help in understanding "
"the source of the problem."
msgstr "重启守护进程( ``verdi daemon restart`` )后，记录的消息数量将显著增加，这可能有助于理解问题的根源。"

#: ../docs/source/working_with_aiida/troubleshooting.rst:35
msgid ""
"In the command above, you can use a different level than ``DEBUG``. The list"
" of the levels and their order is the same of the `standard python logging "
"module <https://docs.python.org/3/library/logging.html#logging-levels>`_. In"
" addition to the standard logging levels, we define our custom ``REPORT`` "
"level, which, with a value of ``23``, sits between the standard ``INFO`` and"
" ``WARNING`` levels. The ``REPORT`` level is the default logging level as "
"this is what is used by messages from, among other things, the work chain "
"report.."
msgstr ""
"在上面的命令中，您可以使用与 ``DEBUG`` 不同的级别。级别列表及其顺序与 "
"`标准python日志模块<https://docs.python.org/3/library/logging.html#logging-"
"levels>`_ 相同。除了标准日志级别之外，我们还定义了自定义的 ``REPORT`` 级别，其值为 ``23`` ，位于标准 ``INFO`` 和"
" ``WARNING`` 级别之间。``REPORT`` 级别是默认的日志记录级别，因为这是用于报告工作链消息使用的日志记录级别。"

#: ../docs/source/working_with_aiida/troubleshooting.rst:43
msgid ""
"When the problem is solved, we suggest to bring back the default logging "
"level, using the two commands::"
msgstr "当问题解决后，我们建议使用以下两个命令恢复默认日志级别::"

#: ../docs/source/working_with_aiida/troubleshooting.rst:48
msgid "to avoid to fill the logfiles."
msgstr "以免塞爆日志文件。"

#: ../docs/source/working_with_aiida/troubleshooting.rst:50
msgid "The config options set for the current profile can be viewed using::"
msgstr "可以使用下面命令查看为当前配置文件设置的配置选项::"

#: ../docs/source/working_with_aiida/troubleshooting.rst:54
msgid "in the ``options`` row."
msgstr "在 ``option`` 行。"

#: ../docs/source/working_with_aiida/troubleshooting.rst:59
msgid "Tips to ease the life of the hard drive (for large databases)"
msgstr "简化硬盘驱动器使用寿命的技巧(适用于大型数据库)"

#: ../docs/source/working_with_aiida/troubleshooting.rst:61
msgid ""
"Those tips are useful when your database is very large, i.e. several "
"hundreds of thousands of nodes or more. With such large databases the hard "
"drive may be constantly working and the computer slowed down a lot. Below "
"are some solutions to take care of the most typical reasons."
msgstr ""
"当您的数据库非常大，即几十万个或更多节点时，这些技巧非常有用。有了这么大的数据库，硬盘驱动器可能会一直工作，计算机运行速度也会大大降低。下面是一些解决方案，可以解决这些典型问题的办法。"

#: ../docs/source/working_with_aiida/troubleshooting.rst:67
msgid "Repository backup"
msgstr "仓库备份"

#: ../docs/source/working_with_aiida/troubleshooting.rst:69
msgid ""
"The backup of the repository takes an extensively long time if it is done "
"through a standard rsync or backup software, since it contains as many "
"folders as the number of nodes (and each folder can contain many files!). A "
"solution is to use instead the incremental backup described in the "
":ref:`repository backup section<repository_backup>`."
msgstr ""
"如果通过标准的rsync或备份软件进行备份，那么存储库的备份将花费很长时间，因为它包含的文件夹与节点的数量一样多(每个文件夹可以包含许多文件!)解决方案是使用"
" :ref:`仓库备份小节<repository_backup>` 中描述的增量备份。"

#: ../docs/source/working_with_aiida/troubleshooting.rst:77
msgid "mlocate cron job"
msgstr "mlocate cron job"

#: ../docs/source/working_with_aiida/troubleshooting.rst:79
msgid ""
"Under typical Linux distributions, there is a cron job (called "
"``updatedb.mlocate``) running every day to update a database of files and "
"folders -- this is to be used by the ``locate`` command. This might become "
"problematic since the repository contains many folders and will be scanned "
"everyday. The net effect is a hard drive almost constantly working."
msgstr ""
"在典型的Linux发行版中，每天运行一个cron作业(称为 ``updatedb.mlocate`` )来更新文件和文件夹的数据库——这将由 "
"``locate`` 命令使用。这可能会有问题，因为存储库包含许多文件夹，并且每天都要进行扫描。净效应是硬盘几乎一直在工作。"

#: ../docs/source/working_with_aiida/troubleshooting.rst:86
msgid ""
"To avoid this issue, edit as root the file ``/etc/updatedb.conf`` and put in"
" ``PRUNEPATHS`` the name of the repository folder."
msgstr ""
"要避免这个问题，使用root权限编辑文件 ``/etc/updatedb.conf`` 并将仓库文件夹放置在 ``PRUNEPATHS`` 行。"

#: ../docs/source/working_with_aiida/visualising_graphs/visualising_graphs.rst:7
msgid "Visualizing Provenance Graphs"
msgstr ""

#: ../docs/source/working_with_aiida/visualising_graphs/visualising_graphs.rst:11
msgid ""
"This tutorial can be downloaded and run as a Jupyter Notebook: "
":download:`visualising_graphs.ipynb`"
msgstr ""

#: ../docs/source/working_with_aiida/visualising_graphs/visualising_graphs.rst:14
msgid ""
"The provenance graph of a database can be visually inspected, *via* "
"`graphviz <https://www.graphviz.org/>`__, using both the python API and "
"command-line interface."
msgstr ""

#: ../docs/source/working_with_aiida/visualising_graphs/visualising_graphs.rst:20
msgid "``verdi graph generate -h``"
msgstr ""

#: ../docs/source/working_with_aiida/visualising_graphs/visualising_graphs.rst:22
msgid "We first load the database and required modules:"
msgstr ""

#: ../docs/source/working_with_aiida/visualising_graphs/visualising_graphs.rst:34
msgid ""
"The example provenance graph, used in this tutorial, can then be imported "
"into the database:"
msgstr ""

#: ../docs/source/working_with_aiida/visualising_graphs/visualising_graphs.rst:47
msgid ""
"The :py:class:`~aiida.tools.visualization.graph.Graph` class is used to "
"store visual representations of the nodes and edges, which can be added "
"separately or cumulatively by one of the graph traversal methods. The "
":py:attr:`~aiida.tools.visualization.graph.Graph.graphviz` attribute returns"
" a `graphviz.Digraph <https://graphviz.readthedocs.io/en/stable/>`__ "
"instance, which will auto-magically render the graph in the notebook, or can"
" be used to save the graph to file."
msgstr ""

#: ../docs/source/working_with_aiida/visualising_graphs/visualising_graphs.rst:90
msgid ""
"The :py:class:`~aiida.tools.visualization.graph.Graph` can also be "
"initialized with global style attributes, as outlined in the `graphviz "
"attributes table <https://www.graphviz.org/doc/info/attrs.html>`__."
msgstr ""

#: ../docs/source/working_with_aiida/visualising_graphs/visualising_graphs.rst:108
msgid ""
"Additionally functions can be parsed to the "
":py:class:`~aiida.tools.visualization.graph.Graph` initializer, to specify "
"exactly how each node will be represented. For example, the "
":py:func:`~aiida.tools.visualization.graph.pstate_node_styles` function "
"colors process nodes by their process state."
msgstr ""

#: ../docs/source/working_with_aiida/visualising_graphs/visualising_graphs.rst:131
msgid ""
"Edges can be annotated by one or both of their edge label and link type."
msgstr ""

#: ../docs/source/working_with_aiida/visualising_graphs/visualising_graphs.rst:148
msgid ""
"The :meth:`~aiida.tools.visualization.graph.Graph.recurse_descendants` and "
":meth:`~aiida.tools.visualization.graph.Graph.recurse_ancestors` methods can"
" be used to construct a full provenance graph."
msgstr ""

#: ../docs/source/working_with_aiida/visualising_graphs/visualising_graphs.rst:166
msgid ""
"The link types can also be filtered, to view only the ‘data’ or ‘logical’ "
"provenance."
msgstr ""
