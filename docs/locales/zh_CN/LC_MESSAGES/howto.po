# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2020, ECOLE POLYTECHNIQUE FEDERALE DE LAUSANNE (Theory and Simulation of Materials (THEOS) and National Centre for Computational Design and Discovery of Novel Materials (NCCR MARVEL)), Switzerland and ROBERT BOSCH LLC, USA. All rights reserved
# This file is distributed under the same license as the AiiDA package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: AiiDA 1.3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-07-01 16:11+0000\n"
"PO-Revision-Date: 2020-07-01 16:11+0000\n"
"Language-Team: Chinese (China) (https://www.transifex.com/aiidateam/teams/98967/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../docs/source/howto/codes.rst:5
msgid "How to run external codes"
msgstr ""

#: ../docs/source/howto/codes.rst:7
msgid ""
"To run an external code with AiiDA, you will need to use an appropriate "
":ref:`calculation plugin <topics:plugins>`. This plugin must contain the "
"instructions necessary for the engine to be able to:"
msgstr ""

#: ../docs/source/howto/codes.rst:10
msgid ""
"Prepare the required input files inside of the folder in which the code will"
" be executed"
msgstr ""

#: ../docs/source/howto/codes.rst:11
msgid "Run the code with the correct set of command line parameters"
msgstr ""

#: ../docs/source/howto/codes.rst:13
msgid ""
"The following subsections will not only take you through the process of "
":ref:`creating the calculation plugin<how-to:codes:interfacing>` and then "
"using these to actually :ref:`run the code<how-to:codes:run>`. It will also "
"show examples on how to implement tools that are commonly coupled with the "
"running of a calculation, such as :ref:`the parsing of outputs<how-"
"to:codes:parsing>`."
msgstr ""

#: ../docs/source/howto/codes.rst:16 ../docs/source/howto/codes.rst:216
#: ../docs/source/howto/codes.rst:316 ../docs/source/howto/data.rst:938
#: ../docs/source/howto/installation.rst:221
#: ../docs/source/howto/plugins.rst:10 ../docs/source/howto/workflows.rst:297
msgid "Todo"
msgstr ""

#: ../docs/source/howto/codes.rst:18
msgid ""
"Add to preceding sentence: :ref:`the communication with external machines"
"<how-to:codes:transport>` and the interaction with its :ref:`scheduling "
"software<how-to:codes:scheduler>`."
msgstr ""

#: ../docs/source/howto/codes.rst:20
msgid "Some general guidelines to keep in mind are:"
msgstr ""

#: ../docs/source/howto/codes.rst:0
msgid "**Check existing resources.**"
msgstr ""

#: ../docs/source/howto/codes.rst:0
msgid ""
"Before starting to write a plugin, check on the `aiida plugin registry "
"<https://aiidateam.github.io/aiida-registry/>`_ whether a plugin for your "
"code is already available. If it is, there is maybe no need to write your "
"own, and you can skip straight ahead to :ref:`running the code<how-"
"to:codes:run>`."
msgstr ""

#: ../docs/source/howto/codes.rst:0
msgid "**Start simple.**"
msgstr ""

#: ../docs/source/howto/codes.rst:0
msgid ""
"Make use of existing classes like "
":py:class:`~aiida.orm.nodes.data.dict.Dict`, "
":py:class:`~aiida.orm.nodes.data.singlefile.SinglefileData`, ... Write only "
"what is necessary to pass information from and to AiiDA."
msgstr ""

#: ../docs/source/howto/codes.rst:0
msgid "**Don't break data provenance.**"
msgstr ""

#: ../docs/source/howto/codes.rst:0
msgid "Store *at least* what is needed for full reproducibility."
msgstr ""

#: ../docs/source/howto/codes.rst:0
msgid "**Expose the full functionality.**"
msgstr ""

#: ../docs/source/howto/codes.rst:0
msgid ""
"Standardization is good but don't artificially limit the power of a code you"
" are wrapping - or your users will get frustrated. If the code can do it, "
"there should be *some* way to do it with your plugin."
msgstr ""

#: ../docs/source/howto/codes.rst:0
msgid ""
"**Don't rely on AiiDA internals.** Functionality at deeper nesting levels is"
" not considered part of the public API and may change between minor AiiDA "
"releases, breaking your plugin."
msgstr ""

#: ../docs/source/howto/codes.rst:0
msgid "**Parse what you want to query for.**"
msgstr ""

#: ../docs/source/howto/codes.rst:0
msgid "Make a list of which information to:"
msgstr ""

#: ../docs/source/howto/codes.rst:38
msgid ""
"parse into the database for querying "
"(:py:class:`~aiida.orm.nodes.data.dict.Dict`, ...)"
msgstr ""

#: ../docs/source/howto/codes.rst:39
msgid ""
"store in the file repository for safe-keeping "
"(:py:class:`~aiida.orm.nodes.data.singlefile.SinglefileData`, ...)"
msgstr ""

#: ../docs/source/howto/codes.rst:40
msgid ""
"leave on the computer where the calculation ran "
"(:py:class:`~aiida.orm.nodes.data.remote.RemoteData`, ...)"
msgstr ""

#: ../docs/source/howto/codes.rst:42
msgid ""
"To demonstrate how to create a plugin for an external code, we will use the "
"trivial example of using the `bash` shell (``/bin/bash``) to sum two numbers"
" by running the command: ``echo $(( numx + numy ))``. Here, the `bash` "
"binary will be effectively acting as our |Code| executable, the input "
"(``aiida.in``) will then be a file containing the command with the numbers "
"provided by the user replaced, and the output (``aiida.out``) will be caught"
" through the standard output. The final recipe to run this code will then "
"be:"
msgstr ""

#: ../docs/source/howto/codes.rst:53
msgid "Interfacing external codes"
msgstr ""

#: ../docs/source/howto/codes.rst:55
msgid ""
"To provide AiiDA with the set of instructions, required to run a code, one "
"should subclass the |CalcJob| class and implement the following two key "
"methods:"
msgstr ""

#: ../docs/source/howto/codes.rst:57
msgid ":py:meth:`~aiida.engine.processes.calcjobs.calcjob.CalcJob.define`"
msgstr ""

#: ../docs/source/howto/codes.rst:58
msgid ""
":py:meth:`~aiida.engine.processes.calcjobs.calcjob.CalcJob.prepare_for_submission`"
msgstr ""

#: ../docs/source/howto/codes.rst:60
msgid "We will now show how each of these can be implemented."
msgstr ""

#: ../docs/source/howto/codes.rst:63
msgid "Defining the specifications"
msgstr ""

#: ../docs/source/howto/codes.rst:65
msgid ""
"The |define| method is where one specifies the different inputs that the "
"caller of the |CalcJob| will have to provide in order to run the code, as "
"well as the outputs that will be produced (exit codes will be "
":ref:`discussed later<how-to:codes:parsing:errors>`). This is done through "
"an instance of "
":py:class:`~aiida.engine.processes.process_spec.CalcJobProcessSpec`, which, "
"as can be seen in the snippet below, is passed as the |spec| argument to the"
" |define| method. For the code that adds up two numbers, we will need to "
"define those numbers as inputs (let's call them ``x`` and ``y`` to label "
"them) and the result as an output (``sum``). The snippet below shows one "
"potential implementation, as it is included in ``aiida-core``:"
msgstr ""

#: ../docs/source/howto/codes.rst:75
msgid ""
"The first line of the |define| implementation calls the method of the parent"
" class |CalcJob|. This step is crucial as it will define `inputs` and "
"`outputs` that are common to all |CalcJob|'s and failing to do so will leave"
" the implementation broken. After the super call, we modify the default "
"values for some of these inputs that are defined by the base class. Inputs "
"that have already been defined can be accessed from the |spec| through the "
":py:attr:`~plumpy.process_spec.ProcessSpec.inputs` attribute, which behaves "
"like a normal dictionary."
msgstr ""

#: ../docs/source/howto/codes.rst:80
msgid ""
"After modifying the existing inputs, we define the inputs that are specific "
"to this code. For this purpose we use the "
":py:meth:`~plumpy.process_spec.ProcessSpec.input` method, which does not "
"modify the existing `inputs`, accessed through "
":py:attr:`~plumpy.process_spec.ProcessSpec.inputs`, but defines new ones "
"that will be specific to this implementation. You can also see that the "
"definitions do not involve the assignment of a value, but only the passing "
"of parameters to the method: a label to identify it, their valid types (in "
"this case nodes of type |Int|) and a description. Finally, note that there "
"is no return statement: this method does not need to return anything, since "
"all modifications are made directly into the received |spec| object. You can"
" check the Topics section about :ref:`defining processes "
"<topics:processes:usage:defining>` if you want more information about "
"setting up your `inputs` and `outputs` (covering validation, dynamic number "
"of inputs, etc.)."
msgstr ""

#: ../docs/source/howto/codes.rst:87
msgid "Preparing for submission"
msgstr ""

#: ../docs/source/howto/codes.rst:89
msgid ""
"The "
":py:meth:`~aiida.engine.processes.calcjobs.calcjob.CalcJob.prepare_for_submission`"
" method is used for two purposes. Firstly, it should create the input files,"
" based on the input nodes passed to the calculation, in the format that the "
"external code will expect. Secondly, the method should create and return a "
":py:class:`~aiida.common.datastructures.CalcInfo` instance that contains "
"various instructions for the engine on how the code should be run. An "
"example implementation, as shipped with ``aiida-core`` can be seen in the "
"following snippet:"
msgstr ""

#: ../docs/source/howto/codes.rst:99
msgid ""
"Note that, unlike the |define| method, this one is implemented from scratch "
"and so there is no super call. The external code that we are running with "
"this |CalcJob| is ``bash`` and so to sum the input numbers ``x`` and ``y``, "
"we should write a bash input file that performs the summation, for example "
"``echo $((x + y))``, where one of course has to replace ``x`` and ``y`` with"
" the actual numbers. You can see how the snippet uses the ``folder`` "
"argument, which is a |Folder| instance that represents a temporary folder on"
" disk, to write the input file with the bash summation. It uses Python's "
"string interpolation to replace the ``x`` and ``y`` placeholders with the "
"actual values that were passed as input, ``self.inputs.x`` and "
"``self.inputs.y``, respectively."
msgstr ""

#: ../docs/source/howto/codes.rst:106
msgid ""
"When the |prepare_for_submission| is called, the inputs that have been "
"passed will have been validated against the specification defined in the "
"|define| method and they can be accessed through the "
":py:attr:`~plumpy.processes.Process.inputs` attribute. This means that if a "
"particular input is required according to the spec, you can safely assume "
"that it will have been set and you do not need to check explicitly for its "
"existence."
msgstr ""

#: ../docs/source/howto/codes.rst:109
msgid ""
"All the files that are copied into the sandbox ``folder`` will be "
"automatically copied by the engine to the scratch directory where the code "
"will be run. In this case we only create one input file, but you can create "
"as many as you need, including subfolders if required."
msgstr ""

#: ../docs/source/howto/codes.rst:114
msgid ""
"The input files written to the ``folder`` sandbox, will also be permanently "
"stored in the file repository of the calculation node for the purpose of "
"additional provenance guarantees. See the section on :ref:`excluding files "
"from "
"provenance<topics:calculations:usage:calcjobs:file_lists_provenance_exclude>`"
" to learn how to prevent certain input files from being stored explicitly."
msgstr ""

#: ../docs/source/howto/codes.rst:117
msgid ""
"After having written the necessary input files, one should create the "
"|CodeInfo| object, which can be used to instruct the engine on how to run "
"the code. We assign the ``code_uuid`` attribute to the ``uuid`` of the "
"``Code`` node that was passed as an input, which can be retrieved through "
"``self.inputs.code``. This is necessary such that the engine can retrieve "
"the required information from the |Code| node, such as the full path of the "
"executable. Note that we didn't explicitly define this |Code| input in the "
"|define| method, but this is one of the inputs defined in the base |CalcJob|"
" class:"
msgstr ""

#: ../docs/source/howto/codes.rst:126
msgid ""
"After defining the UUID of the code node that the engine should use, we "
"define the filenames where the stdin and stdout file descriptors should be "
"redirected to. These values are taken from the inputs, which are part of the"
" ``metadata.options`` namespace, for some of whose inputs we overrode the "
"default values in the specification definition in the previous section. Note"
" that instead of retrieving them through "
"``self.inputs.metadata['options']['input_filename']``, one can use the "
"shortcut ``self.options.input_filename`` as we do here. Based on this "
"definition of the |CodeInfo|, the engine will create a run script that looks"
" like the following:"
msgstr ""

#: ../docs/source/howto/codes.rst:137
msgid ""
"The |CodeInfo| should be attached to the ``codes_info`` attribute of a "
"|CalcInfo| object. A calculation can potentially run more than one code, so "
"the |CodeInfo| object should be assigned as a list. Finally, we define the "
"``retrieve_list`` attribute, which is a list of filenames that the engine "
"should retrieve from the running directory once the calculation job has "
"finished. The engine will store these files in a "
":py:class:`~aiida.orm.nodes.data.folder.FolderData` node that will be "
"attached as an output node to the calculation with the label ``retrieved``. "
"There are :ref:`other file lists "
"available<topics:calculations:usage:calcjobs:file_lists>` that allow you to "
"easily customize how to move files to and from the remote working directory "
"in order to prevent the creation of unnecessary copies."
msgstr ""

#: ../docs/source/howto/codes.rst:143
msgid ""
"This was a minimal example of how to implement the |CalcJob| class to "
"interface AiiDA with an external code. For more detailed information and "
"advanced functionality on the |CalcJob| class, refer to the Topics section "
"on :ref:`defining calculations <topics:calculations:usage>`."
msgstr ""

#: ../docs/source/howto/codes.rst:149
msgid "Parsing the outputs"
msgstr ""

#: ../docs/source/howto/codes.rst:151
msgid ""
"The parsing of the output files generated by a |CalcJob| is optional and can"
" be used to store (part of) their information as AiiDA nodes, which makes "
"the data queryable and therefore easier to access and analyze. To enable "
"|CalcJob| output file parsing, one should subclass the |Parser| class and "
"implement the :py:meth:`~aiida.parsers.parser.Parser.parse` method. The "
"following is an example implementation, as shipped with ``aiida-core``, to "
"parse the outputs of the "
":py:class:`~aiida.calculations.arithmetic.add.ArithmeticAddCalculation` "
"discussed in the previous section:"
msgstr ""

#: ../docs/source/howto/codes.rst:159
msgid ""
"The output files generated by the completed calculation can be accessed from"
" the ``retrieved`` output folder, which can be accessed through the "
":py:attr:`~aiida.parsers.parser.Parser.retrieved` property. It is an "
"instance of :py:class:`~aiida.orm.nodes.data.folder.FolderData` and so "
"provides, among other things, the :py:meth:`~aiida.orm.nodes.node.Node.open`"
" method to open any file it contains. In this example implementation, we use"
" it to open the output file, whose filename we get through the "
":py:meth:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.get_option`"
" method of the corresponding calculation node, which we obtain through the "
":py:attr:`~aiida.parsers.parser.Parser.node` property of the ``Parser``. We "
"read the content of the file and cast it to an integer, which should contain"
" the sum that was produced by the ``bash`` code. We catch any exceptions "
"that might be thrown, for example when the file cannot be read, or if its "
"content cannot be interpreted as an integer, and return an exit code. This "
"method of dealing with potential errors of external codes is discussed in "
"the section on :ref:`handling parsing errors<how-to:codes:parsing:errors>`."
msgstr ""

#: ../docs/source/howto/codes.rst:166
msgid ""
"To attach the parsed sum as an output, use the "
":py:meth:`~aiida.parsers.parser.Parser.out` method. The first argument is "
"the name of the output, which will be used as the label for the link that "
"connects the calculation and data node, and the second is the node that "
"should be recorded as an output. Note that the type of the output should "
"match the type that is specified by the process specification of the "
"corresponding |CalcJob|. If any of the registered outputs do not match the "
"specification, the calculation will be marked as failed."
msgstr ""

#: ../docs/source/howto/codes.rst:171
msgid ""
"To trigger the parsing using a |Parser| after a |CalcJob| has finished (such"
" as the one described in the :ref:`previous section <how-"
"to:codes:interfacing>`) it should be defined in the "
"``metadata.options.parser_name`` input. If a particular parser should always"
" be used by default for a given |CalcJob|, it can be defined as the default "
"in the |define| method, for example:"
msgstr ""

#: ../docs/source/howto/codes.rst:181
msgid ""
"The default can be overridden through the inputs when launching the "
"calculation job. Note, that one should not pass the |Parser| class itself, "
"but rather the corresponding entry point name under which it is registered "
"as a plugin. In other words, in order to use a |Parser| you will need to "
"register it as explained in the how-to section on :ref:`registering plugins "
"<how-to:plugins>`."
msgstr ""

#: ../docs/source/howto/codes.rst:189
msgid "Handling parsing errors"
msgstr ""

#: ../docs/source/howto/codes.rst:191
msgid ""
"So far we have not spent too much attention on dealing with potential errors"
" that might arise when running external codes. However, for many codes, "
"there are lots of ways in which it can fail to execute nominally and "
"produced the correct output. A |Parser| is the solution to detect these "
"errors and report them to the caller through :ref:`exit "
"codes<topics:processes:concepts:exit_codes>`. These exit codes can be "
"defined through the |spec| of the |CalcJob| that is used for that code, just"
" as the inputs and output are defined. For example, the "
":py:class:`~aiida.calculations.arithmetic.add.ArithmeticAddCalculation` "
"introduced in :ref:`\"Interfacing external codes\"<how-"
"to:codes:interfacing>`, defines the following exit codes:"
msgstr ""

#: ../docs/source/howto/codes.rst:203
msgid ""
"Each ``exit_code`` defines an exit status (a positive integer), a label that"
" can be used to reference the code in the |parse| method (through the "
"``self.exit_codes`` property, as seen below), and a message that provides a "
"more detailed description of the problem. To use these in the |parse| "
"method, you just need to return the corresponding exit code which instructs "
"the engine to store it on the node of the calculation that is being parsed. "
"The snippet of the previous section on :ref:`parsing the outputs<how-"
"to:codes:parsing>` already showed two problems that are detected and are "
"communicated by returning the corresponding the exit code:"
msgstr ""

#: ../docs/source/howto/codes.rst:212
msgid ""
"If the ``read()`` call fails to read the output file, for example because "
"the calculation failed to run entirely and did not write anything, it will "
"raise an ``OSError``, which the parser catches and returns the "
"``ERROR_READING_OUTPUT_FILE`` exit code. Alternatively, if the file *could* "
"be read, but it's content cannot be interpreted as an integer, the parser "
"returns ``ERROR_INVALID_OUTPUT``. The Topics section on :ref:`defining "
"processes <topics:processes:usage:defining>` provides additional information"
" on how to use exit codes."
msgstr ""

#: ../docs/source/howto/codes.rst:220
msgid "title: Configuring remote computers"
msgstr ""

#: ../docs/source/howto/codes.rst:222
msgid "`#4123`_"
msgstr ""

#: ../docs/source/howto/codes.rst:227
msgid "Running external codes"
msgstr ""

#: ../docs/source/howto/codes.rst:229
msgid ""
"To run an external code with AiiDA, you will need to use an appropriate "
":ref:`calculation plugin <topics:plugins>` that knows how to transform the "
"input nodes into the input files that the code expects, copy everything in "
"the code's machine, run the calculation and retrieve the results. You can "
"check the `plugin registry <https://aiidateam.github.io/aiida-registry/>`_ "
"to see if a plugin already exists for the code that you would like to run. "
"If that is not the case, you can :ref:`develop your own <how-"
"to:codes:interfacing>`. After you have installed the plugin, you can start "
"running the code through AiiDA. To check which calculation plugins you have "
"currently installed, run:"
msgstr ""

#: ../docs/source/howto/codes.rst:239
msgid ""
"As an example, we will show how to use the ``arithmetic.add`` plugin, which "
"is a pre-installed plugin that uses the `bash shell "
"<https://www.gnu.org/software/bash/>`_ to sum two integers. You can access "
"it with the ``CalculationFactory``:"
msgstr ""

#: ../docs/source/howto/codes.rst:247
msgid ""
"Next, we provide the inputs for the code when running the calculation. Use "
"``verdi plugin`` to determine what inputs a specific plugin expects:"
msgstr ""

#: ../docs/source/howto/codes.rst:260
msgid ""
"You will see that 3 inputs nodes are required: two containing the values to "
"add up (``x``, ``y``) and one containing information about the specific code"
" to execute (``code``). If you already have these nodes in your database, "
"you can get them by :ref:`querying for them <how-to:data:find>` or using "
"``orm.load_node(<PK>)``. Otherwise, you will need to create them as shown "
"below (note that you `will` need to already have the ``localhost`` computer "
"configured, as explained in the :ref:`previous how-to<how-"
"to:codes:computers>`):"
msgstr ""

#: ../docs/source/howto/codes.rst:271
msgid ""
"To provide these as inputs to the calculations, we will now use the "
"``builder`` object that we can get from the class:"
msgstr ""

#: ../docs/source/howto/codes.rst:280
msgid ""
"Now everything is in place and ready to perform the calculation, which can "
"be done in two different ways. The first one is blocking and will return a "
"dictionary containing all the output nodes (keyed after their label, so in "
"this case these should be: \"remote_folder\", \"retrieved\" and \"sum\") "
"that you can safely inspect and work with:"
msgstr ""

#: ../docs/source/howto/codes.rst:289
msgid ""
"The second one is non blocking, as you will be submitting it to the daemon "
"and control is immediately returned to the interpreter. The return value in "
"this case is the calculation node that is stored in the database."
msgstr ""

#: ../docs/source/howto/codes.rst:297
msgid ""
"Note that, although you have access to the node, the underlying calculation "
"`process` is not guaranteed to have finished when you get back control in "
"the interpreter. You can use the verdi command line interface to "
":ref:`monitor<topics:processes:usage:monitoring>` these processes:"
msgstr ""

#: ../docs/source/howto/codes.rst:305
msgid "Performing a dry-run"
msgstr ""

#: ../docs/source/howto/codes.rst:307
msgid ""
"Additionally, you might want to check and verify your inputs before actually"
" running or submitting a calculation. You can do so by specifying to use a "
"``dry_run``, which will create all the input files in a local directory "
"(``submit_test/[date]-0000[x]``) so you can inspect them before actually "
"launching the calculation:"
msgstr ""

#: ../docs/source/howto/codes.rst:320
msgid "title: Using caching to save computational resources"
msgstr ""

#: ../docs/source/howto/codes.rst:322
msgid "`#3988`_"
msgstr ""

#: ../docs/source/howto/codes.rst:327
msgid "title: Adding support for a custom scheduler"
msgstr ""

#: ../docs/source/howto/codes.rst:329
msgid "`#3989`_"
msgstr ""

#: ../docs/source/howto/codes.rst:334
msgid "title: Adding support for a custom transport"
msgstr ""

#: ../docs/source/howto/codes.rst:336
msgid "`#3990`_"
msgstr ""

#: ../docs/source/howto/data.rst:5
msgid "How to work with data"
msgstr ""

#: ../docs/source/howto/data.rst:11
msgid "Importing data"
msgstr ""

#: ../docs/source/howto/data.rst:13
msgid ""
"AiiDA allows users to export data from their database into an export archive"
" file, which can be imported in any other AiiDA database. If you have an "
"AiiDA export archive that you would like to import, you can use the ``verdi "
"import`` command (see :ref:`the reference section<reference:command-line"
":verdi-import>` for details)."
msgstr ""

#: ../docs/source/howto/data.rst:16
msgid ""
"More detailed information on exporting and importing data from AiiDA "
"databases can be found in :ref:`\"How to share data\"<how-to:data:share>`."
msgstr ""

#: ../docs/source/howto/data.rst:18
msgid ""
"If, instead, you have existing data that are not yet part of an AiiDA export"
" archive, such as files, folders, tabular data, arrays or any other kind of "
"data, this how-to guide will show you how to import them into AiiDA."
msgstr ""

#: ../docs/source/howto/data.rst:20
msgid ""
"To store any piece of data in AiiDA, it needs to be wrapped in a "
":py:class:`~aiida.orm.nodes.data.Data` node, such that it can be represented"
" in the :ref:`provenance graph <topics:provenance>`. There are different "
"varieties, or subclasses, of this ``Data`` class that are suited for "
"different types of data. AiiDA ships with a number of built-in data types. "
"You can list these using the :ref:`verdi plugin<reference:command-line"
":verdi-plugin>` command. Executing ``verdi plugin list aiida.data`` should "
"display something like::"
msgstr ""

#: ../docs/source/howto/data.rst:38
msgid ""
"As the output suggests, you can get more information about each type by "
"appending the name to the command, for example, ``verdi plugin list "
"aiida.data singlefile``::"
msgstr ""

#: ../docs/source/howto/data.rst:56
msgid ""
"As you can see, the ``singlefile`` type corresponds to the "
":py:class:`~aiida.orm.nodes.data.singlefile.SinglefileData` class and is "
"designed to wrap a single file that is stored on your local filesystem. If "
"you have such a file that you would like to store in AiiDA, you can use the "
"``verdi shell`` to create it:"
msgstr ""

#: ../docs/source/howto/data.rst:65
msgid ""
"The first step is to load the class that corresponds to the data type, which"
" you do by passing the name (listed by ``verdi plugin list aiida.data``) to "
"the :py:class:`~aiida.plugins.factories.DataFactory`. Then we just construct"
" an instance of that class, passing the file of interest as an argument."
msgstr ""

#: ../docs/source/howto/data.rst:68
msgid ""
"The exact manner of constructing an instance of any particular data type is "
"type dependent. Use the ``verdi plugin list aiida.data <ENTRY_POINT>`` "
"command to get more information for any specific type."
msgstr ""

#: ../docs/source/howto/data.rst:71
msgid ""
"Note that after construction, you will get an *unstored* node. This means "
"that at this point your data is not yet stored in the database and you can "
"first inspect it and optionally modify it. If you are happy with the "
"results, you can store the new data permanently by calling the "
":py:meth:`~aiida.orm.nodes.node.Node.store` method. Every node is assigned a"
" Universal Unique Identifer (UUID) upon creation and once stored it is also "
"assigned a primary key (PK), which can be retrieved through the "
"``node.uuid`` and ``node.pk`` properties, respectively. You can use these "
"identifiers to reference and or retrieve a node. Ways to find and retrieve "
"data that have previously been imported are described in section :ref:`\"How"
" to find data\"<how-to:data:find>`."
msgstr ""

#: ../docs/source/howto/data.rst:78
msgid ""
"If none of the currently available data types, as listed by ``verdi plugin "
"list``, seem to fit your needs, you can also create your own custom type. "
"For details refer to the next section :ref:`\"How to add support for custom "
"data types\"<how-to:data:plugin>`."
msgstr ""

#: ../docs/source/howto/data.rst:85
msgid "Adding support for custom data types"
msgstr ""

#: ../docs/source/howto/data.rst:87
msgid ""
"The nodes in the :ref:`provenance graph<topics:provenance>` that are the "
"inputs and outputs of processes are referred to as `data` and are "
"represented by :class:`~aiida.orm.nodes.data.data.Data` nodes. Since data "
"can come in all shapes and forms, the "
":class:`~aiida.orm.nodes.data.data.Data` class can be sub classed. AiiDA "
"ships with some basic data types such as the "
":class:`~aiida.orm.nodes.data.int.Int` which represents a simple integer and"
" the :class:`~aiida.orm.nodes.data.dict.Dict`, representing a dictionary of "
"key-value pairs. There are also more complex data types such as the "
":class:`~aiida.orm.nodes.data.array.array.ArrayData` which can store "
"multidimensional arrays of numbers. These basic data types serve most needs "
"for the majority of applications, but more specific solutions may be useful "
"or even necessary. In the next sections, we will explain :ref:`how a new "
"data type can be created<how-to:data:plugin:create>` and what "
":ref:`guidelines<how-to:data:plugin:design-guidelines>` should ideally be "
"observed during the design process."
msgstr ""

#: ../docs/source/howto/data.rst:98
msgid "Creating a data plugin"
msgstr ""

#: ../docs/source/howto/data.rst:100
msgid ""
"Creating a new data type is as simple as creating a new sub class of the "
"base :class:`~aiida.orm.nodes.data.data.Data` class."
msgstr ""

#: ../docs/source/howto/data.rst:109
msgid ""
"At this point, our new data type does nothing special. Typically, one "
"creates a new data type to represent a specific type of data. For the "
"purposes of this example, let's assume that the goal of our ``NewData`` type"
" is to store a single numerical value. To allow one to construct a new "
"``NewData`` data node with the desired ``value``, for example:"
msgstr ""

#: ../docs/source/howto/data.rst:118
msgid ""
"we need to allow passing that value to the constructor of the node class. "
"Therefore, we have to override the constructor "
":meth:`~aiida.orm.nodes.node.Node.__init__`:"
msgstr ""

#: ../docs/source/howto/data.rst:135
msgid ""
"For the class to function properly, the signature of the constructor "
"**cannot be changed** and the constructor of the parent class **has to be "
"called**."
msgstr ""

#: ../docs/source/howto/data.rst:137
msgid ""
"Before calling the constructor of the base class, we have to remove the "
"``value`` keyword from the keyword arguments ``kwargs``, because the base "
"class will not expect it and will raise an exception if left in the keyword "
"arguments. The final step is to actually *store* the value that is passed by"
" the caller of the constructor. A new node has two locations to permanently "
"store any of its properties:"
msgstr ""

#: ../docs/source/howto/data.rst:141
msgid "the database"
msgstr ""

#: ../docs/source/howto/data.rst:142
msgid "the file repository"
msgstr ""

#: ../docs/source/howto/data.rst:144
msgid ""
"The section on :ref:`design guidelines<how-to:data:plugin:design-"
"guidelines>` will go into more detail what the advantages and disadvantages "
"of each option are and when to use which. For now, since we are storing only"
" a single value, the easiest and best option is to use the database. Each "
"node has *attributes* that can store any key-value pair, as long as the "
"value is JSON serializable. By adding the value to the node's attributes, "
"they will be queryable in the database once an instance of the ``NewData`` "
"node is stored."
msgstr ""

#: ../docs/source/howto/data.rst:155
msgid ""
"After storing the node instance in the database, its attributes are frozen, "
"and ``node.set_attribute('value', 7)`` will fail. By storing the ``value`` "
"in the attributes of the node instance, we ensure that that ``value`` can be"
" retrieved even when the node is reloaded at a later point in time."
msgstr ""

#: ../docs/source/howto/data.rst:158
msgid ""
"Besides making sure that the content of a data node is stored in the "
"database or file repository, the data type class can also provide useful "
"methods for users to retrieve that data. For example, with the current state"
" of the ``NewData`` class, in order to retrieve the ``value`` of a stored "
"``NewData`` node, one needs to do:"
msgstr ""

#: ../docs/source/howto/data.rst:166
msgid ""
"In other words, the user of the ``NewData`` class needs to know that the "
"``value`` is stored as an attribute with the name 'value'. This is not easy "
"to remember and therefore not very user-friendly. Since the ``NewData`` type"
" is a class, we can give it useful methods. Let's introduce one that will "
"return the value that was stored for it:"
msgstr ""

#: ../docs/source/howto/data.rst:185
msgid ""
"The addition of the instance property ``value`` makes retrieving the value "
"of a ``NewData`` node a lot easier:"
msgstr ""

#: ../docs/source/howto/data.rst:192
msgid ""
"As said before, in addition to their attributes, data types can also store "
"their properties in the file repository. Here is an example for a custom "
"data type that needs to wrap a single text file:"
msgstr ""

#: ../docs/source/howto/data.rst:223
msgid "To create a new instance of this data type and get its content:"
msgstr ""

#: ../docs/source/howto/data.rst:230
msgid ""
"This example is a simplified version of the "
":class:`~aiida.orm.nodes.data.singlefile.SinglefileData` data class that "
"ships with ``aiida-core``. If this happens to be your use case (or very "
"close to it), it is of course better to use that class, or you can sub class"
" it and adapt it where needed."
msgstr ""

#: ../docs/source/howto/data.rst:233
msgid ""
"The just presented examples for new data types are of course trivial, but "
"the concept is always the same and can easily be extended to more complex "
"custom data types. The following section will provide useful guidelines on "
"how to optimally design new data types."
msgstr ""

#: ../docs/source/howto/data.rst:240
msgid "Database or repository?"
msgstr ""

#: ../docs/source/howto/data.rst:242
msgid ""
"When deciding where to store a property of a data type, one has the option "
"to choose between the database and the file repository. All node properties "
"that are stored in the database (such as the attributes), are directly "
"searchable as part of a database query, whereas data stored in the file "
"repository cannot be queried for. What this means is that, for example, it "
"is possible to search for all nodes where a particular database-stored "
"integer attribute falls into a certain value range, but the same value "
"stored in a file within the file repository would not be directly searchable"
" in this way. However, storing large amounts of data within the database "
"comes at the cost of slowing down database queries. Therefore, big data "
"(think large files), whose content does not necessarily need to be queried "
"for, is better stored in the file repository. A data type may safely use "
"both the database and file repository in parallel for individual properties."
" Properties stored in the database are stored as *attributes* of the node. "
"The node class has various methods to set these attributes, such as "
":py:meth:`~aiida.orm.nodes.node.Node.set_attribute` and "
":py:meth:`~aiida.orm.nodes.node.Node.set_attribute_many`."
msgstr ""

#: ../docs/source/howto/data.rst:254
msgid "Finding and querying for data"
msgstr ""

#: ../docs/source/howto/data.rst:256
msgid ""
"Once you have successfully completed a series of workflows for your project,"
" or have imported a dataset you are interested in, you want to quickly find "
"the data that is relevant for your analysis. The data in an AiiDA database "
"is stored as a graph of connected entities, which can be easily *queried* "
"with the :class:`~aiida.orm.querybuilder.QueryBuilder` class."
msgstr ""

#: ../docs/source/howto/data.rst:259
msgid ""
"The :class:`~aiida.orm.querybuilder.QueryBuilder` lets you query your AiiDA "
"database independently of the backend used under the hood. Before starting "
"to write a query, it helps to:"
msgstr ""

#: ../docs/source/howto/data.rst:262
msgid ""
"Know what you want to query for. In the language of databases, you need to "
"tell the backend what *entity* you are looking for and optionally which of "
"its properties you want to *project*. For example, you might be interested "
"in the label of a calculation and the PK's of all its outputs."
msgstr ""

#: ../docs/source/howto/data.rst:265
msgid ""
"Know the relationships between entities you are interested in. Nodes of an "
"AiiDA graph (vertices) are connected with links (edges). A node can for "
"example be either the input or output of another node, but also an ancestor "
"or a descendant."
msgstr ""

#: ../docs/source/howto/data.rst:268
msgid "Know how you want to filter the results of your query."
msgstr ""

#: ../docs/source/howto/data.rst:270
msgid ""
"Once you are clear about what you want and how you can get it, the "
":class:`~aiida.orm.querybuilder.QueryBuilder` will build an SQL-query for "
"you."
msgstr ""

#: ../docs/source/howto/data.rst:272
msgid ""
"There are two ways of using the "
":class:`~aiida.orm.querybuilder.QueryBuilder`:"
msgstr ""

#: ../docs/source/howto/data.rst:274
msgid ""
"In the *appender* method, you construct your query step by step using the "
"``QueryBuilder.append()`` method."
msgstr ""

#: ../docs/source/howto/data.rst:275
msgid ""
"In the *queryhelp* approach, you construct a dictionary that defines your "
"query and pass it to the :class:`~aiida.orm.querybuilder.QueryBuilder`."
msgstr ""

#: ../docs/source/howto/data.rst:277
msgid ""
"Both APIs provide the same functionality - the appender method may be more "
"suitable for interactive use, e.g., in the ``verdi shell``, whereas the "
"queryhelp method can be useful in scripting. In this section we will focus "
"on the basics of the appender method. For more advanced queries or more "
"details on the queryhelp, see the :ref:`topics section on advanced querying "
"<topics:database:advancedquery>`."
msgstr ""

#: ../docs/source/howto/data.rst:284
msgid "Selecting entities"
msgstr ""

#: ../docs/source/howto/data.rst:286
msgid ""
"Using the ``append()`` method of the "
":class:`~aiida.orm.querybuilder.QueryBuilder`, you can query for the "
"entities you are interested in. Suppose you want to query for calculation "
"job nodes in your database:"
msgstr ""

#: ../docs/source/howto/data.rst:295
msgid ""
"If you are interested in instances of different classes, you can also pass "
"an iterable of classes. However, they have to be of the same ORM-type (e.g. "
"all have to be subclasses of :class:`~aiida.orm.nodes.node.Node`):"
msgstr ""

#: ../docs/source/howto/data.rst:305
msgid ""
"Processes have both a run-time "
":class:`~aiida.engine.processes.process.Process` that executes them and a "
":class:`~aiida.orm.nodes.node.Node` that stores their data in the database "
"(see the :ref:`corresponding topics "
"section<topics:processes:concepts:types>` for a detailed explanation). The "
":class:`~aiida.orm.querybuilder.QueryBuilder` allows you to pass either the "
":class:`~aiida.orm.nodes.node.Node` class (e.g. "
":class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode`) or the "
":class:`~aiida.engine.processes.process.Process` class (e.g. "
":class:`~aiida.engine.processes.calcjobs.calcjob.CalcJob`), which will "
"automatically select the right entity for the query. Using either "
":class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode` or "
":class:`~aiida.engine.processes.calcjobs.calcjob.CalcJob` will produce the "
"same query results."
msgstr ""

#: ../docs/source/howto/data.rst:312
msgid "Retrieving results"
msgstr ""

#: ../docs/source/howto/data.rst:314
msgid ""
"Once you have *appended* the entity you want to query for to the "
":class:`~aiida.orm.querybuilder.QueryBuilder`, the next question is how to "
"get the results. There are several ways to obtain data from a query:"
msgstr ""

#: ../docs/source/howto/data.rst:328
msgid ""
"In case you are working with a large dataset, you can also return your query"
" as a generator:"
msgstr ""

#: ../docs/source/howto/data.rst:336
msgid ""
"This will retrieve the data in batches, and you can start working with the "
"data before the query has completely finished. For example, you can iterate "
"over the results of your query in a for loop:"
msgstr ""

#: ../docs/source/howto/data.rst:347
msgid "Filters"
msgstr ""

#: ../docs/source/howto/data.rst:349
msgid ""
"Usually you do not want to query for *all* entities of a certain class, but "
"rather *filter* the results based on certain properties. Suppose you do not "
"want all :class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode` "
"data, but only those that are ``finished``:"
msgstr ""

#: ../docs/source/howto/data.rst:362
msgid ""
"You can apply multiple filters to one entity in a query. Say you are "
"interested in all calculation jobs in your database that are ``finished`` "
"**and** have ``exit_status == 0``:"
msgstr ""

#: ../docs/source/howto/data.rst:376
msgid ""
"In case you want to query for calculation jobs that satisfy one of these "
"conditions, you can use the ``or`` operator:"
msgstr ""

#: ../docs/source/howto/data.rst:391
msgid ""
"If we had written ``and`` instead of ``or`` in the example above, we would "
"have performed the exact same query as the previous one, because ``and`` is "
"the default behavior if you provide several filters as key-value pairs in a "
"dictionary to the ``filters`` argument. In case you want all calculation "
"jobs with state ``finished`` or ``excepted``, you can also use the ``in`` "
"operator:"
msgstr ""

#: ../docs/source/howto/data.rst:404
msgid ""
"You can negate a filter by adding an exclamation mark in front of the "
"operator. So, to query for all calculation jobs that are not a ``finished`` "
"or ``excepted`` state:"
msgstr ""

#: ../docs/source/howto/data.rst:419
msgid ""
"The above rule applies to all operators. For example, you can check non-"
"equality with ``!==``, since this is the equality operator (``==``) with a "
"negation prepended."
msgstr ""

#: ../docs/source/howto/data.rst:422
msgid ""
"A complete list of all available operators can be found in the "
":ref:`advanced querying "
"section<topics:database:advancedquery:tables:operators>`."
msgstr ""

#: ../docs/source/howto/data.rst:427
msgid "Relationships"
msgstr ""

#: ../docs/source/howto/data.rst:429
msgid ""
"It is possible to query for data based on its relationship to another entity"
" in the database. Imagine you are not interested in the calculation jobs "
"themselves, but in one of the outputs they create. You can build upon your "
"initial query for all  "
":class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode`'s in the "
"database using the relationship of the output to the first step in the "
"query:"
msgstr ""

#: ../docs/source/howto/data.rst:439
msgid ""
"In the first ``append`` call, we query for all  "
":class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode`'s in the "
"database, and *tag* this step with the *unique* identifier ``'calcjob'``. "
"Next, we look for all ``Int`` nodes that are an output of the  "
":class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode`'s found in"
" the first step, using the ``with_incoming`` relationship argument. The "
"``Int`` node was created by the  "
":class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode` and as "
"such has an *incoming* create link."
msgstr ""

#: ../docs/source/howto/data.rst:443
msgid ""
"In the context of our query, we are building a *path* consisting of "
"*vertices* (i.e. the entities we query for) connected by *edges* defined by "
"the relationships between them. The complete set of all possible "
"relationships you can use query for, as well as the entities that they "
"connect to, can be found in the :ref:`advanced querying "
"section<topics:database:advancedquery:tables:relationships>`."
msgstr ""

#: ../docs/source/howto/data.rst:448
msgid ""
"The ``tag`` identifier can be any alphanumeric string, it is simply a label "
"used to refer to a previous vertex along the query path when defining a "
"relationship."
msgstr ""

#: ../docs/source/howto/data.rst:453
msgid "Projections"
msgstr ""

#: ../docs/source/howto/data.rst:455
msgid ""
"By default, the :class:`~aiida.orm.querybuilder.QueryBuilder` returns the "
"instances of the entities corresponding to the final append to the query "
"path. For example:"
msgstr ""

#: ../docs/source/howto/data.rst:464
msgid ""
"The above code snippet will return all ``Int`` nodes that are outputs of any"
"  :class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode`. "
"However, you can also *project* other entities in the path by adding "
"``project='*'`` to the corresponding ``append()`` call:"
msgstr ""

#: ../docs/source/howto/data.rst:473
msgid ""
"This will return all  "
":class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode`'s that "
"have an ``Int`` output node."
msgstr ""

#: ../docs/source/howto/data.rst:475
msgid ""
"However, in many cases we are not interested in the entities themselves, but"
" rather their PK, UUID, *attributes* or some other piece of information "
"stored by the entity. This can be achieved by providing the corresponding "
"*column* to the ``project`` keyword argument:"
msgstr ""

#: ../docs/source/howto/data.rst:484
msgid ""
"In the above example, executing the query returns all *PK's* of the ``Int`` "
"nodes which are outputs of all  "
":class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode`'s in the "
"database. Moreover, you can project more than one piece of information for "
"one vertex by providing a list:"
msgstr ""

#: ../docs/source/howto/data.rst:493
msgid ""
"For the query above, ``qb.all()`` will return a list of lists, for which "
"each element corresponds to one entity and contains two items: the PK of the"
" ``Int`` node and its value. Finally, you can project information for "
"multiple vertices along the query path:"
msgstr ""

#: ../docs/source/howto/data.rst:502
msgid ""
"All projections must start with one of the *columns* of the entities in the "
"database, or project the instances themselves using ``'*'``. Examples of "
"columns we have encountered so far are ``id``, ``uuid`` and ``attributes``. "
"If the column is a dictionary, you can expand the dictionary values using a "
"dot notation, as we have done in the previous example to obtain the "
"``attributes.value``. This can be used to project the values of nested "
"dictionaries as well."
msgstr ""

#: ../docs/source/howto/data.rst:509
msgid ""
"Be aware that for consistency, ``QueryBuilder.all()`` / ``iterall()`` always"
" returns a list of lists, even if you only project one property of a single "
"entity. Use ``QueryBuilder.all(flat=True)`` to return the query result as a "
"flat list in this case."
msgstr ""

#: ../docs/source/howto/data.rst:512
msgid ""
"As mentioned in the beginning, this section provides only a brief "
"introduction to the :class:`~aiida.orm.querybuilder.QueryBuilder`'s basic "
"functionality. To learn about more advanced queries, please see :ref:`the "
"corresponding topics section<topics:database:advancedquery>`."
msgstr ""

#: ../docs/source/howto/data.rst:518
msgid "Organizing data"
msgstr ""

#: ../docs/source/howto/data.rst:521
msgid "How to group nodes"
msgstr ""

#: ../docs/source/howto/data.rst:523
msgid ""
"AiiDA's database is great for automatically storing all your data, but "
"sometimes it can be tricky to navigate this flat data store. To create some "
"order in this mass of data, you can *group* sets of nodes together, just as "
"you would with files in folders on your filesystem. A folder, in this "
"analogy, is represented by the :py:class:`~aiida.orm.groups.Group` class. "
"Each group instance can hold any amount of nodes and any node can be "
"contained in any number of groups. A typical use case is to store all nodes "
"that share a common property in a single group."
msgstr ""

#: ../docs/source/howto/data.rst:529
msgid ""
"Below we show how to perform a typical set of operations one may want to "
"perform with groups."
msgstr ""

#: ../docs/source/howto/data.rst:532
msgid "Create a new group"
msgstr ""

#: ../docs/source/howto/data.rst:534 ../docs/source/howto/data.rst:598
#: ../docs/source/howto/data.rst:616 ../docs/source/howto/data.rst:650
#: ../docs/source/howto/data.rst:668 ../docs/source/howto/data.rst:686
msgid "From the command line interface:"
msgstr ""

#: ../docs/source/howto/data.rst:540 ../docs/source/howto/data.rst:623
#: ../docs/source/howto/data.rst:657 ../docs/source/howto/data.rst:693
msgid "From the Python interface:"
msgstr ""

#: ../docs/source/howto/data.rst:551
msgid "List available groups"
msgstr ""

#: ../docs/source/howto/data.rst:553
msgid "Example:"
msgstr ""

#: ../docs/source/howto/data.rst:559
msgid ""
"Groups come in different types, indicated by their type string. By default "
"``verdi group list`` only shows groups of the type *core*. In case you want "
"to show groups of another type use ``-T/--type-string`` option. If you want "
"to show groups of all types, use the ``-a/--all-types`` option."
msgstr ""

#: ../docs/source/howto/data.rst:564
msgid "For example, to list groups of type ``core.auto``, use:"
msgstr ""

#: ../docs/source/howto/data.rst:570
msgid ""
"Similarly, we can use the ``type_string`` key to filter groups with the "
"``QueryBuilder``:"
msgstr ""

#: ../docs/source/howto/data.rst:581
msgid "Add nodes to a group"
msgstr ""

#: ../docs/source/howto/data.rst:582
msgid ""
"Once the ``test_group`` has been created, we can add nodes to it. For "
"example, to add a node with ``pk=1`` to the group we could either use the "
"command line interface:"
msgstr ""

#: ../docs/source/howto/data.rst:590
msgid "Or the Python interface:"
msgstr ""

#: ../docs/source/howto/data.rst:597
msgid "Show information about a group"
msgstr ""

#: ../docs/source/howto/data.rst:615
msgid "Remove nodes from a group"
msgstr ""

#: ../docs/source/howto/data.rst:631
msgid ""
"Alternatively, you might want to remove *all* nodes from the group. In the "
"command line you just need to add ``-c/--clear`` option to ``verdi group "
"remove-nodes ..``"
msgstr ""

#: ../docs/source/howto/data.rst:639
msgid ""
"In the Python interface you can use ``.clear()`` method to achieve the same "
"goal:"
msgstr ""

#: ../docs/source/howto/data.rst:649
msgid "Rename a group"
msgstr ""

#: ../docs/source/howto/data.rst:667
msgid "Delete a group"
msgstr ""

#: ../docs/source/howto/data.rst:677
msgid ""
"Any deletion operation related to groups won't affect the nodes themselves. "
"For example if you delete a group, the nodes that belonged to the group will"
" remain in the database. The same happens if you remove nodes from the group"
" -- they will remain in the database but won't belong to the group anymore."
msgstr ""

#: ../docs/source/howto/data.rst:682
msgid "Copy one group into another"
msgstr ""

#: ../docs/source/howto/data.rst:683
msgid ""
"This operation will copy the nodes of the source group into the destination "
"group. If the destination group does not yet exist, it will be created "
"automatically."
msgstr ""

#: ../docs/source/howto/data.rst:705
msgid "Examples for using groups"
msgstr ""

#: ../docs/source/howto/data.rst:707
msgid ""
"In this section, we will provide some practical examples of how one can use "
"Groups to structure and organize the nodes in the database."
msgstr ""

#: ../docs/source/howto/data.rst:710
msgid "Group structures with a similar property"
msgstr ""

#: ../docs/source/howto/data.rst:712
msgid ""
"Suppose, we wanted to group all structures for which the computed bandgap is"
" higher than ``1.0 eV`` in a group named ``promising_structures``, one could"
" use the following approach:"
msgstr ""

#: ../docs/source/howto/data.rst:728
msgid ""
"Any node can be included in a group only once and if it is added again, it "
"is simply ignored. This means that add_nodes can be safely called multiple "
"times, and only nodes that weren't already part of the group, will be added."
msgstr ""

#: ../docs/source/howto/data.rst:733
msgid "Use grouped data for further processing"
msgstr ""

#: ../docs/source/howto/data.rst:735
msgid ""
"Here we demonstrate how to submit calculations for structures that all "
"belong to a group named ``promising_structures``:"
msgstr ""

#: ../docs/source/howto/data.rst:751
msgid ""
"Note, however, that one can also use ``group.nodes`` to access the nodes of "
"the group. To achieve the same result as above one would need to do "
"something as follows:"
msgstr ""

#: ../docs/source/howto/data.rst:767
msgid ""
"To find all structures that have a property ``property_a`` with a value "
"lower than ``1`` and also belong to the ``promising_structures`` group, one "
"could build a query as follows:"
msgstr ""

#: ../docs/source/howto/data.rst:777
msgid ""
"The return value of ``qb.all(flat=True)`` would contain all the structures "
"matching the above mentioned criteria."
msgstr ""

#: ../docs/source/howto/data.rst:780
msgid "Using groups for data exporting"
msgstr ""

#: ../docs/source/howto/data.rst:782
msgid ""
"Groups can be very useful for selecting specific parts of the database for "
"sharing. All data related to calculations that involved structures as part "
"of the ``promising_structures`` group can be exported with a single command:"
msgstr ""

#: ../docs/source/howto/data.rst:789
msgid ""
"Such an export operation would not only export the structures that are part "
"of the group, but also the nodes linked to them, following the rules "
"discussed in the :ref:`topics:provenance:consistency:traversal-rules` "
"section."
msgstr ""

#: ../docs/source/howto/data.rst:794
msgid "Organise groups in hierarchies"
msgstr ""

#: ../docs/source/howto/data.rst:796
msgid "grouppath"
msgstr ""

#: ../docs/source/howto/data.rst:799
msgid ""
"Groups in AiiDA are inherently \"flat\", in that groups may only contain "
"nodes and not other groups. However it is possible to construct *virtual* "
"group hierarchies based on delimited group labels, using the "
":py:class:`~aiida.tools.groups.paths.GroupPath` utility."
msgstr ""

#: ../docs/source/howto/data.rst:802
msgid ""
":py:class:`~aiida.tools.groups.paths.GroupPath` is designed to work in much "
"the same way as Python's :py:class:`pathlib.Path`, whereby paths are denoted"
" by forward slash characters '/' in group labels."
msgstr ""

#: ../docs/source/howto/data.rst:804
msgid "For example say we have the groups:"
msgstr ""

#: ../docs/source/howto/data.rst:816
msgid "We can also access them from the command-line as:"
msgstr ""

#: ../docs/source/howto/data.rst:829
msgid "Or from the python interface:"
msgstr ""

#: ../docs/source/howto/data.rst:839
msgid "The ``GroupPath`` can be constructed using indexing or \"divisors\":"
msgstr ""

#: ../docs/source/howto/data.rst:847
msgid ""
"Using the :py:func:`~aiida.tools.groups.paths.GroupPath.browse` attribute, "
"you can also construct the paths as preceding attributes. This is useful in "
"interactive environments, whereby available paths will be shown in the tab-"
"completion:"
msgstr ""

#: ../docs/source/howto/data.rst:855
msgid "To check the existence of a path element:"
msgstr ""

#: ../docs/source/howto/data.rst:862
msgid ""
"A group may be \"virtual\", in which case its label does not directly relate"
" to a group, or the group can be retrieved with the "
":py:func:`~aiida.tools.groups.paths.GroupPath.get_group` method:"
msgstr ""

#: ../docs/source/howto/data.rst:875
msgid "Groups can be created and destroyed:"
msgstr ""

#: ../docs/source/howto/data.rst:887
msgid ""
"To traverse paths, use the "
":py:func:`~aiida.tools.groups.paths.GroupPath.children` attribute - for "
"recursive traversal, use "
":py:func:`~aiida.tools.groups.paths.GroupPath.walk`:"
msgstr ""

#: ../docs/source/howto/data.rst:898
msgid ""
"You can also traverse directly through the nodes of a path, optionally "
"filtering by node class and any other filters allowed by the "
":ref:`QueryBuilder <how-to:data:find>`:"
msgstr ""

#: ../docs/source/howto/data.rst:912
msgid ""
"Finally, you can also specify the ``Group`` subclasses (as discussed above):"
msgstr ""

#: ../docs/source/howto/data.rst:923
msgid ""
"A :py:class:`~aiida.tools.groups.paths.GroupPath` instance will only "
"recognise groups of the instantiated ``cls`` type. The default ``cls`` is "
"``aiida.orm.Group``:"
msgstr ""

#: ../docs/source/howto/data.rst:942
msgid "title: Sharing data"
msgstr ""

#: ../docs/source/howto/data.rst:944
msgid "`#3998`_"
msgstr ""

#: ../docs/source/howto/data.rst:950
msgid "Deleting data"
msgstr ""

#: ../docs/source/howto/data.rst:952
msgid ""
"By default, every time you run or submit a new calculation, AiiDA will "
"create for you new nodes in the database, and will never replace or delete "
"data. There are cases, however, when it might be useful to delete nodes that"
" are not useful anymore, for instance test runs or incorrect/wrong data and "
"calculations. For this case, AiiDA provides the ``verdi node delete`` "
"command to remove the nodes from the provenance graph."
msgstr ""

#: ../docs/source/howto/data.rst:957
msgid ""
"Once the data is deleted, there is no way to recover it (unless you made a "
"backup)."
msgstr ""

#: ../docs/source/howto/data.rst:959
msgid ""
"Critically, note that even if you ask to delete only one node, ``verdi node "
"delete`` will typically delete a number of additional linked nodes, in order"
" to preserve a consistent state of the provenance graph. For instance, if "
"you delete an input of a calculation, AiiDA will delete also the calculation"
" itself (as otherwise you would be effectively changing the inputs to that "
"calculation in the provenance graph). The full set of consistency rules are "
"explained in detail :ref:`here <topics:provenance:consistency>`."
msgstr ""

#: ../docs/source/howto/data.rst:963
msgid ""
"Therefore: always check the output of ``verdi node delete`` to make sure "
"that it is not deleting more than you expect. You can also use the ``--dry-"
"run`` flag of ``verdi node delete`` to see what the command would do without"
" performing any actual operation."
msgstr ""

#: ../docs/source/howto/data.rst:966
msgid ""
"In addition, there are a number of additional rules that are not mandatory "
"to ensure consistency, but can be toggled by the user. For instance, you can"
" set ``--create-forward`` if, when deleting a calculation, you want to "
"delete also the data it produced (using instead ``--no-create-forward`` will"
" delete the calculation only, keeping the output data: note that this "
"effectively strips out the provenance information of the output data). The "
"full list of these flags is available from the help command ``verdi node "
"delete -h``."
msgstr ""

#: ../docs/source/howto/data.rst:971
msgid "Deleting computers"
msgstr ""

#: ../docs/source/howto/data.rst:972
msgid ""
"To delete a computer, you can use ``verdi computer delete``. This command is"
" mostly useful if, right after creating a computer, you realise that there "
"was an error and you want to remove it. In particular, note that ``verdi "
"computer delete`` will prevent execution if the computer has been already "
"used by at least one node. In this case, you will need to use ``verdi node "
"delete`` to delete first the corresponding nodes."
msgstr ""

#: ../docs/source/howto/data.rst:977
msgid "Deleting mutable data"
msgstr ""

#: ../docs/source/howto/data.rst:978
msgid ""
"A subset of data in AiiDA is mutable also after storing a node, and is used "
"as a convenience for the user to tag/group/comment on data. This data can be"
" safely deleted at any time. This includes, notably:"
msgstr ""

#: ../docs/source/howto/data.rst:982
msgid ""
"*Node extras*: These can be deleted using "
":py:meth:`~aiida.orm.nodes.node.Node.delete_extra` and "
":py:meth:`~aiida.orm.nodes.node.Node.delete_extra_many`."
msgstr ""

#: ../docs/source/howto/data.rst:983
msgid ""
"*Node comments*: These can be removed using "
":py:meth:`~aiida.orm.nodes.node.Node.remove_comment`."
msgstr ""

#: ../docs/source/howto/data.rst:984
msgid ""
"*Groups*: These can be deleted using :py:meth:`Group.objects.delete() "
"<aiida.orm.groups.Group.Collection.delete>`. This command will only delete "
"the group, not the nodes contained in the group."
msgstr ""

#: ../docs/source/howto/data.rst:988
msgid "Completely deleting an AiiDA profile"
msgstr ""

#: ../docs/source/howto/data.rst:989
msgid ""
"If you don't want to selectively delete some nodes, but instead want to "
"delete a whole AiiDA profile altogether, use the ``verdi profile delete`` "
"command. This command will delete both the file repository and the database."
msgstr ""

#: ../docs/source/howto/data.rst:994
msgid ""
"It is not possible to restore a deleted profile unless it was previously "
"backed up!"
msgstr ""

#: ../docs/source/howto/data.rst:999
msgid "Serving your data to others"
msgstr ""

#: ../docs/source/howto/data.rst:1001
msgid ""
"The AiiDA REST API allows to query your AiiDA database over HTTP(S), e.g. by"
" writing requests directly or via a JavaScript application as on `Materials "
"Cloud <http://materialscloud.org/explore>`_."
msgstr ""

#: ../docs/source/howto/data.rst:1003
msgid ""
"The ``verdi restapi`` command runs the REST API through the ``werkzeug`` "
"python-based HTTP server. In order to deploy production instances of the "
"REST API for serving your data to others, we recommend using a fully fledged"
" web server, such as `Apache <https://httpd.apache.org/>`_ or `NGINX "
"<https://www.nginx.com/>`_."
msgstr ""

#: ../docs/source/howto/data.rst:1007
msgid ""
"One Apache/NGINX server can host multiple APIs, e.g. connecting to different"
" AiiDA profiles."
msgstr ""

#: ../docs/source/howto/data.rst:1009
msgid ""
"In the following, we assume you have a working installation of Apache with "
"the ``mod_wsgi`` `WSGI module <modwsgi.readthedocs.io/>`_ enabled."
msgstr ""

#: ../docs/source/howto/data.rst:1011
msgid ""
"The goal of the example is to hookup the APIs ``django`` and ``sqlalchemy`` "
"pointing to two AiiDA profiles, called for simplicity ``django`` and "
"``sqlalchemy``."
msgstr ""

#: ../docs/source/howto/data.rst:1013
msgid ""
"All the relevant files are enclosed under the path ``/docs/wsgi/`` starting "
"from the AiiDA source code path. In each of the folders ``app1/`` and "
"``app2/``, there is a file named ``rest.wsgi`` containing a python script "
"that instantiates and configures a python web app called ``application``, "
"according to the rules of ``mod_wsgi``. For how the script is written, the "
"object ``application`` is configured through the file ``config.py`` "
"contained in the same folder. Indeed, in ``app1/config.py`` the variable "
"``aiida-profile`` is set to ``\"django\"``, whereas in ``app2/config.py`` "
"its value is ``\"sqlalchemy\"``."
msgstr ""

#: ../docs/source/howto/data.rst:1018
msgid ""
"Anyway, the path where you put the ``.wsgi`` file as well as its name are "
"irrelevant as long as they are correctly referred to in the Apache "
"configuration file, as shown later on. Similarly, you can place "
"``config.py`` in a custom path, provided you change the variable "
"``config_file_path`` in the ``wsgi file`` accordingly."
msgstr ""

#: ../docs/source/howto/data.rst:1021
msgid ""
"In ``rest.wsgi`` probably the only options you might want to change is "
"``catch_internal_server``. When set to ``True``, it lets the exceptions "
"thrown during the execution of the app propagate all the way through until "
"they reach the logger of Apache. Especially when the app is not entirely "
"stable yet, one would like to read the full python error traceback in the "
"Apache error log."
msgstr ""

#: ../docs/source/howto/data.rst:1025
msgid ""
"Finally, you need to setup the Apache site through a proper configuration "
"file. We provide two template files: ``one.conf`` or ``many.conf``. The "
"first file tells Apache to bundle both apps in a unique Apache daemon "
"process. Apache usually creates multiple process dynamically and with this "
"configuration each process will handle both apps."
msgstr ""

#: ../docs/source/howto/data.rst:1030
msgid ""
"The script ``many.conf``, instead, defines two different process groups, one"
" for each app. So the processes created dynamically by Apache will always be"
" handling one app each. The minimal number of Apache daemon processes equals"
" the number of apps, contrarily to the first architecture, where one process"
" is enough to handle two or even a larger number of apps."
msgstr ""

#: ../docs/source/howto/data.rst:1034
msgid ""
"Let us call the two apps for this example ``django`` and ``sqlalchemy``. In "
"both ``one.conf`` and ``many.conf``, the important directives that should be"
" updated if one changes the paths or names of the apps are:"
msgstr ""

#: ../docs/source/howto/data.rst:1037
msgid ""
"``WSGIProcessGroup`` to define the process groups for later reference. In "
"``one.conf`` this directive appears only once to define the generic group "
"``profiles``, as there is only one kind of process handling both apps. In "
"``many.conf`` this directive appears once per app and is embedded into a "
"\"Location\" tag, e.g.::"
msgstr ""

#: ../docs/source/howto/data.rst:1045
msgid ""
"``WSGIDaemonProcess`` to define the path to the AiiDA virtual environment. "
"This appears once per app in both configurations."
msgstr ""

#: ../docs/source/howto/data.rst:1048
msgid ""
"``WSGIScriptAlias`` to define the absolute path of the ``.wsgi`` file of "
"each app."
msgstr ""

#: ../docs/source/howto/data.rst:1050
msgid ""
"The ``<Directory>`` tag mainly used to grant Apache access to the files used"
" by each app, e.g.::"
msgstr ""

#: ../docs/source/howto/data.rst:1056
msgid ""
"The latest step is to move either ``one.conf`` or ``many.conf`` into the "
"Apache configuration folder and restart the Apache server. In Ubuntu, this "
"is usually done with the commands:"
msgstr ""

#: ../docs/source/howto/data.rst:1064
msgid ""
"We believe the two basic architectures we have just explained can be "
"successfully applied in many different deployment scenarios. Nevertheless, "
"we suggest users who need finer tuning of the deployment setup to look into "
"to the official documentation of `Apache <https://httpd.apache.org/>`_ and, "
"more importantly, `WSGI <wsgi.readthedocs.io/>`__."
msgstr ""

#: ../docs/source/howto/data.rst:1067
msgid ""
"The URLs of the requests handled by Apache must start with one of the paths "
"specified in the directives ``WSGIScriptAlias``. These paths identify "
"uniquely each app and allow Apache to route the requests to their correct "
"apps. Examples of well-formed URLs are:"
msgstr ""

#: ../docs/source/howto/data.rst:1076
msgid ""
"The first (second) request will be handled by the app ``django`` "
"(``sqlalchemy``), namely will serve results fetched from the profile "
"``django`` (``sqlalchemy``). Notice that we haven't specified any port in "
"the URLs since Apache listens conventionally to port 80, where any request "
"lacking the port is automatically redirected."
msgstr ""

#: ../docs/source/howto/faq.rst:5
msgid "Frequently Asked Questions"
msgstr ""

#: ../docs/source/howto/faq.rst:7
msgid ""
"If the problem you are facing is not addressed below, you can send an email "
"to the `mailing list <http://www.aiida.net/mailing-list/>`_, or `open an "
"issue on Github <https://github.com/aiidateam/aiida-"
"core/issues/new/choose>`_ if you think it concerns a bug."
msgstr ""

#: ../docs/source/howto/faq.rst:11
msgid ""
"I have updated the version of AiiDA and now it is no longer working. What "
"should I do?"
msgstr ""

#: ../docs/source/howto/faq.rst:12
msgid ""
"First, make sure that your daemon is not running. You can check this with "
"``verdi daemon status``. If you find that your daemon was actually still "
"running, that is likely the problem, so stop it first using ``verdi daemon "
"stop``. It is very important that each time you want to :ref:`update your "
"AiiDA installation<how-to:installation:update>`, you should *always* first "
"finish all running processes and stop the daemon before doing so. After you "
"have stopped the daemon, make sure to run ``reentry scan`` before you "
"restart the daemon with ``verdi daemon start``."
msgstr ""

#: ../docs/source/howto/faq.rst:20
msgid ""
"I get a :py:class:`~aiida.common.exceptions.MissingEntryPointError` or "
":py:class:`~aiida.common.exceptions.MultipleEntryPointError` exception, "
"saying that a particular entry point cannot be found. How can I fix this?"
msgstr ""

#: ../docs/source/howto/faq.rst:21
msgid ""
"Often this is caused by an outdated entry point cache. This can happen for "
"example when you have updated your AiiDA installation or installed a new "
"plugin using ``pip install``. In both cases, you can fix the problem by "
"running ``reentry scan``. Make sure to also restart all daemons, to ensure "
"that the changes are picked up by the daemons as well."
msgstr ""

#: ../docs/source/howto/faq.rst:28
msgid ""
"I have updated the code of a "
":py:class:`~aiida.engine.processes.workchains.WorkChain`, "
":py:class:`~aiida.engine.processes.calcjobs.CalcJob` or whatever other "
"Python code, but the daemon does not seem to pick up the changes?"
msgstr ""

#: ../docs/source/howto/faq.rst:29
msgid ""
"Each time that you change your code, you should restart the daemon for the "
"changes to take effect. Each daemon worker actually is its own system "
"process with its own Python interpreter instance, and since we don't support"
" automated hot==swapping, the daemon workers will not automatically detect "
"the changes in the code. Simply calling ``verdi daemon restart`` will do the"
" trick."
msgstr ""

#: ../docs/source/howto/faq.rst:35
msgid ""
"I have updated the code of a "
":py:class:`~aiida.engine.processes.workchains.WorkChain`, "
":py:class:`~aiida.engine.processes.calcjobs.CalcJob` or whatever other "
"Python code, but my Python shell instance does not seem to pick up the "
"changes?"
msgstr ""

#: ../docs/source/howto/faq.rst:36
msgid ""
"The ``verdi shell`` is its own Python interpreter and does not automatically"
" detect code changes. Simply reloading your shell will solve the problem."
msgstr ""

#: ../docs/source/howto/faq.rst:41
msgid ""
"Why are calculation jobs taking very long to run on remote machines even "
"though the actual computation time should be fast?"
msgstr ""

#: ../docs/source/howto/faq.rst:42
msgid ""
"First make sure that the calculation is not actually waiting in the queue of"
" the scheduler, but it is actually running or has already completed. If it "
"then still takes seemingly a lot of time for AiiDA to update your "
"calculations, there are a couple of explanations. First, if you are running "
"many processes, your daemon workers may simply be busy managing other "
"calculations and workflows. If that is not the case, you may be witnessing "
"the effects of the built in throttling mechanisms of AiiDA's engine. To "
"ensure that the AiiDA daemon does not overload remote computers or their "
"schedulers, there are built in limits to how often the daemon workers are "
"allowed to open an SSH connection, or poll the scheduler. To determine the "
"minimum transport and job polling interval, use ``verdi computer configure "
"show <COMPUTER>`` and ``computer.get_minimum_job_poll_interval()``, "
"respectively. You can lower these values using:"
msgstr ""

#: ../docs/source/howto/faq.rst:54
msgid "and"
msgstr ""

#: ../docs/source/howto/faq.rst:60
msgid ""
"respectively. However, be careful, if you make these intervals too short, "
"the daemon workers may spam the remote machine and/or scheduler, which could"
" have adverse effects on the machine itself or can get your account banned, "
"depending on the policy of the remote machine. An additional note of "
"importance is that each interval is guaranteed to be respected per daemon "
"worker individually, but not as a collective. That is to say, if the safe "
"interval is set to 60 seconds, any single worker is guaranteed to open a "
"connection to that machine at most once every minute, however, if you have "
"multiple active daemon workers, the machine may be accessed more than once "
"per minute."
msgstr ""

#: ../docs/source/howto/faq.rst:67
msgid ""
"Why would a process that runs fine locally raise an exception when submitted"
" to the daemon?"
msgstr ""

#: ../docs/source/howto/faq.rst:68
msgid ""
"This is almost always caused by an import issue. To determine exactly what "
"might be going wrong, first `set the loglevel <intro:increase-logging-"
"verbosity>` to ``DEBUG`` by executing the command:"
msgstr ""

#: ../docs/source/howto/faq.rst:75
msgid ""
"Then restart the daemon with ``verdi daemon restart`` for the changes to "
"take effect. Run the command ``verdi daemon logshow`` in a separate terminal"
" to see the logging output of the daemon and then submit the problematic "
"calculation or workflow again. If the root cause is indeed due to an import "
"problem, it will probably appear as an ``ImportError`` exception in the "
"daemon log. To solve these issues, make sure that all the Python code that "
"is being run is properly importable, which means that it is part of the "
"`PYTHONPATH <https://docs.python.org/3/using/cmdline.html#envvar-"
"PYTHONPATH>`_. Make sure that the PYTHONPATH is correctly defined "
"automatically when starting your shell, so for example if you are using "
"bash, add it to your ``.bashrc``."
msgstr ""

#: ../docs/source/howto/index.rst:3
msgid "How-To Guides"
msgstr ""

#: ../docs/source/howto/installation.rst:5
msgid "How to manage your installation"
msgstr ""

#: ../docs/source/howto/installation.rst:11
msgid "Managing profiles"
msgstr ""

#: ../docs/source/howto/installation.rst:14
msgid "Creating profiles"
msgstr ""

#: ../docs/source/howto/installation.rst:15
msgid ""
"Each AiiDA installation can have multiple profiles, each of which can have "
"its own individual database and file repository to store the contents of the"
" :ref:`provenance graph<topics:provenance:concepts>`. Profiles allow you to "
"run multiple projects completely independently from one another with just a "
"single AiiDA installation and at least one profile is required to run AiiDA."
" A new profile can be created using :ref:`verdi quicksetup<reference"
":command-line:verdi-quicksetup>` or :ref:`verdi setup<reference:command-line"
":verdi-setup>`, which works similar to the former but gives more control to "
"the user."
msgstr ""

#: ../docs/source/howto/installation.rst:20
msgid "Listing profiles"
msgstr ""

#: ../docs/source/howto/installation.rst:21
msgid ""
"The :ref:`verdi profile<reference:command-line:verdi-profile>` command line "
"interface provides various commands to manage the profiles of an AiiDA "
"installation. To list the currently configured profiles, use ``verdi profile"
" list``:"
msgstr ""

#: ../docs/source/howto/installation.rst:30
msgid ""
"In this particular example, there are two configured profiles, ``project-"
"one`` and ``project-two``. The first one is highlighted and marked with a "
"``*`` symbol, meaning it is the default profile. A profile being the default"
" means simply that any ``verdi`` command will always be executed for that "
"profile. You can :ref:`change the profile on a per-call "
"basis<topics:cli:profile>` with the ``--p/--profile`` option. To change the "
"default profile use ``verdi profile setdefault PROFILE``."
msgstr ""

#: ../docs/source/howto/installation.rst:37
msgid "Showing profiles"
msgstr ""

#: ../docs/source/howto/installation.rst:38
msgid ""
"Each profile defines various parameters, such as the location of the file "
"repository on the file system and the connection parameters for the "
"database. To display these parameters, use ``verdi profile show``:"
msgstr ""

#: ../docs/source/howto/installation.rst:58
msgid ""
"By default, the parameters of the default profile are shown, but one can "
"pass the profile name of another, e.g., ``verdi profile show project-two`` "
"to change that."
msgstr ""

#: ../docs/source/howto/installation.rst:61
msgid "Deleting profiles"
msgstr ""

#: ../docs/source/howto/installation.rst:62
msgid ""
"A profile can be deleted using the ``verdi profile delete`` command. By "
"default, deleting a profile will also delete its file repository and the "
"database. This behavior can be changed using the ``--skip-repository`` and "
"``--skip-db`` options."
msgstr ""

#: ../docs/source/howto/installation.rst:68
msgid ""
"In order to delete the database, the system user needs to have the required "
"rights, which is not always guaranteed depending on the system. In such "
"cases, the database deletion may fail and the user will have to perform the "
"deletion manually through PostgreSQL."
msgstr ""

#: ../docs/source/howto/installation.rst:75
msgid "Configuring your installation"
msgstr ""

#: ../docs/source/howto/installation.rst:80
msgid "Activating tab-completion"
msgstr ""

#: ../docs/source/howto/installation.rst:81
msgid ""
"The ``verdi`` command line interface has many commands and parameters, which"
" can be tab-completed to simplify its use. To enable tab-completion, the "
"following shell command should be executed:"
msgstr ""

#: ../docs/source/howto/installation.rst:88
msgid ""
"Place this command in your shell or virtual environment activation script to"
" automatically enable tab completion when opening a new shell or activating "
"an environment. This file is shell specific, but likely one of the "
"following:"
msgstr ""

#: ../docs/source/howto/installation.rst:91
msgid ""
"the startup file of your shell (``.bashrc``, ``.zsh``, ...), if aiida is "
"installed system-wide"
msgstr ""

#: ../docs/source/howto/installation.rst:92
msgid ""
"the `activation script <https://virtualenv.pypa.io/en/latest/userguide"
"/#activate-script>`_ of your virtual environment"
msgstr ""

#: ../docs/source/howto/installation.rst:93
msgid ""
"a `startup file <https://conda.io/docs/user-guide/tasks/manage-"
"environments.html#saving-environment-variables>`_ for your conda environment"
msgstr ""

#: ../docs/source/howto/installation.rst:98
msgid ""
"After you have added the line to the start up script, make sure to restart "
"the terminal or source the script for the changes to take effect."
msgstr ""

#: ../docs/source/howto/installation.rst:104
msgid "Configuring profile options"
msgstr ""

#: ../docs/source/howto/installation.rst:105
msgid ""
"AiiDA provides various configurational options for profiles, which can be "
"controlled with the :ref:`verdi config<reference:command-line:verdi-config>`"
" command. To set a configurational option, simply pass the name of the "
"option and the value to set ``verdi config OPTION_NAME OPTION_VALUE``. The "
"available options are tab-completed, so simply type ``verdi config`` and "
"thit <TAB> twice to list them."
msgstr ""

#: ../docs/source/howto/installation.rst:109
msgid ""
"For example, if you want to change the default number of workers that are "
"created when you start the daemon, you can run:"
msgstr ""

#: ../docs/source/howto/installation.rst:116
msgid ""
"You can check the currently defined value of any option by simply calling "
"the command without specifying a value, for example:"
msgstr ""

#: ../docs/source/howto/installation.rst:123
msgid ""
"If no value is displayed, it means that no value has ever explicitly been "
"set for this particular option and the default will always be used. By "
"default any option set through ``verdi config`` will be applied to the "
"current default profile. To change the profile you can use the :ref:`profile"
" option<topics:cli:profile>`."
msgstr ""

#: ../docs/source/howto/installation.rst:127
msgid ""
"To undo the configuration of a particular option and reset it so the default"
" value is used, you can use the ``--unset`` option:"
msgstr ""

#: ../docs/source/howto/installation.rst:134
msgid ""
"If you want to set a particular option that should be applied to all "
"profiles, you can use the ``--global`` flag:"
msgstr ""

#: ../docs/source/howto/installation.rst:141
msgid ""
"and just as on a per-profile basis, this can be undone with the ``--unset`` "
"flag:"
msgstr ""

#: ../docs/source/howto/installation.rst:150
msgid ""
"Changes that affect the daemon (e.g. ``logging.aiida_loglevel``) will only "
"take affect after restarting the daemon."
msgstr ""

#: ../docs/source/howto/installation.rst:156
msgid "Isolating multiple instances"
msgstr ""

#: ../docs/source/howto/installation.rst:157
msgid ""
"An AiiDA instance is defined as the installed source code plus the "
"configuration folder that stores the configuration files with all the "
"configured profiles. It is possible to run multiple AiiDA instances on a "
"single machine, simply by isolating the code and configuration in a virtual "
"environment."
msgstr ""

#: ../docs/source/howto/installation.rst:160
msgid ""
"To isolate the code, simply create a virtual environment, e.g., with conda "
"or venv, and then follow the instructions for "
":ref:`installation<intro:install:aiida-core>` after activation. Whenever you"
" activate this particular environment, you will be running the particular "
"version of AiiDA (and all the plugins) that you installed specifically for "
"it."
msgstr ""

#: ../docs/source/howto/installation.rst:163
msgid ""
"This is separate from the configuration of AiiDA, which is stored in the "
"configuration directory which is always named ``.aiida`` and by default is "
"stored in the home directory. Therefore, the default path of the "
"configuration directory is ``~/.aiida``. By default, each AiiDA instance "
"(each installation) will store associated profiles in this folder. A best "
"practice is to always separate the profiles together with the code to which "
"they belong. The typical approach is to place the configuration folder in "
"the virtual environment itself and have it automatically selected whenever "
"the environment is activated."
msgstr ""

#: ../docs/source/howto/installation.rst:169
msgid ""
"The location of the AiiDA configuration folder, can be controlled with the "
"``AIIDA_PATH`` environment variable. This allows us to change the "
"configuration folder automatically, by adding the following lines to the "
"activation script of a virtual environment. For example, if the path of your"
" virtual environment is ``/home/user/.virtualenvs/aiida``, add the following"
" line:"
msgstr ""

#: ../docs/source/howto/installation.rst:177
msgid ""
"Make sure to reactivate the virtual environment, if it was already active, "
"for the changes to take effect."
msgstr ""

#: ../docs/source/howto/installation.rst:181
msgid ""
"For ``conda``, create a directory structure ``etc/conda/activate.d`` in the "
"root folder of your conda environment (e.g. "
"``/home/user/miniconda/envs/aiida``), and place a file ``aiida-init.sh`` in "
"that folder which exports the ``AIIDA_PATH``."
msgstr ""

#: ../docs/source/howto/installation.rst:183
msgid ""
"You can test that everything works by first echoing the environment variable"
" with ``echo $AIIDA_PATH`` to confirm it prints the correct path. Finally, "
"you can check that AiiDA know also properly realizes the new location for "
"the configuration folder by calling ``verdi profile list``. This should "
"display the current location of the configuration directory:"
msgstr ""

#: ../docs/source/howto/installation.rst:192
msgid ""
"The second line you will only see if you haven't yet setup a profile for "
"this AiiDA instance. For information on setting up a profile, refer to "
":ref:`creating profiles<how-to:installation:profile>`."
msgstr ""

#: ../docs/source/howto/installation.rst:195
msgid ""
"Besides a single path, the value of ``AIIDA_PATH`` can also be a colon-"
"separated list of paths. AiiDA will go through each of the paths and check "
"whether they contain a configuration directory, i.e., a folder with the name"
" ``.aiida``. The first configuration directory that is encountered will be "
"used as the configuration directory. If no configuration directory is found,"
" one will be created in the last path that was considered. For example, the "
"directory structure in your home folder ``~/`` might look like this::"
msgstr ""

#: ../docs/source/howto/installation.rst:207
msgid ""
"If you leave the ``AIIDA_PATH`` variable unset, the default location "
"``~/.aiida`` will be used. However, if you set:"
msgstr ""

#: ../docs/source/howto/installation.rst:214
msgid "the configuration directory ``~/project_a/.aiida`` will be used."
msgstr ""

#: ../docs/source/howto/installation.rst:218
msgid ""
"If there was no ``.aiida`` directory in ``~/project_a``, AiiDA would have "
"created it for you, so make sure to set the ``AIIDA_PATH`` correctly."
msgstr ""

#: ../docs/source/howto/installation.rst:225
msgid "title: Installing plugins"
msgstr ""

#: ../docs/source/howto/installation.rst:227
msgid "`#4122`_"
msgstr ""

#: ../docs/source/howto/installation.rst:233
msgid "Tuning performance"
msgstr ""

#: ../docs/source/howto/installation.rst:235
msgid ""
"AiiDA supports running hundreds of thousands of calculations and graphs with"
" millions of nodes. However, optimal performance at that scale might require"
" some tweaks to the AiiDA configuration to balance the CPU and disk load. "
"Here are a few general tips that might improve the AiiDA performance:"
msgstr ""

#: ../docs/source/howto/installation.rst:241
msgid ""
"Many Linux distributions include the ``locate`` command to quickly find "
"files and folders, and run a daily cron job ``updatedb.mlocate`` to create "
"the corresponding index. A large file repository can take a long time to "
"index, up to the point where the hard drive is constantly indexing."
msgstr ""

#: ../docs/source/howto/installation.rst:244
msgid ""
"In order to exclude the repository folder from indexing, add its path to the"
" ``PRUNEPATH`` variable in the ``/etc/updatedb.conf`` configuration file "
"(use ``sudo``)."
msgstr ""

#: ../docs/source/howto/installation.rst:248
msgid ""
"The verdi deamon can manage an arbitrary number of parallel workers; by "
"default only one is activated. If ``verdi daemon status`` shows the daemon "
"worker(s) constantly at high CPU usage, use ``verdi daemon incr X`` to add "
"``X`` daemon workers. It is recommended that the number of workers does not "
"exceed the number of CPU cores. Ideally, if possible, one should use one or "
"two cores less than the machine has, to avoid to degrade the PostgreSQL "
"database performance."
msgstr ""

#: ../docs/source/howto/installation.rst:255
msgid ""
"Stop the AiiDA daemon and :ref:`back up your database <how-"
"to:installation:backup:postgresql>`."
msgstr ""

#: ../docs/source/howto/installation.rst:257
msgid ""
"Find the data directory of your postgres installation (something like "
"``/var/lib/postgresql/9.6/main``, ``/scratch/postgres/9.6/main``, ...)."
msgstr ""

#: ../docs/source/howto/installation.rst:259
msgid ""
"The best way is to become the postgres UNIX user and enter the postgres "
"shell::"
msgstr ""

#: ../docs/source/howto/installation.rst:265
msgid ""
"If you are unable to enter the postgres shell, try looking for the "
"``data_directory`` variable in a file "
"``/etc/postgresql/9.6/main/postgresql.conf`` or similar."
msgstr ""

#: ../docs/source/howto/installation.rst:267
msgid "Stop the postgres database service::"
msgstr ""

#: ../docs/source/howto/installation.rst:271
msgid ""
"Copy all files and folders from the postgres ``data_directory`` to the new "
"location::"
msgstr ""

#: ../docs/source/howto/installation.rst:293
msgid ""
"Point the ``data_directory`` variable in your postgres configuration file "
"(e.g. ``/etc/postgresql/9.6/main/postgresql.conf``) to the new directory."
msgstr ""

#: ../docs/source/howto/installation.rst:295
msgid "Restart the database daemon::"
msgstr ""

#: ../docs/source/howto/installation.rst:299
msgid "Finally, check that the data directory has indeed changed::"
msgstr ""

#: ../docs/source/howto/installation.rst:305
msgid ""
"and try a simple AiiDA query with the new database. If everything went fine,"
" you can delete the old database location."
msgstr ""

#: ../docs/source/howto/installation.rst:311
msgid "Updating your installation"
msgstr ""

#: ../docs/source/howto/installation.rst:313
msgid ""
"Whenever updating your AiiDA installation, make sure you follow these "
"instructions **very carefully**, even when merely upgrading the patch "
"version! Failing to do so, may leave your installation in a broken state, or"
" worse may even damage your data, potentially irreparably."
msgstr ""

#: ../docs/source/howto/installation.rst:316
msgid "Activate the Python environment where AiiDA is installed."
msgstr ""

#: ../docs/source/howto/installation.rst:317
msgid ""
"Finish all running processes. All finished processes will be automatically "
"migrated, but it is not possible to resume unfinished processes."
msgstr ""

#: ../docs/source/howto/installation.rst:319
msgid "Stop the daemon using ``verdi daemon stop``."
msgstr ""

#: ../docs/source/howto/installation.rst:320
msgid ""
":ref:`Create a backup of your database and repository<how-"
"to:installation:backup>`."
msgstr ""

#: ../docs/source/howto/installation.rst:324
msgid ""
"Once you have migrated your database, you can no longer go back to an older "
"version of ``aiida-core`` (unless you restore your database and repository "
"from a backup)."
msgstr ""

#: ../docs/source/howto/installation.rst:326
msgid "Update your ``aiida-core`` installation."
msgstr ""

#: ../docs/source/howto/installation.rst:328
msgid ""
"If you have installed AiiDA through ``conda`` simply run: ``conda update "
"aiida-core``."
msgstr ""

#: ../docs/source/howto/installation.rst:329
msgid ""
"If you have installed AiiDA through ``pip`` simply run: ``pip install "
"--upgrade aiida-core``."
msgstr ""

#: ../docs/source/howto/installation.rst:330
msgid ""
"If you have installed from the git repository using ``pip install -e .``, "
"first delete all the ``.pyc`` files (``find . -name \"*.pyc\" -delete``) "
"before updating your branch with ``git pull``."
msgstr ""

#: ../docs/source/howto/installation.rst:332
msgid "Run `reentry scan` to update the cache of registered entry points."
msgstr ""

#: ../docs/source/howto/installation.rst:334
msgid ""
"Migrate your database with ``verdi -p <profile_name> database migrate``. "
"Depending on the size of your database and the number of migrations to "
"perform, data migration can take time, so please be patient."
msgstr ""

#: ../docs/source/howto/installation.rst:337
msgid ""
"After the database migration finishes, you will be able to continue working "
"with your existing data."
msgstr ""

#: ../docs/source/howto/installation.rst:340
msgid ""
"If the update involved a change in the major version number of ``aiida-"
"core``, expect backwards incompatible changes and check whether you also "
"need to update installed plugin packages."
msgstr ""

#: ../docs/source/howto/installation.rst:343
msgid "Updating from 0.x.* to 1.*"
msgstr ""

#: ../docs/source/howto/installation.rst:344
msgid ""
"`Additional instructions on how to migrate from 0.12.x versions "
"<https://aiida.readthedocs.io/projects/aiida-"
"core/en/v1.2.1/install/updating_installation.html#updating-"
"from-0-12-to-1>`_."
msgstr ""

#: ../docs/source/howto/installation.rst:345
msgid ""
"`Additional instructions on how to migrate from versions 0.4 -- 0.11 "
"<https://aiida.readthedocs.io/projects/aiida-"
"core/en/v1.2.1/install/updating_installation.html#older-versions>`_."
msgstr ""

#: ../docs/source/howto/installation.rst:346
msgid ""
"For a list of breaking changes between the 0.x and the 1.x series of AiiDA, "
"check `this page <https://aiida.readthedocs.io/projects/aiida-"
"core/en/v1.2.1/install/updating_installation.html#breaking-changes-"
"from-0-12-to-1>`_."
msgstr ""

#: ../docs/source/howto/installation.rst:354
msgid "Backing up your installation"
msgstr ""

#: ../docs/source/howto/installation.rst:356
msgid ""
"A full backup of an AiiDA instance and AiiDA managed data requires a backup "
"of:"
msgstr ""

#: ../docs/source/howto/installation.rst:358
msgid ""
"the profile configuration in the ``config.json`` file located in the "
"``.aiida`` folder. Typically located at ``~/.aiida`` (see also "
":ref:`intro:install:setup`)."
msgstr ""

#: ../docs/source/howto/installation.rst:361
msgid ""
"files associated with nodes in the repository folder (one per profile). "
"Typically located in the ``.aiida`` folder."
msgstr ""

#: ../docs/source/howto/installation.rst:363
msgid "queryable metadata in the PostgreSQL database (one per profile)."
msgstr ""

#: ../docs/source/howto/installation.rst:369
msgid "Repository backup (``.aiida`` folder)"
msgstr ""

#: ../docs/source/howto/installation.rst:371
msgid ""
"For **small repositories** (with less than ~100k files), simply back up the "
"``.aiida`` folder using standard backup software. For example, the ``rsync``"
" utility supports incremental backups, and a backup command might look like "
"``rsync -avHzPx`` (verbose) or ``rsync -aHzx``."
msgstr ""

#: ../docs/source/howto/installation.rst:374
msgid ""
"For **large repositories** with millions of files, even incremental backups "
"can take a significant amount of time. AiiDA provides a helper script that "
"takes advantage of the AiiDA database in order to figure out which files "
"have been added since your last backup. The instructions below explain how "
"to use it:"
msgstr ""

#: ../docs/source/howto/installation.rst:378
msgid ""
"Configure your backup using ``verdi -p PROFILENAME devel configure-backup`` "
"where ``PROFILENAME`` is the name of the AiiDA profile that should be backed"
" up. This will ask for information on:"
msgstr ""

#: ../docs/source/howto/installation.rst:381
msgid ""
"The \"backup folder\", where the backup *configuration file* will be placed."
" This defaults to a folder named ``backup_PROFILENAME`` in your ``.aiida`` "
"directory."
msgstr ""

#: ../docs/source/howto/installation.rst:384
msgid ""
"The \"destination folder\", where the files of the backup will be stored. "
"This defaults to a subfolder of the backup folder but we **strongly suggest "
"to back up to a different drive** (see note below)."
msgstr ""

#: ../docs/source/howto/installation.rst:387
msgid ""
"The configuration step creates two files in the \"backup folder\": a "
"``backup_info.json`` configuration file (can also be edited manually) and a "
"``start_backup.py`` script."
msgstr ""

#: ../docs/source/howto/installation.rst:391
msgid ""
"Using the same disk for your backup forgoes protection against the most "
"common cause of data loss: disk failure. One simple option is to use a "
"destination folder mounted over ssh."
msgstr ""

#: ../docs/source/howto/installation.rst:394
msgid ""
"On Ubuntu, install ``sshfs`` using ``sudo apt-get install sshfs``. Imagine "
"you run your calculations on `server_1` and would like to back up regularly "
"to `server_2`. Mount a `server_2` directory on `server_1` using the "
"following command on `server_1`:"
msgstr ""

#: ../docs/source/howto/installation.rst:402
msgid ""
"Use ``gnome-session-properties`` in the terminal to add this line to the "
"actions performed at start-up. Do **not** add it to your shell's startup "
"file (e.g. ``.bashrc``) or your computer will complain that the mount point "
"is not empty whenever you open a new terminal."
msgstr ""

#: ../docs/source/howto/installation.rst:405
msgid ""
"Run the ``start_backup.py`` script in the \"backup folder\" to start the "
"backup."
msgstr ""

#: ../docs/source/howto/installation.rst:407
msgid ""
"This will back up all data added after the ``oldest_object_backedup`` date. "
"It will only carry out a new backup every ``periodicity`` days, until a "
"certain end date if specified (using ``end_date_of_backup`` or "
"``days_to_backup``), see :ref:`this reference page <reference:backup-script-"
"config-options>` for a detailed description of all options."
msgstr ""

#: ../docs/source/howto/installation.rst:410
msgid ""
"Once you've checked that it works, make sure to run the script periodically "
"(e.g. using a daily cron job)."
msgstr ""

#: ../docs/source/howto/installation.rst:414
msgid ""
"This is a quick note on how to setup a cron job on Linux (you can find many "
"more resources online)."
msgstr ""

#: ../docs/source/howto/installation.rst:416
msgid "On Ubuntu, you can set up a cron job using:"
msgstr ""

#: ../docs/source/howto/installation.rst:422
msgid "It will open an editor, where you can add a line of the form::"
msgstr ""

#: ../docs/source/howto/installation.rst:426
msgid "or (if you need to backup a different profile than the default one)::"
msgstr ""

#: ../docs/source/howto/installation.rst:430
msgid ""
"This will launch the backup of the database every day at 3 AM (03:00), and "
"send the output (or any error message) to the email address specified at the"
" end (provided the ``mail`` command -- from ``mailutils`` -- is configured "
"appropriately)."
msgstr ""

#: ../docs/source/howto/installation.rst:434
msgid ""
"You might want to exclude the file repository from any separately set up "
"automatic backups of your home directory."
msgstr ""

#: ../docs/source/howto/installation.rst:439
msgid "Database backup"
msgstr ""

#: ../docs/source/howto/installation.rst:441
msgid ""
"PostgreSQL typically spreads database information over multiple files that, "
"if backed up directly, are not guaranteed to restore the database. We "
"therefore strongly recommend to periodically dump the database contents to a"
" file (which you can then back up using your method of choice)."
msgstr ""

#: ../docs/source/howto/installation.rst:444
msgid "A few useful pointers:"
msgstr ""

#: ../docs/source/howto/installation.rst:446
msgid ""
"In order to avoid having to enter your database password each time you use "
"the script, you can create a file ``.pgpass`` in your home directory "
"containing your database credentials, as described `in the PostgreSQL "
"documentation <https://www.postgresql.org/docs/12/libpq-pgpass.html>`_."
msgstr ""

#: ../docs/source/howto/installation.rst:448
msgid ""
"In order to dump your database, use the `pg_dump utility from PostgreSQL "
"<https://www.postgresql.org/docs/12/app-pgdump.html>`_. You can use as a "
"starting example a bash script similar to :download:`this file "
"<include/backup_postgresql.sh>`."
msgstr ""

#: ../docs/source/howto/installation.rst:450
msgid ""
"You can setup the backup script to run daily using cron (see notes in the "
":ref:`previous section <how-to:installation:backup:repository>`)."
msgstr ""

#: ../docs/source/howto/installation.rst:455
msgid "Restore backup"
msgstr ""

#: ../docs/source/howto/installation.rst:457
msgid "In order to restore a backup, you will need to:"
msgstr ""

#: ../docs/source/howto/installation.rst:459
msgid ""
"Restore the repository folder that you backed up earlier in the same "
"location as it used to be (you can check the location in the ``config.json``"
" file inside your ``.aiida`` folder, or simply using ``verdi profile "
"show``)."
msgstr ""

#: ../docs/source/howto/installation.rst:461
msgid ""
"Create an empty database following the instructions described in "
":ref:`database <intro:install:database>` skipping the ``verdi setup`` phase."
" The database should have the same name and database username as the "
"original one (i.e. if you are restoring on the original postgresql cluster, "
"you may have to either rename or delete the original database)."
msgstr ""

#: ../docs/source/howto/installation.rst:464
msgid ""
"Change directory to the folder containing the database dump created with "
"``pg_dump``, and load it using the ``psql`` command."
msgstr ""

#: ../docs/source/howto/installation.rst:468
msgid ""
"This is an example command, assuming that your dump is named ``aiidadb-"
"backup.psql``:"
msgstr ""

#: ../docs/source/howto/installation.rst:474
msgid ""
"After supplying your database password, the database should be restored. "
"Note that, if you installed the database on Ubuntu as a system service, you "
"need to type ``sudo su - postgres`` to become the ``postgres`` UNIX user."
msgstr ""

#: ../docs/source/howto/installation.rst:480
msgid "Running on supercomputers"
msgstr ""

#: ../docs/source/howto/installation.rst:485
msgid "Using passphrase-protected SSH keys via a ssh-agent"
msgstr ""

#: ../docs/source/howto/installation.rst:487
msgid ""
"In order to connect to a remote computer using the ``SSH`` transport, AiiDA "
"needs a password-less login: for this reason, it is necessary to configure "
"an authentication key pair."
msgstr ""

#: ../docs/source/howto/installation.rst:489
msgid ""
"Using a passphrase to encrypt the private key is not mandatory, however it "
"is highly recommended. In some cases it is indispensable because it is "
"requested by the computer center managing the remote cluster. To this "
"purpose, the use of a tool like ``ssh-agent`` becomes essential, so that the"
" private-key passphrase only needs to be supplied once (note that the key "
"needs to be provided again after a reboot of your AiiDA machine)."
msgstr ""

#: ../docs/source/howto/installation.rst:494
msgid "Starting the ssh-agent"
msgstr ""

#: ../docs/source/howto/installation.rst:496
msgid ""
"In the majority of modern Linux systems for desktops/laptops, the ``ssh-"
"agent`` automatically starts during login. In some cases (e.g. virtual "
"machines, or old distributions) it is needed to start it manually instead. "
"If you are unsure, just run the command ``ssh-add``: if it displays the "
"error ``Could not open a connection to your authentication agent``, then you"
" need to start the agent manually as described below."
msgstr ""

#: ../docs/source/howto/installation.rst:502
msgid ""
"If you have no ``ssh-agent`` running, you can start a new one with the "
"command:"
msgstr ""

#: ../docs/source/howto/installation.rst:508
msgid ""
"However, this command will start a new agent that will be visible **only in "
"your current shell**."
msgstr ""

#: ../docs/source/howto/installation.rst:510
msgid ""
"In order to use the same agent instance in every future opened shell, and "
"most importantly to make this accessible to the AiiDA daemon, you need to "
"make sure that the environment variables of ``ssh-agent`` are reused by "
"*all* shells."
msgstr ""

#: ../docs/source/howto/installation.rst:512
msgid ""
"To make the ssh-agent persistent, downlod the script :download:`load-"
"singlesshagent.sh <include/load-singlesshagent.sh>` and put it in a "
"directory dedicated to the storage of your scripts (in our example will be "
"``~/bin``)."
msgstr ""

#: ../docs/source/howto/installation.rst:516
msgid ""
"You need to use this script only if a \"global\" ssh-agent is not available "
"by default on your computer. A global agent is available, for instance, on "
"recent versions of Mac OS X and of Ubuntu Linux."
msgstr ""

#: ../docs/source/howto/installation.rst:519
msgid "Then edit the file ``~/.bashrc`` and add the following lines:"
msgstr ""

#: ../docs/source/howto/installation.rst:527
msgid "To check that it works, perform the following steps:"
msgstr ""

#: ../docs/source/howto/installation.rst:529
msgid "Open a new shell, so that the ``~/.bashrc`` file is sourced."
msgstr ""

#: ../docs/source/howto/installation.rst:530
msgid "Run the command ``ssh-add`` as described in the following section."
msgstr ""

#: ../docs/source/howto/installation.rst:531
msgid "Logout from the current shell."
msgstr ""

#: ../docs/source/howto/installation.rst:532
msgid "Open a new shell."
msgstr ""

#: ../docs/source/howto/installation.rst:533
msgid ""
"Check that you are able to connect to the remote computer without typing the"
" passphrase."
msgstr ""

#: ../docs/source/howto/installation.rst:536
msgid "Adding the passphrase of your key(s) to the agent"
msgstr ""

#: ../docs/source/howto/installation.rst:538
msgid ""
"To provide the passphrase of your private key to the the agent use the "
"command:"
msgstr ""

#: ../docs/source/howto/installation.rst:544
msgid ""
"If you changed the default position or the default name of the private key, "
"or you want to provide the passphrase only for a specific key, you need "
"specify the path to the SSH key file as a parameter to ``ssh-add``."
msgstr ""

#: ../docs/source/howto/installation.rst:546
msgid ""
"The private key and the relative passphrase are now recorded in an instance "
"of the agent."
msgstr ""

#: ../docs/source/howto/installation.rst:550
msgid ""
"The passphase is stored in the agent only until the next reboot. If you shut"
" down or restart the AiiDA machine, before starting the AiiDA deamon "
"remember to run the ``ssh-add`` command again."
msgstr ""

#: ../docs/source/howto/installation.rst:554
msgid "Configure AiiDA"
msgstr ""

#: ../docs/source/howto/installation.rst:556
msgid ""
"In order to use the agent in AiiDA, you need to first make sure that you can"
" connect to the computer via SSH without explicitly specifying a passphrase."
" Make sure that this is the case also in newly opened bash shells."
msgstr ""

#: ../docs/source/howto/installation.rst:559
msgid ""
"Then, when configuring the corresponding AiiDA computer (via ``verdi "
"computer configure``), make sure to specify ``true`` to the question ``Allow"
" ssh agent``. If you already configured the computer and just want to adapt "
"the computer configuration, just rerun"
msgstr ""

#: ../docs/source/howto/installation.rst:566
msgid ""
"After the configuration, you should verify that AiiDA can connect to the "
"computer with:"
msgstr ""

#: ../docs/source/howto/installation.rst:576
msgid "Avoiding overloads"
msgstr ""

#: ../docs/source/howto/installation.rst:578
msgid ""
"If you submit to a supercomputer shared by many users (e.g., in a "
"supercomputer center), be careful not to overload the supercomputer with too"
" many jobs:"
msgstr ""

#: ../docs/source/howto/installation.rst:580
msgid ""
"limit the number of jobs in the queue (the exact number depends on the "
"supercomputer: discuss this with your supercomputer administrators, and you "
"can redirect them to :ref:`this page<how-to:installation:running-on-"
"supercomputers:for_cluster_admins>` that may contain useful information for "
"them). While in the future `this might be dealt with by AiiDA automatically "
"<https://github.com/aiidateam/aiida-core/issues/88>`_, you are responsible "
"for this at the moment. This can be achieved for instance by submitting only"
" a maximum number of workflows to AiiDA, and submitting new ones only when "
"the previous ones complete."
msgstr ""

#: ../docs/source/howto/installation.rst:585
msgid ""
"Tune the parameters that AiiDA uses to avoid overloading the supercomputer "
"with connections or batch requests. For SSH transports, the default is 30 "
"seconds, which means that when each worker opens a SSH connection to a "
"computer, it will reuse it as long as there are tasks to execute and then "
"close it. Opening a new connection will not happen before 30 seconds has "
"passed from the opening of the previous one."
msgstr ""

#: ../docs/source/howto/installation.rst:589
msgid ""
"We stress that this is *per daemon worker*, so that if you have 10 workers, "
"your supercomputer will on average see 10 connections every 30 seconds. "
"Therefore, if you are using many workers and you mostly have long-running "
"jobs, you can set a longer time (e.g., 120 seconds) by reconfiguring the "
"computer with ``verdi computer configure ssh <COMPUTER_NAME>`` and changing "
"the value of the *Connection cooldown time* or, alternatively, by running:"
msgstr ""

#: ../docs/source/howto/installation.rst:597
msgid ""
"In addition to the connection cooldown time described above, AiiDA also "
"limits the frequency for retrieving the job queue from the scheduler "
"(``squeue``, ``qstat``, ...), as this can also impact the performance of the"
" scheduler. For a given computer, you can increase how many seconds must "
"pass between requests. First load the computer in a shell with ``computer = "
"load_computer(<COMPUTER_NAME>)``. You can check the current value in seconds"
" (by default, 10) with ``computer.get_minimum_job_poll_interval()``. You can"
" then set it to a higher value using:"
msgstr ""

#: ../docs/source/howto/installation.rst:610
msgid "Optimising the SLURM scheduler configuration"
msgstr ""

#: ../docs/source/howto/installation.rst:612
msgid ""
"If too many jobs are submitted at the same time to the queue, SLURM might "
"have trouble in dealing with new submissions. If you are a cluster "
"administrator, you might be interested in `some tips available in the AiiDA "
"wiki <https://github.com/aiidateam/aiida-core/wiki/Optimising-the-SLURM-"
"scheduler-configuration-(for-cluster-administrators)>`_, suggested by "
"sysadmins at the Swiss Supercomputer Centre `CSCS <http://www.cscs.ch>`_ (or"
" you can redirect your admin to this page if your cluster is experiencing "
"slowness related to a large number of submitted jobs)."
msgstr ""

#: ../docs/source/howto/installation.rst:618
msgid "Managing multiple users"
msgstr ""

#: ../docs/source/howto/installation.rst:619
msgid ""
"Setups with multiple users for a single AiiDA instance are currently not "
"supported. Instead, each AiiDA user should install AiiDA in a Unix/Windows "
"account on their own computer. Under this account it is possible to "
"configure all the credentials necessary to connect to remote computers. "
"Using independent accounts will ensure that, for instance, the SSH "
"credentials to connect to supercomputers are not shared with others."
msgstr ""

#: ../docs/source/howto/installation.rst:624
msgid ""
"Data can be shared between instances using :ref:`AiiDA's export and import "
"functionality <how-to:data:share>`. Sharing (subsets of) the AiiDA graph can"
" be done as often as needed."
msgstr ""

#: ../docs/source/howto/plugins.rst:5
msgid "How to package plugins"
msgstr ""

#: ../docs/source/howto/plugins.rst:7
msgid ""
"This section focuses on how to *package* AiiDA extensions (plugins) so that "
"they can be tested, published and eventually reused by others. For guides on"
" writing specific extensions, see :ref:`how-to:codes:interfacing` and :ref"
":`how-to:data:plugin`."
msgstr ""

#: ../docs/source/howto/plugins.rst:12
msgid ""
"For guides on writing specific extensions, see :ref:`how-"
"to:codes:interfacing`, -ref-'how-to:codes:scheduler', -ref-'how-"
"to:codes:transport' or :ref:`how-to:data:plugin`."
msgstr ""

#: ../docs/source/howto/plugins.rst:18
msgid "Creating a plugin package"
msgstr ""

#: ../docs/source/howto/plugins.rst:21
msgid ""
"AiiDA plugins can be bundled and distributed in a `Python package "
"<packages>`_ that provides a set of extensions to AiiDA."
msgstr ""

#: ../docs/source/howto/plugins.rst:25
msgid ""
"The Python community uses the term 'package' rather loosely. Depending on "
"context, it may refer simply to a folder containing individual Python "
"modules or it may include the files necessary for building and installing a "
"package to be distributed via the `Python Package Index (PyPI) <pypi>`_."
msgstr ""

#: ../docs/source/howto/plugins.rst:32
msgid "Quickstart"
msgstr ""

#: ../docs/source/howto/plugins.rst:34
msgid ""
"The fastest way to jumpstart an AiiDA plugin package is to use the `AiiDA "
"plugin cutter <plugin-cutter>`_ in order to template the basic folder "
"structure, already customized according to the desired name of your plugin, "
"following AiiDA conventions."
msgstr ""

#: ../docs/source/howto/plugins.rst:36
msgid ""
"Simply go to the `AiiDA plugin cutter <plugin-cutter>`_ and follow the usage"
" instructions. See also the `aiida-diff`_ demo plugin package for an in-"
"depth explanation of the files & folders produced by the plugin cutter."
msgstr ""

#: ../docs/source/howto/plugins.rst:39
msgid ""
"In the following, we explain some of the conventions implemented by the "
"AiiDA plugin cutter."
msgstr ""

#: ../docs/source/howto/plugins.rst:43
msgid "Choosing a name"
msgstr ""

#: ../docs/source/howto/plugins.rst:45
msgid ""
"The naming convention for AiiDA plugin packages is ``aiida-mycode`` for the "
"plugin distribution on `PyPI`_ and ``aiida_mycode`` for the corresponding "
"python package, leading to the following folder structure::"
msgstr ""

#: ../docs/source/howto/plugins.rst:53
msgid "Python package names cannot contain dashes, thus the underscore."
msgstr ""

#: ../docs/source/howto/plugins.rst:55
msgid ""
"If you intend to eventually publish your plugin package, please go to the "
"`AiiDA plugin registry <registry>`_  and choose a name that is not already "
"taken. You are also encouraged to pre-register your package (instructions "
"provided on the registry), both to reserve your plugin name and to inform "
"others of your ongoing development."
msgstr ""

#: ../docs/source/howto/plugins.rst:62 ../docs/source/howto/plugins.rst:144
msgid "Folder structure"
msgstr ""

#: ../docs/source/howto/plugins.rst:64
msgid ""
"The overall folder structure of your plugin is up to you, but it is useful "
"to follow a set of basic conventions. Here is an example of a folder "
"structure for an AiiDA plugin, illustrating different levels of nesting (see"
" also the `aiida-diff demo plugin`_)::"
msgstr ""

#: ../docs/source/howto/plugins.rst:91
msgid "A minimal plugin package instead might look like::"
msgstr ""

#: ../docs/source/howto/plugins.rst:102
msgid "Registering plugins through entry points"
msgstr ""

#: ../docs/source/howto/plugins.rst:104
msgid ""
"An AiiDA plugin is an extension of AiiDA that announces itself by means of a"
" new *entry point* (for details, see :ref:`topics:plugins:entrypoints`). "
"Adding a new entry point consists of the following steps:"
msgstr ""

#: ../docs/source/howto/plugins.rst:107
msgid ""
"Deciding a name. We *strongly* suggest to start the name of each entry point"
" with the name of the plugin package (omitting the 'aiida-' prefix). For a "
"package ``aiida-mycode``, this will usually mean ``\"mycode.<something>\"``"
msgstr ""

#: ../docs/source/howto/plugins.rst:111
msgid ""
"Finding the right entry point group. You can list the entry point groups "
"defined by AiiDA via ``verdi plugin list``. For a documentation of the "
"groups, see :ref:`topics:plugins:entrypointgroups`."
msgstr ""

#: ../docs/source/howto/plugins.rst:114
msgid ""
"Adding the entry point to the ``entry_points`` field in the ``setup.json`` "
"file::"
msgstr ""

#: ../docs/source/howto/plugins.rst:124
msgid ""
"Let setuptools and reentry know about your entry point by installing your "
"plugin again::"
msgstr ""

#: ../docs/source/howto/plugins.rst:129
msgid ""
"Your new entry point should now show up in ``verdi plugin list "
"aiida.calculations``."
msgstr ""

#: ../docs/source/howto/plugins.rst:135
msgid "Testing a plugin package"
msgstr ""

#: ../docs/source/howto/plugins.rst:137
msgid ""
"Writing tests for your AiiDA plugins and running continuous integration "
"tests using free platforms like `GitHub Actions <ghactions>`_ is the best "
"way to ensure that your plugin works and keeps working as it is being "
"developed. We recommend using the `pytest`_ framework for testing AiiDA "
"plugins."
msgstr ""

#: ../docs/source/howto/plugins.rst:140
msgid ""
"For an example of how to write tests and how to set up continuous "
"integration, see the `aiida-diff`_ demo plugin package."
msgstr ""

#: ../docs/source/howto/plugins.rst:146
msgid ""
"We suggest the following folder structure for including tests in AiiDA "
"plugin packages::"
msgstr ""

#: ../docs/source/howto/plugins.rst:153
msgid ""
"Keeping the tests outside the plugin package keeps the distribution of your "
"plugin package light."
msgstr ""

#: ../docs/source/howto/plugins.rst:156
msgid "AiiDA's fixtures"
msgstr ""

#: ../docs/source/howto/plugins.rst:158
msgid ""
"Many tests require a full AiiDA environment to be set up before the test "
"starts, e.g. some AiiDA data nodes. The pytest library has the concept of "
"`fixtures`_ for encapsulating code you would like to run before a test "
"starts. AiiDA ships with a number of fixtures in "
":py:mod:`aiida.manage.tests.pytest_fixtures` that take care of setting up "
"the test environment for you (for more details, see "
":ref:`topics:plugins:testfixtures`)."
msgstr ""

#: ../docs/source/howto/plugins.rst:162
msgid ""
"In order to make these fixtures available to your tests, create a "
"``conftest.py`` (see also `pytest docs <conftest>`_) at the root level of "
"your plugin package as follows::"
msgstr ""

#: ../docs/source/howto/plugins.rst:180
msgid ""
"You can now start writing tests e.g. in a ``tests/test_calculations.py`` "
"file::"
msgstr ""

#: ../docs/source/howto/plugins.rst:200
msgid ""
"In order to run your tests, simply type ``pytest`` at the root level or your"
" package. pytest automatically discovers and executes files, classes and "
"function names starting with the word ``test``."
msgstr ""

#: ../docs/source/howto/plugins.rst:210
msgid "Documenting a plugin package"
msgstr ""

#: ../docs/source/howto/plugins.rst:212
msgid ""
"AiiDA plugin packages are python packages, and general `best practises for "
"writing python documentation <https://docs.python-"
"guide.org/writing/documentation/>`_ apply."
msgstr ""

#: ../docs/source/howto/plugins.rst:214
msgid ""
"In the following, we mention a few hints that apply specifically to AiiDA "
"plugins."
msgstr ""

#: ../docs/source/howto/plugins.rst:217
msgid "Repository-level documentation"
msgstr ""

#: ../docs/source/howto/plugins.rst:219
msgid ""
"Since the source code of most AiiDA plugins is hosted on GitHub, the first "
"contact of a new user with your plugin package is likely the landing page of"
" your GitHub repository."
msgstr ""

#: ../docs/source/howto/plugins.rst:221
msgid ""
"Make sure to have a useful ``README.md``, describing what your plugin does "
"and how to install it."
msgstr ""

#: ../docs/source/howto/plugins.rst:222
msgid "Leaving a contact email and adding a license is also a good idea."
msgstr ""

#: ../docs/source/howto/plugins.rst:223
msgid ""
"Make sure the information in the ``setup.json`` file is correct and up to "
"date (in particular the version number), since this information is used to "
"advertise your package on the AiiDA plugin registry."
msgstr ""

#: ../docs/source/howto/plugins.rst:226
msgid "Source-code-level documentation"
msgstr ""

#: ../docs/source/howto/plugins.rst:228
msgid ""
"Source-code level documentations matters both for users of your plugin's "
"python API and, particularly, for attracting contributions from others."
msgstr ""

#: ../docs/source/howto/plugins.rst:230
msgid ""
"When adding new types of calculations or workflows, make sure to use "
"`docstrings <https://www.python.org/dev/peps/pep-0257/#what-"
"is-a-docstring>`_, and use the ``help`` argument to document input ports and"
" output ports. Users of your plugin can then inspect which inputs the "
"calculations/workflows expect and which outputs they produce directly "
"through the ``verdi`` cli. For example, try::"
msgstr ""

#: ../docs/source/howto/plugins.rst:237
msgid "Documentation website"
msgstr ""

#: ../docs/source/howto/plugins.rst:239
msgid ""
"For simple plugins, a well-written ``README.md`` can be a good start. Once "
"the README grows out of proportion, you may want to consider creating a "
"dedicated documentation website."
msgstr ""

#: ../docs/source/howto/plugins.rst:242
msgid ""
"The `Sphinx <http://www.sphinx-doc.org/en/master/>`_ tool makes it very easy"
" to create documentation websites for python packages, and the `ReadTheDocs "
"<http://readthedocs.org/>`_ service will host your sphinx documentation "
"online for free. The `aiida-diff demo plugin <aiida-diff>`_ comes with a "
"full template for a sphinx-based documentation, including a mix of manually "
"written pages and an automatically generated documentation of your plugin's "
"python API. See the `developer guide of aiida-diff <https://aiida-"
"diff.readthedocs.io/en/latest/developer_guide/index.html>`_ for instructions"
" on how to build it."
msgstr ""

#: ../docs/source/howto/plugins.rst:246
msgid ""
"AiiDA provides a sphinx extension for inserting automatically generated "
"documentations of ``Process`` classes (calculations and workflows) into your"
" sphinx documentation (analogous to the information displayed by ``verdi "
"plugin list``). Enable the extension by adding ``aiida.sphinxext`` to the "
"list of ``extensions`` in your ``docs/conf.py`` file. You can now use the "
"``aiida-process``, ``aiida-calcjob`` or ``aiida-workchain`` directives in "
"your ReST files like so::"
msgstr ""

#: ../docs/source/howto/plugins.rst:254
msgid "Here,"
msgstr ""

#: ../docs/source/howto/plugins.rst:256
msgid "``MyWorkChain`` is the name of the workchain to be documented."
msgstr ""

#: ../docs/source/howto/plugins.rst:257
msgid ""
"``:module:`` is the python module from which the workchain can be imported."
msgstr ""

#: ../docs/source/howto/plugins.rst:258
msgid ""
"``:hide-unstored-inputs:`` hides workchain inputs that are not stored in the"
" database (shown by default)."
msgstr ""

#: ../docs/source/howto/plugins.rst:262
msgid ""
"The ``aiida-workchain`` directive is hooked into ``sphinx.ext.autodoc``, "
"i.e. it is used automatically by the generic ``automodule``, ``autoclass`` "
"directives when applied to workchain classes."
msgstr ""

#: ../docs/source/howto/plugins.rst:269
msgid "Publishing a plugin package"
msgstr ""

#: ../docs/source/howto/plugins.rst:271
msgid ""
"AiiDA plugin packages are published on the `AiiDA plugin registry "
"<registry>`_ and the `python package index (PyPI) <pypi>`_."
msgstr ""

#: ../docs/source/howto/plugins.rst:273
msgid "Before publishing your plugin, make sure your plugin comes with:"
msgstr ""

#: ../docs/source/howto/plugins.rst:275
msgid "a ``setup.json`` file with the plugin metadata"
msgstr ""

#: ../docs/source/howto/plugins.rst:276
msgid "a ``setup.py`` file for installing your plugin via ``pip``"
msgstr ""

#: ../docs/source/howto/plugins.rst:277
msgid "a license"
msgstr ""

#: ../docs/source/howto/plugins.rst:279
msgid ""
"For examples of these files, see the `aiida-diff demo plugin <aiida-diff>`_."
msgstr ""

#: ../docs/source/howto/plugins.rst:284
msgid "Publishing on the plugin registry"
msgstr ""

#: ../docs/source/howto/plugins.rst:286
msgid ""
"The `AiiDA plugin registry <registry>`_ aims to be the home for all publicly"
" available AiiDA plugins. It collects information on the type of plugins "
"provided by your package, which AiiDA versions it is compatible with, etc."
msgstr ""

#: ../docs/source/howto/plugins.rst:289
msgid ""
"In order to register your plugin package, simply go to the `plugin registry "
"<registry>`_ and follow the instructions in the README."
msgstr ""

#: ../docs/source/howto/plugins.rst:293
msgid ""
"The plugin registry reads the metadata of your plugin from the "
"``setup.json`` file in your plugin repository."
msgstr ""

#: ../docs/source/howto/plugins.rst:296
msgid ""
"We encourage you to **get your plugin package listed as soon as possible**, "
"both in order to reserve the plugin name and to inform others of the ongoing"
" development."
msgstr ""

#: ../docs/source/howto/plugins.rst:299
msgid "Publishing on PyPI"
msgstr ""

#: ../docs/source/howto/plugins.rst:301
msgid ""
"For distributing AiiDA plugin packages, we recommend to follow the "
"`guidelines for packaging python projects <packaging>`_, which include "
"making the plugin available on the `python package index <PyPI>`_. This "
"makes it possible for users to simply ``pip install aiida-myplugin``."
msgstr ""

#: ../docs/source/howto/plugins.rst:305
msgid ""
"When updating the version of your plugin, don't forget to update the version"
" number both in the ``setup.json`` and in ``aiida_mycode/__init__.py``."
msgstr ""

#: ../docs/source/howto/visualising_graphs/visualising_graphs.rst:8
msgid "How to visualize provenance"
msgstr ""

#: ../docs/source/howto/visualising_graphs/visualising_graphs.rst:10
msgid "graph,graphviz"
msgstr ""

#: ../docs/source/howto/visualising_graphs/visualising_graphs.rst:15
msgid ""
"This tutorial can be downloaded and run as a Jupyter Notebook: "
":download:`visualising_graphs.ipynb`"
msgstr ""

#: ../docs/source/howto/visualising_graphs/visualising_graphs.rst:18
msgid ""
"The provenance graph of a database can be visually inspected, *via* "
"`graphviz <https://www.graphviz.org/>`__, using both the python API and "
"command-line interface."
msgstr ""

#: ../docs/source/howto/visualising_graphs/visualising_graphs.rst:24
msgid "``verdi graph generate -h``"
msgstr ""

#: ../docs/source/howto/visualising_graphs/visualising_graphs.rst:26
msgid "We first load the database and required modules:"
msgstr ""

#: ../docs/source/howto/visualising_graphs/visualising_graphs.rst:38
msgid ""
"The example provenance graph, used in this tutorial, can be downloaded "
":download:`from this link <graph1.aiida>` :fa:`download`"
msgstr ""

#: ../docs/source/howto/visualising_graphs/visualising_graphs.rst:40
msgid "It can then be imported into the database:"
msgstr ""

#: ../docs/source/howto/visualising_graphs/visualising_graphs.rst:51
msgid ""
"The :py:class:`~aiida.tools.visualization.graph.Graph` class is used to "
"store visual representations of the nodes and edges, which can be added "
"separately or cumulatively by one of the graph traversal methods. The "
":py:attr:`~aiida.tools.visualization.graph.Graph.graphviz` attribute returns"
" a `graphviz.Digraph <https://graphviz.readthedocs.io/en/stable/>`__ "
"instance, which will auto-magically render the graph in the notebook, or can"
" be used to save the graph to file."
msgstr ""

#: ../docs/source/howto/visualising_graphs/visualising_graphs.rst:94
msgid ""
"The :py:class:`~aiida.tools.visualization.graph.Graph` can also be "
"initialized with global style attributes, as outlined in the `graphviz "
"attributes table <https://www.graphviz.org/doc/info/attrs.html>`__."
msgstr ""

#: ../docs/source/howto/visualising_graphs/visualising_graphs.rst:112
msgid ""
"Additionally functions can be parsed to the "
":py:class:`~aiida.tools.visualization.graph.Graph` initializer, to specify "
"exactly how each node will be represented. For example, the "
":py:func:`~aiida.tools.visualization.graph.pstate_node_styles` function "
"colors process nodes by their process state."
msgstr ""

#: ../docs/source/howto/visualising_graphs/visualising_graphs.rst:135
msgid ""
"Edges can be annotated by one or both of their edge label and link type."
msgstr ""

#: ../docs/source/howto/visualising_graphs/visualising_graphs.rst:152
msgid ""
"The :meth:`~aiida.tools.visualization.graph.Graph.recurse_descendants` and "
":meth:`~aiida.tools.visualization.graph.Graph.recurse_ancestors` methods can"
" be used to construct a full provenance graph."
msgstr ""

#: ../docs/source/howto/visualising_graphs/visualising_graphs.rst:171
msgid ""
"The link types can also be filtered, to view only the ‘data’ or ‘logical’ "
"provenance."
msgstr ""

#: ../docs/source/howto/visualising_graphs/visualising_graphs.rst:206
msgid ""
"If you wish to highlight specific node classes, then the "
"``highlight_classes`` option can be used to only color specified nodes:"
msgstr ""

#: ../docs/source/howto/workflows.rst:5
msgid "How to run multi-step workflows"
msgstr ""

#: ../docs/source/howto/workflows.rst:10
msgid "Writing workflows"
msgstr ""

#: ../docs/source/howto/workflows.rst:12
msgid ""
"A workflow in AiiDA is a :ref:`process <topics:processes:concepts>` that "
"calls other workflows and calculations and optionally *returns* data and as "
"such can encode the logic of a typical scientific workflow. Currently, there"
" are two ways of implementing a workflow process:"
msgstr ""

#: ../docs/source/howto/workflows.rst:15
msgid ":ref:`work functions<topics:workflows:concepts:workfunctions>`"
msgstr ""

#: ../docs/source/howto/workflows.rst:16
msgid ":ref:`work chains<topics:workflows:concepts:workchains>`"
msgstr ""

#: ../docs/source/howto/workflows.rst:18
msgid ""
"Here we present a brief introduction on how to write both workflow types."
msgstr ""

#: ../docs/source/howto/workflows.rst:22
msgid ""
"For more details on the concept of a workflow, and the difference between a "
"work function and a work chain, please see the corresponding :ref:`topics "
"section<topics:workflows:concepts>`."
msgstr ""

#: ../docs/source/howto/workflows.rst:25
msgid "Work function"
msgstr ""

#: ../docs/source/howto/workflows.rst:27
msgid ""
"A *work function* is a process function that calls one or more calculation "
"functions and *returns* data that has been *created* by the calculation "
"functions it has called. Moreover, work functions can also call other work "
"functions, allowing you to write nested workflows. Writing a work function, "
"whose provenance is automatically stored, is as simple as writing a Python "
"function and decorating it with the "
":class:`~aiida.engine.processes.functions.workfunction` decorator:"
msgstr ""

#: ../docs/source/howto/workflows.rst:35
msgid ""
"It is important to reiterate here that the "
":class:`~aiida.engine.processes.functions.workfunction`-decorated "
"``add_multiply()`` function does not *create* any new data nodes. The "
"``add()`` and ``multiply()`` calculation functions create the ``Int`` data "
"nodes, all the work function does is *return* the results of the "
"``multiply()`` calculation function. Moreover, both calculation and workflow"
" functions can only accept and return data nodes, i.e. instances of classes "
"that subclass the :class:`~aiida.orm.nodes.data.data.Data` class."
msgstr ""

#: ../docs/source/howto/workflows.rst:40
msgid "Work chain"
msgstr ""

#: ../docs/source/howto/workflows.rst:42
msgid ""
"When the workflow you want to run is more complex and takes longer to "
"finish, it is better to write a *work chain*. Writing a work chain in AiiDA "
"requires creating a class that inherits from the "
":class:`~aiida.engine.processes.workchains.workchain.WorkChain` class. Below"
" is an example of a work chain that takes three integers as inputs, "
"multiplies the first two and then adds the third to obtain the final result:"
msgstr ""

#: ../docs/source/howto/workflows.rst:50
msgid ""
"You can give the work chain any valid Python class name, but the convention "
"is to have it end in "
":class:`~aiida.engine.processes.workchains.workchain.WorkChain` so that it "
"is always immediately clear what it references. Let's go over the methods of"
" the ``MultiplyAddWorkChain`` one by one:"
msgstr ""

#: ../docs/source/howto/workflows.rst:58
msgid ""
"The most important method to implement for every work chain is the "
"``define()`` method. This class method must always start by calling the "
"``define()`` method of its parent class. Next, the ``define()`` method "
"should be used to define the specifications of the work chain, which are "
"contained in the work chain ``spec``:"
msgstr ""

#: ../docs/source/howto/workflows.rst:62
msgid ""
"the **inputs**, specified using the ``spec.input()`` method. The first "
"argument of the ``input()`` method is a string that specifies the label of "
"the input, e.g. ``'x'``. The ``valid_type`` keyword argument allows you to "
"specify the required node type of the input. Other keyword arguments allow "
"the developer to set a default for the input, or indicate that an input "
"should not be stored in the database, see :ref:`the process topics section "
"<topics:processes:usage:spec>` for more details."
msgstr ""

#: ../docs/source/howto/workflows.rst:66
msgid ""
"the **outline** or logic of the workflow, specified using the "
"``spec.outline()`` method. The outline of the workflow is constructed from "
"the methods of the "
":class:`~aiida.engine.processes.workchains.workchain.WorkChain` class. For "
"the ``MultiplyAddWorkChain``, the outline is a simple linear sequence of "
"steps, but it's possible to include actual logic, directly in the outline, "
"in order to define more complex workflows as well. See the :ref:`work chain "
"outline section <topics:workflows:usage:workchains:define_outline>` for more"
" details."
msgstr ""

#: ../docs/source/howto/workflows.rst:70
msgid ""
"the **outputs**, specified using the ``spec.output()`` method. This method "
"is very similar in its usage to the ``input()`` method."
msgstr ""

#: ../docs/source/howto/workflows.rst:72
msgid ""
"the **exit codes** of the work chain, specified using the "
"``spec.exit_code()`` method. Exit codes are used to clearly communicate "
"known failure modes of the work chain to the user. The first and second "
"arguments define the ``exit_status`` of the work chain in case of failure "
"(``400``) and the string that the developer can use to reference the exit "
"code (``ERROR_NEGATIVE_NUMBER``). A descriptive exit message can be provided"
" using the ``message`` keyword argument. For the ``MultiplyAddWorkChain``, "
"we demand that the final result is not a negative number, which is checked "
"in the ``validate_result`` step of the outline."
msgstr ""

#: ../docs/source/howto/workflows.rst:80
msgid ""
"For more information on the ``define()`` method and the process spec, see "
"the :ref:`corresponding section in the topics "
"<topics:processes:usage:defining>`."
msgstr ""

#: ../docs/source/howto/workflows.rst:82
msgid ""
"The ``multiply`` method is the first step in the outline of the "
"``MultiplyAddWorkChain`` work chain."
msgstr ""

#: ../docs/source/howto/workflows.rst:90
msgid ""
"This step simply involves running the calculation function ``multiply()``, "
"on the ``x`` and ``y`` **inputs** of the work chain. To store the result of "
"this function and use it in the next step of the outline, it is added to the"
" *context* of the work chain using ``self.ctx``."
msgstr ""

#: ../docs/source/howto/workflows.rst:99
msgid ""
"The ``add()`` method is the second step in the outline of the work chain. As"
" this step uses the ``ArithmeticAddCalculation`` calculation job, we start "
"by setting up the inputs for this "
":class:`~aiida.engine.processes.calcjobs.calcjob.CalcJob` in a dictionary. "
"Next, when submitting this calculation job to the daemon, it is important to"
" use the submit method from the work chain instance via ``self.submit()``. "
"Since the result of the addition is only available once the calculation job "
"is finished, the ``submit()`` method returns the "
":class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode` of the "
"*future* ``ArithmeticAddCalculation`` process. To tell the work chain to "
"wait for this process to finish before continuing the workflow, we return "
"the ``ToContext`` class, where we have passed a dictionary to specify that "
"the future calculation job node should be assigned to the ``'addition'`` "
"context key."
msgstr ""

#: ../docs/source/howto/workflows.rst:107
msgid ""
"Never use the global ``submit()`` function to submit calculations to the "
"daemon within a "
":class:`~aiida.engine.processes.workchains.workchain.WorkChain`. Doing so "
"will raise an exception during runtime. See the :ref:`topics section on work"
" chains<topics:workflows:usage:workchains:submitting_sub_processes>` for "
"more details."
msgstr ""

#: ../docs/source/howto/workflows.rst:112
msgid ""
"Instead of passing a dictionary, you can also initialize a ``ToContext`` "
"instance by passing the future process as a keyword argument, e.g. "
"``ToContext(addition=calcjob_node)``. More information on the ``ToContext`` "
"class can be found in :ref:`the topics section on submitting sub "
"processes<topics:workflows:usage:workchains:submitting_sub_processes>`."
msgstr ""

#: ../docs/source/howto/workflows.rst:121
msgid ""
"Once the ``ArithmeticAddCalculation`` calculation job is finished, the next "
"step in the work chain is to validate the result, i.e. verify that the "
"result is not a negative number. After the ``addition`` node has been "
"extracted from the context, we take the ``sum`` node from the "
"``ArithmeticAddCalculation`` outputs and store it in the ``result`` "
"variable. In case the value of this ``Int`` node is negative, the "
"``ERROR_NEGATIVE_NUMBER`` exit code - defined in the ``define()`` method - "
"is returned. Note that once an exit code is returned during any step in the "
"outline, the work chain will be terminated and no further steps will be "
"executed."
msgstr ""

#: ../docs/source/howto/workflows.rst:132
msgid ""
"The final step in the outline is to pass the result to the outputs of the "
"work chain using the ``self.out()`` method. The first argument "
"(``'result'``) specifies the label of the output, which corresponds to the "
"label provided to the spec in the ``define()`` method. The second argument "
"is the result of the work chain, extracted from the ``Int`` node stored in "
"the context under the ``'addition'`` key."
msgstr ""

#: ../docs/source/howto/workflows.rst:136
msgid ""
"For a more complete discussion on workflows and their usage, please read "
":ref:`the corresponding topics section<topics:workflows:usage>`."
msgstr ""

#: ../docs/source/howto/workflows.rst:141
msgid "Launching a predefined workflow"
msgstr ""

#: ../docs/source/howto/workflows.rst:143
msgid ""
"The first step to launching a predefined workflow is loading the work "
"function or work chain class that defines the workflow you want to run. The "
"recommended method for loading a workflow is using the ``WorkflowFactory``, "
"for example:"
msgstr ""

#: ../docs/source/howto/workflows.rst:152
msgid ""
"This is essentially the same as importing the workflow from its respective "
"module, but using the ``WorkflowFactory`` has the advantage that the so "
"called *entry point* (e.g. ``'arithmetic.multiply_add'``) will not change "
"when the packages or plugins are reorganised. This means your code is less "
"likely to break when updating AiiDA or the plugin that supplies the "
"workflow."
msgstr ""

#: ../docs/source/howto/workflows.rst:155
msgid ""
"The list of installed plugins can be easily accessed via the verdi CLI:"
msgstr ""

#: ../docs/source/howto/workflows.rst:161
msgid "To see the list of workflow entry points, simply use:"
msgstr ""

#: ../docs/source/howto/workflows.rst:167
msgid ""
"By further specifying the entry point of the workflow, you can see its "
"description, inputs, outputs and exit codes:"
msgstr ""

#: ../docs/source/howto/workflows.rst:174
msgid "Work functions"
msgstr ""

#: ../docs/source/howto/workflows.rst:176
msgid ""
"Running a work function is as simple as calling a typical Python function: "
"simply call it with the required input arguments:"
msgstr ""

#: ../docs/source/howto/workflows.rst:186
msgid ""
"Here, the ``add_and_multiply`` work function returns the output ``Int`` node"
" and we assign it to the variable ``result``. Note that the input arguments "
"of a work function must be an instance of ``Data`` node, or any of its "
"subclasses. Just calling the ``add_and_multiply`` function with regular "
"integers will result in a ``ValueError``, as these cannot be stored in the "
"provenance graph."
msgstr ""

#: ../docs/source/howto/workflows.rst:192
msgid ""
"Although the example above shows the most straightforward way to run the "
"``add_and_multiply`` work function, there are several other ways of running "
"processes that can return more than just the result. For example, the "
"``run_get_node`` function from the AiiDA engine returns both the result of "
"the workflow and the work function node. See the :ref:`corresponding topics "
"section for more details <topics:processes:usage:launching>`."
msgstr ""

#: ../docs/source/howto/workflows.rst:197
msgid "Work chains"
msgstr ""

#: ../docs/source/howto/workflows.rst:199
msgid ""
"To launch a work chain, you can either use the ``run`` or ``submit`` "
"functions. For either function, you need to provide the class of the work "
"chain as the first argument, followed by the inputs as keyword arguments. "
"Using the ``run`` function, or \"running\", a work chain means it is "
"executed in the same system process as the interpreter in which it is "
"launched:"
msgstr ""

#: ../docs/source/howto/workflows.rst:214
msgid ""
"Alternatively, you can first construct a dictionary of the inputs, and pass "
"it to the ``run`` function by taking advantage of `Python's automatic "
"keyword expansion <https://docs.python.org/3/tutorial/controlflow.html"
"#unpacking-argument-lists>`_:"
msgstr ""

#: ../docs/source/howto/workflows.rst:221
msgid ""
"This is particularly useful in case you have a workflow with a lot of "
"inputs. In both cases, running the ``MultiplyAddWorkChain`` workflow returns"
" the **results** of the workflow, i.e. a dictionary of the nodes that are "
"produced as outputs, where the keys of the dictionary correspond to the "
"labels of each respective output."
msgstr ""

#: ../docs/source/howto/workflows.rst:226
msgid ""
"Similar to other processes, there are multiple functions for launching a "
"work chain. See the section on :ref:`launching processes for more "
"details<topics:processes:usage:launching>`."
msgstr ""

#: ../docs/source/howto/workflows.rst:229
msgid ""
"Since *running* a workflow will block the interpreter, you will have to wait"
" until the workflow is finished before you get back control. Moreover, you "
"won't be able to turn your computer or even your terminal off until the "
"workflow has fully terminated, and it is difficult to run multiple workflows"
" in parallel. So, it is advisable to *submit* more complex or longer work "
"chains to the daemon:"
msgstr ""

#: ../docs/source/howto/workflows.rst:245
msgid ""
"Note that when using ``submit`` the work chain is not run in the local "
"interpreter but is sent off to the daemon and you get back control "
"instantly. This allows you to submit multiple work chains at the same time "
"and the daemon will start working on them in parallel. Once the ``submit`` "
"call returns, you will not get the result as with ``run``, but you will get "
"the **node** that represents the work chain. Submitting a work chain instead"
" of directly running it not only makes it easier to execute multiple work "
"chains in parallel, but also ensures that the progress of a workchain is not"
" lost when you restart your computer."
msgstr ""

#: ../docs/source/howto/workflows.rst:252
msgid ""
"In contrast to work chains, work *functions* cannot be submitted to the "
"daemon, and hence can only be *run*."
msgstr ""

#: ../docs/source/howto/workflows.rst:254
msgid ""
"If you are unfamiliar with the inputs of a particular ``WorkChain``, a "
"convenient tool for setting up the work chain is the :ref:`process "
"builder<topics:processes:usage:builder>`. This can be obtained by using the "
"``get_builder()`` method, which is implemented for every ``CalcJob`` and "
"``WorkChain``:"
msgstr ""

#: ../docs/source/howto/workflows.rst:264
msgid ""
"To explore the inputs of the work chain, you can use tab autocompletion by "
"typing ``builder.`` and then hitting ``TAB``. If you want to get more "
"details on a specific input, you can simply add a ``?`` and press enter:"
msgstr ""

#: ../docs/source/howto/workflows.rst:274
msgid ""
"Here you can see that the ``x`` input is required, needs to be of the "
"``Int`` type and is stored in the database (``\"non_db\": \"False\"``)."
msgstr ""

#: ../docs/source/howto/workflows.rst:276
msgid ""
"Using the builder, the inputs of the ``WorkChain`` can be provided one by "
"one:"
msgstr ""

#: ../docs/source/howto/workflows.rst:285
msgid ""
"Once the *required* inputs of the workflow have been provided to the "
"builder, you can either run the work chain or submit it to the daemon:"
msgstr ""

#: ../docs/source/howto/workflows.rst:294
msgid ""
"For more detail on the process builder, see the :ref:`corresponding topics "
"section<topics:processes:usage:builder>`."
msgstr ""

#: ../docs/source/howto/workflows.rst:301
msgid "title: Extending workflows"
msgstr ""

#: ../docs/source/howto/workflows.rst:303
msgid "`#3993`_"
msgstr ""
