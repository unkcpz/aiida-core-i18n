

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Caching &mdash; AiiDA 1.0.0b2 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script type="text/javascript" src="../_static/contentui.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/contentui.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Retrieving results" href="resultmanager.html" />
    <link rel="prev" title="Directly querying in Django" href="../querying/backend.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> AiiDA
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Installation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../install/quick_installation.html">Quick installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../install/prerequisites.html">Prerequisites</a></li>
<li class="toctree-l1"><a class="reference internal" href="../install/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../install/updating_installation.html">Updating AiiDA</a></li>
<li class="toctree-l1"><a class="reference internal" href="../install/troubleshooting.html">Troubleshooting</a></li>
</ul>
<p class="caption"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../get_started/index.html">First things first</a></li>
<li class="toctree-l1"><a class="reference internal" href="../get_started/daemon.html">Setup the daemon</a></li>
<li class="toctree-l1"><a class="reference internal" href="../get_started/computers.html">Setup a computer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../get_started/codes.html">Setup a code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../get_started/plugins.html">Plugins</a></li>
</ul>
<p class="caption"><span class="caption-text">Concepts</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../concepts/provenance.html">Provenance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../concepts/processes.html">Processes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../concepts/calculations.html">Calculations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../concepts/workflows.html">Workflows</a></li>
</ul>
<p class="caption"><span class="caption-text">Working with</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../working/processes.html">Processes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../working/functions.html">Calculation and work functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../working/calculations.html">Calculations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../working/workflows.html">Workflows</a></li>
</ul>
<p class="caption"><span class="caption-text">Working with AiiDA</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="index.html">Command line interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#scripting">Scripting</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#data-types">Data types</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#groups">Groups</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#schedulers">Schedulers</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#querying-data">Querying data</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html#caching">Caching</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Caching</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#configuration">Configuration</a></li>
<li class="toctree-l3"><a class="reference internal" href="#how-are-cached-nodes-matched">How are cached nodes matched?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#what-to-do-when-caching-is-used-when-it-shouldn-t">What to do when caching is used when it shouldn’t</a></li>
<li class="toctree-l3"><a class="reference internal" href="#caching-and-the-provenance-graph">Caching and the Provenance Graph</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#result-manager">Result manager</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#backups">Backups</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#troubleshooting">Troubleshooting</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#rest-api">REST API</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#cookbook">Cookbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../import_export/index.html">Import and Export</a></li>
</ul>
<p class="caption"><span class="caption-text">Development</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../developer_guide/index.html">AiiDA design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../developer_guide/index.html#aiida-core">AiiDA core</a></li>
<li class="toctree-l1"><a class="reference internal" href="../developer_guide/index.html#aiida-plugins">AiiDA plugins</a></li>
</ul>
<p class="caption"><span class="caption-text">Tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../tutorial/index.html">StructureData</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial/index.html#pseudopotentials">Pseudopotentials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial/index.html#plugin-development">Plugin development</a></li>
</ul>
<p class="caption"><span class="caption-text">API reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="`aiida package &lt;https://aiida-core.readthedocs.io/en/latest/apidoc/aiida.html&gt;`_">`aiida package &lt;https://aiida-core.readthedocs.io/en/latest/apidoc/aiida.html&gt;`_</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">AiiDA</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Command line interface</a> &raquo;</li>
        
      <li>Caching</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/working_with_aiida/caching.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="caching">
<span id="id1"></span><h1>Caching<a class="headerlink" href="#caching" title="Permalink to this headline">¶</a></h1>
<p>When working with AiiDA, you might sometimes re-run calculations which were already successfully executed. Because this can waste a lot of computational resources, you can enable AiiDA to <strong>cache</strong> calculations, which means that it will re-use existing calculations if a calculation with the same inputs is submitted again.</p>
<p>When a calculation is cached, a copy of the original calculation is created. This copy will keep the input links of the new calculation. The outputs of the original calculation are also copied, and linked to the new calculation. This allows for the new calculation to be a separate Node in the provenance graph and, critically, preserves the acyclicity of the graph.</p>
<p>Caching is also implemented for Data nodes. This is not very useful in practice (yet), but is an easy way to show how the caching mechanism works:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>

<span class="gp">In [2]: </span><span class="kn">from</span> <span class="nn">aiida.orm</span> <span class="kn">import</span> <span class="n">Str</span>

<span class="gp">In [3]: </span><span class="n">n1</span> <span class="o">=</span> <span class="n">Str</span><span class="p">(</span><span class="s1">&#39;test string&#39;</span><span class="p">)</span>

<span class="gp">In [4]: </span><span class="n">n1</span><span class="o">.</span><span class="n">store</span><span class="p">()</span>
<span class="gh">Out[4]: </span><span class="go">u&#39;test string&#39;</span>

<span class="gp">In [5]: </span><span class="n">n2</span> <span class="o">=</span> <span class="n">Str</span><span class="p">(</span><span class="s1">&#39;test string&#39;</span><span class="p">)</span>

<span class="gp">In [6]: </span><span class="n">n2</span><span class="o">.</span><span class="n">store</span><span class="p">(</span><span class="n">use_cache</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gh">Out[6]: </span><span class="go">u&#39;test string&#39;</span>

<span class="gp">In [7]: </span><span class="k">print</span><span class="p">(</span><span class="s1">&#39;UUID of n1:&#39;</span><span class="p">,</span> <span class="n">n1</span><span class="o">.</span><span class="n">uuid</span><span class="p">)</span>
<span class="go">UUID of n1: 956109e1-4382-4240-a711-2a4f3b522122</span>

<span class="gp">In [8]: </span><span class="k">print</span><span class="p">(</span><span class="s1">&#39;n2 is cached from:&#39;</span><span class="p">,</span> <span class="n">n2</span><span class="o">.</span><span class="n">get_extra</span><span class="p">(</span><span class="s1">&#39;_aiida_cached_from&#39;</span><span class="p">))</span>
<span class="go">n2 is cached from: 956109e1-4382-4240-a711-2a4f3b522122</span>
</pre></div>
</div>
<p>As you can see, passing <code class="docutils literal notranslate"><span class="pre">use_cache=True</span></code> to the <code class="docutils literal notranslate"><span class="pre">store</span></code> method enables using the cache. The fact that <code class="docutils literal notranslate"><span class="pre">n2</span></code> was created from <code class="docutils literal notranslate"><span class="pre">n1</span></code> is stored in the <code class="docutils literal notranslate"><span class="pre">_aiida_cached_from</span></code> extra of <code class="docutils literal notranslate"><span class="pre">n2</span></code>.</p>
<p>When running a <code class="docutils literal notranslate"><span class="pre">CalcJob</span></code> through the <code class="docutils literal notranslate"><span class="pre">Process</span></code> interface, you cannot directly set the <code class="docutils literal notranslate"><span class="pre">use_cache</span></code> flag when the calculation node is stored internally. Instead, you can pass the <code class="docutils literal notranslate"><span class="pre">_use_cache</span></code> flag to the <code class="docutils literal notranslate"><span class="pre">run</span></code> or <code class="docutils literal notranslate"><span class="pre">submit</span></code> method.</p>
<p>Caching is <strong>not</strong> implemented for workchains and workfunctions. Unlike calculations, they can not only create new data nodes, but also return exsting ones. When copying a cached workchain, it’s not clear which node should be returned without actually running the workchain. This is explained in more detail in the section <a class="reference internal" href="#caching-provenance"><span class="std std-ref">Caching and the Provenance Graph</span></a>.</p>
<div class="section" id="configuration">
<h2>Configuration<a class="headerlink" href="#configuration" title="Permalink to this headline">¶</a></h2>
<p>Of course, using caching would be quite tedious if you had to set <code class="docutils literal notranslate"><span class="pre">use_cache</span></code> manually everywhere. To fix this, the default for <code class="docutils literal notranslate"><span class="pre">use_cache</span></code> can be set in the <code class="docutils literal notranslate"><span class="pre">.aiida/cache_config.yml</span></code> file. You can specify a global default, or enable / disable caching for specific calculation or data classes. An example configuration file might look like this:</p>
<div class="code yaml highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">profile</span><span class="o">-</span><span class="n">name</span><span class="p">:</span>
  <span class="n">default</span><span class="p">:</span> <span class="kc">False</span>
  <span class="n">enabled</span><span class="p">:</span>
    <span class="o">-</span> <span class="n">aiida</span><span class="o">.</span><span class="n">calculations</span><span class="o">.</span><span class="n">plugins</span><span class="o">.</span><span class="n">templatereplacer</span><span class="o">.</span><span class="n">TemplatereplacerCalculation</span>
    <span class="o">-</span> <span class="n">aiida</span><span class="o">.</span><span class="n">orm</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">Str</span>
  <span class="n">disabled</span><span class="p">:</span>
    <span class="o">-</span> <span class="n">aiida</span><span class="o">.</span><span class="n">orm</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">float</span><span class="o">.</span><span class="n">Float</span>
</pre></div>
</div>
<p>This means that caching is enabled for <code class="docutils literal notranslate"><span class="pre">TemplatereplacerCalculation</span></code> and <code class="docutils literal notranslate"><span class="pre">Str</span></code>, and disabled for all other classes. In this example, manually disabling <code class="docutils literal notranslate"><span class="pre">aiida.orm.nodes.data.float.Float</span></code> is actually not needed, since the <code class="docutils literal notranslate"><span class="pre">default:</span> <span class="pre">False</span></code> configuration means that caching is disabled for all classes unless it is manually enabled. Note also that the fully qualified class import name (e.g., <code class="docutils literal notranslate"><span class="pre">aiida.orm.nodes.data.str.Str</span></code>) must be given, not just the class name (<code class="docutils literal notranslate"><span class="pre">Str</span></code>). This is to avoid accidentally matching classes with the same name. You can get this name by combining the module name and class name, or (usually) from the string representation of the class:</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [9]: </span><span class="n">Str</span><span class="o">.</span><span class="vm">__module__</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span> <span class="o">+</span> <span class="n">Str</span><span class="o">.</span><span class="vm">__name__</span>
<span class="gh">Out[9]: </span><span class="go">&#39;aiida.orm.nodes.data.str.Str&#39;</span>

<span class="gp">In [10]: </span><span class="nb">str</span><span class="p">(</span><span class="n">Str</span><span class="p">)</span>
<span class="gh">Out[10]: </span><span class="go">&quot;&lt;class &#39;aiida.orm.nodes.data.str.Str&#39;&gt;&quot;</span>
</pre></div>
</div>
<p>Note that this is not the same as the type string stored in the database.</p>
</div>
<div class="section" id="how-are-cached-nodes-matched">
<span id="caching-matches"></span><h2>How are cached nodes matched?<a class="headerlink" href="#how-are-cached-nodes-matched" title="Permalink to this headline">¶</a></h2>
<p>To determine wheter a given node is identical to an existing one, a hash of the content of the node is created. If a node of the same class with the same hash already exists in the database, this is considered a cache match. You can manually check the hash of a given node with the <a class="reference internal" href="../apidoc/aiida.orm.nodes.html#aiida.orm.nodes.Node.get_hash" title="aiida.orm.nodes.Node.get_hash"><code class="xref py py-meth docutils literal notranslate"><span class="pre">.get_hash()</span></code></a> method. Once a node is stored in the database, its hash is stored in the <code class="docutils literal notranslate"><span class="pre">_aiida_hash</span></code> extra, and this is used to find matching nodes.</p>
<p>By default, this hash is created from:</p>
<ul class="simple">
<li>all attributes of a node, except the <code class="docutils literal notranslate"><span class="pre">_updatable_attributes</span></code></li>
<li>the <code class="docutils literal notranslate"><span class="pre">__version__</span></code> of the module which defines the node class</li>
<li>the content of the repository folder of the node</li>
<li>the UUID of the computer, if the node has one</li>
</ul>
<p>In the case of calculations, the hashes of the inputs are also included. When developing calculation and data classes, there are some methods you can use to determine how the hash is created:</p>
<ul class="simple">
<li>To ignore specific attributes, a <code class="docutils literal notranslate"><span class="pre">Node</span></code> subclass can have a <code class="docutils literal notranslate"><span class="pre">_hash_ignored_attributes</span></code> attribute. This is a list of attribute names which are ignored when creating the hash.</li>
<li>For calculations, the <code class="docutils literal notranslate"><span class="pre">_hash_ignored_inputs</span></code> attribute lists inputs that should be ignored when creating the hash.</li>
<li>To add things which should be considered in the hash, you can override the <a class="reference internal" href="../apidoc/aiida.orm.nodes.html#aiida.orm.nodes.Node._get_objects_to_hash" title="aiida.orm.nodes.Node._get_objects_to_hash"><code class="xref py py-meth docutils literal notranslate"><span class="pre">_get_objects_to_hash</span></code></a> method. Note that doing so overrides the behavior described above, so you should make sure to use the <code class="docutils literal notranslate"><span class="pre">super()</span></code> method.</li>
<li>Pass a keyword argument to <a class="reference internal" href="../apidoc/aiida.orm.nodes.html#aiida.orm.nodes.Node.get_hash" title="aiida.orm.nodes.Node.get_hash"><code class="xref py py-meth docutils literal notranslate"><span class="pre">.get_hash</span></code></a>. These are passed on to <code class="docutils literal notranslate"><span class="pre">aiida.common.hashing.make_hash</span></code>. For example, the <code class="docutils literal notranslate"><span class="pre">ignored_folder_content</span></code> keyword is used by the <a class="reference internal" href="../apidoc/aiida.orm.nodes.process.calculation.html#aiida.orm.nodes.process.calculation.calcjob.CalcJobNode" title="aiida.orm.nodes.process.calculation.calcjob.CalcJobNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">JobCalculation</span></code></a> to ignore the <code class="docutils literal notranslate"><span class="pre">raw_input</span></code> subfolder of its repository folder.</li>
</ul>
<p>Additionally, there are two methods you can use to disable caching for particular nodes:</p>
<ul class="simple">
<li>The <a class="reference internal" href="../apidoc/aiida.orm.nodes.html#aiida.orm.nodes.Node.is_valid_cache" title="aiida.orm.nodes.Node.is_valid_cache"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_valid_cache()</span></code></a> property determines whether a particular node can be used as a cache. This is used for example to disable caching from failed calculations.</li>
<li>Node classes have a <code class="docutils literal notranslate"><span class="pre">_cachable</span></code> attribute, which can be set to <code class="docutils literal notranslate"><span class="pre">False</span></code> to completely switch off caching for nodes of that class. This avoids performing queries for the hash altogether.</li>
</ul>
<p>There are two ways in which the hash match can go wrong: False negatives, where two nodes should have the same hash but do not, or false positives, where two different nodes have the same hash. It is important to understand that false negatives are <strong>highly preferrable</strong>, because they only increase the runtime of your calculations, as if caching was disabled. False positives however can break the logic of your calculations. Be mindful of this when modifying the caching behaviour of your calculation and data classes.</p>
</div>
<div class="section" id="what-to-do-when-caching-is-used-when-it-shouldn-t">
<span id="caching-error"></span><h2>What to do when caching is used when it shouldn’t<a class="headerlink" href="#what-to-do-when-caching-is-used-when-it-shouldn-t" title="Permalink to this headline">¶</a></h2>
<p>In general, the caching mechanism should trigger only when the output of a calculation will be exactly the same as if it is run again. However, there might be some edge cases where this is not true.</p>
<p>For example, if the parser is in a different python module than the calculation, the version number used in the hash will not change when the parser is updated. While the “correct” solution to this problem is to increase the version number of a calculation when the behavior of its parser changes, there might still be cases (e.g. during development) when you manually want to stop a particular node from being cached.</p>
<p>In such cases, you can follow these steps to disable caching:</p>
<ol class="arabic">
<li><p class="first">If you suspect that a node has been cached in error, check that it has a <code class="docutils literal notranslate"><span class="pre">_aiida_cached_from</span></code> extra. If that’s not the case, it is not a problem of caching.</p>
</li>
<li><p class="first">Get all nodes which match your node, and clear their hash:</p>
<blockquote>
<div><div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">get_all_same_nodes</span><span class="p">():</span>
    <span class="n">n</span><span class="o">.</span><span class="n">clear_hash</span><span class="p">()</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first">Run your calculation again. Now it should not use caching.</p>
</li>
</ol>
<p>If you instead think that there is a bug in the AiiDA implementation, please open an issue (with enough information to be able to reproduce the error, otherwise it is hard for us to help you) in the AiiDA GitHub repository: <a class="reference external" href="https://github.com/aiidateam/aiida_core/issues/new">https://github.com/aiidateam/aiida_core/issues/new</a>.</p>
</div>
<div class="section" id="caching-and-the-provenance-graph">
<span id="caching-provenance"></span><h2>Caching and the Provenance Graph<a class="headerlink" href="#caching-and-the-provenance-graph" title="Permalink to this headline">¶</a></h2>
<p>The goal of the caching mechanism is to speed up AiiDA calculations by re-using duplicate calculations. However, the resulting provenance graph should be exactly the same as if caching was disabled. This has important consequences on the kind of caching operations that are possible.</p>
<p>The provenance graph consists of nodes describing data, calculations and workchains, and links describing the relationship between these nodes. We have seen that the hash of a node is used to determine whether two nodes are equivalent. To successfully use a cached node however, we also need to know how the new node should be linked to its parents and children.</p>
<p>In the case of a plain data node, this is simple: Copying a data node from an equivalent node should not change its links, so we just need to preserve the links which this new node already has.</p>
<p>For calculations, the situation is a bit more complex: The node can have inputs and creates new data nodes as outputs. Again, the new node needs to keep its existing links. For the outputs, the calculation needs to create a copy of each node and link these as its outputs. This makes it look as if the calculation had produced these outputs itself, without caching.</p>
<p>Finally, workchains can create links not only to nodes which they create themselves, but also to nodes created by a calculation that they called, or even their ancestors. This is where caching becomes impossible. Consider the following example (using workfunctions for simplicity):</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">aiida.engine</span> <span class="k">import</span> <span class="n">workfunction</span>
<span class="kn">from</span> <span class="nn">aiida.orm</span> <span class="k">import</span> <span class="n">Int</span>

<span class="nd">@workfunction</span>
<span class="k">def</span> <span class="nf">select</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">b</span>

<span class="n">d</span> <span class="o">=</span> <span class="n">Int</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">r1</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
<span class="n">r2</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">Int</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">Int</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<p>The two <code class="docutils literal notranslate"><span class="pre">select</span></code> workfunctions have the same inputs as far as their hashes go. However, the first call uses the same input node twice, while the second one has two different inputs. If the second call should be cached from the first one, it is not clear which of the two input nodes should be returned.</p>
<p>While this example might seem contrived, the conclusion is valid more generally: Because workchains can return nodes from their history, they cannot be cached. Since even two equivalent workchains (with the same inputs) can have a different history, there is no way to deduce which links should be created on the new workchain without actually running it.</p>
<p>Overall, this limitation is acceptable: The runtime of AiiDA workchains is usually dominated by time spent inside expensive calculations. Since these can be avoided with the caching mechanism, it still improves the runtime and required computer resources a lot.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="resultmanager.html" class="btn btn-neutral float-right" title="Retrieving results" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../querying/backend.html" class="btn btn-neutral float-left" title="Directly querying in Django" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, ECOLE POLYTECHNIQUE FEDERALE DE LAUSANNE (Theory and Simulation of Materials (THEOS) and National Centre for Computational Design and Discovery of Novel Materials (NCCR MARVEL)), Switzerland and ROBERT BOSCH LLC, USA. All rights reserved

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>