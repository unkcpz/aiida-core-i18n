

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>aiida.common package &mdash; AiiDA 1.0.0b2 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script type="text/javascript" src="../_static/contentui.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/contentui.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> AiiDA
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Installation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../install/quick_installation.html">Quick installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../install/prerequisites.html">Prerequisites</a></li>
<li class="toctree-l1"><a class="reference internal" href="../install/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../install/updating_installation.html">Updating AiiDA</a></li>
<li class="toctree-l1"><a class="reference internal" href="../install/troubleshooting.html">Troubleshooting</a></li>
</ul>
<p class="caption"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../get_started/index.html">First things first</a></li>
<li class="toctree-l1"><a class="reference internal" href="../get_started/daemon.html">Setup the daemon</a></li>
<li class="toctree-l1"><a class="reference internal" href="../get_started/computers.html">Setup a computer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../get_started/codes.html">Setup a code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../get_started/plugins.html">Plugins</a></li>
</ul>
<p class="caption"><span class="caption-text">Concepts</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../concepts/provenance.html">Provenance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../concepts/processes.html">Processes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../concepts/calculations.html">Calculations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../concepts/workflows.html">Workflows</a></li>
</ul>
<p class="caption"><span class="caption-text">Working with</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../working/processes.html">Processes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../working/functions.html">Calculation and work functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../working/calculations.html">Calculations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../working/workflows.html">Workflows</a></li>
</ul>
<p class="caption"><span class="caption-text">Working with AiiDA</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../working_with_aiida/index.html">Command line interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../working_with_aiida/index.html#scripting">Scripting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../working_with_aiida/index.html#data-types">Data types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../working_with_aiida/index.html#groups">Groups</a></li>
<li class="toctree-l1"><a class="reference internal" href="../working_with_aiida/index.html#schedulers">Schedulers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../working_with_aiida/index.html#querying-data">Querying data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../working_with_aiida/index.html#caching">Caching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../working_with_aiida/index.html#result-manager">Result manager</a></li>
<li class="toctree-l1"><a class="reference internal" href="../working_with_aiida/index.html#backups">Backups</a></li>
<li class="toctree-l1"><a class="reference internal" href="../working_with_aiida/index.html#troubleshooting">Troubleshooting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../working_with_aiida/index.html#rest-api">REST API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../working_with_aiida/index.html#cookbook">Cookbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../import_export/index.html">Import and Export</a></li>
</ul>
<p class="caption"><span class="caption-text">Development</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../developer_guide/index.html">AiiDA design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../developer_guide/index.html#aiida-core">AiiDA core</a></li>
<li class="toctree-l1"><a class="reference internal" href="../developer_guide/index.html#aiida-plugins">AiiDA plugins</a></li>
</ul>
<p class="caption"><span class="caption-text">Tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../tutorial/index.html">StructureData</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial/index.html#pseudopotentials">Pseudopotentials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial/index.html#plugin-development">Plugin development</a></li>
</ul>
<p class="caption"><span class="caption-text">API reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="`aiida package &lt;https://aiida-core.readthedocs.io/en/latest/apidoc/aiida.html&gt;`_">`aiida package &lt;https://aiida-core.readthedocs.io/en/latest/apidoc/aiida.html&gt;`_</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">AiiDA</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>aiida.common package</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/apidoc/aiida.common.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-aiida.common">
<span id="aiida-common-package"></span><h1>aiida.common package<a class="headerlink" href="#module-aiida.common" title="Permalink to this headline">¶</a></h1>
<p>Common data structures, utility classes and functions</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Modules in this sub package have to run without a loaded database environment</p>
</div>
<dl class="class">
<dt id="aiida.common.CalcJobState">
<em class="property">class </em><code class="descclassname">aiida.common.</code><code class="descname">CalcJobState</code><a class="reference internal" href="../_modules/aiida/common/datastructures.html#CalcJobState"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.CalcJobState" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">enum.Enum</span></code></p>
<p>The sub state of a CalcJobNode while its Process is in an active state (i.e. Running or Waiting).</p>
<dl class="attribute">
<dt id="aiida.common.CalcJobState.PARSING">
<code class="descname">PARSING</code><em class="property"> = 'parsing'</em><a class="headerlink" href="#aiida.common.CalcJobState.PARSING" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.CalcJobState.RETRIEVING">
<code class="descname">RETRIEVING</code><em class="property"> = 'retrieving'</em><a class="headerlink" href="#aiida.common.CalcJobState.RETRIEVING" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.CalcJobState.SUBMITTING">
<code class="descname">SUBMITTING</code><em class="property"> = 'submitting'</em><a class="headerlink" href="#aiida.common.CalcJobState.SUBMITTING" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.CalcJobState.UPLOADING">
<code class="descname">UPLOADING</code><em class="property"> = 'uploading'</em><a class="headerlink" href="#aiida.common.CalcJobState.UPLOADING" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.CalcJobState.WITHSCHEDULER">
<code class="descname">WITHSCHEDULER</code><em class="property"> = 'withscheduler'</em><a class="headerlink" href="#aiida.common.CalcJobState.WITHSCHEDULER" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.CalcJobState.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.datastructures'</em><a class="headerlink" href="#aiida.common.CalcJobState.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="aiida.common.CalcInfo">
<em class="property">class </em><code class="descclassname">aiida.common.</code><code class="descname">CalcInfo</code><a class="reference internal" href="../_modules/aiida/common/datastructures.html#CalcInfo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.CalcInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.extendeddicts.DefaultFieldsAttributeDict" title="aiida.common.extendeddicts.DefaultFieldsAttributeDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.extendeddicts.DefaultFieldsAttributeDict</span></code></a></p>
<p>This object will store the data returned by the calculation plugin and to be
passed to the ExecManager.</p>
<p>In the following descriptions all paths have to be considered relative</p>
<ul>
<li><dl class="first docutils">
<dt>retrieve_list: a list of strings or tuples that indicate files that are to be retrieved from the remote</dt>
<dd><p class="first">after the calculation has finished and stored in the repository in a FolderData.
If the entry in the list is just a string, it is assumed to be the filepath on the remote and it will
be copied to ‘.’ of the repository with name os.path.split(item)[1]
If the entry is a tuple it is expected to have the following format</p>
<blockquote>
<div><p>(‘remotepath’, ‘localpath’, depth)</p>
</div></blockquote>
<p>If the ‘remotepath’ is a file or folder, it will be copied in the repository to ‘localpath’.
However, if the ‘remotepath’ contains file patterns with wildcards, the ‘localpath’ should be set to ‘.’
and the depth parameter should be an integer that decides the localname. The ‘remotepath’ will be split on
file separators and the local filename will be determined by joining the N last elements, where N is
given by the depth variable.</p>
<p>Example: (‘some/remote/path/files/pattern*[0-9].xml’, ‘.’, 2)</p>
<p>Will result in all files that match the pattern to be copied to the local repository with path</p>
<blockquote class="last">
<div><p>‘files/pattern*[0-9].xml’</p>
</div></blockquote>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>retrieve_temporary_list: a list of strings or tuples that indicate files that will be retrieved</dt>
<dd><p class="first last">and stored temporarily in a FolderData, that will be available only during the parsing call.
The format of the list is the same as that of ‘retrieve_list’</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>retrieve_singlefile_list: a list of tuples with format</dt>
<dd><p class="first last">(‘linkname_from calc to singlefile’, ‘subclass of singlefile’, ‘filename’)
Each tuple represents a file that will be retrieved from cluster and saved in SinglefileData nodes</p>
</dd>
</dl>
</li>
<li><p class="first">local_copy_list: a list of tuples with format (‘node_uuid’, ‘filename’, relativedestpath’)</p>
</li>
<li><p class="first">remote_copy_list: a list of tuples with format (‘remotemachinename’, ‘remoteabspath’, ‘relativedestpath’)</p>
</li>
<li><p class="first">remote_symlink_list: a list of tuples with format (‘remotemachinename’, ‘remoteabspath’, ‘relativedestpath’)</p>
</li>
<li><p class="first">codes_info: a list of dictionaries used to pass the info of the execution of a code</p>
</li>
<li><p class="first">codes_run_mode: a string used to specify the order in which multi codes can be executed</p>
</li>
</ul>
<dl class="attribute">
<dt id="aiida.common.CalcInfo.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.datastructures'</em><a class="headerlink" href="#aiida.common.CalcInfo.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.CalcInfo._default_fields">
<code class="descname">_default_fields</code><em class="property"> = ('job_environment', 'email', 'email_on_started', 'email_on_terminated', 'uuid', 'prepend_text', 'append_text', 'num_machines', 'num_mpiprocs_per_machine', 'priority', 'max_wallclock_seconds', 'max_memory_kb', 'rerunnable', 'retrieve_list', 'retrieve_temporary_list', 'retrieve_singlefile_list', 'local_copy_list', 'remote_copy_list', 'remote_symlink_list', 'codes_info', 'codes_run_mode')</em><a class="headerlink" href="#aiida.common.CalcInfo._default_fields" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="aiida.common.CodeInfo">
<em class="property">class </em><code class="descclassname">aiida.common.</code><code class="descname">CodeInfo</code><a class="reference internal" href="../_modules/aiida/common/datastructures.html#CodeInfo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.CodeInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.extendeddicts.DefaultFieldsAttributeDict" title="aiida.common.extendeddicts.DefaultFieldsAttributeDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.extendeddicts.DefaultFieldsAttributeDict</span></code></a></p>
<p>This attribute-dictionary contains the information needed to execute a code.
Possible attributes are:</p>
<ul>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">cmdline_params</span></code>: a list of strings, containing parameters to be written on
the command line right after the call to the code, as for example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">code</span><span class="o">.</span><span class="n">x</span> <span class="n">cmdline_params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="n">cmdline_params</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">...</span> <span class="o">&lt;</span> <span class="n">stdin</span> <span class="o">&gt;</span> <span class="n">stdout</span>
</pre></div>
</div>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">stdin_name</span></code>: (optional) the name of the standard input file. Note, it is
only possible to use the stdin with the syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">code</span><span class="o">.</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">stdin_name</span>
</pre></div>
</div>
<p>If no stdin_name is specified, the string “&lt; stdin_name” will not be
passed to the code.
Note: it is not possible to substitute/remove the ‘&lt;’ if stdin_name is specified;
if that is needed, avoid stdin_name and use instead the cmdline_params to
specify a suitable syntax.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">stdout_name</span></code>: (optional) the name of the standard output file. Note, it is
only possible to pass output to stdout_name with the syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">code</span><span class="o">.</span><span class="n">x</span> <span class="o">...</span> <span class="o">&gt;</span> <span class="n">stdout_name</span>
</pre></div>
</div>
<p>If no stdout_name is specified, the string “&gt; stdout_name” will not be
passed to the code.
Note: it is not possible to substitute/remove the ‘&gt;’ if stdout_name is specified;
if that is needed, avoid stdout_name and use instead the cmdline_params to
specify a suitable syntax.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">stderr_name</span></code>: (optional) a string, the name of the error file of the code.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">join_files</span></code>: (optional) if True, redirects the error to the output file.
If join_files=True, the code will be called as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">code</span><span class="o">.</span><span class="n">x</span> <span class="o">...</span> <span class="o">&gt;</span> <span class="n">stdout_name</span> <span class="mi">2</span><span class="o">&gt;&amp;</span><span class="mi">1</span>
</pre></div>
</div>
<p>otherwise, if join_files=False and stderr is passed:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">code</span><span class="o">.</span><span class="n">x</span> <span class="o">...</span> <span class="o">&gt;</span> <span class="n">stdout_name</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">stderr_name</span>
</pre></div>
</div>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">withmpi</span></code>: if True, executes the code with mpirun (or another MPI installed
on the remote computer)</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">code_uuid</span></code>: the uuid of the code associated to the CodeInfo</p>
</li>
</ul>
<dl class="attribute">
<dt id="aiida.common.CodeInfo.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.datastructures'</em><a class="headerlink" href="#aiida.common.CodeInfo.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.CodeInfo._default_fields">
<code class="descname">_default_fields</code><em class="property"> = ('cmdline_params', 'stdin_name', 'stdout_name', 'stderr_name', 'join_files', 'withmpi', 'code_uuid')</em><a class="headerlink" href="#aiida.common.CodeInfo._default_fields" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="aiida.common.CodeRunMode">
<em class="property">class </em><code class="descclassname">aiida.common.</code><code class="descname">CodeRunMode</code><a class="reference internal" href="../_modules/aiida/common/datastructures.html#CodeRunMode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.CodeRunMode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">enum.IntEnum</span></code></p>
<p>Enum to indicate the way the codes of a calculation should be run.</p>
<p>For PARALLEL, the codes for a given calculation will be run in parallel by running them in the background:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">code1</span><span class="o">.</span><span class="n">x</span> <span class="o">&amp;</span>
<span class="n">code2</span><span class="o">.</span><span class="n">x</span> <span class="o">&amp;</span>
</pre></div>
</div>
<p>For the SERIAL option, codes will be executed sequentially by running for example the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">code1</span><span class="o">.</span><span class="n">x</span>
<span class="n">code2</span><span class="o">.</span><span class="n">x</span>
</pre></div>
</div>
<dl class="attribute">
<dt id="aiida.common.CodeRunMode.PARALLEL">
<code class="descname">PARALLEL</code><em class="property"> = 1</em><a class="headerlink" href="#aiida.common.CodeRunMode.PARALLEL" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.CodeRunMode.SERIAL">
<code class="descname">SERIAL</code><em class="property"> = 0</em><a class="headerlink" href="#aiida.common.CodeRunMode.SERIAL" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.CodeRunMode.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.datastructures'</em><a class="headerlink" href="#aiida.common.CodeRunMode.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.AiidaException">
<em class="property">exception </em><code class="descclassname">aiida.common.</code><code class="descname">AiidaException</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#AiidaException"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.AiidaException" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code></p>
<p>Base class for all AiiDA exceptions.</p>
<p>Each module will have its own subclass, inherited from this
(e.g. ExecManagerException, TransportException, …)</p>
<dl class="attribute">
<dt id="aiida.common.AiidaException.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.AiidaException.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.AiidaException.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#aiida.common.AiidaException.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.NotExistent">
<em class="property">exception </em><code class="descclassname">aiida.common.</code><code class="descname">NotExistent</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#NotExistent"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.NotExistent" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Raised when the required entity does not exist.</p>
<dl class="attribute">
<dt id="aiida.common.NotExistent.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.NotExistent.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.MultipleObjectsError">
<em class="property">exception </em><code class="descclassname">aiida.common.</code><code class="descname">MultipleObjectsError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#MultipleObjectsError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.MultipleObjectsError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Raised when more than one entity is found in the DB, but only one was
expected.</p>
<dl class="attribute">
<dt id="aiida.common.MultipleObjectsError.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.MultipleObjectsError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.RemoteOperationError">
<em class="property">exception </em><code class="descclassname">aiida.common.</code><code class="descname">RemoteOperationError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#RemoteOperationError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.RemoteOperationError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Raised when an error in a remote operation occurs, as in a failed kill()
of a scheduler job.</p>
<dl class="attribute">
<dt id="aiida.common.RemoteOperationError.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.RemoteOperationError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.ContentNotExistent">
<em class="property">exception </em><code class="descclassname">aiida.common.</code><code class="descname">ContentNotExistent</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#ContentNotExistent"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.ContentNotExistent" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.NotExistent" title="aiida.common.exceptions.NotExistent"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.NotExistent</span></code></a></p>
<p>Raised when trying to access an attribute, a key or a file in the result
nodes that is not present</p>
<dl class="attribute">
<dt id="aiida.common.ContentNotExistent.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.ContentNotExistent.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.FailedError">
<em class="property">exception </em><code class="descclassname">aiida.common.</code><code class="descname">FailedError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#FailedError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.FailedError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Raised when accessing a calculation that is in the FAILED status</p>
<dl class="attribute">
<dt id="aiida.common.FailedError.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.FailedError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.StoringNotAllowed">
<em class="property">exception </em><code class="descclassname">aiida.common.</code><code class="descname">StoringNotAllowed</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#StoringNotAllowed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.StoringNotAllowed" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Raised when the user tries to store an unstorable node (e.g. a base Node class)</p>
<dl class="attribute">
<dt id="aiida.common.StoringNotAllowed.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.StoringNotAllowed.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.ModificationNotAllowed">
<em class="property">exception </em><code class="descclassname">aiida.common.</code><code class="descname">ModificationNotAllowed</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#ModificationNotAllowed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.ModificationNotAllowed" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Raised when the user tries to modify a field, object, property, … that should not
be modified.</p>
<dl class="attribute">
<dt id="aiida.common.ModificationNotAllowed.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.ModificationNotAllowed.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.IntegrityError">
<em class="property">exception </em><code class="descclassname">aiida.common.</code><code class="descname">IntegrityError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#IntegrityError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.IntegrityError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Raised when there is an underlying data integrity error.  This can be database related
or a general data integrity error.  This can happen if, e.g., a foreign key check fails.
See PEP 249 for details.</p>
<dl class="attribute">
<dt id="aiida.common.IntegrityError.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.IntegrityError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.UniquenessError">
<em class="property">exception </em><code class="descclassname">aiida.common.</code><code class="descname">UniquenessError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#UniquenessError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.UniquenessError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Raised when the user tries to violate a uniqueness constraint (on the
DB, for instance).</p>
<dl class="attribute">
<dt id="aiida.common.UniquenessError.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.UniquenessError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.EntryPointError">
<em class="property">exception </em><code class="descclassname">aiida.common.</code><code class="descname">EntryPointError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#EntryPointError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.EntryPointError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Raised when an entry point cannot be uniquely resolved and imported.</p>
<dl class="attribute">
<dt id="aiida.common.EntryPointError.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.EntryPointError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.MissingEntryPointError">
<em class="property">exception </em><code class="descclassname">aiida.common.</code><code class="descname">MissingEntryPointError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#MissingEntryPointError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.MissingEntryPointError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.EntryPointError" title="aiida.common.exceptions.EntryPointError"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.EntryPointError</span></code></a></p>
<p>Raised when the requested entry point is not registered with the entry point manager.</p>
<dl class="attribute">
<dt id="aiida.common.MissingEntryPointError.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.MissingEntryPointError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.MultipleEntryPointError">
<em class="property">exception </em><code class="descclassname">aiida.common.</code><code class="descname">MultipleEntryPointError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#MultipleEntryPointError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.MultipleEntryPointError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.EntryPointError" title="aiida.common.exceptions.EntryPointError"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.EntryPointError</span></code></a></p>
<p>Raised when the requested entry point cannot uniquely be resolved by the entry point manager.</p>
<dl class="attribute">
<dt id="aiida.common.MultipleEntryPointError.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.MultipleEntryPointError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.LoadingEntryPointError">
<em class="property">exception </em><code class="descclassname">aiida.common.</code><code class="descname">LoadingEntryPointError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#LoadingEntryPointError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.LoadingEntryPointError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.EntryPointError" title="aiida.common.exceptions.EntryPointError"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.EntryPointError</span></code></a></p>
<p>Raised when the resource corresponding to requested entry point cannot be imported.</p>
<dl class="attribute">
<dt id="aiida.common.LoadingEntryPointError.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.LoadingEntryPointError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.InvalidOperation">
<em class="property">exception </em><code class="descclassname">aiida.common.</code><code class="descname">InvalidOperation</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#InvalidOperation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.InvalidOperation" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>The allowed operation is not valid (e.g., when trying to add a non-internal attribute
before saving the entry), or deleting an entry that is protected (e.g.,
because it is referenced by foreign keys)</p>
<dl class="attribute">
<dt id="aiida.common.InvalidOperation.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.InvalidOperation.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.ParsingError">
<em class="property">exception </em><code class="descclassname">aiida.common.</code><code class="descname">ParsingError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#ParsingError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.ParsingError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Generic error raised when there is a parsing error</p>
<dl class="attribute">
<dt id="aiida.common.ParsingError.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.ParsingError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.InternalError">
<em class="property">exception </em><code class="descclassname">aiida.common.</code><code class="descname">InternalError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#InternalError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.InternalError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Error raised when there is an internal error of AiiDA.</p>
<dl class="attribute">
<dt id="aiida.common.InternalError.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.InternalError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.PluginInternalError">
<em class="property">exception </em><code class="descclassname">aiida.common.</code><code class="descname">PluginInternalError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#PluginInternalError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.PluginInternalError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.InternalError" title="aiida.common.exceptions.InternalError"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.InternalError</span></code></a></p>
<p>Error raised when there is an internal error which is due to a plugin
and not to the AiiDA infrastructure.</p>
<dl class="attribute">
<dt id="aiida.common.PluginInternalError.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.PluginInternalError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.ValidationError">
<em class="property">exception </em><code class="descclassname">aiida.common.</code><code class="descname">ValidationError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#ValidationError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.ValidationError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Error raised when there is an error during the validation phase
of a property.</p>
<dl class="attribute">
<dt id="aiida.common.ValidationError.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.ValidationError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.ConfigurationError">
<em class="property">exception </em><code class="descclassname">aiida.common.</code><code class="descname">ConfigurationError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#ConfigurationError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.ConfigurationError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Error raised when there is a configuration error in AiiDA.</p>
<dl class="attribute">
<dt id="aiida.common.ConfigurationError.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.ConfigurationError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.ProfileConfigurationError">
<em class="property">exception </em><code class="descclassname">aiida.common.</code><code class="descname">ProfileConfigurationError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#ProfileConfigurationError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.ProfileConfigurationError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.ConfigurationError" title="aiida.common.exceptions.ConfigurationError"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.ConfigurationError</span></code></a></p>
<p>Configuration error raised when a wrong/inexistent profile is requested.</p>
<dl class="attribute">
<dt id="aiida.common.ProfileConfigurationError.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.ProfileConfigurationError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.MissingConfigurationError">
<em class="property">exception </em><code class="descclassname">aiida.common.</code><code class="descname">MissingConfigurationError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#MissingConfigurationError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.MissingConfigurationError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.ConfigurationError" title="aiida.common.exceptions.ConfigurationError"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.ConfigurationError</span></code></a></p>
<p>Configuration error raised when the configuration file is missing.</p>
<dl class="attribute">
<dt id="aiida.common.MissingConfigurationError.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.MissingConfigurationError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.ConfigurationVersionError">
<em class="property">exception </em><code class="descclassname">aiida.common.</code><code class="descname">ConfigurationVersionError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#ConfigurationVersionError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.ConfigurationVersionError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.ConfigurationError" title="aiida.common.exceptions.ConfigurationError"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.ConfigurationError</span></code></a></p>
<p>Configuration error raised when the configuration file version is not
compatible with the current version.</p>
<dl class="attribute">
<dt id="aiida.common.ConfigurationVersionError.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.ConfigurationVersionError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.DbContentError">
<em class="property">exception </em><code class="descclassname">aiida.common.</code><code class="descname">DbContentError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#DbContentError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.DbContentError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Raised when the content of the DB is not valid.
This should never happen if the user does not play directly
with the DB.</p>
<dl class="attribute">
<dt id="aiida.common.DbContentError.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.DbContentError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.InputValidationError">
<em class="property">exception </em><code class="descclassname">aiida.common.</code><code class="descname">InputValidationError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#InputValidationError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.InputValidationError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.ValidationError" title="aiida.common.exceptions.ValidationError"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.ValidationError</span></code></a></p>
<p>The input data for a calculation did not validate (e.g., missing
required input data, wrong data, …)</p>
<dl class="attribute">
<dt id="aiida.common.InputValidationError.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.InputValidationError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.FeatureNotAvailable">
<em class="property">exception </em><code class="descclassname">aiida.common.</code><code class="descname">FeatureNotAvailable</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#FeatureNotAvailable"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.FeatureNotAvailable" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Raised when a feature is requested from a plugin, that is not available.</p>
<dl class="attribute">
<dt id="aiida.common.FeatureNotAvailable.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.FeatureNotAvailable.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.FeatureDisabled">
<em class="property">exception </em><code class="descclassname">aiida.common.</code><code class="descname">FeatureDisabled</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#FeatureDisabled"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.FeatureDisabled" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Raised when a feature is requested, but the user has chosen to disable
it (e.g., for submissions on disabled computers).</p>
<dl class="attribute">
<dt id="aiida.common.FeatureDisabled.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.FeatureDisabled.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.LicensingException">
<em class="property">exception </em><code class="descclassname">aiida.common.</code><code class="descname">LicensingException</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#LicensingException"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.LicensingException" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Raised when requirements for data licensing are not met.</p>
<dl class="attribute">
<dt id="aiida.common.LicensingException.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.LicensingException.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.TestsNotAllowedError">
<em class="property">exception </em><code class="descclassname">aiida.common.</code><code class="descname">TestsNotAllowedError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#TestsNotAllowedError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.TestsNotAllowedError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Raised when tests are required to be run/loaded, but we are not in a testing environment.</p>
<p>This is to prevent data loss.</p>
<dl class="attribute">
<dt id="aiida.common.TestsNotAllowedError.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.TestsNotAllowedError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.UnsupportedSpeciesError">
<em class="property">exception </em><code class="descclassname">aiida.common.</code><code class="descname">UnsupportedSpeciesError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#UnsupportedSpeciesError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.UnsupportedSpeciesError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">ValueError</span></code></p>
<p>Raised when StructureData operations are fed species that are not supported by AiiDA such as Deuterium</p>
<dl class="attribute">
<dt id="aiida.common.UnsupportedSpeciesError.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.UnsupportedSpeciesError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.UnsupportedSpeciesError.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#aiida.common.UnsupportedSpeciesError.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.DanglingLinkError">
<em class="property">exception </em><code class="descclassname">aiida.common.</code><code class="descname">DanglingLinkError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#DanglingLinkError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.DanglingLinkError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code></p>
<p>Raised when an export archive is detected to contain dangling links when importing</p>
<dl class="attribute">
<dt id="aiida.common.DanglingLinkError.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.DanglingLinkError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.DanglingLinkError.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#aiida.common.DanglingLinkError.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.TransportTaskException">
<em class="property">exception </em><code class="descclassname">aiida.common.</code><code class="descname">TransportTaskException</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#TransportTaskException"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.TransportTaskException" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code></p>
<p>Raised when a TransportTask, an task to be completed by the engine that requires transport, fails</p>
<dl class="attribute">
<dt id="aiida.common.TransportTaskException.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.TransportTaskException.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.TransportTaskException.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#aiida.common.TransportTaskException.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.IncompatibleArchiveVersionError">
<em class="property">exception </em><code class="descclassname">aiida.common.</code><code class="descname">IncompatibleArchiveVersionError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#IncompatibleArchiveVersionError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.IncompatibleArchiveVersionError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code></p>
<p>Raised when trying to import an export archive with an incompatible schema version.</p>
<dl class="attribute">
<dt id="aiida.common.IncompatibleArchiveVersionError.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.IncompatibleArchiveVersionError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.IncompatibleArchiveVersionError.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#aiida.common.IncompatibleArchiveVersionError.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.OutputParsingError">
<em class="property">exception </em><code class="descclassname">aiida.common.</code><code class="descname">OutputParsingError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#OutputParsingError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.OutputParsingError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.ParsingError" title="aiida.common.exceptions.ParsingError"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.ParsingError</span></code></a></p>
<p>Can be raised by a Parser when it fails to parse the output generated by a <cite>CalcJob</cite> process.</p>
<dl class="attribute">
<dt id="aiida.common.OutputParsingError.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.OutputParsingError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="aiida.common.AttributeDict">
<em class="property">class </em><code class="descclassname">aiida.common.</code><code class="descname">AttributeDict</code><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#AttributeDict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.AttributeDict" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></p>
<p>This class internally stores values in a dictionary, but exposes
the keys also as attributes, i.e. asking for attrdict.key
will return the value of attrdict[‘key’] and so on.</p>
<p>Raises an AttributeError if the key does not exist, when called as an attribute,
while the usual KeyError if the key does not exist and the dictionary syntax is
used.</p>
<dl class="method">
<dt id="aiida.common.AttributeDict.__deepcopy__">
<code class="descname">__deepcopy__</code><span class="sig-paren">(</span><em>memo=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#AttributeDict.__deepcopy__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.AttributeDict.__deepcopy__" title="Permalink to this definition">¶</a></dt>
<dd><p>Support deepcopy.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.AttributeDict.__delattr__">
<code class="descname">__delattr__</code><span class="sig-paren">(</span><em>attr</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#AttributeDict.__delattr__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.AttributeDict.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete a key as an attribute. Raise AttributeError on missing key.</p>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.AttributeDict.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'aiida.common.extendeddicts', '__doc__': &quot;\n    This class internally stores values in a dictionary, but exposes\n    the keys also as attributes, i.e. asking for attrdict.key\n    will return the value of attrdict['key'] and so on.\n\n    Raises an AttributeError if the key does not exist, when called as an attribute,\n    while the usual KeyError if the key does not exist and the dictionary syntax is\n    used.\n    &quot;, '__repr__': &lt;function AttributeDict.__repr__&gt;, '__getattr__': &lt;function AttributeDict.__getattr__&gt;, '__setattr__': &lt;function AttributeDict.__setattr__&gt;, '__delattr__': &lt;function AttributeDict.__delattr__&gt;, 'copy': &lt;function AttributeDict.copy&gt;, '__deepcopy__': &lt;function AttributeDict.__deepcopy__&gt;, '__getstate__': &lt;function AttributeDict.__getstate__&gt;, '__setstate__': &lt;function AttributeDict.__setstate__&gt;, '__dir__': &lt;function AttributeDict.__dir__&gt;, '__dict__': &lt;attribute '__dict__' of 'AttributeDict' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'AttributeDict' objects&gt;})</em><a class="headerlink" href="#aiida.common.AttributeDict.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.common.AttributeDict.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#AttributeDict.__dir__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.AttributeDict.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.AttributeDict.__getattr__">
<code class="descname">__getattr__</code><span class="sig-paren">(</span><em>attr</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#AttributeDict.__getattr__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.AttributeDict.__getattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a key as an attribute. Raise AttributeError on missing key.
Called only for attributes that do not exist.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.AttributeDict.__getstate__">
<code class="descname">__getstate__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#AttributeDict.__getstate__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.AttributeDict.__getstate__" title="Permalink to this definition">¶</a></dt>
<dd><p>Needed for pickling this class.</p>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.AttributeDict.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.extendeddicts'</em><a class="headerlink" href="#aiida.common.AttributeDict.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.common.AttributeDict.__repr__">
<code class="descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#AttributeDict.__repr__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.AttributeDict.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Representation of the object.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.AttributeDict.__setattr__">
<code class="descname">__setattr__</code><span class="sig-paren">(</span><em>attr</em>, <em>value</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#AttributeDict.__setattr__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.AttributeDict.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a key as an attribute.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.AttributeDict.__setstate__">
<code class="descname">__setstate__</code><span class="sig-paren">(</span><em>dictionary</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#AttributeDict.__setstate__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.AttributeDict.__setstate__" title="Permalink to this definition">¶</a></dt>
<dd><p>Needed for pickling this class.</p>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.AttributeDict.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#aiida.common.AttributeDict.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.AttributeDict.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#AttributeDict.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.AttributeDict.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Shallow copy.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="aiida.common.FixedFieldsAttributeDict">
<em class="property">class </em><code class="descclassname">aiida.common.</code><code class="descname">FixedFieldsAttributeDict</code><span class="sig-paren">(</span><em>init=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#FixedFieldsAttributeDict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.FixedFieldsAttributeDict" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.extendeddicts.AttributeDict" title="aiida.common.extendeddicts.AttributeDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.extendeddicts.AttributeDict</span></code></a></p>
<p>A dictionary with access to the keys as attributes, and with filtering
of valid attributes.
This is only the base class, without valid attributes;
use a derived class to do the actual work.
E.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">TestExample</span><span class="p">(</span><span class="n">FixedFieldsAttributeDict</span><span class="p">):</span>
    <span class="n">_valid_fields</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">)</span>
</pre></div>
</div>
<dl class="method">
<dt id="aiida.common.FixedFieldsAttributeDict.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#FixedFieldsAttributeDict.__dir__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.FixedFieldsAttributeDict.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.FixedFieldsAttributeDict.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>init=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#FixedFieldsAttributeDict.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.FixedFieldsAttributeDict.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.FixedFieldsAttributeDict.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.extendeddicts'</em><a class="headerlink" href="#aiida.common.FixedFieldsAttributeDict.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.common.FixedFieldsAttributeDict.__setattr__">
<code class="descname">__setattr__</code><span class="sig-paren">(</span><em>attr</em>, <em>value</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#FixedFieldsAttributeDict.__setattr__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.FixedFieldsAttributeDict.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overridden to allow direct access to fields with underscore.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.FixedFieldsAttributeDict.__setitem__">
<code class="descname">__setitem__</code><span class="sig-paren">(</span><em>item</em>, <em>value</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#FixedFieldsAttributeDict.__setitem__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.FixedFieldsAttributeDict.__setitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a key as an attribute.</p>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.FixedFieldsAttributeDict._valid_fields">
<code class="descname">_valid_fields</code><em class="property"> = ()</em><a class="headerlink" href="#aiida.common.FixedFieldsAttributeDict._valid_fields" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="aiida.common.FixedFieldsAttributeDict.get_valid_fields">
<em class="property">classmethod </em><code class="descname">get_valid_fields</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#FixedFieldsAttributeDict.get_valid_fields"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.FixedFieldsAttributeDict.get_valid_fields" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of valid fields.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="aiida.common.DefaultFieldsAttributeDict">
<em class="property">class </em><code class="descclassname">aiida.common.</code><code class="descname">DefaultFieldsAttributeDict</code><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#DefaultFieldsAttributeDict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.DefaultFieldsAttributeDict" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.extendeddicts.AttributeDict" title="aiida.common.extendeddicts.AttributeDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.extendeddicts.AttributeDict</span></code></a></p>
<p>A dictionary with access to the keys as attributes, and with an
internal value storing the ‘default’ keys to be distinguished
from extra fields.</p>
<p>Extra methods defaultkeys() and extrakeys() divide the set returned by
keys() in default keys (i.e. those defined at definition time)
and other keys.
There is also a method get_default_fields() to return the internal list.</p>
<p>Moreover, for undefined default keys, it returns None instead of raising a
KeyError/AttributeError exception.</p>
<p>Remember to define the _default_fields in a subclass!
E.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">TestExample</span><span class="p">(</span><span class="n">DefaultFieldsAttributeDict</span><span class="p">):</span>
    <span class="n">_default_fields</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>When the validate() method is called, it calls in turn all validate_KEY
methods, where KEY is one of the default keys.
If the method is not present, the field is considered to be always valid.
Each validate_KEY method should accept a single argument ‘value’ that will
contain the value to be checked.</p>
<p>It raises a ValidationError if any of the validate_KEY
function raises an exception, otherwise it simply returns.
NOTE: the <cite>validate_*</cite> functions are called also for unset fields, so if the
field can be empty on validation, you have to start your validation
function with something similar to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">return</span>
</pre></div>
</div>
<div class="admonition-todo admonition" id="index-0">
<p class="first admonition-title">Todo</p>
<p>Decide behavior if I set to None a field.
Current behavior, if
<code class="docutils literal notranslate"><span class="pre">a</span></code> is an instance and ‘def_field’ one of the default fields, that is
undefined, we get:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">a.get('def_field')</span></code>: None</li>
<li><code class="docutils literal notranslate"><span class="pre">a.get('def_field','whatever')</span></code>: ‘whatever’</li>
<li>Note that <code class="docutils literal notranslate"><span class="pre">a.defaultkeys()</span></code> does NOT contain ‘def_field’</li>
</ul>
<p>if we do <code class="docutils literal notranslate"><span class="pre">a.def_field</span> <span class="pre">=</span> <span class="pre">None</span></code>, then the behavior becomes</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">a.get('def_field')</span></code>: None</li>
<li><code class="docutils literal notranslate"><span class="pre">a.get('def_field','whatever')</span></code>: None</li>
<li>Note that <code class="docutils literal notranslate"><span class="pre">a.defaultkeys()</span></code> DOES contain ‘def_field’</li>
</ul>
<p class="last">See if we want that setting a default field to None means deleting it.</p>
</div>
<dl class="method">
<dt id="aiida.common.DefaultFieldsAttributeDict.__getitem__">
<code class="descname">__getitem__</code><span class="sig-paren">(</span><em>key</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#DefaultFieldsAttributeDict.__getitem__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.DefaultFieldsAttributeDict.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return None instead of raising an exception if the key does not exist
but is in the list of default fields.</p>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.DefaultFieldsAttributeDict.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.extendeddicts'</em><a class="headerlink" href="#aiida.common.DefaultFieldsAttributeDict.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.common.DefaultFieldsAttributeDict.__setattr__">
<code class="descname">__setattr__</code><span class="sig-paren">(</span><em>attr</em>, <em>value</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#DefaultFieldsAttributeDict.__setattr__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.DefaultFieldsAttributeDict.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overridden to allow direct access to fields with underscore.</p>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.DefaultFieldsAttributeDict._default_fields">
<code class="descname">_default_fields</code><em class="property"> = ()</em><a class="headerlink" href="#aiida.common.DefaultFieldsAttributeDict._default_fields" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.common.DefaultFieldsAttributeDict.defaultkeys">
<code class="descname">defaultkeys</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#DefaultFieldsAttributeDict.defaultkeys"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.DefaultFieldsAttributeDict.defaultkeys" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the default keys defined in the instance.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.DefaultFieldsAttributeDict.extrakeys">
<code class="descname">extrakeys</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#DefaultFieldsAttributeDict.extrakeys"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.DefaultFieldsAttributeDict.extrakeys" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the extra keys defined in the instance.</p>
</dd></dl>

<dl class="classmethod">
<dt id="aiida.common.DefaultFieldsAttributeDict.get_default_fields">
<em class="property">classmethod </em><code class="descname">get_default_fields</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#DefaultFieldsAttributeDict.get_default_fields"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.DefaultFieldsAttributeDict.get_default_fields" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of default fields, either defined in the instance or not.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.DefaultFieldsAttributeDict.validate">
<code class="descname">validate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#DefaultFieldsAttributeDict.validate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.DefaultFieldsAttributeDict.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>Validate the keys, if any <code class="docutils literal notranslate"><span class="pre">validate_*</span></code> method is available.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="aiida.common.LinkType">
<em class="property">class </em><code class="descclassname">aiida.common.</code><code class="descname">LinkType</code><a class="reference internal" href="../_modules/aiida/common/links.html#LinkType"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.LinkType" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">enum.Enum</span></code></p>
<p>A simple enum of allowed link types.</p>
<dl class="attribute">
<dt id="aiida.common.LinkType.CALL_CALC">
<code class="descname">CALL_CALC</code><em class="property"> = 'call_calc'</em><a class="headerlink" href="#aiida.common.LinkType.CALL_CALC" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.LinkType.CALL_WORK">
<code class="descname">CALL_WORK</code><em class="property"> = 'call_work'</em><a class="headerlink" href="#aiida.common.LinkType.CALL_WORK" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.LinkType.CREATE">
<code class="descname">CREATE</code><em class="property"> = 'create'</em><a class="headerlink" href="#aiida.common.LinkType.CREATE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.LinkType.INPUT_CALC">
<code class="descname">INPUT_CALC</code><em class="property"> = 'input_calc'</em><a class="headerlink" href="#aiida.common.LinkType.INPUT_CALC" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.LinkType.INPUT_WORK">
<code class="descname">INPUT_WORK</code><em class="property"> = 'input_work'</em><a class="headerlink" href="#aiida.common.LinkType.INPUT_WORK" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.LinkType.RETURN">
<code class="descname">RETURN</code><em class="property"> = 'return'</em><a class="headerlink" href="#aiida.common.LinkType.RETURN" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.LinkType.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.links'</em><a class="headerlink" href="#aiida.common.LinkType.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="aiida.common.validate_link_label">
<code class="descclassname">aiida.common.</code><code class="descname">validate_link_label</code><span class="sig-paren">(</span><em>link_label</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/links.html#validate_link_label"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.validate_link_label" title="Permalink to this definition">¶</a></dt>
<dd><p>Validate the given link label.</p>
<p>Valid link labels adhere to the following restrictions:</p>
<blockquote>
<div><ul class="simple">
<li>Has to be a valid python identifier</li>
<li>Can only contain alphanumeric characters and underscores</li>
<li>Can not start or end with an underscore</li>
</ul>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><strong>TypeError</strong> – if the link label is not a string type</li>
<li><strong>ValueError</strong> – if the link label is invalid</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<div class="section" id="module-aiida.common.archive">
<span id="submodules"></span><h2>Submodules<a class="headerlink" href="#module-aiida.common.archive" title="Permalink to this headline">¶</a></h2>
<p>Utility functions and classes to interact with AiiDA export archives.</p>
<dl class="class">
<dt id="aiida.common.archive.Archive">
<em class="property">class </em><code class="descclassname">aiida.common.archive.</code><code class="descname">Archive</code><span class="sig-paren">(</span><em>filepath</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/archive.html#Archive"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.archive.Archive" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Utility class to operate on exported archive files or directories.</p>
<p>The main usage should be to construct the class with the filepath of the export archive as an argument.
The contents will be lazily unpacked into a sand box folder which is constructed upon entering the instance
within a context and which will be automatically cleaned upon leaving that context. Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">Archive</span><span class="p">(</span><span class="s1">&#39;/some/path/archive.aiida&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">archive</span><span class="p">:</span>
    <span class="n">archive</span><span class="o">.</span><span class="n">version</span>
</pre></div>
</div>
<dl class="attribute">
<dt id="aiida.common.archive.Archive.FILENAME_DATA">
<code class="descname">FILENAME_DATA</code><em class="property"> = 'data.json'</em><a class="headerlink" href="#aiida.common.archive.Archive.FILENAME_DATA" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.archive.Archive.FILENAME_METADATA">
<code class="descname">FILENAME_METADATA</code><em class="property"> = 'metadata.json'</em><a class="headerlink" href="#aiida.common.archive.Archive.FILENAME_METADATA" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.archive.Archive.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'aiida.common.archive', '__doc__': &quot;\n    Utility class to operate on exported archive files or directories.\n\n    The main usage should be to construct the class with the filepath of the export archive as an argument.\n    The contents will be lazily unpacked into a sand box folder which is constructed upon entering the instance\n    within a context and which will be automatically cleaned upon leaving that context. Example::\n\n        with Archive('/some/path/archive.aiida') as archive:\n            archive.version\n\n    &quot;, 'FILENAME_DATA': 'data.json', 'FILENAME_METADATA': 'metadata.json', '__init__': &lt;function Archive.__init__&gt;, '__enter__': &lt;function Archive.__enter__&gt;, '__exit__': &lt;function Archive.__exit__&gt;, 'ensure_within_context': &lt;function Archive.ensure_within_context&gt;, 'ensure_unpacked': &lt;function Archive.ensure_unpacked&gt;, 'unpack': &lt;function Archive.unpack&gt;, 'filepath': &lt;property object&gt;, 'folder': &lt;property object&gt;, 'data': &lt;property object&gt;, 'meta_data': &lt;property object&gt;, 'unpacked': &lt;property object&gt;, 'get_info': &lt;function Archive.get_info&gt;, 'get_data_statistics': &lt;function Archive.get_data_statistics&gt;, 'version_aiida': &lt;property object&gt;, 'version_format': &lt;property object&gt;, 'conversion_info': &lt;property object&gt;, '_read_json_file': &lt;function Archive._read_json_file&gt;, '__dict__': &lt;attribute '__dict__' of 'Archive' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'Archive' objects&gt;})</em><a class="headerlink" href="#aiida.common.archive.Archive.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.common.archive.Archive.__enter__">
<code class="descname">__enter__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/archive.html#Archive.__enter__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.archive.Archive.__enter__" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiate a SandboxFolder into which the archive can be lazily unpacked.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.archive.Archive.__exit__">
<code class="descname">__exit__</code><span class="sig-paren">(</span><em>exc_type</em>, <em>exc_value</em>, <em>traceback</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/archive.html#Archive.__exit__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.archive.Archive.__exit__" title="Permalink to this definition">¶</a></dt>
<dd><p>Clean the sandbox folder if it was instatiated.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.archive.Archive.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>filepath</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/archive.html#Archive.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.archive.Archive.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.archive.Archive.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.archive'</em><a class="headerlink" href="#aiida.common.archive.Archive.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.archive.Archive.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#aiida.common.archive.Archive.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.archive.Archive._read_json_file">
<code class="descname">_read_json_file</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/archive.html#Archive._read_json_file"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.archive.Archive._read_json_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the contents of a JSON file from the unpacked archive contents.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> – the filename relative to the sandbox folder</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">a dictionary with the loaded JSON content</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.archive.Archive.conversion_info">
<code class="descname">conversion_info</code><a class="headerlink" href="#aiida.common.archive.Archive.conversion_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Return information about migration events that were applied to this archive.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">list of conversion notifications</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.archive.Archive.data">
<code class="descname">data</code><a class="headerlink" href="#aiida.common.archive.Archive.data" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the loaded content of the data file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dictionary with contents of data file</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.common.archive.Archive.ensure_unpacked">
<code class="descname">ensure_unpacked</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/archive.html#Archive.ensure_unpacked"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.archive.Archive.ensure_unpacked" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorator to ensure that the archive is unpacked before entering the decorated function.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.archive.Archive.ensure_within_context">
<code class="descname">ensure_within_context</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/archive.html#Archive.ensure_within_context"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.archive.Archive.ensure_within_context" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorator to ensure that the instance is called within a context manager.</p>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.archive.Archive.filepath">
<code class="descname">filepath</code><a class="headerlink" href="#aiida.common.archive.Archive.filepath" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the filepath of the archive</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the archive filepath</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.archive.Archive.folder">
<code class="descname">folder</code><a class="headerlink" href="#aiida.common.archive.Archive.folder" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sandbox folder</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">sandbox folder <a class="reference internal" href="#aiida.common.folders.SandboxFolder" title="aiida.common.folders.SandboxFolder"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.folders.SandboxFolder</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.common.archive.Archive.get_data_statistics">
<code class="descname">get_data_statistics</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/archive.html#Archive.get_data_statistics"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.archive.Archive.get_data_statistics" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a dictionary with statistics about data content, i.e. how many entries of each entity type it contains.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a dictionary with basic details</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.common.archive.Archive.get_info">
<code class="descname">get_info</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/archive.html#Archive.get_info"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.archive.Archive.get_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a dictionary with basic information about the archive.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a dictionary with basic details</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.archive.Archive.meta_data">
<code class="descname">meta_data</code><a class="headerlink" href="#aiida.common.archive.Archive.meta_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the loaded content of the meta data file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dictionary with contents of meta data file</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.common.archive.Archive.unpack">
<code class="descname">unpack</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/archive.html#Archive.unpack"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.archive.Archive.unpack" title="Permalink to this definition">¶</a></dt>
<dd><p>Unpack the archive and store the contents in a sandbox.</p>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.archive.Archive.unpacked">
<code class="descname">unpacked</code><a class="headerlink" href="#aiida.common.archive.Archive.unpacked" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether the archive has been unpacked into the sandbox folder.</p>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.archive.Archive.version_aiida">
<code class="descname">version_aiida</code><a class="headerlink" href="#aiida.common.archive.Archive.version_aiida" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the version of AiiDA the archive was created with.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">version number</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.archive.Archive.version_format">
<code class="descname">version_format</code><a class="headerlink" href="#aiida.common.archive.Archive.version_format" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the version of the archive format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">version number</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="aiida.common.archive.extract_tar">
<code class="descclassname">aiida.common.archive.</code><code class="descname">extract_tar</code><span class="sig-paren">(</span><em>infile</em>, <em>folder</em>, <em>nodes_export_subfolder='nodes'</em>, <em>silent=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/archive.html#extract_tar"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.archive.extract_tar" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract the nodes to be imported from a (possibly zipped) tar file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>infile</strong> – file path</li>
<li><strong>folder</strong> – a SandboxFolder, used to extract the file tree</li>
<li><strong>nodes_export_subfolder</strong> – name of the subfolder for AiiDA nodes</li>
<li><strong>silent</strong> – suppress debug print</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="aiida.common.archive.extract_tree">
<code class="descclassname">aiida.common.archive.</code><code class="descname">extract_tree</code><span class="sig-paren">(</span><em>infile</em>, <em>folder</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/archive.html#extract_tree"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.archive.extract_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepare to import nodes from plain file system tree.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>infile</strong> – path</li>
<li><strong>folder</strong> – a SandboxFolder, used to extract the file tree</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="aiida.common.archive.extract_zip">
<code class="descclassname">aiida.common.archive.</code><code class="descname">extract_zip</code><span class="sig-paren">(</span><em>infile</em>, <em>folder</em>, <em>nodes_export_subfolder='nodes'</em>, <em>silent=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/archive.html#extract_zip"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.archive.extract_zip" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract the nodes to be imported from a zip file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>infile</strong> – file path</li>
<li><strong>folder</strong> – a SandboxFolder, used to extract the file tree</li>
<li><strong>nodes_export_subfolder</strong> – name of the subfolder for AiiDA nodes</li>
<li><strong>silent</strong> – suppress debug print</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<span class="target" id="module-aiida.common.constants"></span><p>Module to define the (physical) constants used throughout the code.</p>
<span class="target" id="module-aiida.common.datastructures"></span><p>Module to define commonly used data structures.</p>
<dl class="class">
<dt id="aiida.common.datastructures.CalcJobState">
<em class="property">class </em><code class="descclassname">aiida.common.datastructures.</code><code class="descname">CalcJobState</code><a class="reference internal" href="../_modules/aiida/common/datastructures.html#CalcJobState"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.datastructures.CalcJobState" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">enum.Enum</span></code></p>
<p>The sub state of a CalcJobNode while its Process is in an active state (i.e. Running or Waiting).</p>
<dl class="attribute">
<dt id="aiida.common.datastructures.CalcJobState.PARSING">
<code class="descname">PARSING</code><em class="property"> = 'parsing'</em><a class="headerlink" href="#aiida.common.datastructures.CalcJobState.PARSING" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.datastructures.CalcJobState.RETRIEVING">
<code class="descname">RETRIEVING</code><em class="property"> = 'retrieving'</em><a class="headerlink" href="#aiida.common.datastructures.CalcJobState.RETRIEVING" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.datastructures.CalcJobState.SUBMITTING">
<code class="descname">SUBMITTING</code><em class="property"> = 'submitting'</em><a class="headerlink" href="#aiida.common.datastructures.CalcJobState.SUBMITTING" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.datastructures.CalcJobState.UPLOADING">
<code class="descname">UPLOADING</code><em class="property"> = 'uploading'</em><a class="headerlink" href="#aiida.common.datastructures.CalcJobState.UPLOADING" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.datastructures.CalcJobState.WITHSCHEDULER">
<code class="descname">WITHSCHEDULER</code><em class="property"> = 'withscheduler'</em><a class="headerlink" href="#aiida.common.datastructures.CalcJobState.WITHSCHEDULER" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.datastructures.CalcJobState.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.datastructures'</em><a class="headerlink" href="#aiida.common.datastructures.CalcJobState.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="aiida.common.datastructures.CalcInfo">
<em class="property">class </em><code class="descclassname">aiida.common.datastructures.</code><code class="descname">CalcInfo</code><a class="reference internal" href="../_modules/aiida/common/datastructures.html#CalcInfo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.datastructures.CalcInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.extendeddicts.DefaultFieldsAttributeDict" title="aiida.common.extendeddicts.DefaultFieldsAttributeDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.extendeddicts.DefaultFieldsAttributeDict</span></code></a></p>
<p>This object will store the data returned by the calculation plugin and to be
passed to the ExecManager.</p>
<p>In the following descriptions all paths have to be considered relative</p>
<ul>
<li><dl class="first docutils">
<dt>retrieve_list: a list of strings or tuples that indicate files that are to be retrieved from the remote</dt>
<dd><p class="first">after the calculation has finished and stored in the repository in a FolderData.
If the entry in the list is just a string, it is assumed to be the filepath on the remote and it will
be copied to ‘.’ of the repository with name os.path.split(item)[1]
If the entry is a tuple it is expected to have the following format</p>
<blockquote>
<div><p>(‘remotepath’, ‘localpath’, depth)</p>
</div></blockquote>
<p>If the ‘remotepath’ is a file or folder, it will be copied in the repository to ‘localpath’.
However, if the ‘remotepath’ contains file patterns with wildcards, the ‘localpath’ should be set to ‘.’
and the depth parameter should be an integer that decides the localname. The ‘remotepath’ will be split on
file separators and the local filename will be determined by joining the N last elements, where N is
given by the depth variable.</p>
<p>Example: (‘some/remote/path/files/pattern*[0-9].xml’, ‘.’, 2)</p>
<p>Will result in all files that match the pattern to be copied to the local repository with path</p>
<blockquote class="last">
<div><p>‘files/pattern*[0-9].xml’</p>
</div></blockquote>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>retrieve_temporary_list: a list of strings or tuples that indicate files that will be retrieved</dt>
<dd><p class="first last">and stored temporarily in a FolderData, that will be available only during the parsing call.
The format of the list is the same as that of ‘retrieve_list’</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>retrieve_singlefile_list: a list of tuples with format</dt>
<dd><p class="first last">(‘linkname_from calc to singlefile’, ‘subclass of singlefile’, ‘filename’)
Each tuple represents a file that will be retrieved from cluster and saved in SinglefileData nodes</p>
</dd>
</dl>
</li>
<li><p class="first">local_copy_list: a list of tuples with format (‘node_uuid’, ‘filename’, relativedestpath’)</p>
</li>
<li><p class="first">remote_copy_list: a list of tuples with format (‘remotemachinename’, ‘remoteabspath’, ‘relativedestpath’)</p>
</li>
<li><p class="first">remote_symlink_list: a list of tuples with format (‘remotemachinename’, ‘remoteabspath’, ‘relativedestpath’)</p>
</li>
<li><p class="first">codes_info: a list of dictionaries used to pass the info of the execution of a code</p>
</li>
<li><p class="first">codes_run_mode: a string used to specify the order in which multi codes can be executed</p>
</li>
</ul>
<dl class="attribute">
<dt id="aiida.common.datastructures.CalcInfo.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.datastructures'</em><a class="headerlink" href="#aiida.common.datastructures.CalcInfo.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.datastructures.CalcInfo._default_fields">
<code class="descname">_default_fields</code><em class="property"> = ('job_environment', 'email', 'email_on_started', 'email_on_terminated', 'uuid', 'prepend_text', 'append_text', 'num_machines', 'num_mpiprocs_per_machine', 'priority', 'max_wallclock_seconds', 'max_memory_kb', 'rerunnable', 'retrieve_list', 'retrieve_temporary_list', 'retrieve_singlefile_list', 'local_copy_list', 'remote_copy_list', 'remote_symlink_list', 'codes_info', 'codes_run_mode')</em><a class="headerlink" href="#aiida.common.datastructures.CalcInfo._default_fields" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="aiida.common.datastructures.CodeInfo">
<em class="property">class </em><code class="descclassname">aiida.common.datastructures.</code><code class="descname">CodeInfo</code><a class="reference internal" href="../_modules/aiida/common/datastructures.html#CodeInfo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.datastructures.CodeInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.extendeddicts.DefaultFieldsAttributeDict" title="aiida.common.extendeddicts.DefaultFieldsAttributeDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.extendeddicts.DefaultFieldsAttributeDict</span></code></a></p>
<p>This attribute-dictionary contains the information needed to execute a code.
Possible attributes are:</p>
<ul>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">cmdline_params</span></code>: a list of strings, containing parameters to be written on
the command line right after the call to the code, as for example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">code</span><span class="o">.</span><span class="n">x</span> <span class="n">cmdline_params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="n">cmdline_params</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">...</span> <span class="o">&lt;</span> <span class="n">stdin</span> <span class="o">&gt;</span> <span class="n">stdout</span>
</pre></div>
</div>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">stdin_name</span></code>: (optional) the name of the standard input file. Note, it is
only possible to use the stdin with the syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">code</span><span class="o">.</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">stdin_name</span>
</pre></div>
</div>
<p>If no stdin_name is specified, the string “&lt; stdin_name” will not be
passed to the code.
Note: it is not possible to substitute/remove the ‘&lt;’ if stdin_name is specified;
if that is needed, avoid stdin_name and use instead the cmdline_params to
specify a suitable syntax.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">stdout_name</span></code>: (optional) the name of the standard output file. Note, it is
only possible to pass output to stdout_name with the syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">code</span><span class="o">.</span><span class="n">x</span> <span class="o">...</span> <span class="o">&gt;</span> <span class="n">stdout_name</span>
</pre></div>
</div>
<p>If no stdout_name is specified, the string “&gt; stdout_name” will not be
passed to the code.
Note: it is not possible to substitute/remove the ‘&gt;’ if stdout_name is specified;
if that is needed, avoid stdout_name and use instead the cmdline_params to
specify a suitable syntax.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">stderr_name</span></code>: (optional) a string, the name of the error file of the code.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">join_files</span></code>: (optional) if True, redirects the error to the output file.
If join_files=True, the code will be called as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">code</span><span class="o">.</span><span class="n">x</span> <span class="o">...</span> <span class="o">&gt;</span> <span class="n">stdout_name</span> <span class="mi">2</span><span class="o">&gt;&amp;</span><span class="mi">1</span>
</pre></div>
</div>
<p>otherwise, if join_files=False and stderr is passed:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">code</span><span class="o">.</span><span class="n">x</span> <span class="o">...</span> <span class="o">&gt;</span> <span class="n">stdout_name</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">stderr_name</span>
</pre></div>
</div>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">withmpi</span></code>: if True, executes the code with mpirun (or another MPI installed
on the remote computer)</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">code_uuid</span></code>: the uuid of the code associated to the CodeInfo</p>
</li>
</ul>
<dl class="attribute">
<dt id="aiida.common.datastructures.CodeInfo.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.datastructures'</em><a class="headerlink" href="#aiida.common.datastructures.CodeInfo.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.datastructures.CodeInfo._default_fields">
<code class="descname">_default_fields</code><em class="property"> = ('cmdline_params', 'stdin_name', 'stdout_name', 'stderr_name', 'join_files', 'withmpi', 'code_uuid')</em><a class="headerlink" href="#aiida.common.datastructures.CodeInfo._default_fields" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="aiida.common.datastructures.CodeRunMode">
<em class="property">class </em><code class="descclassname">aiida.common.datastructures.</code><code class="descname">CodeRunMode</code><a class="reference internal" href="../_modules/aiida/common/datastructures.html#CodeRunMode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.datastructures.CodeRunMode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">enum.IntEnum</span></code></p>
<p>Enum to indicate the way the codes of a calculation should be run.</p>
<p>For PARALLEL, the codes for a given calculation will be run in parallel by running them in the background:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">code1</span><span class="o">.</span><span class="n">x</span> <span class="o">&amp;</span>
<span class="n">code2</span><span class="o">.</span><span class="n">x</span> <span class="o">&amp;</span>
</pre></div>
</div>
<p>For the SERIAL option, codes will be executed sequentially by running for example the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">code1</span><span class="o">.</span><span class="n">x</span>
<span class="n">code2</span><span class="o">.</span><span class="n">x</span>
</pre></div>
</div>
<dl class="attribute">
<dt id="aiida.common.datastructures.CodeRunMode.PARALLEL">
<code class="descname">PARALLEL</code><em class="property"> = 1</em><a class="headerlink" href="#aiida.common.datastructures.CodeRunMode.PARALLEL" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.datastructures.CodeRunMode.SERIAL">
<code class="descname">SERIAL</code><em class="property"> = 0</em><a class="headerlink" href="#aiida.common.datastructures.CodeRunMode.SERIAL" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.datastructures.CodeRunMode.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.datastructures'</em><a class="headerlink" href="#aiida.common.datastructures.CodeRunMode.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<span class="target" id="module-aiida.common.escaping"></span><p>Miscellaneous functions for escaping strings.</p>
<dl class="function">
<dt id="aiida.common.escaping.escape_for_bash">
<code class="descclassname">aiida.common.escaping.</code><code class="descname">escape_for_bash</code><span class="sig-paren">(</span><em>str_to_escape</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/escaping.html#escape_for_bash"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.escaping.escape_for_bash" title="Permalink to this definition">¶</a></dt>
<dd><p>This function takes any string and escapes it in a way that
bash will interpret it as a single string.</p>
<p>Explanation:</p>
<p>At the end, in the return statement, the string is put within single
quotes. Therefore, the only thing that I have to escape in bash is the
single quote character. To do this, I substitute every single
quote ‘ with ‘”’”’ which means:</p>
<p>First single quote: exit from the enclosing single quotes</p>
<p>Second, third and fourth character: “’” is a single quote character,
escaped by double quotes</p>
<p>Last single quote: reopen the single quote to continue the string</p>
<p>Finally, note that for python I have to enclose the string ‘”’”’
within triple quotes to make it work, getting finally: the complicated
string found below.</p>
</dd></dl>

<dl class="function">
<dt id="aiida.common.escaping.escape_for_sql_like">
<code class="descclassname">aiida.common.escaping.</code><code class="descname">escape_for_sql_like</code><span class="sig-paren">(</span><em>string</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/escaping.html#escape_for_sql_like"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.escaping.escape_for_sql_like" title="Permalink to this definition">¶</a></dt>
<dd><p>Function that escapes % or _ symbols provided by user</p>
<p>SQL LIKE syntax summary:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">%</span></code> -&gt; match any number of characters</li>
<li><code class="docutils literal notranslate"><span class="pre">_</span></code> -&gt; match exactly one character</li>
</ul>
</dd></dl>

<dl class="function">
<dt id="aiida.common.escaping.get_regex_pattern_from_sql">
<code class="descclassname">aiida.common.escaping.</code><code class="descname">get_regex_pattern_from_sql</code><span class="sig-paren">(</span><em>sql_pattern</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/escaping.html#get_regex_pattern_from_sql"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.escaping.get_regex_pattern_from_sql" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a string providing a pattern to match in SQL
syntax into a string performing the same match as a regex.</p>
<p>SQL LIKE syntax summary:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">%</span></code> -&gt; match any number of characters</li>
<li><code class="docutils literal notranslate"><span class="pre">_</span></code> -&gt; match exactly one character</li>
</ul>
<p>Moreover, <code class="docutils literal notranslate"><span class="pre">\</span></code> is the escape character (by default), so:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">\\</span></code> -&gt; single backslash</li>
<li><code class="docutils literal notranslate"><span class="pre">\%</span></code> -&gt; literal % symbol</li>
<li><code class="docutils literal notranslate"><span class="pre">\_</span></code> -&gt; literal _ symbol</li>
</ul>
<p>and moreover the string should begin at the beginning of the line
and end at the end of the line.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>sql_pattern</strong> – the string with the pattern in SQL syntax</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">a string with the pattern in regex syntax</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="aiida.common.escaping.sql_string_match">
<code class="descclassname">aiida.common.escaping.</code><code class="descname">sql_string_match</code><span class="sig-paren">(</span><em>string</em>, <em>pattern</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/escaping.html#sql_string_match"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.escaping.sql_string_match" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the string matches the provided pattern,
specified using SQL syntax.</p>
<p>See documentation of <a class="reference internal" href="#aiida.common.escaping.get_regex_pattern_from_sql" title="aiida.common.escaping.get_regex_pattern_from_sql"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_regex_pattern_from_sql()</span></code></a>
for an explanation of the syntax.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>string</strong> – the string to check</li>
<li><strong>pattern</strong> – the SQL pattern</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">True if the string matches, False otherwise</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<span class="target" id="module-aiida.common.exceptions"></span><p>Module that define the exceptions that are thrown by AiiDA’s internal code.</p>
<dl class="exception">
<dt id="aiida.common.exceptions.AiidaException">
<em class="property">exception </em><code class="descclassname">aiida.common.exceptions.</code><code class="descname">AiidaException</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#AiidaException"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.exceptions.AiidaException" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code></p>
<p>Base class for all AiiDA exceptions.</p>
<p>Each module will have its own subclass, inherited from this
(e.g. ExecManagerException, TransportException, …)</p>
<dl class="attribute">
<dt id="aiida.common.exceptions.AiidaException.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.exceptions.AiidaException.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.exceptions.AiidaException.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#aiida.common.exceptions.AiidaException.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.exceptions.NotExistent">
<em class="property">exception </em><code class="descclassname">aiida.common.exceptions.</code><code class="descname">NotExistent</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#NotExistent"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.exceptions.NotExistent" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Raised when the required entity does not exist.</p>
<dl class="attribute">
<dt id="aiida.common.exceptions.NotExistent.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.exceptions.NotExistent.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.exceptions.MultipleObjectsError">
<em class="property">exception </em><code class="descclassname">aiida.common.exceptions.</code><code class="descname">MultipleObjectsError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#MultipleObjectsError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.exceptions.MultipleObjectsError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Raised when more than one entity is found in the DB, but only one was
expected.</p>
<dl class="attribute">
<dt id="aiida.common.exceptions.MultipleObjectsError.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.exceptions.MultipleObjectsError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.exceptions.RemoteOperationError">
<em class="property">exception </em><code class="descclassname">aiida.common.exceptions.</code><code class="descname">RemoteOperationError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#RemoteOperationError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.exceptions.RemoteOperationError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Raised when an error in a remote operation occurs, as in a failed kill()
of a scheduler job.</p>
<dl class="attribute">
<dt id="aiida.common.exceptions.RemoteOperationError.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.exceptions.RemoteOperationError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.exceptions.ContentNotExistent">
<em class="property">exception </em><code class="descclassname">aiida.common.exceptions.</code><code class="descname">ContentNotExistent</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#ContentNotExistent"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.exceptions.ContentNotExistent" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.NotExistent" title="aiida.common.exceptions.NotExistent"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.NotExistent</span></code></a></p>
<p>Raised when trying to access an attribute, a key or a file in the result
nodes that is not present</p>
<dl class="attribute">
<dt id="aiida.common.exceptions.ContentNotExistent.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.exceptions.ContentNotExistent.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.exceptions.FailedError">
<em class="property">exception </em><code class="descclassname">aiida.common.exceptions.</code><code class="descname">FailedError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#FailedError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.exceptions.FailedError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Raised when accessing a calculation that is in the FAILED status</p>
<dl class="attribute">
<dt id="aiida.common.exceptions.FailedError.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.exceptions.FailedError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.exceptions.StoringNotAllowed">
<em class="property">exception </em><code class="descclassname">aiida.common.exceptions.</code><code class="descname">StoringNotAllowed</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#StoringNotAllowed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.exceptions.StoringNotAllowed" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Raised when the user tries to store an unstorable node (e.g. a base Node class)</p>
<dl class="attribute">
<dt id="aiida.common.exceptions.StoringNotAllowed.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.exceptions.StoringNotAllowed.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.exceptions.ModificationNotAllowed">
<em class="property">exception </em><code class="descclassname">aiida.common.exceptions.</code><code class="descname">ModificationNotAllowed</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#ModificationNotAllowed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.exceptions.ModificationNotAllowed" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Raised when the user tries to modify a field, object, property, … that should not
be modified.</p>
<dl class="attribute">
<dt id="aiida.common.exceptions.ModificationNotAllowed.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.exceptions.ModificationNotAllowed.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.exceptions.IntegrityError">
<em class="property">exception </em><code class="descclassname">aiida.common.exceptions.</code><code class="descname">IntegrityError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#IntegrityError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.exceptions.IntegrityError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Raised when there is an underlying data integrity error.  This can be database related
or a general data integrity error.  This can happen if, e.g., a foreign key check fails.
See PEP 249 for details.</p>
<dl class="attribute">
<dt id="aiida.common.exceptions.IntegrityError.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.exceptions.IntegrityError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.exceptions.UniquenessError">
<em class="property">exception </em><code class="descclassname">aiida.common.exceptions.</code><code class="descname">UniquenessError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#UniquenessError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.exceptions.UniquenessError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Raised when the user tries to violate a uniqueness constraint (on the
DB, for instance).</p>
<dl class="attribute">
<dt id="aiida.common.exceptions.UniquenessError.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.exceptions.UniquenessError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.exceptions.EntryPointError">
<em class="property">exception </em><code class="descclassname">aiida.common.exceptions.</code><code class="descname">EntryPointError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#EntryPointError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.exceptions.EntryPointError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Raised when an entry point cannot be uniquely resolved and imported.</p>
<dl class="attribute">
<dt id="aiida.common.exceptions.EntryPointError.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.exceptions.EntryPointError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.exceptions.MissingEntryPointError">
<em class="property">exception </em><code class="descclassname">aiida.common.exceptions.</code><code class="descname">MissingEntryPointError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#MissingEntryPointError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.exceptions.MissingEntryPointError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.EntryPointError" title="aiida.common.exceptions.EntryPointError"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.EntryPointError</span></code></a></p>
<p>Raised when the requested entry point is not registered with the entry point manager.</p>
<dl class="attribute">
<dt id="aiida.common.exceptions.MissingEntryPointError.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.exceptions.MissingEntryPointError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.exceptions.MultipleEntryPointError">
<em class="property">exception </em><code class="descclassname">aiida.common.exceptions.</code><code class="descname">MultipleEntryPointError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#MultipleEntryPointError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.exceptions.MultipleEntryPointError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.EntryPointError" title="aiida.common.exceptions.EntryPointError"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.EntryPointError</span></code></a></p>
<p>Raised when the requested entry point cannot uniquely be resolved by the entry point manager.</p>
<dl class="attribute">
<dt id="aiida.common.exceptions.MultipleEntryPointError.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.exceptions.MultipleEntryPointError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.exceptions.LoadingEntryPointError">
<em class="property">exception </em><code class="descclassname">aiida.common.exceptions.</code><code class="descname">LoadingEntryPointError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#LoadingEntryPointError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.exceptions.LoadingEntryPointError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.EntryPointError" title="aiida.common.exceptions.EntryPointError"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.EntryPointError</span></code></a></p>
<p>Raised when the resource corresponding to requested entry point cannot be imported.</p>
<dl class="attribute">
<dt id="aiida.common.exceptions.LoadingEntryPointError.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.exceptions.LoadingEntryPointError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.exceptions.InvalidOperation">
<em class="property">exception </em><code class="descclassname">aiida.common.exceptions.</code><code class="descname">InvalidOperation</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#InvalidOperation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.exceptions.InvalidOperation" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>The allowed operation is not valid (e.g., when trying to add a non-internal attribute
before saving the entry), or deleting an entry that is protected (e.g.,
because it is referenced by foreign keys)</p>
<dl class="attribute">
<dt id="aiida.common.exceptions.InvalidOperation.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.exceptions.InvalidOperation.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.exceptions.ParsingError">
<em class="property">exception </em><code class="descclassname">aiida.common.exceptions.</code><code class="descname">ParsingError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#ParsingError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.exceptions.ParsingError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Generic error raised when there is a parsing error</p>
<dl class="attribute">
<dt id="aiida.common.exceptions.ParsingError.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.exceptions.ParsingError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.exceptions.InternalError">
<em class="property">exception </em><code class="descclassname">aiida.common.exceptions.</code><code class="descname">InternalError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#InternalError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.exceptions.InternalError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Error raised when there is an internal error of AiiDA.</p>
<dl class="attribute">
<dt id="aiida.common.exceptions.InternalError.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.exceptions.InternalError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.exceptions.PluginInternalError">
<em class="property">exception </em><code class="descclassname">aiida.common.exceptions.</code><code class="descname">PluginInternalError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#PluginInternalError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.exceptions.PluginInternalError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.InternalError" title="aiida.common.exceptions.InternalError"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.InternalError</span></code></a></p>
<p>Error raised when there is an internal error which is due to a plugin
and not to the AiiDA infrastructure.</p>
<dl class="attribute">
<dt id="aiida.common.exceptions.PluginInternalError.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.exceptions.PluginInternalError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.exceptions.ValidationError">
<em class="property">exception </em><code class="descclassname">aiida.common.exceptions.</code><code class="descname">ValidationError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#ValidationError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.exceptions.ValidationError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Error raised when there is an error during the validation phase
of a property.</p>
<dl class="attribute">
<dt id="aiida.common.exceptions.ValidationError.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.exceptions.ValidationError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.exceptions.ConfigurationError">
<em class="property">exception </em><code class="descclassname">aiida.common.exceptions.</code><code class="descname">ConfigurationError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#ConfigurationError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.exceptions.ConfigurationError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Error raised when there is a configuration error in AiiDA.</p>
<dl class="attribute">
<dt id="aiida.common.exceptions.ConfigurationError.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.exceptions.ConfigurationError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.exceptions.ProfileConfigurationError">
<em class="property">exception </em><code class="descclassname">aiida.common.exceptions.</code><code class="descname">ProfileConfigurationError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#ProfileConfigurationError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.exceptions.ProfileConfigurationError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.ConfigurationError" title="aiida.common.exceptions.ConfigurationError"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.ConfigurationError</span></code></a></p>
<p>Configuration error raised when a wrong/inexistent profile is requested.</p>
<dl class="attribute">
<dt id="aiida.common.exceptions.ProfileConfigurationError.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.exceptions.ProfileConfigurationError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.exceptions.MissingConfigurationError">
<em class="property">exception </em><code class="descclassname">aiida.common.exceptions.</code><code class="descname">MissingConfigurationError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#MissingConfigurationError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.exceptions.MissingConfigurationError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.ConfigurationError" title="aiida.common.exceptions.ConfigurationError"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.ConfigurationError</span></code></a></p>
<p>Configuration error raised when the configuration file is missing.</p>
<dl class="attribute">
<dt id="aiida.common.exceptions.MissingConfigurationError.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.exceptions.MissingConfigurationError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.exceptions.ConfigurationVersionError">
<em class="property">exception </em><code class="descclassname">aiida.common.exceptions.</code><code class="descname">ConfigurationVersionError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#ConfigurationVersionError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.exceptions.ConfigurationVersionError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.ConfigurationError" title="aiida.common.exceptions.ConfigurationError"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.ConfigurationError</span></code></a></p>
<p>Configuration error raised when the configuration file version is not
compatible with the current version.</p>
<dl class="attribute">
<dt id="aiida.common.exceptions.ConfigurationVersionError.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.exceptions.ConfigurationVersionError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.exceptions.DbContentError">
<em class="property">exception </em><code class="descclassname">aiida.common.exceptions.</code><code class="descname">DbContentError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#DbContentError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.exceptions.DbContentError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Raised when the content of the DB is not valid.
This should never happen if the user does not play directly
with the DB.</p>
<dl class="attribute">
<dt id="aiida.common.exceptions.DbContentError.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.exceptions.DbContentError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.exceptions.InputValidationError">
<em class="property">exception </em><code class="descclassname">aiida.common.exceptions.</code><code class="descname">InputValidationError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#InputValidationError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.exceptions.InputValidationError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.ValidationError" title="aiida.common.exceptions.ValidationError"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.ValidationError</span></code></a></p>
<p>The input data for a calculation did not validate (e.g., missing
required input data, wrong data, …)</p>
<dl class="attribute">
<dt id="aiida.common.exceptions.InputValidationError.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.exceptions.InputValidationError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.exceptions.FeatureNotAvailable">
<em class="property">exception </em><code class="descclassname">aiida.common.exceptions.</code><code class="descname">FeatureNotAvailable</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#FeatureNotAvailable"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.exceptions.FeatureNotAvailable" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Raised when a feature is requested from a plugin, that is not available.</p>
<dl class="attribute">
<dt id="aiida.common.exceptions.FeatureNotAvailable.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.exceptions.FeatureNotAvailable.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.exceptions.FeatureDisabled">
<em class="property">exception </em><code class="descclassname">aiida.common.exceptions.</code><code class="descname">FeatureDisabled</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#FeatureDisabled"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.exceptions.FeatureDisabled" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Raised when a feature is requested, but the user has chosen to disable
it (e.g., for submissions on disabled computers).</p>
<dl class="attribute">
<dt id="aiida.common.exceptions.FeatureDisabled.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.exceptions.FeatureDisabled.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.exceptions.LicensingException">
<em class="property">exception </em><code class="descclassname">aiida.common.exceptions.</code><code class="descname">LicensingException</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#LicensingException"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.exceptions.LicensingException" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Raised when requirements for data licensing are not met.</p>
<dl class="attribute">
<dt id="aiida.common.exceptions.LicensingException.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.exceptions.LicensingException.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.exceptions.TestsNotAllowedError">
<em class="property">exception </em><code class="descclassname">aiida.common.exceptions.</code><code class="descname">TestsNotAllowedError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#TestsNotAllowedError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.exceptions.TestsNotAllowedError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.AiidaException" title="aiida.common.exceptions.AiidaException"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.AiidaException</span></code></a></p>
<p>Raised when tests are required to be run/loaded, but we are not in a testing environment.</p>
<p>This is to prevent data loss.</p>
<dl class="attribute">
<dt id="aiida.common.exceptions.TestsNotAllowedError.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.exceptions.TestsNotAllowedError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.exceptions.UnsupportedSpeciesError">
<em class="property">exception </em><code class="descclassname">aiida.common.exceptions.</code><code class="descname">UnsupportedSpeciesError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#UnsupportedSpeciesError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.exceptions.UnsupportedSpeciesError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">ValueError</span></code></p>
<p>Raised when StructureData operations are fed species that are not supported by AiiDA such as Deuterium</p>
<dl class="attribute">
<dt id="aiida.common.exceptions.UnsupportedSpeciesError.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.exceptions.UnsupportedSpeciesError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.exceptions.UnsupportedSpeciesError.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#aiida.common.exceptions.UnsupportedSpeciesError.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.exceptions.DanglingLinkError">
<em class="property">exception </em><code class="descclassname">aiida.common.exceptions.</code><code class="descname">DanglingLinkError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#DanglingLinkError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.exceptions.DanglingLinkError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code></p>
<p>Raised when an export archive is detected to contain dangling links when importing</p>
<dl class="attribute">
<dt id="aiida.common.exceptions.DanglingLinkError.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.exceptions.DanglingLinkError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.exceptions.DanglingLinkError.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#aiida.common.exceptions.DanglingLinkError.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.exceptions.TransportTaskException">
<em class="property">exception </em><code class="descclassname">aiida.common.exceptions.</code><code class="descname">TransportTaskException</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#TransportTaskException"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.exceptions.TransportTaskException" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code></p>
<p>Raised when a TransportTask, an task to be completed by the engine that requires transport, fails</p>
<dl class="attribute">
<dt id="aiida.common.exceptions.TransportTaskException.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.exceptions.TransportTaskException.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.exceptions.TransportTaskException.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#aiida.common.exceptions.TransportTaskException.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.exceptions.IncompatibleArchiveVersionError">
<em class="property">exception </em><code class="descclassname">aiida.common.exceptions.</code><code class="descname">IncompatibleArchiveVersionError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#IncompatibleArchiveVersionError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.exceptions.IncompatibleArchiveVersionError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code></p>
<p>Raised when trying to import an export archive with an incompatible schema version.</p>
<dl class="attribute">
<dt id="aiida.common.exceptions.IncompatibleArchiveVersionError.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.exceptions.IncompatibleArchiveVersionError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.exceptions.IncompatibleArchiveVersionError.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#aiida.common.exceptions.IncompatibleArchiveVersionError.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.exceptions.OutputParsingError">
<em class="property">exception </em><code class="descclassname">aiida.common.exceptions.</code><code class="descname">OutputParsingError</code><a class="reference internal" href="../_modules/aiida/common/exceptions.html#OutputParsingError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.exceptions.OutputParsingError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.exceptions.ParsingError" title="aiida.common.exceptions.ParsingError"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.exceptions.ParsingError</span></code></a></p>
<p>Can be raised by a Parser when it fails to parse the output generated by a <cite>CalcJob</cite> process.</p>
<dl class="attribute">
<dt id="aiida.common.exceptions.OutputParsingError.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.exceptions'</em><a class="headerlink" href="#aiida.common.exceptions.OutputParsingError.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<span class="target" id="module-aiida.common.extendeddicts"></span><p>Various dictionary types with extended functionality.</p>
<dl class="class">
<dt id="aiida.common.extendeddicts.AttributeDict">
<em class="property">class </em><code class="descclassname">aiida.common.extendeddicts.</code><code class="descname">AttributeDict</code><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#AttributeDict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.extendeddicts.AttributeDict" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></p>
<p>This class internally stores values in a dictionary, but exposes
the keys also as attributes, i.e. asking for attrdict.key
will return the value of attrdict[‘key’] and so on.</p>
<p>Raises an AttributeError if the key does not exist, when called as an attribute,
while the usual KeyError if the key does not exist and the dictionary syntax is
used.</p>
<dl class="method">
<dt id="aiida.common.extendeddicts.AttributeDict.__deepcopy__">
<code class="descname">__deepcopy__</code><span class="sig-paren">(</span><em>memo=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#AttributeDict.__deepcopy__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.extendeddicts.AttributeDict.__deepcopy__" title="Permalink to this definition">¶</a></dt>
<dd><p>Support deepcopy.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.extendeddicts.AttributeDict.__delattr__">
<code class="descname">__delattr__</code><span class="sig-paren">(</span><em>attr</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#AttributeDict.__delattr__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.extendeddicts.AttributeDict.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete a key as an attribute. Raise AttributeError on missing key.</p>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.extendeddicts.AttributeDict.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'aiida.common.extendeddicts', '__doc__': &quot;\n    This class internally stores values in a dictionary, but exposes\n    the keys also as attributes, i.e. asking for attrdict.key\n    will return the value of attrdict['key'] and so on.\n\n    Raises an AttributeError if the key does not exist, when called as an attribute,\n    while the usual KeyError if the key does not exist and the dictionary syntax is\n    used.\n    &quot;, '__repr__': &lt;function AttributeDict.__repr__&gt;, '__getattr__': &lt;function AttributeDict.__getattr__&gt;, '__setattr__': &lt;function AttributeDict.__setattr__&gt;, '__delattr__': &lt;function AttributeDict.__delattr__&gt;, 'copy': &lt;function AttributeDict.copy&gt;, '__deepcopy__': &lt;function AttributeDict.__deepcopy__&gt;, '__getstate__': &lt;function AttributeDict.__getstate__&gt;, '__setstate__': &lt;function AttributeDict.__setstate__&gt;, '__dir__': &lt;function AttributeDict.__dir__&gt;, '__dict__': &lt;attribute '__dict__' of 'AttributeDict' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'AttributeDict' objects&gt;})</em><a class="headerlink" href="#aiida.common.extendeddicts.AttributeDict.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.common.extendeddicts.AttributeDict.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#AttributeDict.__dir__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.extendeddicts.AttributeDict.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.extendeddicts.AttributeDict.__getattr__">
<code class="descname">__getattr__</code><span class="sig-paren">(</span><em>attr</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#AttributeDict.__getattr__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.extendeddicts.AttributeDict.__getattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a key as an attribute. Raise AttributeError on missing key.
Called only for attributes that do not exist.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.extendeddicts.AttributeDict.__getstate__">
<code class="descname">__getstate__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#AttributeDict.__getstate__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.extendeddicts.AttributeDict.__getstate__" title="Permalink to this definition">¶</a></dt>
<dd><p>Needed for pickling this class.</p>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.extendeddicts.AttributeDict.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.extendeddicts'</em><a class="headerlink" href="#aiida.common.extendeddicts.AttributeDict.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.common.extendeddicts.AttributeDict.__repr__">
<code class="descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#AttributeDict.__repr__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.extendeddicts.AttributeDict.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Representation of the object.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.extendeddicts.AttributeDict.__setattr__">
<code class="descname">__setattr__</code><span class="sig-paren">(</span><em>attr</em>, <em>value</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#AttributeDict.__setattr__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.extendeddicts.AttributeDict.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a key as an attribute.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.extendeddicts.AttributeDict.__setstate__">
<code class="descname">__setstate__</code><span class="sig-paren">(</span><em>dictionary</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#AttributeDict.__setstate__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.extendeddicts.AttributeDict.__setstate__" title="Permalink to this definition">¶</a></dt>
<dd><p>Needed for pickling this class.</p>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.extendeddicts.AttributeDict.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#aiida.common.extendeddicts.AttributeDict.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.extendeddicts.AttributeDict.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#AttributeDict.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.extendeddicts.AttributeDict.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Shallow copy.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="aiida.common.extendeddicts.FixedFieldsAttributeDict">
<em class="property">class </em><code class="descclassname">aiida.common.extendeddicts.</code><code class="descname">FixedFieldsAttributeDict</code><span class="sig-paren">(</span><em>init=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#FixedFieldsAttributeDict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.extendeddicts.FixedFieldsAttributeDict" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.extendeddicts.AttributeDict" title="aiida.common.extendeddicts.AttributeDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.extendeddicts.AttributeDict</span></code></a></p>
<p>A dictionary with access to the keys as attributes, and with filtering
of valid attributes.
This is only the base class, without valid attributes;
use a derived class to do the actual work.
E.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">TestExample</span><span class="p">(</span><span class="n">FixedFieldsAttributeDict</span><span class="p">):</span>
    <span class="n">_valid_fields</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">)</span>
</pre></div>
</div>
<dl class="method">
<dt id="aiida.common.extendeddicts.FixedFieldsAttributeDict.__dir__">
<code class="descname">__dir__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#FixedFieldsAttributeDict.__dir__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.extendeddicts.FixedFieldsAttributeDict.__dir__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default dir() implementation.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.extendeddicts.FixedFieldsAttributeDict.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>init=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#FixedFieldsAttributeDict.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.extendeddicts.FixedFieldsAttributeDict.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.extendeddicts.FixedFieldsAttributeDict.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.extendeddicts'</em><a class="headerlink" href="#aiida.common.extendeddicts.FixedFieldsAttributeDict.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.common.extendeddicts.FixedFieldsAttributeDict.__setattr__">
<code class="descname">__setattr__</code><span class="sig-paren">(</span><em>attr</em>, <em>value</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#FixedFieldsAttributeDict.__setattr__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.extendeddicts.FixedFieldsAttributeDict.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overridden to allow direct access to fields with underscore.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.extendeddicts.FixedFieldsAttributeDict.__setitem__">
<code class="descname">__setitem__</code><span class="sig-paren">(</span><em>item</em>, <em>value</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#FixedFieldsAttributeDict.__setitem__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.extendeddicts.FixedFieldsAttributeDict.__setitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a key as an attribute.</p>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.extendeddicts.FixedFieldsAttributeDict._valid_fields">
<code class="descname">_valid_fields</code><em class="property"> = ()</em><a class="headerlink" href="#aiida.common.extendeddicts.FixedFieldsAttributeDict._valid_fields" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="aiida.common.extendeddicts.FixedFieldsAttributeDict.get_valid_fields">
<em class="property">classmethod </em><code class="descname">get_valid_fields</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#FixedFieldsAttributeDict.get_valid_fields"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.extendeddicts.FixedFieldsAttributeDict.get_valid_fields" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of valid fields.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="aiida.common.extendeddicts.DefaultFieldsAttributeDict">
<em class="property">class </em><code class="descclassname">aiida.common.extendeddicts.</code><code class="descname">DefaultFieldsAttributeDict</code><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#DefaultFieldsAttributeDict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.extendeddicts.DefaultFieldsAttributeDict" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.extendeddicts.AttributeDict" title="aiida.common.extendeddicts.AttributeDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.extendeddicts.AttributeDict</span></code></a></p>
<p>A dictionary with access to the keys as attributes, and with an
internal value storing the ‘default’ keys to be distinguished
from extra fields.</p>
<p>Extra methods defaultkeys() and extrakeys() divide the set returned by
keys() in default keys (i.e. those defined at definition time)
and other keys.
There is also a method get_default_fields() to return the internal list.</p>
<p>Moreover, for undefined default keys, it returns None instead of raising a
KeyError/AttributeError exception.</p>
<p>Remember to define the _default_fields in a subclass!
E.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">TestExample</span><span class="p">(</span><span class="n">DefaultFieldsAttributeDict</span><span class="p">):</span>
    <span class="n">_default_fields</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>When the validate() method is called, it calls in turn all validate_KEY
methods, where KEY is one of the default keys.
If the method is not present, the field is considered to be always valid.
Each validate_KEY method should accept a single argument ‘value’ that will
contain the value to be checked.</p>
<p>It raises a ValidationError if any of the validate_KEY
function raises an exception, otherwise it simply returns.
NOTE: the <cite>validate_*</cite> functions are called also for unset fields, so if the
field can be empty on validation, you have to start your validation
function with something similar to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">return</span>
</pre></div>
</div>
<div class="admonition-todo admonition" id="index-1">
<p class="first admonition-title">Todo</p>
<p>Decide behavior if I set to None a field.
Current behavior, if
<code class="docutils literal notranslate"><span class="pre">a</span></code> is an instance and ‘def_field’ one of the default fields, that is
undefined, we get:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">a.get('def_field')</span></code>: None</li>
<li><code class="docutils literal notranslate"><span class="pre">a.get('def_field','whatever')</span></code>: ‘whatever’</li>
<li>Note that <code class="docutils literal notranslate"><span class="pre">a.defaultkeys()</span></code> does NOT contain ‘def_field’</li>
</ul>
<p>if we do <code class="docutils literal notranslate"><span class="pre">a.def_field</span> <span class="pre">=</span> <span class="pre">None</span></code>, then the behavior becomes</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">a.get('def_field')</span></code>: None</li>
<li><code class="docutils literal notranslate"><span class="pre">a.get('def_field','whatever')</span></code>: None</li>
<li>Note that <code class="docutils literal notranslate"><span class="pre">a.defaultkeys()</span></code> DOES contain ‘def_field’</li>
</ul>
<p class="last">See if we want that setting a default field to None means deleting it.</p>
</div>
<dl class="method">
<dt id="aiida.common.extendeddicts.DefaultFieldsAttributeDict.__getitem__">
<code class="descname">__getitem__</code><span class="sig-paren">(</span><em>key</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#DefaultFieldsAttributeDict.__getitem__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.extendeddicts.DefaultFieldsAttributeDict.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return None instead of raising an exception if the key does not exist
but is in the list of default fields.</p>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.extendeddicts.DefaultFieldsAttributeDict.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.extendeddicts'</em><a class="headerlink" href="#aiida.common.extendeddicts.DefaultFieldsAttributeDict.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.common.extendeddicts.DefaultFieldsAttributeDict.__setattr__">
<code class="descname">__setattr__</code><span class="sig-paren">(</span><em>attr</em>, <em>value</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#DefaultFieldsAttributeDict.__setattr__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.extendeddicts.DefaultFieldsAttributeDict.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overridden to allow direct access to fields with underscore.</p>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.extendeddicts.DefaultFieldsAttributeDict._default_fields">
<code class="descname">_default_fields</code><em class="property"> = ()</em><a class="headerlink" href="#aiida.common.extendeddicts.DefaultFieldsAttributeDict._default_fields" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.common.extendeddicts.DefaultFieldsAttributeDict.defaultkeys">
<code class="descname">defaultkeys</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#DefaultFieldsAttributeDict.defaultkeys"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.extendeddicts.DefaultFieldsAttributeDict.defaultkeys" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the default keys defined in the instance.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.extendeddicts.DefaultFieldsAttributeDict.extrakeys">
<code class="descname">extrakeys</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#DefaultFieldsAttributeDict.extrakeys"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.extendeddicts.DefaultFieldsAttributeDict.extrakeys" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the extra keys defined in the instance.</p>
</dd></dl>

<dl class="classmethod">
<dt id="aiida.common.extendeddicts.DefaultFieldsAttributeDict.get_default_fields">
<em class="property">classmethod </em><code class="descname">get_default_fields</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#DefaultFieldsAttributeDict.get_default_fields"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.extendeddicts.DefaultFieldsAttributeDict.get_default_fields" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of default fields, either defined in the instance or not.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.extendeddicts.DefaultFieldsAttributeDict.validate">
<code class="descname">validate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/extendeddicts.html#DefaultFieldsAttributeDict.validate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.extendeddicts.DefaultFieldsAttributeDict.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>Validate the keys, if any <code class="docutils literal notranslate"><span class="pre">validate_*</span></code> method is available.</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-aiida.common.files"></span><p>Utility functions to operate on filesystem files.</p>
<dl class="function">
<dt id="aiida.common.files.get_mode_string">
<code class="descclassname">aiida.common.files.</code><code class="descname">get_mode_string</code><span class="sig-paren">(</span><em>mode</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/files.html#get_mode_string"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.files.get_mode_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a file’s mode to a string of the form ‘-rwxrwxrwx’.
Taken (simplified) from cpython 3.3 stat module: <a class="reference external" href="https://hg.python.org/cpython/file/3.3/Lib/stat.py">https://hg.python.org/cpython/file/3.3/Lib/stat.py</a></p>
</dd></dl>

<dl class="function">
<dt id="aiida.common.files.md5_file">
<code class="descclassname">aiida.common.files.</code><code class="descname">md5_file</code><span class="sig-paren">(</span><em>filepath</em>, <em>block_size_factor=128</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/files.html#md5_file"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.files.md5_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the hexdigested md5 checksum of the contents from</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>filepath</strong> – the filepath of the file for which we want the md5sum</li>
<li><strong>block_size_factor</strong> – the file is read at chunks of size <code class="docutils literal notranslate"><span class="pre">block_size_factor</span> <span class="pre">*</span> <span class="pre">md5.block_size</span></code>, where
<code class="docutils literal notranslate"><span class="pre">md5.block_size</span></code> is the block_size used internally by the hashlib module.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">a string with the hexdigest md5.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last">No checks are done on the file, so if it doesn’t exists it may
raise IOError.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="aiida.common.files.md5_from_filelike">
<code class="descclassname">aiida.common.files.</code><code class="descname">md5_from_filelike</code><span class="sig-paren">(</span><em>filelike</em>, <em>block_size_factor=128</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/files.html#md5_from_filelike"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.files.md5_from_filelike" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the hexdigested md5 checksum of the contents from a filelike object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>filelike</strong> – the filelike object for whose contents to generate the md5 checksum</li>
<li><strong>block_size_factor</strong> – the file is read at chunks of size <code class="docutils literal notranslate"><span class="pre">block_size_factor</span> <span class="pre">*</span> <span class="pre">md5.block_size</span></code>, where
<code class="docutils literal notranslate"><span class="pre">md5.block_size</span></code> is the block_size used internally by the hashlib module.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">a string with the hexdigest md5.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last">no checks are done on the filelike object, so it may raise IOError if it cannot be read from.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="aiida.common.files.sha1_file">
<code class="descclassname">aiida.common.files.</code><code class="descname">sha1_file</code><span class="sig-paren">(</span><em>filename</em>, <em>block_size_factor=128</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/files.html#sha1_file"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.files.sha1_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Open a file and return its sha1sum (hexdigested).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>filename</strong> – the filename of the file for which we want the sha1sum</li>
<li><strong>block_size_factor</strong> – the file is read at chunks of size
<code class="docutils literal notranslate"><span class="pre">block_size_factor</span> <span class="pre">*</span> <span class="pre">sha1.block_size</span></code>,
where <code class="docutils literal notranslate"><span class="pre">sha1.block_size</span></code> is the block_size used internally by the
hashlib module.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">a string with the hexdigest sha1.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last">No checks are done on the file, so if it doesn’t exists it may
raise IOError.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="aiida.common.files.which">
<code class="descclassname">aiida.common.files.</code><code class="descname">which</code><span class="sig-paren">(</span><em>cmd</em>, <em>mode=1</em>, <em>path=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/files.html#which"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.files.which" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a command, mode, and a PATH string, return the path which
conforms to the given mode on the PATH, or None if there is no such
file.</p>
<p><cite>mode</cite> defaults to os.F_OK | os.X_OK. <cite>path</cite> defaults to the result
of os.environ.get(“PATH”), or can be overridden with a custom search
path.</p>
</dd></dl>

<span class="target" id="module-aiida.common.folders"></span><p>Utility functions to operate on filesystem folders.</p>
<dl class="class">
<dt id="aiida.common.folders.Folder">
<em class="property">class </em><code class="descclassname">aiida.common.folders.</code><code class="descname">Folder</code><span class="sig-paren">(</span><em>abspath</em>, <em>folder_limit=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/folders.html#Folder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.folders.Folder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A class to manage generic folders, avoiding to get out of
specific given folder borders.</p>
<div class="admonition-todo admonition" id="index-2">
<p class="first admonition-title">Todo</p>
<p class="last">fix this, os.path.commonprefix of /a/b/c and /a/b2/c will give
a/b, check if this is wanted or if we want to put trailing slashes.
(or if we want to use os.path.relpath and check for a string starting
with os.pardir?)</p>
</div>
<div class="admonition-todo admonition" id="index-3">
<p class="first admonition-title">Todo</p>
<p class="last">rethink whether the folder_limit option is still useful. If not, remove
it alltogether (it was a nice feature, but unfortunately all the calls
to os.path.abspath or normpath are quite slow).</p>
</div>
<dl class="attribute">
<dt id="aiida.common.folders.Folder.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'aiida.common.folders', '__doc__': '\n    A class to manage generic folders, avoiding to get out of\n    specific given folder borders.\n\n    .. todo::\n        fix this, os.path.commonprefix of /a/b/c and /a/b2/c will give\n        a/b, check if this is wanted or if we want to put trailing slashes.\n        (or if we want to use os.path.relpath and check for a string starting\n        with os.pardir?)\n\n    .. todo::\n        rethink whether the folder_limit option is still useful. If not, remove\n        it alltogether (it was a nice feature, but unfortunately all the calls\n        to os.path.abspath or normpath are quite slow).\n    ', '__init__': &lt;function Folder.__init__&gt;, 'mode_dir': &lt;property object&gt;, 'mode_file': &lt;property object&gt;, 'get_subfolder': &lt;function Folder.get_subfolder&gt;, 'get_content_list': &lt;function Folder.get_content_list&gt;, 'create_symlink': &lt;function Folder.create_symlink&gt;, 'insert_path': &lt;function Folder.insert_path&gt;, 'create_file_from_filelike': &lt;function Folder.create_file_from_filelike&gt;, 'remove_path': &lt;function Folder.remove_path&gt;, 'get_abs_path': &lt;function Folder.get_abs_path&gt;, 'open': &lt;function Folder.open&gt;, 'abspath': &lt;property object&gt;, 'folder_limit': &lt;property object&gt;, 'exists': &lt;function Folder.exists&gt;, 'isfile': &lt;function Folder.isfile&gt;, 'isdir': &lt;function Folder.isdir&gt;, 'erase': &lt;function Folder.erase&gt;, 'create': &lt;function Folder.create&gt;, 'replace_with_folder': &lt;function Folder.replace_with_folder&gt;, '__dict__': &lt;attribute '__dict__' of 'Folder' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'Folder' objects&gt;})</em><a class="headerlink" href="#aiida.common.folders.Folder.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.common.folders.Folder.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>abspath</em>, <em>folder_limit=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/folders.html#Folder.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.folders.Folder.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.folders.Folder.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.folders'</em><a class="headerlink" href="#aiida.common.folders.Folder.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.folders.Folder.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#aiida.common.folders.Folder.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.folders.Folder.abspath">
<code class="descname">abspath</code><a class="headerlink" href="#aiida.common.folders.Folder.abspath" title="Permalink to this definition">¶</a></dt>
<dd><p>The absolute path of the folder.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.folders.Folder.create">
<code class="descname">create</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/folders.html#Folder.create"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.folders.Folder.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the folder, if it does not exist on the disk yet.</p>
<p>It will also create top directories, if absent.</p>
<p>It is always safe to call it, it will do nothing if the folder
already exists.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.folders.Folder.create_file_from_filelike">
<code class="descname">create_file_from_filelike</code><span class="sig-paren">(</span><em>filelike</em>, <em>filename</em>, <em>mode='wb'</em>, <em>encoding=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/folders.html#Folder.create_file_from_filelike"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.folders.Folder.create_file_from_filelike" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a file with the given filename from a filelike object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>filelike</strong> – a filelike object whose contents to copy</li>
<li><strong>filename</strong> – the filename for the file that is to be created</li>
<li><strong>mode</strong> – the mode with which the target file will be written</li>
<li><strong>encoding</strong> – the encoding with which the target file will be written</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the absolute filepath of the created file</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.common.folders.Folder.create_symlink">
<code class="descname">create_symlink</code><span class="sig-paren">(</span><em>src</em>, <em>name</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/folders.html#Folder.create_symlink"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.folders.Folder.create_symlink" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a symlink inside the folder to the location ‘src’.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> – the location to which the symlink must point. Can be
either a relative or an absolute path. Should, however,
be relative to work properly also when the repository is
moved!</li>
<li><strong>name</strong> – the filename of the symlink to be created.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.common.folders.Folder.erase">
<code class="descname">erase</code><span class="sig-paren">(</span><em>create_empty_folder=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/folders.html#Folder.erase"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.folders.Folder.erase" title="Permalink to this definition">¶</a></dt>
<dd><p>Erases the folder. Should be called only in very specific cases,
in general folder should not be erased!</p>
<p>Doesn’t complain if the folder does not exist.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>create_empty_folder</strong> – if True, after erasing, creates an empty dir.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.common.folders.Folder.exists">
<code class="descname">exists</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/folders.html#Folder.exists"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.folders.Folder.exists" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the folder exists, False otherwise.</p>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.folders.Folder.folder_limit">
<code class="descname">folder_limit</code><a class="headerlink" href="#aiida.common.folders.Folder.folder_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>The folder limit that cannot be crossed when creating files and folders.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.folders.Folder.get_abs_path">
<code class="descname">get_abs_path</code><span class="sig-paren">(</span><em>relpath</em>, <em>check_existence=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/folders.html#Folder.get_abs_path"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.folders.Folder.get_abs_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an absolute path for a file or folder in this folder.</p>
<p>The advantage of using this method is that it checks that filename
is a valid filename within this folder,
and not something e.g. containing slashes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filename</strong> – The file or directory.</li>
<li><strong>check_existence</strong> – if False, just return the file path.
Otherwise, also check if the file or directory actually exists.
Raise OSError if it does not.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.common.folders.Folder.get_content_list">
<code class="descname">get_content_list</code><span class="sig-paren">(</span><em>pattern='*'</em>, <em>only_paths=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/folders.html#Folder.get_content_list"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.folders.Folder.get_content_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of files (and subfolders) in the folder,
matching a given pattern.</p>
<p>Example: If you want to exclude files starting with a dot, you can
call this method with <code class="docutils literal notranslate"><span class="pre">pattern='[!.]*'</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>pattern</strong> – a pattern for the file/folder names, using Unix filename
pattern matching (see Python standard module fnmatch).
By default, pattern is ‘*’, matching all files and folders.</li>
<li><strong>only_paths</strong> – if False (default), return pairs (name, is_file).
if True, return only a flat list.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a list of tuples of two elements, the first is the file name and
the second is True if the element is a file, False if it is a
directory.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.common.folders.Folder.get_subfolder">
<code class="descname">get_subfolder</code><span class="sig-paren">(</span><em>subfolder</em>, <em>create=False</em>, <em>reset_limit=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/folders.html#Folder.get_subfolder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.folders.Folder.get_subfolder" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a Folder object pointing to a subfolder.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>subfolder</strong> – a string with the relative path of the subfolder,
relative to the absolute path of this object. Note that
this may also contain ‘..’ parts,
as far as this does not go beyond the folder_limit.</li>
<li><strong>create</strong> – if True, the new subfolder is created, if it does not exist.</li>
<li><strong>reset_limit</strong> – when doing <code class="docutils literal notranslate"><span class="pre">b</span> <span class="pre">=</span> <span class="pre">a.get_subfolder('xxx',</span> <span class="pre">reset_limit=False)</span></code>,
the limit of b will be the same limit of a.
if True, the limit will be set to the boundaries of folder b.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a Folder object pointing to the subfolder.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.common.folders.Folder.insert_path">
<code class="descname">insert_path</code><span class="sig-paren">(</span><em>src</em>, <em>dest_name=None</em>, <em>overwrite=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/folders.html#Folder.insert_path"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.folders.Folder.insert_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy a file to the folder.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> – the source filename to copy</li>
<li><strong>dest_name</strong> – if None, the same basename of src is used. Otherwise,
the destination filename will have this file name.</li>
<li><strong>overwrite</strong> – if <code class="docutils literal notranslate"><span class="pre">False</span></code>, raises an error on existing destination;
otherwise, delete it first.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.common.folders.Folder.isdir">
<code class="descname">isdir</code><span class="sig-paren">(</span><em>relpath</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/folders.html#Folder.isdir"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.folders.Folder.isdir" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if ‘relpath’ exists inside the folder and is a directory,
False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.folders.Folder.isfile">
<code class="descname">isfile</code><span class="sig-paren">(</span><em>relpath</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/folders.html#Folder.isfile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.folders.Folder.isfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if ‘relpath’ exists inside the folder and is a file,
False otherwise.</p>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.folders.Folder.mode_dir">
<code class="descname">mode_dir</code><a class="headerlink" href="#aiida.common.folders.Folder.mode_dir" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the mode with which the folders should be created</p>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.folders.Folder.mode_file">
<code class="descname">mode_file</code><a class="headerlink" href="#aiida.common.folders.Folder.mode_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the mode with which the files should be created</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.folders.Folder.open">
<code class="descname">open</code><span class="sig-paren">(</span><em>name</em>, <em>mode='r'</em>, <em>encoding='utf8'</em>, <em>check_existence=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/folders.html#Folder.open"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.folders.Folder.open" title="Permalink to this definition">¶</a></dt>
<dd><p>Open a file in the current folder and return the corresponding file object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>check_existence</strong> – if False, just return the file path.
Otherwise, also check if the file or directory actually exists.
Raise OSError if it does not.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.common.folders.Folder.remove_path">
<code class="descname">remove_path</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/folders.html#Folder.remove_path"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.folders.Folder.remove_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a file or folder from the folder.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> – the relative path name to remove</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.common.folders.Folder.replace_with_folder">
<code class="descname">replace_with_folder</code><span class="sig-paren">(</span><em>srcdir</em>, <em>move=False</em>, <em>overwrite=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/folders.html#Folder.replace_with_folder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.folders.Folder.replace_with_folder" title="Permalink to this definition">¶</a></dt>
<dd><p>This routine copies or moves the source folder ‘srcdir’ to the local
folder pointed by this Folder object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>srcdir</strong> – the source folder on the disk; this must be a string with
an absolute path</li>
<li><strong>move</strong> – if True, the srcdir is moved to the repository. Otherwise, it
is only copied.</li>
<li><strong>overwrite</strong> – if True, the folder will be erased first.
if False, a IOError is raised if the folder already exists.
Whatever the value of this flag, parent directories will be
created, if needed.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first">OSError or IOError: in case of problems accessing or writing
the files.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last">ValueError: if the section is not recognized.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="aiida.common.folders.RepositoryFolder">
<em class="property">class </em><code class="descclassname">aiida.common.folders.</code><code class="descname">RepositoryFolder</code><span class="sig-paren">(</span><em>section</em>, <em>uuid</em>, <em>subfolder='.'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/folders.html#RepositoryFolder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.folders.RepositoryFolder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.folders.Folder" title="aiida.common.folders.Folder"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.folders.Folder</span></code></a></p>
<p>A class to manage the local AiiDA repository folders.</p>
<dl class="method">
<dt id="aiida.common.folders.RepositoryFolder.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>section</em>, <em>uuid</em>, <em>subfolder='.'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/folders.html#RepositoryFolder.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.folders.RepositoryFolder.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes the object by pointing it to a folder in the repository.</p>
<p>Pass the uuid as a string.</p>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.folders.RepositoryFolder.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.folders'</em><a class="headerlink" href="#aiida.common.folders.RepositoryFolder.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.common.folders.RepositoryFolder.get_topdir">
<code class="descname">get_topdir</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/folders.html#RepositoryFolder.get_topdir"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.folders.RepositoryFolder.get_topdir" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the top directory, i.e., the section/uuid folder object.</p>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.folders.RepositoryFolder.section">
<code class="descname">section</code><a class="headerlink" href="#aiida.common.folders.RepositoryFolder.section" title="Permalink to this definition">¶</a></dt>
<dd><p>The section to which this folder belongs.</p>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.folders.RepositoryFolder.subfolder">
<code class="descname">subfolder</code><a class="headerlink" href="#aiida.common.folders.RepositoryFolder.subfolder" title="Permalink to this definition">¶</a></dt>
<dd><p>The subfolder within the section/uuid folder.</p>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.folders.RepositoryFolder.uuid">
<code class="descname">uuid</code><a class="headerlink" href="#aiida.common.folders.RepositoryFolder.uuid" title="Permalink to this definition">¶</a></dt>
<dd><p>The uuid to which this folder belongs.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="aiida.common.folders.SandboxFolder">
<em class="property">class </em><code class="descclassname">aiida.common.folders.</code><code class="descname">SandboxFolder</code><span class="sig-paren">(</span><em>sandbox_in_repo=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/folders.html#SandboxFolder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.folders.SandboxFolder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.folders.Folder" title="aiida.common.folders.Folder"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.folders.Folder</span></code></a></p>
<p>A class to manage the creation and management of a sandbox folder.</p>
<p>Note: this class must be used within a context manager, i.e.:</p>
<dl class="docutils">
<dt>with SandboxFolder as f:</dt>
<dd>## do something with f</dd>
</dl>
<p>In this way, the sandbox folder is removed from disk
(if it wasn’t removed already) when exiting the ‘with’ block.</p>
<div class="admonition-todo admonition" id="index-4">
<p class="first admonition-title">Todo</p>
<p class="last">Implement check of whether the folder has been removed.</p>
</div>
<dl class="method">
<dt id="aiida.common.folders.SandboxFolder.__enter__">
<code class="descname">__enter__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/folders.html#SandboxFolder.__enter__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.folders.SandboxFolder.__enter__" title="Permalink to this definition">¶</a></dt>
<dd><p>Called when entering in the with statement</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.folders.SandboxFolder.__exit__">
<code class="descname">__exit__</code><span class="sig-paren">(</span><em>exc_type</em>, <em>exc_value</em>, <em>traceback</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/folders.html#SandboxFolder.__exit__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.folders.SandboxFolder.__exit__" title="Permalink to this definition">¶</a></dt>
<dd><p>In exit, I remove the sandbox folder from disk, if it still exists</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.folders.SandboxFolder.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>sandbox_in_repo=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/folders.html#SandboxFolder.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.folders.SandboxFolder.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes the object by creating a new temporary folder in the
sandbox.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>sandbox_in_repo</strong> (<em>bool</em>) – If True (default), creates the folder in the repository.
If false,  relies on the defaults of tempfile.mkdtemp</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.folders.SandboxFolder.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.folders'</em><a class="headerlink" href="#aiida.common.folders.SandboxFolder.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="aiida.common.folders.SubmitTestFolder">
<em class="property">class </em><code class="descclassname">aiida.common.folders.</code><code class="descname">SubmitTestFolder</code><span class="sig-paren">(</span><em>basepath='submit_test'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/folders.html#SubmitTestFolder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.folders.SubmitTestFolder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#aiida.common.folders.Folder" title="aiida.common.folders.Folder"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.folders.Folder</span></code></a></p>
<p>Sandbox folder that can be used for the test submission of <cite>CalcJobs</cite>.</p>
<p>The directory will be created in the current working directory with a configurable basename.
Then a sub folder will be created within this base folder based on the current date and an index in order to
not overwrite already existing created test folders.</p>
<dl class="method">
<dt id="aiida.common.folders.SubmitTestFolder.__enter__">
<code class="descname">__enter__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/folders.html#SubmitTestFolder.__enter__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.folders.SubmitTestFolder.__enter__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sub folder that should be Called when entering in the with statement.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.folders.SubmitTestFolder.__exit__">
<code class="descname">__exit__</code><span class="sig-paren">(</span><em>exc_type</em>, <em>exc_value</em>, <em>traceback</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/folders.html#SubmitTestFolder.__exit__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.folders.SubmitTestFolder.__exit__" title="Permalink to this definition">¶</a></dt>
<dd><p>When context manager is exited, do not delete the folder.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.folders.SubmitTestFolder.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>basepath='submit_test'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/folders.html#SubmitTestFolder.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.folders.SubmitTestFolder.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct and create the sandbox folder.</p>
<p>The directory will be created in the current working directory with the name given by <cite>basepath</cite>.
Then a sub folder will be created within this base folder based on the current date and an index in order to
not overwrite already existing created test folders.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>basepath</strong> – name of the base directory that will be created in the current working directory</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.folders.SubmitTestFolder.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.folders'</em><a class="headerlink" href="#aiida.common.folders.SubmitTestFolder.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.folders.SubmitTestFolder._sub_folder">
<code class="descname">_sub_folder</code><em class="property"> = None</em><a class="headerlink" href="#aiida.common.folders.SubmitTestFolder._sub_folder" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<span class="target" id="module-aiida.common.hashing"></span><p>Common password and hash generation functions.</p>
<dl class="function">
<dt id="aiida.common.hashing._">
<code class="descclassname">aiida.common.hashing.</code><code class="descname">_</code><span class="sig-paren">(</span><em>arr</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/hashing.html#_"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.hashing._" title="Permalink to this definition">¶</a></dt>
<dd><p>Hashing for Numpy arrays</p>
</dd></dl>

<dl class="function">
<dt id="aiida.common.hashing._make_hash">
<code class="descclassname">aiida.common.hashing.</code><code class="descname">_make_hash</code><span class="sig-paren">(</span><em>object_to_hash</em>, <em>**_</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/hashing.html#_make_hash"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.hashing._make_hash" title="Permalink to this definition">¶</a></dt>
<dd><p>Implementation of the <code class="docutils literal notranslate"><span class="pre">make_hash</span></code> function. The hash is created as a
28 byte integer, and only later converted to a string.</p>
</dd></dl>

<dl class="function">
<dt id="aiida.common.hashing._single_digest">
<code class="descclassname">aiida.common.hashing.</code><code class="descname">_single_digest</code><span class="sig-paren">(</span><em>obj_type</em>, <em>obj_bytes=b''</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/hashing.html#_single_digest"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.hashing._single_digest" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="aiida.common.hashing.create_unusable_pass">
<code class="descclassname">aiida.common.hashing.</code><code class="descname">create_unusable_pass</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/hashing.html#create_unusable_pass"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.hashing.create_unusable_pass" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="aiida.common.hashing.get_random_string">
<code class="descclassname">aiida.common.hashing.</code><code class="descname">get_random_string</code><span class="sig-paren">(</span><em>length=12</em>, <em>allowed_chars='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/hashing.html#get_random_string"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.hashing.get_random_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a securely generated random string.</p>
<p>The default length of 12 with the a-z, A-Z, 0-9 character set returns
a 71-bit value. log_2((26+26+10)^12) =~ 71 bits</p>
</dd></dl>

<dl class="function">
<dt id="aiida.common.hashing.is_password_usable">
<code class="descclassname">aiida.common.hashing.</code><code class="descname">is_password_usable</code><span class="sig-paren">(</span><em>enc_pass</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/hashing.html#is_password_usable"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.hashing.is_password_usable" title="Permalink to this definition">¶</a></dt>
<dd><p>check whether the passed password string is a valid hashed password</p>
</dd></dl>

<dl class="function">
<dt id="aiida.common.hashing.make_hash">
<code class="descclassname">aiida.common.hashing.</code><code class="descname">make_hash</code><span class="sig-paren">(</span><em>object_to_hash</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/hashing.html#make_hash"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.hashing.make_hash" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes a hash from a dictionary, list, tuple or set to any level, that contains
only other hashable or nonhashable types (including lists, tuples, sets, and
dictionaries).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>object_to_hash</strong> – the object to hash</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">a unique hash</td>
</tr>
</tbody>
</table>
<p>There are a lot of modules providing functionalities to create unique
hashes for hashable values.
However, getting hashes for nonhashable items like sets or dictionaries is
not easily doable because order is not fixed.
This leads to the peril of getting different hashes for the same
dictionary.</p>
<p>This function avoids this by recursing through nonhashable items and
hashing iteratively. Uses python’s sorted function to sort unsorted
sets and dictionaries by sorting the hashed keys.</p>
</dd></dl>

<dl class="function">
<dt id="aiida.common.hashing.truncate_array64">
<code class="descclassname">aiida.common.hashing.</code><code class="descname">truncate_array64</code><span class="sig-paren">(</span><em>value</em>, <em>num_bits=4</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/hashing.html#truncate_array64"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.hashing.truncate_array64" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="aiida.common.hashing.truncate_float64">
<code class="descclassname">aiida.common.hashing.</code><code class="descname">truncate_float64</code><span class="sig-paren">(</span><em>value</em>, <em>num_bits=4</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/hashing.html#truncate_float64"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.hashing.truncate_float64" title="Permalink to this definition">¶</a></dt>
<dd><p>reduce the number of bits making it into the hash to avoid rehashing due to
possible truncation in float-&gt;str-&gt;float roundtrips</p>
</dd></dl>

<span class="target" id="module-aiida.common.json"></span><p>Abstracts JSON usage to ensure compatibility with Python2 and Python3.</p>
<p>Use this module prefentially over standard json to ensure compatibility.
Also note the conventions for using io.open for dump and dumps.</p>
<dl class="function">
<dt id="aiida.common.json.dump">
<code class="descclassname">aiida.common.json.</code><code class="descname">dump</code><span class="sig-paren">(</span><em>data</em>, <em>fhandle</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/json.html#dump"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.json.dump" title="Permalink to this definition">¶</a></dt>
<dd><p>Write JSON encoded ‘data’ to a file-like object, fhandle
In Py2/3, use io.open(filename, ‘wb’) to write.
The utf8write object is used to ensure that the resulting serialised data is
encoding as UTF8.
Any strings with non-ASCII characters need to be unicode strings.
We use ensure_ascii=False to write unicode characters specifically
as this improves the readability of the json and reduces the file size.</p>
</dd></dl>

<dl class="function">
<dt id="aiida.common.json.dumps">
<code class="descclassname">aiida.common.json.</code><code class="descname">dumps</code><span class="sig-paren">(</span><em>data</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/json.html#dumps"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.json.dumps" title="Permalink to this definition">¶</a></dt>
<dd><p>Write JSON encoded ‘data’ to a string.
simplejson is useful here as it always returns unicode if ensure_ascii=False is used,
unlike the standard library json, rather than being dependant on the input.
We use also ensure_ascii=False to write unicode characters specifically
as this improves the readability of the json and reduces the file size.
When writing to file, use io.open(filename, ‘w’, encoding=’utf8’)</p>
</dd></dl>

<dl class="function">
<dt id="aiida.common.json.load">
<code class="descclassname">aiida.common.json.</code><code class="descname">load</code><span class="sig-paren">(</span><em>fhandle</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/json.html#load"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.json.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Deserialise a JSON file.</p>
<p>For Py2/Py3 compatibility, io.open(filename, ‘r’, encoding=’utf8’) should be used.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><strong>ValueError</strong> – if no valid JSON object could be decoded</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="aiida.common.json.loads">
<code class="descclassname">aiida.common.json.</code><code class="descname">loads</code><span class="sig-paren">(</span><em>json_string</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/json.html#loads"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.json.loads" title="Permalink to this definition">¶</a></dt>
<dd><p>Deserialise a JSON string.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><strong>ValueError</strong> – if no valid JSON object could be decoded</td>
</tr>
</tbody>
</table>
</dd></dl>

<span class="target" id="module-aiida.common.lang"></span><p>Utilities that extend the basic python language.</p>
<dl class="class">
<dt id="aiida.common.lang.EmptyContextManager">
<em class="property">class </em><code class="descclassname">aiida.common.lang.</code><code class="descname">EmptyContextManager</code><a class="reference internal" href="../_modules/aiida/common/lang.html#EmptyContextManager"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.lang.EmptyContextManager" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A dummy/no-op context manager.</p>
<dl class="attribute">
<dt id="aiida.common.lang.EmptyContextManager.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'aiida.common.lang', '__doc__': '\n    A dummy/no-op context manager.\n    ', '__enter__': &lt;function EmptyContextManager.__enter__&gt;, '__exit__': &lt;function EmptyContextManager.__exit__&gt;, '__dict__': &lt;attribute '__dict__' of 'EmptyContextManager' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'EmptyContextManager' objects&gt;})</em><a class="headerlink" href="#aiida.common.lang.EmptyContextManager.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.common.lang.EmptyContextManager.__enter__">
<code class="descname">__enter__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/lang.html#EmptyContextManager.__enter__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.lang.EmptyContextManager.__enter__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.common.lang.EmptyContextManager.__exit__">
<code class="descname">__exit__</code><span class="sig-paren">(</span><em>exc_type</em>, <em>exc_value</em>, <em>traceback</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/lang.html#EmptyContextManager.__exit__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.lang.EmptyContextManager.__exit__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.lang.EmptyContextManager.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.lang'</em><a class="headerlink" href="#aiida.common.lang.EmptyContextManager.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.lang.EmptyContextManager.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#aiida.common.lang.EmptyContextManager.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="aiida.common.lang.abstractclassmethod">
<em class="property">class </em><code class="descclassname">aiida.common.lang.</code><code class="descname">abstractclassmethod</code><span class="sig-paren">(</span><em>callable</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/lang.html#abstractclassmethod"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.lang.abstractclassmethod" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">classmethod</span></code></p>
<p>A decorator indicating abstract classmethods.</p>
<p>Backported from python3.</p>
<dl class="method">
<dt id="aiida.common.lang.abstractclassmethod.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>callable</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/lang.html#abstractclassmethod.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.lang.abstractclassmethod.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.lang.abstractclassmethod.__isabstractmethod__">
<code class="descname">__isabstractmethod__</code><em class="property"> = True</em><a class="headerlink" href="#aiida.common.lang.abstractclassmethod.__isabstractmethod__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.lang.abstractclassmethod.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.lang'</em><a class="headerlink" href="#aiida.common.lang.abstractclassmethod.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.lang.abstractclassmethod.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#aiida.common.lang.abstractclassmethod.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="aiida.common.lang.abstractstaticmethod">
<em class="property">class </em><code class="descclassname">aiida.common.lang.</code><code class="descname">abstractstaticmethod</code><span class="sig-paren">(</span><em>callable</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/lang.html#abstractstaticmethod"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.lang.abstractstaticmethod" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">staticmethod</span></code></p>
<p>A decorator indicating abstract staticmethods.</p>
<p>Similar to abstractmethod.
Backported from python3.</p>
<dl class="method">
<dt id="aiida.common.lang.abstractstaticmethod.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>callable</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/lang.html#abstractstaticmethod.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.lang.abstractstaticmethod.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.lang.abstractstaticmethod.__isabstractmethod__">
<code class="descname">__isabstractmethod__</code><em class="property"> = True</em><a class="headerlink" href="#aiida.common.lang.abstractstaticmethod.__isabstractmethod__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.lang.abstractstaticmethod.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.lang'</em><a class="headerlink" href="#aiida.common.lang.abstractstaticmethod.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.lang.abstractstaticmethod.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#aiida.common.lang.abstractstaticmethod.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="aiida.common.lang.classproperty">
<em class="property">class </em><code class="descclassname">aiida.common.lang.</code><code class="descname">classproperty</code><span class="sig-paren">(</span><em>getter</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/lang.html#classproperty"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.lang.classproperty" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A class that, when used as a decorator, works as if the
two decorators &#64;property and &#64;classmethod where applied together
(i.e., the object works as a property, both for the Class and for any
of its instance; and is called with the class cls rather than with the
instance as its first argument).</p>
<dl class="attribute">
<dt id="aiida.common.lang.classproperty.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'aiida.common.lang', '__doc__': '\n    A class that, when used as a decorator, works as if the\n    two decorators &#64;property and &#64;classmethod where applied together\n    (i.e., the object works as a property, both for the Class and for any\n    of its instance; and is called with the class cls rather than with the\n    instance as its first argument).\n    ', '__init__': &lt;function classproperty.__init__&gt;, '__get__': &lt;function classproperty.__get__&gt;, '__dict__': &lt;attribute '__dict__' of 'classproperty' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'classproperty' objects&gt;})</em><a class="headerlink" href="#aiida.common.lang.classproperty.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.common.lang.classproperty.__get__">
<code class="descname">__get__</code><span class="sig-paren">(</span><em>instance</em>, <em>owner</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/lang.html#classproperty.__get__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.lang.classproperty.__get__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.common.lang.classproperty.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>getter</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/lang.html#classproperty.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.lang.classproperty.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.lang.classproperty.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.lang'</em><a class="headerlink" href="#aiida.common.lang.classproperty.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.lang.classproperty.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#aiida.common.lang.classproperty.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="aiida.common.lang.combomethod">
<em class="property">class </em><code class="descclassname">aiida.common.lang.</code><code class="descname">combomethod</code><span class="sig-paren">(</span><em>method</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/lang.html#combomethod"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.lang.combomethod" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A decorator that wraps a function that can be both a classmethod or
instancemethod and behaves accordingly:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">A</span><span class="p">():</span>

    <span class="nd">@combomethod</span>
    <span class="k">def</span> <span class="nf">do</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">isclass</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;isclass&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">isclass</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;I am a class&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;I am an instance&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

<span class="n">A</span><span class="o">.</span><span class="n">do</span><span class="p">()</span>
<span class="n">A</span><span class="p">()</span><span class="o">.</span><span class="n">do</span><span class="p">()</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">I</span> <span class="n">am</span> <span class="n">a</span> <span class="k">class</span> <span class="nc">__main__</span><span class="o">.</span><span class="n">A</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">I</span> <span class="n">am</span> <span class="n">an</span> <span class="n">instance</span> <span class="o">&lt;</span><span class="n">__main__</span><span class="o">.</span><span class="n">A</span> <span class="n">instance</span> <span class="n">at</span> <span class="mh">0x7f2efb116e60</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Attention: For ease of handling, pass keyword <strong>isclass</strong>
equal to True if this was called as a classmethod and False if this
was called as an instance.
The argument self is therefore ambiguous!</p>
<dl class="attribute">
<dt id="aiida.common.lang.combomethod.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'aiida.common.lang', '__doc__': '\n    A decorator that wraps a function that can be both a classmethod or\n    instancemethod and behaves accordingly::\n\n        class A():\n\n            &#64;combomethod\n            def do(self, **kwargs):\n                isclass = kwargs.get(\'isclass\')\n                if isclass:\n                    print(&quot;I am a class&quot;, self)\n                else:\n                    print(&quot;I am an instance&quot;, self)\n\n        A.do()\n        A().do()\n\n        &gt;&gt;&gt; I am a class __main__.A\n        &gt;&gt;&gt; I am an instance &lt;__main__.A instance&gt;\n\n    Attention: For ease of handling, pass keyword **isclass**\n    equal to True if this was called as a classmethod and False if this\n    was called as an instance.\n    The argument self is therefore ambiguous!\n    ', '__init__': &lt;function combomethod.__init__&gt;, '__get__': &lt;function combomethod.__get__&gt;, '__dict__': &lt;attribute '__dict__' of 'combomethod' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'combomethod' objects&gt;})</em><a class="headerlink" href="#aiida.common.lang.combomethod.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.common.lang.combomethod.__get__">
<code class="descname">__get__</code><span class="sig-paren">(</span><em>obj=None</em>, <em>objtype=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/lang.html#combomethod.__get__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.lang.combomethod.__get__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.common.lang.combomethod.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>method</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/lang.html#combomethod.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.lang.combomethod.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.lang.combomethod.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.lang'</em><a class="headerlink" href="#aiida.common.lang.combomethod.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.lang.combomethod.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#aiida.common.lang.combomethod.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="aiida.common.lang.isidentifier">
<code class="descclassname">aiida.common.lang.</code><code class="descname">isidentifier</code><span class="sig-paren">(</span><em>identifier</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/lang.html#isidentifier"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.lang.isidentifier" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether the given string is a valid python identifier.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">boolean, True if identifier is valid, False otherwise</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><strong>TypeError</strong> – if identifier is not string type</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="aiida.common.lang.override">
<code class="descclassname">aiida.common.lang.</code><code class="descname">override</code><span class="sig-paren">(</span><em>func</em><span class="sig-paren">)</span><a class="headerlink" href="#aiida.common.lang.override" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="aiida.common.lang.override_decorator">
<code class="descclassname">aiida.common.lang.</code><code class="descname">override_decorator</code><span class="sig-paren">(</span><em>check=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/lang.html#override_decorator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.lang.override_decorator" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorator to signal that a method from a base class is being overridden completely.</p>
</dd></dl>

<dl class="function">
<dt id="aiida.common.lang.protected">
<code class="descclassname">aiida.common.lang.</code><code class="descname">protected</code><span class="sig-paren">(</span><em>func</em><span class="sig-paren">)</span><a class="headerlink" href="#aiida.common.lang.protected" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="aiida.common.lang.protected_decorator">
<code class="descclassname">aiida.common.lang.</code><code class="descname">protected_decorator</code><span class="sig-paren">(</span><em>check=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/lang.html#protected_decorator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.lang.protected_decorator" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorator to ensure that the decorated method is not called from outside the class hierarchy.</p>
</dd></dl>

<dl class="function">
<dt id="aiida.common.lang.type_check">
<code class="descclassname">aiida.common.lang.</code><code class="descname">type_check</code><span class="sig-paren">(</span><em>what</em>, <em>of_type</em>, <em>msg=None</em>, <em>allow_none=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/lang.html#type_check"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.lang.type_check" title="Permalink to this definition">¶</a></dt>
<dd><p>Verify that object ‘what’ is of type ‘of_type’ and if not the case, raise a TypeError.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>what</strong> – the object to check</li>
<li><strong>of_type</strong> – the type (or tuple of types) to compare to</li>
<li><strong>msg</strong> – if specified, allows to customize the message that is passed within the TypeError exception</li>
<li><strong>allow_none</strong> – boolean, if True will not raise if the passed <cite>what</cite> is <cite>None</cite></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<span class="target" id="module-aiida.common.links"></span><p>Module to define valid link types.</p>
<dl class="class">
<dt id="aiida.common.links.LinkType">
<em class="property">class </em><code class="descclassname">aiida.common.links.</code><code class="descname">LinkType</code><a class="reference internal" href="../_modules/aiida/common/links.html#LinkType"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.links.LinkType" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">enum.Enum</span></code></p>
<p>A simple enum of allowed link types.</p>
<dl class="attribute">
<dt id="aiida.common.links.LinkType.CALL_CALC">
<code class="descname">CALL_CALC</code><em class="property"> = 'call_calc'</em><a class="headerlink" href="#aiida.common.links.LinkType.CALL_CALC" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.links.LinkType.CALL_WORK">
<code class="descname">CALL_WORK</code><em class="property"> = 'call_work'</em><a class="headerlink" href="#aiida.common.links.LinkType.CALL_WORK" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.links.LinkType.CREATE">
<code class="descname">CREATE</code><em class="property"> = 'create'</em><a class="headerlink" href="#aiida.common.links.LinkType.CREATE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.links.LinkType.INPUT_CALC">
<code class="descname">INPUT_CALC</code><em class="property"> = 'input_calc'</em><a class="headerlink" href="#aiida.common.links.LinkType.INPUT_CALC" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.links.LinkType.INPUT_WORK">
<code class="descname">INPUT_WORK</code><em class="property"> = 'input_work'</em><a class="headerlink" href="#aiida.common.links.LinkType.INPUT_WORK" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.links.LinkType.RETURN">
<code class="descname">RETURN</code><em class="property"> = 'return'</em><a class="headerlink" href="#aiida.common.links.LinkType.RETURN" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.links.LinkType.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.links'</em><a class="headerlink" href="#aiida.common.links.LinkType.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="aiida.common.links.validate_link_label">
<code class="descclassname">aiida.common.links.</code><code class="descname">validate_link_label</code><span class="sig-paren">(</span><em>link_label</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/links.html#validate_link_label"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.links.validate_link_label" title="Permalink to this definition">¶</a></dt>
<dd><p>Validate the given link label.</p>
<p>Valid link labels adhere to the following restrictions:</p>
<blockquote>
<div><ul class="simple">
<li>Has to be a valid python identifier</li>
<li>Can only contain alphanumeric characters and underscores</li>
<li>Can not start or end with an underscore</li>
</ul>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><strong>TypeError</strong> – if the link label is not a string type</li>
<li><strong>ValueError</strong> – if the link label is invalid</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<span class="target" id="module-aiida.common.log"></span><p>Module for all logging methods/classes that don’t need the ORM.</p>
<span class="target" id="module-aiida.common.timezone"></span><p>Utility functions to operate on datetime objects.</p>
<dl class="function">
<dt id="aiida.common.timezone.delta">
<code class="descclassname">aiida.common.timezone.</code><code class="descname">delta</code><span class="sig-paren">(</span><em>from_time</em>, <em>to_time=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/timezone.html#delta"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.timezone.delta" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the datetime object representing the different between two datetime objects.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>from_time</strong> – starting datetime object</li>
<li><strong>to_time</strong> – end datetime object</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the delta datetime object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="aiida.common.timezone.get_current_timezone">
<code class="descclassname">aiida.common.timezone.</code><code class="descname">get_current_timezone</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/timezone.html#get_current_timezone"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.timezone.get_current_timezone" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the current timezone.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">current timezone</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="aiida.common.timezone.is_aware">
<code class="descclassname">aiida.common.timezone.</code><code class="descname">is_aware</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/timezone.html#is_aware"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.timezone.is_aware" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether the given datetime object is timezone aware</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">boolean, True if aware, False otherwise</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="aiida.common.timezone.is_naive">
<code class="descclassname">aiida.common.timezone.</code><code class="descname">is_naive</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/timezone.html#is_naive"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.timezone.is_naive" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether the given datetime object is timezone naive</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">boolean, True if naive, False otherwise</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="aiida.common.timezone.localtime">
<code class="descclassname">aiida.common.timezone.</code><code class="descname">localtime</code><span class="sig-paren">(</span><em>value</em>, <em>timezone=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/timezone.html#localtime"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.timezone.localtime" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts an aware datetime.datetime to local time.
Local time is defined by the current time zone, unless another time zone
is specified.</p>
</dd></dl>

<dl class="function">
<dt id="aiida.common.timezone.make_aware">
<code class="descclassname">aiida.common.timezone.</code><code class="descname">make_aware</code><span class="sig-paren">(</span><em>value</em>, <em>timezone=None</em>, <em>is_dst=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/timezone.html#make_aware"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.timezone.make_aware" title="Permalink to this definition">¶</a></dt>
<dd><p>Make the given datetime object timezone aware</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>value</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">datetime.datetime</span></code>) – The datetime to make aware</li>
<li><strong>timezone</strong> – </li>
<li><strong>is_dst</strong> – </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="aiida.common.timezone.now">
<code class="descclassname">aiida.common.timezone.</code><code class="descname">now</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/timezone.html#now"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.timezone.now" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the datetime object of the current time.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">datetime object represeting current time</td>
</tr>
</tbody>
</table>
</dd></dl>

<span class="target" id="module-aiida.common.utils"></span><p>Miscellaneous generic utility functions and classes.</p>
<dl class="class">
<dt id="aiida.common.utils.ArrayCounter">
<em class="property">class </em><code class="descclassname">aiida.common.utils.</code><code class="descname">ArrayCounter</code><a class="reference internal" href="../_modules/aiida/common/utils.html#ArrayCounter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.ArrayCounter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A counter &amp; a method that increments it and returns its value.
It is used in various tests.</p>
<dl class="attribute">
<dt id="aiida.common.utils.ArrayCounter.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'aiida.common.utils', '__doc__': '\n    A counter &amp; a method that increments it and returns its value.\n    It is used in various tests.\n    ', 'seq': None, '__init__': &lt;function ArrayCounter.__init__&gt;, 'array_counter': &lt;function ArrayCounter.array_counter&gt;, '__dict__': &lt;attribute '__dict__' of 'ArrayCounter' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'ArrayCounter' objects&gt;})</em><a class="headerlink" href="#aiida.common.utils.ArrayCounter.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.common.utils.ArrayCounter.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#ArrayCounter.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.ArrayCounter.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.utils.ArrayCounter.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.utils'</em><a class="headerlink" href="#aiida.common.utils.ArrayCounter.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.utils.ArrayCounter.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#aiida.common.utils.ArrayCounter.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.utils.ArrayCounter.array_counter">
<code class="descname">array_counter</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#ArrayCounter.array_counter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.ArrayCounter.array_counter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.utils.ArrayCounter.seq">
<code class="descname">seq</code><em class="property"> = None</em><a class="headerlink" href="#aiida.common.utils.ArrayCounter.seq" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="aiida.common.utils.Capturing">
<em class="property">class </em><code class="descclassname">aiida.common.utils.</code><code class="descname">Capturing</code><span class="sig-paren">(</span><em>capture_stderr=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#Capturing"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.Capturing" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>This class captures stdout and returns it
(as a list, split by lines).</p>
<p>Note: if you raise a SystemExit, you have to catch it outside.
E.g., in our tests, this works:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span>
<span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertRaises</span><span class="p">(</span><span class="ne">SystemExit</span><span class="p">):</span>
    <span class="k">with</span> <span class="n">Capturing</span><span class="p">()</span> <span class="k">as</span> <span class="n">output</span><span class="p">:</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">()</span>
</pre></div>
</div>
<p>But out of the testing environment, the code instead just exits.</p>
<p>To use it, access the obj.stdout_lines, or just iterate over the object</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>capture_stderr</strong> – if True, also captures sys.stderr. To access the
lines, use obj.stderr_lines. If False, obj.stderr_lines is None.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="aiida.common.utils.Capturing.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'aiida.common.utils', '__doc__': '\n    This class captures stdout and returns it\n    (as a list, split by lines).\n\n    Note: if you raise a SystemExit, you have to catch it outside.\n    E.g., in our tests, this works::\n\n        import sys\n        with self.assertRaises(SystemExit):\n            with Capturing() as output:\n                sys.exit()\n\n    But out of the testing environment, the code instead just exits.\n\n    To use it, access the obj.stdout_lines, or just iterate over the object\n\n    :param capture_stderr: if True, also captures sys.stderr. To access the\n        lines, use obj.stderr_lines. If False, obj.stderr_lines is None.\n    ', '__init__': &lt;function Capturing.__init__&gt;, '__enter__': &lt;function Capturing.__enter__&gt;, '__exit__': &lt;function Capturing.__exit__&gt;, '__str__': &lt;function Capturing.__str__&gt;, '__iter__': &lt;function Capturing.__iter__&gt;, '__dict__': &lt;attribute '__dict__' of 'Capturing' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'Capturing' objects&gt;})</em><a class="headerlink" href="#aiida.common.utils.Capturing.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.common.utils.Capturing.__enter__">
<code class="descname">__enter__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#Capturing.__enter__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.Capturing.__enter__" title="Permalink to this definition">¶</a></dt>
<dd><p>Enter the context where all output is captured.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.utils.Capturing.__exit__">
<code class="descname">__exit__</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#Capturing.__exit__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.Capturing.__exit__" title="Permalink to this definition">¶</a></dt>
<dd><p>Exit the context where all output is captured.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.utils.Capturing.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>capture_stderr=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#Capturing.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.Capturing.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.utils.Capturing.__iter__">
<code class="descname">__iter__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#Capturing.__iter__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.Capturing.__iter__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.utils.Capturing.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.utils'</em><a class="headerlink" href="#aiida.common.utils.Capturing.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.common.utils.Capturing.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#Capturing.__str__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.Capturing.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.utils.Capturing.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#aiida.common.utils.Capturing.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="aiida.common.utils.ErrorAccumulator">
<em class="property">class </em><code class="descclassname">aiida.common.utils.</code><code class="descname">ErrorAccumulator</code><span class="sig-paren">(</span><em>*error_cls</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#ErrorAccumulator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.ErrorAccumulator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Allows to run a number of functions and collect all the errors they raise</p>
<p>This allows to validate multiple things and tell the user about all the
errors encountered at once. Works best if the individual functions do not depend on each other.</p>
<p>Does not allow to trace the stack of each error, therefore do not use for debugging, but for
semantical checking with user friendly error messages.</p>
<dl class="attribute">
<dt id="aiida.common.utils.ErrorAccumulator.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'aiida.common.utils', '__doc__': '\n    Allows to run a number of functions and collect all the errors they raise\n\n    This allows to validate multiple things and tell the user about all the\n    errors encountered at once. Works best if the individual functions do not depend on each other.\n\n    Does not allow to trace the stack of each error, therefore do not use for debugging, but for\n    semantical checking with user friendly error messages.\n    ', '__init__': &lt;function ErrorAccumulator.__init__&gt;, 'run': &lt;function ErrorAccumulator.run&gt;, 'success': &lt;function ErrorAccumulator.success&gt;, 'result': &lt;function ErrorAccumulator.result&gt;, 'raise_errors': &lt;function ErrorAccumulator.raise_errors&gt;, '__dict__': &lt;attribute '__dict__' of 'ErrorAccumulator' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'ErrorAccumulator' objects&gt;})</em><a class="headerlink" href="#aiida.common.utils.ErrorAccumulator.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.common.utils.ErrorAccumulator.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*error_cls</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#ErrorAccumulator.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.ErrorAccumulator.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.utils.ErrorAccumulator.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.utils'</em><a class="headerlink" href="#aiida.common.utils.ErrorAccumulator.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.utils.ErrorAccumulator.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#aiida.common.utils.ErrorAccumulator.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="aiida.common.utils.ErrorAccumulator.raise_errors">
<code class="descname">raise_errors</code><span class="sig-paren">(</span><em>raise_cls</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#ErrorAccumulator.raise_errors"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.ErrorAccumulator.raise_errors" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.common.utils.ErrorAccumulator.result">
<code class="descname">result</code><span class="sig-paren">(</span><em>raise_error=&lt;class 'Exception'&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#ErrorAccumulator.result"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.ErrorAccumulator.result" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.common.utils.ErrorAccumulator.run">
<code class="descname">run</code><span class="sig-paren">(</span><em>function</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#ErrorAccumulator.run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.ErrorAccumulator.run" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.common.utils.ErrorAccumulator.success">
<code class="descname">success</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#ErrorAccumulator.success"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.ErrorAccumulator.success" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="aiida.common.utils.Prettifier">
<em class="property">class </em><code class="descclassname">aiida.common.utils.</code><code class="descname">Prettifier</code><span class="sig-paren">(</span><em>format</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#Prettifier"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.Prettifier" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Class to manage prettifiers (typically for labels of kpoints
in band plots)</p>
<dl class="attribute">
<dt id="aiida.common.utils.Prettifier.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'aiida.common.utils', '__doc__': '\n    Class to manage prettifiers (typically for labels of kpoints\n    in band plots)\n    ', '_prettify_label_pass': &lt;classmethod object&gt;, '_prettify_label_agr': &lt;classmethod object&gt;, '_prettify_label_agr_simple': &lt;classmethod object&gt;, '_prettify_label_gnuplot': &lt;classmethod object&gt;, '_prettify_label_gnuplot_simple': &lt;classmethod object&gt;, '_prettify_label_latex': &lt;classmethod object&gt;, '_prettify_label_latex_simple': &lt;classmethod object&gt;, 'prettifiers': &lt;aiida.common.lang.classproperty object&gt;, 'get_prettifiers': &lt;classmethod object&gt;, '__init__': &lt;function Prettifier.__init__&gt;, 'prettify': &lt;function Prettifier.prettify&gt;, '__dict__': &lt;attribute '__dict__' of 'Prettifier' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'Prettifier' objects&gt;})</em><a class="headerlink" href="#aiida.common.utils.Prettifier.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.common.utils.Prettifier.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>format</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#Prettifier.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.Prettifier.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a class to pretttify strings of a given format</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>format</strong> – a string with the format to use to prettify.
Valid formats are obtained from self.prettifiers</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.utils.Prettifier.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.utils'</em><a class="headerlink" href="#aiida.common.utils.Prettifier.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.utils.Prettifier.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#aiida.common.utils.Prettifier.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="classmethod">
<dt id="aiida.common.utils.Prettifier._prettify_label_agr">
<em class="property">classmethod </em><code class="descname">_prettify_label_agr</code><span class="sig-paren">(</span><em>label</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#Prettifier._prettify_label_agr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.Prettifier._prettify_label_agr" title="Permalink to this definition">¶</a></dt>
<dd><p>Prettifier for XMGrace</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>label</strong> – a string to prettify</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="aiida.common.utils.Prettifier._prettify_label_agr_simple">
<em class="property">classmethod </em><code class="descname">_prettify_label_agr_simple</code><span class="sig-paren">(</span><em>label</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#Prettifier._prettify_label_agr_simple"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.Prettifier._prettify_label_agr_simple" title="Permalink to this definition">¶</a></dt>
<dd><p>Prettifier for XMGrace (for old label names)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>label</strong> – a string to prettify</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="aiida.common.utils.Prettifier._prettify_label_gnuplot">
<em class="property">classmethod </em><code class="descname">_prettify_label_gnuplot</code><span class="sig-paren">(</span><em>label</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#Prettifier._prettify_label_gnuplot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.Prettifier._prettify_label_gnuplot" title="Permalink to this definition">¶</a></dt>
<dd><p>Prettifier for Gnuplot</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body">uses unicode, returns unicode strings (potentially, if needed)</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><strong>label</strong> – a string to prettify</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="aiida.common.utils.Prettifier._prettify_label_gnuplot_simple">
<em class="property">classmethod </em><code class="descname">_prettify_label_gnuplot_simple</code><span class="sig-paren">(</span><em>label</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#Prettifier._prettify_label_gnuplot_simple"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.Prettifier._prettify_label_gnuplot_simple" title="Permalink to this definition">¶</a></dt>
<dd><p>Prettifier for Gnuplot (for old label names)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body">uses unicode, returns unicode strings (potentially, if needed)</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><strong>label</strong> – a string to prettify</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="aiida.common.utils.Prettifier._prettify_label_latex">
<em class="property">classmethod </em><code class="descname">_prettify_label_latex</code><span class="sig-paren">(</span><em>label</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#Prettifier._prettify_label_latex"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.Prettifier._prettify_label_latex" title="Permalink to this definition">¶</a></dt>
<dd><p>Prettifier for matplotlib, using LaTeX syntax</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>label</strong> – a string to prettify</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="aiida.common.utils.Prettifier._prettify_label_latex_simple">
<em class="property">classmethod </em><code class="descname">_prettify_label_latex_simple</code><span class="sig-paren">(</span><em>label</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#Prettifier._prettify_label_latex_simple"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.Prettifier._prettify_label_latex_simple" title="Permalink to this definition">¶</a></dt>
<dd><p>Prettifier for matplotlib, using LaTeX syntax (for old label names)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>label</strong> – a string to prettify</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="aiida.common.utils.Prettifier._prettify_label_pass">
<em class="property">classmethod </em><code class="descname">_prettify_label_pass</code><span class="sig-paren">(</span><em>label</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#Prettifier._prettify_label_pass"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.Prettifier._prettify_label_pass" title="Permalink to this definition">¶</a></dt>
<dd><p>No-op prettifier, simply returns  the same label</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>label</strong> – a string to prettify</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="aiida.common.utils.Prettifier.get_prettifiers">
<em class="property">classmethod </em><code class="descname">get_prettifiers</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#Prettifier.get_prettifiers"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.Prettifier.get_prettifiers" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of valid prettifier strings</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a list of strings</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="aiida.common.utils.Prettifier.prettifiers">
<code class="descname">prettifiers</code><em class="property"> = {'agr_seekpath': &lt;bound method Prettifier._prettify_label_agr of &lt;class 'aiida.common.utils.Prettifier'&gt;&gt;, 'agr_simple': &lt;bound method Prettifier._prettify_label_agr_simple of &lt;class 'aiida.common.utils.Prettifier'&gt;&gt;, 'gnuplot_seekpath': &lt;bound method Prettifier._prettify_label_gnuplot of &lt;class 'aiida.common.utils.Prettifier'&gt;&gt;, 'gnuplot_simple': &lt;bound method Prettifier._prettify_label_gnuplot_simple of &lt;class 'aiida.common.utils.Prettifier'&gt;&gt;, 'latex_seekpath': &lt;bound method Prettifier._prettify_label_latex of &lt;class 'aiida.common.utils.Prettifier'&gt;&gt;, 'latex_simple': &lt;bound method Prettifier._prettify_label_latex_simple of &lt;class 'aiida.common.utils.Prettifier'&gt;&gt;, 'pass': &lt;bound method Prettifier._prettify_label_pass of &lt;class 'aiida.common.utils.Prettifier'&gt;&gt;}</em><a class="headerlink" href="#aiida.common.utils.Prettifier.prettifiers" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.common.utils.Prettifier.prettify">
<code class="descname">prettify</code><span class="sig-paren">(</span><em>label</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#Prettifier.prettify"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.Prettifier.prettify" title="Permalink to this definition">¶</a></dt>
<dd><p>Prettify a label using the format passed in the initializer</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>label</strong> – the string to prettify</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">a prettified string</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="aiida.common.utils.are_dir_trees_equal">
<code class="descclassname">aiida.common.utils.</code><code class="descname">are_dir_trees_equal</code><span class="sig-paren">(</span><em>dir1</em>, <em>dir2</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#are_dir_trees_equal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.are_dir_trees_equal" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare two directories recursively. Files in each directory are
assumed to be equal if their names and contents are equal.</p>
<p>&#64;param dir1: First directory path
&#64;param dir2: Second directory path</p>
<dl class="docutils">
<dt>&#64;return: True if the directory trees are the same and</dt>
<dd>there were no errors while accessing the directories or files,
False otherwise.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="aiida.common.utils.export_shard_uuid">
<code class="descclassname">aiida.common.utils.</code><code class="descname">export_shard_uuid</code><span class="sig-paren">(</span><em>uuid</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#export_shard_uuid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.export_shard_uuid" title="Permalink to this definition">¶</a></dt>
<dd><p>Sharding of the UUID for the import/export</p>
</dd></dl>

<dl class="function">
<dt id="aiida.common.utils.get_class_string">
<code class="descclassname">aiida.common.utils.</code><code class="descname">get_class_string</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#get_class_string"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.get_class_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the string identifying the class of the object (module + object name,
joined by dots).</p>
<p>It works both for classes and for class instances.</p>
</dd></dl>

<dl class="function">
<dt id="aiida.common.utils.get_new_uuid">
<code class="descclassname">aiida.common.utils.</code><code class="descname">get_new_uuid</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#get_new_uuid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.get_new_uuid" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new UUID (typically to be used for new nodes).
It uses the UUID version specified in
aiida.backends.settings.AIIDANODES_UUID_VERSION</p>
</dd></dl>

<dl class="function">
<dt id="aiida.common.utils.get_object_from_string">
<code class="descclassname">aiida.common.utils.</code><code class="descname">get_object_from_string</code><span class="sig-paren">(</span><em>class_string</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#get_object_from_string"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.get_object_from_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a string identifying an object (as returned by the get_class_string
method) load and return the actual object.</p>
</dd></dl>

<dl class="function">
<dt id="aiida.common.utils.get_repository_folder">
<code class="descclassname">aiida.common.utils.</code><code class="descname">get_repository_folder</code><span class="sig-paren">(</span><em>subfolder=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#get_repository_folder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.get_repository_folder" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the top folder of the local repository.</p>
</dd></dl>

<dl class="function">
<dt id="aiida.common.utils.get_unique_filename">
<code class="descclassname">aiida.common.utils.</code><code class="descname">get_unique_filename</code><span class="sig-paren">(</span><em>filename</em>, <em>list_of_filenames</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#get_unique_filename"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.get_unique_filename" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a unique filename that can be added to the list_of_filenames.</p>
<p>If filename is not in list_of_filenames, it simply returns the filename
string itself. Otherwise, it appends a integer number to the filename
(before the extension) until it finds a unique filename.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>filename</strong> – the filename to add</li>
<li><strong>list_of_filenames</strong> – the list of filenames to which filename
should be added, without name duplicates</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Either filename or its modification, with a number appended
between the name and the extension.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="aiida.common.utils.grouper">
<code class="descclassname">aiida.common.utils.</code><code class="descname">grouper</code><span class="sig-paren">(</span><em>n</em>, <em>iterable</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#grouper"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.grouper" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an iterable, returns an iterable that returns tuples of groups of
elements from iterable of length n, except the last one that has the
required length to exaust iterable (i.e., there is no filling applied).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>n</strong> – length of each tuple (except the last one,that will have length
&lt;= n</li>
<li><strong>iterable</strong> – the iterable to divide in groups</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="aiida.common.utils.join_labels">
<code class="descclassname">aiida.common.utils.</code><code class="descname">join_labels</code><span class="sig-paren">(</span><em>labels</em>, <em>join_symbol='|'</em>, <em>threshold=1e-06</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#join_labels"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.join_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Join labels with a joining symbol when they are very close</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>labels</strong> – a list of length-2 tuples, in the format(position, label)</li>
<li><strong>join_symbol</strong> – the string to use to join different paths. By default, a pipe</li>
<li><strong>threshold</strong> – the threshold to decide if two float values are the same and should
be joined</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the same list as labels, but with the second value possibly replaced
with strings joined when close enough</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="aiida.common.utils.prettify_labels">
<code class="descclassname">aiida.common.utils.</code><code class="descname">prettify_labels</code><span class="sig-paren">(</span><em>labels</em>, <em>format=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#prettify_labels"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.prettify_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Prettify label for typesetting in various formats</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>labels</strong> – a list of length-2 tuples, in the format(position, label)</li>
<li><strong>format</strong> – a string with the format for the prettifier (e.g. ‘agr’,
‘matplotlib’, …)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the same list as labels, but with the second value possibly replaced
with a prettified version that typesets nicely in the selected format</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="aiida.common.utils.str_timedelta">
<code class="descclassname">aiida.common.utils.</code><code class="descname">str_timedelta</code><span class="sig-paren">(</span><em>dt</em>, <em>max_num_fields=3</em>, <em>short=False</em>, <em>negative_to_zero=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#str_timedelta"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.str_timedelta" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a dt in seconds, return it in a HH:MM:SS format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dt</strong> – a TimeDelta object</li>
<li><strong>max_num_fields</strong> – maximum number of non-zero fields to show
(for instance if the number of days is non-zero, shows only
days, hours and minutes, but not seconds)</li>
<li><strong>short</strong> – if False, print always <code class="docutils literal notranslate"><span class="pre">max_num_fields</span></code> fields, even
if they are zero. If True, do not print the first fields, if they
are zero.</li>
<li><strong>negative_to_zero</strong> – if True, set dt = 0 if dt &lt; 0.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="aiida.common.utils.strip_prefix">
<code class="descclassname">aiida.common.utils.</code><code class="descname">strip_prefix</code><span class="sig-paren">(</span><em>full_string</em>, <em>prefix</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#strip_prefix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.strip_prefix" title="Permalink to this definition">¶</a></dt>
<dd><p>Strip the prefix from the given string and return it. If the prefix is not present
the original string will be returned unaltered</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>full_string</strong> – the string from which to remove the prefix</li>
<li><strong>prefix</strong> – the prefix to remove</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the string with prefix removed</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="aiida.common.utils.validate_list_of_string_tuples">
<code class="descclassname">aiida.common.utils.</code><code class="descname">validate_list_of_string_tuples</code><span class="sig-paren">(</span><em>val</em>, <em>tuple_length</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/common/utils.html#validate_list_of_string_tuples"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.utils.validate_list_of_string_tuples" title="Permalink to this definition">¶</a></dt>
<dd><p>Check that:</p>
<ol class="arabic simple">
<li><code class="docutils literal notranslate"><span class="pre">val</span></code> is a list or tuple</li>
<li>each element of the list:</li>
</ol>
<blockquote>
<div><ol class="loweralpha simple">
<li>is a list or tuple</li>
<li>is of length equal to the parameter tuple_length</li>
<li>each of the two elements is a string</li>
</ol>
</div></blockquote>
<p>Return if valid, raise ValidationError if invalid</p>
</dd></dl>

<span class="target" id="module-aiida.common.warnings"></span><p>Define warnings that can be thrown by AiiDA.</p>
<dl class="exception">
<dt id="aiida.common.warnings.AiidaDeprecationWarning">
<em class="property">exception </em><code class="descclassname">aiida.common.warnings.</code><code class="descname">AiidaDeprecationWarning</code><a class="reference internal" href="../_modules/aiida/common/warnings.html#AiidaDeprecationWarning"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.warnings.AiidaDeprecationWarning" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Warning</span></code></p>
<p>Class for AiiDA deprecations.</p>
<p>It does <em>not</em> inherit, on purpose, from <cite>DeprecationWarning</cite> as
this would be filtered out by default.
Enabled by default, you can disable it by running in the shell:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">verdi</span> <span class="n">config</span> <span class="n">warnings</span><span class="o">.</span><span class="n">showdeprecations</span> <span class="kc">False</span>
</pre></div>
</div>
<dl class="attribute">
<dt id="aiida.common.warnings.AiidaDeprecationWarning.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.warnings'</em><a class="headerlink" href="#aiida.common.warnings.AiidaDeprecationWarning.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.warnings.AiidaDeprecationWarning.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#aiida.common.warnings.AiidaDeprecationWarning.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="aiida.common.warnings.AiidaEntryPointWarning">
<em class="property">exception </em><code class="descclassname">aiida.common.warnings.</code><code class="descname">AiidaEntryPointWarning</code><a class="reference internal" href="../_modules/aiida/common/warnings.html#AiidaEntryPointWarning"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.common.warnings.AiidaEntryPointWarning" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Warning</span></code></p>
<p>Class for warnings concerning AiiDA entry points.</p>
<p>It does <em>not</em> inherit, on purpose, from <cite>DeprecationWarning</cite> as
this would be filtered out by default.</p>
<dl class="attribute">
<dt id="aiida.common.warnings.AiidaEntryPointWarning.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.common.warnings'</em><a class="headerlink" href="#aiida.common.warnings.AiidaEntryPointWarning.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.common.warnings.AiidaEntryPointWarning.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#aiida.common.warnings.AiidaEntryPointWarning.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, ECOLE POLYTECHNIQUE FEDERALE DE LAUSANNE (Theory and Simulation of Materials (THEOS) and National Centre for Computational Design and Discovery of Novel Materials (NCCR MARVEL)), Switzerland and ROBERT BOSCH LLC, USA. All rights reserved

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>