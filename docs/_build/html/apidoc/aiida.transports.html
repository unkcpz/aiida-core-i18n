

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>aiida.transports package &mdash; AiiDA 1.0.0b2 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script type="text/javascript" src="../_static/contentui.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/contentui.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> AiiDA
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Installation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../install/quick_installation.html">Quick installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../install/prerequisites.html">Prerequisites</a></li>
<li class="toctree-l1"><a class="reference internal" href="../install/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../install/updating_installation.html">Updating AiiDA</a></li>
<li class="toctree-l1"><a class="reference internal" href="../install/troubleshooting.html">Troubleshooting</a></li>
</ul>
<p class="caption"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../get_started/index.html">First things first</a></li>
<li class="toctree-l1"><a class="reference internal" href="../get_started/daemon.html">Setup the daemon</a></li>
<li class="toctree-l1"><a class="reference internal" href="../get_started/computers.html">Setup a computer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../get_started/codes.html">Setup a code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../get_started/plugins.html">Plugins</a></li>
</ul>
<p class="caption"><span class="caption-text">Concepts</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../concepts/provenance.html">Provenance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../concepts/processes.html">Processes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../concepts/calculations.html">Calculations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../concepts/workflows.html">Workflows</a></li>
</ul>
<p class="caption"><span class="caption-text">Working with</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../working/processes.html">Processes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../working/functions.html">Calculation and work functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../working/calculations.html">Calculations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../working/workflows.html">Workflows</a></li>
</ul>
<p class="caption"><span class="caption-text">Working with AiiDA</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../working_with_aiida/index.html">Command line interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../working_with_aiida/index.html#scripting">Scripting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../working_with_aiida/index.html#data-types">Data types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../working_with_aiida/index.html#groups">Groups</a></li>
<li class="toctree-l1"><a class="reference internal" href="../working_with_aiida/index.html#schedulers">Schedulers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../working_with_aiida/index.html#querying-data">Querying data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../working_with_aiida/index.html#caching">Caching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../working_with_aiida/index.html#result-manager">Result manager</a></li>
<li class="toctree-l1"><a class="reference internal" href="../working_with_aiida/index.html#backups">Backups</a></li>
<li class="toctree-l1"><a class="reference internal" href="../working_with_aiida/index.html#troubleshooting">Troubleshooting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../working_with_aiida/index.html#rest-api">REST API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../working_with_aiida/index.html#cookbook">Cookbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../import_export/index.html">Import and Export</a></li>
</ul>
<p class="caption"><span class="caption-text">Development</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../developer_guide/index.html">AiiDA design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../developer_guide/index.html#aiida-core">AiiDA core</a></li>
<li class="toctree-l1"><a class="reference internal" href="../developer_guide/index.html#aiida-plugins">AiiDA plugins</a></li>
</ul>
<p class="caption"><span class="caption-text">Tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../tutorial/index.html">StructureData</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial/index.html#pseudopotentials">Pseudopotentials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial/index.html#plugin-development">Plugin development</a></li>
</ul>
<p class="caption"><span class="caption-text">API reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="`aiida package &lt;https://aiida-core.readthedocs.io/en/latest/apidoc/aiida.html&gt;`_">`aiida package &lt;https://aiida-core.readthedocs.io/en/latest/apidoc/aiida.html&gt;`_</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">AiiDA</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>aiida.transports package</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/apidoc/aiida.transports.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-aiida.transports">
<span id="aiida-transports-package"></span><h1>aiida.transports package<a class="headerlink" href="#module-aiida.transports" title="Permalink to this headline">¶</a></h1>
<p>Module for classes and utilities to define transports to other machines.</p>
<dl class="class">
<dt id="aiida.transports.Transport">
<em class="property">class </em><code class="descclassname">aiida.transports.</code><code class="descname">Transport</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.Transport" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Abstract class for a generic transport (ssh, local, …)
Contains the set of minimal methods</p>
<dl class="attribute">
<dt id="aiida.transports.Transport._MAGIC_CHECK">
<code class="descname">_MAGIC_CHECK</code><em class="property"> = re.compile('[*?[]')</em><a class="headerlink" href="#aiida.transports.Transport._MAGIC_CHECK" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.transports.Transport.__abstractmethods__">
<code class="descname">__abstractmethods__</code><em class="property"> = frozenset()</em><a class="headerlink" href="#aiida.transports.Transport.__abstractmethods__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.transports.Transport.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'aiida.transports.transport', '__doc__': '\n    Abstract class for a generic transport (ssh, local, ...)\n    Contains the set of minimal methods\n    ', '_valid_auth_params': None, '_MAGIC_CHECK': re.compile('[*?[]'), '_valid_auth_options': [], '_common_auth_options': [('safe_interval', {'type': &lt;class 'int'&gt;, 'prompt': 'Connection cooldown time (sec)', 'help': 'Minimum time between connections in sec', 'non_interactive_default': True})], '__init__': &lt;function Transport.__init__&gt;, '__enter__': &lt;function Transport.__enter__&gt;, '__exit__': &lt;function Transport.__exit__&gt;, 'is_open': &lt;property object&gt;, 'open': &lt;function Transport.open&gt;, 'close': &lt;function Transport.close&gt;, '__repr__': &lt;function Transport.__repr__&gt;, '__str__': &lt;function Transport.__str__&gt;, 'set_logger_extra': &lt;function Transport.set_logger_extra&gt;, 'get_short_doc': &lt;classmethod object&gt;, 'get_valid_transports': &lt;classmethod object&gt;, 'get_valid_auth_params': &lt;classmethod object&gt;, 'auth_options': &lt;aiida.common.lang.classproperty object&gt;, '_get_safe_interval_suggestion_string': &lt;classmethod object&gt;, 'logger': &lt;property object&gt;, 'get_safe_open_interval': &lt;function Transport.get_safe_open_interval&gt;, 'chdir': &lt;function Transport.chdir&gt;, 'chmod': &lt;function Transport.chmod&gt;, 'chown': &lt;function Transport.chown&gt;, 'copy': &lt;function Transport.copy&gt;, 'copyfile': &lt;function Transport.copyfile&gt;, 'copytree': &lt;function Transport.copytree&gt;, 'copy_from_remote_to_remote': &lt;function Transport.copy_from_remote_to_remote&gt;, '_exec_command_internal': &lt;function Transport._exec_command_internal&gt;, 'exec_command_wait': &lt;function Transport.exec_command_wait&gt;, 'get': &lt;function Transport.get&gt;, 'getfile': &lt;function Transport.getfile&gt;, 'gettree': &lt;function Transport.gettree&gt;, 'getcwd': &lt;function Transport.getcwd&gt;, 'get_attribute': &lt;function Transport.get_attribute&gt;, 'get_mode': &lt;function Transport.get_mode&gt;, 'isdir': &lt;function Transport.isdir&gt;, 'isfile': &lt;function Transport.isfile&gt;, 'listdir': &lt;function Transport.listdir&gt;, 'listdir_withattributes': &lt;function Transport.listdir_withattributes&gt;, 'makedirs': &lt;function Transport.makedirs&gt;, 'mkdir': &lt;function Transport.mkdir&gt;, 'normalize': &lt;function Transport.normalize&gt;, 'put': &lt;function Transport.put&gt;, 'putfile': &lt;function Transport.putfile&gt;, 'puttree': &lt;function Transport.puttree&gt;, 'remove': &lt;function Transport.remove&gt;, 'rename': &lt;function Transport.rename&gt;, 'rmdir': &lt;function Transport.rmdir&gt;, 'rmtree': &lt;function Transport.rmtree&gt;, 'gotocomputer_command': &lt;function Transport.gotocomputer_command&gt;, 'symlink': &lt;function Transport.symlink&gt;, 'whoami': &lt;function Transport.whoami&gt;, 'path_exists': &lt;function Transport.path_exists&gt;, 'glob': &lt;function Transport.glob&gt;, 'iglob': &lt;function Transport.iglob&gt;, 'glob1': &lt;function Transport.glob1&gt;, 'glob0': &lt;function Transport.glob0&gt;, 'has_magic': &lt;function Transport.has_magic&gt;, '__dict__': &lt;attribute '__dict__' of 'Transport' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'Transport' objects&gt;, '__abstractmethods__': frozenset(), '_abc_impl': &lt;_abc_data object&gt;})</em><a class="headerlink" href="#aiida.transports.Transport.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.transports.Transport.__enter__">
<code class="descname">__enter__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.__enter__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.Transport.__enter__" title="Permalink to this definition">¶</a></dt>
<dd><p>For transports that require opening a connection, opens
all required channels (used in ‘with’ statements).</p>
<p>This object can be used in nested <cite>with</cite> statements and the connection
will only be opened once and closed when the final <cite>with</cite> scope
finishes e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">t</span> <span class="o">=</span> <span class="n">Transport</span><span class="p">()</span>
<span class="k">with</span> <span class="n">t</span><span class="p">:</span>
    <span class="c1"># Connection is now open..</span>
    <span class="k">with</span> <span class="n">t</span><span class="p">:</span>
        <span class="c1"># ..still open..</span>
        <span class="k">pass</span>
    <span class="c1"># ..still open..</span>
<span class="c1"># ...closed</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.Transport.__exit__">
<code class="descname">__exit__</code><span class="sig-paren">(</span><em>type_</em>, <em>value</em>, <em>traceback</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.__exit__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.Transport.__exit__" title="Permalink to this definition">¶</a></dt>
<dd><p>Closes connections, if needed (used in ‘with’ statements).</p>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.Transport.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.Transport.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>__init__ method of the Transport base class.</p>
</dd></dl>

<dl class="attribute">
<dt id="aiida.transports.Transport.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.transports.transport'</em><a class="headerlink" href="#aiida.transports.Transport.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.transports.Transport.__repr__">
<code class="descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.__repr__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.Transport.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.Transport.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.__str__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.Transport.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="aiida.transports.Transport.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#aiida.transports.Transport.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="attribute">
<dt id="aiida.transports.Transport._abc_impl">
<code class="descname">_abc_impl</code><em class="property"> = &lt;_abc_data object&gt;</em><a class="headerlink" href="#aiida.transports.Transport._abc_impl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.transports.Transport._common_auth_options">
<code class="descname">_common_auth_options</code><em class="property"> = [('safe_interval', {'type': &lt;class 'int'&gt;, 'prompt': 'Connection cooldown time (sec)', 'help': 'Minimum time between connections in sec', 'non_interactive_default': True})]</em><a class="headerlink" href="#aiida.transports.Transport._common_auth_options" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.transports.Transport._exec_command_internal">
<code class="descname">_exec_command_internal</code><span class="sig-paren">(</span><em>command</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport._exec_command_internal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.Transport._exec_command_internal" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute the command on the shell, similarly to os.system.</p>
<p>Enforce the execution to be run from the cwd (as given by
self.getcwd), if this is not None.</p>
<p>If possible, use the higher-level
exec_command_wait function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>command</strong> (<em>str</em>) – execute the command given as a string</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">stdin, stdout, stderr and the session, when this exists                  (can be None).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="aiida.transports.Transport._get_safe_interval_suggestion_string">
<em class="property">classmethod </em><code class="descname">_get_safe_interval_suggestion_string</code><span class="sig-paren">(</span><em>computer</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport._get_safe_interval_suggestion_string"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.Transport._get_safe_interval_suggestion_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Default time in seconds between consecutive checks.</p>
<p>Set to a non-zero value to be safe e.g. in the case of transports with a connection limit,
to avoid overloading the server (and being banned). Should be overriden
in plugins. This is anyway just a default, as the value can be changed
by the user in the Computer properties, for instance.
Currently both the local and the ssh transport override this value, so this is not used,
but it will be the default for possible new plugins.</p>
</dd></dl>

<dl class="attribute">
<dt id="aiida.transports.Transport._valid_auth_options">
<code class="descname">_valid_auth_options</code><em class="property"> = []</em><a class="headerlink" href="#aiida.transports.Transport._valid_auth_options" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.transports.Transport._valid_auth_params">
<code class="descname">_valid_auth_params</code><em class="property"> = None</em><a class="headerlink" href="#aiida.transports.Transport._valid_auth_params" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.transports.Transport.auth_options">
<code class="descname">auth_options</code><em class="property"> = {'safe_interval': {'help': 'Minimum time between connections in sec', 'non_interactive_default': True, 'prompt': 'Connection cooldown time (sec)', 'type': &lt;class 'int'&gt;}}</em><a class="headerlink" href="#aiida.transports.Transport.auth_options" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.transports.Transport.chdir">
<code class="descname">chdir</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.chdir"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.Transport.chdir" title="Permalink to this definition">¶</a></dt>
<dd><p>Change directory to ‘path’</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>path</strong> (<em>str</em>) – path to change working directory into.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">IOError, if the requested path does not exist</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.Transport.chmod">
<code class="descname">chmod</code><span class="sig-paren">(</span><em>path</em>, <em>mode</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.chmod"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.Transport.chmod" title="Permalink to this definition">¶</a></dt>
<dd><p>Change permissions of a path.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>path</strong> (<em>str</em>) – path to file</li>
<li><strong>mode</strong> (<em>int</em>) – new permissions</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.Transport.chown">
<code class="descname">chown</code><span class="sig-paren">(</span><em>path</em>, <em>uid</em>, <em>gid</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.chown"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.Transport.chown" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the owner (uid) and group (gid) of a file.
As with python’s os.chown function, you must pass both arguments,
so if you only want to change one, use stat first to retrieve the
current owner and group.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>path</strong> (<em>str</em>) – path to the file to change the owner and group of</li>
<li><strong>uid</strong> (<em>int</em>) – new owner’s uid</li>
<li><strong>gid</strong> (<em>int</em>) – new group id</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.Transport.close">
<code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.close"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.Transport.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Closes the local transport channel</p>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.Transport.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>remotesource</em>, <em>remotedestination</em>, <em>dereference=False</em>, <em>recursive=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.Transport.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy a file or a directory from remote source to remote destination
(On the same remote machine)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>remotesource</strong> (<em>str</em>) – path of the remote source directory / file</li>
<li><strong>remotedestination</strong> (<em>str</em>) – path of the remote destination directory / file</li>
<li><strong>dereference</strong> (<em>bool</em>) – if True copy the contents of any symlinks found, otherwise copy the symlinks themselves</li>
<li><strong>recursive</strong> (<em>bool</em>) – if True copy directories recursively, otherwise only copy the specified file(s)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last">IOError, if one of src or dst does not exist</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.Transport.copy_from_remote_to_remote">
<code class="descname">copy_from_remote_to_remote</code><span class="sig-paren">(</span><em>transportdestination</em>, <em>remotesource</em>, <em>remotedestination</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.copy_from_remote_to_remote"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.Transport.copy_from_remote_to_remote" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy files or folders from a remote computer to another remote computer.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>transportdestination</strong> – transport to be used for the destination computer</li>
<li><strong>remotesource</strong> (<em>str</em>) – path to the remote source directory / file</li>
<li><strong>remotedestination</strong> (<em>str</em>) – path to the remote destination directory / file</li>
<li><strong>kwargs</strong> – keyword parameters passed to the call to transportdestination.put,
except for ‘dereference’ that is passed to self.get</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">the keyword ‘dereference’ SHOULD be set to False for the
final put (onto the destination), while it can be set to the
value given in kwargs for the get from the source. In that
way, a symbolic link would never be followed in the final
copy to the remote destination. That way we could avoid getting
unknown (potentially malicious) files into the destination computer.
HOWEVER, since dereference=False is currently NOT
supported by all plugins, we still force it to True for the final put.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">the supported keys in kwargs are callback, dereference,
overwrite and ignore_nonexisting.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.Transport.copyfile">
<code class="descname">copyfile</code><span class="sig-paren">(</span><em>remotesource</em>, <em>remotedestination</em>, <em>dereference=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.copyfile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.Transport.copyfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy a file from remote source to remote destination
(On the same remote machine)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>remotesource</strong> (<em>str</em>) – path of the remote source directory / file</li>
<li><strong>remotedestination</strong> (<em>str</em>) – path of the remote destination directory / file</li>
<li><strong>dereference</strong> (<em>bool</em>) – if True copy the contents of any symlinks found, otherwise copy the symlinks themselves</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><strong>IOError</strong> – if one of src or dst does not exist</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.Transport.copytree">
<code class="descname">copytree</code><span class="sig-paren">(</span><em>remotesource</em>, <em>remotedestination</em>, <em>dereference=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.copytree"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.Transport.copytree" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy a folder from remote source to remote destination
(On the same remote machine)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>remotesource</strong> (<em>str</em>) – path of the remote source directory / file</li>
<li><strong>remotedestination</strong> (<em>str</em>) – path of the remote destination directory / file</li>
<li><strong>dereference</strong> (<em>bool</em>) – if True copy the contents of any symlinks found, otherwise copy the symlinks themselves</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><strong>IOError</strong> – if one of src or dst does not exist</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.Transport.exec_command_wait">
<code class="descname">exec_command_wait</code><span class="sig-paren">(</span><em>command</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.exec_command_wait"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.Transport.exec_command_wait" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute the command on the shell, waits for it to finish,
and return the retcode, the stdout and the stderr.</p>
<p>Enforce the execution to be run from the pwd (as given by
self.getcwd), if this is not None.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>command</strong> (<em>str</em>) – execute the command given as a string</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">a list: the retcode (int), stdout (str) and stderr (str).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.Transport.get">
<code class="descname">get</code><span class="sig-paren">(</span><em>remotepath</em>, <em>localpath</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.get"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.Transport.get" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve a file or folder from remote source to local destination
dst must be an absolute path (src not necessarily)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>remotepath</strong> – (str) remote_folder_path</li>
<li><strong>localpath</strong> – (str) local_folder_path</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.Transport.get_attribute">
<code class="descname">get_attribute</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.get_attribute"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.Transport.get_attribute" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an object FixedFieldsAttributeDict for file in a given path,
as defined in aiida.common.extendeddicts
Each attribute object consists in a dictionary with the following keys:</p>
<ul class="simple">
<li>st_size: size of files, in bytes</li>
<li>st_uid: user id of owner</li>
<li>st_gid: group id of owner</li>
<li>st_mode: protection bits</li>
<li>st_atime: time of most recent access</li>
<li>st_mtime: time of most recent modification</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>path</strong> (<em>str</em>) – path to file</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">object FixedFieldsAttributeDict</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.Transport.get_mode">
<code class="descname">get_mode</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.get_mode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.Transport.get_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the portion of the file’s mode that can be set by chmod().</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>path</strong> (<em>str</em>) – path to file</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">the portion of the file’s mode that can be set by chmod()</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.Transport.get_safe_open_interval">
<code class="descname">get_safe_open_interval</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.get_safe_open_interval"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.Transport.get_safe_open_interval" title="Permalink to this definition">¶</a></dt>
<dd><p>Get an interval (in seconds) that suggests how long the user should wait
between consecutive calls to open the transport.  This can be used as
a way to get the user to not swamp a limited number of connections, etc.
However it is just advisory.</p>
<p>If returns 0, it is taken that there are no reasons to limit the
frequency of open calls.</p>
<p>In the main class, it returns a default value (&gt;0 for safety), set in
the _DEFAULT_SAFE_OPEN_INTERVAL attribute of the class. Plugins should override it.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The safe interval between calling open, in seconds</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">float</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="aiida.transports.Transport.get_short_doc">
<em class="property">classmethod </em><code class="descname">get_short_doc</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.get_short_doc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.Transport.get_short_doc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the first non-empty line of the class docstring, if available</p>
</dd></dl>

<dl class="classmethod">
<dt id="aiida.transports.Transport.get_valid_auth_params">
<em class="property">classmethod </em><code class="descname">get_valid_auth_params</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.get_valid_auth_params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.Transport.get_valid_auth_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the internal list of valid auth_params</p>
</dd></dl>

<dl class="classmethod">
<dt id="aiida.transports.Transport.get_valid_transports">
<em class="property">classmethod </em><code class="descname">get_valid_transports</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.get_valid_transports"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.Transport.get_valid_transports" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a list of existing plugin names</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.Transport.getcwd">
<code class="descname">getcwd</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.getcwd"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.Transport.getcwd" title="Permalink to this definition">¶</a></dt>
<dd><p>Get working directory</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a string identifying the current working directory</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.Transport.getfile">
<code class="descname">getfile</code><span class="sig-paren">(</span><em>remotepath</em>, <em>localpath</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.getfile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.Transport.getfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve a file from remote source to local destination
dst must be an absolute path (src not necessarily)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>remotepath</strong> (<em>str</em>) – remote_folder_path</li>
<li><strong>localpath</strong> (<em>str</em>) – local_folder_path</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.Transport.gettree">
<code class="descname">gettree</code><span class="sig-paren">(</span><em>remotepath</em>, <em>localpath</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.gettree"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.Transport.gettree" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve a folder recursively from remote source to local destination
dst must be an absolute path (src not necessarily)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>remotepath</strong> (<em>str</em>) – remote_folder_path</li>
<li><strong>localpath</strong> (<em>str</em>) – local_folder_path</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.Transport.glob">
<code class="descname">glob</code><span class="sig-paren">(</span><em>pathname</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.glob"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.Transport.glob" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of paths matching a pathname pattern.</p>
<p>The pattern may contain simple shell-style wildcards a la fnmatch.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.Transport.glob0">
<code class="descname">glob0</code><span class="sig-paren">(</span><em>dirname</em>, <em>basename</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.glob0"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.Transport.glob0" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrap basename i a list if it is empty or if dirname/basename is an existing path, else return empty list.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.Transport.glob1">
<code class="descname">glob1</code><span class="sig-paren">(</span><em>dirname</em>, <em>pattern</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.glob1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.Transport.glob1" title="Permalink to this definition">¶</a></dt>
<dd><p>Match subpaths of dirname against pattern.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.Transport.gotocomputer_command">
<code class="descname">gotocomputer_command</code><span class="sig-paren">(</span><em>remotedir</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.gotocomputer_command"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.Transport.gotocomputer_command" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a string to be run using os.system in order to connect
via the transport to the remote directory.</p>
<p>Expected behaviors:</p>
<ul class="simple">
<li>A new bash session is opened</li>
<li>A reasonable error message is produced if the folder does not exist</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>remotedir</strong> (<em>str</em>) – the full path of the remote directory</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.Transport.has_magic">
<code class="descname">has_magic</code><span class="sig-paren">(</span><em>string</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.has_magic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.Transport.has_magic" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.transports.Transport.iglob">
<code class="descname">iglob</code><span class="sig-paren">(</span><em>pathname</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.iglob"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.Transport.iglob" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an iterator which yields the paths matching a pathname pattern.</p>
<p>The pattern may contain simple shell-style wildcards a la fnmatch.</p>
</dd></dl>

<dl class="attribute">
<dt id="aiida.transports.Transport.is_open">
<code class="descname">is_open</code><a class="headerlink" href="#aiida.transports.Transport.is_open" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.transports.Transport.isdir">
<code class="descname">isdir</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.isdir"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.Transport.isdir" title="Permalink to this definition">¶</a></dt>
<dd><p>True if path is an existing directory.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>path</strong> (<em>str</em>) – path to directory</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">boolean</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.Transport.isfile">
<code class="descname">isfile</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.isfile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.Transport.isfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if path is an existing file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>path</strong> (<em>str</em>) – path to file</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">boolean</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.Transport.listdir">
<code class="descname">listdir</code><span class="sig-paren">(</span><em>path='.'</em>, <em>pattern=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.listdir"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.Transport.listdir" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of the names of the entries in the given path.
The list is in arbitrary order. It does not include the special
entries ‘.’ and ‘..’ even if they are present in the directory.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>path</strong> (<em>str</em>) – path to list (default to ‘.’)</li>
<li><strong>pattern</strong> (<em>str</em>) – if used, listdir returns a list of files matching
filters in Unix style. Unix only.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a list of strings</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.Transport.listdir_withattributes">
<code class="descname">listdir_withattributes</code><span class="sig-paren">(</span><em>path='.'</em>, <em>pattern=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.listdir_withattributes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.Transport.listdir_withattributes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of the names of the entries in the given path.
The list is in arbitrary order. It does not include the special
entries ‘.’ and ‘..’ even if they are present in the directory.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>path</strong> (<em>str</em>) – path to list (default to ‘.’)</li>
<li><strong>pattern</strong> (<em>str</em>) – if used, listdir returns a list of files matching
filters in Unix style. Unix only.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><p>a list of dictionaries, one per entry.
The schema of the dictionary is
the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
   <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span>
   <span class="s1">&#39;attributes&#39;</span><span class="p">:</span> <span class="n">FileAttributeObject</span><span class="p">,</span>
   <span class="s1">&#39;isdir&#39;</span><span class="p">:</span> <span class="n">Bool</span>
<span class="p">}</span>
</pre></div>
</div>
<p>where ‘name’ is the file or folder directory, and any other information is metadata
(if the file is a folder, a directory, …). ‘attributes’ behaves as the output of
transport.get_attribute(); isdir is a boolean indicating if the object is a directory or not.</p>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="aiida.transports.Transport.logger">
<code class="descname">logger</code><a class="headerlink" href="#aiida.transports.Transport.logger" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the internal logger.
If you have set extra parameters using set_logger_extra(), a
suitable LoggerAdapter instance is created, bringing with itself
also the extras.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.Transport.makedirs">
<code class="descname">makedirs</code><span class="sig-paren">(</span><em>path</em>, <em>ignore_existing=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.makedirs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.Transport.makedirs" title="Permalink to this definition">¶</a></dt>
<dd><p>Super-mkdir; create a leaf directory and all intermediate ones.
Works like mkdir, except that any intermediate path segment (not
just the rightmost) will be created if it does not exist.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>path</strong> (<em>str</em>) – directory to create</li>
<li><strong>ignore_existing</strong> (<em>bool</em>) – if set to true, it doesn’t give any error
if the leaf directory does already exist</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last">OSError, if directory at path already exists</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.Transport.mkdir">
<code class="descname">mkdir</code><span class="sig-paren">(</span><em>path</em>, <em>ignore_existing=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.mkdir"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.Transport.mkdir" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a folder (directory) named path.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>path</strong> (<em>str</em>) – name of the folder to create</li>
<li><strong>ignore_existing</strong> (<em>bool</em>) – if True, does not give any error if the
directory already exists</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last">OSError, if directory at path already exists</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.Transport.normalize">
<code class="descname">normalize</code><span class="sig-paren">(</span><em>path='.'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.normalize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.Transport.normalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the normalized path (on the server) of a given path.
This can be used to quickly resolve symbolic links or determine
what the server is considering to be the “current folder”.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>path</strong> (<em>str</em>) – path to be normalized</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><strong>IOError</strong> – if the path can’t be resolved on the server</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.Transport.open">
<code class="descname">open</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.open"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.Transport.open" title="Permalink to this definition">¶</a></dt>
<dd><p>Opens a local transport channel</p>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.Transport.path_exists">
<code class="descname">path_exists</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.path_exists"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.Transport.path_exists" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if path exists, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.Transport.put">
<code class="descname">put</code><span class="sig-paren">(</span><em>localpath</em>, <em>remotepath</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.put"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.Transport.put" title="Permalink to this definition">¶</a></dt>
<dd><p>Put a file or a directory from local src to remote dst.
src must be an absolute path (dst not necessarily))
Redirects to putfile and puttree.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>localpath</strong> (<em>str</em>) – absolute path to local source</li>
<li><strong>remotepath</strong> (<em>str</em>) – path to remote destination</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.Transport.putfile">
<code class="descname">putfile</code><span class="sig-paren">(</span><em>localpath</em>, <em>remotepath</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.putfile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.Transport.putfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Put a file from local src to remote dst.
src must be an absolute path (dst not necessarily))</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>localpath</strong> (<em>str</em>) – absolute path to local file</li>
<li><strong>remotepath</strong> (<em>str</em>) – path to remote file</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.Transport.puttree">
<code class="descname">puttree</code><span class="sig-paren">(</span><em>localpath</em>, <em>remotepath</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.puttree"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.Transport.puttree" title="Permalink to this definition">¶</a></dt>
<dd><p>Put a folder recursively from local src to remote dst.
src must be an absolute path (dst not necessarily))</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>localpath</strong> (<em>str</em>) – absolute path to local folder</li>
<li><strong>remotepath</strong> (<em>str</em>) – path to remote folder</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.Transport.remove">
<code class="descname">remove</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.remove"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.Transport.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the file at the given path. This only works on files;
for removing folders (directories), use rmdir.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>path</strong> (<em>str</em>) – path to file to remove</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><strong>IOError</strong> – if the path is a directory</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.Transport.rename">
<code class="descname">rename</code><span class="sig-paren">(</span><em>oldpath</em>, <em>newpath</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.rename"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.Transport.rename" title="Permalink to this definition">¶</a></dt>
<dd><p>Rename a file or folder from oldpath to newpath.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>oldpath</strong> (<em>str</em>) – existing name of the file or folder</li>
<li><strong>newpath</strong> (<em>str</em>) – new name for the file or folder</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><strong>IOError</strong> – if oldpath/newpath is not found</li>
<li><strong>ValueError</strong> – if oldpath/newpath is not a valid string</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.Transport.rmdir">
<code class="descname">rmdir</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.rmdir"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.Transport.rmdir" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the folder named path.
This works only for empty folders. For recursive remove, use rmtree.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>path</strong> (<em>str</em>) – absolute path to the folder to remove</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.Transport.rmtree">
<code class="descname">rmtree</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.rmtree"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.Transport.rmtree" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove recursively the content at path</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>path</strong> (<em>str</em>) – absolute path to remove</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.Transport.set_logger_extra">
<code class="descname">set_logger_extra</code><span class="sig-paren">(</span><em>logger_extra</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.set_logger_extra"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.Transport.set_logger_extra" title="Permalink to this definition">¶</a></dt>
<dd><p>Pass the data that should be passed automatically to self.logger
as ‘extra’ keyword. This is typically useful if you pass data
obtained using get_dblogger_extra in aiida.backends.djsite.utils, to automatically
log also to the DbLog table.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>logger_extra</strong> – data that you want to pass as extra to the
self.logger. To write to DbLog, it should be created by the
aiida.backends.djsite.utils.get_dblogger_extra function. Pass None if you
do not want to have extras passed.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.Transport.symlink">
<code class="descname">symlink</code><span class="sig-paren">(</span><em>remotesource</em>, <em>remotedestination</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.symlink"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.Transport.symlink" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a symbolic link between the remote source and the remote
destination.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>remotesource</strong> – remote source</li>
<li><strong>remotedestination</strong> – remote destination</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.Transport.whoami">
<code class="descname">whoami</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.whoami"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.Transport.whoami" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the remote username</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">list of username (str),
retval (int),
stderr (str)</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<div class="section" id="subpackages">
<h2>Subpackages<a class="headerlink" href="#subpackages" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="aiida.transports.plugins.html">aiida.transports.plugins package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="aiida.transports.plugins.html#module-aiida.transports.plugins.local">Submodules</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="module-aiida.transports.cli">
<span id="submodules"></span><h2>Submodules<a class="headerlink" href="#module-aiida.transports.cli" title="Permalink to this headline">¶</a></h2>
<p>Common cli utilities for transport plugins.</p>
<dl class="function">
<dt id="aiida.transports.cli.common_params">
<code class="descclassname">aiida.transports.cli.</code><code class="descname">common_params</code><span class="sig-paren">(</span><em>command_func</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/cli.html#common_params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.cli.common_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorate a command function with common click parameters for all transport plugins.</p>
</dd></dl>

<dl class="function">
<dt id="aiida.transports.cli.configure_computer_main">
<code class="descclassname">aiida.transports.cli.</code><code class="descname">configure_computer_main</code><span class="sig-paren">(</span><em>computer</em>, <em>user</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/cli.html#configure_computer_main"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.cli.configure_computer_main" title="Permalink to this definition">¶</a></dt>
<dd><p>Configure a computer via the CLI.</p>
</dd></dl>

<dl class="function">
<dt id="aiida.transports.cli.create_configure_cmd">
<code class="descclassname">aiida.transports.cli.</code><code class="descname">create_configure_cmd</code><span class="sig-paren">(</span><em>transport_type</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/cli.html#create_configure_cmd"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.cli.create_configure_cmd" title="Permalink to this definition">¶</a></dt>
<dd><p>Create verdi computer configure subcommand for a transport type.</p>
</dd></dl>

<dl class="function">
<dt id="aiida.transports.cli.create_option">
<code class="descclassname">aiida.transports.cli.</code><code class="descname">create_option</code><span class="sig-paren">(</span><em>name</em>, <em>spec</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/cli.html#create_option"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.cli.create_option" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a click option from a name and partial specs as used in transport auth_options.</p>
</dd></dl>

<dl class="function">
<dt id="aiida.transports.cli.interactive_default">
<code class="descclassname">aiida.transports.cli.</code><code class="descname">interactive_default</code><span class="sig-paren">(</span><em>transport_type</em>, <em>key</em>, <em>also_noninteractive=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/cli.html#interactive_default"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.cli.interactive_default" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a contextual_default value callback for an auth_param key.</p>
</dd></dl>

<dl class="function">
<dt id="aiida.transports.cli.list_transport_options">
<code class="descclassname">aiida.transports.cli.</code><code class="descname">list_transport_options</code><span class="sig-paren">(</span><em>transport_type</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/cli.html#list_transport_options"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.cli.list_transport_options" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="aiida.transports.cli.match_comp_transport">
<code class="descclassname">aiida.transports.cli.</code><code class="descname">match_comp_transport</code><span class="sig-paren">(</span><em>ctx</em>, <em>param</em>, <em>computer</em>, <em>transport_type</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/cli.html#match_comp_transport"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.cli.match_comp_transport" title="Permalink to this definition">¶</a></dt>
<dd><p>Check the computer argument against the transport type.</p>
</dd></dl>

<dl class="function">
<dt id="aiida.transports.cli.transport_option_default">
<code class="descclassname">aiida.transports.cli.</code><code class="descname">transport_option_default</code><span class="sig-paren">(</span><em>name</em>, <em>computer</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/cli.html#transport_option_default"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.cli.transport_option_default" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the default value for an auth_param key.</p>
</dd></dl>

<dl class="function">
<dt id="aiida.transports.cli.transport_options">
<code class="descclassname">aiida.transports.cli.</code><code class="descname">transport_options</code><span class="sig-paren">(</span><em>transport_type</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/cli.html#transport_options"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.cli.transport_options" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorate a command with all options for a computer configure subcommand for transport_type.</p>
</dd></dl>

<span class="target" id="module-aiida.transports.transport"></span><p>Transport interface.</p>
<dl class="class">
<dt id="aiida.transports.transport.Transport">
<em class="property">class </em><code class="descclassname">aiida.transports.transport.</code><code class="descname">Transport</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.transport.Transport" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Abstract class for a generic transport (ssh, local, …)
Contains the set of minimal methods</p>
<dl class="attribute">
<dt id="aiida.transports.transport.Transport._MAGIC_CHECK">
<code class="descname">_MAGIC_CHECK</code><em class="property"> = re.compile('[*?[]')</em><a class="headerlink" href="#aiida.transports.transport.Transport._MAGIC_CHECK" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.transports.transport.Transport.__abstractmethods__">
<code class="descname">__abstractmethods__</code><em class="property"> = frozenset()</em><a class="headerlink" href="#aiida.transports.transport.Transport.__abstractmethods__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.transports.transport.Transport.__dict__">
<code class="descname">__dict__</code><em class="property"> = mappingproxy({'__module__': 'aiida.transports.transport', '__doc__': '\n    Abstract class for a generic transport (ssh, local, ...)\n    Contains the set of minimal methods\n    ', '_valid_auth_params': None, '_MAGIC_CHECK': re.compile('[*?[]'), '_valid_auth_options': [], '_common_auth_options': [('safe_interval', {'type': &lt;class 'int'&gt;, 'prompt': 'Connection cooldown time (sec)', 'help': 'Minimum time between connections in sec', 'non_interactive_default': True})], '__init__': &lt;function Transport.__init__&gt;, '__enter__': &lt;function Transport.__enter__&gt;, '__exit__': &lt;function Transport.__exit__&gt;, 'is_open': &lt;property object&gt;, 'open': &lt;function Transport.open&gt;, 'close': &lt;function Transport.close&gt;, '__repr__': &lt;function Transport.__repr__&gt;, '__str__': &lt;function Transport.__str__&gt;, 'set_logger_extra': &lt;function Transport.set_logger_extra&gt;, 'get_short_doc': &lt;classmethod object&gt;, 'get_valid_transports': &lt;classmethod object&gt;, 'get_valid_auth_params': &lt;classmethod object&gt;, 'auth_options': &lt;aiida.common.lang.classproperty object&gt;, '_get_safe_interval_suggestion_string': &lt;classmethod object&gt;, 'logger': &lt;property object&gt;, 'get_safe_open_interval': &lt;function Transport.get_safe_open_interval&gt;, 'chdir': &lt;function Transport.chdir&gt;, 'chmod': &lt;function Transport.chmod&gt;, 'chown': &lt;function Transport.chown&gt;, 'copy': &lt;function Transport.copy&gt;, 'copyfile': &lt;function Transport.copyfile&gt;, 'copytree': &lt;function Transport.copytree&gt;, 'copy_from_remote_to_remote': &lt;function Transport.copy_from_remote_to_remote&gt;, '_exec_command_internal': &lt;function Transport._exec_command_internal&gt;, 'exec_command_wait': &lt;function Transport.exec_command_wait&gt;, 'get': &lt;function Transport.get&gt;, 'getfile': &lt;function Transport.getfile&gt;, 'gettree': &lt;function Transport.gettree&gt;, 'getcwd': &lt;function Transport.getcwd&gt;, 'get_attribute': &lt;function Transport.get_attribute&gt;, 'get_mode': &lt;function Transport.get_mode&gt;, 'isdir': &lt;function Transport.isdir&gt;, 'isfile': &lt;function Transport.isfile&gt;, 'listdir': &lt;function Transport.listdir&gt;, 'listdir_withattributes': &lt;function Transport.listdir_withattributes&gt;, 'makedirs': &lt;function Transport.makedirs&gt;, 'mkdir': &lt;function Transport.mkdir&gt;, 'normalize': &lt;function Transport.normalize&gt;, 'put': &lt;function Transport.put&gt;, 'putfile': &lt;function Transport.putfile&gt;, 'puttree': &lt;function Transport.puttree&gt;, 'remove': &lt;function Transport.remove&gt;, 'rename': &lt;function Transport.rename&gt;, 'rmdir': &lt;function Transport.rmdir&gt;, 'rmtree': &lt;function Transport.rmtree&gt;, 'gotocomputer_command': &lt;function Transport.gotocomputer_command&gt;, 'symlink': &lt;function Transport.symlink&gt;, 'whoami': &lt;function Transport.whoami&gt;, 'path_exists': &lt;function Transport.path_exists&gt;, 'glob': &lt;function Transport.glob&gt;, 'iglob': &lt;function Transport.iglob&gt;, 'glob1': &lt;function Transport.glob1&gt;, 'glob0': &lt;function Transport.glob0&gt;, 'has_magic': &lt;function Transport.has_magic&gt;, '__dict__': &lt;attribute '__dict__' of 'Transport' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'Transport' objects&gt;, '__abstractmethods__': frozenset(), '_abc_impl': &lt;_abc_data object&gt;})</em><a class="headerlink" href="#aiida.transports.transport.Transport.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.transports.transport.Transport.__enter__">
<code class="descname">__enter__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.__enter__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.transport.Transport.__enter__" title="Permalink to this definition">¶</a></dt>
<dd><p>For transports that require opening a connection, opens
all required channels (used in ‘with’ statements).</p>
<p>This object can be used in nested <cite>with</cite> statements and the connection
will only be opened once and closed when the final <cite>with</cite> scope
finishes e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">t</span> <span class="o">=</span> <span class="n">Transport</span><span class="p">()</span>
<span class="k">with</span> <span class="n">t</span><span class="p">:</span>
    <span class="c1"># Connection is now open..</span>
    <span class="k">with</span> <span class="n">t</span><span class="p">:</span>
        <span class="c1"># ..still open..</span>
        <span class="k">pass</span>
    <span class="c1"># ..still open..</span>
<span class="c1"># ...closed</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.transport.Transport.__exit__">
<code class="descname">__exit__</code><span class="sig-paren">(</span><em>type_</em>, <em>value</em>, <em>traceback</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.__exit__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.transport.Transport.__exit__" title="Permalink to this definition">¶</a></dt>
<dd><p>Closes connections, if needed (used in ‘with’ statements).</p>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.transport.Transport.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.transport.Transport.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>__init__ method of the Transport base class.</p>
</dd></dl>

<dl class="attribute">
<dt id="aiida.transports.transport.Transport.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.transports.transport'</em><a class="headerlink" href="#aiida.transports.transport.Transport.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.transports.transport.Transport.__repr__">
<code class="descname">__repr__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.__repr__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.transport.Transport.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return repr(self).</p>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.transport.Transport.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.__str__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.transport.Transport.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

<dl class="attribute">
<dt id="aiida.transports.transport.Transport.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#aiida.transports.transport.Transport.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="attribute">
<dt id="aiida.transports.transport.Transport._abc_impl">
<code class="descname">_abc_impl</code><em class="property"> = &lt;_abc_data object&gt;</em><a class="headerlink" href="#aiida.transports.transport.Transport._abc_impl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.transports.transport.Transport._common_auth_options">
<code class="descname">_common_auth_options</code><em class="property"> = [('safe_interval', {'type': &lt;class 'int'&gt;, 'prompt': 'Connection cooldown time (sec)', 'help': 'Minimum time between connections in sec', 'non_interactive_default': True})]</em><a class="headerlink" href="#aiida.transports.transport.Transport._common_auth_options" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.transports.transport.Transport._exec_command_internal">
<code class="descname">_exec_command_internal</code><span class="sig-paren">(</span><em>command</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport._exec_command_internal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.transport.Transport._exec_command_internal" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute the command on the shell, similarly to os.system.</p>
<p>Enforce the execution to be run from the cwd (as given by
self.getcwd), if this is not None.</p>
<p>If possible, use the higher-level
exec_command_wait function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>command</strong> (<em>str</em>) – execute the command given as a string</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">stdin, stdout, stderr and the session, when this exists                  (can be None).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="aiida.transports.transport.Transport._get_safe_interval_suggestion_string">
<em class="property">classmethod </em><code class="descname">_get_safe_interval_suggestion_string</code><span class="sig-paren">(</span><em>computer</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport._get_safe_interval_suggestion_string"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.transport.Transport._get_safe_interval_suggestion_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Default time in seconds between consecutive checks.</p>
<p>Set to a non-zero value to be safe e.g. in the case of transports with a connection limit,
to avoid overloading the server (and being banned). Should be overriden
in plugins. This is anyway just a default, as the value can be changed
by the user in the Computer properties, for instance.
Currently both the local and the ssh transport override this value, so this is not used,
but it will be the default for possible new plugins.</p>
</dd></dl>

<dl class="attribute">
<dt id="aiida.transports.transport.Transport._valid_auth_options">
<code class="descname">_valid_auth_options</code><em class="property"> = []</em><a class="headerlink" href="#aiida.transports.transport.Transport._valid_auth_options" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.transports.transport.Transport._valid_auth_params">
<code class="descname">_valid_auth_params</code><em class="property"> = None</em><a class="headerlink" href="#aiida.transports.transport.Transport._valid_auth_params" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.transports.transport.Transport.auth_options">
<code class="descname">auth_options</code><em class="property"> = {'safe_interval': {'help': 'Minimum time between connections in sec', 'non_interactive_default': True, 'prompt': 'Connection cooldown time (sec)', 'type': &lt;class 'int'&gt;}}</em><a class="headerlink" href="#aiida.transports.transport.Transport.auth_options" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.transports.transport.Transport.chdir">
<code class="descname">chdir</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.chdir"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.transport.Transport.chdir" title="Permalink to this definition">¶</a></dt>
<dd><p>Change directory to ‘path’</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>path</strong> (<em>str</em>) – path to change working directory into.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">IOError, if the requested path does not exist</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.transport.Transport.chmod">
<code class="descname">chmod</code><span class="sig-paren">(</span><em>path</em>, <em>mode</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.chmod"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.transport.Transport.chmod" title="Permalink to this definition">¶</a></dt>
<dd><p>Change permissions of a path.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>path</strong> (<em>str</em>) – path to file</li>
<li><strong>mode</strong> (<em>int</em>) – new permissions</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.transport.Transport.chown">
<code class="descname">chown</code><span class="sig-paren">(</span><em>path</em>, <em>uid</em>, <em>gid</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.chown"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.transport.Transport.chown" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the owner (uid) and group (gid) of a file.
As with python’s os.chown function, you must pass both arguments,
so if you only want to change one, use stat first to retrieve the
current owner and group.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>path</strong> (<em>str</em>) – path to the file to change the owner and group of</li>
<li><strong>uid</strong> (<em>int</em>) – new owner’s uid</li>
<li><strong>gid</strong> (<em>int</em>) – new group id</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.transport.Transport.close">
<code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.close"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.transport.Transport.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Closes the local transport channel</p>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.transport.Transport.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>remotesource</em>, <em>remotedestination</em>, <em>dereference=False</em>, <em>recursive=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.transport.Transport.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy a file or a directory from remote source to remote destination
(On the same remote machine)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>remotesource</strong> (<em>str</em>) – path of the remote source directory / file</li>
<li><strong>remotedestination</strong> (<em>str</em>) – path of the remote destination directory / file</li>
<li><strong>dereference</strong> (<em>bool</em>) – if True copy the contents of any symlinks found, otherwise copy the symlinks themselves</li>
<li><strong>recursive</strong> (<em>bool</em>) – if True copy directories recursively, otherwise only copy the specified file(s)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last">IOError, if one of src or dst does not exist</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.transport.Transport.copy_from_remote_to_remote">
<code class="descname">copy_from_remote_to_remote</code><span class="sig-paren">(</span><em>transportdestination</em>, <em>remotesource</em>, <em>remotedestination</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.copy_from_remote_to_remote"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.transport.Transport.copy_from_remote_to_remote" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy files or folders from a remote computer to another remote computer.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>transportdestination</strong> – transport to be used for the destination computer</li>
<li><strong>remotesource</strong> (<em>str</em>) – path to the remote source directory / file</li>
<li><strong>remotedestination</strong> (<em>str</em>) – path to the remote destination directory / file</li>
<li><strong>kwargs</strong> – keyword parameters passed to the call to transportdestination.put,
except for ‘dereference’ that is passed to self.get</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">the keyword ‘dereference’ SHOULD be set to False for the
final put (onto the destination), while it can be set to the
value given in kwargs for the get from the source. In that
way, a symbolic link would never be followed in the final
copy to the remote destination. That way we could avoid getting
unknown (potentially malicious) files into the destination computer.
HOWEVER, since dereference=False is currently NOT
supported by all plugins, we still force it to True for the final put.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">the supported keys in kwargs are callback, dereference,
overwrite and ignore_nonexisting.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.transport.Transport.copyfile">
<code class="descname">copyfile</code><span class="sig-paren">(</span><em>remotesource</em>, <em>remotedestination</em>, <em>dereference=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.copyfile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.transport.Transport.copyfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy a file from remote source to remote destination
(On the same remote machine)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>remotesource</strong> (<em>str</em>) – path of the remote source directory / file</li>
<li><strong>remotedestination</strong> (<em>str</em>) – path of the remote destination directory / file</li>
<li><strong>dereference</strong> (<em>bool</em>) – if True copy the contents of any symlinks found, otherwise copy the symlinks themselves</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><strong>IOError</strong> – if one of src or dst does not exist</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.transport.Transport.copytree">
<code class="descname">copytree</code><span class="sig-paren">(</span><em>remotesource</em>, <em>remotedestination</em>, <em>dereference=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.copytree"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.transport.Transport.copytree" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy a folder from remote source to remote destination
(On the same remote machine)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>remotesource</strong> (<em>str</em>) – path of the remote source directory / file</li>
<li><strong>remotedestination</strong> (<em>str</em>) – path of the remote destination directory / file</li>
<li><strong>dereference</strong> (<em>bool</em>) – if True copy the contents of any symlinks found, otherwise copy the symlinks themselves</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><strong>IOError</strong> – if one of src or dst does not exist</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.transport.Transport.exec_command_wait">
<code class="descname">exec_command_wait</code><span class="sig-paren">(</span><em>command</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.exec_command_wait"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.transport.Transport.exec_command_wait" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute the command on the shell, waits for it to finish,
and return the retcode, the stdout and the stderr.</p>
<p>Enforce the execution to be run from the pwd (as given by
self.getcwd), if this is not None.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>command</strong> (<em>str</em>) – execute the command given as a string</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">a list: the retcode (int), stdout (str) and stderr (str).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.transport.Transport.get">
<code class="descname">get</code><span class="sig-paren">(</span><em>remotepath</em>, <em>localpath</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.get"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.transport.Transport.get" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve a file or folder from remote source to local destination
dst must be an absolute path (src not necessarily)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>remotepath</strong> – (str) remote_folder_path</li>
<li><strong>localpath</strong> – (str) local_folder_path</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.transport.Transport.get_attribute">
<code class="descname">get_attribute</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.get_attribute"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.transport.Transport.get_attribute" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an object FixedFieldsAttributeDict for file in a given path,
as defined in aiida.common.extendeddicts
Each attribute object consists in a dictionary with the following keys:</p>
<ul class="simple">
<li>st_size: size of files, in bytes</li>
<li>st_uid: user id of owner</li>
<li>st_gid: group id of owner</li>
<li>st_mode: protection bits</li>
<li>st_atime: time of most recent access</li>
<li>st_mtime: time of most recent modification</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>path</strong> (<em>str</em>) – path to file</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">object FixedFieldsAttributeDict</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.transport.Transport.get_mode">
<code class="descname">get_mode</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.get_mode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.transport.Transport.get_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the portion of the file’s mode that can be set by chmod().</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>path</strong> (<em>str</em>) – path to file</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">the portion of the file’s mode that can be set by chmod()</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.transport.Transport.get_safe_open_interval">
<code class="descname">get_safe_open_interval</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.get_safe_open_interval"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.transport.Transport.get_safe_open_interval" title="Permalink to this definition">¶</a></dt>
<dd><p>Get an interval (in seconds) that suggests how long the user should wait
between consecutive calls to open the transport.  This can be used as
a way to get the user to not swamp a limited number of connections, etc.
However it is just advisory.</p>
<p>If returns 0, it is taken that there are no reasons to limit the
frequency of open calls.</p>
<p>In the main class, it returns a default value (&gt;0 for safety), set in
the _DEFAULT_SAFE_OPEN_INTERVAL attribute of the class. Plugins should override it.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The safe interval between calling open, in seconds</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">float</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="aiida.transports.transport.Transport.get_short_doc">
<em class="property">classmethod </em><code class="descname">get_short_doc</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.get_short_doc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.transport.Transport.get_short_doc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the first non-empty line of the class docstring, if available</p>
</dd></dl>

<dl class="classmethod">
<dt id="aiida.transports.transport.Transport.get_valid_auth_params">
<em class="property">classmethod </em><code class="descname">get_valid_auth_params</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.get_valid_auth_params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.transport.Transport.get_valid_auth_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the internal list of valid auth_params</p>
</dd></dl>

<dl class="classmethod">
<dt id="aiida.transports.transport.Transport.get_valid_transports">
<em class="property">classmethod </em><code class="descname">get_valid_transports</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.get_valid_transports"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.transport.Transport.get_valid_transports" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a list of existing plugin names</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.transport.Transport.getcwd">
<code class="descname">getcwd</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.getcwd"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.transport.Transport.getcwd" title="Permalink to this definition">¶</a></dt>
<dd><p>Get working directory</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a string identifying the current working directory</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.transport.Transport.getfile">
<code class="descname">getfile</code><span class="sig-paren">(</span><em>remotepath</em>, <em>localpath</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.getfile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.transport.Transport.getfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve a file from remote source to local destination
dst must be an absolute path (src not necessarily)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>remotepath</strong> (<em>str</em>) – remote_folder_path</li>
<li><strong>localpath</strong> (<em>str</em>) – local_folder_path</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.transport.Transport.gettree">
<code class="descname">gettree</code><span class="sig-paren">(</span><em>remotepath</em>, <em>localpath</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.gettree"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.transport.Transport.gettree" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve a folder recursively from remote source to local destination
dst must be an absolute path (src not necessarily)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>remotepath</strong> (<em>str</em>) – remote_folder_path</li>
<li><strong>localpath</strong> (<em>str</em>) – local_folder_path</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.transport.Transport.glob">
<code class="descname">glob</code><span class="sig-paren">(</span><em>pathname</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.glob"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.transport.Transport.glob" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of paths matching a pathname pattern.</p>
<p>The pattern may contain simple shell-style wildcards a la fnmatch.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.transport.Transport.glob0">
<code class="descname">glob0</code><span class="sig-paren">(</span><em>dirname</em>, <em>basename</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.glob0"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.transport.Transport.glob0" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrap basename i a list if it is empty or if dirname/basename is an existing path, else return empty list.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.transport.Transport.glob1">
<code class="descname">glob1</code><span class="sig-paren">(</span><em>dirname</em>, <em>pattern</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.glob1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.transport.Transport.glob1" title="Permalink to this definition">¶</a></dt>
<dd><p>Match subpaths of dirname against pattern.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.transport.Transport.gotocomputer_command">
<code class="descname">gotocomputer_command</code><span class="sig-paren">(</span><em>remotedir</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.gotocomputer_command"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.transport.Transport.gotocomputer_command" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a string to be run using os.system in order to connect
via the transport to the remote directory.</p>
<p>Expected behaviors:</p>
<ul class="simple">
<li>A new bash session is opened</li>
<li>A reasonable error message is produced if the folder does not exist</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>remotedir</strong> (<em>str</em>) – the full path of the remote directory</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.transport.Transport.has_magic">
<code class="descname">has_magic</code><span class="sig-paren">(</span><em>string</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.has_magic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.transport.Transport.has_magic" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.transports.transport.Transport.iglob">
<code class="descname">iglob</code><span class="sig-paren">(</span><em>pathname</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.iglob"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.transport.Transport.iglob" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an iterator which yields the paths matching a pathname pattern.</p>
<p>The pattern may contain simple shell-style wildcards a la fnmatch.</p>
</dd></dl>

<dl class="attribute">
<dt id="aiida.transports.transport.Transport.is_open">
<code class="descname">is_open</code><a class="headerlink" href="#aiida.transports.transport.Transport.is_open" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.transports.transport.Transport.isdir">
<code class="descname">isdir</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.isdir"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.transport.Transport.isdir" title="Permalink to this definition">¶</a></dt>
<dd><p>True if path is an existing directory.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>path</strong> (<em>str</em>) – path to directory</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">boolean</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.transport.Transport.isfile">
<code class="descname">isfile</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.isfile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.transport.Transport.isfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if path is an existing file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>path</strong> (<em>str</em>) – path to file</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">boolean</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.transport.Transport.listdir">
<code class="descname">listdir</code><span class="sig-paren">(</span><em>path='.'</em>, <em>pattern=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.listdir"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.transport.Transport.listdir" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of the names of the entries in the given path.
The list is in arbitrary order. It does not include the special
entries ‘.’ and ‘..’ even if they are present in the directory.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>path</strong> (<em>str</em>) – path to list (default to ‘.’)</li>
<li><strong>pattern</strong> (<em>str</em>) – if used, listdir returns a list of files matching
filters in Unix style. Unix only.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a list of strings</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.transport.Transport.listdir_withattributes">
<code class="descname">listdir_withattributes</code><span class="sig-paren">(</span><em>path='.'</em>, <em>pattern=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.listdir_withattributes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.transport.Transport.listdir_withattributes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of the names of the entries in the given path.
The list is in arbitrary order. It does not include the special
entries ‘.’ and ‘..’ even if they are present in the directory.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>path</strong> (<em>str</em>) – path to list (default to ‘.’)</li>
<li><strong>pattern</strong> (<em>str</em>) – if used, listdir returns a list of files matching
filters in Unix style. Unix only.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><p>a list of dictionaries, one per entry.
The schema of the dictionary is
the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
   <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span>
   <span class="s1">&#39;attributes&#39;</span><span class="p">:</span> <span class="n">FileAttributeObject</span><span class="p">,</span>
   <span class="s1">&#39;isdir&#39;</span><span class="p">:</span> <span class="n">Bool</span>
<span class="p">}</span>
</pre></div>
</div>
<p>where ‘name’ is the file or folder directory, and any other information is metadata
(if the file is a folder, a directory, …). ‘attributes’ behaves as the output of
transport.get_attribute(); isdir is a boolean indicating if the object is a directory or not.</p>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="aiida.transports.transport.Transport.logger">
<code class="descname">logger</code><a class="headerlink" href="#aiida.transports.transport.Transport.logger" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the internal logger.
If you have set extra parameters using set_logger_extra(), a
suitable LoggerAdapter instance is created, bringing with itself
also the extras.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.transport.Transport.makedirs">
<code class="descname">makedirs</code><span class="sig-paren">(</span><em>path</em>, <em>ignore_existing=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.makedirs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.transport.Transport.makedirs" title="Permalink to this definition">¶</a></dt>
<dd><p>Super-mkdir; create a leaf directory and all intermediate ones.
Works like mkdir, except that any intermediate path segment (not
just the rightmost) will be created if it does not exist.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>path</strong> (<em>str</em>) – directory to create</li>
<li><strong>ignore_existing</strong> (<em>bool</em>) – if set to true, it doesn’t give any error
if the leaf directory does already exist</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last">OSError, if directory at path already exists</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.transport.Transport.mkdir">
<code class="descname">mkdir</code><span class="sig-paren">(</span><em>path</em>, <em>ignore_existing=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.mkdir"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.transport.Transport.mkdir" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a folder (directory) named path.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>path</strong> (<em>str</em>) – name of the folder to create</li>
<li><strong>ignore_existing</strong> (<em>bool</em>) – if True, does not give any error if the
directory already exists</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last">OSError, if directory at path already exists</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.transport.Transport.normalize">
<code class="descname">normalize</code><span class="sig-paren">(</span><em>path='.'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.normalize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.transport.Transport.normalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the normalized path (on the server) of a given path.
This can be used to quickly resolve symbolic links or determine
what the server is considering to be the “current folder”.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>path</strong> (<em>str</em>) – path to be normalized</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><strong>IOError</strong> – if the path can’t be resolved on the server</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.transport.Transport.open">
<code class="descname">open</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.open"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.transport.Transport.open" title="Permalink to this definition">¶</a></dt>
<dd><p>Opens a local transport channel</p>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.transport.Transport.path_exists">
<code class="descname">path_exists</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.path_exists"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.transport.Transport.path_exists" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if path exists, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.transport.Transport.put">
<code class="descname">put</code><span class="sig-paren">(</span><em>localpath</em>, <em>remotepath</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.put"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.transport.Transport.put" title="Permalink to this definition">¶</a></dt>
<dd><p>Put a file or a directory from local src to remote dst.
src must be an absolute path (dst not necessarily))
Redirects to putfile and puttree.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>localpath</strong> (<em>str</em>) – absolute path to local source</li>
<li><strong>remotepath</strong> (<em>str</em>) – path to remote destination</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.transport.Transport.putfile">
<code class="descname">putfile</code><span class="sig-paren">(</span><em>localpath</em>, <em>remotepath</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.putfile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.transport.Transport.putfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Put a file from local src to remote dst.
src must be an absolute path (dst not necessarily))</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>localpath</strong> (<em>str</em>) – absolute path to local file</li>
<li><strong>remotepath</strong> (<em>str</em>) – path to remote file</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.transport.Transport.puttree">
<code class="descname">puttree</code><span class="sig-paren">(</span><em>localpath</em>, <em>remotepath</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.puttree"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.transport.Transport.puttree" title="Permalink to this definition">¶</a></dt>
<dd><p>Put a folder recursively from local src to remote dst.
src must be an absolute path (dst not necessarily))</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>localpath</strong> (<em>str</em>) – absolute path to local folder</li>
<li><strong>remotepath</strong> (<em>str</em>) – path to remote folder</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.transport.Transport.remove">
<code class="descname">remove</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.remove"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.transport.Transport.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the file at the given path. This only works on files;
for removing folders (directories), use rmdir.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>path</strong> (<em>str</em>) – path to file to remove</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><strong>IOError</strong> – if the path is a directory</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.transport.Transport.rename">
<code class="descname">rename</code><span class="sig-paren">(</span><em>oldpath</em>, <em>newpath</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.rename"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.transport.Transport.rename" title="Permalink to this definition">¶</a></dt>
<dd><p>Rename a file or folder from oldpath to newpath.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>oldpath</strong> (<em>str</em>) – existing name of the file or folder</li>
<li><strong>newpath</strong> (<em>str</em>) – new name for the file or folder</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><strong>IOError</strong> – if oldpath/newpath is not found</li>
<li><strong>ValueError</strong> – if oldpath/newpath is not a valid string</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.transport.Transport.rmdir">
<code class="descname">rmdir</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.rmdir"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.transport.Transport.rmdir" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the folder named path.
This works only for empty folders. For recursive remove, use rmtree.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>path</strong> (<em>str</em>) – absolute path to the folder to remove</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.transport.Transport.rmtree">
<code class="descname">rmtree</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.rmtree"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.transport.Transport.rmtree" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove recursively the content at path</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>path</strong> (<em>str</em>) – absolute path to remove</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.transport.Transport.set_logger_extra">
<code class="descname">set_logger_extra</code><span class="sig-paren">(</span><em>logger_extra</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.set_logger_extra"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.transport.Transport.set_logger_extra" title="Permalink to this definition">¶</a></dt>
<dd><p>Pass the data that should be passed automatically to self.logger
as ‘extra’ keyword. This is typically useful if you pass data
obtained using get_dblogger_extra in aiida.backends.djsite.utils, to automatically
log also to the DbLog table.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>logger_extra</strong> – data that you want to pass as extra to the
self.logger. To write to DbLog, it should be created by the
aiida.backends.djsite.utils.get_dblogger_extra function. Pass None if you
do not want to have extras passed.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.transport.Transport.symlink">
<code class="descname">symlink</code><span class="sig-paren">(</span><em>remotesource</em>, <em>remotedestination</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.symlink"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.transport.Transport.symlink" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a symbolic link between the remote source and the remote
destination.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>remotesource</strong> – remote source</li>
<li><strong>remotedestination</strong> – remote destination</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="aiida.transports.transport.Transport.whoami">
<code class="descname">whoami</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/transport.html#Transport.whoami"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.transport.Transport.whoami" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the remote username</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">list of username (str),
retval (int),
stderr (str)</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<span class="target" id="module-aiida.transports.util"></span><p>General utilities for Transport classes.</p>
<dl class="class">
<dt id="aiida.transports.util.FileAttribute">
<em class="property">class </em><code class="descclassname">aiida.transports.util.</code><code class="descname">FileAttribute</code><span class="sig-paren">(</span><em>init=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/util.html#FileAttribute"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.util.FileAttribute" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="aiida.common.html#aiida.common.extendeddicts.FixedFieldsAttributeDict" title="aiida.common.extendeddicts.FixedFieldsAttributeDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">aiida.common.extendeddicts.FixedFieldsAttributeDict</span></code></a></p>
<p>A class, resembling a dictionary, to describe the attributes of a file,
that is returned by get_attribute().
Possible keys: st_size, st_uid, st_gid, st_mode, st_atime, st_mtime</p>
<dl class="attribute">
<dt id="aiida.transports.util.FileAttribute.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.transports.util'</em><a class="headerlink" href="#aiida.transports.util.FileAttribute.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="aiida.transports.util.FileAttribute._valid_fields">
<code class="descname">_valid_fields</code><em class="property"> = ('st_size', 'st_uid', 'st_gid', 'st_mode', 'st_atime', 'st_mtime')</em><a class="headerlink" href="#aiida.transports.util.FileAttribute._valid_fields" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="aiida.transports.util._DetachedProxyCommand">
<em class="property">class </em><code class="descclassname">aiida.transports.util.</code><code class="descname">_DetachedProxyCommand</code><span class="sig-paren">(</span><em>command_line</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/util.html#_DetachedProxyCommand"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.util._DetachedProxyCommand" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">paramiko.proxy.ProxyCommand</span></code></p>
<p>Modifies paramiko’s ProxyCommand by launching the process in a separate process group.</p>
<dl class="method">
<dt id="aiida.transports.util._DetachedProxyCommand.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>command_line</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/util.html#_DetachedProxyCommand.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.util._DetachedProxyCommand.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new CommandProxy instance. The instance created by this
class can be passed as an argument to the <cite>.Transport</cite> class.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>command_line</strong> (<em>str</em>) – the command that should be executed and used as the proxy.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="aiida.transports.util._DetachedProxyCommand.__module__">
<code class="descname">__module__</code><em class="property"> = 'aiida.transports.util'</em><a class="headerlink" href="#aiida.transports.util._DetachedProxyCommand.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="aiida.transports.util._DetachedProxyCommand.close">
<code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/util.html#_DetachedProxyCommand.close"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.util._DetachedProxyCommand.close" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="aiida.transports.util.copy_from_remote_to_remote">
<code class="descclassname">aiida.transports.util.</code><code class="descname">copy_from_remote_to_remote</code><span class="sig-paren">(</span><em>transportsource</em>, <em>transportdestination</em>, <em>remotesource</em>, <em>remotedestination</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/aiida/transports/util.html#copy_from_remote_to_remote"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#aiida.transports.util.copy_from_remote_to_remote" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy files or folders from a remote computer to another remote computer.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>transportsource</strong> – transport to be used for the source computer</li>
<li><strong>transportdestination</strong> – transport to be used for the destination computer</li>
<li><strong>remotesource</strong> (<em>str</em>) – path to the remote source directory / file</li>
<li><strong>remotedestination</strong> (<em>str</em>) – path to the remote destination directory / file</li>
<li><strong>kwargs</strong> – keyword parameters passed to the final put,
except for ‘dereference’ that is passed to the initial get</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">it uses the method transportsource.copy_from_remote_to_remote</p>
</div>
</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, ECOLE POLYTECHNIQUE FEDERALE DE LAUSANNE (Theory and Simulation of Materials (THEOS) and National Centre for Computational Design and Discovery of Novel Materials (NCCR MARVEL)), Switzerland and ROBERT BOSCH LLC, USA. All rights reserved

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>