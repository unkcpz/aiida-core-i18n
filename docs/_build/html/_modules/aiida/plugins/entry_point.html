

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>aiida.plugins.entry_point &mdash; AiiDA 1.0.0b2 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../_static/language_data.js"></script>
        <script type="text/javascript" src="../../../_static/contentui.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/contentui.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> AiiDA
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Installation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install/quick_installation.html">Quick installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../install/prerequisites.html">Prerequisites</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../install/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../install/updating_installation.html">Updating AiiDA</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../install/troubleshooting.html">Troubleshooting</a></li>
</ul>
<p class="caption"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../get_started/index.html">First things first</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../get_started/daemon.html">Setup the daemon</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../get_started/computers.html">Setup a computer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../get_started/codes.html">Setup a code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../get_started/plugins.html">Plugins</a></li>
</ul>
<p class="caption"><span class="caption-text">Concepts</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../concepts/provenance.html">Provenance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../concepts/processes.html">Processes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../concepts/calculations.html">Calculations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../concepts/workflows.html">Workflows</a></li>
</ul>
<p class="caption"><span class="caption-text">Working with</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../working/processes.html">Processes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../working/functions.html">Calculation and work functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../working/calculations.html">Calculations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../working/workflows.html">Workflows</a></li>
</ul>
<p class="caption"><span class="caption-text">Working with AiiDA</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../working_with_aiida/index.html">Command line interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../working_with_aiida/index.html#scripting">Scripting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../working_with_aiida/index.html#data-types">Data types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../working_with_aiida/index.html#groups">Groups</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../working_with_aiida/index.html#schedulers">Schedulers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../working_with_aiida/index.html#querying-data">Querying data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../working_with_aiida/index.html#caching">Caching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../working_with_aiida/index.html#result-manager">Result manager</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../working_with_aiida/index.html#backups">Backups</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../working_with_aiida/index.html#troubleshooting">Troubleshooting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../working_with_aiida/index.html#rest-api">REST API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../working_with_aiida/index.html#cookbook">Cookbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../import_export/index.html">Import and Export</a></li>
</ul>
<p class="caption"><span class="caption-text">Development</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../developer_guide/index.html">AiiDA design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../developer_guide/index.html#aiida-core">AiiDA core</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../developer_guide/index.html#aiida-plugins">AiiDA plugins</a></li>
</ul>
<p class="caption"><span class="caption-text">Tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial/index.html">StructureData</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial/index.html#pseudopotentials">Pseudopotentials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial/index.html#plugin-development">Plugin development</a></li>
</ul>
<p class="caption"><span class="caption-text">API reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="`aiida package &lt;https://aiida-core.readthedocs.io/en/latest/apidoc/aiida.html&gt;`_">`aiida package &lt;https://aiida-core.readthedocs.io/en/latest/apidoc/aiida.html&gt;`_</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">AiiDA</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../../aiida.html">aiida</a> &raquo;</li>
        
      <li>aiida.plugins.entry_point</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for aiida.plugins.entry_point</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1">###########################################################################</span>
<span class="c1"># Copyright (c), The AiiDA team. All rights reserved.                     #</span>
<span class="c1"># This file is part of the AiiDA code.                                    #</span>
<span class="c1">#                                                                         #</span>
<span class="c1"># The code is hosted on GitHub at https://github.com/aiidateam/aiida_core #</span>
<span class="c1"># For further information on the license, see the LICENSE.txt file        #</span>
<span class="c1"># For further information please visit http://www.aiida.net               #</span>
<span class="c1">###########################################################################</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span>

<span class="kn">import</span> <span class="nn">enum</span>
<span class="kn">import</span> <span class="nn">six</span>
<span class="kn">import</span> <span class="nn">traceback</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">reentry.default_manager</span> <span class="k">import</span> <span class="n">PluginManager</span>
    <span class="c1"># I don&#39;t use the default manager as it has scan_for_not_found=True</span>
    <span class="c1"># by default, which re-runs scan if no entrypoints are found</span>
    <span class="n">ENTRYPOINT_MANAGER</span> <span class="o">=</span> <span class="n">PluginManager</span><span class="p">(</span><span class="n">scan_for_not_found</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">pkg_resources</span> <span class="k">as</span> <span class="nn">ENTRYPOINT_MANAGER</span>

<span class="kn">from</span> <span class="nn">aiida.common.exceptions</span> <span class="k">import</span> <span class="n">MissingEntryPointError</span><span class="p">,</span> <span class="n">MultipleEntryPointError</span><span class="p">,</span> <span class="n">LoadingEntryPointError</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;load_entry_point&#39;</span><span class="p">,</span> <span class="s1">&#39;load_entry_point_from_string&#39;</span><span class="p">)</span>


<span class="n">ENTRY_POINT_GROUP_PREFIX</span> <span class="o">=</span> <span class="s1">&#39;aiida.&#39;</span>
<span class="n">ENTRY_POINT_STRING_SEPARATOR</span> <span class="o">=</span> <span class="s1">&#39;:&#39;</span>


<span class="k">class</span> <span class="nc">EntryPointFormat</span><span class="p">(</span><span class="n">enum</span><span class="o">.</span><span class="n">Enum</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Enum to distinguish between the various possible entry point string formats. An entry point string</span>
<span class="sd">    is fully qualified by its group and name concatenated by the entry point string separator character.</span>
<span class="sd">    The group in AiiDA has the prefix `aiida.` and the separator character is the colon `:`.</span>

<span class="sd">    Under these definitions a potentially valid entry point string may have the following formats:</span>

<span class="sd">        * FULL:    prefixed group plus entry point name     aiida.transports:ssh</span>
<span class="sd">        * PARTIAL: unprefixed group plus entry point name   transports:ssh</span>
<span class="sd">        * MINIMAL: no group but only entry point name:      ssh</span>

<span class="sd">    Note that the MINIMAL format can potentially lead to ambiguity if the name appears in multiple</span>
<span class="sd">    entry point groups.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">INVALID</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">FULL</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">PARTIAL</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">MINIMAL</span> <span class="o">=</span> <span class="mi">3</span>


<span class="n">entry_point_group_to_module_path_map</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;aiida.calculations&#39;</span><span class="p">:</span> <span class="s1">&#39;aiida.orm.nodes.process.calculation.calcjob&#39;</span><span class="p">,</span>
    <span class="s1">&#39;aiida.data&#39;</span><span class="p">:</span> <span class="s1">&#39;aiida.orm.nodes.data&#39;</span><span class="p">,</span>
    <span class="s1">&#39;aiida.node&#39;</span><span class="p">:</span> <span class="s1">&#39;aiida.orm.nodes&#39;</span><span class="p">,</span>
    <span class="s1">&#39;aiida.parsers&#39;</span><span class="p">:</span> <span class="s1">&#39;aiida.parsers.plugins&#39;</span><span class="p">,</span>
    <span class="s1">&#39;aiida.schedulers&#39;</span><span class="p">:</span> <span class="s1">&#39;aiida.schedulers.plugins&#39;</span><span class="p">,</span>
    <span class="s1">&#39;aiida.tools.dbexporters&#39;</span><span class="p">:</span> <span class="s1">&#39;aiida.tools.dbexporters&#39;</span><span class="p">,</span>
    <span class="s1">&#39;aiida.tools.dbimporters&#39;</span><span class="p">:</span> <span class="s1">&#39;aiida.tools.dbimporters.plugins&#39;</span><span class="p">,</span>
    <span class="s1">&#39;aiida.transports&#39;</span><span class="p">:</span> <span class="s1">&#39;aiida.transports.plugins&#39;</span><span class="p">,</span>
    <span class="s1">&#39;aiida.workflows&#39;</span><span class="p">:</span> <span class="s1">&#39;aiida.workflows&#39;</span><span class="p">,</span>
<span class="p">}</span>


<span class="k">def</span> <span class="nf">format_entry_point_string</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="n">EntryPointFormat</span><span class="o">.</span><span class="n">FULL</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Format an entry point string for a given entry point group and name, based on the specified format</span>

<span class="sd">    :param group: the entry point group</span>
<span class="sd">    :param name: the name of the entry point</span>
<span class="sd">    :param fmt: the desired output format</span>
<span class="sd">    :raises TypeError: if fmt is not instance of EntryPointFormat</span>
<span class="sd">    :raises ValueError: if fmt value is invalid</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="n">EntryPointFormat</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;fmt should be an instance of EntryPointFormat&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">fmt</span> <span class="o">==</span> <span class="n">EntryPointFormat</span><span class="o">.</span><span class="n">FULL</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}{}{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">ENTRY_POINT_STRING_SEPARATOR</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">fmt</span> <span class="o">==</span> <span class="n">EntryPointFormat</span><span class="o">.</span><span class="n">PARTIAL</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}{}{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">group</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">ENTRY_POINT_GROUP_PREFIX</span><span class="p">):],</span> <span class="n">ENTRY_POINT_STRING_SEPARATOR</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">fmt</span> <span class="o">==</span> <span class="n">EntryPointFormat</span><span class="o">.</span><span class="n">MINIMAL</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;invalid EntryPointFormat&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">parse_entry_point_string</span><span class="p">(</span><span class="n">entry_point_string</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Validate the entry point string and attempt to parse the entry point group and name</span>

<span class="sd">    :param entry_point_string: the entry point string</span>
<span class="sd">    :return: the entry point group and name if the string is valid</span>
<span class="sd">    :raises TypeError: if the entry_point_string is not a string type</span>
<span class="sd">    :raises ValueError: if the entry_point_string cannot be split into two parts on the entry point string separator</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">entry_point_string</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;the entry_point_string should be a string&#39;</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">group</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="n">entry_point_string</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">ENTRY_POINT_STRING_SEPARATOR</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;invalid entry_point_string format&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">group</span><span class="p">,</span> <span class="n">name</span>


<span class="k">def</span> <span class="nf">get_entry_point_string_format</span><span class="p">(</span><span class="n">entry_point_string</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determine the format of an entry point string. Note that it does not validate the actual entry point</span>
<span class="sd">    string and it may not correspond to any actual entry point. This will only assess the string format</span>

<span class="sd">    :param entry_point_string: the entry point string</span>
<span class="sd">    :returns: the entry point type</span>
<span class="sd">    :rtype: EntryPointFormat</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">group</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="n">entry_point_string</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">ENTRY_POINT_STRING_SEPARATOR</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">EntryPointFormat</span><span class="o">.</span><span class="n">MINIMAL</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">group</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">ENTRY_POINT_GROUP_PREFIX</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">EntryPointFormat</span><span class="o">.</span><span class="n">FULL</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">EntryPointFormat</span><span class="o">.</span><span class="n">PARTIAL</span>


<span class="k">def</span> <span class="nf">get_entry_point_from_string</span><span class="p">(</span><span class="n">entry_point_string</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return an entry point for the given entry point string</span>

<span class="sd">    :param entry_point_string: the entry point string</span>
<span class="sd">    :return: the entry point if it exists else None</span>
<span class="sd">    :raises TypeError: if the entry_point_string is not a string type</span>
<span class="sd">    :raises ValueError: if the entry_point_string cannot be split into two parts on the entry point string separator</span>
<span class="sd">    :raises aiida.common.MissingEntryPointError: entry point was not registered</span>
<span class="sd">    :raises aiida.common.MultipleEntryPointError: entry point could not be uniquely resolved</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">group</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="n">parse_entry_point_string</span><span class="p">(</span><span class="n">entry_point_string</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">get_entry_point</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>


<div class="viewcode-block" id="load_entry_point_from_string"><a class="viewcode-back" href="../../../apidoc/aiida.plugins.html#aiida.plugins.load_entry_point_from_string">[docs]</a><span class="k">def</span> <span class="nf">load_entry_point_from_string</span><span class="p">(</span><span class="n">entry_point_string</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load the class registered for a given entry point string that determines group and name</span>

<span class="sd">    :param entry_point_string: the entry point string</span>
<span class="sd">    :return: class registered at the given entry point</span>
<span class="sd">    :raises TypeError: if the entry_point_string is not a string type</span>
<span class="sd">    :raises ValueError: if the entry_point_string cannot be split into two parts on the entry point string separator</span>
<span class="sd">    :raises aiida.common.MissingEntryPointError: entry point was not registered</span>
<span class="sd">    :raises aiida.common.MultipleEntryPointError: entry point could not be uniquely resolved</span>
<span class="sd">    :raises aiida.common.LoadingEntryPointError: entry point could not be loaded</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">group</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="n">parse_entry_point_string</span><span class="p">(</span><span class="n">entry_point_string</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">load_entry_point</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span></div>


<div class="viewcode-block" id="load_entry_point"><a class="viewcode-back" href="../../../apidoc/aiida.plugins.html#aiida.plugins.load_entry_point">[docs]</a><span class="k">def</span> <span class="nf">load_entry_point</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load the class registered under the entry point for a given name and group</span>

<span class="sd">    :param group: the entry point group</span>
<span class="sd">    :param name: the name of the entry point</span>
<span class="sd">    :return: class registered at the given entry point</span>
<span class="sd">    :raises TypeError: if the entry_point_string is not a string type</span>
<span class="sd">    :raises ValueError: if the entry_point_string cannot be split into two parts on the entry point string separator</span>
<span class="sd">    :raises aiida.common.MissingEntryPointError: entry point was not registered</span>
<span class="sd">    :raises aiida.common.MultipleEntryPointError: entry point could not be uniquely resolved</span>
<span class="sd">    :raises aiida.common.LoadingEntryPointError: entry point could not be loaded</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">entry_point</span> <span class="o">=</span> <span class="n">get_entry_point</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">loaded_entry_point</span> <span class="o">=</span> <span class="n">entry_point</span><span class="o">.</span><span class="n">load</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">LoadingEntryPointError</span><span class="p">(</span><span class="s2">&quot;Failed to load entry point &#39;</span><span class="si">{}</span><span class="s2">&#39;:</span><span class="se">\n</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">traceback</span><span class="o">.</span><span class="n">format_exc</span><span class="p">()))</span>

    <span class="k">return</span> <span class="n">loaded_entry_point</span></div>


<span class="k">def</span> <span class="nf">get_entry_point_groups</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a list of all the recognized entry point groups</span>

<span class="sd">    :return: a list of valid entry point groups</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">entry_point_group_to_module_path_map</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">get_entry_point_names</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a list of all the entry point names within a specific group</span>

<span class="sd">    :param group: the entry point group</span>
<span class="sd">    :param sort: if True, the returned list will be sorted alphabetically</span>
<span class="sd">    :return: a list of entry point names</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">entry_point_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">ep</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">ep</span> <span class="ow">in</span> <span class="n">get_entry_points</span><span class="p">(</span><span class="n">group</span><span class="p">)]</span>

    <span class="k">if</span> <span class="n">sort</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">entry_point_names</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">entry_point_names</span>


<span class="k">def</span> <span class="nf">get_entry_points</span><span class="p">(</span><span class="n">group</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a list of all the entry points within a specific group</span>

<span class="sd">    :param group: the entry point group</span>
<span class="sd">    :return: a list of entry points</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">ep</span> <span class="k">for</span> <span class="n">ep</span> <span class="ow">in</span> <span class="n">ENTRYPOINT_MANAGER</span><span class="o">.</span><span class="n">iter_entry_points</span><span class="p">(</span><span class="n">group</span><span class="o">=</span><span class="n">group</span><span class="p">)]</span>


<span class="k">def</span> <span class="nf">get_entry_point</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return an entry point with a given name within a specific group</span>

<span class="sd">    :param group: the entry point group</span>
<span class="sd">    :param name: the name of the entry point</span>
<span class="sd">    :return: the entry point if it exists else None</span>
<span class="sd">    :raises aiida.common.MissingEntryPointError: entry point was not registered</span>
<span class="sd">    :raises aiida.common.MultipleEntryPointError: entry point could not be uniquely resolved</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">entry_points</span> <span class="o">=</span> <span class="p">[</span><span class="n">ep</span> <span class="k">for</span> <span class="n">ep</span> <span class="ow">in</span> <span class="n">get_entry_points</span><span class="p">(</span><span class="n">group</span><span class="p">)</span> <span class="k">if</span> <span class="n">ep</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">name</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">entry_points</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">MissingEntryPointError</span><span class="p">(</span><span class="s2">&quot;Entry point &#39;</span><span class="si">{}</span><span class="s2">&#39; not found in group &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">group</span><span class="p">))</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">entry_points</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">MultipleEntryPointError</span><span class="p">(</span><span class="s2">&quot;Multiple entry points &#39;</span><span class="si">{}</span><span class="s2">&#39; found in group&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">group</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">entry_points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">get_entry_point_from_class</span><span class="p">(</span><span class="n">class_module</span><span class="p">,</span> <span class="n">class_name</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given the module and name of a class, attempt to obtain the corresponding entry point if it exists</span>

<span class="sd">    :param class_module: module of the class</span>
<span class="sd">    :param class_name: name of the class</span>
<span class="sd">    :return: a tuple of the corresponding group and entry point or None if not found</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">ENTRYPOINT_MANAGER</span><span class="o">.</span><span class="n">get_entry_map</span><span class="p">()</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">entry_point</span> <span class="ow">in</span> <span class="n">ENTRYPOINT_MANAGER</span><span class="o">.</span><span class="n">iter_entry_points</span><span class="p">(</span><span class="n">group</span><span class="p">):</span>

            <span class="k">if</span> <span class="n">entry_point</span><span class="o">.</span><span class="n">module_name</span> <span class="o">!=</span> <span class="n">class_module</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">for</span> <span class="n">entry_point_class_name</span> <span class="ow">in</span> <span class="n">entry_point</span><span class="o">.</span><span class="n">attrs</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">entry_point_class_name</span> <span class="o">==</span> <span class="n">class_name</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">group</span><span class="p">,</span> <span class="n">entry_point</span>

    <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>


<span class="k">def</span> <span class="nf">get_entry_point_string_from_class</span><span class="p">(</span><span class="n">class_module</span><span class="p">,</span> <span class="n">class_name</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given the module and name of a class, attempt to obtain the corresponding entry point if it</span>
<span class="sd">    exists and return the entry point string which will be the entry point group and entry point</span>
<span class="sd">    name concatenated by the entry point string separator</span>

<span class="sd">        entry_point_string = &#39;{group:}:{entry_point_name:}&#39;</span>

<span class="sd">    This ensures that given the entry point string, one can load the corresponding class</span>
<span class="sd">    by splitting on the separator, which will give the group and entry point, which should</span>
<span class="sd">    the corresponding factory to uniquely determine and load the class</span>


<span class="sd">    :param class_module: module of the class</span>
<span class="sd">    :param class_name: name of the class</span>
<span class="sd">    :return: the corresponding entry point string or None</span>
<span class="sd">    :rtype: str</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">group</span><span class="p">,</span> <span class="n">entry_point</span> <span class="o">=</span> <span class="n">get_entry_point_from_class</span><span class="p">(</span><span class="n">class_module</span><span class="p">,</span> <span class="n">class_name</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">group</span> <span class="ow">and</span> <span class="n">entry_point</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ENTRY_POINT_STRING_SEPARATOR</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">group</span><span class="p">,</span> <span class="n">entry_point</span><span class="o">.</span><span class="n">name</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>


<span class="k">def</span> <span class="nf">is_valid_entry_point_string</span><span class="p">(</span><span class="n">entry_point_string</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Verify whether the given entry point string is a valid one. For the string to be valid means that it is composed</span>
<span class="sd">    of two strings, the entry point group and name, concatenated by the entry point string separator. If that is the</span>
<span class="sd">    case, the group name will be verified to see if it is known. If the group can be retrieved and it is known, the</span>
<span class="sd">    string is considered to be valid. It is invalid otherwise</span>

<span class="sd">    :param entry_point_string: the entry point string, generated by get_entry_point_string_from_class</span>
<span class="sd">    :return: True if the string is considered valid, False otherwise</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">group</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="n">entry_point_string</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">ENTRY_POINT_STRING_SEPARATOR</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">entry_point_group_to_module_path_map</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, ECOLE POLYTECHNIQUE FEDERALE DE LAUSANNE (Theory and Simulation of Materials (THEOS) and National Centre for Computational Design and Discovery of Novel Materials (NCCR MARVEL)), Switzerland and ROBERT BOSCH LLC, USA. All rights reserved

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>