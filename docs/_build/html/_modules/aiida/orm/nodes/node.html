

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>aiida.orm.nodes.node &mdash; AiiDA 1.0.0b2 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../../_static/language_data.js"></script>
        <script type="text/javascript" src="../../../../_static/contentui.js"></script>
    
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/contentui.css" type="text/css" />
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../../index.html" class="icon icon-home"> AiiDA
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Installation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../install/quick_installation.html">Quick installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../install/prerequisites.html">Prerequisites</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../install/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../install/updating_installation.html">Updating AiiDA</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../install/troubleshooting.html">Troubleshooting</a></li>
</ul>
<p class="caption"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../get_started/index.html">First things first</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../get_started/daemon.html">Setup the daemon</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../get_started/computers.html">Setup a computer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../get_started/codes.html">Setup a code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../get_started/plugins.html">Plugins</a></li>
</ul>
<p class="caption"><span class="caption-text">Concepts</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../concepts/provenance.html">Provenance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../concepts/processes.html">Processes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../concepts/calculations.html">Calculations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../concepts/workflows.html">Workflows</a></li>
</ul>
<p class="caption"><span class="caption-text">Working with</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../working/processes.html">Processes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../working/functions.html">Calculation and work functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../working/calculations.html">Calculations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../working/workflows.html">Workflows</a></li>
</ul>
<p class="caption"><span class="caption-text">Working with AiiDA</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../working_with_aiida/index.html">Command line interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../working_with_aiida/index.html#scripting">Scripting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../working_with_aiida/index.html#data-types">Data types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../working_with_aiida/index.html#groups">Groups</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../working_with_aiida/index.html#schedulers">Schedulers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../working_with_aiida/index.html#querying-data">Querying data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../working_with_aiida/index.html#caching">Caching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../working_with_aiida/index.html#result-manager">Result manager</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../working_with_aiida/index.html#backups">Backups</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../working_with_aiida/index.html#troubleshooting">Troubleshooting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../working_with_aiida/index.html#rest-api">REST API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../working_with_aiida/index.html#cookbook">Cookbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../import_export/index.html">Import and Export</a></li>
</ul>
<p class="caption"><span class="caption-text">Development</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../developer_guide/index.html">AiiDA design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../developer_guide/index.html#aiida-core">AiiDA core</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../developer_guide/index.html#aiida-plugins">AiiDA plugins</a></li>
</ul>
<p class="caption"><span class="caption-text">Tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorial/index.html">StructureData</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorial/index.html#pseudopotentials">Pseudopotentials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorial/index.html#plugin-development">Plugin development</a></li>
</ul>
<p class="caption"><span class="caption-text">API reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="`aiida package &lt;https://aiida-core.readthedocs.io/en/latest/apidoc/aiida.html&gt;`_">`aiida package &lt;https://aiida-core.readthedocs.io/en/latest/apidoc/aiida.html&gt;`_</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">AiiDA</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../../../aiida.html">aiida</a> &raquo;</li>
        
      <li>aiida.orm.nodes.node</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for aiida.orm.nodes.node</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1">###########################################################################</span>
<span class="c1"># Copyright (c), The AiiDA team. All rights reserved.                     #</span>
<span class="c1"># This file is part of the AiiDA code.                                    #</span>
<span class="c1">#                                                                         #</span>
<span class="c1"># The code is hosted on GitHub at https://github.com/aiidateam/aiida_core #</span>
<span class="c1"># For further information on the license, see the LICENSE.txt file        #</span>
<span class="c1"># For further information please visit http://www.aiida.net               #</span>
<span class="c1">###########################################################################</span>
<span class="c1"># pylint: disable=too-many-lines</span>
<span class="sd">&quot;&quot;&quot;Package for node ORM classes.&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span>

<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">importlib</span>
<span class="kn">import</span> <span class="nn">six</span>

<span class="kn">from</span> <span class="nn">aiida.backends.utils</span> <span class="k">import</span> <span class="n">validate_attribute_key</span>
<span class="kn">from</span> <span class="nn">aiida.common</span> <span class="k">import</span> <span class="n">exceptions</span>
<span class="kn">from</span> <span class="nn">aiida.common.escaping</span> <span class="k">import</span> <span class="n">sql_string_match</span>
<span class="kn">from</span> <span class="nn">aiida.common.hashing</span> <span class="k">import</span> <span class="n">make_hash</span><span class="p">,</span> <span class="n">_HASH_EXTRA_KEY</span>
<span class="kn">from</span> <span class="nn">aiida.common.lang</span> <span class="k">import</span> <span class="n">classproperty</span><span class="p">,</span> <span class="n">type_check</span>
<span class="kn">from</span> <span class="nn">aiida.common.links</span> <span class="k">import</span> <span class="n">LinkType</span>
<span class="kn">from</span> <span class="nn">aiida.manage.manager</span> <span class="k">import</span> <span class="n">get_manager</span>
<span class="kn">from</span> <span class="nn">aiida.orm.utils.links</span> <span class="k">import</span> <span class="n">LinkManager</span><span class="p">,</span> <span class="n">LinkTriple</span>
<span class="kn">from</span> <span class="nn">aiida.orm.utils.repository</span> <span class="k">import</span> <span class="n">Repository</span>
<span class="kn">from</span> <span class="nn">aiida.orm.utils.node</span> <span class="k">import</span> <span class="n">AbstractNodeMeta</span><span class="p">,</span> <span class="n">clean_value</span>

<span class="kn">from</span> <span class="nn">..comments</span> <span class="k">import</span> <span class="n">Comment</span>
<span class="kn">from</span> <span class="nn">..computers</span> <span class="k">import</span> <span class="n">Computer</span>
<span class="kn">from</span> <span class="nn">..entities</span> <span class="k">import</span> <span class="n">Entity</span>
<span class="kn">from</span> <span class="nn">..entities</span> <span class="k">import</span> <span class="n">Collection</span> <span class="k">as</span> <span class="n">EntityCollection</span>
<span class="kn">from</span> <span class="nn">..querybuilder</span> <span class="k">import</span> <span class="n">QueryBuilder</span>
<span class="kn">from</span> <span class="nn">..users</span> <span class="k">import</span> <span class="n">User</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Node&#39;</span><span class="p">,)</span>

<span class="n">_NO_DEFAULT</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">()</span>


<div class="viewcode-block" id="Node"><a class="viewcode-back" href="../../../../developer_guide/core/orm_overview.html#aiida.orm.Node">[docs]</a><span class="nd">@six</span><span class="o">.</span><span class="n">add_metaclass</span><span class="p">(</span><span class="n">AbstractNodeMeta</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">Node</span><span class="p">(</span><span class="n">Entity</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for all nodes in AiiDA.</span>

<span class="sd">    Stores attributes starting with an underscore.</span>

<span class="sd">    Caches files and attributes before the first save, and saves everything</span>
<span class="sd">    only on store(). After the call to store(), attributes cannot be changed.</span>

<span class="sd">    Only after storing (or upon loading from uuid) extras can be modified</span>
<span class="sd">    and in this case they are directly set on the db.</span>

<span class="sd">    In the plugin, also set the _plugin_type_string, to be set in the DB in</span>
<span class="sd">    the &#39;type&#39; field.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># pylint: disable=too-many-public-methods</span>

<div class="viewcode-block" id="Node.Collection"><a class="viewcode-back" href="../../../../developer_guide/core/orm_overview.html#aiida.orm.Node.Collection">[docs]</a>    <span class="k">class</span> <span class="nc">Collection</span><span class="p">(</span><span class="n">EntityCollection</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The collection of AuthInfo entries.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="Node.Collection.delete"><a class="viewcode-back" href="../../../../developer_guide/core/orm_overview.html#aiida.orm.Node.Collection.delete">[docs]</a>        <span class="k">def</span> <span class="nf">delete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Delete a `Node` from the collection with the given id</span>

<span class="sd">            :param node_id: the node id</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="n">node_id</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">is_stored</span><span class="p">:</span>
                <span class="k">return</span>

            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">get_outgoing</span><span class="p">()</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="k">raise</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">InvalidOperation</span><span class="p">(</span><span class="s1">&#39;cannot delete Node&lt;</span><span class="si">{}</span><span class="s1">&gt; because it has output links&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">pk</span><span class="p">))</span>

            <span class="n">repository</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">_repository</span>  <span class="c1"># pylint: disable=protected-access</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_backend</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">node_id</span><span class="p">)</span>
            <span class="n">repository</span><span class="o">.</span><span class="n">erase</span><span class="p">(</span><span class="n">force</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div></div>

    <span class="c1"># This will be set by the metaclass call</span>
    <span class="n">_logger</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># A tuple of attribute names that can be updated even after node is stored</span>
    <span class="c1"># Requires Sealable mixin, but needs empty tuple for base class</span>
    <span class="n">_updatable_attributes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">()</span>

    <span class="c1"># A tuple of attribute names that will be ignored when creating the hash.</span>
    <span class="n">_hash_ignored_attributes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">()</span>

    <span class="c1"># Flag that determines whether the class can be cached.</span>
    <span class="n">_cachable</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># Base path within the repository where to put objects by default</span>
    <span class="n">_repository_base_path</span> <span class="o">=</span> <span class="s1">&#39;path&#39;</span>

    <span class="c1"># Flag that determines whether the class can be stored.</span>
    <span class="n">_storable</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">_unstorable_message</span> <span class="o">=</span> <span class="s1">&#39;only Data, WorkflowNode, CalculationNode or their subclasses can be stored&#39;</span>

    <span class="c1"># These are to be initialized in the `initialization` method</span>
    <span class="n">_incoming_cache</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_attrs_cache</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_repository</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="Node.from_backend_entity"><a class="viewcode-back" href="../../../../developer_guide/core/orm_overview.html#aiida.orm.Node.from_backend_entity">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_backend_entity</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">backend_entity</span><span class="p">):</span>
        <span class="n">entity</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">Node</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="n">from_backend_entity</span><span class="p">(</span><span class="n">backend_entity</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">entity</span></div>

<div class="viewcode-block" id="Node.__init__"><a class="viewcode-back" href="../../../../apidoc/aiida.orm.nodes.html#aiida.orm.Node.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">user</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">computer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">backend</span> <span class="o">=</span> <span class="n">backend</span> <span class="ow">or</span> <span class="n">get_manager</span><span class="p">()</span><span class="o">.</span><span class="n">get_backend</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">computer</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">computer</span><span class="o">.</span><span class="n">is_stored</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;the computer is not stored&#39;</span><span class="p">)</span>

        <span class="n">computer</span> <span class="o">=</span> <span class="n">computer</span><span class="o">.</span><span class="n">backend_entity</span> <span class="k">if</span> <span class="n">computer</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">user</span> <span class="o">=</span> <span class="n">user</span><span class="o">.</span><span class="n">backend_entity</span> <span class="k">if</span> <span class="n">user</span> <span class="k">else</span> <span class="n">User</span><span class="o">.</span><span class="n">objects</span><span class="p">(</span><span class="n">backend</span><span class="p">)</span><span class="o">.</span><span class="n">get_default</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">user</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">aiida.manage.configuration</span> <span class="k">import</span> <span class="n">get_config</span><span class="p">,</span> <span class="n">get_profile</span>
            <span class="n">config</span> <span class="o">=</span> <span class="n">get_config</span><span class="p">()</span>
            <span class="n">profile</span> <span class="o">=</span> <span class="n">get_profile</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;CONFIG&#39;</span><span class="p">,</span> <span class="n">config</span><span class="o">.</span><span class="n">dictionary</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;PROFILE&#39;</span><span class="p">,</span> <span class="n">profile</span><span class="o">.</span><span class="n">dictionary</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;USERS&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">user</span><span class="o">.</span><span class="n">email</span> <span class="k">for</span> <span class="n">user</span> <span class="ow">in</span> <span class="n">User</span><span class="o">.</span><span class="n">objects</span><span class="p">(</span><span class="n">backend</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()])</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;the user cannot be None&#39;</span><span class="p">)</span>

        <span class="n">backend_entity</span> <span class="o">=</span> <span class="n">backend</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">create</span><span class="p">(</span>
            <span class="n">node_type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">class_node_type</span><span class="p">,</span> <span class="n">user</span><span class="o">=</span><span class="n">user</span><span class="o">.</span><span class="n">backend_entity</span><span class="p">,</span> <span class="n">computer</span><span class="o">=</span><span class="n">computer</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Node</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">backend_entity</span><span class="p">)</span></div>

<div class="viewcode-block" id="Node.__repr__"><a class="viewcode-back" href="../../../../apidoc/aiida.orm.nodes.html#aiida.orm.Node.__repr__">[docs]</a>    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;&lt;</span><span class="si">{}</span><span class="s1">: </span><span class="si">{}</span><span class="s1">&gt;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span></div>

<div class="viewcode-block" id="Node.__str__"><a class="viewcode-back" href="../../../../apidoc/aiida.orm.nodes.html#aiida.orm.Node.__str__">[docs]</a>    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_stored</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;uuid: </span><span class="si">{}</span><span class="s1"> (unstored)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">uuid</span><span class="p">)</span>

        <span class="k">return</span> <span class="s1">&#39;uuid: </span><span class="si">{}</span><span class="s1"> (pk: </span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">uuid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pk</span><span class="p">)</span></div>

<div class="viewcode-block" id="Node.__copy__"><a class="viewcode-back" href="../../../../apidoc/aiida.orm.nodes.html#aiida.orm.Node.__copy__">[docs]</a>    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Copying a Node is not supported in general, but only for the Data sub class.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">InvalidOperation</span><span class="p">(</span><span class="s1">&#39;copying a base Node is not supported&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Node.__deepcopy__"><a class="viewcode-back" href="../../../../apidoc/aiida.orm.nodes.html#aiida.orm.Node.__deepcopy__">[docs]</a>    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Deep copying a Node is not supported in general, but only for the Data sub class.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">InvalidOperation</span><span class="p">(</span><span class="s1">&#39;deep copying a base Node is not supported&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Node.initialize"><a class="viewcode-back" href="../../../../developer_guide/core/orm_overview.html#aiida.orm.Node.initialize">[docs]</a>    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize internal variables for the backend node</span>

<span class="sd">        This needs to be called explicitly in each specific subclass implementation of the init.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Node</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">initialize</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_attrs_cache</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># A cache of incoming links represented as a list of LinkTriples instances</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_incoming_cache</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

        <span class="c1"># Calls the initialisation from the RepositoryMixin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_repository</span> <span class="o">=</span> <span class="n">Repository</span><span class="p">(</span><span class="n">uuid</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">uuid</span><span class="p">,</span> <span class="n">is_stored</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">is_stored</span><span class="p">,</span> <span class="n">base_path</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_repository_base_path</span><span class="p">)</span></div>

<div class="viewcode-block" id="Node._validate"><a class="viewcode-back" href="../../../../apidoc/aiida.orm.nodes.html#aiida.orm.Node._validate">[docs]</a>    <span class="k">def</span> <span class="nf">_validate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if the attributes and files retrieved from the database are valid.</span>

<span class="sd">        Must be able to work even before storing: therefore, use the `get_attr` and similar methods that automatically</span>
<span class="sd">        read either from the DB or from the internal attribute cache.</span>

<span class="sd">        For the base class, this is always valid. Subclasses will reimplement this.</span>
<span class="sd">        In the subclass, always call the super()._validate() method first!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># pylint: disable=no-self-use</span>
        <span class="k">return</span> <span class="kc">True</span></div>

    <span class="nd">@classproperty</span>
    <span class="k">def</span> <span class="nf">class_node_type</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the node type of this node (sub) class.&quot;&quot;&quot;</span>
        <span class="c1"># pylint: disable=no-self-argument,no-member</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_plugin_type_string</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">logger</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the logger configured for this Node.</span>

<span class="sd">        :return: Logger object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">uuid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the node UUID.</span>

<span class="sd">        :return: the string representation of the UUID</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">backend_entity</span><span class="o">.</span><span class="n">uuid</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">node_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the node type.</span>

<span class="sd">        :return: the node type</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">backend_entity</span><span class="o">.</span><span class="n">node_type</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">process_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the node process type.</span>

<span class="sd">        :return: the process type</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">backend_entity</span><span class="o">.</span><span class="n">process_type</span>

    <span class="nd">@process_type</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">process_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the node process type.</span>

<span class="sd">        :param value: the new value to set</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">backend_entity</span><span class="o">.</span><span class="n">process_type</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">label</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the node label.</span>

<span class="sd">        :return: the label</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">backend_entity</span><span class="o">.</span><span class="n">label</span>

    <span class="nd">@label</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the label.</span>

<span class="sd">        :param value: the new value to set</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">backend_entity</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">description</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the node description.</span>

<span class="sd">        :return: the description</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">backend_entity</span><span class="o">.</span><span class="n">description</span>

    <span class="nd">@description</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">description</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the description.</span>

<span class="sd">        :param value: the new value to set</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">backend_entity</span><span class="o">.</span><span class="n">description</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">computer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the computer of this node.</span>

<span class="sd">        :return: the computer or None</span>
<span class="sd">        :rtype: `Computer` or None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">backend_entity</span><span class="o">.</span><span class="n">computer</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Computer</span><span class="o">.</span><span class="n">from_backend_entity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">backend_entity</span><span class="o">.</span><span class="n">computer</span><span class="p">)</span>

        <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@computer</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">computer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">computer</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the computer of this node.</span>

<span class="sd">        :param computer: a `Computer`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_stored</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">ModificationNotAllowed</span><span class="p">(</span><span class="s1">&#39;cannot set the computer on a stored node&#39;</span><span class="p">)</span>

        <span class="n">type_check</span><span class="p">(</span><span class="n">computer</span><span class="p">,</span> <span class="n">Computer</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">computer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">computer</span> <span class="o">=</span> <span class="n">computer</span><span class="o">.</span><span class="n">backend_entity</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">backend_entity</span><span class="o">.</span><span class="n">computer</span> <span class="o">=</span> <span class="n">computer</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">user</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the user of this node.</span>

<span class="sd">        :return: the user</span>
<span class="sd">        :rtype: `User`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">User</span><span class="o">.</span><span class="n">from_backend_entity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">backend_entity</span><span class="o">.</span><span class="n">user</span><span class="p">)</span>

    <span class="nd">@user</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">user</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the user of this node.</span>

<span class="sd">        :param user: a `User`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_stored</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">ModificationNotAllowed</span><span class="p">(</span><span class="s1">&#39;cannot set the user on a stored node&#39;</span><span class="p">)</span>

        <span class="n">type_check</span><span class="p">(</span><span class="n">user</span><span class="p">,</span> <span class="n">User</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">backend_entity</span><span class="o">.</span><span class="n">user</span> <span class="o">=</span> <span class="n">user</span><span class="o">.</span><span class="n">backend_entity</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ctime</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the node ctime.</span>

<span class="sd">        :return: the ctime</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">backend_entity</span><span class="o">.</span><span class="n">ctime</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mtime</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the node mtime.</span>

<span class="sd">        :return: the mtime</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">backend_entity</span><span class="o">.</span><span class="n">mtime</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">version</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the node version.</span>

<span class="sd">        :return: the version</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">backend_entity</span><span class="o">.</span><span class="n">version</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">public</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the node public attribute.</span>

<span class="sd">        :return: the public attribute</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">backend_entity</span><span class="o">.</span><span class="n">public</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the attributes dictionary.</span>

<span class="sd">        .. note:: This will fetch all the attributes from the database which can be a heavy operation. If you only need</span>
<span class="sd">            the keys or some values, use the iterators `attributes_keys` and `attributes_items`, or the getters</span>
<span class="sd">            `get_attribute` and `get_attributes` instead.</span>

<span class="sd">        :return: the attributes as a dictionary</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_stored</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">backend_entity</span><span class="o">.</span><span class="n">attributes</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attrs_cache</span>

<div class="viewcode-block" id="Node.get_attribute"><a class="viewcode-back" href="../../../../developer_guide/core/orm_overview.html#aiida.orm.Node.get_attribute">[docs]</a>    <span class="k">def</span> <span class="nf">get_attribute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">_NO_DEFAULT</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an attribute.</span>

<span class="sd">        :param key: name of the attribute</span>
<span class="sd">        :param default: return this value instead of raising if the extra does not exist</span>
<span class="sd">        :return: the value of the attribute</span>
<span class="sd">        :raises AttributeError: if the attribute does not exist</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_stored</span><span class="p">:</span>
                <span class="n">attribute</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">backend_entity</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">attribute</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attrs_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">KeyError</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">default</span> <span class="ow">is</span> <span class="n">_NO_DEFAULT</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;attribute </span><span class="si">{}</span><span class="s1"> does not exist&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>
            <span class="n">attribute</span> <span class="o">=</span> <span class="n">default</span>

        <span class="k">return</span> <span class="n">attribute</span></div>

<div class="viewcode-block" id="Node.get_attributes"><a class="viewcode-back" href="../../../../developer_guide/core/orm_overview.html#aiida.orm.Node.get_attributes">[docs]</a>    <span class="k">def</span> <span class="nf">get_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a set of attributes.</span>

<span class="sd">        :param keys: names of the attributes</span>
<span class="sd">        :return: the values of the attributes</span>
<span class="sd">        :raises AttributeError: if at least one attribute does not exist</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">backend_entity</span><span class="o">.</span><span class="n">get_attributes</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span></div>

<div class="viewcode-block" id="Node.set_attribute"><a class="viewcode-back" href="../../../../developer_guide/core/orm_overview.html#aiida.orm.Node.set_attribute">[docs]</a>    <span class="k">def</span> <span class="nf">set_attribute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">clean</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">stored_check</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set an attribute to the given value.</span>

<span class="sd">        Setting attributes on a stored node is forbidden unless `stored_check` is set to False.</span>

<span class="sd">        :param key: name of the attribute</span>
<span class="sd">        :param value: value of the attribute</span>
<span class="sd">        :param clean: boolean, when True will clean the value before passing it to the backend</span>
<span class="sd">        :param stored_check: boolean, if True skips the check whether the node is stored</span>
<span class="sd">        :raise aiida.common.ModificationNotAllowed: if the node is stored and `stored_check=False`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">stored_check</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_stored</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">ModificationNotAllowed</span><span class="p">(</span><span class="s1">&#39;cannot set an attribute on a stored node&#39;</span><span class="p">)</span>

        <span class="n">validate_attribute_key</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">clean</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">clean_value</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_stored</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">backend_entity</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_attrs_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span></div>

<div class="viewcode-block" id="Node.set_attributes"><a class="viewcode-back" href="../../../../developer_guide/core/orm_overview.html#aiida.orm.Node.set_attributes">[docs]</a>    <span class="k">def</span> <span class="nf">set_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attributes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set attributes.</span>

<span class="sd">        .. note:: This will override any existing attributes that are present in the new dictionary.</span>

<span class="sd">        :param attributes: the new attributes to set</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_stored</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">ModificationNotAllowed</span><span class="p">(</span><span class="s1">&#39;cannot set attributes of a stored node&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">attributes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_attrs_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">clean_value</span><span class="p">(</span><span class="n">value</span><span class="p">)</span></div>

<div class="viewcode-block" id="Node.reset_attributes"><a class="viewcode-back" href="../../../../developer_guide/core/orm_overview.html#aiida.orm.Node.reset_attributes">[docs]</a>    <span class="k">def</span> <span class="nf">reset_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attributes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reset the attributes.</span>

<span class="sd">        .. note:: This will completely reset any existing attributes and replace them with the new dictionary.</span>

<span class="sd">        :param attributes: the new attributes to set</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_stored</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">ModificationNotAllowed</span><span class="p">(</span><span class="s1">&#39;cannot reset the attributes of a stored node&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">clear_attributes</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_attributes</span><span class="p">(</span><span class="n">attributes</span><span class="p">)</span></div>

<div class="viewcode-block" id="Node.delete_attribute"><a class="viewcode-back" href="../../../../developer_guide/core/orm_overview.html#aiida.orm.Node.delete_attribute">[docs]</a>    <span class="k">def</span> <span class="nf">delete_attribute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">stored_check</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Delete an attribute.</span>

<span class="sd">        Deleting attributes on a stored node is forbidden unless `stored_check` is set to False.</span>

<span class="sd">        :param key: name of the attribute</span>
<span class="sd">        :param stored_check: boolean, if True skips the check whether the node is stored</span>
<span class="sd">        :raises AttributeError: if the attribute does not exist</span>
<span class="sd">        :raise aiida.common.ModificationNotAllowed: if the node is stored and `stored_check=False`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">stored_check</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_stored</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">ModificationNotAllowed</span><span class="p">(</span><span class="s1">&#39;cannot delete an attribute on a stored node&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_stored</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">backend_entity</span><span class="o">.</span><span class="n">delete_attribute</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attrs_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;attribute </span><span class="si">{}</span><span class="s1"> does not exist&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">))</span></div>

<div class="viewcode-block" id="Node.delete_attributes"><a class="viewcode-back" href="../../../../developer_guide/core/orm_overview.html#aiida.orm.Node.delete_attributes">[docs]</a>    <span class="k">def</span> <span class="nf">delete_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Delete multiple attributes.</span>

<span class="sd">        :param keys: names of the attributes to delete</span>
<span class="sd">        :raises AttributeError: if at least on of the attribute does not exist</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_stored</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">ModificationNotAllowed</span><span class="p">(</span><span class="s1">&#39;cannot delete attributes of a stored node&#39;</span><span class="p">)</span>

        <span class="n">attributes_backup</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_attrs_cache</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_attrs_cache</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_attrs_cache</span> <span class="o">=</span> <span class="n">attributes_backup</span>
                <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;attribute </span><span class="si">{}</span><span class="s1"> does not exist&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">))</span></div>

<div class="viewcode-block" id="Node.clear_attributes"><a class="viewcode-back" href="../../../../developer_guide/core/orm_overview.html#aiida.orm.Node.clear_attributes">[docs]</a>    <span class="k">def</span> <span class="nf">clear_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Delete all attributes.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_stored</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">ModificationNotAllowed</span><span class="p">(</span><span class="s1">&#39;cannot clear the attributes of a stored node&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_attrs_cache</span> <span class="o">=</span> <span class="p">{}</span></div>

<div class="viewcode-block" id="Node.attributes_items"><a class="viewcode-back" href="../../../../developer_guide/core/orm_overview.html#aiida.orm.Node.attributes_items">[docs]</a>    <span class="k">def</span> <span class="nf">attributes_items</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an iterator over the attribute items.</span>

<span class="sd">        :return: an iterator with attribute key value pairs</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_stored</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">backend_entity</span><span class="o">.</span><span class="n">attributes_items</span><span class="p">():</span>
                <span class="k">yield</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attrs_cache</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">yield</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span></div>

<div class="viewcode-block" id="Node.attributes_keys"><a class="viewcode-back" href="../../../../developer_guide/core/orm_overview.html#aiida.orm.Node.attributes_keys">[docs]</a>    <span class="k">def</span> <span class="nf">attributes_keys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an iterator over the attribute keys.</span>

<span class="sd">        :return: an iterator with attribute keys</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_stored</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">backend_entity</span><span class="o">.</span><span class="n">attributes_keys</span><span class="p">():</span>
                <span class="k">yield</span> <span class="n">key</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attrs_cache</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">yield</span> <span class="n">key</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">extras</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the extras dictionary.</span>

<span class="sd">        .. note:: This will fetch all the extras from the database which can be a heavy operation. If you only need</span>
<span class="sd">            the keys or some values, use the iterators `extras_keys` and `extras_items`, or the getters `get_extra`</span>
<span class="sd">            and `get_extras` instead.</span>

<span class="sd">        :return: the extras as a dictionary</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">backend_entity</span><span class="o">.</span><span class="n">extras</span>

<div class="viewcode-block" id="Node.get_extra"><a class="viewcode-back" href="../../../../developer_guide/core/orm_overview.html#aiida.orm.Node.get_extra">[docs]</a>    <span class="k">def</span> <span class="nf">get_extra</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">_NO_DEFAULT</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an extra.</span>

<span class="sd">        :param key: name of the extra</span>
<span class="sd">        :param default: return this value instead of raising if the extra does not exist</span>
<span class="sd">        :return: the value of the extra</span>
<span class="sd">        :raises AttributeError: if the extra does not exist</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">backend_entity</span><span class="o">.</span><span class="n">get_extra</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">default</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_NO_DEFAULT</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">default</span>
            <span class="k">raise</span></div>

<div class="viewcode-block" id="Node.get_extras"><a class="viewcode-back" href="../../../../developer_guide/core/orm_overview.html#aiida.orm.Node.get_extras">[docs]</a>    <span class="k">def</span> <span class="nf">get_extras</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a set of extras.</span>

<span class="sd">        :param keys: names of the extras</span>
<span class="sd">        :return: the values of the extras</span>
<span class="sd">        :raises AttributeError: if at least one extra does not exist</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">backend_entity</span><span class="o">.</span><span class="n">get_extras</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span></div>

<div class="viewcode-block" id="Node.set_extra"><a class="viewcode-back" href="../../../../developer_guide/core/orm_overview.html#aiida.orm.Node.set_extra">[docs]</a>    <span class="k">def</span> <span class="nf">set_extra</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set an extra to the given value.</span>

<span class="sd">        Setting extras on unstored nodes is forbidden.</span>

<span class="sd">        :param key: name of the extra</span>
<span class="sd">        :param value: value of the extra</span>
<span class="sd">        :raise aiida.common.ModificationNotAllowed: if the node is not stored</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_stored</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">ModificationNotAllowed</span><span class="p">(</span><span class="s1">&#39;cannot set extras on unstored nodes&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">backend_entity</span><span class="o">.</span><span class="n">set_extra</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">clean_value</span><span class="p">(</span><span class="n">value</span><span class="p">))</span></div>

<div class="viewcode-block" id="Node.set_extras"><a class="viewcode-back" href="../../../../developer_guide/core/orm_overview.html#aiida.orm.Node.set_extras">[docs]</a>    <span class="k">def</span> <span class="nf">set_extras</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">extras</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set extras.</span>

<span class="sd">        .. note:: This will override any existing extras that are present in the new dictionary.</span>

<span class="sd">        :param extras: the new extras to set</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_stored</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">ModificationNotAllowed</span><span class="p">(</span><span class="s1">&#39;cannot set extras on unstored nodes&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">backend_entity</span><span class="o">.</span><span class="n">set_extras</span><span class="p">(</span><span class="n">clean_value</span><span class="p">(</span><span class="n">extras</span><span class="p">))</span></div>

<div class="viewcode-block" id="Node.reset_extras"><a class="viewcode-back" href="../../../../developer_guide/core/orm_overview.html#aiida.orm.Node.reset_extras">[docs]</a>    <span class="k">def</span> <span class="nf">reset_extras</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">extras</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reset the extras.</span>

<span class="sd">        .. note:: This will completely reset any existing extras and replace them with the new dictionary.</span>

<span class="sd">        :param extras: the new extras to set</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_stored</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">ModificationNotAllowed</span><span class="p">(</span><span class="s1">&#39;cannot set extras on unstored nodes&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">extras</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;extras has to be a dictionary&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">backend_entity</span><span class="o">.</span><span class="n">reset_extras</span><span class="p">(</span><span class="n">clean_value</span><span class="p">(</span><span class="n">extras</span><span class="p">))</span></div>

<div class="viewcode-block" id="Node.delete_extra"><a class="viewcode-back" href="../../../../developer_guide/core/orm_overview.html#aiida.orm.Node.delete_extra">[docs]</a>    <span class="k">def</span> <span class="nf">delete_extra</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Delete an extra.</span>

<span class="sd">        Deleting extras on unstored nodes is forbidden.</span>

<span class="sd">        :param key: name of the extra</span>
<span class="sd">        :raises AttributeError: if the extra does not exist</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_stored</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">ModificationNotAllowed</span><span class="p">(</span><span class="s1">&#39;cannot delete extras on unstored nodes&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">backend_entity</span><span class="o">.</span><span class="n">delete_extra</span><span class="p">(</span><span class="n">key</span><span class="p">)</span></div>

<div class="viewcode-block" id="Node.delete_extras"><a class="viewcode-back" href="../../../../developer_guide/core/orm_overview.html#aiida.orm.Node.delete_extras">[docs]</a>    <span class="k">def</span> <span class="nf">delete_extras</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Delete multiple extras.</span>

<span class="sd">        :param keys: names of the extras to delete</span>
<span class="sd">        :raises AttributeError: if at least on of the extra does not exist</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_stored</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">ModificationNotAllowed</span><span class="p">(</span><span class="s1">&#39;cannot delete extras on unstored nodes&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">backend_entity</span><span class="o">.</span><span class="n">delete_extras</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span></div>

<div class="viewcode-block" id="Node.clear_extras"><a class="viewcode-back" href="../../../../developer_guide/core/orm_overview.html#aiida.orm.Node.clear_extras">[docs]</a>    <span class="k">def</span> <span class="nf">clear_extras</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Delete all extras.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_stored</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">ModificationNotAllowed</span><span class="p">(</span><span class="s1">&#39;cannot clear the extras of unstored nodes&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">backend_entity</span><span class="o">.</span><span class="n">clear_extras</span><span class="p">()</span></div>

<div class="viewcode-block" id="Node.extras_items"><a class="viewcode-back" href="../../../../developer_guide/core/orm_overview.html#aiida.orm.Node.extras_items">[docs]</a>    <span class="k">def</span> <span class="nf">extras_items</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an iterator over the extra items.</span>

<span class="sd">        :return: an iterator with extra key value pairs</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">backend_entity</span><span class="o">.</span><span class="n">extras</span><span class="p">():</span>
            <span class="k">yield</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span></div>

<div class="viewcode-block" id="Node.extras_keys"><a class="viewcode-back" href="../../../../developer_guide/core/orm_overview.html#aiida.orm.Node.extras_keys">[docs]</a>    <span class="k">def</span> <span class="nf">extras_keys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an iterator over the attribute keys.</span>

<span class="sd">        :return: an iterator with attribute keys</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">backend_entity</span><span class="o">.</span><span class="n">extras</span><span class="p">():</span>
            <span class="k">yield</span> <span class="n">key</span></div>

<div class="viewcode-block" id="Node.append_to_attr"><a class="viewcode-back" href="../../../../developer_guide/core/orm_overview.html#aiida.orm.Node.append_to_attr">[docs]</a>    <span class="k">def</span> <span class="nf">append_to_attr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">clean</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Append value to an attribute of the Node (in the DbAttribute table).</span>

<span class="sd">        :param key: key name of &quot;list-type&quot; attribute</span>
<span class="sd">            If attribute doesn&#39;t exist, it is created.</span>
<span class="sd">        :param value: the value to append to the list</span>
<span class="sd">        :param clean: whether to clean the value</span>
<span class="sd">            WARNING: when set to False, storing will throw errors</span>
<span class="sd">            for any data types not recognized by the db backend</span>
<span class="sd">        :raise aiida.common.ValidationError: if the key is not valid, e.g. it contains the separator symbol</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_stored</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">ModificationNotAllowed</span><span class="p">(</span><span class="s1">&#39;can only call `append_to_attr` on unstored nodes&#39;</span><span class="p">)</span>

        <span class="n">validate_attribute_key</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_attrs_cache</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">list</span><span class="p">())</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">clean</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_attrs_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">clean_value</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_attrs_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;can only call `append_to_attr` for attributes that are lists&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Node.list_objects"><a class="viewcode-back" href="../../../../developer_guide/core/orm_overview.html#aiida.orm.Node.list_objects">[docs]</a>    <span class="k">def</span> <span class="nf">list_objects</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a list of the objects contained in this repository, optionally in the given sub directory.</span>

<span class="sd">        :param key: fully qualified identifier for the object within the repository</span>
<span class="sd">        :return: a list of `File` named tuples representing the objects present in directory with the given key</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_repository</span><span class="o">.</span><span class="n">list_objects</span><span class="p">(</span><span class="n">key</span><span class="p">)</span></div>

<div class="viewcode-block" id="Node.list_object_names"><a class="viewcode-back" href="../../../../developer_guide/core/orm_overview.html#aiida.orm.Node.list_object_names">[docs]</a>    <span class="k">def</span> <span class="nf">list_object_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a list of the object names contained in this repository, optionally in the given sub directory.</span>

<span class="sd">        :param key: fully qualified identifier for the object within the repository</span>
<span class="sd">        :return: a list of `File` named tuples representing the objects present in directory with the given key</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_repository</span><span class="o">.</span><span class="n">list_object_names</span><span class="p">(</span><span class="n">key</span><span class="p">)</span></div>

<div class="viewcode-block" id="Node.open"><a class="viewcode-back" href="../../../../developer_guide/core/orm_overview.html#aiida.orm.Node.open">[docs]</a>    <span class="k">def</span> <span class="nf">open</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Open a file handle to an object stored under the given key.</span>

<span class="sd">        :param key: fully qualified identifier for the object within the repository</span>
<span class="sd">        :param mode: the mode under which to open the handle</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_repository</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span></div>

<div class="viewcode-block" id="Node.get_object"><a class="viewcode-back" href="../../../../developer_guide/core/orm_overview.html#aiida.orm.Node.get_object">[docs]</a>    <span class="k">def</span> <span class="nf">get_object</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the object identified by key.</span>

<span class="sd">        :param key: fully qualified identifier for the object within the repository</span>
<span class="sd">        :return: a `File` named tuple representing the object located at key</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_repository</span><span class="o">.</span><span class="n">get_object</span><span class="p">(</span><span class="n">key</span><span class="p">)</span></div>

<div class="viewcode-block" id="Node.get_object_content"><a class="viewcode-back" href="../../../../developer_guide/core/orm_overview.html#aiida.orm.Node.get_object_content">[docs]</a>    <span class="k">def</span> <span class="nf">get_object_content</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the content of a object identified by key.</span>

<span class="sd">        :param key: fully qualified identifier for the object within the repository</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_repository</span><span class="o">.</span><span class="n">get_object_content</span><span class="p">(</span><span class="n">key</span><span class="p">)</span></div>

<div class="viewcode-block" id="Node.put_object_from_tree"><a class="viewcode-back" href="../../../../developer_guide/core/orm_overview.html#aiida.orm.Node.put_object_from_tree">[docs]</a>    <span class="k">def</span> <span class="nf">put_object_from_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">contents_only</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Store a new object under `key` with the contents of the directory located at `path` on this file system.</span>

<span class="sd">        .. warning:: If the repository belongs to a stored node, a `ModificationNotAllowed` exception will be raised.</span>
<span class="sd">            This check can be avoided by using the `force` flag, but this should be used with extreme caution!</span>

<span class="sd">        :param path: absolute path of directory whose contents to copy to the repository</span>
<span class="sd">        :param key: fully qualified identifier for the object within the repository</span>
<span class="sd">        :param contents_only: boolean, if True, omit the top level directory of the path and only copy its contents.</span>
<span class="sd">        :param force: boolean, if True, will skip the mutability check</span>
<span class="sd">        :raises aiida.common.ModificationNotAllowed: if repository is immutable and `force=False`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_repository</span><span class="o">.</span><span class="n">put_object_from_tree</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">contents_only</span><span class="p">,</span> <span class="n">force</span><span class="p">)</span></div>

<div class="viewcode-block" id="Node.put_object_from_file"><a class="viewcode-back" href="../../../../developer_guide/core/orm_overview.html#aiida.orm.Node.put_object_from_file">[docs]</a>    <span class="k">def</span> <span class="nf">put_object_from_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;utf8&#39;</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Store a new object under `key` with contents of the file located at `path` on this file system.</span>

<span class="sd">        .. warning:: If the repository belongs to a stored node, a `ModificationNotAllowed` exception will be raised.</span>
<span class="sd">            This check can be avoided by using the `force` flag, but this should be used with extreme caution!</span>

<span class="sd">        :param path: absolute path of file whose contents to copy to the repository</span>
<span class="sd">        :param key: fully qualified identifier for the object within the repository</span>
<span class="sd">        :param mode: the file mode with which the object will be written</span>
<span class="sd">        :param encoding: the file encoding with which the object will be written</span>
<span class="sd">        :param force: boolean, if True, will skip the mutability check</span>
<span class="sd">        :raises aiida.common.ModificationNotAllowed: if repository is immutable and `force=False`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_repository</span><span class="o">.</span><span class="n">put_object_from_file</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">encoding</span><span class="p">,</span> <span class="n">force</span><span class="p">)</span></div>

<div class="viewcode-block" id="Node.put_object_from_filelike"><a class="viewcode-back" href="../../../../developer_guide/core/orm_overview.html#aiida.orm.Node.put_object_from_filelike">[docs]</a>    <span class="k">def</span> <span class="nf">put_object_from_filelike</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">handle</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;utf8&#39;</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Store a new object under `key` with contents of filelike object `handle`.</span>

<span class="sd">        .. warning:: If the repository belongs to a stored node, a `ModificationNotAllowed` exception will be raised.</span>
<span class="sd">            This check can be avoided by using the `force` flag, but this should be used with extreme caution!</span>

<span class="sd">        :param handle: filelike object with the content to be stored</span>
<span class="sd">        :param key: fully qualified identifier for the object within the repository</span>
<span class="sd">        :param mode: the file mode with which the object will be written</span>
<span class="sd">        :param encoding: the file encoding with which the object will be written</span>
<span class="sd">        :param force: boolean, if True, will skip the mutability check</span>
<span class="sd">        :raises aiida.common.ModificationNotAllowed: if repository is immutable and `force=False`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_repository</span><span class="o">.</span><span class="n">put_object_from_filelike</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">encoding</span><span class="p">,</span> <span class="n">force</span><span class="p">)</span></div>

<div class="viewcode-block" id="Node.delete_object"><a class="viewcode-back" href="../../../../developer_guide/core/orm_overview.html#aiida.orm.Node.delete_object">[docs]</a>    <span class="k">def</span> <span class="nf">delete_object</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Delete the object from the repository.</span>

<span class="sd">        .. warning:: If the repository belongs to a stored node, a `ModificationNotAllowed` exception will be raised.</span>
<span class="sd">            This check can be avoided by using the `force` flag, but this should be used with extreme caution!</span>

<span class="sd">        :param key: fully qualified identifier for the object within the repository</span>
<span class="sd">        :param force: boolean, if True, will skip the mutability check</span>
<span class="sd">        :raises aiida.common.ModificationNotAllowed: if repository is immutable and `force=False`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_repository</span><span class="o">.</span><span class="n">delete_object</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">force</span><span class="p">)</span></div>

<div class="viewcode-block" id="Node.add_comment"><a class="viewcode-back" href="../../../../developer_guide/core/orm_overview.html#aiida.orm.Node.add_comment">[docs]</a>    <span class="k">def</span> <span class="nf">add_comment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">content</span><span class="p">,</span> <span class="n">user</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a new comment.</span>

<span class="sd">        :param content: string with comment</span>
<span class="sd">        :param user: the user to associate with the comment, will use default if not supplied</span>
<span class="sd">        :return: the newly created comment</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">user</span> <span class="o">=</span> <span class="n">user</span> <span class="ow">or</span> <span class="n">User</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get_default</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">Comment</span><span class="p">(</span><span class="n">node</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">user</span><span class="o">=</span><span class="n">user</span><span class="p">,</span> <span class="n">content</span><span class="o">=</span><span class="n">content</span><span class="p">)</span><span class="o">.</span><span class="n">store</span><span class="p">()</span></div>

<div class="viewcode-block" id="Node.get_comment"><a class="viewcode-back" href="../../../../developer_guide/core/orm_overview.html#aiida.orm.Node.get_comment">[docs]</a>    <span class="k">def</span> <span class="nf">get_comment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">identifier</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a comment corresponding to the given identifier.</span>

<span class="sd">        :param identifier: the comment pk</span>
<span class="sd">        :raise aiida.common.NotExistent: if the comment with the given id does not exist</span>
<span class="sd">        :raise aiida.common.MultipleObjectsError: if the id cannot be uniquely resolved to a comment</span>
<span class="sd">        :return: the comment</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Comment</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">dbnode_id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pk</span><span class="p">,</span> <span class="n">pk</span><span class="o">=</span><span class="n">identifier</span><span class="p">)</span></div>

<div class="viewcode-block" id="Node.get_comments"><a class="viewcode-back" href="../../../../developer_guide/core/orm_overview.html#aiida.orm.Node.get_comments">[docs]</a>    <span class="k">def</span> <span class="nf">get_comments</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a sorted list of comments for this node.</span>

<span class="sd">        :return: the list of comments, sorted by pk</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Comment</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">filters</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dbnode_id&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">pk</span><span class="p">},</span> <span class="n">order_by</span><span class="o">=</span><span class="p">[{</span><span class="s1">&#39;id&#39;</span><span class="p">:</span> <span class="s1">&#39;asc&#39;</span><span class="p">}])</span></div>

<div class="viewcode-block" id="Node.update_comment"><a class="viewcode-back" href="../../../../developer_guide/core/orm_overview.html#aiida.orm.Node.update_comment">[docs]</a>    <span class="k">def</span> <span class="nf">update_comment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">identifier</span><span class="p">,</span> <span class="n">content</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Update the content of an existing comment.</span>

<span class="sd">        :param identifier: the comment pk</span>
<span class="sd">        :param content: the new comment content</span>
<span class="sd">        :raise aiida.common.NotExistent: if the comment with the given id does not exist</span>
<span class="sd">        :raise aiida.common.MultipleObjectsError: if the id cannot be uniquely resolved to a comment</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">comment</span> <span class="o">=</span> <span class="n">Comment</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">dbnode_id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pk</span><span class="p">,</span> <span class="n">pk</span><span class="o">=</span><span class="n">identifier</span><span class="p">)</span>
        <span class="n">comment</span><span class="o">.</span><span class="n">set_content</span><span class="p">(</span><span class="n">content</span><span class="p">)</span></div>

<div class="viewcode-block" id="Node.remove_comment"><a class="viewcode-back" href="../../../../developer_guide/core/orm_overview.html#aiida.orm.Node.remove_comment">[docs]</a>    <span class="k">def</span> <span class="nf">remove_comment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">identifier</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Delete an existing comment.</span>

<span class="sd">        :param identifier: the comment pk</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Comment</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">dbnode_id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pk</span><span class="p">,</span> <span class="n">comment</span><span class="o">=</span><span class="n">identifier</span><span class="p">)</span></div>

<div class="viewcode-block" id="Node.add_incoming"><a class="viewcode-back" href="../../../../developer_guide/core/orm_overview.html#aiida.orm.Node.add_incoming">[docs]</a>    <span class="k">def</span> <span class="nf">add_incoming</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">link_type</span><span class="p">,</span> <span class="n">link_label</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a link of the given type from a given node to ourself.</span>

<span class="sd">        :param source: the node from which the link is coming</span>
<span class="sd">        :param link_type: the link type</span>
<span class="sd">        :param link_label: the link label</span>
<span class="sd">        :raise TypeError: if `source` is not a Node instance or `link_type` is not a `LinkType` enum</span>
<span class="sd">        :raise ValueError: if the proposed link is invalid</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">validate_incoming</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">link_type</span><span class="p">,</span> <span class="n">link_label</span><span class="p">)</span>
        <span class="n">source</span><span class="o">.</span><span class="n">validate_outgoing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">link_type</span><span class="p">,</span> <span class="n">link_label</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_stored</span> <span class="ow">and</span> <span class="n">source</span><span class="o">.</span><span class="n">is_stored</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">backend_entity</span><span class="o">.</span><span class="n">add_incoming</span><span class="p">(</span><span class="n">source</span><span class="o">.</span><span class="n">backend_entity</span><span class="p">,</span> <span class="n">link_type</span><span class="p">,</span> <span class="n">link_label</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_add_incoming_cache</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">link_type</span><span class="p">,</span> <span class="n">link_label</span><span class="p">)</span></div>

<div class="viewcode-block" id="Node.validate_incoming"><a class="viewcode-back" href="../../../../developer_guide/core/orm_overview.html#aiida.orm.Node.validate_incoming">[docs]</a>    <span class="k">def</span> <span class="nf">validate_incoming</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">link_type</span><span class="p">,</span> <span class="n">link_label</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Validate adding a link of the given type from a given node to ourself.</span>

<span class="sd">        This function will first validate the types of the inputs, followed by the node and link types and validate</span>
<span class="sd">        whether in principle a link of that type between the nodes of these types is allowed.the</span>

<span class="sd">        Subsequently, the validity of the &quot;degree&quot; of the proposed link is validated, which means validating the</span>
<span class="sd">        number of links of the given type from the given node type is allowed.</span>

<span class="sd">        :param source: the node from which the link is coming</span>
<span class="sd">        :param link_type: the link type</span>
<span class="sd">        :param link_label: the link label</span>
<span class="sd">        :raise TypeError: if `source` is not a Node instance or `link_type` is not a `LinkType` enum</span>
<span class="sd">        :raise ValueError: if the proposed link is invalid</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">aiida.orm.utils.links</span> <span class="k">import</span> <span class="n">validate_link</span>

        <span class="n">validate_link</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">link_type</span><span class="p">,</span> <span class="n">link_label</span><span class="p">)</span>

        <span class="c1"># Check if the proposed link would introduce a cycle in the graph following ancestor/descendant rules</span>
        <span class="k">if</span> <span class="n">link_type</span> <span class="ow">in</span> <span class="p">[</span><span class="n">LinkType</span><span class="o">.</span><span class="n">CREATE</span><span class="p">,</span> <span class="n">LinkType</span><span class="o">.</span><span class="n">INPUT_CALC</span><span class="p">,</span> <span class="n">LinkType</span><span class="o">.</span><span class="n">INPUT_WORK</span><span class="p">]:</span>
            <span class="n">builder</span> <span class="o">=</span> <span class="n">QueryBuilder</span><span class="p">()</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">Node</span><span class="p">,</span> <span class="n">filters</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;id&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">pk</span><span class="p">},</span> <span class="n">tag</span><span class="o">=</span><span class="s1">&#39;parent&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">Node</span><span class="p">,</span> <span class="n">filters</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;id&#39;</span><span class="p">:</span> <span class="n">source</span><span class="o">.</span><span class="n">pk</span><span class="p">},</span> <span class="n">tag</span><span class="o">=</span><span class="s1">&#39;child&#39;</span><span class="p">,</span> <span class="n">with_ancestors</span><span class="o">=</span><span class="s1">&#39;parent&#39;</span><span class="p">)</span>  <span class="c1"># yapf:disable</span>
            <span class="k">if</span> <span class="n">builder</span><span class="o">.</span><span class="n">count</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;the link you are attempting to create would generate a cycle in the graph&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Node.validate_outgoing"><a class="viewcode-back" href="../../../../developer_guide/core/orm_overview.html#aiida.orm.Node.validate_outgoing">[docs]</a>    <span class="k">def</span> <span class="nf">validate_outgoing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">link_type</span><span class="p">,</span> <span class="n">link_label</span><span class="p">):</span>  <span class="c1"># pylint: disable=unused-argument,no-self-use</span>
        <span class="sd">&quot;&quot;&quot;Validate adding a link of the given type from ourself to a given node.</span>

<span class="sd">        The validity of the triple (source, link, target) should be validated in the `validate_incoming` call.</span>
<span class="sd">        This method will be called afterwards and can be overriden by subclasses to add additional checks that are</span>
<span class="sd">        specific to that subclass.</span>

<span class="sd">        :param target: the node to which the link is going</span>
<span class="sd">        :param link_type: the link type</span>
<span class="sd">        :param link_label: the link label</span>
<span class="sd">        :raise TypeError: if `target` is not a Node instance or `link_type` is not a `LinkType` enum</span>
<span class="sd">        :raise ValueError: if the proposed link is invalid</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">type_check</span><span class="p">(</span><span class="n">link_type</span><span class="p">,</span> <span class="n">LinkType</span><span class="p">,</span> <span class="s1">&#39;link_type should be a LinkType enum but got: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">link_type</span><span class="p">)))</span>
        <span class="n">type_check</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">Node</span><span class="p">,</span> <span class="s1">&#39;target should be a `Node` instance but got: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">target</span><span class="p">)))</span></div>

<div class="viewcode-block" id="Node._add_incoming_cache"><a class="viewcode-back" href="../../../../apidoc/aiida.orm.nodes.html#aiida.orm.Node._add_incoming_cache">[docs]</a>    <span class="k">def</span> <span class="nf">_add_incoming_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">link_type</span><span class="p">,</span> <span class="n">link_label</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add an incoming link to the cache.</span>

<span class="sd">        .. note: the proposed link is not validated in this function, so this should not be called directly</span>
<span class="sd">            but it should only be called by `Node.add_incoming`.</span>

<span class="sd">        :param source: the node from which the link is coming</span>
<span class="sd">        :param link_type: the link type</span>
<span class="sd">        :param link_label: the link label</span>
<span class="sd">        :raise aiida.common.UniquenessError: if the given link triple already exists in the cache</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">link_triple</span> <span class="o">=</span> <span class="n">LinkTriple</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">link_type</span><span class="p">,</span> <span class="n">link_label</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">link_triple</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_incoming_cache</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">UniquenessError</span><span class="p">(</span><span class="s1">&#39;the link triple </span><span class="si">{}</span><span class="s1"> is already present in the cache&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">link_triple</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_incoming_cache</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">link_triple</span><span class="p">)</span></div>

<div class="viewcode-block" id="Node.get_stored_link_triples"><a class="viewcode-back" href="../../../../developer_guide/core/orm_overview.html#aiida.orm.Node.get_stored_link_triples">[docs]</a>    <span class="k">def</span> <span class="nf">get_stored_link_triples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_class</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">link_type</span><span class="o">=</span><span class="p">(),</span> <span class="n">link_label_filter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">link_direction</span><span class="o">=</span><span class="s1">&#39;incoming&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the list of stored link triples directly incoming to or outgoing of this node.</span>

<span class="sd">        Note this will only return link triples that are stored in the database. Anything in the cache is ignored.</span>

<span class="sd">        :param node_class: If specified, should be a class, and it filters only elements of that (subclass of) type</span>
<span class="sd">        :param link_type: Only get inputs of this link type, if empty tuple then returns all inputs of all link types.</span>
<span class="sd">        :param link_label_filter: filters the incoming nodes by its link label. This should be a regex statement as</span>
<span class="sd">            one would pass directly to a QuerBuilder filter statement with the &#39;like&#39; operation.</span>
<span class="sd">        :param link_direction: `incoming` or `outgoing` to get the incoming or outgoing links, respectively.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">link_type</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">link_type</span> <span class="o">=</span> <span class="p">(</span><span class="n">link_type</span><span class="p">,)</span>

        <span class="k">if</span> <span class="n">link_type</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">LinkType</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">link_type</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;link_type should be a LinkType or tuple of LinkType: got </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">link_type</span><span class="p">))</span>

        <span class="n">node_class</span> <span class="o">=</span> <span class="n">node_class</span> <span class="ow">or</span> <span class="n">Node</span>
        <span class="n">node_filters</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;id&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;==&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">}}</span>
        <span class="n">edge_filters</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">if</span> <span class="n">link_type</span><span class="p">:</span>
            <span class="n">edge_filters</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">value</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">link_type</span><span class="p">]}</span>

        <span class="k">if</span> <span class="n">link_label_filter</span><span class="p">:</span>
            <span class="n">edge_filters</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;like&#39;</span><span class="p">:</span> <span class="n">link_label_filter</span><span class="p">}</span>

        <span class="n">builder</span> <span class="o">=</span> <span class="n">QueryBuilder</span><span class="p">()</span>
        <span class="n">builder</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Node</span><span class="p">,</span> <span class="n">filters</span><span class="o">=</span><span class="n">node_filters</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="s1">&#39;main&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">link_direction</span> <span class="o">==</span> <span class="s1">&#39;outgoing&#39;</span><span class="p">:</span>
            <span class="n">builder</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">node_class</span><span class="p">,</span>
                <span class="n">with_incoming</span><span class="o">=</span><span class="s1">&#39;main&#39;</span><span class="p">,</span>
                <span class="n">project</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;*&#39;</span><span class="p">],</span>
                <span class="n">edge_project</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">,</span> <span class="s1">&#39;label&#39;</span><span class="p">],</span>
                <span class="n">edge_filters</span><span class="o">=</span><span class="n">edge_filters</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">builder</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">node_class</span><span class="p">,</span>
                <span class="n">with_outgoing</span><span class="o">=</span><span class="s1">&#39;main&#39;</span><span class="p">,</span>
                <span class="n">project</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;*&#39;</span><span class="p">],</span>
                <span class="n">edge_project</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">,</span> <span class="s1">&#39;label&#39;</span><span class="p">],</span>
                <span class="n">edge_filters</span><span class="o">=</span><span class="n">edge_filters</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">LinkTriple</span><span class="p">(</span><span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">LinkType</span><span class="p">(</span><span class="n">entry</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">entry</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">builder</span><span class="o">.</span><span class="n">all</span><span class="p">()]</span></div>

<div class="viewcode-block" id="Node.get_incoming"><a class="viewcode-back" href="../../../../developer_guide/core/orm_overview.html#aiida.orm.Node.get_incoming">[docs]</a>    <span class="k">def</span> <span class="nf">get_incoming</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_class</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">link_type</span><span class="o">=</span><span class="p">(),</span> <span class="n">link_label_filter</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a list of link triples that are (directly) incoming into this node.</span>

<span class="sd">        :param node_class: If specified, should be a class or tuple of classes, and it filters only</span>
<span class="sd">            elements of that specific type (or a subclass of &#39;type&#39;)</span>
<span class="sd">        :param link_type: If specified should be a string or tuple to get the inputs of this</span>
<span class="sd">            link type, if None then returns all inputs of all link types.</span>
<span class="sd">        :param link_label_filter: filters the incoming nodes by its link label.</span>
<span class="sd">            Here wildcards (% and _) can be passed in link label filter as we are using &quot;like&quot; in QB.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">link_type</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">link_type</span> <span class="o">=</span> <span class="p">(</span><span class="n">link_type</span><span class="p">,)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_stored</span><span class="p">:</span>
            <span class="n">link_triples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_stored_link_triples</span><span class="p">(</span><span class="n">node_class</span><span class="p">,</span> <span class="n">link_type</span><span class="p">,</span> <span class="n">link_label_filter</span><span class="p">,</span> <span class="s1">&#39;incoming&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">link_triples</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Get all cached link triples</span>
        <span class="k">for</span> <span class="n">link_triple</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_incoming_cache</span><span class="p">:</span>

            <span class="k">if</span> <span class="n">link_triple</span> <span class="ow">in</span> <span class="n">link_triples</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">InternalError</span><span class="p">(</span><span class="s1">&#39;Node&lt;</span><span class="si">{}</span><span class="s1">&gt; has both a stored and cached link triple </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">pk</span><span class="p">,</span> <span class="n">link_triple</span><span class="p">))</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">link_type</span> <span class="ow">or</span> <span class="n">link_triple</span><span class="o">.</span><span class="n">link_type</span> <span class="ow">in</span> <span class="n">link_type</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">link_label_filter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">sql_string_match</span><span class="p">(</span><span class="n">string</span><span class="o">=</span><span class="n">link_triple</span><span class="o">.</span><span class="n">link_label</span><span class="p">,</span> <span class="n">pattern</span><span class="o">=</span><span class="n">link_label_filter</span><span class="p">):</span>
                        <span class="n">link_triples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">link_triple</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">link_triples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">link_triple</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">LinkManager</span><span class="p">(</span><span class="n">link_triples</span><span class="p">)</span></div>

<div class="viewcode-block" id="Node.get_outgoing"><a class="viewcode-back" href="../../../../developer_guide/core/orm_overview.html#aiida.orm.Node.get_outgoing">[docs]</a>    <span class="k">def</span> <span class="nf">get_outgoing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_class</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">link_type</span><span class="o">=</span><span class="p">(),</span> <span class="n">link_label_filter</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a list of link triples that are (directly) outgoing of this node.</span>

<span class="sd">        :param node_class: If specified, should be a class or tuple of classes, and it filters only</span>
<span class="sd">            elements of that specific type (or a subclass of &#39;type&#39;)</span>
<span class="sd">        :param link_type: If specified should be a string or tuple to get the inputs of this</span>
<span class="sd">            link type, if None then returns all outputs of all link types.</span>
<span class="sd">        :param link_label_filter: filters the outgoing nodes by its link label.</span>
<span class="sd">            Here wildcards (% and _) can be passed in link label filter as we are using &quot;like&quot; in QB.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">link_triples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_stored_link_triples</span><span class="p">(</span><span class="n">node_class</span><span class="p">,</span> <span class="n">link_type</span><span class="p">,</span> <span class="n">link_label_filter</span><span class="p">,</span> <span class="s1">&#39;outgoing&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">LinkManager</span><span class="p">(</span><span class="n">link_triples</span><span class="p">)</span></div>

<div class="viewcode-block" id="Node.has_cached_links"><a class="viewcode-back" href="../../../../developer_guide/core/orm_overview.html#aiida.orm.Node.has_cached_links">[docs]</a>    <span class="k">def</span> <span class="nf">has_cached_links</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Feturn whether there are unstored incoming links in the cache.</span>

<span class="sd">        :return: boolean, True when there are links in the incoming cache, False otherwise</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_incoming_cache</span><span class="p">)</span></div>

<div class="viewcode-block" id="Node.store_all"><a class="viewcode-back" href="../../../../developer_guide/core/orm_overview.html#aiida.orm.Node.store_all">[docs]</a>    <span class="k">def</span> <span class="nf">store_all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">with_transaction</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">use_cache</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Store the node, together with all input links.</span>

<span class="sd">        Unstored nodes from cached incoming linkswill also be stored.</span>

<span class="sd">        :parameter with_transaction: if False, do not use a transaction because the caller will already have opened one.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_stored</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">ModificationNotAllowed</span><span class="p">(</span><span class="s1">&#39;Node&lt;</span><span class="si">{}</span><span class="s1">&gt; is already stored&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">))</span>

        <span class="c1"># For each node of a cached incoming link, check that all its incoming links are stored</span>
        <span class="k">for</span> <span class="n">link_triple</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_incoming_cache</span><span class="p">:</span>
            <span class="n">link_triple</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">verify_are_parents_stored</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">link_triple</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_incoming_cache</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">link_triple</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">is_stored</span><span class="p">:</span>
                <span class="n">link_triple</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">store</span><span class="p">(</span><span class="n">with_transaction</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">use_cache</span><span class="o">=</span><span class="n">use_cache</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">store</span><span class="p">(</span><span class="n">with_transaction</span><span class="p">,</span> <span class="n">use_cache</span><span class="o">=</span><span class="n">use_cache</span><span class="p">)</span></div>

<div class="viewcode-block" id="Node.store"><a class="viewcode-back" href="../../../../developer_guide/core/orm_overview.html#aiida.orm.Node.store">[docs]</a>    <span class="k">def</span> <span class="nf">store</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">with_transaction</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">use_cache</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Store the node in the database while saving its attributes and repository directory.</span>

<span class="sd">        After being called attributes cannot be changed anymore! Instead, extras can be changed only AFTER calling</span>
<span class="sd">        this store() function.</span>

<span class="sd">        :note: After successful storage, those links that are in the cache, and for which also the parent node is</span>
<span class="sd">            already stored, will be automatically stored. The others will remain unstored.</span>

<span class="sd">        :parameter with_transaction: if False, do not use a transaction because the caller will already have opened one.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># pylint: disable=arguments-differ</span>
        <span class="kn">from</span> <span class="nn">aiida.manage.caching</span> <span class="k">import</span> <span class="n">get_use_cache</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_storable</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">StoringNotAllowed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_unstorable_message</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_stored</span><span class="p">:</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_validate</span><span class="p">()</span>

            <span class="c1"># Verify that parents are already stored. Raises if this is not the case.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">verify_are_parents_stored</span><span class="p">()</span>

            <span class="c1"># Get default for use_cache if it&#39;s not set explicitly.</span>
            <span class="k">if</span> <span class="n">use_cache</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">use_cache</span> <span class="o">=</span> <span class="n">get_use_cache</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

            <span class="c1"># Retrieve the cached node.</span>
            <span class="n">same_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_same_node</span><span class="p">()</span> <span class="k">if</span> <span class="n">use_cache</span> <span class="k">else</span> <span class="kc">None</span>

            <span class="k">if</span> <span class="n">same_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_store_from_cache</span><span class="p">(</span><span class="n">same_node</span><span class="p">,</span> <span class="n">with_transaction</span><span class="o">=</span><span class="n">with_transaction</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_store</span><span class="p">(</span><span class="n">with_transaction</span><span class="o">=</span><span class="n">with_transaction</span><span class="p">)</span>

            <span class="c1"># Set up autogrouping used by verdi run</span>
            <span class="kn">from</span> <span class="nn">aiida.orm.autogroup</span> <span class="k">import</span> <span class="n">current_autogroup</span><span class="p">,</span> <span class="n">Autogroup</span><span class="p">,</span> <span class="n">VERDIAUTOGROUP_TYPE</span>
            <span class="kn">from</span> <span class="nn">aiida.orm</span> <span class="k">import</span> <span class="n">Group</span>

            <span class="k">if</span> <span class="n">current_autogroup</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">current_autogroup</span><span class="p">,</span> <span class="n">Autogroup</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">ValidationError</span><span class="p">(</span><span class="s1">&#39;`current_autogroup` is not of type `Autogroup`&#39;</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">current_autogroup</span><span class="o">.</span><span class="n">is_to_be_grouped</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                    <span class="n">group_label</span> <span class="o">=</span> <span class="n">current_autogroup</span><span class="o">.</span><span class="n">get_group_name</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">group_label</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">group</span> <span class="o">=</span> <span class="n">Group</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get_or_create</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="n">group_label</span><span class="p">,</span> <span class="n">type_string</span><span class="o">=</span><span class="n">VERDIAUTOGROUP_TYPE</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">group</span><span class="o">.</span><span class="n">add_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Node._store"><a class="viewcode-back" href="../../../../apidoc/aiida.orm.nodes.html#aiida.orm.Node._store">[docs]</a>    <span class="k">def</span> <span class="nf">_store</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">with_transaction</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Store the node in the database while saving its attributes and repository directory.</span>

<span class="sd">        :parameter with_transaction: if False, do not use a transaction because the caller will already have opened one.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># First store the repository folder such that if this fails, there won&#39;t be an incomplete node in the database.</span>
        <span class="c1"># On the flipside, in the case that storing the node does fail, the repository will now have an orphaned node</span>
        <span class="c1"># directory which will have to be cleaned manually sometime.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_repository</span><span class="o">.</span><span class="n">store</span><span class="p">()</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">attributes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attrs_cache</span>
            <span class="n">links</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_incoming_cache</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_backend_entity</span><span class="o">.</span><span class="n">store</span><span class="p">(</span><span class="n">attributes</span><span class="p">,</span> <span class="n">links</span><span class="p">,</span> <span class="n">with_transaction</span><span class="o">=</span><span class="n">with_transaction</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="c1"># I put back the files in the sandbox folder since the transaction did not succeed</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_repository</span><span class="o">.</span><span class="n">restore</span><span class="p">()</span>
            <span class="k">raise</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_attrs_cache</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_incoming_cache</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_backend_entity</span><span class="o">.</span><span class="n">set_extra</span><span class="p">(</span><span class="n">_HASH_EXTRA_KEY</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_hash</span><span class="p">(),</span> <span class="n">increase_version</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Node.verify_are_parents_stored"><a class="viewcode-back" href="../../../../developer_guide/core/orm_overview.html#aiida.orm.Node.verify_are_parents_stored">[docs]</a>    <span class="k">def</span> <span class="nf">verify_are_parents_stored</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Verify that all `parent` nodes are already stored.</span>

<span class="sd">        :raise aiida.common.ModificationNotAllowed: if one of the source nodes of incoming links is not stored.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">link_triple</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_incoming_cache</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">link_triple</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">is_stored</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">ModificationNotAllowed</span><span class="p">(</span>
                    <span class="s1">&#39;Cannot store because source node of link triple </span><span class="si">{}</span><span class="s1"> is not stored&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">link_triple</span><span class="p">))</span></div>

<div class="viewcode-block" id="Node._store_from_cache"><a class="viewcode-back" href="../../../../apidoc/aiida.orm.nodes.html#aiida.orm.Node._store_from_cache">[docs]</a>    <span class="k">def</span> <span class="nf">_store_from_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cache_node</span><span class="p">,</span> <span class="n">with_transaction</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Store this node from an existing cache node.&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">aiida.orm.utils.mixins</span> <span class="k">import</span> <span class="n">Sealable</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_type</span> <span class="o">==</span> <span class="n">cache_node</span><span class="o">.</span><span class="n">node_type</span>

        <span class="c1"># Make sure the node doesn&#39;t have any RETURN links</span>
        <span class="k">if</span> <span class="n">cache_node</span><span class="o">.</span><span class="n">get_outgoing</span><span class="p">(</span><span class="n">link_type</span><span class="o">=</span><span class="n">LinkType</span><span class="o">.</span><span class="n">RETURN</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot use cache from nodes with RETURN links.&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">cache_node</span><span class="o">.</span><span class="n">label</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">description</span> <span class="o">=</span> <span class="n">cache_node</span><span class="o">.</span><span class="n">description</span>

        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">cache_node</span><span class="o">.</span><span class="n">attributes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">!=</span> <span class="n">Sealable</span><span class="o">.</span><span class="n">SEALED_KEY</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">put_object_from_tree</span><span class="p">(</span><span class="n">cache_node</span><span class="o">.</span><span class="n">_repository</span><span class="o">.</span><span class="n">_get_base_folder</span><span class="p">()</span><span class="o">.</span><span class="n">abspath</span><span class="p">)</span>  <span class="c1"># pylint: disable=protected-access</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_store</span><span class="p">(</span><span class="n">with_transaction</span><span class="o">=</span><span class="n">with_transaction</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_add_outputs_from_cache</span><span class="p">(</span><span class="n">cache_node</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_extra</span><span class="p">(</span><span class="s1">&#39;_aiida_cached_from&#39;</span><span class="p">,</span> <span class="n">cache_node</span><span class="o">.</span><span class="n">uuid</span><span class="p">)</span></div>

<div class="viewcode-block" id="Node._add_outputs_from_cache"><a class="viewcode-back" href="../../../../apidoc/aiida.orm.nodes.html#aiida.orm.Node._add_outputs_from_cache">[docs]</a>    <span class="k">def</span> <span class="nf">_add_outputs_from_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cache_node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Replicate the output links and nodes from the cached node onto this node.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">cache_node</span><span class="o">.</span><span class="n">get_outgoing</span><span class="p">(</span><span class="n">link_type</span><span class="o">=</span><span class="n">LinkType</span><span class="o">.</span><span class="n">CREATE</span><span class="p">):</span>
            <span class="n">new_node</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
            <span class="n">new_node</span><span class="o">.</span><span class="n">add_incoming</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">link_type</span><span class="o">=</span><span class="n">LinkType</span><span class="o">.</span><span class="n">CREATE</span><span class="p">,</span> <span class="n">link_label</span><span class="o">=</span><span class="n">entry</span><span class="o">.</span><span class="n">link_label</span><span class="p">)</span>
            <span class="n">new_node</span><span class="o">.</span><span class="n">store</span><span class="p">()</span></div>

<div class="viewcode-block" id="Node.get_hash"><a class="viewcode-back" href="../../../../developer_guide/core/orm_overview.html#aiida.orm.Node.get_hash">[docs]</a>    <span class="k">def</span> <span class="nf">get_hash</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ignore_errors</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the hash for this node based on its attributes.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">make_hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_objects_to_hash</span><span class="p">(),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>  <span class="c1"># pylint: disable=broad-except</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">ignore_errors</span><span class="p">:</span>
                <span class="k">raise</span></div>

<div class="viewcode-block" id="Node._get_objects_to_hash"><a class="viewcode-back" href="../../../../apidoc/aiida.orm.nodes.html#aiida.orm.Node._get_objects_to_hash">[docs]</a>    <span class="k">def</span> <span class="nf">_get_objects_to_hash</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a list of objects which should be included in the hash.&quot;&quot;&quot;</span>
        <span class="n">objects</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">importlib</span><span class="o">.</span><span class="n">import_module</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__module__</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">__version__</span><span class="p">,</span>
            <span class="p">{</span>
                <span class="n">key</span><span class="p">:</span> <span class="n">val</span>
                <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">attributes_items</span><span class="p">()</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hash_ignored_attributes</span> <span class="ow">and</span>
                    <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_updatable_attributes&#39;</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">()))</span>
            <span class="p">},</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_repository</span><span class="o">.</span><span class="n">_get_base_folder</span><span class="p">(),</span>  <span class="c1"># pylint: disable=protected-access</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">computer</span><span class="o">.</span><span class="n">uuid</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">computer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="n">objects</span></div>

<div class="viewcode-block" id="Node.rehash"><a class="viewcode-back" href="../../../../developer_guide/core/orm_overview.html#aiida.orm.Node.rehash">[docs]</a>    <span class="k">def</span> <span class="nf">rehash</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Regenerate the stored hash of the Node.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_extra</span><span class="p">(</span><span class="n">_HASH_EXTRA_KEY</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_hash</span><span class="p">())</span></div>

<div class="viewcode-block" id="Node.clear_hash"><a class="viewcode-back" href="../../../../developer_guide/core/orm_overview.html#aiida.orm.Node.clear_hash">[docs]</a>    <span class="k">def</span> <span class="nf">clear_hash</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets the stored hash of the Node to None.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_extra</span><span class="p">(</span><span class="n">_HASH_EXTRA_KEY</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span></div>

<div class="viewcode-block" id="Node.get_cache_source"><a class="viewcode-back" href="../../../../developer_guide/core/orm_overview.html#aiida.orm.Node.get_cache_source">[docs]</a>    <span class="k">def</span> <span class="nf">get_cache_source</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the UUID of the node that was used in creating this node from the cache, or None if it was not cached.</span>

<span class="sd">        :return: source node UUID or None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_extra</span><span class="p">(</span><span class="s1">&#39;_aiida_cached_from&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_created_from_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return whether this node was created from a cached node.</span>

<span class="sd">        :return: boolean, True if the node was created by cloning a cached node, False otherwise</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cache_source</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

<div class="viewcode-block" id="Node._get_same_node"><a class="viewcode-back" href="../../../../apidoc/aiida.orm.nodes.html#aiida.orm.Node._get_same_node">[docs]</a>    <span class="k">def</span> <span class="nf">_get_same_node</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a stored node from which the current Node can be cached or None if it does not exist</span>

<span class="sd">        If a node is returned it is a valid cache, meaning its `_aiida_hash` extra matches `self.get_hash()`.</span>
<span class="sd">        If there are multiple valid matches, the first one is returned.</span>
<span class="sd">        If no matches are found, `None` is returned.</span>

<span class="sd">        :return: a stored `Node` instance with the same hash as this code or None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iter_all_same_nodes</span><span class="p">())</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Node.get_all_same_nodes"><a class="viewcode-back" href="../../../../developer_guide/core/orm_overview.html#aiida.orm.Node.get_all_same_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">get_all_same_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a list of stored nodes which match the type and hash of the current node.</span>

<span class="sd">        All returned nodes are valid caches, meaning their `_aiida_hash` extra matches `self.get_hash()`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iter_all_same_nodes</span><span class="p">())</span></div>

<div class="viewcode-block" id="Node._iter_all_same_nodes"><a class="viewcode-back" href="../../../../apidoc/aiida.orm.nodes.html#aiida.orm.Node._iter_all_same_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">_iter_all_same_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns an iterator of all same nodes.&quot;&quot;&quot;</span>
        <span class="n">node_hash</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_hash</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">node_hash</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cachable</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">iter</span><span class="p">(())</span>

        <span class="n">builder</span> <span class="o">=</span> <span class="n">QueryBuilder</span><span class="p">()</span>
        <span class="n">builder</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">filters</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;extras._aiida_hash&#39;</span><span class="p">:</span> <span class="n">node_hash</span><span class="p">},</span> <span class="n">project</span><span class="o">=</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="n">subclassing</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">nodes_identical</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">builder</span><span class="o">.</span><span class="n">iterall</span><span class="p">())</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes_identical</span> <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">is_valid_cache</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_valid_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Hook to exclude certain `Node` instances from being considered a valid cache.&quot;&quot;&quot;</span>
        <span class="c1"># pylint: disable=no-self-use</span>
        <span class="k">return</span> <span class="kc">True</span>

<div class="viewcode-block" id="Node.get_description"><a class="viewcode-back" href="../../../../developer_guide/core/orm_overview.html#aiida.orm.Node.get_description">[docs]</a>    <span class="k">def</span> <span class="nf">get_description</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a string with a description of the node.</span>

<span class="sd">        :return: a description string</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># pylint: disable=no-self-use</span>
        <span class="k">return</span> <span class="s1">&#39;&#39;</span></div>

<div class="viewcode-block" id="Node.get_schema"><a class="viewcode-back" href="../../../../developer_guide/core/orm_overview.html#aiida.orm.Node.get_schema">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_schema</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Every node property contains:</span>
<span class="sd">            - display_name: display name of the property</span>
<span class="sd">            - help text: short help text of the property</span>
<span class="sd">            - is_foreign_key: is the property foreign key to other type of the node</span>
<span class="sd">            - type: type of the property. e.g. str, dict, int</span>

<span class="sd">        :return: get schema of the node</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;attributes&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;display_name&quot;</span><span class="p">:</span> <span class="s2">&quot;Attributes&quot;</span><span class="p">,</span>
                <span class="s2">&quot;help_text&quot;</span><span class="p">:</span> <span class="s2">&quot;Attributes of the node&quot;</span><span class="p">,</span>
                <span class="s2">&quot;is_foreign_key&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
                <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;dict&quot;</span>
            <span class="p">},</span>
            <span class="s2">&quot;attributes.state&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;display_name&quot;</span><span class="p">:</span> <span class="s2">&quot;State&quot;</span><span class="p">,</span>
                <span class="s2">&quot;help_text&quot;</span><span class="p">:</span> <span class="s2">&quot;AiiDA state of the calculation&quot;</span><span class="p">,</span>
                <span class="s2">&quot;is_foreign_key&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
                <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;</span>
            <span class="p">},</span>
            <span class="s2">&quot;ctime&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;display_name&quot;</span><span class="p">:</span> <span class="s2">&quot;Creation time&quot;</span><span class="p">,</span>
                <span class="s2">&quot;help_text&quot;</span><span class="p">:</span> <span class="s2">&quot;Creation time of the node&quot;</span><span class="p">,</span>
                <span class="s2">&quot;is_foreign_key&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
                <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;datetime.datetime&quot;</span>
            <span class="p">},</span>
            <span class="s2">&quot;extras&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;display_name&quot;</span><span class="p">:</span> <span class="s2">&quot;Extras&quot;</span><span class="p">,</span>
                <span class="s2">&quot;help_text&quot;</span><span class="p">:</span> <span class="s2">&quot;Extras of the node&quot;</span><span class="p">,</span>
                <span class="s2">&quot;is_foreign_key&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
                <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;dict&quot;</span>
            <span class="p">},</span>
            <span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;display_name&quot;</span><span class="p">:</span> <span class="s2">&quot;Id&quot;</span><span class="p">,</span>
                <span class="s2">&quot;help_text&quot;</span><span class="p">:</span> <span class="s2">&quot;Id of the object&quot;</span><span class="p">,</span>
                <span class="s2">&quot;is_foreign_key&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
                <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span>
            <span class="p">},</span>
            <span class="s2">&quot;label&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;display_name&quot;</span><span class="p">:</span> <span class="s2">&quot;Label&quot;</span><span class="p">,</span>
                <span class="s2">&quot;help_text&quot;</span><span class="p">:</span> <span class="s2">&quot;User-assigned label&quot;</span><span class="p">,</span>
                <span class="s2">&quot;is_foreign_key&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
                <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;str&quot;</span>
            <span class="p">},</span>
            <span class="s2">&quot;mtime&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;display_name&quot;</span><span class="p">:</span> <span class="s2">&quot;Last Modification time&quot;</span><span class="p">,</span>
                <span class="s2">&quot;help_text&quot;</span><span class="p">:</span> <span class="s2">&quot;Last modification time&quot;</span><span class="p">,</span>
                <span class="s2">&quot;is_foreign_key&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
                <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;datetime.datetime&quot;</span>
            <span class="p">},</span>
            <span class="s2">&quot;node_type&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;display_name&quot;</span><span class="p">:</span> <span class="s2">&quot;Type&quot;</span><span class="p">,</span>
                <span class="s2">&quot;help_text&quot;</span><span class="p">:</span> <span class="s2">&quot;Node type&quot;</span><span class="p">,</span>
                <span class="s2">&quot;is_foreign_key&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
                <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;str&quot;</span>
            <span class="p">},</span>
            <span class="s2">&quot;user_id&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;display_name&quot;</span><span class="p">:</span> <span class="s2">&quot;Id of creator&quot;</span><span class="p">,</span>
                <span class="s2">&quot;help_text&quot;</span><span class="p">:</span> <span class="s2">&quot;Id of the user that created the node&quot;</span><span class="p">,</span>
                <span class="s2">&quot;is_foreign_key&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="s2">&quot;related_column&quot;</span><span class="p">:</span> <span class="s2">&quot;id&quot;</span><span class="p">,</span>
                <span class="s2">&quot;related_resource&quot;</span><span class="p">:</span> <span class="s2">&quot;_dbusers&quot;</span><span class="p">,</span>
                <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span>
            <span class="p">},</span>
            <span class="s2">&quot;uuid&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;display_name&quot;</span><span class="p">:</span> <span class="s2">&quot;Unique ID&quot;</span><span class="p">,</span>
                <span class="s2">&quot;help_text&quot;</span><span class="p">:</span> <span class="s2">&quot;Universally Unique Identifier&quot;</span><span class="p">,</span>
                <span class="s2">&quot;is_foreign_key&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
                <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;unicode&quot;</span>
            <span class="p">},</span>
            <span class="s2">&quot;nodeversion&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;display_name&quot;</span><span class="p">:</span> <span class="s2">&quot;Node version&quot;</span><span class="p">,</span>
                <span class="s2">&quot;help_text&quot;</span><span class="p">:</span> <span class="s2">&quot;Version of the node&quot;</span><span class="p">,</span>
                <span class="s2">&quot;is_foreign_key&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
                <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span>
            <span class="p">},</span>
            <span class="s2">&quot;process_type&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;display_name&quot;</span><span class="p">:</span> <span class="s2">&quot;Process type&quot;</span><span class="p">,</span>
                <span class="s2">&quot;help_text&quot;</span><span class="p">:</span> <span class="s2">&quot;Process type&quot;</span><span class="p">,</span>
                <span class="s2">&quot;is_foreign_key&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
                <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;str&quot;</span>
            <span class="p">}</span>
        <span class="p">}</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, ECOLE POLYTECHNIQUE FEDERALE DE LAUSANNE (Theory and Simulation of Materials (THEOS) and National Centre for Computational Design and Discovery of Novel Materials (NCCR MARVEL)), Switzerland and ROBERT BOSCH LLC, USA. All rights reserved

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>