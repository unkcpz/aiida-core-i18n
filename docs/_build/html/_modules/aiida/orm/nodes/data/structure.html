

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>aiida.orm.nodes.data.structure &mdash; AiiDA 1.0.0b2 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../../" src="../../../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../../../_static/language_data.js"></script>
        <script type="text/javascript" src="../../../../../_static/contentui.js"></script>
    
    <script type="text/javascript" src="../../../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../../../_static/contentui.css" type="text/css" />
    <link rel="index" title="Index" href="../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../../../index.html" class="icon icon-home"> AiiDA
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Installation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../install/quick_installation.html">Quick installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../install/prerequisites.html">Prerequisites</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../install/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../install/updating_installation.html">Updating AiiDA</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../install/troubleshooting.html">Troubleshooting</a></li>
</ul>
<p class="caption"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../get_started/index.html">First things first</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../get_started/daemon.html">Setup the daemon</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../get_started/computers.html">Setup a computer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../get_started/codes.html">Setup a code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../get_started/plugins.html">Plugins</a></li>
</ul>
<p class="caption"><span class="caption-text">Concepts</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../concepts/provenance.html">Provenance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../concepts/processes.html">Processes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../concepts/calculations.html">Calculations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../concepts/workflows.html">Workflows</a></li>
</ul>
<p class="caption"><span class="caption-text">Working with</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../working/processes.html">Processes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../working/functions.html">Calculation and work functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../working/calculations.html">Calculations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../working/workflows.html">Workflows</a></li>
</ul>
<p class="caption"><span class="caption-text">Working with AiiDA</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../working_with_aiida/index.html">Command line interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../working_with_aiida/index.html#scripting">Scripting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../working_with_aiida/index.html#data-types">Data types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../working_with_aiida/index.html#groups">Groups</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../working_with_aiida/index.html#schedulers">Schedulers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../working_with_aiida/index.html#querying-data">Querying data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../working_with_aiida/index.html#caching">Caching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../working_with_aiida/index.html#result-manager">Result manager</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../working_with_aiida/index.html#backups">Backups</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../working_with_aiida/index.html#troubleshooting">Troubleshooting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../working_with_aiida/index.html#rest-api">REST API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../working_with_aiida/index.html#cookbook">Cookbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../import_export/index.html">Import and Export</a></li>
</ul>
<p class="caption"><span class="caption-text">Development</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../developer_guide/index.html">AiiDA design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../developer_guide/index.html#aiida-core">AiiDA core</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../developer_guide/index.html#aiida-plugins">AiiDA plugins</a></li>
</ul>
<p class="caption"><span class="caption-text">Tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../tutorial/index.html">StructureData</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../tutorial/index.html#pseudopotentials">Pseudopotentials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../tutorial/index.html#plugin-development">Plugin development</a></li>
</ul>
<p class="caption"><span class="caption-text">API reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="`aiida package &lt;https://aiida-core.readthedocs.io/en/latest/apidoc/aiida.html&gt;`_">`aiida package &lt;https://aiida-core.readthedocs.io/en/latest/apidoc/aiida.html&gt;`_</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../index.html">AiiDA</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../../../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../../../../aiida.html">aiida</a> &raquo;</li>
        
      <li>aiida.orm.nodes.data.structure</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for aiida.orm.nodes.data.structure</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1">###########################################################################</span>
<span class="c1"># Copyright (c), The AiiDA team. All rights reserved.                     #</span>
<span class="c1"># This file is part of the AiiDA code.                                    #</span>
<span class="c1">#                                                                         #</span>
<span class="c1"># The code is hosted on GitHub at https://github.com/aiidateam/aiida_core #</span>
<span class="c1"># For further information on the license, see the LICENSE.txt file        #</span>
<span class="c1"># For further information please visit http://www.aiida.net               #</span>
<span class="c1">###########################################################################</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module defines the classes for structures and all related</span>
<span class="sd">functions to operate on them.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span>

<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="k">import</span> <span class="n">reduce</span>

<span class="kn">import</span> <span class="nn">six</span>
<span class="kn">from</span> <span class="nn">six.moves</span> <span class="k">import</span> <span class="nb">range</span><span class="p">,</span> <span class="nb">zip</span>

<span class="kn">from</span> <span class="nn">.data</span> <span class="k">import</span> <span class="n">Data</span>
<span class="kn">from</span> <span class="nn">aiida.common.constants</span> <span class="k">import</span> <span class="n">elements</span>
<span class="kn">from</span> <span class="nn">aiida.common.exceptions</span> <span class="k">import</span> <span class="n">UnsupportedSpeciesError</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;StructureData&#39;</span><span class="p">,</span> <span class="s1">&#39;Kind&#39;</span><span class="p">,</span> <span class="s1">&#39;Site&#39;</span><span class="p">)</span>

<span class="c1"># Threshold used to check if the mass of two different Site objects is the same.</span>

<span class="n">_mass_threshold</span> <span class="o">=</span> <span class="mf">1.e-3</span>
<span class="c1"># Threshold to check if the sum is one or not</span>
<span class="n">_sum_threshold</span> <span class="o">=</span> <span class="mf">1.e-6</span>
<span class="c1"># Threshold used to check if the cell volume is not zero.</span>
<span class="n">_volume_threshold</span> <span class="o">=</span> <span class="mf">1.e-6</span>

<span class="n">_valid_symbols</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="s1">&#39;symbol&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">elements</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
<span class="n">_atomic_masses</span> <span class="o">=</span> <span class="p">{</span><span class="n">el</span><span class="p">[</span><span class="s1">&#39;symbol&#39;</span><span class="p">]:</span> <span class="n">el</span><span class="p">[</span><span class="s1">&#39;mass&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">elements</span><span class="o">.</span><span class="n">values</span><span class="p">()}</span>
<span class="n">_atomic_numbers</span> <span class="o">=</span> <span class="p">{</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;symbol&#39;</span><span class="p">]:</span> <span class="n">num</span> <span class="k">for</span> <span class="n">num</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">elements</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>


<span class="k">def</span> <span class="nf">_get_valid_cell</span><span class="p">(</span><span class="n">inputcell</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the cell in a valid format from a generic input.</span>

<span class="sd">    :raise ValueError: whenever the format is not valid.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">the_cell</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">inputcell</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">the_cell</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">the_cell</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">IndexError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cell must be a list of three vectors, each defined as a list of three coordinates.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">calc_cell_volume</span><span class="p">(</span><span class="n">the_cell</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">_volume_threshold</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The cell volume is zero. Invalid cell.&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">the_cell</span>


<span class="k">def</span> <span class="nf">get_valid_pbc</span><span class="p">(</span><span class="n">inputpbc</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a list of three booleans for the periodic boundary conditions,</span>
<span class="sd">    in a valid format from a generic input.</span>

<span class="sd">    :raise ValueError: if the format is not valid.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inputpbc</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="n">the_pbc</span> <span class="o">=</span> <span class="p">(</span><span class="n">inputpbc</span><span class="p">,</span> <span class="n">inputpbc</span><span class="p">,</span> <span class="n">inputpbc</span><span class="p">)</span>
    <span class="k">elif</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">inputpbc</span><span class="p">,</span> <span class="s1">&#39;__iter__&#39;</span><span class="p">)):</span>
        <span class="c1"># To manage numpy lists of bools, whose elements are of type numpy.bool_</span>
        <span class="c1"># and for which isinstance(i,bool) return False...</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">inputpbc</span><span class="p">,</span> <span class="s1">&#39;tolist&#39;</span><span class="p">):</span>
            <span class="n">the_value</span> <span class="o">=</span> <span class="n">inputpbc</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">the_value</span> <span class="o">=</span> <span class="n">inputpbc</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">the_value</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">the_value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">the_pbc</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">the_value</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">the_value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">the_pbc</span> <span class="o">=</span> <span class="p">(</span><span class="n">the_value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">the_value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">the_value</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;pbc length must be either one or three.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;pbc elements are not booleans.&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;pbc must be a boolean or a list of three booleans.&quot;</span><span class="p">,</span> <span class="n">inputpbc</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">the_pbc</span>


<span class="k">def</span> <span class="nf">has_ase</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :return: True if the ase module can be imported, False otherwise.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">ase</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span>


<span class="k">def</span> <span class="nf">has_pymatgen</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :return: True if the pymatgen module can be imported, False otherwise.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">pymatgen</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span>


<span class="k">def</span> <span class="nf">get_pymatgen_version</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :return: string with pymatgen version, None if can not import.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">has_pymatgen</span><span class="p">():</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="kn">import</span> <span class="nn">pymatgen</span>
    <span class="k">return</span> <span class="n">pymatgen</span><span class="o">.</span><span class="n">__version__</span>


<span class="k">def</span> <span class="nf">has_spglib</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :return: True if the spglib module can be imported, False otherwise.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">spglib</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span>


<span class="k">def</span> <span class="nf">calc_cell_volume</span><span class="p">(</span><span class="n">cell</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the volume of a cell given the three lattice vectors.</span>

<span class="sd">    It is calculated as cell[0] . (cell[1] x cell[2]), where . represents</span>
<span class="sd">    a dot product and x a cross product.</span>

<span class="sd">    :param cell: the cell vectors; the must be a 3x3 list of lists of floats,</span>
<span class="sd">            no other checks are done.</span>

<span class="sd">    :returns: the cell volume.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># returns the volume of the primitive cell: |a1.(a2xa3)|</span>
    <span class="n">a1</span> <span class="o">=</span> <span class="n">cell</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">a2</span> <span class="o">=</span> <span class="n">cell</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">a3</span> <span class="o">=</span> <span class="n">cell</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">a_mid_0</span> <span class="o">=</span> <span class="n">a2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">a3</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">a2</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">a3</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">a_mid_1</span> <span class="o">=</span> <span class="n">a2</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">a3</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">a2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">a3</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">a_mid_2</span> <span class="o">=</span> <span class="n">a2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">a3</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">a2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">a3</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">a1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">a_mid_0</span> <span class="o">+</span> <span class="n">a1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">a_mid_1</span> <span class="o">+</span> <span class="n">a1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">a_mid_2</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_create_symbols_tuple</span><span class="p">(</span><span class="n">symbols</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a tuple with the symbols provided. If a string is provided,</span>
<span class="sd">    this is converted to a tuple with one single element.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">symbols</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
        <span class="n">symbols_list</span> <span class="o">=</span> <span class="p">(</span><span class="n">symbols</span><span class="p">,)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">symbols_list</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">symbols_list</span>


<span class="k">def</span> <span class="nf">_create_weights_tuple</span><span class="p">(</span><span class="n">weights</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a tuple with the weights provided. If a number is provided,</span>
<span class="sd">    this is converted to a tuple with one single element.</span>
<span class="sd">    If None is provided, this is converted to the tuple (1.,)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">numbers</span>

    <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">weights_tuple</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.</span><span class="p">,)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Number</span><span class="p">):</span>
        <span class="n">weights_tuple</span> <span class="o">=</span> <span class="p">(</span><span class="n">weights</span><span class="p">,)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">weights_tuple</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">weights</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">weights_tuple</span>


<span class="k">def</span> <span class="nf">create_automatic_kind_name</span><span class="p">(</span><span class="n">symbols</span><span class="p">,</span> <span class="n">weights</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a string obtained with the symbols appended one</span>
<span class="sd">    after the other, without spaces, in alphabetical order;</span>
<span class="sd">    if the site has a vacancy, a X is appended at the end too.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sorted_symbol_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">symbols</span><span class="p">))</span>
    <span class="n">sorted_symbol_list</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>  <span class="c1"># In-place sort</span>
    <span class="n">name_string</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sorted_symbol_list</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">has_vacancies</span><span class="p">(</span><span class="n">weights</span><span class="p">):</span>
        <span class="n">name_string</span> <span class="o">+=</span> <span class="s2">&quot;X&quot;</span>
    <span class="k">return</span> <span class="n">name_string</span>


<span class="k">def</span> <span class="nf">validate_weights_tuple</span><span class="p">(</span><span class="n">weights_tuple</span><span class="p">,</span> <span class="n">threshold</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Validates the weight of the atomic kinds.</span>

<span class="sd">    :raise: ValueError if the weights_tuple is not valid.</span>

<span class="sd">    :param weights_tuple: the tuple to validate. It must be a</span>
<span class="sd">            a tuple of floats (as created by :func:_create_weights_tuple).</span>
<span class="sd">    :param threshold: a float number used as a threshold to check that the sum</span>
<span class="sd">            of the weights is &lt;= 1.</span>

<span class="sd">    If the sum is less than one, it means that there are vacancies.</span>
<span class="sd">    Each element of the list must be &gt;= 0, and the sum must be &lt;= 1.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">w_sum</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">weights_tuple</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">any</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mf">0.</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">weights_tuple</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">w_sum</span> <span class="o">-</span> <span class="mf">1.</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The weight list is not valid (each element must be positive, and the sum must be &lt;= 1).&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">is_valid_symbol</span><span class="p">(</span><span class="n">symbol</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Validates the chemical symbol name.</span>

<span class="sd">    :return: True if the symbol is a valid chemical symbol (with correct</span>
<span class="sd">        capitalization), or the dummy X, False otherwise.</span>

<span class="sd">    Recognized symbols are for elements from hydrogen (Z=1) to lawrencium</span>
<span class="sd">    (Z=103). In addition, a dummy element unknown name (Z=0) is supported.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="n">_valid_symbols</span>


<span class="k">def</span> <span class="nf">validate_symbols_tuple</span><span class="p">(</span><span class="n">symbols_tuple</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Used to validate whether the chemical species are valid.</span>

<span class="sd">    :param symbols_tuple: a tuple (or list) with the chemical symbols name.</span>
<span class="sd">    :raises: UnsupportedSpeciesError if any symbol in the tuple is not a valid chemical</span>
<span class="sd">        symbol (with correct capitalization).</span>

<span class="sd">    Refer also to the documentation of :func:is_valid_symbol</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">symbols_tuple</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">valid</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">valid</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">is_valid_symbol</span><span class="p">(</span><span class="n">sym</span><span class="p">)</span> <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="n">symbols_tuple</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">valid</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">UnsupportedSpeciesError</span><span class="p">(</span><span class="s2">&quot;At least one element of the symbol list </span><span class="si">{}</span><span class="s2"> has &quot;</span>
                                      <span class="s2">&quot;not been recognized.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">symbols_tuple</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">is_ase_atoms</span><span class="p">(</span><span class="n">ase_atoms</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check if the ase_atoms parameter is actually a ase.Atoms object.</span>

<span class="sd">    :param ase_atoms: an object, expected to be an ase.Atoms.</span>
<span class="sd">    :return: a boolean.</span>

<span class="sd">    Requires the ability to import ase, by doing &#39;import ase&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO: Check if we want to try to import ase and do something</span>
    <span class="c1"># reasonable depending on whether ase is there or not.</span>
    <span class="kn">import</span> <span class="nn">ase</span>

    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ase_atoms</span><span class="p">,</span> <span class="n">ase</span><span class="o">.</span><span class="n">Atoms</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">group_symbols</span><span class="p">(</span><span class="n">_list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Group a list of symbols to a list containing the number of consecutive</span>
<span class="sd">    identical symbols, and the symbol itself.</span>

<span class="sd">    Examples:</span>

<span class="sd">    * ``[&#39;Ba&#39;,&#39;Ti&#39;,&#39;O&#39;,&#39;O&#39;,&#39;O&#39;,&#39;Ba&#39;]`` will return</span>
<span class="sd">      ``[[1,&#39;Ba&#39;],[1,&#39;Ti&#39;],[3,&#39;O&#39;],[1,&#39;Ba&#39;]]``</span>

<span class="sd">    * ``[ [ [1,&#39;Ba&#39;],[1,&#39;Ti&#39;] ],[ [1,&#39;Ba&#39;],[1,&#39;Ti&#39;] ] ]`` will return</span>
<span class="sd">      ``[[2, [ [1, &#39;Ba&#39;], [1, &#39;Ti&#39;] ] ]]``</span>

<span class="sd">    :param _list: a list of elements representing a chemical formula</span>
<span class="sd">    :return: a list of length-2 lists of the form [ multiplicity , element ]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">the_list</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">_list</span><span class="p">)</span>
    <span class="n">the_list</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
    <span class="n">grouped_list</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="n">the_list</span><span class="o">.</span><span class="n">pop</span><span class="p">()]]</span>
    <span class="k">while</span> <span class="n">the_list</span><span class="p">:</span>
        <span class="n">elem</span> <span class="o">=</span> <span class="n">the_list</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">elem</span> <span class="o">==</span> <span class="n">grouped_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span>
            <span class="c1"># same symbol is repeated</span>
            <span class="n">grouped_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">grouped_list</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">elem</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">grouped_list</span>


<span class="k">def</span> <span class="nf">get_formula_from_symbol_list</span><span class="p">(</span><span class="n">_list</span><span class="p">,</span> <span class="n">separator</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a string with the formula obtained from the list of symbols.</span>
<span class="sd">    Examples:</span>
<span class="sd">    * ``[[1,&#39;Ba&#39;],[1,&#39;Ti&#39;],[3,&#39;O&#39;]]`` will return ``&#39;BaTiO3&#39;``</span>
<span class="sd">    * ``[[2, [ [1, &#39;Ba&#39;], [1, &#39;Ti&#39;] ] ]]`` will return ``&#39;(BaTi)2&#39;``</span>

<span class="sd">    :param _list: a list of symbols and multiplicities as obtained from</span>
<span class="sd">        the function group_symbols</span>
<span class="sd">    :param separator: a string used to concatenate symbols. Default empty.</span>

<span class="sd">    :return: a string</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">list_str</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">_list</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">multiplicity_str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">multiplicity_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
            <span class="n">list_str</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">multiplicity_str</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">list_str</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;(</span><span class="si">{}</span><span class="s2">)</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">get_formula_from_symbol_list</span><span class="p">(</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">separator</span><span class="o">=</span><span class="n">separator</span><span class="p">),</span> <span class="n">multiplicity_str</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">list_str</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">get_formula_from_symbol_list</span><span class="p">(</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">separator</span><span class="o">=</span><span class="n">separator</span><span class="p">),</span> <span class="n">multiplicity_str</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">separator</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">list_str</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">get_formula_group</span><span class="p">(</span><span class="n">symbol_list</span><span class="p">,</span> <span class="n">separator</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a string with the chemical formula from a list of chemical symbols.</span>
<span class="sd">    The formula is written in a compact&quot; way, i.e. trying to group as much as</span>
<span class="sd">    possible parts of the formula.</span>

<span class="sd">    .. note:: it works for instance very well if structure was obtained</span>
<span class="sd">        from an ASE supercell.</span>

<span class="sd">    Example of result:</span>
<span class="sd">    ``[&#39;Ba&#39;, &#39;Ti&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;, &#39;Ba&#39;, &#39;Ti&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;,</span>
<span class="sd">    &#39;Ba&#39;, &#39;Ti&#39;, &#39;Ti&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;]`` will return ``&#39;(BaTiO3)2BaTi2O3&#39;``.</span>

<span class="sd">    :param symbol_list: list of symbols</span>
<span class="sd">        (e.g. [&#39;Ba&#39;,&#39;Ti&#39;,&#39;O&#39;,&#39;O&#39;,&#39;O&#39;])</span>
<span class="sd">    :param separator: a string used to concatenate symbols. Default empty.</span>
<span class="sd">    :returns: a string with the chemical formula for the given structure.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">group_together</span><span class="p">(</span><span class="n">_list</span><span class="p">,</span> <span class="n">group_size</span><span class="p">,</span> <span class="n">offset</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param _list: a list</span>
<span class="sd">        :param group_size: size of the groups</span>
<span class="sd">        :param offset: beginning grouping after offset elements</span>
<span class="sd">        :return : a list of lists made of groups of size group_size</span>
<span class="sd">            obtained by grouping list elements together</span>
<span class="sd">            The first elements (up to _list[offset-1]) are not grouped</span>
<span class="sd">        example:</span>
<span class="sd">            ``group_together([&#39;O&#39;,&#39;Ba&#39;,&#39;Ti&#39;,&#39;Ba&#39;,&#39;Ti&#39;],2,1) =</span>
<span class="sd">                [&#39;O&#39;,[&#39;Ba&#39;,&#39;Ti&#39;],[&#39;Ba&#39;,&#39;Ti&#39;]]``</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">the_list</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">_list</span><span class="p">)</span>
        <span class="n">the_list</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
        <span class="n">grouped_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">offset</span><span class="p">):</span>
            <span class="n">grouped_list</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">the_list</span><span class="o">.</span><span class="n">pop</span><span class="p">()])</span>

        <span class="k">while</span> <span class="n">the_list</span><span class="p">:</span>
            <span class="n">l</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">group_size</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">the_list</span><span class="p">:</span>
                    <span class="n">l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">the_list</span><span class="o">.</span><span class="n">pop</span><span class="p">())</span>
            <span class="n">grouped_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">grouped_list</span>

    <span class="k">def</span> <span class="nf">cleanout_symbol_list</span><span class="p">(</span><span class="n">_list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param _list: a list of groups of symbols and multiplicities</span>
<span class="sd">        :return : a list where all groups with multiplicity 1 have</span>
<span class="sd">            been reduced to minimum</span>
<span class="sd">        example: ``[[1,[[1,&#39;Ba&#39;]]]]`` will return ``[[1,&#39;Ba&#39;]]``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">the_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">the_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">the_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">the_list</span>

    <span class="k">def</span> <span class="nf">group_together_symbols</span><span class="p">(</span><span class="n">_list</span><span class="p">,</span> <span class="n">group_size</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Successive application of group_together, group_symbols and</span>
<span class="sd">        cleanout_symbol_list, in order to group a symbol list, scanning all</span>
<span class="sd">        possible offsets, for a given group size</span>
<span class="sd">        :param _list: the symbol list (see function group_symbols)</span>
<span class="sd">        :param group_size: the size of the groups</span>
<span class="sd">        :return the_symbol_list: the new grouped symbol list</span>
<span class="sd">        :return has_grouped: True if we grouped something</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">the_symbol_list</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">_list</span><span class="p">)</span>
        <span class="n">has_grouped</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="p">(</span><span class="ow">not</span> <span class="n">has_grouped</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="n">group_size</span><span class="p">):</span>
            <span class="n">grouped_list</span> <span class="o">=</span> <span class="n">group_together</span><span class="p">(</span><span class="n">the_symbol_list</span><span class="p">,</span> <span class="n">group_size</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>
            <span class="n">new_symbol_list</span> <span class="o">=</span> <span class="n">group_symbols</span><span class="p">(</span><span class="n">grouped_list</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_symbol_list</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">grouped_list</span><span class="p">)):</span>
                <span class="n">the_symbol_list</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">new_symbol_list</span><span class="p">)</span>
                <span class="n">the_symbol_list</span> <span class="o">=</span> <span class="n">cleanout_symbol_list</span><span class="p">(</span><span class="n">the_symbol_list</span><span class="p">)</span>
                <span class="n">has_grouped</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="c1"># print get_formula_from_symbol_list(the_symbol_list)</span>
            <span class="n">offset</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">the_symbol_list</span><span class="p">,</span> <span class="n">has_grouped</span>

    <span class="k">def</span> <span class="nf">group_all_together_symbols</span><span class="p">(</span><span class="n">_list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Successive application of the function group_together_symbols, to group</span>
<span class="sd">        a symbol list, scanning all possible offsets and group sizes</span>
<span class="sd">        :param _list: the symbol list (see function group_symbols)</span>
<span class="sd">        :return: the new grouped symbol list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">has_finished</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">group_size</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_list</span><span class="p">)</span>
        <span class="n">the_symbol_list</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">_list</span><span class="p">)</span>

        <span class="k">while</span> <span class="p">(</span><span class="ow">not</span> <span class="n">has_finished</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">group_size</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="o">//</span> <span class="mi">2</span><span class="p">):</span>
            <span class="c1"># try to group as much as possible by groups of size group_size</span>
            <span class="n">the_symbol_list</span><span class="p">,</span> <span class="n">has_grouped</span> <span class="o">=</span> <span class="n">group_together_symbols</span><span class="p">(</span><span class="n">the_symbol_list</span><span class="p">,</span> <span class="n">group_size</span><span class="p">)</span>
            <span class="n">has_finished</span> <span class="o">=</span> <span class="n">has_grouped</span>
            <span class="n">group_size</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1"># stop as soon as we managed to group something</span>
            <span class="c1"># or when the group_size is too big to get anything</span>

        <span class="k">return</span> <span class="n">the_symbol_list</span>

    <span class="c1"># initial grouping of the chemical symbols</span>
    <span class="n">old_symbol_list</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">new_symbol_list</span> <span class="o">=</span> <span class="n">group_symbols</span><span class="p">(</span><span class="n">symbol_list</span><span class="p">)</span>

    <span class="c1"># successively apply the grouping procedure until the symbol list does not</span>
    <span class="c1"># change anymore</span>
    <span class="k">while</span> <span class="n">new_symbol_list</span> <span class="o">!=</span> <span class="n">old_symbol_list</span><span class="p">:</span>
        <span class="n">old_symbol_list</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">new_symbol_list</span><span class="p">)</span>
        <span class="n">new_symbol_list</span> <span class="o">=</span> <span class="n">group_all_together_symbols</span><span class="p">(</span><span class="n">old_symbol_list</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">get_formula_from_symbol_list</span><span class="p">(</span><span class="n">new_symbol_list</span><span class="p">,</span> <span class="n">separator</span><span class="o">=</span><span class="n">separator</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">get_formula</span><span class="p">(</span><span class="n">symbol_list</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;hill&#39;</span><span class="p">,</span> <span class="n">separator</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a string with the chemical formula.</span>

<span class="sd">    :param symbol_list: a list of symbols, e.g. ``[&#39;H&#39;,&#39;H&#39;,&#39;O&#39;]``</span>
<span class="sd">    :param mode: a string to specify how to generate the formula, can</span>
<span class="sd">        assume one of the following values:</span>

<span class="sd">        * &#39;hill&#39; (default): count the number of atoms of each species,</span>
<span class="sd">          then use Hill notation, i.e. alphabetical order with C and H</span>
<span class="sd">          first if one or several C atom(s) is (are) present, e.g.</span>
<span class="sd">          ``[&#39;C&#39;,&#39;H&#39;,&#39;H&#39;,&#39;H&#39;,&#39;O&#39;,&#39;C&#39;,&#39;H&#39;,&#39;H&#39;,&#39;H&#39;]`` will return ``&#39;C2H6O&#39;``</span>
<span class="sd">          ``[&#39;S&#39;,&#39;O&#39;,&#39;O&#39;,&#39;H&#39;,&#39;O&#39;,&#39;H&#39;,&#39;O&#39;]``  will return ``&#39;H2O4S&#39;``</span>
<span class="sd">          From E. A. Hill, J. Am. Chem. Soc., 22 (8), pp 478–494 (1900)</span>

<span class="sd">        * &#39;hill_compact&#39;: same as hill but the number of atoms for each</span>
<span class="sd">          species is divided by the greatest common divisor of all of them, e.g.</span>
<span class="sd">          ``[&#39;C&#39;,&#39;H&#39;,&#39;H&#39;,&#39;H&#39;,&#39;O&#39;,&#39;C&#39;,&#39;H&#39;,&#39;H&#39;,&#39;H&#39;,&#39;O&#39;,&#39;O&#39;,&#39;O&#39;]``</span>
<span class="sd">          will return ``&#39;CH3O2&#39;``</span>

<span class="sd">        * &#39;reduce&#39;: group repeated symbols e.g.</span>
<span class="sd">          ``[&#39;Ba&#39;, &#39;Ti&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;, &#39;Ba&#39;, &#39;Ti&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;,</span>
<span class="sd">          &#39;Ba&#39;, &#39;Ti&#39;, &#39;Ti&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;]`` will return ``&#39;BaTiO3BaTiO3BaTi2O3&#39;``</span>

<span class="sd">        * &#39;group&#39;: will try to group as much as possible parts of the formula</span>
<span class="sd">          e.g.</span>
<span class="sd">          ``[&#39;Ba&#39;, &#39;Ti&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;, &#39;Ba&#39;, &#39;Ti&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;,</span>
<span class="sd">          &#39;Ba&#39;, &#39;Ti&#39;, &#39;Ti&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;]`` will return ``&#39;(BaTiO3)2BaTi2O3&#39;``</span>

<span class="sd">        * &#39;count&#39;: same as hill (i.e. one just counts the number</span>
<span class="sd">          of atoms of each species) without the re-ordering (take the</span>
<span class="sd">          order of the atomic sites), e.g.</span>
<span class="sd">          ``[&#39;Ba&#39;, &#39;Ti&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;,&#39;Ba&#39;, &#39;Ti&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;]``</span>
<span class="sd">          will return ``&#39;Ba2Ti2O6&#39;``</span>

<span class="sd">        * &#39;count_compact&#39;: same as count but the number of atoms</span>
<span class="sd">          for each species is divided by the greatest common divisor of</span>
<span class="sd">          all of them, e.g.</span>
<span class="sd">          ``[&#39;Ba&#39;, &#39;Ti&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;,&#39;Ba&#39;, &#39;Ti&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;]``</span>
<span class="sd">          will return ``&#39;BaTiO3&#39;``</span>

<span class="sd">    :param separator: a string used to concatenate symbols. Default empty.</span>

<span class="sd">    :return: a string with the formula</span>

<span class="sd">    .. note:: in modes reduce, group, count and count_compact, the</span>
<span class="sd">        initial order in which the atoms were appended by the user is</span>
<span class="sd">        used to group and/or order the symbols in the formula</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;group&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">get_formula_group</span><span class="p">(</span><span class="n">symbol_list</span><span class="p">,</span> <span class="n">separator</span><span class="o">=</span><span class="n">separator</span><span class="p">)</span>

    <span class="c1"># for hill and count cases, simply count the occurences of each</span>
    <span class="c1"># chemical symbol (with some re-ordering in hill)</span>
    <span class="k">elif</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;hill&#39;</span><span class="p">,</span> <span class="s1">&#39;hill_compact&#39;</span><span class="p">]:</span>
        <span class="n">symbol_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">symbol_list</span><span class="p">)</span>
        <span class="n">first_symbols</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="s1">&#39;C&#39;</span> <span class="ow">in</span> <span class="n">symbol_set</span><span class="p">:</span>
            <span class="c1"># remove C (and H if present) from list and put them at the</span>
            <span class="c1"># beginning</span>
            <span class="n">symbol_set</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
            <span class="n">first_symbols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="s1">&#39;H&#39;</span> <span class="ow">in</span> <span class="n">symbol_set</span><span class="p">:</span>
                <span class="n">symbol_set</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">)</span>
                <span class="n">first_symbols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">)</span>
        <span class="n">ordered_symbol_set</span> <span class="o">=</span> <span class="n">first_symbols</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">symbol_set</span><span class="p">))</span>
        <span class="n">the_symbol_list</span> <span class="o">=</span> <span class="p">[[</span><span class="n">symbol_list</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">elem</span><span class="p">),</span> <span class="n">elem</span><span class="p">]</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">ordered_symbol_set</span><span class="p">]</span>

    <span class="k">elif</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">,</span> <span class="s1">&#39;count_compact&#39;</span><span class="p">]:</span>
        <span class="n">ordered_symbol_indexes</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">symbol_list</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">symbol_list</span><span class="p">)])</span>
        <span class="n">ordered_symbol_set</span> <span class="o">=</span> <span class="p">[</span><span class="n">symbol_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ordered_symbol_indexes</span><span class="p">]</span>
        <span class="n">the_symbol_list</span> <span class="o">=</span> <span class="p">[[</span><span class="n">symbol_list</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">elem</span><span class="p">),</span> <span class="n">elem</span><span class="p">]</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">ordered_symbol_set</span><span class="p">]</span>

    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;reduce&#39;</span><span class="p">:</span>
        <span class="n">the_symbol_list</span> <span class="o">=</span> <span class="n">group_symbols</span><span class="p">(</span><span class="n">symbol_list</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Mode should be hill, hill_compact, group, &#39;</span> <span class="s1">&#39;reduce, count or count_compact&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;hill_compact&#39;</span><span class="p">,</span> <span class="s1">&#39;count_compact&#39;</span><span class="p">]:</span>
        <span class="kn">from</span> <span class="nn">fractions</span> <span class="k">import</span> <span class="n">gcd</span>
        <span class="n">the_gcd</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">gcd</span><span class="p">,</span> <span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">the_symbol_list</span><span class="p">])</span>
        <span class="n">the_symbol_list</span> <span class="o">=</span> <span class="p">[[</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="n">the_gcd</span><span class="p">,</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">the_symbol_list</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">get_formula_from_symbol_list</span><span class="p">(</span><span class="n">the_symbol_list</span><span class="p">,</span> <span class="n">separator</span><span class="o">=</span><span class="n">separator</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">get_symbols_string</span><span class="p">(</span><span class="n">symbols</span><span class="p">,</span> <span class="n">weights</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a string that tries to match as good as possible the symbols</span>
<span class="sd">    and weights. If there is only one symbol (no alloy) with 100%</span>
<span class="sd">    occupancy, just returns the symbol name. Otherwise, groups the full</span>
<span class="sd">    string in curly brackets, and try to write also the composition</span>
<span class="sd">    (with 2 precision only).</span>
<span class="sd">    If (sum of weights&lt;1), we indicate it with the X symbol followed</span>
<span class="sd">    by 1-sum(weights) (still with 2 digits precision, so it can be 0.00)</span>

<span class="sd">    :param symbols: the symbols as obtained from &lt;kind&gt;._symbols</span>
<span class="sd">    :param weights: the weights as obtained from &lt;kind&gt;._weights</span>

<span class="sd">    .. note:: Note the difference with respect to the symbols and the</span>
<span class="sd">        symbol properties!</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">weights</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mf">1.</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">symbols</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">pieces</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">symbols</span><span class="p">,</span> <span class="n">weights</span><span class="p">):</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}{:4.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">w</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">has_vacancies</span><span class="p">(</span><span class="n">weights</span><span class="p">):</span>
            <span class="n">pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;X</span><span class="si">{:4.2f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">)))</span>
        <span class="k">return</span> <span class="s2">&quot;{{</span><span class="si">{}</span><span class="s2">}}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">pieces</span><span class="p">)))</span>


<span class="k">def</span> <span class="nf">has_vacancies</span><span class="p">(</span><span class="n">weights</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns True if the sum of the weights is less than one.</span>
<span class="sd">    It uses the internal variable _sum_threshold as a threshold.</span>
<span class="sd">    :param weights: the weights</span>
<span class="sd">    :return: a boolean</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">w_sum</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
    <span class="k">return</span> <span class="ow">not</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">w_sum</span> <span class="o">&lt;</span> <span class="n">_sum_threshold</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">symop_ortho_from_fract</span><span class="p">(</span><span class="n">cell</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates a matrix for conversion from orthogonal to fractional</span>
<span class="sd">    coordinates.</span>

<span class="sd">    Taken from</span>
<span class="sd">    svn://www.crystallography.net/cod-tools/trunk/lib/perl5/Fractional.pm,</span>
<span class="sd">    revision 850.</span>

<span class="sd">    :param cell: array of cell parameters (three lengths and three angles)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">math</span>
    <span class="kn">import</span> <span class="nn">numpy</span>

    <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span> <span class="o">=</span> <span class="n">cell</span>
    <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span> <span class="o">=</span> <span class="p">[</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">x</span> <span class="o">/</span> <span class="mi">180</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span><span class="p">]]</span>
    <span class="n">ca</span><span class="p">,</span> <span class="n">cb</span><span class="p">,</span> <span class="n">cg</span> <span class="o">=</span> <span class="p">[</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span><span class="p">]]</span>
    <span class="n">sg</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">*</span> <span class="n">cg</span><span class="p">,</span> <span class="n">c</span> <span class="o">*</span> <span class="n">cb</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">b</span> <span class="o">*</span> <span class="n">sg</span><span class="p">,</span> <span class="n">c</span> <span class="o">*</span> <span class="p">(</span><span class="n">ca</span> <span class="o">-</span> <span class="n">cb</span> <span class="o">*</span> <span class="n">cg</span><span class="p">)</span> <span class="o">/</span> <span class="n">sg</span><span class="p">],</span>
                        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">c</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sg</span> <span class="o">*</span> <span class="n">sg</span> <span class="o">-</span> <span class="n">ca</span> <span class="o">*</span> <span class="n">ca</span> <span class="o">-</span> <span class="n">cb</span> <span class="o">*</span> <span class="n">cb</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">ca</span> <span class="o">*</span> <span class="n">cb</span> <span class="o">*</span> <span class="n">cg</span><span class="p">)</span> <span class="o">/</span> <span class="n">sg</span><span class="p">]])</span>


<span class="k">def</span> <span class="nf">symop_fract_from_ortho</span><span class="p">(</span><span class="n">cell</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates a matrix for conversion from fractional to orthogonal</span>
<span class="sd">    coordinates.</span>

<span class="sd">    Taken from</span>
<span class="sd">    svn://www.crystallography.net/cod-tools/trunk/lib/perl5/Fractional.pm,</span>
<span class="sd">    revision 850.</span>

<span class="sd">    :param cell: array of cell parameters (three lengths and three angles)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">math</span>
    <span class="kn">import</span> <span class="nn">numpy</span>

    <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span> <span class="o">=</span> <span class="n">cell</span>
    <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span> <span class="o">=</span> <span class="p">[</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">x</span> <span class="o">/</span> <span class="mi">180</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span><span class="p">]]</span>
    <span class="n">ca</span><span class="p">,</span> <span class="n">cb</span><span class="p">,</span> <span class="n">cg</span> <span class="o">=</span> <span class="p">[</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span><span class="p">]]</span>
    <span class="n">sg</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span>
    <span class="n">ctg</span> <span class="o">=</span> <span class="n">cg</span> <span class="o">/</span> <span class="n">sg</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sg</span> <span class="o">*</span> <span class="n">sg</span> <span class="o">-</span> <span class="n">cb</span> <span class="o">*</span> <span class="n">cb</span> <span class="o">-</span> <span class="n">ca</span> <span class="o">*</span> <span class="n">ca</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">ca</span> <span class="o">*</span> <span class="n">cb</span> <span class="o">*</span> <span class="n">cg</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
        <span class="p">[</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">a</span><span class="p">,</span> <span class="o">-</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="n">ctg</span><span class="p">,</span> <span class="p">(</span><span class="n">ca</span> <span class="o">*</span> <span class="n">cg</span> <span class="o">-</span> <span class="n">cb</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">D</span><span class="p">)],</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">b</span> <span class="o">*</span> <span class="n">sg</span><span class="p">),</span> <span class="o">-</span><span class="p">(</span><span class="n">ca</span> <span class="o">-</span> <span class="n">cb</span> <span class="o">*</span> <span class="n">cg</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">b</span> <span class="o">*</span> <span class="n">D</span> <span class="o">*</span> <span class="n">sg</span><span class="p">)],</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sg</span> <span class="o">/</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span> <span class="n">D</span><span class="p">)],</span>
    <span class="p">])</span>


<span class="k">def</span> <span class="nf">ase_refine_cell</span><span class="p">(</span><span class="n">aseatoms</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Detect the symmetry of the structure, remove symmetric atoms and</span>
<span class="sd">    refine unit cell.</span>

<span class="sd">    :param aseatoms: an ase.atoms.Atoms instance</span>
<span class="sd">    :param symprec: symmetry precision, used by spglib</span>
<span class="sd">    :return newase: refined cell with reduced set of atoms</span>
<span class="sd">    :return symmetry: a dictionary describing the symmetry space group</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">spglib</span> <span class="k">import</span> <span class="n">refine_cell</span><span class="p">,</span> <span class="n">get_symmetry_dataset</span>
    <span class="kn">from</span> <span class="nn">ase.atoms</span> <span class="k">import</span> <span class="n">Atoms</span>
    <span class="n">cell</span><span class="p">,</span> <span class="n">positions</span><span class="p">,</span> <span class="n">numbers</span> <span class="o">=</span> <span class="n">refine_cell</span><span class="p">(</span><span class="n">aseatoms</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="n">refined_atoms</span> <span class="o">=</span> <span class="n">Atoms</span><span class="p">(</span><span class="n">numbers</span><span class="p">,</span> <span class="n">scaled_positions</span><span class="o">=</span><span class="n">positions</span><span class="p">,</span> <span class="n">cell</span><span class="o">=</span><span class="n">cell</span><span class="p">,</span> <span class="n">pbc</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">sym_dataset</span> <span class="o">=</span> <span class="n">get_symmetry_dataset</span><span class="p">(</span><span class="n">refined_atoms</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="n">unique_numbers</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">unique_positions</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">sym_dataset</span><span class="p">[</span><span class="s1">&#39;equivalent_atoms&#39;</span><span class="p">]):</span>
        <span class="n">unique_numbers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">refined_atoms</span><span class="o">.</span><span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">unique_positions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">refined_atoms</span><span class="o">.</span><span class="n">get_scaled_positions</span><span class="p">()[</span><span class="n">i</span><span class="p">])</span>

    <span class="n">unique_atoms</span> <span class="o">=</span> <span class="n">Atoms</span><span class="p">(</span><span class="n">unique_numbers</span><span class="p">,</span> <span class="n">scaled_positions</span><span class="o">=</span><span class="n">unique_positions</span><span class="p">,</span> <span class="n">cell</span><span class="o">=</span><span class="n">cell</span><span class="p">,</span> <span class="n">pbc</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">unique_atoms</span><span class="p">,</span> <span class="p">{</span>
        <span class="s1">&#39;hm&#39;</span><span class="p">:</span> <span class="n">sym_dataset</span><span class="p">[</span><span class="s1">&#39;international&#39;</span><span class="p">],</span>
        <span class="s1">&#39;hall&#39;</span><span class="p">:</span> <span class="n">sym_dataset</span><span class="p">[</span><span class="s1">&#39;hall&#39;</span><span class="p">],</span>
        <span class="s1">&#39;tables&#39;</span><span class="p">:</span> <span class="n">sym_dataset</span><span class="p">[</span><span class="s1">&#39;number&#39;</span><span class="p">],</span>
        <span class="s1">&#39;rotations&#39;</span><span class="p">:</span> <span class="n">sym_dataset</span><span class="p">[</span><span class="s1">&#39;rotations&#39;</span><span class="p">],</span>
        <span class="s1">&#39;translations&#39;</span><span class="p">:</span> <span class="n">sym_dataset</span><span class="p">[</span><span class="s1">&#39;translations&#39;</span><span class="p">]</span>
    <span class="p">}</span>


<span class="k">def</span> <span class="nf">atom_kinds_to_html</span><span class="p">(</span><span class="n">atom_kind</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Construct in html format</span>

<span class="sd">    an alloy with 0.5 Ge, 0.4 Si and 0.1 vacancy is represented as</span>
<span class="sd">    Ge&lt;sub&gt;0.5&lt;/sub&gt; + Si&lt;sub&gt;0.4&lt;/sub&gt; + vacancy&lt;sub&gt;0.1&lt;/sub&gt;</span>

<span class="sd">    Args:</span>
<span class="sd">        atom_kind: a string with the name of the atomic kind, as printed by</span>
<span class="sd">        kind.get_symbols_string(), e.g. Ba0.80Ca0.10X0.10</span>

<span class="sd">    Returns:</span>
<span class="sd">        html code for rendered formula</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Parse the formula (TODO can be made more robust though never fails if</span>
    <span class="c1"># it takes strings generated with kind.get_symbols_string())</span>
    <span class="kn">import</span> <span class="nn">re</span>
    <span class="n">elements</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;([A-Z][a-z]*)([0-1][.[0-9]*]?)?&#39;</span><span class="p">,</span> <span class="n">atom_kind</span><span class="p">)</span>

    <span class="c1"># Compose the html string</span>
    <span class="n">html_formula_pieces</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">elements</span><span class="p">:</span>

        <span class="c1"># replace element X by &#39;vacancy&#39;</span>
        <span class="n">species</span> <span class="o">=</span> <span class="n">element</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">element</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;X&#39;</span> <span class="k">else</span> <span class="s1">&#39;vacancy&#39;</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="n">element</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">element</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">weight</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">html_formula_pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">species</span> <span class="o">+</span> <span class="s1">&#39;&lt;sub&gt;&#39;</span> <span class="o">+</span> <span class="n">weight</span> <span class="o">+</span> <span class="s1">&#39;&lt;/sub&gt;&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">html_formula_pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">species</span><span class="p">)</span>

    <span class="n">html_formula</span> <span class="o">=</span> <span class="s1">&#39; + &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">html_formula_pieces</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">html_formula</span>


<div class="viewcode-block" id="StructureData"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.StructureData">[docs]</a><span class="k">class</span> <span class="nc">StructureData</span><span class="p">(</span><span class="n">Data</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class contains the information about a given structure, i.e. a</span>
<span class="sd">    collection of sites together with a cell, the</span>
<span class="sd">    boundary conditions (whether they are periodic or not) and other</span>
<span class="sd">    related useful information.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_set_incompatibilities</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;ase&quot;</span><span class="p">,</span> <span class="s2">&quot;cell&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;ase&quot;</span><span class="p">,</span> <span class="s2">&quot;pbc&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;ase&quot;</span><span class="p">,</span> <span class="s2">&quot;pymatgen&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;ase&quot;</span><span class="p">,</span> <span class="s2">&quot;pymatgen_molecule&quot;</span><span class="p">),</span>
                              <span class="p">(</span><span class="s2">&quot;ase&quot;</span><span class="p">,</span> <span class="s2">&quot;pymatgen_structure&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;cell&quot;</span><span class="p">,</span> <span class="s2">&quot;pymatgen&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;cell&quot;</span><span class="p">,</span> <span class="s2">&quot;pymatgen_molecule&quot;</span><span class="p">),</span>
                              <span class="p">(</span><span class="s2">&quot;cell&quot;</span><span class="p">,</span> <span class="s2">&quot;pymatgen_structure&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;pbc&quot;</span><span class="p">,</span> <span class="s2">&quot;pymatgen&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;pbc&quot;</span><span class="p">,</span> <span class="s2">&quot;pymatgen_molecule&quot;</span><span class="p">),</span>
                              <span class="p">(</span><span class="s2">&quot;pbc&quot;</span><span class="p">,</span> <span class="s2">&quot;pymatgen_structure&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;pymatgen&quot;</span><span class="p">,</span> <span class="s2">&quot;pymatgen_molecule&quot;</span><span class="p">),</span>
                              <span class="p">(</span><span class="s2">&quot;pymatgen&quot;</span><span class="p">,</span> <span class="s2">&quot;pymatgen_structure&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;pymatgen_molecule&quot;</span><span class="p">,</span> <span class="s2">&quot;pymatgen_structure&quot;</span><span class="p">)]</span>

    <span class="n">_dimensionality_label</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s2">&quot;length&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s2">&quot;surface&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="s2">&quot;volume&quot;</span><span class="p">}</span>

<div class="viewcode-block" id="StructureData.__init__"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.StructureData.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cell</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pbc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ase</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pymatgen</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pymatgen_structure</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pymatgen_molecule</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="n">args</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;cell&#39;</span><span class="p">:</span> <span class="n">cell</span><span class="p">,</span>
            <span class="s1">&#39;pbc&#39;</span><span class="p">:</span> <span class="n">pbc</span><span class="p">,</span>
            <span class="s1">&#39;ase&#39;</span><span class="p">:</span> <span class="n">ase</span><span class="p">,</span>
            <span class="s1">&#39;pymatgen&#39;</span><span class="p">:</span> <span class="n">pymatgen</span><span class="p">,</span>
            <span class="s1">&#39;pymatgen_structure&#39;</span><span class="p">:</span> <span class="n">pymatgen_structure</span><span class="p">,</span>
            <span class="s1">&#39;pymatgen_molecule&#39;</span><span class="p">:</span> <span class="n">pymatgen_molecule</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_incompatibilities</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">args</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">args</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;cannot pass </span><span class="si">{}</span><span class="s1"> and </span><span class="si">{}</span><span class="s1"> at the same time&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">))</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">StructureData</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">ext</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">ext</span> <span class="ow">in</span> <span class="p">[</span><span class="n">ase</span><span class="p">,</span> <span class="n">pymatgen</span><span class="p">,</span> <span class="n">pymatgen_structure</span><span class="p">,</span> <span class="n">pymatgen_molecule</span><span class="p">]]):</span>

            <span class="k">if</span> <span class="n">ase</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_ase</span><span class="p">(</span><span class="n">ase</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">pymatgen</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_pymatgen</span><span class="p">(</span><span class="n">pymatgen</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">pymatgen_structure</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_pymatgen_structure</span><span class="p">(</span><span class="n">pymatgen_structure</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">pymatgen_molecule</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_pymatgen_molecule</span><span class="p">(</span><span class="n">pymatgen_molecule</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cell</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">cell</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">]]</span>

            <span class="k">if</span> <span class="n">pbc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">pbc</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">set_cell</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_pbc</span><span class="p">(</span><span class="n">pbc</span><span class="p">)</span></div>

<div class="viewcode-block" id="StructureData.get_dimensionality"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.StructureData.get_dimensionality">[docs]</a>    <span class="k">def</span> <span class="nf">get_dimensionality</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function checks the dimensionality of the structure and</span>
<span class="sd">        calculates its length/surface/volume</span>
<span class="sd">        :return: returns the dimensionality and length/surface/volume</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

        <span class="n">retdict</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">cell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">)</span>
        <span class="n">pbc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pbc</span><span class="p">)</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pbc</span><span class="p">[</span><span class="n">pbc</span><span class="p">])</span>

        <span class="n">retdict</span><span class="p">[</span><span class="s1">&#39;dim&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dim</span>
        <span class="n">retdict</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dimensionality_label</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">cell</span><span class="p">[</span><span class="n">pbc</span><span class="p">]</span>
            <span class="n">retdict</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">vectors</span> <span class="o">=</span> <span class="n">cell</span><span class="p">[</span><span class="n">pbc</span><span class="p">]</span>
            <span class="n">retdict</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">vectors</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">vectors</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">elif</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">retdict</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">cell</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">cell</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">cell</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Dimensionality </span><span class="si">{}</span><span class="s2"> must be &lt;= 3&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dim</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">retdict</span></div>

<div class="viewcode-block" id="StructureData.set_ase"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.StructureData.set_ase">[docs]</a>    <span class="k">def</span> <span class="nf">set_ase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aseatoms</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load the structure from a ASE object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">is_ase_atoms</span><span class="p">(</span><span class="n">aseatoms</span><span class="p">):</span>
            <span class="c1"># Read the ase structure</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cell</span> <span class="o">=</span> <span class="n">aseatoms</span><span class="o">.</span><span class="n">cell</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pbc</span> <span class="o">=</span> <span class="n">aseatoms</span><span class="o">.</span><span class="n">pbc</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">clear_kinds</span><span class="p">()</span>  <span class="c1"># This also calls clear_sites</span>
            <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">aseatoms</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">append_atom</span><span class="p">(</span><span class="n">ase</span><span class="o">=</span><span class="n">atom</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The value is not an ase.Atoms object&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="StructureData.set_pymatgen"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.StructureData.set_pymatgen">[docs]</a>    <span class="k">def</span> <span class="nf">set_pymatgen</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load the structure from a pymatgen object.</span>

<span class="sd">        .. note:: Requires the pymatgen module (version &gt;= 3.0.13, usage</span>
<span class="sd">            of earlier versions may cause errors).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">typestr</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;set_pymatgen_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">typestr</span><span class="o">.</span><span class="n">lower</span><span class="p">()))</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;Converter for &#39;</span><span class="si">{}</span><span class="s2">&#39; to AiiDA structure does not exist&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">typestr</span><span class="p">))</span>
        <span class="n">func</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="StructureData.set_pymatgen_molecule"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.StructureData.set_pymatgen_molecule">[docs]</a>    <span class="k">def</span> <span class="nf">set_pymatgen_molecule</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mol</span><span class="p">,</span> <span class="n">margin</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load the structure from a pymatgen Molecule object.</span>

<span class="sd">        :param margin: the margin to be added in all directions of the</span>
<span class="sd">            bounding box of the molecule.</span>

<span class="sd">        .. note:: Requires the pymatgen module (version &gt;= 3.0.13, usage</span>
<span class="sd">            of earlier versions may cause errors).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">box</span> <span class="o">=</span> <span class="p">[</span>
            <span class="nb">max</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">tolist</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">mol</span><span class="o">.</span><span class="n">sites</span><span class="p">])</span> <span class="o">-</span> <span class="nb">min</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">tolist</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">mol</span><span class="o">.</span><span class="n">sites</span>
                                                                 <span class="p">])</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">margin</span><span class="p">,</span>
            <span class="nb">max</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">tolist</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">mol</span><span class="o">.</span><span class="n">sites</span><span class="p">])</span> <span class="o">-</span> <span class="nb">min</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">tolist</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">mol</span><span class="o">.</span><span class="n">sites</span><span class="p">])</span> <span class="o">+</span>
            <span class="mi">2</span> <span class="o">*</span> <span class="n">margin</span><span class="p">,</span>
            <span class="nb">max</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">tolist</span><span class="p">()[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">mol</span><span class="o">.</span><span class="n">sites</span><span class="p">])</span> <span class="o">-</span> <span class="nb">min</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">tolist</span><span class="p">()[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">mol</span><span class="o">.</span><span class="n">sites</span><span class="p">])</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">margin</span>
        <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_pymatgen_structure</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">get_boxed_structure</span><span class="p">(</span><span class="o">*</span><span class="n">box</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pbc</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">]</span></div>

<div class="viewcode-block" id="StructureData.set_pymatgen_structure"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.StructureData.set_pymatgen_structure">[docs]</a>    <span class="k">def</span> <span class="nf">set_pymatgen_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">struct</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load the structure from a pymatgen Structure object.</span>

<span class="sd">        .. note:: periodic boundary conditions are set to True in all</span>
<span class="sd">            three directions.</span>
<span class="sd">        .. note:: Requires the pymatgen module (version &gt;= 3.3.5, usage</span>
<span class="sd">            of earlier versions may cause errors).</span>

<span class="sd">        :raise ValueError: if there are partial occupancies together with spins.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">build_kind_name</span><span class="p">(</span><span class="n">species_and_occu</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Build a kind name from a pymatgen Composition, including an additional ordinal if spin is included,</span>
<span class="sd">            e.g. it returns &#39;&lt;specie&gt;1&#39; for an atom with spin &lt; 0 and &#39;&lt;specie&gt;2&#39; for an atom with spin &gt; 0,</span>
<span class="sd">            otherwise (no spin) it returns None</span>

<span class="sd">            :param species_and_occu: a pymatgen species and occupations dictionary</span>
<span class="sd">            :return: a string representing the kind name or None</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">species</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">species_and_occu</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="n">occupations</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">species_and_occu</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

            <span class="n">has_spin</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="n">specie</span><span class="o">.</span><span class="n">as_dict</span><span class="p">()</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;properties&#39;</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;spin&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">specie</span> <span class="ow">in</span> <span class="n">species</span><span class="p">)</span>
            <span class="n">has_partial_occupancies</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">occupations</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">occupations</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mf">1.0</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">has_partial_occupancies</span> <span class="ow">and</span> <span class="n">has_spin</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot set partial occupancies and spins at the same time&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">has_spin</span><span class="p">:</span>

                <span class="n">symbols</span> <span class="o">=</span> <span class="p">[</span><span class="n">specie</span><span class="o">.</span><span class="n">symbol</span> <span class="k">for</span> <span class="n">specie</span> <span class="ow">in</span> <span class="n">species</span><span class="p">]</span>
                <span class="n">kind_name</span> <span class="o">=</span> <span class="n">create_automatic_kind_name</span><span class="p">(</span><span class="n">symbols</span><span class="p">,</span> <span class="n">occupations</span><span class="p">)</span>

                <span class="c1"># If there is spin, we can only have a single specie, otherwise we would have raised above</span>
                <span class="n">specie</span> <span class="o">=</span> <span class="n">species</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">spin</span> <span class="o">=</span> <span class="n">specie</span><span class="o">.</span><span class="n">as_dict</span><span class="p">()</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;properties&#39;</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;spin&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">spin</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">kind_name</span> <span class="o">+=</span> <span class="s1">&#39;1&#39;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">kind_name</span> <span class="o">+=</span> <span class="s1">&#39;2&#39;</span>

                <span class="k">return</span> <span class="n">kind_name</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cell</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pbc</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clear_kinds</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">struct</span><span class="o">.</span><span class="n">sites</span><span class="p">:</span>

            <span class="k">if</span> <span class="s1">&#39;kind_name&#39;</span> <span class="ow">in</span> <span class="n">site</span><span class="o">.</span><span class="n">properties</span><span class="p">:</span>
                <span class="n">kind_name</span> <span class="o">=</span> <span class="n">site</span><span class="o">.</span><span class="n">properties</span><span class="p">[</span><span class="s1">&#39;kind_name&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">kind_name</span> <span class="o">=</span> <span class="n">build_kind_name</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">species_and_occu</span><span class="p">)</span>

            <span class="n">inputs</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;symbols&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">symbol</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">site</span><span class="o">.</span><span class="n">species_and_occu</span><span class="o">.</span><span class="n">keys</span><span class="p">()],</span>
                <span class="s1">&#39;weights&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">site</span><span class="o">.</span><span class="n">species_and_occu</span><span class="o">.</span><span class="n">values</span><span class="p">()],</span>
                <span class="s1">&#39;position&#39;</span><span class="p">:</span> <span class="n">site</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="n">kind_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">inputs</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kind_name</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">append_atom</span><span class="p">(</span><span class="o">**</span><span class="n">inputs</span><span class="p">)</span></div>

<div class="viewcode-block" id="StructureData._validate"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.StructureData._validate">[docs]</a>    <span class="k">def</span> <span class="nf">_validate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs some standard validation tests.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">from</span> <span class="nn">aiida.common.exceptions</span> <span class="k">import</span> <span class="n">ValidationError</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">StructureData</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_validate</span><span class="p">()</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">_get_valid_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ValidationError</span><span class="p">(</span><span class="s2">&quot;Invalid cell: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">exc</span><span class="p">))</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">get_valid_pbc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pbc</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ValidationError</span><span class="p">(</span><span class="s2">&quot;Invalid periodic boundary conditions: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">exc</span><span class="p">))</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># This will try to create the kinds objects</span>
            <span class="n">kinds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kinds</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ValidationError</span><span class="p">(</span><span class="s2">&quot;Unable to validate the kinds: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">exc</span><span class="p">))</span>

        <span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">Counter</span>

        <span class="n">counts</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">([</span><span class="n">k</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">kinds</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">counts</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">counts</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ValidationError</span><span class="p">(</span><span class="s2">&quot;Kind with name &#39;</span><span class="si">{}</span><span class="s2">&#39; appears </span><span class="si">{}</span><span class="s2"> times &quot;</span>
                                      <span class="s2">&quot;instead of only one&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">counts</span><span class="p">[</span><span class="n">c</span><span class="p">]))</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># This will try to create the sites objects</span>
            <span class="n">sites</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ValidationError</span><span class="p">(</span><span class="s2">&quot;Unable to validate the sites: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">exc</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">sites</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">site</span><span class="o">.</span><span class="n">kind_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">k</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">kinds</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="n">ValidationError</span><span class="p">(</span><span class="s2">&quot;A site has kind </span><span class="si">{}</span><span class="s2">, but no specie with that name exists&quot;</span>
                                      <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">kind_name</span><span class="p">))</span>

        <span class="n">kinds_without_sites</span> <span class="o">=</span> <span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">kinds</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">kind_name</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sites</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">kinds_without_sites</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ValidationError</span><span class="p">(</span><span class="s2">&quot;The following kinds are defined, but there &quot;</span>
                                  <span class="s2">&quot;are no sites with that kind: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">kinds_without_sites</span><span class="p">)))</span></div>

<div class="viewcode-block" id="StructureData._prepare_xsf"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.StructureData._prepare_xsf">[docs]</a>    <span class="k">def</span> <span class="nf">_prepare_xsf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">main_file_name</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write the given structure to a string of format XSF (for XCrySDen).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_alloy</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_vacancies</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;XSF for alloys or systems with vacancies not implemented.&quot;</span><span class="p">)</span>

        <span class="n">sites</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites</span>

        <span class="n">return_string</span> <span class="o">=</span> <span class="s2">&quot;CRYSTAL</span><span class="se">\n</span><span class="s2">PRIMVEC 1</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">for</span> <span class="n">cell_vector</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">:</span>
            <span class="n">return_string</span> <span class="o">+=</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;</span><span class="si">%18.10f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">cell_vector</span><span class="p">])</span>
            <span class="n">return_string</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">return_string</span> <span class="o">+=</span> <span class="s2">&quot;PRIMCOORD 1</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">return_string</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> 1</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">sites</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">sites</span><span class="p">:</span>
            <span class="c1"># I checked above that it is not an alloy, therefore I take the</span>
            <span class="c1"># first symbol</span>
            <span class="n">return_string</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> &quot;</span> <span class="o">%</span> <span class="n">_atomic_numbers</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_kind</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">kind_name</span><span class="p">)</span><span class="o">.</span><span class="n">symbols</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">return_string</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">%18.10f</span><span class="s2"> </span><span class="si">%18.10f</span><span class="s2"> </span><span class="si">%18.10f</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">position</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">return_string</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">),</span> <span class="p">{}</span></div>

<div class="viewcode-block" id="StructureData._prepare_cif"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.StructureData._prepare_cif">[docs]</a>    <span class="k">def</span> <span class="nf">_prepare_cif</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">main_file_name</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write the given structure to a string of format CIF.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">aiida.orm</span> <span class="k">import</span> <span class="n">CifData</span>

        <span class="n">cif</span> <span class="o">=</span> <span class="n">CifData</span><span class="p">(</span><span class="n">ase</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_ase</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">cif</span><span class="o">.</span><span class="n">_prepare_cif</span><span class="p">()</span></div>

<div class="viewcode-block" id="StructureData._prepare_chemdoodle"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.StructureData._prepare_chemdoodle">[docs]</a>    <span class="k">def</span> <span class="nf">_prepare_chemdoodle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">main_file_name</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write the given structure to a string of format required by ChemDoodle.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
        <span class="kn">from</span> <span class="nn">itertools</span> <span class="k">import</span> <span class="n">product</span>

        <span class="kn">from</span> <span class="nn">aiida.common</span> <span class="k">import</span> <span class="n">json</span>

        <span class="n">supercell_factors</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Get cell vectors and atomic position</span>
        <span class="n">lattice_vectors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="s1">&#39;cell&#39;</span><span class="p">))</span>
        <span class="n">base_sites</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="s1">&#39;sites&#39;</span><span class="p">)</span>

        <span class="n">start1</span> <span class="o">=</span> <span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="n">supercell_factors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">start2</span> <span class="o">=</span> <span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="n">supercell_factors</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">start3</span> <span class="o">=</span> <span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="n">supercell_factors</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">stop1</span> <span class="o">=</span> <span class="n">start1</span> <span class="o">+</span> <span class="n">supercell_factors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">stop2</span> <span class="o">=</span> <span class="n">start2</span> <span class="o">+</span> <span class="n">supercell_factors</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">stop3</span> <span class="o">=</span> <span class="n">start3</span> <span class="o">+</span> <span class="n">supercell_factors</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

        <span class="n">grid1</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">start1</span><span class="p">,</span> <span class="n">stop1</span><span class="p">)</span>
        <span class="n">grid2</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">start2</span><span class="p">,</span> <span class="n">stop2</span><span class="p">)</span>
        <span class="n">grid3</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">start3</span><span class="p">,</span> <span class="n">stop3</span><span class="p">)</span>

        <span class="n">atoms_json</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Manual recenter of the structure</span>
        <span class="n">center</span> <span class="o">=</span> <span class="p">(</span><span class="n">lattice_vectors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">lattice_vectors</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">lattice_vectors</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="mf">2.</span>

        <span class="k">for</span> <span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">iz</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="n">grid1</span><span class="p">,</span> <span class="n">grid2</span><span class="p">,</span> <span class="n">grid3</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">base_site</span> <span class="ow">in</span> <span class="n">base_sites</span><span class="p">:</span>
                <span class="n">shift</span> <span class="o">=</span> <span class="p">(</span><span class="n">ix</span> <span class="o">*</span> <span class="n">lattice_vectors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">iy</span> <span class="o">*</span> <span class="n">lattice_vectors</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> \
                         <span class="n">iz</span> <span class="o">*</span> <span class="n">lattice_vectors</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">center</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

                <span class="n">kind_name</span> <span class="o">=</span> <span class="n">base_site</span><span class="p">[</span><span class="s1">&#39;kind_name&#39;</span><span class="p">]</span>
                <span class="n">kind_string</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_kind</span><span class="p">(</span><span class="n">kind_name</span><span class="p">)</span><span class="o">.</span><span class="n">get_symbols_string</span><span class="p">()</span>

                <span class="n">atoms_json</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                    <span class="s1">&#39;l&#39;</span><span class="p">:</span> <span class="n">kind_string</span><span class="p">,</span>
                    <span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="n">base_site</span><span class="p">[</span><span class="s1">&#39;position&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">shift</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="n">base_site</span><span class="p">[</span><span class="s1">&#39;position&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">shift</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                    <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="n">base_site</span><span class="p">[</span><span class="s1">&#39;position&#39;</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">shift</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                    <span class="c1"># &#39;atomic_elements_html&#39;: kind_string</span>
                    <span class="s1">&#39;atomic_elements_html&#39;</span><span class="p">:</span> <span class="n">atom_kinds_to_html</span><span class="p">(</span><span class="n">kind_string</span><span class="p">)</span>
                <span class="p">})</span>

        <span class="n">cell_json</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;t&quot;</span><span class="p">:</span> <span class="s2">&quot;UnitCell&quot;</span><span class="p">,</span>
            <span class="s2">&quot;i&quot;</span><span class="p">:</span> <span class="s2">&quot;s0&quot;</span><span class="p">,</span>
            <span class="s2">&quot;o&quot;</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="n">center</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
            <span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">lattice_vectors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">center</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
            <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">lattice_vectors</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">center</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
            <span class="s2">&quot;z&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">lattice_vectors</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">center</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
            <span class="s2">&quot;xy&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">lattice_vectors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">lattice_vectors</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">center</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
            <span class="s2">&quot;xz&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">lattice_vectors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">lattice_vectors</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">center</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
            <span class="s2">&quot;yz&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">lattice_vectors</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">lattice_vectors</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">center</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
            <span class="s2">&quot;xyz&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">lattice_vectors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">lattice_vectors</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">lattice_vectors</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">center</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
        <span class="p">}</span>

        <span class="n">return_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;s&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">cell_json</span><span class="p">],</span> <span class="s2">&quot;m&quot;</span><span class="p">:</span> <span class="p">[{</span><span class="s2">&quot;a&quot;</span><span class="p">:</span> <span class="n">atoms_json</span><span class="p">}],</span> <span class="s2">&quot;units&quot;</span><span class="p">:</span> <span class="s1">&#39;&amp;Aring;&#39;</span><span class="p">}</span>

        <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">return_dict</span><span class="p">),</span> <span class="p">{}</span></div>

<div class="viewcode-block" id="StructureData._prepare_xyz"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.StructureData._prepare_xyz">[docs]</a>    <span class="k">def</span> <span class="nf">_prepare_xyz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">main_file_name</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write the given structure to a string of format XYZ.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_alloy</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_vacancies</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;XYZ for alloys or systems with vacancies not implemented.&quot;</span><span class="p">)</span>

        <span class="n">sites</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites</span>
        <span class="n">cell</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span>

        <span class="n">return_list</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sites</span><span class="p">))]</span>
        <span class="n">return_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;Lattice=&quot;</span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1">&quot; pbc=&quot;</span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1">&quot;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">cell</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">cell</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">cell</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> <span class="n">cell</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">cell</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">cell</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> <span class="n">cell</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">cell</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">cell</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pbc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">pbc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">pbc</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
        <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">sites</span><span class="p">:</span>
            <span class="c1"># I checked above that it is not an alloy, therefore I take the</span>
            <span class="c1"># first symbol</span>
            <span class="n">return_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{:6s}</span><span class="s2"> </span><span class="si">{:18.10f}</span><span class="s2"> </span><span class="si">{:18.10f}</span><span class="s2"> </span><span class="si">{:18.10f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_kind</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">kind_name</span><span class="p">)</span><span class="o">.</span><span class="n">symbols</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">site</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">site</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">site</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>

        <span class="n">return_string</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">return_list</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">return_string</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">),</span> <span class="p">{}</span></div>

<div class="viewcode-block" id="StructureData._parse_xyz"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.StructureData._parse_xyz">[docs]</a>    <span class="k">def</span> <span class="nf">_parse_xyz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputstring</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read the structure from a string of format XYZ.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">aiida.tools.data.structure</span> <span class="k">import</span> <span class="n">xyz_parser_iterator</span>

        <span class="c1"># idiom to get to the last block</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">atoms</span> <span class="ow">in</span> <span class="n">xyz_parser_iterator</span><span class="p">(</span><span class="n">inputstring</span><span class="p">):</span>
            <span class="k">pass</span>

        <span class="k">if</span> <span class="n">atoms</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The data does not contain any XYZ data&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">clear_kinds</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pbc</span> <span class="o">=</span> <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">sym</span><span class="p">,</span> <span class="n">position</span> <span class="ow">in</span> <span class="n">atoms</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">append_atom</span><span class="p">(</span><span class="n">symbols</span><span class="o">=</span><span class="n">sym</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="n">position</span><span class="p">)</span></div>

<div class="viewcode-block" id="StructureData._adjust_default_cell"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.StructureData._adjust_default_cell">[docs]</a>    <span class="k">def</span> <span class="nf">_adjust_default_cell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vacuum_factor</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">vacuum_addition</span><span class="o">=</span><span class="mf">10.0</span><span class="p">,</span> <span class="n">pbc</span><span class="o">=</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">)):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If the structure was imported from an xyz file, it lacks a defined cell,</span>
<span class="sd">        and the default cell is taken ([[1,0,0], [0,1,0], [0,0,1]]),</span>
<span class="sd">        leading to an unphysical definition of the structure.</span>
<span class="sd">        This method will adjust the cell</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
        <span class="kn">from</span> <span class="nn">ase.visualize</span> <span class="k">import</span> <span class="n">view</span>

        <span class="k">def</span> <span class="nf">get_extremas_from_positions</span><span class="p">(</span><span class="n">positions</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            returns the minimum and maximum value for each dimension in the positions given</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="p">[(</span><span class="nb">min</span><span class="p">(</span><span class="n">values</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">values</span><span class="p">))</span> <span class="k">for</span> <span class="n">values</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">positions</span><span class="p">)]))</span>

        <span class="c1"># First, set PBC</span>
        <span class="c1"># All the checks are done in get_valid_pbc called by set_pbc, no need to check anything here</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_pbc</span><span class="p">(</span><span class="n">pbc</span><span class="p">)</span>

        <span class="c1"># Calculating the minimal cell:</span>
        <span class="n">positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">site</span><span class="o">.</span><span class="n">position</span> <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">])</span>
        <span class="n">position_min</span><span class="p">,</span> <span class="n">position_max</span> <span class="o">=</span> <span class="n">get_extremas_from_positions</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span>

        <span class="c1"># Translate the structure to the origin, such that the minimal values in each dimension</span>
        <span class="c1"># amount to (0,0,0)</span>
        <span class="n">positions</span> <span class="o">-=</span> <span class="n">position_min</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">site</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="s1">&#39;sites&#39;</span><span class="p">)):</span>
            <span class="n">site</span><span class="p">[</span><span class="s1">&#39;position&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">positions</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>

        <span class="c1"># The orthorhombic cell that (just) accomodates the whole structure is now given by the</span>
        <span class="c1"># extremas of position in each dimension:</span>
        <span class="n">minimal_orthorhombic_cell_dimensions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">get_extremas_from_positions</span><span class="p">(</span><span class="n">positions</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">minimal_orthorhombic_cell_dimensions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vacuum_factor</span><span class="p">,</span> <span class="n">minimal_orthorhombic_cell_dimensions</span><span class="p">)</span>
        <span class="n">minimal_orthorhombic_cell_dimensions</span> <span class="o">+=</span> <span class="n">vacuum_addition</span>

        <span class="c1"># Transform the vector (a, b, c ) to [[a,0,0], [0,b,0], [0,0,c]]</span>
        <span class="n">newcell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">minimal_orthorhombic_cell_dimensions</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_cell</span><span class="p">(</span><span class="n">newcell</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span></div>

<div class="viewcode-block" id="StructureData.get_description"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.StructureData.get_description">[docs]</a>    <span class="k">def</span> <span class="nf">get_description</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a string with infos retrieved from StructureData node&#39;s properties</span>

<span class="sd">        :param self: the StructureData node</span>
<span class="sd">        :return: retsrt: the description string</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_formula</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;hill_compact&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="StructureData.get_symbols_set"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.StructureData.get_symbols_set">[docs]</a>    <span class="k">def</span> <span class="nf">get_symbols_set</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a set containing the names of all elements involved in</span>
<span class="sd">        this structure (i.e., for it joins the list of symbols for each</span>
<span class="sd">        kind k in the structure).</span>

<span class="sd">        :returns: a set of strings of element names.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">kind</span><span class="o">.</span><span class="n">symbols</span> <span class="k">for</span> <span class="n">kind</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">kinds</span><span class="p">))</span></div>

<div class="viewcode-block" id="StructureData.get_formula"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.StructureData.get_formula">[docs]</a>    <span class="k">def</span> <span class="nf">get_formula</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;hill&#39;</span><span class="p">,</span> <span class="n">separator</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a string with the chemical formula.</span>

<span class="sd">        :param mode: a string to specify how to generate the formula, can</span>
<span class="sd">            assume one of the following values:</span>

<span class="sd">            * &#39;hill&#39; (default): count the number of atoms of each species,</span>
<span class="sd">              then use Hill notation, i.e. alphabetical order with C and H</span>
<span class="sd">              first if one or several C atom(s) is (are) present, e.g.</span>
<span class="sd">              ``[&#39;C&#39;,&#39;H&#39;,&#39;H&#39;,&#39;H&#39;,&#39;O&#39;,&#39;C&#39;,&#39;H&#39;,&#39;H&#39;,&#39;H&#39;]`` will return ``&#39;C2H6O&#39;``</span>
<span class="sd">              ``[&#39;S&#39;,&#39;O&#39;,&#39;O&#39;,&#39;H&#39;,&#39;O&#39;,&#39;H&#39;,&#39;O&#39;]``  will return ``&#39;H2O4S&#39;``</span>
<span class="sd">              From E. A. Hill, J. Am. Chem. Soc., 22 (8), pp 478–494 (1900)</span>

<span class="sd">            * &#39;hill_compact&#39;: same as hill but the number of atoms for each</span>
<span class="sd">              species is divided by the greatest common divisor of all of them, e.g.</span>
<span class="sd">              ``[&#39;C&#39;,&#39;H&#39;,&#39;H&#39;,&#39;H&#39;,&#39;O&#39;,&#39;C&#39;,&#39;H&#39;,&#39;H&#39;,&#39;H&#39;,&#39;O&#39;,&#39;O&#39;,&#39;O&#39;]``</span>
<span class="sd">              will return ``&#39;CH3O2&#39;``</span>

<span class="sd">            * &#39;reduce&#39;: group repeated symbols e.g.</span>
<span class="sd">              ``[&#39;Ba&#39;, &#39;Ti&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;, &#39;Ba&#39;, &#39;Ti&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;,</span>
<span class="sd">              &#39;Ba&#39;, &#39;Ti&#39;, &#39;Ti&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;]`` will return ``&#39;BaTiO3BaTiO3BaTi2O3&#39;``</span>

<span class="sd">            * &#39;group&#39;: will try to group as much as possible parts of the formula</span>
<span class="sd">              e.g.</span>
<span class="sd">              ``[&#39;Ba&#39;, &#39;Ti&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;, &#39;Ba&#39;, &#39;Ti&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;,</span>
<span class="sd">              &#39;Ba&#39;, &#39;Ti&#39;, &#39;Ti&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;]`` will return ``&#39;(BaTiO3)2BaTi2O3&#39;``</span>

<span class="sd">            * &#39;count&#39;: same as hill (i.e. one just counts the number</span>
<span class="sd">              of atoms of each species) without the re-ordering (take the</span>
<span class="sd">              order of the atomic sites), e.g.</span>
<span class="sd">              ``[&#39;Ba&#39;, &#39;Ti&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;,&#39;Ba&#39;, &#39;Ti&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;]``</span>
<span class="sd">              will return ``&#39;Ba2Ti2O6&#39;``</span>

<span class="sd">            * &#39;count_compact&#39;: same as count but the number of atoms</span>
<span class="sd">              for each species is divided by the greatest common divisor of</span>
<span class="sd">              all of them, e.g.</span>
<span class="sd">              ``[&#39;Ba&#39;, &#39;Ti&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;,&#39;Ba&#39;, &#39;Ti&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;]``</span>
<span class="sd">              will return ``&#39;BaTiO3&#39;``</span>

<span class="sd">        :param separator: a string used to concatenate symbols. Default empty.</span>

<span class="sd">        :return: a string with the formula</span>

<span class="sd">        .. note:: in modes reduce, group, count and count_compact, the</span>
<span class="sd">            initial order in which the atoms were appended by the user is</span>
<span class="sd">            used to group and/or order the symbols in the formula</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">symbol_list</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_kind</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">kind_name</span><span class="p">)</span><span class="o">.</span><span class="n">get_symbols_string</span><span class="p">()</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">get_formula</span><span class="p">(</span><span class="n">symbol_list</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">separator</span><span class="o">=</span><span class="n">separator</span><span class="p">)</span></div>

<div class="viewcode-block" id="StructureData.get_site_kindnames"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.StructureData.get_site_kindnames">[docs]</a>    <span class="k">def</span> <span class="nf">get_site_kindnames</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list with length equal to the number of sites of this structure,</span>
<span class="sd">        where each element of the list is the kind name of the corresponding site.</span>

<span class="sd">        .. note:: This is NOT necessarily a list of chemical symbols! Use</span>
<span class="sd">            ``[ self.get_kind(s.kind_name).get_symbols_string() for s in self.sites]``</span>
<span class="sd">            for chemical symbols</span>

<span class="sd">        :return: a list of strings</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">this_site</span><span class="o">.</span><span class="n">kind_name</span> <span class="k">for</span> <span class="n">this_site</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">]</span></div>

<div class="viewcode-block" id="StructureData.get_composition"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.StructureData.get_composition">[docs]</a>    <span class="k">def</span> <span class="nf">get_composition</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the chemical composition of this structure as a dictionary,</span>
<span class="sd">        where each key is the kind symbol (e.g. H, Li, Ba),</span>
<span class="sd">        and each value is the number of occurences of that element in this</span>
<span class="sd">        structure. For BaZrO3 it would return {&#39;Ba&#39;:1, &#39;Zr&#39;:1, &#39;O&#39;:3}.</span>
<span class="sd">        No reduction with smallest common divisor!</span>

<span class="sd">        :returns: a dictionary with the composition</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">symbols_list</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_kind</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">kind_name</span><span class="p">)</span><span class="o">.</span><span class="n">get_symbols_string</span><span class="p">()</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">]</span>
        <span class="n">composition</span> <span class="o">=</span> <span class="p">{</span><span class="n">symbol</span><span class="p">:</span> <span class="n">symbols_list</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">symbol</span><span class="p">)</span> <span class="k">for</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">symbols_list</span><span class="p">)}</span>
        <span class="k">return</span> <span class="n">composition</span></div>

<div class="viewcode-block" id="StructureData.get_ase"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.StructureData.get_ase">[docs]</a>    <span class="k">def</span> <span class="nf">get_ase</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the ASE object.</span>
<span class="sd">        Requires to be able to import ase.</span>

<span class="sd">        :return: an ASE object corresponding to this</span>
<span class="sd">          :py:class:`StructureData &lt;aiida.orm.nodes.data.structure.StructureData&gt;`</span>
<span class="sd">          object.</span>

<span class="sd">        .. note:: If any site is an alloy or has vacancies, a ValueError</span>
<span class="sd">            is raised (from the site.get_ase() routine).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_object_ase</span><span class="p">()</span></div>

<div class="viewcode-block" id="StructureData.get_pymatgen"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.StructureData.get_pymatgen">[docs]</a>    <span class="k">def</span> <span class="nf">get_pymatgen</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get pymatgen object. Returns Structure for structures with</span>
<span class="sd">        periodic boundary conditions (in three dimensions) and Molecule</span>
<span class="sd">        otherwise.</span>
<span class="sd">        :param add_spin: True to add the spins to the pymatgen structure.</span>
<span class="sd">        Default is False (no spin added).</span>

<span class="sd">        .. note:: The spins are set according to the following rule:</span>
<span class="sd">            </span>
<span class="sd">            * if the kind name ends with 1 -&gt; spin=+1</span>
<span class="sd">            </span>
<span class="sd">            * if the kind name ends with 2 -&gt; spin=-1</span>

<span class="sd">        .. note:: Requires the pymatgen module (version &gt;= 3.0.13, usage</span>
<span class="sd">            of earlier versions may cause errors).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_object_pymatgen</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="StructureData.get_pymatgen_structure"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.StructureData.get_pymatgen_structure">[docs]</a>    <span class="k">def</span> <span class="nf">get_pymatgen_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the pymatgen Structure object.</span>
<span class="sd">        :param add_spin: True to add the spins to the pymatgen structure.</span>
<span class="sd">        Default is False (no spin added).</span>

<span class="sd">        .. note:: The spins are set according to the following rule:</span>
<span class="sd">            </span>
<span class="sd">            * if the kind name ends with 1 -&gt; spin=+1</span>
<span class="sd">            </span>
<span class="sd">            * if the kind name ends with 2 -&gt; spin=-1</span>

<span class="sd">        .. note:: Requires the pymatgen module (version &gt;= 3.0.13, usage</span>
<span class="sd">            of earlier versions may cause errors).</span>

<span class="sd">        :return: a pymatgen Structure object corresponding to this</span>
<span class="sd">          :py:class:`StructureData &lt;aiida.orm.nodes.data.structure.StructureData&gt;`</span>
<span class="sd">          object.</span>
<span class="sd">        :raise ValueError: if periodic boundary conditions do not hold</span>
<span class="sd">          in at least one dimension of real space.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_object_pymatgen_structure</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="StructureData.get_pymatgen_molecule"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.StructureData.get_pymatgen_molecule">[docs]</a>    <span class="k">def</span> <span class="nf">get_pymatgen_molecule</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the pymatgen Molecule object.</span>

<span class="sd">        .. note:: Requires the pymatgen module (version &gt;= 3.0.13, usage</span>
<span class="sd">            of earlier versions may cause errors).</span>

<span class="sd">        :return: a pymatgen Molecule object corresponding to this</span>
<span class="sd">          :py:class:`StructureData &lt;aiida.orm.nodes.data.structure.StructureData&gt;`</span>
<span class="sd">          object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_object_pymatgen_molecule</span><span class="p">()</span></div>

<div class="viewcode-block" id="StructureData.append_kind"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.StructureData.append_kind">[docs]</a>    <span class="k">def</span> <span class="nf">append_kind</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kind</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Append a kind to the</span>
<span class="sd">        :py:class:`StructureData &lt;aiida.orm.nodes.data.structure.StructureData&gt;`.</span>
<span class="sd">        It makes a copy of the kind.</span>

<span class="sd">        :param kind: the site to append, must be a Kind object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">aiida.common.exceptions</span> <span class="k">import</span> <span class="n">ModificationNotAllowed</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_stored</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ModificationNotAllowed</span><span class="p">(</span><span class="s2">&quot;The StructureData object cannot be modified, it has already been stored&quot;</span><span class="p">)</span>

        <span class="n">new_kind</span> <span class="o">=</span> <span class="n">Kind</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">)</span>  <span class="c1"># So we make a copy</span>

        <span class="k">if</span> <span class="n">kind</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="n">k</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">kinds</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;A kind with the same name (</span><span class="si">{}</span><span class="s2">) already exists.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">kind</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

        <span class="c1"># If here, no exceptions have been raised, so I add the site.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">append_to_attr</span><span class="p">(</span><span class="s1">&#39;kinds&#39;</span><span class="p">,</span> <span class="n">new_kind</span><span class="o">.</span><span class="n">get_raw</span><span class="p">())</span>
        <span class="c1"># Note, this is a dict (with integer keys) so it allows for empty</span>
        <span class="c1"># spots!</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_internal_kind_tags&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_internal_kind_tags</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_internal_kind_tags</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="s1">&#39;kinds&#39;</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">kind</span><span class="o">.</span><span class="n">_internal_tag</span></div>

<div class="viewcode-block" id="StructureData.append_site"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.StructureData.append_site">[docs]</a>    <span class="k">def</span> <span class="nf">append_site</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">site</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Append a site to the</span>
<span class="sd">        :py:class:`StructureData &lt;aiida.orm.nodes.data.structure.StructureData&gt;`.</span>
<span class="sd">        It makes a copy of the site.</span>

<span class="sd">        :param site: the site to append. It must be a Site object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">aiida.common.exceptions</span> <span class="k">import</span> <span class="n">ModificationNotAllowed</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_stored</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ModificationNotAllowed</span><span class="p">(</span><span class="s2">&quot;The StructureData object cannot be modified, it has already been stored&quot;</span><span class="p">)</span>

        <span class="n">new_site</span> <span class="o">=</span> <span class="n">Site</span><span class="p">(</span><span class="n">site</span><span class="o">=</span><span class="n">site</span><span class="p">)</span>  <span class="c1"># So we make a copy</span>

        <span class="k">if</span> <span class="n">site</span><span class="o">.</span><span class="n">kind_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">k</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">kinds</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No kind with name &#39;</span><span class="si">{}</span><span class="s2">&#39;, available kinds are: &quot;</span>
                             <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">kind_name</span><span class="p">,</span> <span class="p">[</span><span class="n">k</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">kinds</span><span class="p">]))</span>

        <span class="c1"># If here, no exceptions have been raised, so I add the site.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">append_to_attr</span><span class="p">(</span><span class="s1">&#39;sites&#39;</span><span class="p">,</span> <span class="n">new_site</span><span class="o">.</span><span class="n">get_raw</span><span class="p">())</span></div>

<div class="viewcode-block" id="StructureData.append_atom"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.StructureData.append_atom">[docs]</a>    <span class="k">def</span> <span class="nf">append_atom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Append an atom to the Structure, taking care of creating the</span>
<span class="sd">        corresponding kind.</span>

<span class="sd">        :param ase: the ase Atom object from which we want to create a new atom</span>
<span class="sd">                (if present, this must be the only parameter)</span>
<span class="sd">        :param position: the position of the atom (three numbers in angstrom)</span>
<span class="sd">        :param symbols: passed to the constructor of the Kind object.</span>
<span class="sd">        :param weights: passed to the constructor of the Kind object.</span>
<span class="sd">        :param name: passed to the constructor of the Kind object. See also the note below.</span>

<span class="sd">        .. note :: Note on the &#39;name&#39; parameter (that is, the name of the kind):</span>

<span class="sd">            * if specified, no checks are done on existing species. Simply,</span>
<span class="sd">              a new kind with that name is created. If there is a name</span>
<span class="sd">              clash, a check is done: if the kinds are identical, no error</span>
<span class="sd">              is issued; otherwise, an error is issued because you are trying</span>
<span class="sd">              to store two different kinds with the same name.</span>

<span class="sd">            * if not specified, the name is automatically generated. Before</span>
<span class="sd">              adding the kind, a check is done. If other species with the</span>
<span class="sd">              same properties already exist, no new kinds are created, but</span>
<span class="sd">              the site is added to the existing (identical) kind.</span>
<span class="sd">              (Actually, the first kind that is encountered).</span>
<span class="sd">              Otherwise, the name is made unique first, by adding to the string</span>
<span class="sd">              containing the list of chemical symbols a number starting from 1,</span>
<span class="sd">              until an unique name is found</span>

<span class="sd">        .. note :: checks of equality of species are done using</span>
<span class="sd">          the :py:meth:`~aiida.orm.nodes.data.structure.Kind.compare_with` method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">aseatom</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;ase&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">aseatom</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;If you pass &#39;ase&#39; as a parameter to &quot;</span>
                                 <span class="s2">&quot;append_atom, you cannot pass any further&quot;</span>
                                 <span class="s2">&quot;parameter&quot;</span><span class="p">)</span>
            <span class="n">position</span> <span class="o">=</span> <span class="n">aseatom</span><span class="o">.</span><span class="n">position</span>
            <span class="n">kind</span> <span class="o">=</span> <span class="n">Kind</span><span class="p">(</span><span class="n">ase</span><span class="o">=</span><span class="n">aseatom</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">position</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;position&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">position</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;You have to specify the position of the new atom&quot;</span><span class="p">)</span>
            <span class="c1"># all remaining parameters</span>
            <span class="n">kind</span> <span class="o">=</span> <span class="n">Kind</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># I look for identical species only if the name is not specified</span>
        <span class="n">_kinds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kinds</span>

        <span class="k">if</span> <span class="s1">&#39;name&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="c1"># If the kind is identical to an existing one, I use the existing</span>
            <span class="c1"># one, otherwise I replace it</span>
            <span class="n">exists_already</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">existing_kind</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">_kinds</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">existing_kind</span><span class="o">.</span><span class="n">_internal_tag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal_kind_tags</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="c1"># self._internal_kind_tags does not contain any info for</span>
                    <span class="c1"># the kind in position idx: I don&#39;t have to add anything</span>
                    <span class="c1"># then, and I continue</span>
                    <span class="k">pass</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">kind</span><span class="o">.</span><span class="n">compare_with</span><span class="p">(</span><span class="n">existing_kind</span><span class="p">)[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="n">kind</span> <span class="o">=</span> <span class="n">existing_kind</span>
                    <span class="n">exists_already</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">exists_already</span><span class="p">:</span>
                <span class="c1"># There is not an identical kind.</span>
                <span class="c1"># By default, the name of &#39;kind&#39; just contains the elements.</span>
                <span class="c1"># I then check that the name of &#39;kind&#39; does not already exist,</span>
                <span class="c1"># and if it exists I add a number (starting from 1) until I</span>
                <span class="c1"># find a non-used name.</span>
                <span class="n">existing_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">_kinds</span><span class="p">]</span>
                <span class="n">simplename</span> <span class="o">=</span> <span class="n">kind</span><span class="o">.</span><span class="n">name</span>
                <span class="n">counter</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">while</span> <span class="n">kind</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">existing_names</span><span class="p">:</span>
                    <span class="n">kind</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">simplename</span><span class="p">,</span> <span class="n">counter</span><span class="p">)</span>
                    <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">append_kind</span><span class="p">(</span><span class="n">kind</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># &#39;name&#39; was specified</span>
            <span class="n">old_kind</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">existing_kind</span> <span class="ow">in</span> <span class="n">_kinds</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">existing_kind</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]:</span>
                    <span class="n">old_kind</span> <span class="o">=</span> <span class="n">existing_kind</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="n">old_kind</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">append_kind</span><span class="p">(</span><span class="n">kind</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">is_the_same</span><span class="p">,</span> <span class="n">firstdiff</span> <span class="o">=</span> <span class="n">kind</span><span class="o">.</span><span class="n">compare_with</span><span class="p">(</span><span class="n">old_kind</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">is_the_same</span><span class="p">:</span>
                    <span class="n">kind</span> <span class="o">=</span> <span class="n">old_kind</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;You are explicitly setting the name &quot;</span>
                                     <span class="s2">&quot;of the kind to &#39;</span><span class="si">{}</span><span class="s2">&#39;, that already &quot;</span>
                                     <span class="s2">&quot;exists, but the two kinds are different!&quot;</span>
                                     <span class="s2">&quot; (first difference: </span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">kind</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">firstdiff</span><span class="p">))</span>

        <span class="n">site</span> <span class="o">=</span> <span class="n">Site</span><span class="p">(</span><span class="n">kind_name</span><span class="o">=</span><span class="n">kind</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="n">position</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">append_site</span><span class="p">(</span><span class="n">site</span><span class="p">)</span></div>

<div class="viewcode-block" id="StructureData.clear_kinds"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.StructureData.clear_kinds">[docs]</a>    <span class="k">def</span> <span class="nf">clear_kinds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes all kinds for the StructureData object.</span>

<span class="sd">        .. note:: Also clear all sites!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">aiida.common.exceptions</span> <span class="k">import</span> <span class="n">ModificationNotAllowed</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_stored</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ModificationNotAllowed</span><span class="p">(</span><span class="s2">&quot;The StructureData object cannot be modified, it has already been stored&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="s1">&#39;kinds&#39;</span><span class="p">,</span> <span class="p">[])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_internal_kind_tags</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clear_sites</span><span class="p">()</span></div>

<div class="viewcode-block" id="StructureData.clear_sites"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.StructureData.clear_sites">[docs]</a>    <span class="k">def</span> <span class="nf">clear_sites</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes all sites for the StructureData object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">aiida.common.exceptions</span> <span class="k">import</span> <span class="n">ModificationNotAllowed</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_stored</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ModificationNotAllowed</span><span class="p">(</span><span class="s2">&quot;The StructureData object cannot be modified, it has already been stored&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="s1">&#39;sites&#39;</span><span class="p">,</span> <span class="p">[])</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sites</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of sites.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">raw_sites</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="s1">&#39;sites&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">raw_sites</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">Site</span><span class="p">(</span><span class="n">raw</span><span class="o">=</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">raw_sites</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">kinds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of kinds.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">raw_kinds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="s1">&#39;kinds&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">raw_kinds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">Kind</span><span class="p">(</span><span class="n">raw</span><span class="o">=</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">raw_kinds</span><span class="p">]</span>

<div class="viewcode-block" id="StructureData.get_kind"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.StructureData.get_kind">[docs]</a>    <span class="k">def</span> <span class="nf">get_kind</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kind_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the kind object associated with the given kind name.</span>

<span class="sd">        :param kind_name: String, the name of the kind you want to get</span>

<span class="sd">        :return: The Kind object associated with the given kind_name, if</span>
<span class="sd">           a Kind with the given name is present in the structure.</span>

<span class="sd">        :raise: ValueError if the kind_name is not present.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Cache the kinds, if stored, for efficiency</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_stored</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">kinds_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kinds_cache</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_kinds_cache</span> <span class="o">=</span> <span class="p">{</span><span class="n">_</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">_</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">kinds</span><span class="p">}</span>
                <span class="n">kinds_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kinds_cache</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">kinds_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">_</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">_</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">kinds</span><span class="p">}</span>

        <span class="c1"># Will raise ValueError if the kind is not present</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">kinds_dict</span><span class="p">[</span><span class="n">kind_name</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Kind name &#39;</span><span class="si">{}</span><span class="s2">&#39; unknown&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">kind_name</span><span class="p">))</span></div>

<div class="viewcode-block" id="StructureData.get_kind_names"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.StructureData.get_kind_names">[docs]</a>    <span class="k">def</span> <span class="nf">get_kind_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of kind names (in the same order of the ``self.kinds``</span>
<span class="sd">        property, but return the names rather than Kind objects)</span>

<span class="sd">        .. note:: This is NOT necessarily a list of chemical symbols! Use</span>
<span class="sd">            get_symbols_set for chemical symbols</span>

<span class="sd">        :return: a list of strings.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">k</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">kinds</span><span class="p">]</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cell</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the cell shape.</span>

<span class="sd">        :return: a 3x3 list of lists.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="s1">&#39;cell&#39;</span><span class="p">))</span>

    <span class="nd">@cell</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">cell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_cell</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

<div class="viewcode-block" id="StructureData.set_cell"><a class="viewcode-back" href="../../../../../apidoc/aiida.orm.nodes.data.html#aiida.backends.tests.test_dataclasses.StructureData.set_cell">[docs]</a>    <span class="k">def</span> <span class="nf">set_cell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">aiida.common.exceptions</span> <span class="k">import</span> <span class="n">ModificationNotAllowed</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_stored</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ModificationNotAllowed</span><span class="p">(</span><span class="s2">&quot;The StructureData object cannot be modified, it has already been stored&quot;</span><span class="p">)</span>

        <span class="n">the_cell</span> <span class="o">=</span> <span class="n">_get_valid_cell</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="s1">&#39;cell&#39;</span><span class="p">,</span> <span class="n">the_cell</span><span class="p">)</span></div>

<div class="viewcode-block" id="StructureData.reset_cell"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.StructureData.reset_cell">[docs]</a>    <span class="k">def</span> <span class="nf">reset_cell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_cell</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reset the cell of a structure not yet stored to a new value.</span>

<span class="sd">        :param new_cell: list specifying the cell vectors</span>

<span class="sd">        :raises:</span>
<span class="sd">            ModificationNotAllowed: if object is already stored</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">aiida.common.exceptions</span> <span class="k">import</span> <span class="n">ModificationNotAllowed</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_stored</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ModificationNotAllowed</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="s1">&#39;cell&#39;</span><span class="p">,</span> <span class="n">new_cell</span><span class="p">)</span></div>

<div class="viewcode-block" id="StructureData.reset_sites_positions"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.StructureData.reset_sites_positions">[docs]</a>    <span class="k">def</span> <span class="nf">reset_sites_positions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_positions</span><span class="p">,</span> <span class="n">conserve_particle</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Replace all the Site positions attached to the Structure</span>

<span class="sd">        :param new_positions: list of (3D) positions for every sites.</span>

<span class="sd">        :param conserve_particle: if True, allows the possibility of removing a site.</span>
<span class="sd">            currently not implemented.</span>

<span class="sd">        :raises aiida.common.ModificationNotAllowed: if object is stored already</span>
<span class="sd">        :raises ValueError: if positions are invalid</span>

<span class="sd">        .. note:: it is assumed that the order of the new_positions is</span>
<span class="sd">            given in the same order of the one it&#39;s substituting, i.e. the</span>
<span class="sd">            kind of the site will not be checked.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">aiida.common.exceptions</span> <span class="k">import</span> <span class="n">ModificationNotAllowed</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_stored</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ModificationNotAllowed</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">conserve_particle</span><span class="p">:</span>
            <span class="c1"># TODO:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="c1"># test consistency of th enew input</span>
            <span class="n">n_sites</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">n_sites</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_positions</span><span class="p">)</span> <span class="ow">and</span> <span class="n">conserve_particle</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;the new positions should be as many as the previous structure.&quot;</span><span class="p">)</span>

            <span class="n">new_sites</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_sites</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">this_pos</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">new_positions</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expecting a list of floats. Found instead </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">new_positions</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">this_pos</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expecting a list of lists of length 3. found instead </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">this_pos</span><span class="p">)))</span>

                <span class="c1"># now append this Site to the new_site list.</span>
                <span class="n">new_site</span> <span class="o">=</span> <span class="n">Site</span><span class="p">(</span><span class="n">site</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>  <span class="c1"># So we make a copy</span>
                <span class="n">new_site</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">this_pos</span><span class="p">)</span>
                <span class="n">new_sites</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_site</span><span class="p">)</span>

            <span class="c1"># now clear the old sites, and substitute with the new ones</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">clear_sites</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">this_new_site</span> <span class="ow">in</span> <span class="n">new_sites</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">append_site</span><span class="p">(</span><span class="n">this_new_site</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pbc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the periodic boundary conditions.</span>

<span class="sd">        :return: a tuple of three booleans, each one tells if there are periodic</span>
<span class="sd">            boundary conditions for the i-th real-space direction (i=1,2,3)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># return copy.deepcopy(self._pbc)</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="s1">&#39;pbc1&#39;</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="s1">&#39;pbc2&#39;</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="s1">&#39;pbc3&#39;</span><span class="p">))</span>

    <span class="nd">@pbc</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">pbc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_pbc</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

<div class="viewcode-block" id="StructureData.set_pbc"><a class="viewcode-back" href="../../../../../apidoc/aiida.orm.nodes.data.html#aiida.backends.tests.test_dataclasses.StructureData.set_pbc">[docs]</a>    <span class="k">def</span> <span class="nf">set_pbc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">aiida.common.exceptions</span> <span class="k">import</span> <span class="n">ModificationNotAllowed</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_stored</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ModificationNotAllowed</span><span class="p">(</span><span class="s2">&quot;The StructureData object cannot be modified, it has already been stored&quot;</span><span class="p">)</span>
        <span class="n">the_pbc</span> <span class="o">=</span> <span class="n">get_valid_pbc</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="c1"># self._pbc = the_pbc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="s1">&#39;pbc1&#39;</span><span class="p">,</span> <span class="n">the_pbc</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="s1">&#39;pbc2&#39;</span><span class="p">,</span> <span class="n">the_pbc</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="s1">&#39;pbc3&#39;</span><span class="p">,</span> <span class="n">the_pbc</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cell_lengths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the lengths of cell lattice vectors in angstroms.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">numpy</span>

        <span class="n">cell</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">cell</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">cell</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">cell</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
        <span class="p">]</span>

    <span class="nd">@cell_lengths</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">cell_lengths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_cell_lengths</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

<div class="viewcode-block" id="StructureData.set_cell_lengths"><a class="viewcode-back" href="../../../../../apidoc/aiida.orm.nodes.data.html#aiida.backends.tests.test_dataclasses.StructureData.set_cell_lengths">[docs]</a>    <span class="k">def</span> <span class="nf">set_cell_lengths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Modification is not implemented yet&quot;</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cell_angles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the angles between the cell lattice vectors in degrees.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">numpy</span>

        <span class="n">cell</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span>
        <span class="n">lengths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_lengths</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="nb">float</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mi">180</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span>
                <span class="n">numpy</span><span class="o">.</span><span class="n">vdot</span><span class="p">(</span><span class="n">cell</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">cell</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="n">lengths</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">lengths</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                <span class="n">numpy</span><span class="o">.</span><span class="n">vdot</span><span class="p">(</span><span class="n">cell</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cell</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="n">lengths</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">lengths</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                <span class="n">numpy</span><span class="o">.</span><span class="n">vdot</span><span class="p">(</span><span class="n">cell</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cell</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">lengths</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">lengths</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="p">]</span>
        <span class="p">]</span>

    <span class="nd">@cell_angles</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">cell_angles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_cell_angles</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

<div class="viewcode-block" id="StructureData.set_cell_angles"><a class="viewcode-back" href="../../../../../apidoc/aiida.orm.nodes.data.html#aiida.backends.tests.test_dataclasses.StructureData.set_cell_angles">[docs]</a>    <span class="k">def</span> <span class="nf">set_cell_angles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Modification is not implemented yet&quot;</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_alloy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return whether the structure contains any alloy kinds.</span>

<span class="sd">        :return: a boolean, True if at least one kind is an alloy</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">kind</span><span class="o">.</span><span class="n">is_alloy</span> <span class="k">for</span> <span class="n">kind</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">kinds</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_vacancies</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return whether the structure has vacancies in the structure.</span>

<span class="sd">        :return: a boolean, True if at least one kind has a vacancy</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">kind</span><span class="o">.</span><span class="n">has_vacancies</span> <span class="k">for</span> <span class="n">kind</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">kinds</span><span class="p">)</span>

<div class="viewcode-block" id="StructureData.get_cell_volume"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.StructureData.get_cell_volume">[docs]</a>    <span class="k">def</span> <span class="nf">get_cell_volume</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the cell volume in Angstrom^3.</span>

<span class="sd">        :return: a float.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">calc_cell_volume</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">)</span></div>

<div class="viewcode-block" id="StructureData._get_cif"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.StructureData._get_cif">[docs]</a>    <span class="k">def</span> <span class="nf">_get_cif</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">converter</span><span class="o">=</span><span class="s1">&#39;ase&#39;</span><span class="p">,</span> <span class="n">store</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates :py:class:`aiida.orm.nodes.data.cif.CifData`.</span>

<span class="sd">        :param converter: specify the converter. Default &#39;ase&#39;.</span>
<span class="sd">        :param store: If True, intermediate calculation gets stored in the</span>
<span class="sd">            AiiDA database for record. Default False.</span>
<span class="sd">        :return: :py:class:`aiida.orm.nodes.data.cif.CifData` node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">warnings</span>
        <span class="kn">from</span> <span class="nn">aiida.common.warnings</span> <span class="k">import</span> <span class="n">AiidaDeprecationWarning</span> <span class="k">as</span> <span class="ne">DeprecationWarning</span>  <span class="c1"># pylint: disable=redefined-builtin</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;This method has been deprecated and will be renamed to get_cif() in AiiDA v1.0&#39;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cif</span><span class="p">(</span><span class="n">converter</span><span class="o">=</span><span class="n">converter</span><span class="p">,</span> <span class="n">store</span><span class="o">=</span><span class="n">store</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="StructureData.get_cif"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.StructureData.get_cif">[docs]</a>    <span class="k">def</span> <span class="nf">get_cif</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">converter</span><span class="o">=</span><span class="s1">&#39;ase&#39;</span><span class="p">,</span> <span class="n">store</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates :py:class:`aiida.orm.nodes.data.cif.CifData`.</span>

<span class="sd">        .. versionadded:: 1.0</span>
<span class="sd">           Renamed from _get_cif</span>

<span class="sd">        :param converter: specify the converter. Default &#39;ase&#39;.</span>
<span class="sd">        :param store: If True, intermediate calculation gets stored in the</span>
<span class="sd">            AiiDA database for record. Default False.</span>
<span class="sd">        :return: :py:class:`aiida.orm.nodes.data.cif.CifData` node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.dict</span> <span class="k">import</span> <span class="n">Dict</span>
        <span class="kn">from</span> <span class="nn">aiida.tools.data</span> <span class="k">import</span> <span class="n">structure</span> <span class="k">as</span> <span class="n">structure_tools</span>

        <span class="n">param</span> <span class="o">=</span> <span class="n">Dict</span><span class="p">(</span><span class="nb">dict</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">conv_f</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">structure_tools</span><span class="p">,</span> <span class="s1">&#39;_get_cif_</span><span class="si">{}</span><span class="s1">_inline&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">converter</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No such converter &#39;</span><span class="si">{}</span><span class="s2">&#39; available&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">converter</span><span class="p">))</span>
        <span class="n">ret_dict</span> <span class="o">=</span> <span class="n">conv_f</span><span class="p">(</span><span class="n">struct</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="o">=</span><span class="n">param</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;store_provenance&#39;</span><span class="p">:</span> <span class="n">store</span><span class="p">})</span>
        <span class="k">return</span> <span class="n">ret_dict</span><span class="p">[</span><span class="s1">&#39;cif&#39;</span><span class="p">]</span></div>

<div class="viewcode-block" id="StructureData._get_object_phonopyatoms"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.StructureData._get_object_phonopyatoms">[docs]</a>    <span class="k">def</span> <span class="nf">_get_object_phonopyatoms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts StructureData to PhonopyAtoms</span>

<span class="sd">        :return: a PhonopyAtoms object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">phonopy.structure.atoms</span> <span class="k">import</span> <span class="n">Atoms</span> <span class="k">as</span> <span class="n">PhonopyAtoms</span>

        <span class="n">atoms</span> <span class="o">=</span> <span class="n">PhonopyAtoms</span><span class="p">(</span><span class="n">symbols</span><span class="o">=</span><span class="p">[</span><span class="n">_</span><span class="o">.</span><span class="n">kind_name</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">])</span>
        <span class="c1"># Phonopy internally uses scaled positions, so you must store cell first!</span>
        <span class="n">atoms</span><span class="o">.</span><span class="n">set_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">)</span>
        <span class="n">atoms</span><span class="o">.</span><span class="n">set_positions</span><span class="p">([</span><span class="n">_</span><span class="o">.</span><span class="n">position</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">atoms</span></div>

<div class="viewcode-block" id="StructureData._get_object_ase"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.StructureData._get_object_ase">[docs]</a>    <span class="k">def</span> <span class="nf">_get_object_ase</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts</span>
<span class="sd">        :py:class:`StructureData &lt;aiida.orm.nodes.data.structure.StructureData&gt;`</span>
<span class="sd">        to ase.Atoms</span>

<span class="sd">        :return: an ase.Atoms object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">ase</span>

        <span class="n">asecell</span> <span class="o">=</span> <span class="n">ase</span><span class="o">.</span><span class="n">Atoms</span><span class="p">(</span><span class="n">cell</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">,</span> <span class="n">pbc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pbc</span><span class="p">)</span>
        <span class="n">_kinds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kinds</span>

        <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">:</span>
            <span class="n">asecell</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">get_ase</span><span class="p">(</span><span class="n">kinds</span><span class="o">=</span><span class="n">_kinds</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">asecell</span></div>

<div class="viewcode-block" id="StructureData._get_object_pymatgen"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.StructureData._get_object_pymatgen">[docs]</a>    <span class="k">def</span> <span class="nf">_get_object_pymatgen</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts</span>
<span class="sd">        :py:class:`StructureData &lt;aiida.orm.nodes.data.structure.StructureData&gt;`</span>
<span class="sd">        to pymatgen object</span>

<span class="sd">        :return: a pymatgen Structure for structures with periodic boundary</span>
<span class="sd">            conditions (in three dimensions) and Molecule otherwise</span>

<span class="sd">        .. note:: Requires the pymatgen module (version &gt;= 3.0.13, usage</span>
<span class="sd">            of earlier versions may cause errors).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pbc</span> <span class="o">==</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_object_pymatgen_structure</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_object_pymatgen_molecule</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="StructureData._get_object_pymatgen_structure"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.StructureData._get_object_pymatgen_structure">[docs]</a>    <span class="k">def</span> <span class="nf">_get_object_pymatgen_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts</span>
<span class="sd">        :py:class:`StructureData &lt;aiida.orm.nodes.data.structure.StructureData&gt;`</span>
<span class="sd">        to pymatgen Structure object</span>
<span class="sd">        :param add_spin: True to add the spins to the pymatgen structure.</span>
<span class="sd">        Default is False (no spin added).</span>

<span class="sd">        .. note:: The spins are set according to the following rule:</span>
<span class="sd">            </span>
<span class="sd">            * if the kind name ends with 1 -&gt; spin=+1</span>
<span class="sd">            </span>
<span class="sd">            * if the kind name ends with 2 -&gt; spin=-1</span>

<span class="sd">        :return: a pymatgen Structure object corresponding to this</span>
<span class="sd">          :py:class:`StructureData &lt;aiida.orm.nodes.data.structure.StructureData&gt;`</span>
<span class="sd">          object</span>
<span class="sd">        :raise ValueError: if periodic boundary conditions does not hold</span>
<span class="sd">          in at least one dimension of real space; if there are partial occupancies</span>
<span class="sd">          together with spins (defined by kind names ending with &#39;1&#39; or &#39;2&#39;).</span>

<span class="sd">        .. note:: Requires the pymatgen module (version &gt;= 3.0.13, usage</span>
<span class="sd">            of earlier versions may cause errors)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pymatgen.core.structure</span> <span class="k">import</span> <span class="n">Structure</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pbc</span> <span class="o">!=</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Periodic boundary conditions must apply in all three dimensions of real space&quot;</span><span class="p">)</span>

        <span class="n">species</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">additional_kwargs</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;add_spin&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">([</span><span class="n">n</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">n</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;2&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_kind_names</span><span class="p">()])):</span>
            <span class="c1"># case when spins are defined -&gt; no partial occupancy allowed</span>
            <span class="kn">from</span> <span class="nn">pymatgen.core.structure</span> <span class="k">import</span> <span class="n">Specie</span>
            <span class="n">oxidation_state</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># now I always set the oxidation_state to zero</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">:</span>
                <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_kind</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">kind_name</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">symbols</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">weights</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">sum</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">weights</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1.</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot set partial occupancies and spins at the same time&quot;</span><span class="p">)</span>
                <span class="n">species</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">Specie</span><span class="p">(</span>
                        <span class="n">k</span><span class="o">.</span><span class="n">symbols</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                        <span class="n">oxidation_state</span><span class="p">,</span>
                        <span class="n">properties</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;spin&#39;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;2&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="mi">0</span><span class="p">}))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># case when no spin are defined</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">:</span>
                <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_kind</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">kind_name</span><span class="p">)</span>
                <span class="n">species</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="n">s</span><span class="p">:</span> <span class="n">w</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">symbols</span><span class="p">,</span> <span class="n">k</span><span class="o">.</span><span class="n">weights</span><span class="p">)})</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">([</span>
                    <span class="n">create_automatic_kind_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_kind</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">symbols</span><span class="p">,</span>
                                               <span class="bp">self</span><span class="o">.</span><span class="n">get_kind</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">weights</span><span class="p">)</span> <span class="o">!=</span> <span class="n">name</span>
                    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_site_kindnames</span><span class="p">()</span>
            <span class="p">]):</span>
                <span class="c1"># add &quot;kind_name&quot; as a properties to each site, whenever</span>
                <span class="c1"># the kind_name cannot be automatically obtained from the symbols</span>
                <span class="n">additional_kwargs</span><span class="p">[</span><span class="s1">&#39;site_properties&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;kind_name&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_site_kindnames</span><span class="p">()}</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unrecognized parameters passed to pymatgen converter: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>

        <span class="n">positions</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">position</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">Structure</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">,</span> <span class="n">species</span><span class="p">,</span> <span class="n">positions</span><span class="p">,</span> <span class="n">coords_are_cartesian</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">additional_kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="StructureData._get_object_pymatgen_molecule"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.StructureData._get_object_pymatgen_molecule">[docs]</a>    <span class="k">def</span> <span class="nf">_get_object_pymatgen_molecule</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts</span>
<span class="sd">        :py:class:`StructureData &lt;aiida.orm.nodes.data.structure.StructureData&gt;`</span>
<span class="sd">        to pymatgen Molecule object</span>

<span class="sd">        :return: a pymatgen Molecule object corresponding to this</span>
<span class="sd">          :py:class:`StructureData &lt;aiida.orm.nodes.data.structure.StructureData&gt;`</span>
<span class="sd">          object.</span>

<span class="sd">        .. note:: Requires the pymatgen module (version &gt;= 3.0.13, usage</span>
<span class="sd">            of earlier versions may cause errors)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pymatgen.core.structure</span> <span class="k">import</span> <span class="n">Molecule</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unrecognized parameters passed to pymatgen converter: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>

        <span class="n">species</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_kind</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">kind_name</span><span class="p">)</span>
            <span class="n">species</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="n">s</span><span class="p">:</span> <span class="n">w</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">symbols</span><span class="p">,</span> <span class="n">k</span><span class="o">.</span><span class="n">weights</span><span class="p">)})</span>

        <span class="n">positions</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">position</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">Molecule</span><span class="p">(</span><span class="n">species</span><span class="p">,</span> <span class="n">positions</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="Kind"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.Kind">[docs]</a><span class="k">class</span> <span class="nc">Kind</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class contains the information about the species (kinds) of the system.</span>

<span class="sd">    It can be a single atom, or an alloy, or even contain vacancies.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Kind.__init__"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.Kind.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a site.</span>
<span class="sd">        One can either pass:</span>

<span class="sd">        :param raw: the raw python dictionary that will be converted to a</span>
<span class="sd">               Kind object.</span>
<span class="sd">        :param ase: an ase Atom object</span>
<span class="sd">        :param kind: a Kind object (to get a copy)</span>

<span class="sd">        Or alternatively the following parameters:</span>

<span class="sd">        :param symbols: a single string for the symbol of this site, or a list</span>
<span class="sd">                   of symbol strings</span>
<span class="sd">        :param weights: (optional) the weights for each atomic species of</span>
<span class="sd">                   this site.</span>
<span class="sd">                   If only a single symbol is provided, then this value is</span>
<span class="sd">                   optional and the weight is set to 1.</span>
<span class="sd">        :param mass: (optional) the mass for this site in atomic mass units.</span>
<span class="sd">                   If not provided, the mass is set by the</span>
<span class="sd">                   self.reset_mass() function.</span>
<span class="sd">        :param name: a string that uniquely identifies the kind, and that</span>
<span class="sd">                   is used to identify the sites.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Internal variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mass</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_symbols</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_weights</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># It will be remain to None in general; it is used to further</span>
        <span class="c1"># identify this species. At the moment, it is used only when importing</span>
        <span class="c1"># from ASE, if the species had a tag (different from zero).</span>
        <span class="c1">## NOTE! This is not persisted on DB but only used while the class</span>
        <span class="c1"># is loaded in memory (i.e., it is not output with the get_raw() method)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_internal_tag</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Logic to create the site from the raw format</span>
        <span class="k">if</span> <span class="s1">&#39;raw&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;If you pass &#39;raw&#39;, then you cannot pass any other parameter.&quot;</span><span class="p">)</span>

            <span class="n">raw</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;raw&#39;</span><span class="p">]</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_symbols_and_weights</span><span class="p">(</span><span class="n">raw</span><span class="p">[</span><span class="s1">&#39;symbols&#39;</span><span class="p">],</span> <span class="n">raw</span><span class="p">[</span><span class="s1">&#39;weights&#39;</span><span class="p">])</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;You didn&#39;t specify either &#39;symbols&#39; or &#39;weights&#39; in the raw site data.&quot;</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mass</span> <span class="o">=</span> <span class="n">raw</span><span class="p">[</span><span class="s1">&#39;mass&#39;</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;You didn&#39;t specify the site mass in the raw site data.&quot;</span><span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">raw</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;You didn&#39;t specify the name in the raw site data.&quot;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="s1">&#39;kind&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;If you pass &#39;kind&#39;, then you cannot pass any other parameter.&quot;</span><span class="p">)</span>
            <span class="n">oldkind</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;kind&#39;</span><span class="p">]</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_symbols_and_weights</span><span class="p">(</span><span class="n">oldkind</span><span class="o">.</span><span class="n">symbols</span><span class="p">,</span> <span class="n">oldkind</span><span class="o">.</span><span class="n">weights</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mass</span> <span class="o">=</span> <span class="n">oldkind</span><span class="o">.</span><span class="n">mass</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">oldkind</span><span class="o">.</span><span class="n">name</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_internal_tag</span> <span class="o">=</span> <span class="n">oldkind</span><span class="o">.</span><span class="n">_internal_tag</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Error using the Kind object. Are you sure &quot;</span>
                                 <span class="s2">&quot;it is a Kind object? [Introspection says it is &quot;</span>
                                 <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">oldkind</span><span class="p">))))</span>

        <span class="k">elif</span> <span class="s1">&#39;ase&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">aseatom</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;ase&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;If you pass &#39;ase&#39;, then you cannot pass any other parameter.&quot;</span><span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="kn">import</span> <span class="nn">numpy</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_symbols_and_weights</span><span class="p">([</span><span class="n">aseatom</span><span class="o">.</span><span class="n">symbol</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.</span><span class="p">])</span>
                <span class="c1"># ASE sets mass to numpy.nan for unstable species</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">aseatom</span><span class="o">.</span><span class="n">mass</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mass</span> <span class="o">=</span> <span class="n">aseatom</span><span class="o">.</span><span class="n">mass</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">reset_mass</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Error using the aseatom object. Are you sure &quot;</span>
                                 <span class="s2">&quot;it is a ase.atom.Atom object? [Introspection says it is &quot;</span>
                                 <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">aseatom</span><span class="p">))))</span>
            <span class="k">if</span> <span class="n">aseatom</span><span class="o">.</span><span class="n">tag</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_automatic_kind_name</span><span class="p">(</span><span class="n">tag</span><span class="o">=</span><span class="n">aseatom</span><span class="o">.</span><span class="n">tag</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_internal_tag</span> <span class="o">=</span> <span class="n">aseatom</span><span class="o">.</span><span class="n">tag</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_automatic_kind_name</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;symbols&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;symbols&#39; need to be &quot;</span>
                                 <span class="s2">&quot;specified (at least) to create a Site object. Otherwise, &quot;</span>
                                 <span class="s2">&quot;pass a raw site using the &#39;raw&#39; parameter.&quot;</span><span class="p">)</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;weights&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_symbols_and_weights</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;symbols&#39;</span><span class="p">),</span> <span class="n">weights</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mass</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;mass&#39;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">reset_mass</span><span class="p">()</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_automatic_kind_name</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unrecognized parameters passed to Kind constructor: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span></div>

<div class="viewcode-block" id="Kind.get_raw"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.Kind.get_raw">[docs]</a>    <span class="k">def</span> <span class="nf">get_raw</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the raw version of the site, mapped to a suitable dictionary.</span>
<span class="sd">        This is the format that is actually used to store each kind of the</span>
<span class="sd">        structure in the DB.</span>

<span class="sd">        :return: a python dictionary with the kind.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;symbols&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">symbols</span><span class="p">,</span>
            <span class="s1">&#39;weights&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">,</span>
            <span class="s1">&#39;mass&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">mass</span><span class="p">,</span>
            <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
        <span class="p">}</span></div>

<div class="viewcode-block" id="Kind.reset_mass"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.Kind.reset_mass">[docs]</a>    <span class="k">def</span> <span class="nf">reset_mass</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reset the mass to the automatic calculated value.</span>

<span class="sd">        The mass can be set manually; by default, if not provided,</span>
<span class="sd">        it is the mass of the constituent atoms, weighted with their</span>
<span class="sd">        weight (after the weight has been normalized to one to take</span>
<span class="sd">        correctly into account vacancies).</span>

<span class="sd">        This function uses the internal _symbols and _weights values and</span>
<span class="sd">        thus assumes that the values are validated.</span>

<span class="sd">        It sets the mass to None if the sum of weights is zero.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">w_sum</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_weights</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">w_sum</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">_sum_threshold</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mass</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">return</span>

        <span class="n">normalized_weights</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">/</span> <span class="n">w_sum</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_weights</span><span class="p">)</span>
        <span class="n">element_masses</span> <span class="o">=</span> <span class="p">(</span><span class="n">_atomic_masses</span><span class="p">[</span><span class="n">sym</span><span class="p">]</span> <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_symbols</span><span class="p">)</span>
        <span class="c1"># Weighted mass</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mass</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">j</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">normalized_weights</span><span class="p">,</span> <span class="n">element_masses</span><span class="p">))</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the name of this kind.</span>
<span class="sd">        The name of a kind is used to identify the species of a site.</span>

<span class="sd">        :return: a string</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>

    <span class="nd">@name</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the name of this site (a string).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">six</span><span class="o">.</span><span class="n">text_type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

<div class="viewcode-block" id="Kind.set_automatic_kind_name"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.Kind.set_automatic_kind_name">[docs]</a>    <span class="k">def</span> <span class="nf">set_automatic_kind_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the type to a string obtained with the symbols appended one</span>
<span class="sd">        after the other, without spaces, in alphabetical order;</span>
<span class="sd">        if the site has a vacancy, a X is appended at the end too.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">name_string</span> <span class="o">=</span> <span class="n">create_automatic_kind_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">symbols</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tag</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name_string</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name_string</span><span class="p">,</span> <span class="n">tag</span><span class="p">)</span></div>

<div class="viewcode-block" id="Kind.compare_with"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.Kind.compare_with">[docs]</a>    <span class="k">def</span> <span class="nf">compare_with</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_kind</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compare with another Kind object to check if they are different.</span>

<span class="sd">        .. note:: This does NOT check the &#39;type&#39; attribute. Instead, it compares</span>
<span class="sd">            (with reasonable thresholds, where applicable): the mass, and the list</span>
<span class="sd">            of symbols and of weights. Moreover, it compares the</span>
<span class="sd">            ``_internal_tag``, if defined (at the moment, defined automatically</span>
<span class="sd">            only when importing the Kind from ASE, if the atom has a non-zero tag).</span>
<span class="sd">            Note that the _internal_tag is only used while the class is loaded,</span>
<span class="sd">            but is not persisted on the database.</span>

<span class="sd">        :return: A tuple with two elements. The first one is True if the two sites</span>
<span class="sd">            are &#39;equivalent&#39; (same mass, symbols and weights), False otherwise.</span>
<span class="sd">            The second element of the tuple is a string,</span>
<span class="sd">            which is either None (if the first element was True), or contains</span>
<span class="sd">            a &#39;human-readable&#39; description of the first difference encountered</span>
<span class="sd">            between the two sites.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check length of symbols</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">symbols</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">other_kind</span><span class="o">.</span><span class="n">symbols</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;Different length of symbols list&quot;</span><span class="p">)</span>

        <span class="c1"># Check list of symbols</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">symbols</span><span class="p">)):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">symbols</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">other_kind</span><span class="o">.</span><span class="n">symbols</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">return</span> <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;Symbol at position </span><span class="si">{:d}</span><span class="s2"> are different &quot;</span>
                        <span class="s2">&quot;(</span><span class="si">{}</span><span class="s2"> vs. </span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">symbols</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">other_kind</span><span class="o">.</span><span class="n">symbols</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
        <span class="c1"># Check weights (assuming length of weights and of symbols have same</span>
        <span class="c1"># length, which should be always true</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">)):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">other_kind</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">return</span> <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;Weight at position </span><span class="si">{:d}</span><span class="s2"> are different &quot;</span>
                        <span class="s2">&quot;(</span><span class="si">{}</span><span class="s2"> vs. </span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">other_kind</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
        <span class="c1"># Check masses</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mass</span> <span class="o">-</span> <span class="n">other_kind</span><span class="o">.</span><span class="n">mass</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_mass_threshold</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;Masses are different (</span><span class="si">{}</span><span class="s2"> vs. </span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mass</span><span class="p">,</span> <span class="n">other_kind</span><span class="o">.</span><span class="n">mass</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal_tag</span> <span class="o">!=</span> <span class="n">other_kind</span><span class="o">.</span><span class="n">_internal_tag</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;Internal tags are different (</span><span class="si">{}</span><span class="s2"> vs. </span><span class="si">{}</span><span class="s2">)&quot;</span>
                    <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_internal_tag</span><span class="p">,</span> <span class="n">other_kind</span><span class="o">.</span><span class="n">_internal_tag</span><span class="p">))</span>

        <span class="c1"># If we got here, the two Site objects are similar enough</span>
        <span class="c1"># to be considered of the same kind</span>
        <span class="k">return</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mass</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The mass of this species kind.</span>

<span class="sd">        :return: a float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mass</span>

    <span class="nd">@mass</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">mass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">the_mass</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">the_mass</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The mass must be positive.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mass</span> <span class="o">=</span> <span class="n">the_mass</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">weights</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Weights for this species kind. Refer also to</span>
<span class="sd">        :func:validate_symbols_tuple for the validation rules on the weights.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_weights</span><span class="p">)</span>

    <span class="nd">@weights</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">weights</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If value is a number, a single weight is used. Otherwise, a list or</span>
<span class="sd">        tuple of numbers is expected.</span>
<span class="sd">        None is also accepted, corresponding to the list [1.].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">weights_tuple</span> <span class="o">=</span> <span class="n">_create_weights_tuple</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">weights_tuple</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_symbols</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot change the number of weights. Use the &quot;</span>
                             <span class="s2">&quot;set_symbols_and_weights function instead.&quot;</span><span class="p">)</span>
        <span class="n">validate_weights_tuple</span><span class="p">(</span><span class="n">weights_tuple</span><span class="p">,</span> <span class="n">_sum_threshold</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_weights</span> <span class="o">=</span> <span class="n">weights_tuple</span>

<div class="viewcode-block" id="Kind.get_symbols_string"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.Kind.get_symbols_string">[docs]</a>    <span class="k">def</span> <span class="nf">get_symbols_string</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a string that tries to match as good as possible the symbols</span>
<span class="sd">        of this kind. If there is only one symbol (no alloy) with 100%</span>
<span class="sd">        occupancy, just returns the symbol name. Otherwise, groups the full</span>
<span class="sd">        string in curly brackets, and try to write also the composition</span>
<span class="sd">        (with 2 precision only).</span>

<span class="sd">        .. note:: If there is a vacancy (sum of weights&lt;1), we indicate it</span>
<span class="sd">            with the X symbol followed by 1-sum(weights) (still with 2</span>
<span class="sd">            digits precision, so it can be 0.00)</span>

<span class="sd">        .. note:: Note the difference with respect to the symbols and the</span>
<span class="sd">            symbol properties!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">get_symbols_string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_symbols</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_weights</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">symbol</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If the kind has only one symbol, return it; otherwise, raise a</span>
<span class="sd">        ValueError.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_symbols</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_symbols</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;This kind has more than one symbol (it is an alloy): </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_symbols</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">symbols</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        List of symbols for this site. If the site is a single atom,</span>
<span class="sd">        pass a list of one element only, or simply the string for that atom.</span>
<span class="sd">        For alloys, a list of elements.</span>

<span class="sd">        .. note:: Note that if you change the list of symbols, the kind</span>
<span class="sd">            name remains unchanged.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_symbols</span><span class="p">)</span>

    <span class="nd">@symbols</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">symbols</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If value is a string, a single symbol is used. Otherwise, a list or</span>
<span class="sd">        tuple of strings is expected.</span>

<span class="sd">        I set a copy of the list, so to avoid that the content changes</span>
<span class="sd">        after the value is set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">symbols_tuple</span> <span class="o">=</span> <span class="n">_create_symbols_tuple</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">symbols_tuple</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_weights</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot change the number of symbols. Use the &quot;</span>
                             <span class="s2">&quot;set_symbols_and_weights function instead.&quot;</span><span class="p">)</span>
        <span class="n">validate_symbols_tuple</span><span class="p">(</span><span class="n">symbols_tuple</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_symbols</span> <span class="o">=</span> <span class="n">symbols_tuple</span>

<div class="viewcode-block" id="Kind.set_symbols_and_weights"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.Kind.set_symbols_and_weights">[docs]</a>    <span class="k">def</span> <span class="nf">set_symbols_and_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">weights</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the chemical symbols and the weights for the site.</span>

<span class="sd">        .. note:: Note that the kind name remains unchanged.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">symbols_tuple</span> <span class="o">=</span> <span class="n">_create_symbols_tuple</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span>
        <span class="n">weights_tuple</span> <span class="o">=</span> <span class="n">_create_weights_tuple</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">symbols_tuple</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">weights_tuple</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The number of symbols and weights must coincide.&quot;</span><span class="p">)</span>
        <span class="n">validate_symbols_tuple</span><span class="p">(</span><span class="n">symbols_tuple</span><span class="p">)</span>
        <span class="n">validate_weights_tuple</span><span class="p">(</span><span class="n">weights_tuple</span><span class="p">,</span> <span class="n">_sum_threshold</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_symbols</span> <span class="o">=</span> <span class="n">symbols_tuple</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_weights</span> <span class="o">=</span> <span class="n">weights_tuple</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_alloy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return whether the Kind is an alloy, i.e. contains more than one element</span>

<span class="sd">        :return: boolean, True if the kind has more than one element, False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_symbols</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_vacancies</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return whether the Kind contains vacancies, i.e. when the sum of the weights is less than one.</span>

<span class="sd">        .. note:: the property uses the internal variable `_sum_threshold` as a threshold.</span>

<span class="sd">        :return: boolean, True if the sum of the weights is less than one, False otherwise</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">has_vacancies</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_weights</span><span class="p">)</span>

<div class="viewcode-block" id="Kind.__repr__"><a class="viewcode-back" href="../../../../../apidoc/aiida.orm.nodes.data.html#aiida.backends.tests.test_dataclasses.Kind.__repr__">[docs]</a>    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;&lt;</span><span class="si">{}</span><span class="s1">: </span><span class="si">{}</span><span class="s1">&gt;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span></div>

<div class="viewcode-block" id="Kind.__str__"><a class="viewcode-back" href="../../../../../apidoc/aiida.orm.nodes.data.html#aiida.backends.tests.test_dataclasses.Kind.__str__">[docs]</a>    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">symbol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_symbols_string</span><span class="p">()</span>
        <span class="k">return</span> <span class="s2">&quot;name &#39;</span><span class="si">{}</span><span class="s2">&#39;, symbol &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">symbol</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="Site"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.Site">[docs]</a><span class="k">class</span> <span class="nc">Site</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class contains the information about a given site of the system.</span>

<span class="sd">    It can be a single atom, or an alloy, or even contain vacancies.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Site.__init__"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.Site.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a site.</span>

<span class="sd">        :param kind_name: a string that identifies the kind (species) of this site.</span>
<span class="sd">                This has to be found in the list of kinds of the StructureData</span>
<span class="sd">                object.</span>
<span class="sd">                Validation will be done at the StructureData level.</span>
<span class="sd">        :param position: the absolute position (three floats) in angstrom</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_kind_name</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_position</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="s1">&#39;site&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">site</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;site&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;If you pass &#39;site&#39;, you cannot pass any further parameter to the Site constructor&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">site</span><span class="p">,</span> <span class="n">Site</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;site&#39; must be of type Site&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kind_name</span> <span class="o">=</span> <span class="n">site</span><span class="o">.</span><span class="n">kind_name</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">site</span><span class="o">.</span><span class="n">position</span>
        <span class="k">elif</span> <span class="s1">&#39;raw&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">raw</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;raw&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;If you pass &#39;raw&#39;, you cannot pass any further parameter to the Site constructor&quot;</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">kind_name</span> <span class="o">=</span> <span class="n">raw</span><span class="p">[</span><span class="s1">&#39;kind_name&#39;</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">raw</span><span class="p">[</span><span class="s1">&#39;position&#39;</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid raw object, it does not contain any key </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">exc</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid raw object, it is not a dictionary&quot;</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">kind_name</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;kind_name&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;position&#39;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;You need to specify </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">exc</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unrecognized parameters: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">))</span></div>

<div class="viewcode-block" id="Site.get_raw"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.Site.get_raw">[docs]</a>    <span class="k">def</span> <span class="nf">get_raw</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the raw version of the site, mapped to a suitable dictionary.</span>
<span class="sd">        This is the format that is actually used to store each site of the</span>
<span class="sd">        structure in the DB.</span>

<span class="sd">        :return: a python dictionary with the site.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;position&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">,</span>
            <span class="s1">&#39;kind_name&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">kind_name</span><span class="p">,</span>
        <span class="p">}</span></div>

<div class="viewcode-block" id="Site.get_ase"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.Site.get_ase">[docs]</a>    <span class="k">def</span> <span class="nf">get_ase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kinds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a ase.Atom object for this site.</span>

<span class="sd">        :param kinds: the list of kinds from the StructureData object.</span>

<span class="sd">        .. note:: If any site is an alloy or has vacancies, a ValueError</span>
<span class="sd">            is raised (from the site.get_ase() routine).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">defaultdict</span>
        <span class="kn">import</span> <span class="nn">ase</span>

        <span class="c1"># I create the list of tags</span>
        <span class="n">tag_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">used_tags</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">kinds</span><span class="p">:</span>
            <span class="c1"># Skip alloys and vacancies</span>
            <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">is_alloy</span> <span class="ow">or</span> <span class="n">k</span><span class="o">.</span><span class="n">has_vacancies</span><span class="p">:</span>
                <span class="n">tag_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="c1"># If the kind name is equal to the specie name,</span>
            <span class="c1"># then no tag should be set</span>
            <span class="k">elif</span> <span class="n">six</span><span class="o">.</span><span class="n">text_type</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="o">==</span> <span class="n">six</span><span class="o">.</span><span class="n">text_type</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">symbols</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">tag_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Name is not the specie name</span>
                <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">symbols</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">new_tag</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">symbols</span><span class="p">[</span><span class="mi">0</span><span class="p">])])</span>
                        <span class="n">tag_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_tag</span><span class="p">)</span>
                        <span class="n">used_tags</span><span class="p">[</span><span class="n">k</span><span class="o">.</span><span class="n">symbols</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_tag</span><span class="p">)</span>
                        <span class="k">continue</span>
                    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                        <span class="k">pass</span>
                <span class="n">tag_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">symbols</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># I use a string as a placeholder</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tag_list</span><span class="p">)):</span>
            <span class="c1"># If it is a string, it is the name of the element,</span>
            <span class="c1"># and I have to generate a new integer for this element</span>
            <span class="c1"># and replace tag_list[i] with this new integer</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tag_list</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
                <span class="c1"># I get a list of used tags for this element</span>
                <span class="n">existing_tags</span> <span class="o">=</span> <span class="n">used_tags</span><span class="p">[</span><span class="n">tag_list</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                <span class="k">if</span> <span class="n">existing_tags</span><span class="p">:</span>
                    <span class="n">new_tag</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">existing_tags</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># empty list</span>
                    <span class="n">new_tag</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="c1"># I store it also as a used tag!</span>
                <span class="n">used_tags</span><span class="p">[</span><span class="n">tag_list</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_tag</span><span class="p">)</span>
                <span class="c1"># I update the tag</span>
                <span class="n">tag_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_tag</span>

        <span class="n">found</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">kinds</span><span class="p">,</span> <span class="n">tag_list</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">kind_name</span><span class="p">:</span>
                <span class="n">kind</span> <span class="o">=</span> <span class="n">k</span>
                <span class="n">tag</span> <span class="o">=</span> <span class="n">t</span>
                <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">found</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No kind &#39;</span><span class="si">{}</span><span class="s2">&#39; has been found in the list of kinds&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kind_name</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">kind</span><span class="o">.</span><span class="n">is_alloy</span> <span class="ow">or</span> <span class="n">kind</span><span class="o">.</span><span class="n">has_vacancies</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot convert to ASE if the kind represents an alloy or it has vacancies.&quot;</span><span class="p">)</span>
        <span class="n">aseatom</span> <span class="o">=</span> <span class="n">ase</span><span class="o">.</span><span class="n">Atom</span><span class="p">(</span><span class="n">position</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">,</span> <span class="n">symbol</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">kind</span><span class="o">.</span><span class="n">symbols</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">mass</span><span class="o">=</span><span class="n">kind</span><span class="o">.</span><span class="n">mass</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tag</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">aseatom</span><span class="o">.</span><span class="n">tag</span> <span class="o">=</span> <span class="n">tag</span>
        <span class="k">return</span> <span class="n">aseatom</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">kind_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the kind name of this site (a string).</span>

<span class="sd">        The type of a site is used to decide whether two sites are identical</span>
<span class="sd">        (same mass, symbols, weights, ...) or not.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kind_name</span>

    <span class="nd">@kind_name</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">kind_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the type of this site (a string).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_kind_name</span> <span class="o">=</span> <span class="n">six</span><span class="o">.</span><span class="n">text_type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">position</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the position of this site in absolute coordinates,</span>
<span class="sd">        in angstrom.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_position</span><span class="p">)</span>

    <span class="nd">@position</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">position</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the position of this site in absolute coordinates,</span>
<span class="sd">        in angstrom.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">internal_pos</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">internal_pos</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span>
        <span class="c1"># value is not iterable or elements are not floats or len != 3</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Wrong format for position, must be a list of three float numbers.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_position</span> <span class="o">=</span> <span class="n">internal_pos</span>

<div class="viewcode-block" id="Site.__repr__"><a class="viewcode-back" href="../../../../../apidoc/aiida.orm.nodes.data.html#aiida.backends.tests.test_dataclasses.Site.__repr__">[docs]</a>    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;&lt;</span><span class="si">{}</span><span class="s1">: </span><span class="si">{}</span><span class="s1">&gt;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span></div>

<div class="viewcode-block" id="Site.__str__"><a class="viewcode-back" href="../../../../../apidoc/aiida.orm.nodes.data.html#aiida.backends.tests.test_dataclasses.Site.__str__">[docs]</a>    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;kind name &#39;</span><span class="si">{}</span><span class="s2">&#39; @ </span><span class="si">{}</span><span class="s2">,</span><span class="si">{}</span><span class="s2">,</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kind_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span></div></div>


<span class="c1"># get_structuredata_from_qeinput has been moved to:</span>
<span class="c1"># aiida.tools.codespecific.quantumespresso.qeinputparser</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, ECOLE POLYTECHNIQUE FEDERALE DE LAUSANNE (Theory and Simulation of Materials (THEOS) and National Centre for Computational Design and Discovery of Novel Materials (NCCR MARVEL)), Switzerland and ROBERT BOSCH LLC, USA. All rights reserved

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>