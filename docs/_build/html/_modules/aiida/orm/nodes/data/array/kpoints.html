

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>aiida.orm.nodes.data.array.kpoints &mdash; AiiDA 1.0.0b2 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../../../" src="../../../../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../../../../_static/language_data.js"></script>
        <script type="text/javascript" src="../../../../../../_static/contentui.js"></script>
    
    <script type="text/javascript" src="../../../../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../../../../_static/contentui.css" type="text/css" />
    <link rel="index" title="Index" href="../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../../../../index.html" class="icon icon-home"> AiiDA
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Installation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../install/quick_installation.html">Quick installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../install/prerequisites.html">Prerequisites</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../install/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../install/updating_installation.html">Updating AiiDA</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../install/troubleshooting.html">Troubleshooting</a></li>
</ul>
<p class="caption"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../get_started/index.html">First things first</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../get_started/daemon.html">Setup the daemon</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../get_started/computers.html">Setup a computer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../get_started/codes.html">Setup a code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../get_started/plugins.html">Plugins</a></li>
</ul>
<p class="caption"><span class="caption-text">Concepts</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../concepts/provenance.html">Provenance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../concepts/processes.html">Processes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../concepts/calculations.html">Calculations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../concepts/workflows.html">Workflows</a></li>
</ul>
<p class="caption"><span class="caption-text">Working with</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../working/processes.html">Processes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../working/functions.html">Calculation and work functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../working/calculations.html">Calculations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../working/workflows.html">Workflows</a></li>
</ul>
<p class="caption"><span class="caption-text">Working with AiiDA</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../working_with_aiida/index.html">Command line interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../working_with_aiida/index.html#scripting">Scripting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../working_with_aiida/index.html#data-types">Data types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../working_with_aiida/index.html#groups">Groups</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../working_with_aiida/index.html#schedulers">Schedulers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../working_with_aiida/index.html#querying-data">Querying data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../working_with_aiida/index.html#caching">Caching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../working_with_aiida/index.html#result-manager">Result manager</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../working_with_aiida/index.html#backups">Backups</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../working_with_aiida/index.html#troubleshooting">Troubleshooting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../working_with_aiida/index.html#rest-api">REST API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../working_with_aiida/index.html#cookbook">Cookbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../import_export/index.html">Import and Export</a></li>
</ul>
<p class="caption"><span class="caption-text">Development</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../developer_guide/index.html">AiiDA design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../developer_guide/index.html#aiida-core">AiiDA core</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../developer_guide/index.html#aiida-plugins">AiiDA plugins</a></li>
</ul>
<p class="caption"><span class="caption-text">Tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../tutorial/index.html">StructureData</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../tutorial/index.html#pseudopotentials">Pseudopotentials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../tutorial/index.html#plugin-development">Plugin development</a></li>
</ul>
<p class="caption"><span class="caption-text">API reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="`aiida package &lt;https://aiida-core.readthedocs.io/en/latest/apidoc/aiida.html&gt;`_">`aiida package &lt;https://aiida-core.readthedocs.io/en/latest/apidoc/aiida.html&gt;`_</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../../index.html">AiiDA</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../../../../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../../../../../aiida.html">aiida</a> &raquo;</li>
        
      <li>aiida.orm.nodes.data.array.kpoints</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for aiida.orm.nodes.data.array.kpoints</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1">###########################################################################</span>
<span class="c1"># Copyright (c), The AiiDA team. All rights reserved.                     #</span>
<span class="c1"># This file is part of the AiiDA code.                                    #</span>
<span class="c1">#                                                                         #</span>
<span class="c1"># The code is hosted on GitHub at https://github.com/aiidateam/aiida_core #</span>
<span class="c1"># For further information on the license, see the LICENSE.txt file        #</span>
<span class="c1"># For further information please visit http://www.aiida.net               #</span>
<span class="c1">###########################################################################</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Module of the KpointsData class, defining the AiiDA data type for storing</span>
<span class="sd">lists and meshes of k-points (i.e., points in the reciprocal space of a</span>
<span class="sd">periodic crystal structure).</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span>

<span class="kn">import</span> <span class="nn">six</span>
<span class="kn">from</span> <span class="nn">six.moves</span> <span class="k">import</span> <span class="nb">range</span><span class="p">,</span> <span class="nb">zip</span>
<span class="kn">import</span> <span class="nn">numpy</span>

<span class="kn">from</span> <span class="nn">aiida.common.warnings</span> <span class="k">import</span> <span class="n">AiidaDeprecationWarning</span>
<span class="kn">from</span> <span class="nn">.array</span> <span class="k">import</span> <span class="n">ArrayData</span>

<span class="n">DEPRECATION_DOCS_URL</span> <span class="o">=</span> <span class="s1">&#39;http://aiida-core.readthedocs.io/en/latest/datatypes/kpoints.html#deprecated-methods&#39;</span>

<span class="n">_DEFAULT_EPSILON_LENGTH</span> <span class="o">=</span> <span class="mf">1e-5</span>
<span class="n">_DEFAULT_EPSILON_ANGLE</span> <span class="o">=</span> <span class="mf">1e-5</span>


<div class="viewcode-block" id="KpointsData"><a class="viewcode-back" href="../../../../../../developer_guide/core/orm_overview.html#aiida.orm.KpointsData">[docs]</a><span class="k">class</span> <span class="nc">KpointsData</span><span class="p">(</span><span class="n">ArrayData</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class to handle array of kpoints in the Brillouin zone. Provide methods to</span>
<span class="sd">    generate either user-defined k-points or path of k-points along symmetry</span>
<span class="sd">    lines.</span>
<span class="sd">    Internally, all k-points are defined in terms of crystal (fractional)</span>
<span class="sd">    coordinates.</span>
<span class="sd">    Cell and lattice vector coordinates are in Angstroms, reciprocal lattice</span>
<span class="sd">    vectors in Angstrom^-1 .</span>
<span class="sd">    :note: The methods setting and using the Bravais lattice info assume the</span>
<span class="sd">    PRIMITIVE unit cell is provided in input to the set_cell or</span>
<span class="sd">    set_cell_from_structure methods.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="KpointsData.get_description"><a class="viewcode-back" href="../../../../../../developer_guide/core/orm_overview.html#aiida.orm.KpointsData.get_description">[docs]</a>    <span class="k">def</span> <span class="nf">get_description</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a string with infos retrieved from  kpoints node&#39;s properties.</span>
<span class="sd">        :param node:</span>
<span class="sd">        :return: retstr</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">mesh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_kpoints_mesh</span><span class="p">()</span>
            <span class="k">return</span> <span class="s2">&quot;Kpoints mesh: </span><span class="si">{}</span><span class="s2">x</span><span class="si">{}</span><span class="s2">x</span><span class="si">{}</span><span class="s2"> (+</span><span class="si">{:.1f}</span><span class="s2">,</span><span class="si">{:.1f}</span><span class="s2">,</span><span class="si">{:.1f}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mesh</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">mesh</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">mesh</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span>
                                                                           <span class="n">mesh</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">mesh</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">mesh</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="s1">&#39;(Path of </span><span class="si">{}</span><span class="s1"> kpts)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_kpoints</span><span class="p">()))</span>
            <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_type</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cell</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The crystal unit cell. Rows are the crystal vectors in Angstroms.</span>
<span class="sd">        :return: a 3x3 numpy.array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="s1">&#39;cell&#39;</span><span class="p">))</span>

    <span class="nd">@cell</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">cell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the crystal unit cell</span>
<span class="sd">        :param value: a 3x3 list/tuple/array of numbers (units = Angstroms).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_cell</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

<div class="viewcode-block" id="KpointsData._set_cell"><a class="viewcode-back" href="../../../../../../developer_guide/core/orm_overview.html#aiida.orm.KpointsData._set_cell">[docs]</a>    <span class="k">def</span> <span class="nf">_set_cell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Validate if &#39;value&#39; is a allowed crystal unit cell</span>
<span class="sd">        :param value: something compatible with a 3x3 tuple of floats</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">aiida.common.exceptions</span> <span class="k">import</span> <span class="n">ModificationNotAllowed</span>
        <span class="kn">from</span> <span class="nn">aiida.orm.nodes.data.structure</span> <span class="k">import</span> <span class="n">_get_valid_cell</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_stored</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ModificationNotAllowed</span><span class="p">(</span><span class="s2">&quot;KpointsData cannot be modified, it has already been stored&quot;</span><span class="p">)</span>

        <span class="n">the_cell</span> <span class="o">=</span> <span class="n">_get_valid_cell</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="s1">&#39;cell&#39;</span><span class="p">,</span> <span class="n">the_cell</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pbc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The periodic boundary conditions along the vectors a1,a2,a3.</span>

<span class="sd">        :return: a tuple of three booleans, each one tells if there are periodic</span>
<span class="sd">            boundary conditions for the i-th real-space direction (i=1,2,3)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># return copy.deepcopy(self._pbc)</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="s1">&#39;pbc1&#39;</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="s1">&#39;pbc2&#39;</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="s1">&#39;pbc3&#39;</span><span class="p">))</span>

    <span class="nd">@pbc</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">pbc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the value of pbc, i.e. a tuple of three booleans, indicating if the</span>
<span class="sd">        cell is periodic in the 1,2,3 crystal direction</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_pbc</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

<div class="viewcode-block" id="KpointsData._set_pbc"><a class="viewcode-back" href="../../../../../../developer_guide/core/orm_overview.html#aiida.orm.KpointsData._set_pbc">[docs]</a>    <span class="k">def</span> <span class="nf">_set_pbc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        validate the pbc, then store them</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">aiida.common.exceptions</span> <span class="k">import</span> <span class="n">ModificationNotAllowed</span>
        <span class="kn">from</span> <span class="nn">aiida.orm.nodes.data.structure</span> <span class="k">import</span> <span class="n">get_valid_pbc</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_stored</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ModificationNotAllowed</span><span class="p">(</span><span class="s2">&quot;The KpointsData object cannot be modified, it has already been stored&quot;</span><span class="p">)</span>
        <span class="n">the_pbc</span> <span class="o">=</span> <span class="n">get_valid_pbc</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="s1">&#39;pbc1&#39;</span><span class="p">,</span> <span class="n">the_pbc</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="s1">&#39;pbc2&#39;</span><span class="p">,</span> <span class="n">the_pbc</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="s1">&#39;pbc3&#39;</span><span class="p">,</span> <span class="n">the_pbc</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">labels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Labels associated with the list of kpoints.</span>
<span class="sd">        List of tuples with kpoint index and kpoint name: ``[(0,&#39;G&#39;),(13,&#39;M&#39;),...]``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">label_numbers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="s1">&#39;label_numbers&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="s1">&#39;labels&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">labels</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">label_numbers</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">label_numbers</span><span class="p">,</span> <span class="n">labels</span><span class="p">))</span>

    <span class="nd">@labels</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_labels</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

<div class="viewcode-block" id="KpointsData._set_labels"><a class="viewcode-back" href="../../../../../../developer_guide/core/orm_overview.html#aiida.orm.KpointsData._set_labels">[docs]</a>    <span class="k">def</span> <span class="nf">_set_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        set label names. Must pass in input a list like: ``[[0,&#39;X&#39;],[34,&#39;L&#39;],... ]``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check if kpoints were set</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_kpoints</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;Kpoints must be set before the labels&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">label_numbers</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">value</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The input must contain an integer index, to map the labels into the kpoint list&quot;</span><span class="p">)</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">value</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">i</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_kpoints</span><span class="p">())</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">label_numbers</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Index of label exceeding the list of kpoints&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="s1">&#39;label_numbers&#39;</span><span class="p">,</span> <span class="n">label_numbers</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="s1">&#39;labels&#39;</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span></div>

<div class="viewcode-block" id="KpointsData._change_reference"><a class="viewcode-back" href="../../../../../../developer_guide/core/orm_overview.html#aiida.orm.KpointsData._change_reference">[docs]</a>    <span class="k">def</span> <span class="nf">_change_reference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kpoints</span><span class="p">,</span> <span class="n">to_cartesian</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Change reference system, from cartesian to crystal coordinates (units of b1,b2,b3) or viceversa.</span>
<span class="sd">        :param kpoints: a list of (3) point coordinates</span>
<span class="sd">        :return kpoints: a list of (3) point coordinates in the new reference</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kpoints</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;kpoints must be a numpy.array for method change_reference()&quot;</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">rec_cell</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reciprocal_cell</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="c1"># rec_cell = numpy.eye(3)</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;Cannot use cartesian coordinates without having defined a cell&quot;</span><span class="p">)</span>

        <span class="n">trec_cell</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rec_cell</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">to_cartesian</span><span class="p">:</span>
            <span class="n">matrix</span> <span class="o">=</span> <span class="n">trec_cell</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">matrix</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">trec_cell</span><span class="p">)</span>

        <span class="c1"># note: kpoints is a list Nx3, matrix is 3x3.</span>
        <span class="c1"># hence, first transpose kpoints, then multiply, finally transpose it back</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">kpoints</span><span class="p">)))</span></div>

<div class="viewcode-block" id="KpointsData.set_cell_from_structure"><a class="viewcode-back" href="../../../../../../developer_guide/core/orm_overview.html#aiida.orm.KpointsData.set_cell_from_structure">[docs]</a>    <span class="k">def</span> <span class="nf">set_cell_from_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">structuredata</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set a cell to be used for symmetry analysis from an AiiDA structure.</span>
<span class="sd">        Inherits both the cell and the pbc&#39;s.</span>
<span class="sd">        To set manually a cell, use &quot;set_cell&quot;</span>

<span class="sd">        :param structuredata: an instance of StructureData</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">aiida.orm</span> <span class="k">import</span> <span class="n">StructureData</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">structuredata</span><span class="p">,</span> <span class="n">StructureData</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;An instance of StructureData should be passed to &quot;</span>
                             <span class="s2">&quot;the KpointsData, found instead </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">structuredata</span><span class="o">.</span><span class="vm">__class__</span><span class="p">))</span>
        <span class="n">cell</span> <span class="o">=</span> <span class="n">structuredata</span><span class="o">.</span><span class="n">cell</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_cell</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">structuredata</span><span class="o">.</span><span class="n">pbc</span><span class="p">)</span></div>

<div class="viewcode-block" id="KpointsData.set_cell"><a class="viewcode-back" href="../../../../../../developer_guide/core/orm_overview.html#aiida.orm.KpointsData.set_cell">[docs]</a>    <span class="k">def</span> <span class="nf">set_cell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cell</span><span class="p">,</span> <span class="n">pbc</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set a cell to be used for symmetry analysis.</span>
<span class="sd">        To set a cell from an AiiDA structure, use &quot;set_cell_from_structure&quot;.</span>

<span class="sd">        :param cell: 3x3 matrix of cell vectors. Orientation: each row</span>
<span class="sd">                     represent a lattice vector. Units are Angstroms.</span>
<span class="sd">        :param pbc: list of 3 booleans, True if in the nth crystal direction the</span>
<span class="sd">                    structure is periodic. Default = [True,True,True]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cell</span> <span class="o">=</span> <span class="n">cell</span>
        <span class="k">if</span> <span class="n">pbc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pbc</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pbc</span> <span class="o">=</span> <span class="n">pbc</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">reciprocal_cell</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the reciprocal cell in units of 1/Angstrom from the internally set cell</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">the_cell</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">)</span>
        <span class="n">reciprocal_cell</span> <span class="o">=</span> <span class="mf">2.</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">the_cell</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">reciprocal_cell</span>

<div class="viewcode-block" id="KpointsData.set_kpoints_mesh"><a class="viewcode-back" href="../../../../../../developer_guide/core/orm_overview.html#aiida.orm.KpointsData.set_kpoints_mesh">[docs]</a>    <span class="k">def</span> <span class="nf">set_kpoints_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set KpointsData to represent a uniformily spaced mesh of kpoints in the</span>
<span class="sd">        Brillouin zone. This excludes the possibility of set/get kpoints</span>

<span class="sd">        :param mesh: a list of three integers, representing the size of the</span>
<span class="sd">            kpoint mesh along b1,b2,b3.</span>
<span class="sd">        :param offset: (optional) a list of three floats between 0 and 1.</span>
<span class="sd">            [0.,0.,0.] is Gamma centered mesh</span>
<span class="sd">            [0.5,0.5,0.5] is half shifted</span>
<span class="sd">            [1.,1.,1.] by periodicity should be equivalent to [0.,0.,0.]</span>
<span class="sd">            Default = [0.,0.,0.].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">aiida.common.exceptions</span> <span class="k">import</span> <span class="n">ModificationNotAllowed</span>
        <span class="c1"># validate</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">the_mesh</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">mesh</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">the_mesh</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">IndexError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The kpoint mesh must be a list of three integers&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">offset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">the_offset</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">offset</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">the_offset</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">IndexError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The offset must be a list of three floats&quot;</span><span class="p">)</span>
        <span class="c1"># check that there is no list of kpoints saved already</span>
        <span class="c1"># I cannot have both of them at the same time</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_array</span><span class="p">(</span><span class="s1">&#39;kpoints&#39;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">ModificationNotAllowed</span><span class="p">(</span><span class="s2">&quot;KpointsData has already a kpoint-list stored&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="c1"># store</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="s1">&#39;mesh&#39;</span><span class="p">,</span> <span class="n">the_mesh</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="s1">&#39;offset&#39;</span><span class="p">,</span> <span class="n">the_offset</span><span class="p">)</span></div>

<div class="viewcode-block" id="KpointsData.get_kpoints_mesh"><a class="viewcode-back" href="../../../../../../developer_guide/core/orm_overview.html#aiida.orm.KpointsData.get_kpoints_mesh">[docs]</a>    <span class="k">def</span> <span class="nf">get_kpoints_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">print_list</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the mesh of kpoints.</span>

<span class="sd">        :param print_list: default=False. If True, prints the mesh of kpoints as a list</span>

<span class="sd">        :raise AttributeError: if no mesh has been set</span>
<span class="sd">        :return mesh,offset: (if print_list=False) a list of 3 integers and a list of three</span>
<span class="sd">                floats 0&lt;x&lt;1, representing the mesh and the offset of kpoints</span>
<span class="sd">        :return kpoints: (if print_list = True) an explicit list of kpoints coordinates,</span>
<span class="sd">                similar to what returned by get_kpoints()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="s1">&#39;mesh&#39;</span><span class="p">)</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="s1">&#39;offset&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">print_list</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">offset</span>

        <span class="n">kpoints</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">mesh</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">:</span><span class="n">mesh</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">:</span><span class="n">mesh</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
        <span class="n">kpoints</span> <span class="o">=</span> <span class="n">kpoints</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">offset_kpoints</span> <span class="o">=</span> <span class="n">kpoints</span> <span class="o">+</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>
        <span class="n">offset_kpoints</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/=</span> <span class="n">mesh</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">offset_kpoints</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/=</span> <span class="n">mesh</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">offset_kpoints</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">/=</span> <span class="n">mesh</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">offset_kpoints</span></div>

<div class="viewcode-block" id="KpointsData.set_kpoints_mesh_from_density"><a class="viewcode-back" href="../../../../../../developer_guide/core/orm_overview.html#aiida.orm.KpointsData.set_kpoints_mesh_from_density">[docs]</a>    <span class="k">def</span> <span class="nf">set_kpoints_mesh_from_density</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">force_parity</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set a kpoints mesh using a kpoints density, expressed as the maximum</span>
<span class="sd">        distance between adjacent points along a reciprocal axis</span>

<span class="sd">        :param distance: distance (in 1/Angstrom) between adjacent</span>
<span class="sd">            kpoints, i.e. the number of kpoints along each reciprocal</span>
<span class="sd">            axis i is :math:`|b_i|/distance`</span>
<span class="sd">            where :math:`|b_i|` is the norm of the reciprocal cell vector.</span>
<span class="sd">        :param offset: (optional) a list of three floats between 0 and 1.</span>
<span class="sd">            [0.,0.,0.] is Gamma centered mesh</span>
<span class="sd">            [0.5,0.5,0.5] is half shifted</span>
<span class="sd">            Default = [0.,0.,0.].</span>
<span class="sd">        :param force_parity: (optional) if True, force each integer in the mesh</span>
<span class="sd">            to be even (except for the non-periodic directions).</span>

<span class="sd">        :note: a cell should be defined first.</span>
<span class="sd">        :note: the number of kpoints along non-periodic axes is always 1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">offset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">rec_cell</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reciprocal_cell</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="c1"># rec_cell = numpy.eye(3)</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;Cannot define a mesh from a density without having defined a cell&quot;</span><span class="p">)</span>
        <span class="c1"># I first round to the fifth digit |b|/distance (to avoid that e.g.</span>
        <span class="c1"># 3.00000001 becomes 4)</span>
        <span class="n">kpointsmesh</span> <span class="o">=</span> <span class="p">[</span>
            <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">/</span> <span class="n">distance</span><span class="p">,</span> <span class="mi">5</span><span class="p">))),</span> <span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">pbc</span> <span class="k">else</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">pbc</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pbc</span><span class="p">,</span> <span class="n">rec_cell</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="n">force_parity</span><span class="p">:</span>
            <span class="n">kpointsmesh</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="p">(</span><span class="n">k</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="k">if</span> <span class="n">pbc</span> <span class="k">else</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">pbc</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pbc</span><span class="p">,</span> <span class="n">kpointsmesh</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_kpoints_mesh</span><span class="p">(</span><span class="n">kpointsmesh</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Dimensionality of the structure, found from its pbc (i.e. 1 if it&#39;s a 1D</span>
<span class="sd">        structure, 2 if its 2D, 3 if it&#39;s 3D ...).</span>
<span class="sd">        :return dimensionality: 0, 1, 2 or 3</span>
<span class="sd">        :note: will return 3 if pbc has not been set beforehand</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pbc</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">3</span>

<div class="viewcode-block" id="KpointsData._validate_kpoints_weights"><a class="viewcode-back" href="../../../../../../developer_guide/core/orm_overview.html#aiida.orm.KpointsData._validate_kpoints_weights">[docs]</a>    <span class="k">def</span> <span class="nf">_validate_kpoints_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kpoints</span><span class="p">,</span> <span class="n">weights</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Validate the list of kpoints and of weights before storage.</span>
<span class="sd">        Kpoints and weights must be convertible respectively to an array of</span>
<span class="sd">        N x dimension and N floats</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kpoints</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kpoints</span><span class="p">)</span>

        <span class="c1"># I cannot just use `if not kpoints` because it&#39;s a numpy array and</span>
        <span class="c1"># `not` of a numpy array does not work</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kpoints</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># pylint: disable=len-as-condition</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dimension</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># replace empty list by Gamma point</span>
                <span class="n">kpoints</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;empty kpoints list is valid only in zero dimension&quot;</span>
                                 <span class="s2">&quot;; instead here with have </span><span class="si">{}</span><span class="s2"> dimensions&quot;</span>
                                 <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dimension</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kpoints</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># list of scalars is accepted only in the 0D and 1D cases</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dimension</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># replace by singletons</span>
                <span class="n">kpoints</span> <span class="o">=</span> <span class="n">kpoints</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">kpoints</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;kpoints must be a list of lists in </span><span class="si">{}</span><span class="s2">D case&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dimension</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">kpoints</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;kpoints must be an array of type floats. Found instead </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">kpoints</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">kpoints</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dimension</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;In a system which has </span><span class="si">{0}</span><span class="s2"> dimensions, kpoint need&quot;</span>
                             <span class="s2">&quot;more than </span><span class="si">{0}</span><span class="s2"> coordinates (found instead </span><span class="si">{1}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dimension</span><span class="p">,</span> <span class="n">kpoints</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

        <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">weights</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">kpoints</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Found </span><span class="si">{}</span><span class="s2"> weights but </span><span class="si">{}</span><span class="s2"> kpoints&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">weights</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">kpoints</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="k">if</span> <span class="n">weights</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;weights must be an array of type floats. Found instead </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">weights</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">kpoints</span><span class="p">,</span> <span class="n">weights</span></div>

<div class="viewcode-block" id="KpointsData.set_kpoints"><a class="viewcode-back" href="../../../../../../developer_guide/core/orm_overview.html#aiida.orm.KpointsData.set_kpoints">[docs]</a>    <span class="k">def</span> <span class="nf">set_kpoints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kpoints</span><span class="p">,</span> <span class="n">cartesian</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fill_values</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the list of kpoints. If a mesh has already been stored, raise a</span>
<span class="sd">        ModificationNotAllowed</span>

<span class="sd">        :param kpoints: a list of kpoints, each kpoint being a list of one, two</span>
<span class="sd">            or three coordinates, depending on self.pbc: if structure is 1D</span>
<span class="sd">            (only one True in self.pbc) one allows singletons or scalars for</span>
<span class="sd">            each k-point, if it&#39;s 2D it can be a length-2 list, and in all</span>
<span class="sd">            cases it can be a length-3 list.</span>
<span class="sd">            Examples:</span>

<span class="sd">                * [[0.,0.,0.],[0.1,0.1,0.1],...] for 1D, 2D or 3D</span>
<span class="sd">                * [[0.,0.],[0.1,0.1,],...] for 1D or 2D</span>
<span class="sd">                * [[0.],[0.1],...] for 1D</span>
<span class="sd">                * [0., 0.1, ...] for 1D (list of scalars)</span>

<span class="sd">            For 0D (all pbc are False), the list can be any of the above</span>
<span class="sd">            or empty - then only Gamma point is set.</span>
<span class="sd">            The value of k for the non-periodic dimension(s) is set by</span>
<span class="sd">            fill_values</span>
<span class="sd">        :param cartesian: if True, the coordinates given in input are treated</span>
<span class="sd">            as in cartesian units. If False, the coordinates are crystal,</span>
<span class="sd">            i.e. in units of b1,b2,b3. Default = False</span>
<span class="sd">        :param labels: optional, the list of labels to be set for some of the</span>
<span class="sd">            kpoints. See labels for more info</span>
<span class="sd">        :param weights: optional, a list of floats with the weight associated</span>
<span class="sd">            to the kpoint list</span>
<span class="sd">        :param fill_values: scalar to be set to all</span>
<span class="sd">            non-periodic dimensions (indicated by False in self.pbc), or list of</span>
<span class="sd">            values for each of the non-periodic dimensions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">aiida.common.exceptions</span> <span class="k">import</span> <span class="n">ModificationNotAllowed</span>

        <span class="c1"># check that it is a &#39;dim&#39;x #kpoints dimensional array</span>
        <span class="n">the_kpoints</span><span class="p">,</span> <span class="n">the_weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_kpoints_weights</span><span class="p">(</span><span class="n">kpoints</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>

        <span class="c1"># if k-points have less than 3 coordinates (low dimensionality), fill</span>
        <span class="c1"># with constant values the non-periodic dimensions</span>
        <span class="k">if</span> <span class="n">the_kpoints</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">fill_values</span><span class="p">):</span>
                <span class="c1"># replace scalar by a list of 3-the_kpoints.shape[1] identical</span>
                <span class="c1"># elements</span>
                <span class="n">fill_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">fill_values</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">3</span> <span class="o">-</span> <span class="n">the_kpoints</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fill_values</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="o">-</span> <span class="n">the_kpoints</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;fill_values should be either a scalar or a &quot;</span>
                                 <span class="s2">&quot;length-</span><span class="si">{}</span><span class="s2"> list&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="mi">3</span> <span class="o">-</span> <span class="n">the_kpoints</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tmp_kpoints</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">the_kpoints</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">))</span>
                <span class="n">i_kpts</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">i_fill</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">idim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                    <span class="c1"># check periodic boundary condition of each of the 3 dimensions:</span>
                    <span class="c1"># - if it&#39;s a periodic one, fill with the k-points values</span>
                    <span class="c1"># defined in input</span>
                    <span class="c1"># - if it&#39;s non-periodic, fill with one of the values in</span>
                    <span class="c1"># fill_values</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pbc</span><span class="p">[</span><span class="n">idim</span><span class="p">]:</span>
                        <span class="n">tmp_kpoints</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">tmp_kpoints</span><span class="p">,</span> <span class="n">the_kpoints</span><span class="p">[:,</span> <span class="n">i_kpts</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">the_kpoints</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                                                                 <span class="mi">1</span><span class="p">))))</span>
                        <span class="n">i_kpts</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">tmp_kpoints</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">tmp_kpoints</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span>
                            <span class="p">(</span><span class="n">the_kpoints</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">fill_values</span><span class="p">[</span><span class="n">i_fill</span><span class="p">]))</span>
                        <span class="n">i_fill</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">the_kpoints</span> <span class="o">=</span> <span class="n">tmp_kpoints</span>

        <span class="c1"># change reference and always store in crystal coords</span>
        <span class="k">if</span> <span class="n">cartesian</span><span class="p">:</span>
            <span class="n">the_kpoints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_change_reference</span><span class="p">(</span><span class="n">the_kpoints</span><span class="p">,</span> <span class="n">to_cartesian</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># check that we did not saved a mesh already</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="s1">&#39;mesh&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ModificationNotAllowed</span><span class="p">(</span><span class="s2">&quot;KpointsData has already a mesh stored&quot;</span><span class="p">)</span>

        <span class="c1"># store</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_array</span><span class="p">(</span><span class="s1">&#39;kpoints&#39;</span><span class="p">,</span> <span class="n">the_kpoints</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">the_weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_array</span><span class="p">(</span><span class="s1">&#39;weights&#39;</span><span class="p">,</span> <span class="n">the_weights</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">labels</span> <span class="o">=</span> <span class="n">labels</span></div>

<div class="viewcode-block" id="KpointsData.get_kpoints"><a class="viewcode-back" href="../../../../../../developer_guide/core/orm_overview.html#aiida.orm.KpointsData.get_kpoints">[docs]</a>    <span class="k">def</span> <span class="nf">get_kpoints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">also_weights</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cartesian</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the list of kpoints</span>

<span class="sd">        :param also_weights: if True, returns also the list of weights.</span>
<span class="sd">            Default = False</span>
<span class="sd">        :param cartesian: if True, returns points in cartesian coordinates,</span>
<span class="sd">            otherwise, returns in crystal coordinates. Default = False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">kpoints</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_array</span><span class="p">(</span><span class="s1">&#39;kpoints&#39;</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;Before the get, first set a list of kpoints&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">cartesian</span><span class="p">:</span>
            <span class="n">kpoints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_change_reference</span><span class="p">(</span><span class="n">kpoints</span><span class="p">,</span> <span class="n">to_cartesian</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">also_weights</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">the_weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_array</span><span class="p">(</span><span class="s1">&#39;weights&#39;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;No weights were set&#39;</span><span class="p">)</span>

            <span class="n">weights</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">the_weights</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">kpoints</span><span class="p">,</span> <span class="n">weights</span>

        <span class="k">return</span> <span class="n">kpoints</span></div>


<span class="c1"># All functions below are deprecated and have been moved to aiida.tools.data.array.kpoints.legacy</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bravais_lattice</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The dictionary containing informations about the cell symmetry</span>

<span class="sd">        .. deprecated:: 0.11</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">warnings</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>  <span class="c1"># pylint: disable=no-member</span>
            <span class="s1">&#39;the bravais_lattice method has been deprecated, see </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">DEPRECATION_DOCS_URL</span><span class="p">),</span>
            <span class="n">AiidaDeprecationWarning</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="s1">&#39;bravais_lattice&#39;</span><span class="p">)</span>

    <span class="nd">@bravais_lattice</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">bravais_lattice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the bravais lattice dictionary</span>

<span class="sd">        .. deprecated:: 0.11</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">warnings</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>  <span class="c1"># pylint: disable=no-member</span>
            <span class="s1">&#39;the bravais_lattice method has been deprecated, see </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">DEPRECATION_DOCS_URL</span><span class="p">),</span>
            <span class="n">AiidaDeprecationWarning</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_bravais_lattice</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

<div class="viewcode-block" id="KpointsData._set_bravais_lattice"><a class="viewcode-back" href="../../../../../../developer_guide/core/orm_overview.html#aiida.orm.KpointsData._set_bravais_lattice">[docs]</a>    <span class="k">def</span> <span class="nf">_set_bravais_lattice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Validating function to set the bravais_lattice dictionary</span>

<span class="sd">        .. deprecated:: 0.11</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">warnings</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>  <span class="c1"># pylint: disable=no-member</span>
            <span class="s1">&#39;the _set_bravais_lattice method has been deprecated, see </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">DEPRECATION_DOCS_URL</span><span class="p">),</span>
            <span class="n">AiidaDeprecationWarning</span><span class="p">)</span>

        <span class="kn">import</span> <span class="nn">copy</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;bravais_lattice is not a dict&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">([</span><span class="n">i</span> <span class="ow">in</span> <span class="n">value</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;short_name&quot;</span><span class="p">,</span> <span class="s2">&quot;extended_name&quot;</span><span class="p">,</span> <span class="s2">&quot;index&quot;</span><span class="p">,</span> <span class="s2">&quot;permutation&quot;</span><span class="p">]]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">()</span>

        <span class="n">bravais_lattice</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="n">bravais_lattice</span><span class="p">[</span><span class="s1">&#39;permutation&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">value</span><span class="p">[</span><span class="s1">&#39;permutation&#39;</span><span class="p">]]</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bravais_lattice</span><span class="p">[</span><span class="s1">&#39;variation&#39;</span><span class="p">],</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bravais_lattice</span><span class="p">[</span><span class="s1">&#39;extra&#39;</span><span class="p">],</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">bravais_lattice</span><span class="p">[</span><span class="s1">&#39;extra&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()]):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="s1">&#39;bravais_lattice&#39;</span><span class="p">,</span> <span class="n">bravais_lattice</span><span class="p">)</span></div>

<div class="viewcode-block" id="KpointsData._get_or_create_bravais_lattice"><a class="viewcode-back" href="../../../../../../developer_guide/core/orm_overview.html#aiida.orm.KpointsData._get_or_create_bravais_lattice">[docs]</a>    <span class="k">def</span> <span class="nf">_get_or_create_bravais_lattice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                       <span class="n">epsilon_length</span><span class="o">=</span><span class="n">_DEFAULT_EPSILON_LENGTH</span><span class="p">,</span>
                                       <span class="n">epsilon_angle</span><span class="o">=</span><span class="n">_DEFAULT_EPSILON_ANGLE</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Try to get the bravais_lattice info if stored already, otherwise analyze</span>
<span class="sd">        the cell with the default settings and save this in the attribute.</span>

<span class="sd">        .. deprecated:: 0.11</span>
<span class="sd">           Use the methods inside the :ref:`aiida.tools.data.array.kpoints&lt;AutomaticKpoints&gt;` module instead.</span>

<span class="sd">        :param epsilon_length: threshold on lengths comparison, used</span>
<span class="sd">             to get the bravais lattice info</span>
<span class="sd">        :param epsilon_angle: threshold on angles comparison, used</span>
<span class="sd">             to get the bravais lattice info</span>

<span class="sd">        :return bravais_lattice: the dictionary containing the symmetry info</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">warnings</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>  <span class="c1"># pylint: disable=no-member</span>
            <span class="s1">&#39;the _get_or_create_bravais_lattice method has been deprecated, see </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">DEPRECATION_DOCS_URL</span><span class="p">),</span>
            <span class="n">AiidaDeprecationWarning</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">bravais_lattice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bravais_lattice</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">bravais_lattice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_bravais_info</span><span class="p">(</span><span class="n">epsilon_length</span><span class="o">=</span><span class="n">epsilon_length</span><span class="p">,</span> <span class="n">epsilon_angle</span><span class="o">=</span><span class="n">epsilon_angle</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bravais_lattice</span> <span class="o">=</span> <span class="n">bravais_lattice</span>
        <span class="k">return</span> <span class="n">bravais_lattice</span></div>

<div class="viewcode-block" id="KpointsData.set_kpoints_path"><a class="viewcode-back" href="../../../../../../developer_guide/core/orm_overview.html#aiida.orm.KpointsData.set_kpoints_path">[docs]</a>    <span class="k">def</span> <span class="nf">set_kpoints_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                         <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">kpoint_distance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">cartesian</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                         <span class="n">epsilon_length</span><span class="o">=</span><span class="n">_DEFAULT_EPSILON_LENGTH</span><span class="p">,</span>
                         <span class="n">epsilon_angle</span><span class="o">=</span><span class="n">_DEFAULT_EPSILON_ANGLE</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set a path of kpoints in the Brillouin zone.</span>

<span class="sd">        .. deprecated:: 0.11</span>
<span class="sd">           Use the methods inside the :ref:`aiida.tools.data.array.kpoints&lt;AutomaticKpoints&gt;` module instead.</span>

<span class="sd">        :param value: description of the path, in various possible formats.</span>

<span class="sd">            None: automatically sets all irreducible high symmetry paths.</span>
<span class="sd">            Requires that a cell was set</span>

<span class="sd">            or</span>

<span class="sd">            [(&#39;G&#39;,&#39;M&#39;), (...), ...]</span>
<span class="sd">            [(&#39;G&#39;,&#39;M&#39;,30), (...), ...]</span>
<span class="sd">            [(&#39;G&#39;,(0,0,0),&#39;M&#39;,(1,1,1)), (...), ...]</span>
<span class="sd">            [(&#39;G&#39;,(0,0,0),&#39;M&#39;,(1,1,1),30), (...), ...]</span>

<span class="sd">        :param bool cartesian: if set to true, reads the coordinates eventually</span>
<span class="sd">            passed in value as cartesian coordinates. Default: False.</span>
<span class="sd">        :param float kpoint_distance: parameter controlling the distance between</span>
<span class="sd">            kpoints. Distance is given in crystal coordinates, i.e. the distance</span>
<span class="sd">            is computed in the space of b1,b2,b3. The distance set will be the</span>
<span class="sd">            closest possible to this value, compatible with the requirement of</span>
<span class="sd">            putting equispaced points between two special points (since extrema</span>
<span class="sd">            are included).</span>
<span class="sd">        :param float epsilon_length: threshold on lengths comparison, used</span>
<span class="sd">            to get the bravais lattice info. It has to be used if the</span>
<span class="sd">            user wants to be sure the right symmetries are recognized.</span>
<span class="sd">        :param float epsilon_angle: threshold on angles comparison, used</span>
<span class="sd">            to get the bravais lattice info. It has to be used if the</span>
<span class="sd">            user wants to be sure the right symmetries are recognized.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">warnings</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>  <span class="c1"># pylint: disable=no-member</span>
            <span class="s1">&#39;the set_kpoints_path method has been deprecated, see </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">DEPRECATION_DOCS_URL</span><span class="p">),</span>
            <span class="n">AiidaDeprecationWarning</span><span class="p">)</span>

        <span class="kn">from</span> <span class="nn">aiida.tools.data.array.kpoints.legacy</span> <span class="k">import</span> <span class="n">get_explicit_kpoints_path</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">cell</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">cell</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">pbc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pbc</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">pbc</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">point_coords</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">bravais_info</span><span class="p">,</span> <span class="n">explicit_kpoints</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="n">get_explicit_kpoints_path</span><span class="p">(</span>  <span class="c1"># pylint: disable=unused-variable</span>
            <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">,</span>
            <span class="n">cell</span><span class="o">=</span><span class="n">cell</span><span class="p">,</span>
            <span class="n">pbc</span><span class="o">=</span><span class="n">pbc</span><span class="p">,</span>
            <span class="n">kpoint_distance</span><span class="o">=</span><span class="n">kpoint_distance</span><span class="p">,</span>
            <span class="n">cartesian</span><span class="o">=</span><span class="n">cartesian</span><span class="p">,</span>
            <span class="n">epsilon_length</span><span class="o">=</span><span class="n">epsilon_length</span><span class="p">,</span>
            <span class="n">epsilon_angle</span><span class="o">=</span><span class="n">epsilon_angle</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_kpoints</span><span class="p">(</span><span class="n">explicit_kpoints</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labels</span> <span class="o">=</span> <span class="n">labels</span></div>

<div class="viewcode-block" id="KpointsData._find_bravais_info"><a class="viewcode-back" href="../../../../../../developer_guide/core/orm_overview.html#aiida.orm.KpointsData._find_bravais_info">[docs]</a>    <span class="k">def</span> <span class="nf">_find_bravais_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">epsilon_length</span><span class="o">=</span><span class="n">_DEFAULT_EPSILON_LENGTH</span><span class="p">,</span> <span class="n">epsilon_angle</span><span class="o">=</span><span class="n">_DEFAULT_EPSILON_ANGLE</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds the Bravais lattice of the cell passed in input to the Kpoint class</span>
<span class="sd">        :note: We assume that the cell given by the cell property is the</span>
<span class="sd">        primitive unit cell.</span>

<span class="sd">        .. deprecated:: 0.11</span>
<span class="sd">           Use the methods inside the :ref:`aiida.tools.data.array.kpoints&lt;AutomaticKpoints&gt;` module instead.</span>

<span class="sd">        :return: a dictionary, with keys short_name, extended_name, index</span>
<span class="sd">                (index of the Bravais lattice), and sometimes variation (name of</span>
<span class="sd">                the variation of the Bravais lattice) and extra (a dictionary</span>
<span class="sd">                with extra parameters used by the get_special_points method)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">warnings</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>  <span class="c1"># pylint: disable=no-member</span>
            <span class="s1">&#39;the _find_bravais_info method has been deprecated, see </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">DEPRECATION_DOCS_URL</span><span class="p">),</span>
            <span class="n">AiidaDeprecationWarning</span><span class="p">)</span>

        <span class="kn">from</span> <span class="nn">aiida.tools.data.array.kpoints.legacy</span> <span class="k">import</span> <span class="n">find_bravais_info</span>
        <span class="k">return</span> <span class="n">find_bravais_info</span><span class="p">(</span>
            <span class="n">cell</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">,</span> <span class="n">pbc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pbc</span><span class="p">,</span> <span class="n">epsilon_length</span><span class="o">=</span><span class="n">epsilon_length</span><span class="p">,</span> <span class="n">epsilon_angle</span><span class="o">=</span><span class="n">epsilon_angle</span><span class="p">)</span></div>

<div class="viewcode-block" id="KpointsData.find_bravais_lattice"><a class="viewcode-back" href="../../../../../../developer_guide/core/orm_overview.html#aiida.orm.KpointsData.find_bravais_lattice">[docs]</a>    <span class="k">def</span> <span class="nf">find_bravais_lattice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">epsilon_length</span><span class="o">=</span><span class="n">_DEFAULT_EPSILON_LENGTH</span><span class="p">,</span> <span class="n">epsilon_angle</span><span class="o">=</span><span class="n">_DEFAULT_EPSILON_ANGLE</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Analyze the symmetry of the cell. Allows to relax or tighten the</span>
<span class="sd">        thresholds used to compare angles and lengths of the cell. Save the</span>
<span class="sd">        information of the cell used for later use (like getting special</span>
<span class="sd">        points). It has to be used if the user wants to be sure the right</span>
<span class="sd">        symmetries are recognized. Otherwise, this function is automatically</span>
<span class="sd">        called with the default values.</span>

<span class="sd">        If the right symmetry is not found, be sure also you are providing cells</span>
<span class="sd">        with enough digits.</span>

<span class="sd">        If node is already stored, just returns the symmetry found before</span>
<span class="sd">        storing (if any).</span>

<span class="sd">        .. deprecated:: 0.11</span>
<span class="sd">           Use the methods inside the :ref:`aiida.tools.data.array.kpoints&lt;AutomaticKpoints&gt;` module instead.</span>

<span class="sd">        :return (str) lattice_name: the name of the bravais lattice and its</span>
<span class="sd">             eventual variation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">warnings</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>  <span class="c1"># pylint: disable=no-member</span>
            <span class="s1">&#39;the find_bravais_lattice method has been deprecated, see </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">DEPRECATION_DOCS_URL</span><span class="p">),</span>
            <span class="n">AiidaDeprecationWarning</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_stored</span><span class="p">:</span>
            <span class="n">bravais_lattice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_bravais_info</span><span class="p">(</span><span class="n">epsilon_length</span><span class="o">=</span><span class="n">epsilon_length</span><span class="p">,</span> <span class="n">epsilon_angle</span><span class="o">=</span><span class="n">epsilon_angle</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bravais_lattice</span> <span class="o">=</span> <span class="n">bravais_lattice</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bravais_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bravais_lattice</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">variation</span> <span class="o">=</span> <span class="s2">&quot;, variation: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">bravais_info</span><span class="p">[</span><span class="s1">&#39;variation&#39;</span><span class="p">])</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">variation</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="k">return</span> <span class="n">bravais_info</span><span class="p">[</span><span class="s1">&#39;extended_name&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">variation</span></div>

<div class="viewcode-block" id="KpointsData.get_special_points"><a class="viewcode-back" href="../../../../../../developer_guide/core/orm_overview.html#aiida.orm.KpointsData.get_special_points">[docs]</a>    <span class="k">def</span> <span class="nf">get_special_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                           <span class="n">cartesian</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                           <span class="n">epsilon_length</span><span class="o">=</span><span class="n">_DEFAULT_EPSILON_LENGTH</span><span class="p">,</span>
                           <span class="n">epsilon_angle</span><span class="o">=</span><span class="n">_DEFAULT_EPSILON_ANGLE</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the special point and path of a given structure.</span>

<span class="sd">        References:</span>

<span class="sd">        - In 2D, coordinates are based on the paper:</span>
<span class="sd">          R. Ramirez and M. C. Bohm,  Int. J. Quant. Chem., XXX, pp. 391-411 (1986)</span>

<span class="sd">        - In 3D, coordinates are based on the paper:</span>
<span class="sd">          W. Setyawan, S. Curtarolo, Comp. Mat. Sci. 49, 299 (2010)</span>

<span class="sd">        .. deprecated:: 0.11</span>
<span class="sd">           Use the methods inside the :ref:`aiida.tools.data.array.kpoints&lt;AutomaticKpoints&gt;` module instead.</span>

<span class="sd">        :param cartesian: If true, returns points in cartesian coordinates.</span>
<span class="sd">            Crystal coordinates otherwise. Default=False</span>
<span class="sd">        :param epsilon_length: threshold on lengths comparison, used to get the bravais lattice info</span>
<span class="sd">        :param epsilon_angle: threshold on angles comparison, used to get the bravais lattice info</span>
<span class="sd">        :returns point_coords: a dictionary of point_name:point_coords key,values.</span>
<span class="sd">        :returns path: the suggested path which goes through all high symmetry lines.</span>
<span class="sd">            A list of lists for all path segments. e.g. [(&#39;G&#39;,&#39;X&#39;),(&#39;X&#39;,&#39;M&#39;),...]</span>
<span class="sd">            It&#39;s not necessarily a continuous line.</span>
<span class="sd">        :note: We assume that the cell given by the cell property is the primitive unit cell</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">warnings</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>  <span class="c1"># pylint: disable=no-member</span>
            <span class="s1">&#39;the get_special_points method has been deprecated, see </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">DEPRECATION_DOCS_URL</span><span class="p">),</span>
            <span class="n">AiidaDeprecationWarning</span><span class="p">)</span>

        <span class="kn">from</span> <span class="nn">aiida.tools.data.array.kpoints.legacy</span> <span class="k">import</span> <span class="n">get_kpoints_path</span>
        <span class="n">point_coords</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">bravais_info</span> <span class="o">=</span> <span class="n">get_kpoints_path</span><span class="p">(</span>  <span class="c1"># pylint: disable=unused-variable</span>
            <span class="n">cell</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">,</span>
            <span class="n">pbc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pbc</span><span class="p">,</span>
            <span class="n">cartesian</span><span class="o">=</span><span class="n">cartesian</span><span class="p">,</span>
            <span class="n">epsilon_length</span><span class="o">=</span><span class="n">epsilon_length</span><span class="p">,</span>
            <span class="n">epsilon_angle</span><span class="o">=</span><span class="n">epsilon_angle</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">point_coords</span><span class="p">,</span> <span class="n">path</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, ECOLE POLYTECHNIQUE FEDERALE DE LAUSANNE (Theory and Simulation of Materials (THEOS) and National Centre for Computational Design and Discovery of Novel Materials (NCCR MARVEL)), Switzerland and ROBERT BOSCH LLC, USA. All rights reserved

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>