

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>aiida.orm.nodes.data.cif &mdash; AiiDA 1.0.0b2 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../../" src="../../../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../../../_static/language_data.js"></script>
        <script type="text/javascript" src="../../../../../_static/contentui.js"></script>
    
    <script type="text/javascript" src="../../../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../../../_static/contentui.css" type="text/css" />
    <link rel="index" title="Index" href="../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../../../index.html" class="icon icon-home"> AiiDA
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Installation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../install/quick_installation.html">Quick installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../install/prerequisites.html">Prerequisites</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../install/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../install/updating_installation.html">Updating AiiDA</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../install/troubleshooting.html">Troubleshooting</a></li>
</ul>
<p class="caption"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../get_started/index.html">First things first</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../get_started/daemon.html">Setup the daemon</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../get_started/computers.html">Setup a computer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../get_started/codes.html">Setup a code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../get_started/plugins.html">Plugins</a></li>
</ul>
<p class="caption"><span class="caption-text">Concepts</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../concepts/provenance.html">Provenance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../concepts/processes.html">Processes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../concepts/calculations.html">Calculations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../concepts/workflows.html">Workflows</a></li>
</ul>
<p class="caption"><span class="caption-text">Working with</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../working/processes.html">Processes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../working/functions.html">Calculation and work functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../working/calculations.html">Calculations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../working/workflows.html">Workflows</a></li>
</ul>
<p class="caption"><span class="caption-text">Working with AiiDA</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../working_with_aiida/index.html">Command line interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../working_with_aiida/index.html#scripting">Scripting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../working_with_aiida/index.html#data-types">Data types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../working_with_aiida/index.html#groups">Groups</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../working_with_aiida/index.html#schedulers">Schedulers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../working_with_aiida/index.html#querying-data">Querying data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../working_with_aiida/index.html#caching">Caching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../working_with_aiida/index.html#result-manager">Result manager</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../working_with_aiida/index.html#backups">Backups</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../working_with_aiida/index.html#troubleshooting">Troubleshooting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../working_with_aiida/index.html#rest-api">REST API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../working_with_aiida/index.html#cookbook">Cookbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../import_export/index.html">Import and Export</a></li>
</ul>
<p class="caption"><span class="caption-text">Development</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../developer_guide/index.html">AiiDA design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../developer_guide/index.html#aiida-core">AiiDA core</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../developer_guide/index.html#aiida-plugins">AiiDA plugins</a></li>
</ul>
<p class="caption"><span class="caption-text">Tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../tutorial/index.html">StructureData</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../tutorial/index.html#pseudopotentials">Pseudopotentials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../tutorial/index.html#plugin-development">Plugin development</a></li>
</ul>
<p class="caption"><span class="caption-text">API reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="`aiida package &lt;https://aiida-core.readthedocs.io/en/latest/apidoc/aiida.html&gt;`_">`aiida package &lt;https://aiida-core.readthedocs.io/en/latest/apidoc/aiida.html&gt;`_</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../index.html">AiiDA</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../../../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../../../../aiida.html">aiida</a> &raquo;</li>
        
      <li>aiida.orm.nodes.data.cif</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for aiida.orm.nodes.data.cif</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1">###########################################################################</span>
<span class="c1"># Copyright (c), The AiiDA team. All rights reserved.                     #</span>
<span class="c1"># This file is part of the AiiDA code.                                    #</span>
<span class="c1">#                                                                         #</span>
<span class="c1"># The code is hosted on GitHub at https://github.com/aiidateam/aiida_core #</span>
<span class="c1"># For further information on the license, see the LICENSE.txt file        #</span>
<span class="c1"># For further information please visit http://www.aiida.net               #</span>
<span class="c1">###########################################################################</span>
<span class="c1"># pylint: disable=invalid-name,too-many-locals,too-many-statements</span>
<span class="sd">&quot;&quot;&quot;Tools for handling Crystallographic Information Files (CIF)&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span>

<span class="kn">from</span> <span class="nn">aiida.common.utils</span> <span class="k">import</span> <span class="n">Capturing</span>

<span class="kn">from</span> <span class="nn">.singlefile</span> <span class="k">import</span> <span class="n">SinglefileData</span>

<span class="n">ase_loops</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;_atom_site&#39;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">&#39;_atom_site_label&#39;</span><span class="p">,</span>
        <span class="s1">&#39;_atom_site_occupancy&#39;</span><span class="p">,</span>
        <span class="s1">&#39;_atom_site_fract_x&#39;</span><span class="p">,</span>
        <span class="s1">&#39;_atom_site_fract_y&#39;</span><span class="p">,</span>
        <span class="s1">&#39;_atom_site_fract_z&#39;</span><span class="p">,</span>
        <span class="s1">&#39;_atom_site_adp_type&#39;</span><span class="p">,</span>
        <span class="s1">&#39;_atom_site_thermal_displace_type&#39;</span><span class="p">,</span>
        <span class="s1">&#39;_atom_site_B_iso_or_equiv&#39;</span><span class="p">,</span>
        <span class="s1">&#39;_atom_site_U_iso_or_equiv&#39;</span><span class="p">,</span>
        <span class="s1">&#39;_atom_site_B_equiv_geom_mean&#39;</span><span class="p">,</span>
        <span class="s1">&#39;_atom_site_U_equiv_geom_mean&#39;</span><span class="p">,</span>
        <span class="s1">&#39;_atom_site_type_symbol&#39;</span><span class="p">,</span>
    <span class="p">]</span>
<span class="p">}</span>


<div class="viewcode-block" id="has_pycifrw"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.has_pycifrw">[docs]</a><span class="k">def</span> <span class="nf">has_pycifrw</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :return: True if the PyCifRW module can be imported, False otherwise.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># pylint: disable=unused-variable,unused-import</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">CifFile</span>
        <span class="kn">from</span> <span class="nn">CifFile</span> <span class="k">import</span> <span class="n">CifBlock</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="cif_from_ase"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.cif_from_ase">[docs]</a><span class="k">def</span> <span class="nf">cif_from_ase</span><span class="p">(</span><span class="n">ase</span><span class="p">,</span> <span class="n">full_occupancies</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">add_fake_biso</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Construct a CIF datablock from the ASE structure. The code is taken</span>
<span class="sd">    from</span>
<span class="sd">    https://wiki.fysik.dtu.dk/ase/epydoc/ase.io.cif-pysrc.html#write_cif,</span>
<span class="sd">    as the original ASE code contains a bug in printing the</span>
<span class="sd">    Hermann-Mauguin symmetry space group symbol.</span>

<span class="sd">    :param ase: ASE &quot;images&quot;</span>
<span class="sd">    :return: array of CIF datablocks</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">arccos</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">dot</span>
    <span class="kn">from</span> <span class="nn">numpy.linalg</span> <span class="k">import</span> <span class="n">norm</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ase</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="n">ase</span> <span class="o">=</span> <span class="p">[</span><span class="n">ase</span><span class="p">]</span>

    <span class="n">datablocks</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">atoms</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ase</span><span class="p">):</span>
        <span class="n">datablock</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="n">cell</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">cell</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">cell</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">cell</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">cell</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">arccos</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">cell</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">cell</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">b</span> <span class="o">*</span> <span class="n">c</span><span class="p">))</span> <span class="o">*</span> <span class="mf">180.</span> <span class="o">/</span> <span class="n">pi</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="n">arccos</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">cell</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cell</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">c</span><span class="p">))</span> <span class="o">*</span> <span class="mf">180.</span> <span class="o">/</span> <span class="n">pi</span>
        <span class="n">gamma</span> <span class="o">=</span> <span class="n">arccos</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">cell</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cell</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">))</span> <span class="o">*</span> <span class="mf">180.</span> <span class="o">/</span> <span class="n">pi</span>

        <span class="n">datablock</span><span class="p">[</span><span class="s1">&#39;_cell_length_a&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">datablock</span><span class="p">[</span><span class="s1">&#39;_cell_length_b&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="n">datablock</span><span class="p">[</span><span class="s1">&#39;_cell_length_c&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="n">datablock</span><span class="p">[</span><span class="s1">&#39;_cell_angle_alpha&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="n">datablock</span><span class="p">[</span><span class="s1">&#39;_cell_angle_beta&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span>
        <span class="n">datablock</span><span class="p">[</span><span class="s1">&#39;_cell_angle_gamma&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">atoms</span><span class="o">.</span><span class="n">pbc</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="n">datablock</span><span class="p">[</span><span class="s1">&#39;_symmetry_space_group_name_H-M&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;P 1&#39;</span>
            <span class="n">datablock</span><span class="p">[</span><span class="s1">&#39;_symmetry_int_tables_number&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">datablock</span><span class="p">[</span><span class="s1">&#39;_symmetry_equiv_pos_as_xyz&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;x, y, z&#39;</span><span class="p">]</span>

        <span class="n">datablock</span><span class="p">[</span><span class="s1">&#39;_atom_site_label&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">datablock</span><span class="p">[</span><span class="s1">&#39;_atom_site_fract_x&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">datablock</span><span class="p">[</span><span class="s1">&#39;_atom_site_fract_y&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">datablock</span><span class="p">[</span><span class="s1">&#39;_atom_site_fract_z&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">datablock</span><span class="p">[</span><span class="s1">&#39;_atom_site_type_symbol&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">full_occupancies</span><span class="p">:</span>
            <span class="n">datablock</span><span class="p">[</span><span class="s1">&#39;_atom_site_occupancy&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">add_fake_biso</span><span class="p">:</span>
            <span class="n">datablock</span><span class="p">[</span><span class="s1">&#39;_atom_site_thermal_displace_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">datablock</span><span class="p">[</span><span class="s1">&#39;_atom_site_B_iso_or_equiv&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">scaled</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">get_scaled_positions</span><span class="p">()</span>
        <span class="n">no</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">atom</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">atoms</span><span class="p">):</span>
            <span class="n">symbol</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">symbol</span>
            <span class="k">if</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="n">no</span><span class="p">:</span>
                <span class="n">no</span><span class="p">[</span><span class="n">symbol</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">no</span><span class="p">[</span><span class="n">symbol</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">datablock</span><span class="p">[</span><span class="s1">&#39;_atom_site_label&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">symbol</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">no</span><span class="p">[</span><span class="n">symbol</span><span class="p">]))</span>
            <span class="n">datablock</span><span class="p">[</span><span class="s1">&#39;_atom_site_fract_x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">scaled</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">datablock</span><span class="p">[</span><span class="s1">&#39;_atom_site_fract_y&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">scaled</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]))</span>
            <span class="n">datablock</span><span class="p">[</span><span class="s1">&#39;_atom_site_fract_z&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">scaled</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]))</span>
            <span class="n">datablock</span><span class="p">[</span><span class="s1">&#39;_atom_site_type_symbol&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">symbol</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">full_occupancies</span><span class="p">:</span>
                <span class="n">datablock</span><span class="p">[</span><span class="s1">&#39;_atom_site_occupancy&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="mf">1.0</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">add_fake_biso</span><span class="p">:</span>
                <span class="n">datablock</span><span class="p">[</span><span class="s1">&#39;_atom_site_thermal_displace_type&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;Biso&#39;</span><span class="p">)</span>
                <span class="n">datablock</span><span class="p">[</span><span class="s1">&#39;_atom_site_B_iso_or_equiv&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="mf">1.0</span><span class="p">))</span>

        <span class="n">datablocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">datablock</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">datablocks</span></div>


<span class="c1"># pylint: disable=too-many-branches</span>
<div class="viewcode-block" id="pycifrw_from_cif"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.pycifrw_from_cif">[docs]</a><span class="k">def</span> <span class="nf">pycifrw_from_cif</span><span class="p">(</span><span class="n">datablocks</span><span class="p">,</span> <span class="n">loops</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Constructs PyCifRW&#39;s CifFile from an array of CIF datablocks.</span>

<span class="sd">    :param datablocks: an array of CIF datablocks</span>
<span class="sd">    :param loops: optional dict of lists of CIF tag loops.</span>
<span class="sd">    :param names: optional list of datablock names</span>
<span class="sd">    :return: CifFile</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">CifFile</span>
        <span class="kn">from</span> <span class="nn">CifFile</span> <span class="k">import</span> <span class="n">CifBlock</span>
    <span class="k">except</span> <span class="ne">ImportError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">exc</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;. You need to install the PyCifRW package.&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">loops</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">loops</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="n">cif</span> <span class="o">=</span> <span class="n">CifFile</span><span class="o">.</span><span class="n">CifFile</span><span class="p">()</span>  <span class="c1"># pylint: disable=no-member</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">cif</span><span class="o">.</span><span class="n">set_grammar</span><span class="p">(</span><span class="s2">&quot;1.1&quot;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="c1"># if no grammar can be set, we assume it&#39;s 1.1 (widespread standard)</span>
        <span class="k">pass</span>

    <span class="k">if</span> <span class="n">names</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">datablocks</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Not enough names supplied for &quot;</span>
                         <span class="s2">&quot;datablocks: </span><span class="si">{}</span><span class="s2"> (names) &lt; &quot;</span>
                         <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> (datablocks)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">datablocks</span><span class="p">)))</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">values</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">datablocks</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">names</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">datablock</span> <span class="o">=</span> <span class="n">CifBlock</span><span class="p">()</span>
        <span class="n">cif</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">datablock</span>
        <span class="n">tags_in_loops</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">loopname</span> <span class="ow">in</span> <span class="n">loops</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">row_size</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">tags_seen</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">loops</span><span class="p">[</span><span class="n">loopname</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
                    <span class="n">tag_values</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tag_values</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                        <span class="n">tag_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">tag_values</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">row_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">row_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tag_values</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">row_size</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tag_values</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Number of values for tag &quot;</span>
                                         <span class="s2">&quot;&#39;</span><span class="si">{}</span><span class="s2">&#39; is different from &quot;</span>
                                         <span class="s2">&quot;the others in the same &quot;</span>
                                         <span class="s2">&quot;loop&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">row_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">datablock</span><span class="o">.</span><span class="n">AddItem</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="n">tag_values</span><span class="p">)</span>
                    <span class="n">tags_seen</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span>
                    <span class="n">tags_in_loops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">row_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">row_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">datablock</span><span class="o">.</span><span class="n">CreateLoop</span><span class="p">(</span><span class="n">datanames</span><span class="o">=</span><span class="n">tags_seen</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">tags_in_loops</span><span class="p">:</span>
                <span class="n">datablock</span><span class="o">.</span><span class="n">AddItem</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="n">values</span><span class="p">[</span><span class="n">tag</span><span class="p">])</span>
                <span class="c1"># create automatically a loop for non-scalar values</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">tag</span><span class="p">],</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">))</span> <span class="ow">and</span> <span class="n">tag</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">loops</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">datablock</span><span class="o">.</span><span class="n">CreateLoop</span><span class="p">([</span><span class="n">tag</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">cif</span></div>


<div class="viewcode-block" id="parse_formula"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.parse_formula">[docs]</a><span class="k">def</span> <span class="nf">parse_formula</span><span class="p">(</span><span class="n">formula</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parses the Hill formulae, written with spaces for separators.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">re</span>

    <span class="n">contents</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\s+&#39;</span><span class="p">,</span> <span class="n">formula</span><span class="p">):</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(\D+)([\.\d]+)?&#39;</span><span class="p">,</span> <span class="n">part</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">specie</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">quantity</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">quantity</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">quantity</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^\d+$&#39;</span><span class="p">,</span> <span class="n">quantity</span><span class="p">):</span>
                <span class="n">quantity</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">quantity</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">quantity</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">quantity</span><span class="p">)</span>
        <span class="n">contents</span><span class="p">[</span><span class="n">specie</span><span class="p">]</span> <span class="o">=</span> <span class="n">quantity</span>
    <span class="k">return</span> <span class="n">contents</span></div>


<span class="c1"># pylint: disable=abstract-method,too-many-public-methods</span>
<span class="c1"># Note:  Method &#39;query&#39; is abstract in class &#39;Node&#39; but is not overridden</span>
<div class="viewcode-block" id="CifData"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.CifData">[docs]</a><span class="k">class</span> <span class="nc">CifData</span><span class="p">(</span><span class="n">SinglefileData</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrapper for Crystallographic Interchange File (CIF)</span>

<span class="sd">    .. note:: the file (physical) is held as the authoritative source of</span>
<span class="sd">        information, so all conversions are done through the physical file:</span>
<span class="sd">        when setting ``ase`` or ``values``, a physical CIF file is generated</span>
<span class="sd">        first, the values are updated from the physical CIF file.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># pylint: disable=abstract-method, too-many-public-methods</span>
    <span class="n">_set_incompatibilities</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;ase&#39;</span><span class="p">,</span> <span class="s1">&#39;file&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;ase&#39;</span><span class="p">,</span> <span class="s1">&#39;values&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;file&#39;</span><span class="p">,</span> <span class="s1">&#39;values&#39;</span><span class="p">)]</span>
    <span class="n">_scan_types</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;standard&#39;</span><span class="p">,</span> <span class="s1">&#39;flex&#39;</span><span class="p">)</span>
    <span class="n">_parse_policies</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;eager&#39;</span><span class="p">,</span> <span class="s1">&#39;lazy&#39;</span><span class="p">)</span>
    <span class="n">_values</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_ase</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="CifData.__init__"><a class="viewcode-back" href="../../../../../apidoc/aiida.orm.nodes.data.html#aiida.backends.tests.test_dataclasses.CifData.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">ase</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">values</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">source</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">scan_type</span><span class="o">=</span><span class="s1">&#39;standard&#39;</span><span class="p">,</span>
                 <span class="n">parse_policy</span><span class="o">=</span><span class="s1">&#39;eager&#39;</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># pylint: disable=too-many-arguments, redefined-builtin</span>

        <span class="n">args</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;ase&#39;</span><span class="p">:</span> <span class="n">ase</span><span class="p">,</span>
            <span class="s1">&#39;file&#39;</span><span class="p">:</span> <span class="n">file</span><span class="p">,</span>
            <span class="s1">&#39;values&#39;</span><span class="p">:</span> <span class="n">values</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_incompatibilities</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">args</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">args</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;cannot pass </span><span class="si">{}</span><span class="s1"> and </span><span class="si">{}</span><span class="s1"> at the same time&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">))</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">CifData</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_scan_type</span><span class="p">(</span><span class="n">scan_type</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_parse_policy</span><span class="p">(</span><span class="n">parse_policy</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">source</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_source</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ase</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_ase</span><span class="p">(</span><span class="n">ase</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">values</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_values</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_stored</span> <span class="ow">and</span> <span class="n">file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="s1">&#39;parse_policy&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;eager&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parse</span><span class="p">()</span></div>

<div class="viewcode-block" id="CifData.read_cif"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.CifData.read_cif">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">read_cif</span><span class="p">(</span><span class="n">fileobj</span><span class="p">,</span> <span class="n">index</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A wrapper method that simulates the behavior of the old</span>
<span class="sd">        function ase.io.cif.read_cif by using the new generic ase.io.read</span>
<span class="sd">        function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">ase.io</span> <span class="k">import</span> <span class="n">read</span>

        <span class="c1"># the read function returns a list as a cif file might contain multiple</span>
        <span class="c1"># structures</span>
        <span class="n">struct_list</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">fileobj</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="s1">&#39;:&#39;</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;cif&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># If index is explicitely set to None, the list is returned as such.</span>
            <span class="k">return</span> <span class="n">struct_list</span>
        <span class="c1"># otherwise return the desired structure specified by index.</span>
        <span class="c1"># If no index is specified, the last structure is assumed by default</span>
        <span class="k">return</span> <span class="n">struct_list</span><span class="p">[</span><span class="n">index</span><span class="p">]</span></div>

<div class="viewcode-block" id="CifData.from_md5"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.CifData.from_md5">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_md5</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">md5</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of all CIF files that match a given MD5 hash.</span>

<span class="sd">        .. note:: the hash has to be stored in a ``_md5`` attribute,</span>
<span class="sd">            otherwise the CIF file will not be found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">aiida.orm.querybuilder</span> <span class="k">import</span> <span class="n">QueryBuilder</span>
        <span class="n">qb</span> <span class="o">=</span> <span class="n">QueryBuilder</span><span class="p">()</span>
        <span class="n">qb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">filters</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;attributes.md5&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;==&#39;</span><span class="p">:</span> <span class="n">md5</span><span class="p">}})</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">_</span> <span class="k">for</span> <span class="p">[</span><span class="n">_</span><span class="p">]</span> <span class="ow">in</span> <span class="n">qb</span><span class="o">.</span><span class="n">all</span><span class="p">()]</span></div>

<div class="viewcode-block" id="CifData.get_or_create"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.CifData.get_or_create">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">get_or_create</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">use_first</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">store_cif</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pass the same parameter of the init; if a file with the same md5</span>
<span class="sd">        is found, that CifData is returned.</span>

<span class="sd">        :param filename: an absolute filename on disk</span>
<span class="sd">        :param use_first: if False (default), raise an exception if more than \</span>
<span class="sd">                one CIF file is found.\</span>
<span class="sd">                If it is True, instead, use the first available CIF file.</span>
<span class="sd">        :param bool store_cif: If false, the CifData objects are not stored in</span>
<span class="sd">                the database. default=True.</span>
<span class="sd">        :return (cif, created): where cif is the CifData object, and create is either\</span>
<span class="sd">            True if the object was created, or False if the object was retrieved\</span>
<span class="sd">            from the DB.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">os</span>
        <span class="kn">from</span> <span class="nn">aiida.common.files</span> <span class="k">import</span> <span class="n">md5_file</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;filename must be an absolute path&quot;</span><span class="p">)</span>
        <span class="n">md5</span> <span class="o">=</span> <span class="n">md5_file</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

        <span class="n">cifs</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_md5</span><span class="p">(</span><span class="n">md5</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">cifs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">store_cif</span><span class="p">:</span>
                <span class="n">instance</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">file</span><span class="o">=</span><span class="n">filename</span><span class="p">)</span><span class="o">.</span><span class="n">store</span><span class="p">()</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
            <span class="n">instance</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">file</span><span class="o">=</span><span class="n">filename</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cifs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">use_first</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">cifs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">False</span><span class="p">)</span>

            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;More than one copy of a CIF file &quot;</span>
                             <span class="s2">&quot;with the same MD5 has been found in &quot;</span>
                             <span class="s2">&quot;the DB. pks=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">pk</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">cifs</span><span class="p">])))</span>

        <span class="k">return</span> <span class="n">cifs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">False</span></div>

    <span class="c1"># pylint: disable=attribute-defined-outside-init</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ase</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        ASE object, representing the CIF.</span>

<span class="sd">        .. note:: requires ASE module.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ase</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ase</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_ase</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ase</span>

<div class="viewcode-block" id="CifData.get_ase"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.CifData.get_ase">[docs]</a>    <span class="k">def</span> <span class="nf">get_ase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns ASE object, representing the CIF. This function differs</span>
<span class="sd">        from the property ``ase`` by the possibility to pass the keyworded</span>
<span class="sd">        arguments (kwargs) to ase.io.cif.read_cif().</span>

<span class="sd">        .. note:: requires ASE module.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ase</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ase</span>
        <span class="k">return</span> <span class="n">CifData</span><span class="o">.</span><span class="n">read_cif</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">open</span><span class="p">(),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="CifData.set_ase"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.CifData.set_ase">[docs]</a>    <span class="k">def</span> <span class="nf">set_ase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aseatoms</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the contents of the CifData starting from an ASE atoms object</span>

<span class="sd">        :param aseatoms: the ASE atoms object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">tempfile</span>
        <span class="n">cif</span> <span class="o">=</span> <span class="n">cif_from_ase</span><span class="p">(</span><span class="n">aseatoms</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">NamedTemporaryFile</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w+&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">tmpf</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">Capturing</span><span class="p">():</span>
                <span class="n">tmpf</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">pycifrw_from_cif</span><span class="p">(</span><span class="n">cif</span><span class="p">,</span> <span class="n">loops</span><span class="o">=</span><span class="n">ase_loops</span><span class="p">)</span><span class="o">.</span><span class="n">WriteOut</span><span class="p">())</span>
            <span class="n">tmpf</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_file</span><span class="p">(</span><span class="n">tmpf</span><span class="o">.</span><span class="n">name</span><span class="p">)</span></div>

    <span class="nd">@ase</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">ase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aseatoms</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_ase</span><span class="p">(</span><span class="n">aseatoms</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        PyCifRW structure, representing the CIF datablocks.</span>

<span class="sd">        .. note:: requires PyCifRW module.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">CifFile</span>
            <span class="kn">from</span> <span class="nn">CifFile</span> <span class="k">import</span> <span class="n">CifBlock</span>  <span class="c1"># pylint: disable=no-name-in-module</span>

            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">open</span><span class="p">()</span> <span class="k">as</span> <span class="n">handle</span><span class="p">:</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">CifFile</span><span class="o">.</span><span class="n">ReadCif</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">scantype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="s1">&#39;scan_type&#39;</span><span class="p">))</span>  <span class="c1"># pylint: disable=no-member</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">c</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">c</span><span class="o">.</span><span class="n">dictionary</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">CifBlock</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_values</span> <span class="o">=</span> <span class="n">c</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span>

<div class="viewcode-block" id="CifData.set_values"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.CifData.set_values">[docs]</a>    <span class="k">def</span> <span class="nf">set_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set internal representation to `values`.</span>

<span class="sd">        Warning: This also writes a new CIF file.</span>

<span class="sd">        :param values: PyCifRW CifFile object</span>

<span class="sd">        .. note:: requires PyCifRW module.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">tempfile</span>
        <span class="k">with</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">NamedTemporaryFile</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w+&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">tmpf</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">Capturing</span><span class="p">():</span>
                <span class="n">tmpf</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">WriteOut</span><span class="p">())</span>
            <span class="n">tmpf</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_file</span><span class="p">(</span><span class="n">tmpf</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_values</span> <span class="o">=</span> <span class="n">values</span></div>

    <span class="nd">@values</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_values</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

<div class="viewcode-block" id="CifData.parse"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.CifData.parse">[docs]</a>    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scan_type</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parses CIF file and sets attributes.</span>

<span class="sd">        :param scan_type:  See set_scan_type</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">scan_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_scan_type</span><span class="p">(</span><span class="n">scan_type</span><span class="p">)</span>

        <span class="c1"># Note: this causes parsing, if not already parsed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="s1">&#39;formulae&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_formulae</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="s1">&#39;spacegroup_numbers&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_spacegroup_numbers</span><span class="p">())</span></div>

    <span class="c1"># pylint: disable=arguments-differ</span>
<div class="viewcode-block" id="CifData.store"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.CifData.store">[docs]</a>    <span class="k">def</span> <span class="nf">store</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Store the node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_stored</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="s1">&#39;md5&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_md5</span><span class="p">())</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">CifData</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">store</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="CifData.set_file"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.CifData.set_file">[docs]</a>    <span class="k">def</span> <span class="nf">set_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the file.</span>

<span class="sd">        If the source is set and the MD5 checksum of new file</span>
<span class="sd">        is different from the source, the source has to be deleted.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># pylint: disable=redefined-builtin</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">CifData</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">set_file</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
        <span class="n">md5sum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_md5</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">and</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;source_md5&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="s1">&#39;source_md5&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">md5sum</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="s1">&#39;md5&#39;</span><span class="p">,</span> <span class="n">md5sum</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_values</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ase</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="s1">&#39;formulae&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="s1">&#39;spacegroup_numbers&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span></div>

<div class="viewcode-block" id="CifData.set_scan_type"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.CifData.set_scan_type">[docs]</a>    <span class="k">def</span> <span class="nf">set_scan_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scan_type</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the scan_type for PyCifRW.</span>

<span class="sd">        The &#39;flex&#39; scan_type of PyCifRW is faster for large CIF files but</span>
<span class="sd">        does not yet support the CIF2 format as of 02/2018.</span>
<span class="sd">        See the CifFile.ReadCif function</span>

<span class="sd">        :param scan_type: Either &#39;standard&#39; or &#39;flex&#39; (see _scan_types)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">scan_type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scan_types</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="s1">&#39;scan_type&#39;</span><span class="p">,</span> <span class="n">scan_type</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Got unknown scan_type </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">scan_type</span><span class="p">))</span></div>

<div class="viewcode-block" id="CifData.set_parse_policy"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.CifData.set_parse_policy">[docs]</a>    <span class="k">def</span> <span class="nf">set_parse_policy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parse_policy</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the parse policy.</span>

<span class="sd">        :param parse_policy: Either &#39;eager&#39; (parse CIF file on set_file)</span>
<span class="sd">            or &#39;lazy&#39; (defer parsing until needed)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">parse_policy</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_policies</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="s1">&#39;parse_policy&#39;</span><span class="p">,</span> <span class="n">parse_policy</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Got unknown parse_policy </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">parse_policy</span><span class="p">))</span></div>

<div class="viewcode-block" id="CifData.get_formulae"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.CifData.get_formulae">[docs]</a>    <span class="k">def</span> <span class="nf">get_formulae</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;sum&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return chemical formulae specified in CIF file.</span>

<span class="sd">        Note: This does not compute the formula, it only reads it from the</span>
<span class="sd">        appropriate tag. Use refine_inline to compute formulae.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># note: If formulae are not None, they could be returned</span>
        <span class="c1"># directly (but the function is very cheap anyhow).</span>
        <span class="n">formula_tag</span> <span class="o">=</span> <span class="s2">&quot;_chemical_formula_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>
        <span class="n">formulae</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">datablock</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">formula</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">formula_tag</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">datablock</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">formula</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">datablock</span><span class="p">][</span><span class="n">formula_tag</span><span class="p">]</span>
            <span class="n">formulae</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">formula</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">formulae</span></div>

<div class="viewcode-block" id="CifData.get_spacegroup_numbers"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.CifData.get_spacegroup_numbers">[docs]</a>    <span class="k">def</span> <span class="nf">get_spacegroup_numbers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the spacegroup international number.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># note: If spacegroup_numbers are not None, they could be returned</span>
        <span class="c1"># directly (but the function is very cheap anyhow).</span>
        <span class="n">spg_tags</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;_space_group.it_number&quot;</span><span class="p">,</span> <span class="s2">&quot;_space_group_it_number&quot;</span><span class="p">,</span> <span class="s2">&quot;_symmetry_int_tables_number&quot;</span><span class="p">]</span>
        <span class="n">spacegroup_numbers</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">datablock</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">spacegroup_number</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">correct_tags</span> <span class="o">=</span> <span class="p">[</span><span class="n">tag</span> <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">spg_tags</span> <span class="k">if</span> <span class="n">tag</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">datablock</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()]</span>
            <span class="k">if</span> <span class="n">correct_tags</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">spacegroup_number</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">datablock</span><span class="p">][</span><span class="n">correct_tags</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="k">pass</span>
            <span class="n">spacegroup_numbers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spacegroup_number</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">spacegroup_numbers</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_partial_occupancies</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return if the cif data contains partial occupancies</span>

<span class="sd">        A partial occupancy is defined as site with an occupancy that differs from unity, within a precision of 1E-6</span>

<span class="sd">        .. note: occupancies that cannot be parsed into a float are ignored</span>

<span class="sd">        :return: True if there are partial occupancies, False otherwise</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">re</span>

        <span class="n">tag</span> <span class="o">=</span> <span class="s1">&#39;_atom_site_occupancy&#39;</span>

        <span class="n">epsilon</span> <span class="o">=</span> <span class="mf">1e-6</span>
        <span class="n">partial_occupancies</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">for</span> <span class="n">datablock</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">tag</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">datablock</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">position</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">datablock</span><span class="p">][</span><span class="n">tag</span><span class="p">]:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="c1"># First remove any parentheses to support value like 1.134(56) and then cast to float</span>
                        <span class="n">occupancy</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;[\(\)]&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">position</span><span class="p">))</span>
                    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                        <span class="k">pass</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">occupancy</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">epsilon</span><span class="p">:</span>
                            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="n">partial_occupancies</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_attached_hydrogens</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if there are hydrogens without coordinates, specified as attached</span>
<span class="sd">        to the atoms of the structure.</span>

<span class="sd">        :returns: True if there are attached hydrogens, False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tag</span> <span class="o">=</span> <span class="s1">&#39;_atom_site_attached_hydrogens&#39;</span>
        <span class="k">for</span> <span class="n">datablock</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">tag</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">datablock</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">datablock</span><span class="p">][</span><span class="n">tag</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="s1">&#39;?&#39;</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">]:</span>
                        <span class="k">return</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_undefined_atomic_sites</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether the cif data contains any undefined atomic sites.</span>

<span class="sd">        An undefined atomic site is defined as a site where at least one of the fractional coordinates specified in the</span>
<span class="sd">        `_atom_site_fract_*` tags, cannot be successfully interpreted as a float. If the cif data contains any site that</span>
<span class="sd">        matches this description, or it does not contain any atomic site tags at all, the cif data is said to have</span>
<span class="sd">        undefined atomic sites.</span>

<span class="sd">        :return: boolean, True if no atomic sites are defined or if any of the defined sites contain undefined positions</span>
<span class="sd">            and False otherwise</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">re</span>

        <span class="n">tag_x</span> <span class="o">=</span> <span class="s1">&#39;_atom_site_fract_x&#39;</span>
        <span class="n">tag_y</span> <span class="o">=</span> <span class="s1">&#39;_atom_site_fract_y&#39;</span>
        <span class="n">tag_z</span> <span class="o">=</span> <span class="s1">&#39;_atom_site_fract_z&#39;</span>

        <span class="c1"># Some CifData files do not even contain a single `_atom_site_fract_*` tag</span>
        <span class="n">has_tags</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">for</span> <span class="n">datablock</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="p">[</span><span class="n">tag_x</span><span class="p">,</span> <span class="n">tag_y</span><span class="p">,</span> <span class="n">tag_z</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">tag</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">datablock</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="k">for</span> <span class="n">position</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">datablock</span><span class="p">][</span><span class="n">tag</span><span class="p">]:</span>

                        <span class="c1"># The CifData contains at least one `_atom_site_fract_*` tag</span>
                        <span class="n">has_tags</span> <span class="o">=</span> <span class="kc">True</span>

                        <span class="k">try</span><span class="p">:</span>
                            <span class="c1"># First remove any parentheses to support value like 1.134(56) and then cast to float</span>
                            <span class="nb">float</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;[\(\)]&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">position</span><span class="p">))</span>
                        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                            <span class="c1"># Position cannot be converted to a float value, so we have undefined atomic sites</span>
                            <span class="k">return</span> <span class="kc">True</span>

        <span class="c1"># At this point the file either has no tags at all, or it does and all coordinates were valid floats</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="n">has_tags</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_atomic_sites</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns whether there are any atomic sites defined in the cif data. That</span>
<span class="sd">        is to say, it will check all the values for the `_atom_site_fract_*` tags</span>
<span class="sd">        and if they are all equal to `?` that means there are no relevant atomic</span>
<span class="sd">        sites defined and the function will return False. In all other cases the</span>
<span class="sd">        function will return True</span>

<span class="sd">        :returns: False when at least one atomic site fractional coordinate is not</span>
<span class="sd">            equal to `?` and True otherwise</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tag_x</span> <span class="o">=</span> <span class="s1">&#39;_atom_site_fract_x&#39;</span>
        <span class="n">tag_y</span> <span class="o">=</span> <span class="s1">&#39;_atom_site_fract_y&#39;</span>
        <span class="n">tag_z</span> <span class="o">=</span> <span class="s1">&#39;_atom_site_fract_z&#39;</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">datablock</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="p">[</span><span class="n">tag_x</span><span class="p">,</span> <span class="n">tag_y</span><span class="p">,</span> <span class="n">tag_z</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">tag</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">datablock</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">coords</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">datablock</span><span class="p">][</span><span class="n">tag</span><span class="p">])</span>

        <span class="k">return</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">([</span><span class="n">coord</span> <span class="o">==</span> <span class="s1">&#39;?&#39;</span> <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_unknown_species</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns whether the cif contains atomic species that are not recognized by AiiDA.</span>

<span class="sd">        The known species are taken from the elements dictionary in `aiida.common.constants`, with the exception of</span>
<span class="sd">        the &quot;unknown&quot; placeholder element with symbol &#39;X&#39;, as this could not be used to construct a real structure.</span>
<span class="sd">        If any of the formula of the cif data contain species that are not in that elements dictionary, the function</span>
<span class="sd">        will return True and False in all other cases. If there is no formulae to be found, it will return None</span>

<span class="sd">        :returns: True when there are unknown species in any of the formulae, False if not, None if no formula found</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">aiida.common.constants</span> <span class="k">import</span> <span class="n">elements</span>

        <span class="c1"># Get all the elements known by AiiDA, excluding the &quot;unknown&quot; element with symbol &#39;X&#39;</span>
        <span class="n">known_species</span> <span class="o">=</span> <span class="p">[</span><span class="n">element</span><span class="p">[</span><span class="s1">&#39;symbol&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">elements</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">if</span> <span class="n">element</span><span class="p">[</span><span class="s1">&#39;symbol&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;X&#39;</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">formula</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_formulae</span><span class="p">():</span>

            <span class="k">if</span> <span class="n">formula</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>

            <span class="n">species</span> <span class="o">=</span> <span class="n">parse_formula</span><span class="p">(</span><span class="n">formula</span><span class="p">)</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">specie</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">known_species</span> <span class="k">for</span> <span class="n">specie</span> <span class="ow">in</span> <span class="n">species</span><span class="p">]):</span>
                <span class="k">return</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="kc">False</span>

<div class="viewcode-block" id="CifData.generate_md5"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.CifData.generate_md5">[docs]</a>    <span class="k">def</span> <span class="nf">generate_md5</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes and returns MD5 hash of the CIF file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">aiida.common.files</span> <span class="k">import</span> <span class="n">md5_from_filelike</span>

        <span class="c1"># Open in binary mode which is required for generating the md5 checksum</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">handle</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">md5_from_filelike</span><span class="p">(</span><span class="n">handle</span><span class="p">)</span></div>

<div class="viewcode-block" id="CifData._get_aiida_structure"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.CifData._get_aiida_structure">[docs]</a>    <span class="k">def</span> <span class="nf">_get_aiida_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">converter</span><span class="o">=</span><span class="s1">&#39;pymatgen&#39;</span><span class="p">,</span> <span class="n">store</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates :py:class:`aiida.orm.nodes.data.structure.StructureData`.</span>

<span class="sd">        :param converter: specify the converter. Default &#39;pymatgen&#39;.</span>
<span class="sd">        :param store: if True, intermediate calculation gets stored in the</span>
<span class="sd">            AiiDA database for record. Default False.</span>
<span class="sd">        :param primitive_cell: if True, primitive cell is returned,</span>
<span class="sd">            conventional cell if False. Default False.</span>
<span class="sd">        :param occupancy_tolerance: If total occupancy of a site is between 1 and occupancy_tolerance,</span>
<span class="sd">            the occupancies will be scaled down to 1. (pymatgen only)</span>
<span class="sd">        :param site_tolerance: This tolerance is used to determine if two sites are sitting in the same position,</span>
<span class="sd">            in which case they will be combined to a single disordered site. Defaults to 1e-4. (pymatgen only)</span>
<span class="sd">        :return: :py:class:`aiida.orm.nodes.data.structure.StructureData` node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">warnings</span>
        <span class="kn">from</span> <span class="nn">aiida.common.warnings</span> <span class="k">import</span> <span class="n">AiidaDeprecationWarning</span> <span class="k">as</span> <span class="ne">DeprecationWarning</span>  <span class="c1"># pylint: disable=redefined-builtin</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>  <span class="c1"># pylint: disable=no-member</span>
            <span class="s1">&#39;This method has been deprecated and will be renamed to get_structure() in AiiDA v1.0&#39;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_structure</span><span class="p">(</span><span class="n">converter</span><span class="o">=</span><span class="n">converter</span><span class="p">,</span> <span class="n">store</span><span class="o">=</span><span class="n">store</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="CifData.get_structure"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.CifData.get_structure">[docs]</a>    <span class="k">def</span> <span class="nf">get_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">converter</span><span class="o">=</span><span class="s1">&#39;pymatgen&#39;</span><span class="p">,</span> <span class="n">store</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates :py:class:`aiida.orm.nodes.data.structure.StructureData`.</span>

<span class="sd">        .. versionadded:: 1.0</span>
<span class="sd">           Renamed from _get_aiida_structure</span>

<span class="sd">        :param converter: specify the converter. Default &#39;pymatgen&#39;.</span>
<span class="sd">        :param store: if True, intermediate calculation gets stored in the</span>
<span class="sd">            AiiDA database for record. Default False.</span>
<span class="sd">        :param primitive_cell: if True, primitive cell is returned,</span>
<span class="sd">            conventional cell if False. Default False.</span>
<span class="sd">        :param occupancy_tolerance: If total occupancy of a site is between 1 and occupancy_tolerance,</span>
<span class="sd">            the occupancies will be scaled down to 1. (pymatgen only)</span>
<span class="sd">        :param site_tolerance: This tolerance is used to determine if two sites are sitting in the same position,</span>
<span class="sd">            in which case they will be combined to a single disordered site. Defaults to 1e-4. (pymatgen only)</span>
<span class="sd">        :return: :py:class:`aiida.orm.nodes.data.structure.StructureData` node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">aiida.orm</span> <span class="k">import</span> <span class="n">Dict</span>
        <span class="kn">from</span> <span class="nn">aiida.tools.data</span> <span class="k">import</span> <span class="n">cif</span> <span class="k">as</span> <span class="n">cif_tools</span>

        <span class="n">parameters</span> <span class="o">=</span> <span class="n">Dict</span><span class="p">(</span><span class="nb">dict</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">convert_function</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">cif_tools</span><span class="p">,</span> <span class="s1">&#39;_get_aiida_structure_</span><span class="si">{}</span><span class="s1">_inline&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">converter</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No such converter &#39;</span><span class="si">{}</span><span class="s2">&#39; available&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">converter</span><span class="p">))</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">convert_function</span><span class="p">(</span><span class="n">cif</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="o">=</span><span class="n">parameters</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;store_provenance&#39;</span><span class="p">:</span> <span class="n">store</span><span class="p">})</span>

        <span class="k">return</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;structure&#39;</span><span class="p">]</span></div>

    <span class="c1"># pylint: disable=unused-argument</span>
<div class="viewcode-block" id="CifData._prepare_cif"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.CifData._prepare_cif">[docs]</a>    <span class="k">def</span> <span class="nf">_prepare_cif</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">main_file_name</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return CIF string of CifData object.</span>

<span class="sd">        If parsed values are present, a CIF string is created</span>
<span class="sd">        and written to file.</span>
<span class="sd">        If no parsed values are present, the CIF string is read</span>
<span class="sd">        from file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_stored</span><span class="p">:</span>
            <span class="c1"># Note: this overwrites the CIF file!</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_values</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">)</span>

        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">open</span><span class="p">()</span> <span class="k">as</span> <span class="n">handle</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">handle</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">),</span> <span class="p">{}</span></div>

<div class="viewcode-block" id="CifData._get_object_ase"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.CifData._get_object_ase">[docs]</a>    <span class="k">def</span> <span class="nf">_get_object_ase</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts CifData to ase.Atoms</span>

<span class="sd">        :return: an ase.Atoms object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ase</span></div>

<div class="viewcode-block" id="CifData._get_object_pycifrw"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.CifData._get_object_pycifrw">[docs]</a>    <span class="k">def</span> <span class="nf">_get_object_pycifrw</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts CifData to PyCIFRW.CifFile</span>

<span class="sd">        :return: a PyCIFRW.CifFile object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span></div>

<div class="viewcode-block" id="CifData._validate"><a class="viewcode-back" href="../../../../../developer_guide/core/orm_overview.html#aiida.backends.tests.test_dataclasses.CifData._validate">[docs]</a>    <span class="k">def</span> <span class="nf">_validate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Validates MD5 hash of CIF file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">aiida.common.exceptions</span> <span class="k">import</span> <span class="n">ValidationError</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">CifData</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_validate</span><span class="p">()</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">attr_md5</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="s1">&#39;md5&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ValidationError</span><span class="p">(</span><span class="s2">&quot;attribute &#39;md5&#39; not set.&quot;</span><span class="p">)</span>
        <span class="n">md5</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_md5</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">attr_md5</span> <span class="o">!=</span> <span class="n">md5</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ValidationError</span><span class="p">(</span><span class="s2">&quot;Attribute &#39;md5&#39; says &#39;</span><span class="si">{}</span><span class="s2">&#39; but &#39;</span><span class="si">{}</span><span class="s2">&#39; was parsed instead.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">attr_md5</span><span class="p">,</span> <span class="n">md5</span><span class="p">))</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, ECOLE POLYTECHNIQUE FEDERALE DE LAUSANNE (Theory and Simulation of Materials (THEOS) and National Centre for Computational Design and Discovery of Novel Materials (NCCR MARVEL)), Switzerland and ROBERT BOSCH LLC, USA. All rights reserved

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>