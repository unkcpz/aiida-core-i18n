

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>aiida.orm.importexport &mdash; AiiDA 1.0.0b2 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../_static/language_data.js"></script>
        <script type="text/javascript" src="../../../_static/contentui.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/contentui.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> AiiDA
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Installation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install/quick_installation.html">Quick installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../install/prerequisites.html">Prerequisites</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../install/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../install/updating_installation.html">Updating AiiDA</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../install/troubleshooting.html">Troubleshooting</a></li>
</ul>
<p class="caption"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../get_started/index.html">First things first</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../get_started/daemon.html">Setup the daemon</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../get_started/computers.html">Setup a computer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../get_started/codes.html">Setup a code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../get_started/plugins.html">Plugins</a></li>
</ul>
<p class="caption"><span class="caption-text">Concepts</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../concepts/provenance.html">Provenance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../concepts/processes.html">Processes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../concepts/calculations.html">Calculations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../concepts/workflows.html">Workflows</a></li>
</ul>
<p class="caption"><span class="caption-text">Working with</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../working/processes.html">Processes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../working/functions.html">Calculation and work functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../working/calculations.html">Calculations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../working/workflows.html">Workflows</a></li>
</ul>
<p class="caption"><span class="caption-text">Working with AiiDA</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../working_with_aiida/index.html">Command line interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../working_with_aiida/index.html#scripting">Scripting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../working_with_aiida/index.html#data-types">Data types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../working_with_aiida/index.html#groups">Groups</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../working_with_aiida/index.html#schedulers">Schedulers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../working_with_aiida/index.html#querying-data">Querying data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../working_with_aiida/index.html#caching">Caching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../working_with_aiida/index.html#result-manager">Result manager</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../working_with_aiida/index.html#backups">Backups</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../working_with_aiida/index.html#troubleshooting">Troubleshooting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../working_with_aiida/index.html#rest-api">REST API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../working_with_aiida/index.html#cookbook">Cookbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../import_export/index.html">Import and Export</a></li>
</ul>
<p class="caption"><span class="caption-text">Development</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../developer_guide/index.html">AiiDA design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../developer_guide/index.html#aiida-core">AiiDA core</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../developer_guide/index.html#aiida-plugins">AiiDA plugins</a></li>
</ul>
<p class="caption"><span class="caption-text">Tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial/index.html">StructureData</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial/index.html#pseudopotentials">Pseudopotentials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial/index.html#plugin-development">Plugin development</a></li>
</ul>
<p class="caption"><span class="caption-text">API reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="`aiida package &lt;https://aiida-core.readthedocs.io/en/latest/apidoc/aiida.html&gt;`_">`aiida package &lt;https://aiida-core.readthedocs.io/en/latest/apidoc/aiida.html&gt;`_</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">AiiDA</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../../aiida.html">aiida</a> &raquo;</li>
        
      <li>aiida.orm.importexport</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for aiida.orm.importexport</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1">###########################################################################</span>
<span class="c1"># Copyright (c), The AiiDA team. All rights reserved.                     #</span>
<span class="c1"># This file is part of the AiiDA code.                                    #</span>
<span class="c1">#                                                                         #</span>
<span class="c1"># The code is hosted on GitHub at https://github.com/aiidateam/aiida_core #</span>
<span class="c1"># For further information on the license, see the LICENSE.txt file        #</span>
<span class="c1"># For further information please visit http://www.aiida.net               #</span>
<span class="c1">###########################################################################</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span>

<span class="kn">import</span> <span class="nn">io</span>

<span class="kn">import</span> <span class="nn">click</span>
<span class="kn">import</span> <span class="nn">six</span>
<span class="kn">from</span> <span class="nn">six.moves</span> <span class="k">import</span> <span class="nb">zip</span>
<span class="kn">from</span> <span class="nn">six.moves.html_parser</span> <span class="k">import</span> <span class="n">HTMLParser</span>
<span class="kn">from</span> <span class="nn">distutils.version</span> <span class="k">import</span> <span class="n">StrictVersion</span>
<span class="kn">from</span> <span class="nn">aiida.common</span> <span class="k">import</span> <span class="n">exceptions</span>
<span class="kn">from</span> <span class="nn">aiida.common.utils</span> <span class="k">import</span> <span class="n">export_shard_uuid</span><span class="p">,</span> <span class="n">get_class_string</span><span class="p">,</span> <span class="n">grouper</span><span class="p">,</span> <span class="n">get_new_uuid</span>
<span class="kn">from</span> <span class="nn">aiida.orm</span> <span class="k">import</span> <span class="n">Computer</span><span class="p">,</span> <span class="n">Group</span><span class="p">,</span> <span class="n">GroupTypeString</span><span class="p">,</span> <span class="n">Node</span><span class="p">,</span> <span class="n">QueryBuilder</span><span class="p">,</span> <span class="n">User</span><span class="p">,</span> <span class="n">Log</span><span class="p">,</span> <span class="n">Comment</span>
<span class="kn">from</span> <span class="nn">aiida.orm.utils.repository</span> <span class="k">import</span> <span class="n">Repository</span>

<span class="n">IMPORTGROUP_TYPE</span> <span class="o">=</span> <span class="n">GroupTypeString</span><span class="o">.</span><span class="n">IMPORTGROUP_TYPE</span><span class="o">.</span><span class="n">value</span>
<span class="n">DUPL_SUFFIX</span> <span class="o">=</span> <span class="s1">&#39; (Imported #</span><span class="si">{}</span><span class="s1">)&#39;</span>

<span class="c1"># Giving names to the various entities. Attributes and links are not AiiDA</span>
<span class="c1"># entities but we will refer to them as entities in the file (to simplify</span>
<span class="c1"># references to them).</span>
<span class="n">NODE_ENTITY_NAME</span> <span class="o">=</span> <span class="s2">&quot;Node&quot;</span>
<span class="n">LINK_ENTITY_NAME</span> <span class="o">=</span> <span class="s2">&quot;Link&quot;</span>
<span class="n">GROUP_ENTITY_NAME</span> <span class="o">=</span> <span class="s2">&quot;Group&quot;</span>
<span class="n">ATTRIBUTE_ENTITY_NAME</span> <span class="o">=</span> <span class="s2">&quot;Attribute&quot;</span>
<span class="n">COMPUTER_ENTITY_NAME</span> <span class="o">=</span> <span class="s2">&quot;Computer&quot;</span>
<span class="n">USER_ENTITY_NAME</span> <span class="o">=</span> <span class="s2">&quot;User&quot;</span>
<span class="n">LOG_ENTITY_NAME</span> <span class="o">=</span> <span class="s2">&quot;Log&quot;</span>
<span class="n">COMMENT_ENTITY_NAME</span> <span class="o">=</span> <span class="s2">&quot;Comment&quot;</span>

<span class="c1"># The signatures used to reference the entities in the import/export file</span>
<span class="n">NODE_SIGNATURE</span> <span class="o">=</span> <span class="s2">&quot;aiida.backends.djsite.db.models.DbNode&quot;</span>
<span class="n">LINK_SIGNATURE</span> <span class="o">=</span> <span class="s2">&quot;aiida.backends.djsite.db.models.DbLink&quot;</span>
<span class="n">GROUP_SIGNATURE</span> <span class="o">=</span> <span class="s2">&quot;aiida.backends.djsite.db.models.DbGroup&quot;</span>
<span class="n">COMPUTER_SIGNATURE</span> <span class="o">=</span> <span class="s2">&quot;aiida.backends.djsite.db.models.DbComputer&quot;</span>
<span class="n">USER_SIGNATURE</span> <span class="o">=</span> <span class="s2">&quot;aiida.backends.djsite.db.models.DbUser&quot;</span>
<span class="n">ATTRIBUTE_SIGNATURE</span> <span class="o">=</span> <span class="s2">&quot;aiida.backends.djsite.db.models.DbAttribute&quot;</span>
<span class="n">LOG_SIGNATURE</span> <span class="o">=</span> <span class="s2">&quot;aiida.backends.djsite.db.models.DbLog&quot;</span>
<span class="n">COMMENT_SIGNATURE</span> <span class="o">=</span> <span class="s2">&quot;aiida.backends.djsite.db.models.DbComment&quot;</span>

<span class="c1"># Mapping from entity names to signatures (used by the SQLA import/export)</span>
<span class="n">entity_names_to_signatures</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">NODE_ENTITY_NAME</span><span class="p">:</span> <span class="n">NODE_SIGNATURE</span><span class="p">,</span>
    <span class="n">LINK_ENTITY_NAME</span><span class="p">:</span> <span class="n">LINK_SIGNATURE</span><span class="p">,</span>
    <span class="n">GROUP_ENTITY_NAME</span><span class="p">:</span> <span class="n">GROUP_SIGNATURE</span><span class="p">,</span>
    <span class="n">COMPUTER_ENTITY_NAME</span><span class="p">:</span> <span class="n">COMPUTER_SIGNATURE</span><span class="p">,</span>
    <span class="n">USER_ENTITY_NAME</span><span class="p">:</span> <span class="n">USER_SIGNATURE</span><span class="p">,</span>
    <span class="n">ATTRIBUTE_ENTITY_NAME</span><span class="p">:</span> <span class="n">ATTRIBUTE_SIGNATURE</span><span class="p">,</span>
    <span class="n">LOG_ENTITY_NAME</span><span class="p">:</span> <span class="n">LOG_SIGNATURE</span><span class="p">,</span>
    <span class="n">COMMENT_ENTITY_NAME</span><span class="p">:</span> <span class="n">COMMENT_SIGNATURE</span>
<span class="p">}</span>

<span class="c1"># Mapping from signatures to entity names (used by the SQLA import/export)</span>
<span class="n">signatures_to_entity_names</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">NODE_SIGNATURE</span><span class="p">:</span> <span class="n">NODE_ENTITY_NAME</span><span class="p">,</span>
    <span class="n">LINK_SIGNATURE</span><span class="p">:</span> <span class="n">LINK_ENTITY_NAME</span><span class="p">,</span>
    <span class="n">GROUP_SIGNATURE</span><span class="p">:</span> <span class="n">GROUP_ENTITY_NAME</span><span class="p">,</span>
    <span class="n">COMPUTER_SIGNATURE</span><span class="p">:</span> <span class="n">COMPUTER_ENTITY_NAME</span><span class="p">,</span>
    <span class="n">USER_SIGNATURE</span><span class="p">:</span> <span class="n">USER_ENTITY_NAME</span><span class="p">,</span>
    <span class="n">ATTRIBUTE_SIGNATURE</span><span class="p">:</span> <span class="n">ATTRIBUTE_ENTITY_NAME</span><span class="p">,</span>
    <span class="n">LOG_SIGNATURE</span><span class="p">:</span> <span class="n">LOG_ENTITY_NAME</span><span class="p">,</span>
    <span class="n">COMMENT_SIGNATURE</span><span class="p">:</span> <span class="n">COMMENT_ENTITY_NAME</span>
<span class="p">}</span>

<span class="c1"># Mapping from entity names to AiiDA classes (used by the SQLA import/export)</span>
<span class="n">entity_names_to_entities</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">NODE_ENTITY_NAME</span><span class="p">:</span> <span class="n">Node</span><span class="p">,</span>
    <span class="n">GROUP_ENTITY_NAME</span><span class="p">:</span> <span class="n">Group</span><span class="p">,</span>
    <span class="n">COMPUTER_ENTITY_NAME</span><span class="p">:</span> <span class="n">Computer</span><span class="p">,</span>
    <span class="n">USER_ENTITY_NAME</span><span class="p">:</span> <span class="n">User</span><span class="p">,</span>
    <span class="n">LOG_ENTITY_NAME</span><span class="p">:</span> <span class="n">Log</span><span class="p">,</span>
    <span class="n">COMMENT_ENTITY_NAME</span><span class="p">:</span> <span class="n">Comment</span>
<span class="p">}</span>


<div class="viewcode-block" id="schema_to_entity_names"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.importexport.schema_to_entity_names">[docs]</a><span class="k">def</span> <span class="nf">schema_to_entity_names</span><span class="p">(</span><span class="n">class_string</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mapping from classes path to entity names (used by the SQLA import/export)</span>
<span class="sd">    This could have been written much simpler if it is only for SQLA but there</span>
<span class="sd">    is an attempt the SQLA import/export code to be used for Django too.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">class_string</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">class_string</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">class_string</span> <span class="o">==</span> <span class="s2">&quot;aiida.backends.djsite.db.models.DbNode&quot;</span> <span class="ow">or</span>
            <span class="n">class_string</span> <span class="o">==</span> <span class="s2">&quot;aiida.backends.sqlalchemy.models.node.DbNode&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">NODE_ENTITY_NAME</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">class_string</span> <span class="o">==</span> <span class="s2">&quot;aiida.backends.djsite.db.models.DbLink&quot;</span> <span class="ow">or</span>
            <span class="n">class_string</span> <span class="o">==</span> <span class="s2">&quot;aiida.backends.sqlalchemy.models.node.DbLink&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">LINK_ENTITY_NAME</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">class_string</span> <span class="o">==</span> <span class="s2">&quot;aiida.backends.djsite.db.models.DbGroup&quot;</span> <span class="ow">or</span>
            <span class="n">class_string</span> <span class="o">==</span>
            <span class="s2">&quot;aiida.backends.sqlalchemy.models.group.DbGroup&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">GROUP_ENTITY_NAME</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">class_string</span> <span class="o">==</span> <span class="s2">&quot;aiida.backends.djsite.db.models.DbComputer&quot;</span> <span class="ow">or</span>
            <span class="n">class_string</span> <span class="o">==</span>
            <span class="s2">&quot;aiida.backends.sqlalchemy.models.computer.DbComputer&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">COMPUTER_ENTITY_NAME</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">class_string</span> <span class="o">==</span> <span class="s2">&quot;aiida.backends.djsite.db.models.DbUser&quot;</span> <span class="ow">or</span>
            <span class="n">class_string</span> <span class="o">==</span> <span class="s2">&quot;aiida.backends.sqlalchemy.models.user.DbUser&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">USER_ENTITY_NAME</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">class_string</span> <span class="o">==</span> <span class="s2">&quot;aiida.backends.djsite.db.models.DbLog&quot;</span> <span class="ow">or</span>
            <span class="n">class_string</span> <span class="o">==</span> <span class="s2">&quot;aiida.backends.sqlalchemy.models.log.DbLog&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">LOG_ENTITY_NAME</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">class_string</span> <span class="o">==</span> <span class="s2">&quot;aiida.backends.djsite.db.models.DbComment&quot;</span> <span class="ow">or</span>
            <span class="n">class_string</span> <span class="o">==</span> <span class="s2">&quot;aiida.backends.sqlalchemy.models.comment.DbComment&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">COMMENT_ENTITY_NAME</span></div>


<span class="c1"># Mapping of entity names to SQLA class paths</span>
<span class="n">entity_names_to_sqla_schema</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">NODE_ENTITY_NAME</span><span class="p">:</span> <span class="s2">&quot;aiida.backends.sqlalchemy.models.node.DbNode&quot;</span><span class="p">,</span>
    <span class="n">LINK_ENTITY_NAME</span><span class="p">:</span> <span class="s2">&quot;aiida.backends.sqlalchemy.models.node.DbLink&quot;</span><span class="p">,</span>
    <span class="n">GROUP_ENTITY_NAME</span><span class="p">:</span> <span class="s2">&quot;aiida.backends.sqlalchemy.models.group.DbGroup&quot;</span><span class="p">,</span>
    <span class="n">COMPUTER_ENTITY_NAME</span><span class="p">:</span> <span class="s2">&quot;aiida.backends.sqlalchemy.models.computer.DbComputer&quot;</span><span class="p">,</span>
    <span class="n">USER_ENTITY_NAME</span><span class="p">:</span> <span class="s2">&quot;aiida.backends.sqlalchemy.models.user.DbUser&quot;</span><span class="p">,</span>
    <span class="n">LOG_ENTITY_NAME</span><span class="p">:</span> <span class="s2">&quot;aiida.backends.sqlalchemy.models.log.DbLog&quot;</span><span class="p">,</span>
    <span class="n">COMMENT_ENTITY_NAME</span><span class="p">:</span> <span class="s2">&quot;aiida.backends.sqlalchemy.models.comment.DbComment&quot;</span>
<span class="p">}</span>

<span class="c1"># Mapping of the export file fields (that coincide with the Django fields) to</span>
<span class="c1"># model fields that can be used for the query of the database in both backends.</span>
<span class="c1"># These are the names of the fields of the models that belong to the</span>
<span class="c1"># corresponding entities.</span>
<span class="n">file_fields_to_model_fields</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">NODE_ENTITY_NAME</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;dbcomputer&quot;</span><span class="p">:</span> <span class="s2">&quot;dbcomputer_id&quot;</span><span class="p">,</span>
        <span class="s2">&quot;user&quot;</span><span class="p">:</span> <span class="s2">&quot;user_id&quot;</span>
    <span class="p">},</span>
    <span class="n">GROUP_ENTITY_NAME</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;user&quot;</span><span class="p">:</span> <span class="s2">&quot;user_id&quot;</span>
    <span class="p">},</span>
    <span class="n">COMPUTER_ENTITY_NAME</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;metadata&quot;</span><span class="p">:</span> <span class="s2">&quot;_metadata&quot;</span>
    <span class="p">},</span>
    <span class="n">LOG_ENTITY_NAME</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;dbnode&quot;</span><span class="p">:</span> <span class="s2">&quot;dbnode_id&quot;</span><span class="p">,</span>
        <span class="s2">&quot;metadata&quot;</span><span class="p">:</span> <span class="s2">&quot;_metadata&quot;</span>
    <span class="p">},</span>
    <span class="n">COMMENT_ENTITY_NAME</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;dbnode&quot;</span><span class="p">:</span> <span class="s2">&quot;dbnode_id&quot;</span><span class="p">,</span>
        <span class="s2">&quot;user&quot;</span><span class="p">:</span> <span class="s2">&quot;user_id&quot;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1"># As above but the opposite procedure</span>
<span class="n">model_fields_to_file_fields</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">NODE_ENTITY_NAME</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;dbcomputer_id&quot;</span><span class="p">:</span> <span class="s2">&quot;dbcomputer&quot;</span><span class="p">,</span>
        <span class="s2">&quot;user_id&quot;</span><span class="p">:</span> <span class="s2">&quot;user&quot;</span>
    <span class="p">},</span>
    <span class="n">LINK_ENTITY_NAME</span><span class="p">:</span> <span class="p">{},</span>
    <span class="n">GROUP_ENTITY_NAME</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;user_id&quot;</span><span class="p">:</span> <span class="s2">&quot;user&quot;</span>
    <span class="p">},</span>
    <span class="n">COMPUTER_ENTITY_NAME</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;_metadata&quot;</span><span class="p">:</span> <span class="s2">&quot;metadata&quot;</span>
    <span class="p">},</span>
    <span class="n">USER_ENTITY_NAME</span><span class="p">:</span> <span class="p">{},</span>
    <span class="n">LOG_ENTITY_NAME</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;dbnode_id&quot;</span><span class="p">:</span> <span class="s2">&quot;dbnode&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_metadata&quot;</span><span class="p">:</span> <span class="s2">&quot;metadata&quot;</span>
    <span class="p">},</span>
    <span class="n">COMMENT_ENTITY_NAME</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;dbnode_id&quot;</span><span class="p">:</span> <span class="s2">&quot;dbnode&quot;</span><span class="p">,</span>
        <span class="s2">&quot;user_id&quot;</span><span class="p">:</span> <span class="s2">&quot;user&quot;</span>
    <span class="p">}</span>
<span class="p">}</span>


<div class="viewcode-block" id="get_all_fields_info"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.importexport.get_all_fields_info">[docs]</a><span class="k">def</span> <span class="nf">get_all_fields_info</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This method returns a description of the field names that should be used</span>
<span class="sd">    to describe the entity properties.</span>
<span class="sd">    Apart from of the listing of the fields per properties, it also shown</span>
<span class="sd">    the dependencies among different entities (and on which fields). It is</span>
<span class="sd">    also shown/return the unique identifiers used per entity.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">unique_identifiers</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">USER_ENTITY_NAME</span><span class="p">:</span> <span class="s2">&quot;email&quot;</span><span class="p">,</span>
        <span class="n">COMPUTER_ENTITY_NAME</span><span class="p">:</span> <span class="s2">&quot;uuid&quot;</span><span class="p">,</span>
        <span class="n">LINK_ENTITY_NAME</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">NODE_ENTITY_NAME</span><span class="p">:</span> <span class="s2">&quot;uuid&quot;</span><span class="p">,</span>
        <span class="n">ATTRIBUTE_ENTITY_NAME</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">GROUP_ENTITY_NAME</span><span class="p">:</span> <span class="s2">&quot;uuid&quot;</span><span class="p">,</span>
        <span class="n">LOG_ENTITY_NAME</span><span class="p">:</span> <span class="s2">&quot;uuid&quot;</span><span class="p">,</span>
        <span class="n">COMMENT_ENTITY_NAME</span><span class="p">:</span> <span class="s2">&quot;uuid&quot;</span>
    <span class="p">}</span>

    <span class="n">all_fields_info</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">all_fields_info</span><span class="p">[</span><span class="n">USER_ENTITY_NAME</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;last_name&quot;</span><span class="p">:</span> <span class="p">{},</span>
        <span class="s2">&quot;first_name&quot;</span><span class="p">:</span> <span class="p">{},</span>
        <span class="s2">&quot;institution&quot;</span><span class="p">:</span> <span class="p">{},</span>
        <span class="s2">&quot;email&quot;</span><span class="p">:</span> <span class="p">{}</span>
    <span class="p">}</span>
    <span class="n">all_fields_info</span><span class="p">[</span><span class="n">COMPUTER_ENTITY_NAME</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;transport_type&quot;</span><span class="p">:</span> <span class="p">{},</span>
        <span class="s2">&quot;transport_params&quot;</span><span class="p">:</span> <span class="p">{},</span>
        <span class="s2">&quot;hostname&quot;</span><span class="p">:</span> <span class="p">{},</span>
        <span class="s2">&quot;description&quot;</span><span class="p">:</span> <span class="p">{},</span>
        <span class="s2">&quot;scheduler_type&quot;</span><span class="p">:</span> <span class="p">{},</span>
        <span class="s2">&quot;metadata&quot;</span><span class="p">:</span> <span class="p">{},</span>
        <span class="s2">&quot;uuid&quot;</span><span class="p">:</span> <span class="p">{},</span>
        <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="p">{}</span>
    <span class="p">}</span>
    <span class="n">all_fields_info</span><span class="p">[</span><span class="n">LINK_ENTITY_NAME</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;input&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;requires&quot;</span><span class="p">:</span> <span class="n">NODE_ENTITY_NAME</span><span class="p">,</span>
            <span class="s2">&quot;related_name&quot;</span><span class="p">:</span> <span class="s2">&quot;output_links&quot;</span>
        <span class="p">},</span>
        <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="p">{},</span>
        <span class="s2">&quot;output&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;requires&quot;</span><span class="p">:</span> <span class="n">NODE_ENTITY_NAME</span><span class="p">,</span>
            <span class="s2">&quot;related_name&quot;</span><span class="p">:</span> <span class="s2">&quot;input_links&quot;</span>
        <span class="p">},</span>
        <span class="s2">&quot;label&quot;</span><span class="p">:</span> <span class="p">{}</span>
    <span class="p">}</span>
    <span class="n">all_fields_info</span><span class="p">[</span><span class="n">NODE_ENTITY_NAME</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;ctime&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;convert_type&quot;</span><span class="p">:</span> <span class="s2">&quot;date&quot;</span>
        <span class="p">},</span>
        <span class="s2">&quot;uuid&quot;</span><span class="p">:</span> <span class="p">{},</span>
        <span class="s2">&quot;public&quot;</span><span class="p">:</span> <span class="p">{},</span>
        <span class="s2">&quot;mtime&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;convert_type&quot;</span><span class="p">:</span> <span class="s2">&quot;date&quot;</span>
        <span class="p">},</span>
        <span class="s2">&quot;node_type&quot;</span><span class="p">:</span> <span class="p">{},</span>
        <span class="s2">&quot;label&quot;</span><span class="p">:</span> <span class="p">{},</span>
        <span class="s2">&quot;nodeversion&quot;</span><span class="p">:</span> <span class="p">{},</span>
        <span class="s2">&quot;user&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;requires&quot;</span><span class="p">:</span> <span class="n">USER_ENTITY_NAME</span><span class="p">,</span>
            <span class="s2">&quot;related_name&quot;</span><span class="p">:</span> <span class="s2">&quot;dbnodes&quot;</span>
        <span class="p">},</span>
        <span class="s2">&quot;dbcomputer&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;requires&quot;</span><span class="p">:</span> <span class="n">COMPUTER_ENTITY_NAME</span><span class="p">,</span>
            <span class="s2">&quot;related_name&quot;</span><span class="p">:</span> <span class="s2">&quot;dbnodes&quot;</span>
        <span class="p">},</span>
        <span class="s2">&quot;description&quot;</span><span class="p">:</span> <span class="p">{},</span>
        <span class="s2">&quot;process_type&quot;</span><span class="p">:</span> <span class="p">{}</span>
    <span class="p">}</span>
    <span class="n">all_fields_info</span><span class="p">[</span><span class="n">ATTRIBUTE_ENTITY_NAME</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;dbnode&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;requires&quot;</span><span class="p">:</span> <span class="n">NODE_ENTITY_NAME</span><span class="p">,</span>
            <span class="s2">&quot;related_name&quot;</span><span class="p">:</span> <span class="s2">&quot;dbattributes&quot;</span>
        <span class="p">},</span>
        <span class="s2">&quot;key&quot;</span><span class="p">:</span> <span class="p">{},</span>
        <span class="s2">&quot;tval&quot;</span><span class="p">:</span> <span class="p">{},</span>
        <span class="s2">&quot;fval&quot;</span><span class="p">:</span> <span class="p">{},</span>
        <span class="s2">&quot;bval&quot;</span><span class="p">:</span> <span class="p">{},</span>
        <span class="s2">&quot;datatype&quot;</span><span class="p">:</span> <span class="p">{},</span>
        <span class="s2">&quot;dval&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;convert_type&quot;</span><span class="p">:</span> <span class="s2">&quot;date&quot;</span>
        <span class="p">},</span>
        <span class="s2">&quot;ival&quot;</span><span class="p">:</span> <span class="p">{}</span>
    <span class="p">}</span>
    <span class="n">all_fields_info</span><span class="p">[</span><span class="n">GROUP_ENTITY_NAME</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
         <span class="s2">&quot;description&quot;</span><span class="p">:</span> <span class="p">{},</span>
         <span class="s2">&quot;user&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;related_name&quot;</span><span class="p">:</span> <span class="s2">&quot;dbgroups&quot;</span><span class="p">,</span>
            <span class="s2">&quot;requires&quot;</span><span class="p">:</span> <span class="n">USER_ENTITY_NAME</span>
         <span class="p">},</span>
         <span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;convert_type&quot;</span><span class="p">:</span> <span class="s2">&quot;date&quot;</span>
         <span class="p">},</span>
         <span class="s2">&quot;type_string&quot;</span><span class="p">:</span> <span class="p">{},</span>
         <span class="s2">&quot;uuid&quot;</span><span class="p">:</span> <span class="p">{},</span>
         <span class="s2">&quot;label&quot;</span><span class="p">:</span> <span class="p">{}</span>
    <span class="p">}</span>
    <span class="n">all_fields_info</span><span class="p">[</span><span class="n">LOG_ENTITY_NAME</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
         <span class="s2">&quot;uuid&quot;</span><span class="p">:</span> <span class="p">{},</span>
         <span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="p">{</span>
             <span class="s2">&quot;convert_type&quot;</span><span class="p">:</span> <span class="s2">&quot;date&quot;</span>
         <span class="p">},</span>
         <span class="s2">&quot;loggername&quot;</span><span class="p">:</span> <span class="p">{},</span>
         <span class="s2">&quot;levelname&quot;</span><span class="p">:</span> <span class="p">{},</span>
         <span class="s2">&quot;message&quot;</span><span class="p">:</span> <span class="p">{},</span>
         <span class="s2">&quot;metadata&quot;</span><span class="p">:</span> <span class="p">{},</span>
         <span class="s2">&quot;dbnode&quot;</span><span class="p">:</span> <span class="p">{</span>
             <span class="s2">&quot;related_name&quot;</span><span class="p">:</span> <span class="s2">&quot;dblogs&quot;</span><span class="p">,</span>
             <span class="s2">&quot;requires&quot;</span><span class="p">:</span> <span class="n">NODE_ENTITY_NAME</span>
         <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">all_fields_info</span><span class="p">[</span><span class="n">COMMENT_ENTITY_NAME</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
         <span class="s2">&quot;uuid&quot;</span><span class="p">:</span> <span class="p">{},</span>
         <span class="s2">&quot;ctime&quot;</span><span class="p">:</span> <span class="p">{</span>
             <span class="s2">&quot;convert_type&quot;</span><span class="p">:</span> <span class="s2">&quot;date&quot;</span>
         <span class="p">},</span>
         <span class="s2">&quot;mtime&quot;</span><span class="p">:</span> <span class="p">{</span>
             <span class="s2">&quot;convert_type&quot;</span><span class="p">:</span> <span class="s2">&quot;date&quot;</span>
         <span class="p">},</span>
         <span class="s2">&quot;content&quot;</span><span class="p">:</span> <span class="p">{},</span>
         <span class="s2">&quot;dbnode&quot;</span><span class="p">:</span> <span class="p">{</span>
             <span class="s2">&quot;related_name&quot;</span><span class="p">:</span> <span class="s2">&quot;dbcomments&quot;</span><span class="p">,</span>
             <span class="s2">&quot;requires&quot;</span><span class="p">:</span> <span class="n">NODE_ENTITY_NAME</span>
         <span class="p">},</span>
         <span class="s2">&quot;user&quot;</span><span class="p">:</span> <span class="p">{</span>
             <span class="s2">&quot;related_name&quot;</span><span class="p">:</span> <span class="s2">&quot;dbcomments&quot;</span><span class="p">,</span>
             <span class="s2">&quot;requires&quot;</span><span class="p">:</span> <span class="n">USER_ENTITY_NAME</span>
         <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">all_fields_info</span><span class="p">,</span> <span class="n">unique_identifiers</span></div>


<div class="viewcode-block" id="deserialize_attributes"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.importexport.deserialize_attributes">[docs]</a><span class="k">def</span> <span class="nf">deserialize_attributes</span><span class="p">(</span><span class="n">attributes_data</span><span class="p">,</span> <span class="n">conversion_data</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">datetime</span>
    <span class="kn">import</span> <span class="nn">pytz</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">attributes_data</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="n">ret_data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">attributes_data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># print(&quot;k: &quot;, k, &quot; v: &quot;, v)</span>
            <span class="k">if</span> <span class="n">conversion_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ret_data</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">deserialize_attributes</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">conversion_data</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ret_data</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">deserialize_attributes</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">attributes_data</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="n">ret_data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">conversion_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">value</span><span class="p">,</span> <span class="n">conversion</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">attributes_data</span><span class="p">,</span> <span class="n">conversion_data</span><span class="p">):</span>
                <span class="n">ret_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">deserialize_attributes</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">conversion</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">attributes_data</span><span class="p">:</span>
                <span class="n">ret_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">deserialize_attributes</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">conversion_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ret_data</span> <span class="o">=</span> <span class="n">attributes_data</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">conversion_data</span> <span class="o">==</span> <span class="s1">&#39;date&#39;</span><span class="p">:</span>
                <span class="n">ret_data</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span>
                    <span class="n">attributes_data</span><span class="p">,</span> <span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1">T%H:%M:%S.</span><span class="si">%f</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                    <span class="n">tzinfo</span><span class="o">=</span><span class="n">pytz</span><span class="o">.</span><span class="n">utc</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown convert_type &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">conversion_data</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">ret_data</span></div>


<div class="viewcode-block" id="deserialize_field"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.importexport.deserialize_field">[docs]</a><span class="k">def</span> <span class="nf">deserialize_field</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">fields_info</span><span class="p">,</span> <span class="n">import_unique_ids_mappings</span><span class="p">,</span>
                      <span class="n">foreign_ids_reverse_mappings</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">field_info</span> <span class="o">=</span> <span class="n">fields_info</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown field &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="s1">&#39;id&#39;</span> <span class="ow">or</span> <span class="n">k</span> <span class="o">==</span> <span class="s1">&#39;pk&#39;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;ID or PK explicitly passed!&quot;</span><span class="p">)</span>

    <span class="n">requires</span> <span class="o">=</span> <span class="n">field_info</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;requires&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">requires</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Actual data, no foreign key</span>
        <span class="n">converter</span> <span class="o">=</span> <span class="n">field_info</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;convert_type&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">deserialize_attributes</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">converter</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Foreign field</span>
        <span class="c1"># Correctly manage nullable fields</span>
        <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">unique_id</span> <span class="o">=</span> <span class="n">import_unique_ids_mappings</span><span class="p">[</span><span class="n">requires</span><span class="p">][</span><span class="n">v</span><span class="p">]</span>
            <span class="c1"># map to the PK/ID associated to the given entry, in the arrival DB,</span>
            <span class="c1"># rather than in the export DB</span>

            <span class="c1"># I store it in the FIELDNAME_id variable, that directly stores the</span>
            <span class="c1"># PK in the remote table, rather than requiring to create Model</span>
            <span class="c1"># instances for the foreign relations</span>
            <span class="k">return</span> <span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_id&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">),</span>
                    <span class="n">foreign_ids_reverse_mappings</span><span class="p">[</span><span class="n">requires</span><span class="p">][</span><span class="n">unique_id</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_id&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span></div>

<div class="viewcode-block" id="merge_extras"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.importexport.merge_extras">[docs]</a><span class="k">def</span> <span class="nf">merge_extras</span><span class="p">(</span><span class="n">old_extras</span><span class="p">,</span> <span class="n">new_extras</span><span class="p">,</span> <span class="n">mode</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :param old_extras: a dictionary containing the old extras of an already existing node</span>
<span class="sd">    :param new_extras: a dictionary containing the new extras of an imported node</span>
<span class="sd">    :param extras_mode_existing: 3 letter code that will identify what to do with the extras import. The first letter acts on</span>
<span class="sd">                        extras that are present in the original node and not present in the imported node. Can be</span>
<span class="sd">                        either k (keep it) or n (do not keep it). The second letter acts on the imported extras that</span>
<span class="sd">                        are not present in the original node. Can be either c (create it) or n (do not create it). The</span>
<span class="sd">                        third letter says what to do in case of a name collision. Can be l (leave the old value), u</span>
<span class="sd">                        (update with a new value), d (delete the extra), a (ask what to do if the content is</span>
<span class="sd">                        different).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">six</span> <span class="k">import</span> <span class="n">string_types</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Parameter &#39;mode&#39; should be of string type, you provided &#39;</span><span class="si">{}</span><span class="s2">&#39; type&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">mode</span><span class="p">)))</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Parameter &#39;mode&#39; should be a 3-letter string, you provided: &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span>

    <span class="n">old_keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">old_extras</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">new_keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">new_extras</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="n">collided_keys</span> <span class="o">=</span> <span class="n">old_keys</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">new_keys</span><span class="p">)</span>
    <span class="n">old_keys_only</span> <span class="o">=</span> <span class="n">old_keys</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">collided_keys</span><span class="p">)</span>
    <span class="n">new_keys_only</span> <span class="o">=</span> <span class="n">new_keys</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">collided_keys</span><span class="p">)</span>

    <span class="n">final_extras</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># Fast implementations for the common operations:</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;ncu&#39;</span><span class="p">:</span> <span class="c1"># &#39;mirror&#39; operation: remove old extras, put only the new ones</span>
        <span class="k">return</span> <span class="n">new_extras</span>

    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;knl&#39;</span><span class="p">:</span> <span class="c1"># &#39;none&#39;: keep old extras, do not add imported ones</span>
        <span class="k">return</span> <span class="n">old_extras</span>

    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;kcu&#39;</span><span class="p">:</span> <span class="c1"># &#39;update_existing&#39; operation: if an extra already exists,</span>
                      <span class="c1"># overwrite its new value with a new one</span>
        <span class="n">final_extras</span> <span class="o">=</span> <span class="n">new_extras</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">old_keys_only</span><span class="p">:</span>
            <span class="n">final_extras</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">old_extras</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;kcl&#39;</span><span class="p">:</span> <span class="c1"># &#39;keep_existing&#39;: if an extra already exists, keep its original value</span>
        <span class="n">final_extras</span> <span class="o">=</span> <span class="n">old_extras</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">new_keys_only</span><span class="p">:</span>
            <span class="n">final_extras</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_extras</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;kca&#39;</span><span class="p">:</span> <span class="c1"># &#39;ask&#39;: if an extra already exists ask a user whether to update its value</span>
        <span class="n">final_extras</span> <span class="o">=</span> <span class="n">old_extras</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">new_keys_only</span><span class="p">:</span>
            <span class="n">final_extras</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_extras</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">collided_keys</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">old_extras</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">!=</span> <span class="n">new_extras</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">click</span><span class="o">.</span><span class="n">confirm</span><span class="p">(</span><span class="s1">&#39;The extra </span><span class="si">{}</span><span class="s1"> collided, would you&#39;</span>
                        <span class="s1">&#39; like to overwrite its value?</span><span class="se">\n</span><span class="s1">Old value: </span><span class="si">{}</span><span class="se">\n</span><span class="s1">New value: </span><span class="si">{}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">,</span>
                            <span class="n">old_extras</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">new_extras</span><span class="p">[</span><span class="n">key</span><span class="p">])):</span>
                    <span class="n">final_extras</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_extras</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="c1"># Slow, but more general implementation</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">mode</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;k&#39;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">old_keys_only</span><span class="p">:</span>
                <span class="n">final_extras</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">old_extras</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">mode</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;n&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown first letter of the update extras mode: &#39;</span><span class="si">{}</span><span class="s2">&#39;. &quot;</span> \
                             <span class="s2">&quot;Should be either &#39;k&#39; or &#39;n&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">mode</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">new_keys_only</span><span class="p">:</span>
                <span class="n">final_extras</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_extras</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">mode</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;n&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown second letter of the update extras mode: &#39;</span><span class="si">{}</span><span class="s2">&#39;. &quot;</span> \
                             <span class="s2">&quot;Should be either &#39;c&#39; or &#39;n&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">mode</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;u&#39;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">collided_keys</span><span class="p">:</span>
                <span class="n">final_extras</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_extras</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">mode</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;l&#39;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">collided_keys</span><span class="p">:</span>
                <span class="n">final_extras</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">old_extras</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">mode</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;a&#39;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">collided_keys</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">old_extras</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">!=</span> <span class="n">new_extras</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">click</span><span class="o">.</span><span class="n">confirm</span><span class="p">(</span><span class="s1">&#39;The extra </span><span class="si">{}</span><span class="s1"> collided, would you&#39;</span>
                            <span class="s1">&#39; like to overwrite its value?</span><span class="se">\n</span><span class="s1">Old value: </span><span class="si">{}</span><span class="se">\n</span><span class="s1">New value: </span><span class="si">{}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">,</span>
                                <span class="n">old_extras</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">new_extras</span><span class="p">[</span><span class="n">key</span><span class="p">])):</span>
                        <span class="n">final_extras</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_extras</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">final_extras</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">old_extras</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">mode</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;d&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown third letter of the update extras mode: &#39;</span><span class="si">{}</span><span class="s2">&#39;. &quot;</span> \
                             <span class="s2">&quot;Should be one of &#39;u&#39;/&#39;l&#39;/&#39;a&#39;/&#39;d&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">final_extras</span></div>


<div class="viewcode-block" id="_merge_comment"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.importexport._merge_comment">[docs]</a><span class="k">def</span> <span class="nf">_merge_comment</span><span class="p">(</span><span class="n">incoming_comment</span><span class="p">,</span> <span class="n">comment_mode</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Merge comment according comment_mode</span>
<span class="sd">    :return: New UUID if new Comment should be created, else None.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Get incoming Comment&#39;s UUID, &#39;mtime&#39;, and &#39;comment&#39;</span>
    <span class="n">incoming_uuid</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">incoming_comment</span><span class="p">[</span><span class="s1">&#39;uuid&#39;</span><span class="p">])</span>
    <span class="n">incoming_mtime</span> <span class="o">=</span> <span class="n">incoming_comment</span><span class="p">[</span><span class="s1">&#39;mtime&#39;</span><span class="p">]</span>
    <span class="n">incoming_content</span> <span class="o">=</span> <span class="n">incoming_comment</span><span class="p">[</span><span class="s1">&#39;content&#39;</span><span class="p">]</span>

    <span class="c1"># Compare modification time &#39;mtime&#39;</span>
    <span class="k">if</span> <span class="n">comment_mode</span> <span class="o">==</span> <span class="s1">&#39;newest&#39;</span><span class="p">:</span>
        <span class="c1"># Get existing Comment&#39;s &#39;mtime&#39; and &#39;content&#39;</span>
        <span class="n">builder</span> <span class="o">=</span> <span class="n">QueryBuilder</span><span class="p">()</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Comment</span><span class="p">,</span>
            <span class="n">filters</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;uuid&#39;</span><span class="p">:</span> <span class="n">incoming_uuid</span><span class="p">},</span>
            <span class="n">project</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;mtime&#39;</span><span class="p">,</span> <span class="s1">&#39;content&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">builder</span><span class="o">.</span><span class="n">count</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">ValidationError</span><span class="p">(</span><span class="s2">&quot;Multiple Comments with the same &quot;</span>
                                             <span class="s2">&quot;UUID: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">incoming_uuid</span><span class="p">))</span>
        <span class="n">builder</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>

        <span class="n">existing_mtime</span> <span class="o">=</span> <span class="n">builder</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">existing_content</span> <span class="o">=</span> <span class="n">builder</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Existing Comment is &quot;newer&quot; than imported Comment: KEEP existing</span>
        <span class="k">if</span> <span class="n">existing_mtime</span> <span class="o">&gt;</span> <span class="n">incoming_mtime</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># Existing Comment is &quot;older&quot; than imported Comment: OVERWRITE existing</span>
        <span class="k">if</span> <span class="n">existing_mtime</span> <span class="o">&lt;</span> <span class="n">incoming_mtime</span><span class="p">:</span>
            <span class="n">cmt</span> <span class="o">=</span> <span class="n">Comment</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">uuid</span><span class="o">=</span><span class="n">incoming_uuid</span><span class="p">)</span>
            <span class="n">cmt</span><span class="o">.</span><span class="n">set_content</span><span class="p">(</span><span class="n">incoming_content</span><span class="p">)</span>
            <span class="n">cmt</span><span class="o">.</span><span class="n">set_mtime</span><span class="p">(</span><span class="n">incoming_mtime</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># Existing Comment has the same modification time as the imported Comment</span>
        <span class="c1"># Check content. If the same, ignore Comment. If different, add as new Comment.</span>
        <span class="k">if</span> <span class="n">existing_mtime</span> <span class="o">==</span> <span class="n">incoming_mtime</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">existing_content</span> <span class="o">==</span> <span class="n">incoming_content</span><span class="p">:</span>
                <span class="c1"># Ignore</span>
                <span class="k">return</span> <span class="kc">None</span>

            <span class="c1"># ELSE: Add it as a new comment</span>
            <span class="k">return</span> <span class="n">get_new_uuid</span><span class="p">()</span>

    <span class="c1"># Overwrite existing Comment</span>
    <span class="k">elif</span> <span class="n">comment_mode</span> <span class="o">==</span> <span class="s1">&#39;overwrite&#39;</span><span class="p">:</span>
        <span class="n">cmt</span> <span class="o">=</span> <span class="n">Comment</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">uuid</span><span class="o">=</span><span class="n">incoming_uuid</span><span class="p">)</span>
        <span class="n">cmt</span><span class="o">.</span><span class="n">set_content</span><span class="p">(</span><span class="n">incoming_content</span><span class="p">)</span>
        <span class="n">cmt</span><span class="o">.</span><span class="n">set_mtime</span><span class="p">(</span><span class="n">incoming_mtime</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># Invalid comment_mode</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown comment_mode value: </span><span class="si">{}</span><span class="s2">. Should be &quot;</span>
                         <span class="s2">&quot;either &#39;newest&#39; or &#39;overwrite&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">comment_mode</span><span class="p">))</span></div>


<div class="viewcode-block" id="import_data"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.importexport.import_data">[docs]</a><span class="k">def</span> <span class="nf">import_data</span><span class="p">(</span><span class="n">in_path</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">silent</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Import exported AiiDA environment to the AiiDA database.</span>
<span class="sd">    If the &#39;in_path&#39; is a folder, calls extract_tree; otherwise, tries to</span>
<span class="sd">    detect the compression format (zip, tar.gz, tar.bz2, ...) and calls the</span>
<span class="sd">    correct function.</span>
<span class="sd">    :param in_path: the path to a file or folder that can be imported in AiiDA</span>
<span class="sd">    :param extras_mode_existing: 3 letter code that will identify what to do with the extras import.</span>
<span class="sd">    The first letter acts on extras that are present in the original node and not present in the imported node.</span>
<span class="sd">    Can be either:</span>
<span class="sd">    &#39;k&#39; (keep it) or</span>
<span class="sd">    &#39;n&#39; (do not keep it).</span>
<span class="sd">    The second letter acts on the imported extras that are not present in the original node.</span>
<span class="sd">    Can be either:</span>
<span class="sd">    &#39;c&#39; (create it) or</span>
<span class="sd">    &#39;n&#39; (do not create it).</span>
<span class="sd">    The third letter defines what to do in case of a name collision.</span>
<span class="sd">    Can be either:</span>
<span class="sd">    &#39;l&#39; (leave the old value),</span>
<span class="sd">    &#39;u&#39; (update with a new value),</span>
<span class="sd">    &#39;d&#39; (delete the extra),</span>
<span class="sd">    &#39;a&#39; (ask what to do if the content is different).</span>
<span class="sd">    :param extras_mode_new: &#39;import&#39; to import extras of new nodes or &#39;none&#39; to ignore them</span>
<span class="sd">    :param comment_node_existing: Similar to param extras_mode_existing, but for Comments.</span>
<span class="sd">    :param comment_mode_new: Similar to param extras_mode_new, but for Comments.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">aiida.manage</span> <span class="k">import</span> <span class="n">configuration</span>
    <span class="kn">from</span> <span class="nn">aiida.backends</span> <span class="k">import</span> <span class="n">BACKEND_DJANGO</span><span class="p">,</span> <span class="n">BACKEND_SQLA</span>

    <span class="k">if</span> <span class="n">configuration</span><span class="o">.</span><span class="n">PROFILE</span><span class="o">.</span><span class="n">database_backend</span> <span class="o">==</span> <span class="n">BACKEND_SQLA</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">import_data_sqla</span><span class="p">(</span><span class="n">in_path</span><span class="p">,</span> <span class="n">user_group</span><span class="o">=</span><span class="n">group</span><span class="p">,</span> <span class="n">silent</span><span class="o">=</span><span class="n">silent</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">configuration</span><span class="o">.</span><span class="n">PROFILE</span><span class="o">.</span><span class="n">database_backend</span> <span class="o">==</span> <span class="n">BACKEND_DJANGO</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">import_data_dj</span><span class="p">(</span><span class="n">in_path</span><span class="p">,</span> <span class="n">user_group</span><span class="o">=</span><span class="n">group</span><span class="p">,</span> <span class="n">silent</span><span class="o">=</span><span class="n">silent</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Unknown backend: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">configuration</span><span class="o">.</span><span class="n">PROFILE</span><span class="o">.</span><span class="n">database_backend</span><span class="p">))</span></div>


<div class="viewcode-block" id="import_data_dj"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.importexport.import_data_dj">[docs]</a><span class="k">def</span> <span class="nf">import_data_dj</span><span class="p">(</span><span class="n">in_path</span><span class="p">,</span> <span class="n">user_group</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ignore_unknown_nodes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                   <span class="n">extras_mode_existing</span><span class="o">=</span><span class="s1">&#39;kcl&#39;</span><span class="p">,</span> <span class="n">extras_mode_new</span><span class="o">=</span><span class="s1">&#39;import&#39;</span><span class="p">,</span>
                   <span class="n">comment_mode</span><span class="o">=</span><span class="s1">&#39;newest&#39;</span><span class="p">,</span> <span class="n">silent</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Import exported AiiDA environment to the AiiDA database.</span>
<span class="sd">    If the &#39;in_path&#39; is a folder, calls extract_tree; otherwise, tries to</span>
<span class="sd">    detect the compression format (zip, tar.gz, tar.bz2, ...) and calls the</span>
<span class="sd">    correct function.</span>
<span class="sd">    :param in_path: the path to a file or folder that can be imported in AiiDA</span>
<span class="sd">    :param extras_mode_existing: 3 letter code that will identify what to do with the extras import.</span>
<span class="sd">    The first letter acts on extras that are present in the original node and not present in the imported node.</span>
<span class="sd">    Can be either:</span>
<span class="sd">    &#39;k&#39; (keep it) or</span>
<span class="sd">    &#39;n&#39; (do not keep it).</span>
<span class="sd">    The second letter acts on the imported extras that are not present in the original node.</span>
<span class="sd">    Can be either:</span>
<span class="sd">    &#39;c&#39; (create it) or</span>
<span class="sd">    &#39;n&#39; (do not create it).</span>
<span class="sd">    The third letter defines what to do in case of a name collision.</span>
<span class="sd">    Can be either:</span>
<span class="sd">    &#39;l&#39; (leave the old value),</span>
<span class="sd">    &#39;u&#39; (update with a new value),</span>
<span class="sd">    &#39;d&#39; (delete the extra),</span>
<span class="sd">    &#39;a&#39; (ask what to do if the content is different).</span>
<span class="sd">    :param extras_mode_new: &#39;import&#39; to import extras of new nodes or &#39;none&#39; to ignore them</span>
<span class="sd">    :param comment_mode: Comment import modes (when same UUIDs are found):</span>
<span class="sd">    &#39;newest&#39;: Will keep the Comment with the most recent modification time (mtime)</span>
<span class="sd">    &#39;overwrite&#39;: Will overwrite existing Comments with the ones from the import file</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">os</span>
    <span class="kn">import</span> <span class="nn">tarfile</span>
    <span class="kn">import</span> <span class="nn">zipfile</span>
    <span class="kn">from</span> <span class="nn">itertools</span> <span class="k">import</span> <span class="n">chain</span>

    <span class="kn">from</span> <span class="nn">django.db</span> <span class="k">import</span> <span class="n">transaction</span>
    <span class="kn">from</span> <span class="nn">aiida.common</span> <span class="k">import</span> <span class="n">timezone</span>

    <span class="kn">from</span> <span class="nn">aiida.common.archive</span> <span class="k">import</span> <span class="n">extract_tree</span><span class="p">,</span> <span class="n">extract_tar</span><span class="p">,</span> <span class="n">extract_zip</span>
    <span class="kn">from</span> <span class="nn">aiida.common.links</span> <span class="k">import</span> <span class="n">LinkType</span>
    <span class="kn">from</span> <span class="nn">aiida.common.folders</span> <span class="k">import</span> <span class="n">SandboxFolder</span><span class="p">,</span> <span class="n">RepositoryFolder</span>
    <span class="kn">from</span> <span class="nn">aiida.backends.djsite.db</span> <span class="k">import</span> <span class="n">models</span>
    <span class="kn">from</span> <span class="nn">aiida.common.utils</span> <span class="k">import</span> <span class="n">get_object_from_string</span>
    <span class="kn">from</span> <span class="nn">aiida.common</span> <span class="k">import</span> <span class="n">json</span>
    <span class="kn">from</span> <span class="nn">aiida.backends.djsite.db.models</span> <span class="k">import</span> <span class="n">suppress_auto_now</span>

    <span class="c1"># This is the export version expected by this function</span>
    <span class="n">expected_export_version</span> <span class="o">=</span> <span class="n">StrictVersion</span><span class="p">(</span><span class="s1">&#39;0.4&#39;</span><span class="p">)</span>

    <span class="c1"># The name of the subfolder in which the node files are stored</span>
    <span class="n">nodes_export_subfolder</span> <span class="o">=</span> <span class="s1">&#39;nodes&#39;</span>

    <span class="c1"># The returned dictionary with new and existing nodes and links</span>
    <span class="n">ret_dict</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1">################</span>
    <span class="c1"># EXTRACT DATA #</span>
    <span class="c1">################</span>
    <span class="c1"># The sandbox has to remain open until the end</span>
    <span class="k">with</span> <span class="n">SandboxFolder</span><span class="p">()</span> <span class="k">as</span> <span class="n">folder</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">in_path</span><span class="p">):</span>
            <span class="n">extract_tree</span><span class="p">(</span><span class="n">in_path</span><span class="p">,</span> <span class="n">folder</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">tarfile</span><span class="o">.</span><span class="n">is_tarfile</span><span class="p">(</span><span class="n">in_path</span><span class="p">):</span>
                <span class="n">extract_tar</span><span class="p">(</span><span class="n">in_path</span><span class="p">,</span> <span class="n">folder</span><span class="p">,</span> <span class="n">silent</span><span class="o">=</span><span class="n">silent</span><span class="p">,</span>
                            <span class="n">nodes_export_subfolder</span><span class="o">=</span><span class="n">nodes_export_subfolder</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">zipfile</span><span class="o">.</span><span class="n">is_zipfile</span><span class="p">(</span><span class="n">in_path</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">extract_zip</span><span class="p">(</span><span class="n">in_path</span><span class="p">,</span> <span class="n">folder</span><span class="p">,</span> <span class="n">silent</span><span class="o">=</span><span class="n">silent</span><span class="p">,</span>
                                <span class="n">nodes_export_subfolder</span><span class="o">=</span><span class="n">nodes_export_subfolder</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The following problem occured while processing the &quot;</span>
                          <span class="s2">&quot;provided file: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">exc</span><span class="p">))</span>
                    <span class="k">return</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unable to detect the input file format, it &quot;</span>
                                 <span class="s2">&quot;is neither a (possibly compressed) tar file, &quot;</span>
                                 <span class="s2">&quot;nor a zip file.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">folder</span><span class="o">.</span><span class="n">get_content_list</span><span class="p">():</span>
            <span class="kn">from</span> <span class="nn">aiida.common.exceptions</span> <span class="k">import</span> <span class="n">ContentNotExistent</span>
            <span class="k">raise</span> <span class="n">ContentNotExistent</span><span class="p">(</span><span class="s2">&quot;The provided file/folder (</span><span class="si">{}</span><span class="s2">) is empty&quot;</span>
                                     <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">in_path</span><span class="p">))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">io</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">folder</span><span class="o">.</span><span class="n">get_abs_path</span><span class="p">(</span><span class="s1">&#39;metadata.json&#39;</span><span class="p">),</span> <span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;utf8&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fhandle</span><span class="p">:</span>
                <span class="n">metadata</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fhandle</span><span class="p">)</span>

            <span class="k">with</span> <span class="n">io</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">folder</span><span class="o">.</span><span class="n">get_abs_path</span><span class="p">(</span><span class="s1">&#39;data.json&#39;</span><span class="p">),</span> <span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;utf8&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fhandle</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fhandle</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">IOError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unable to find the file </span><span class="si">{}</span><span class="s2"> in the import &quot;</span>
                             <span class="s2">&quot;file or folder&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">filename</span><span class="p">))</span>

        <span class="c1">######################</span>
        <span class="c1"># PRELIMINARY CHECKS #</span>
        <span class="c1">######################</span>
        <span class="n">export_version</span> <span class="o">=</span> <span class="n">StrictVersion</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;export_version&#39;</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">export_version</span> <span class="o">!=</span> <span class="n">expected_export_version</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Export file version is </span><span class="si">{}</span><span class="s2">, can import only version </span><span class="si">{}</span><span class="s2">&quot;</span>\
                    <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;export_version&#39;</span><span class="p">],</span> <span class="n">expected_export_version</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">export_version</span> <span class="o">&lt;</span> <span class="n">expected_export_version</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Use &#39;verdi export migrate&#39; to update this export file.&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Update your AiiDA version in order to import this file.&quot;</span>

            <span class="k">raise</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">IncompatibleArchiveVersionError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c1">##########################################################################</span>
        <span class="c1"># CREATE UUID REVERSE TABLES AND CHECK IF I HAVE ALL NODES FOR THE LINKS #</span>
        <span class="c1">##########################################################################</span>
        <span class="n">linked_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">((</span><span class="n">l</span><span class="p">[</span><span class="s1">&#39;input&#39;</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="s1">&#39;output&#39;</span><span class="p">])</span>
                                               <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;links_uuid&#39;</span><span class="p">]))</span>
        <span class="n">group_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">six</span><span class="o">.</span><span class="n">itervalues</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;groups_uuid&#39;</span><span class="p">])))</span>

        <span class="c1"># I preload the nodes, I need to check each of them later, and I also</span>
        <span class="c1"># store them in a reverse table</span>
        <span class="c1"># I break up the query due to SQLite limitations..</span>
        <span class="n">relevant_db_nodes</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">grouper</span><span class="p">(</span><span class="mi">999</span><span class="p">,</span> <span class="n">linked_nodes</span><span class="p">):</span>
            <span class="n">relevant_db_nodes</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">n</span><span class="o">.</span><span class="n">uuid</span><span class="p">:</span> <span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span>
                                      <span class="n">models</span><span class="o">.</span><span class="n">DbNode</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
                                          <span class="n">uuid__in</span><span class="o">=</span><span class="n">group</span><span class="p">)})</span>

        <span class="n">db_nodes_uuid</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">relevant_db_nodes</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="c1"># ~ dbnode_model = get_class_string(models.DbNode)</span>
        <span class="c1"># ~ print(dbnode_model)</span>
        <span class="k">if</span> <span class="n">NODE_ENTITY_NAME</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;export_data&#39;</span><span class="p">]:</span>
            <span class="n">import_nodes_uuid</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="s1">&#39;uuid&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;export_data&#39;</span><span class="p">][</span><span class="n">NODE_ENTITY_NAME</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">import_nodes_uuid</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="c1"># the combined set of linked_nodes and group_nodes was obtained from looking at all the links</span>
        <span class="c1"># the combined set of db_nodes_uuid and import_nodes_uuid was received from the staff</span>
        <span class="c1"># actually referred to in export_data</span>
        <span class="n">unknown_nodes</span> <span class="o">=</span> <span class="n">linked_nodes</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">group_nodes</span><span class="p">)</span> <span class="o">-</span> <span class="n">db_nodes_uuid</span><span class="o">.</span><span class="n">union</span><span class="p">(</span>
            <span class="n">import_nodes_uuid</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">unknown_nodes</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">ignore_unknown_nodes</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The import file refers to </span><span class="si">{}</span><span class="s2"> nodes with unknown UUID, therefore &quot;</span>
                <span class="s2">&quot;it cannot be imported. Either first import the unknown nodes, &quot;</span>
                <span class="s2">&quot;or export also the parents when exporting. The unknown UUIDs &quot;</span>
                <span class="s2">&quot;are:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">unknown_nodes</span><span class="p">))</span> <span class="o">+</span>
                <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;* </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">uuid</span><span class="p">)</span> <span class="k">for</span> <span class="n">uuid</span> <span class="ow">in</span> <span class="n">unknown_nodes</span><span class="p">))</span>

        <span class="c1">###################################</span>
        <span class="c1"># DOUBLE-CHECK MODEL DEPENDENCIES #</span>
        <span class="c1">###################################</span>
        <span class="c1"># I hardcode here the model order, for simplicity; in any case, this is</span>
        <span class="c1"># fixed by the export version</span>

        <span class="n">model_order</span> <span class="o">=</span> <span class="p">(</span><span class="n">USER_ENTITY_NAME</span><span class="p">,</span> <span class="n">COMPUTER_ENTITY_NAME</span><span class="p">,</span> <span class="n">NODE_ENTITY_NAME</span><span class="p">,</span>
                      <span class="n">GROUP_ENTITY_NAME</span><span class="p">,</span> <span class="n">LOG_ENTITY_NAME</span><span class="p">,</span> <span class="n">COMMENT_ENTITY_NAME</span><span class="p">)</span>
        <span class="c1"># Models that do appear in the import file, but whose import is managed manually</span>
        <span class="n">model_manual</span> <span class="o">=</span> <span class="p">(</span><span class="n">LINK_ENTITY_NAME</span><span class="p">,</span> <span class="n">ATTRIBUTE_ENTITY_NAME</span><span class="p">)</span>

        <span class="n">all_known_models</span> <span class="o">=</span> <span class="n">model_order</span> <span class="o">+</span> <span class="n">model_manual</span>

        <span class="k">for</span> <span class="n">import_field_name</span> <span class="ow">in</span> <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;all_fields_info&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">import_field_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">all_known_models</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Apparently, you are importing a &quot;</span>
                                          <span class="s2">&quot;file with a model &#39;</span><span class="si">{}</span><span class="s2">&#39;, but this does not appear in &quot;</span>
                                          <span class="s2">&quot;all_known_models!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">import_field_name</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">model_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">model_order</span><span class="p">):</span>
            <span class="n">dependencies</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;all_fields_info&#39;</span><span class="p">][</span><span class="n">model_name</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">dependencies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="s1">&#39;requires&#39;</span><span class="p">])</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="c1"># (No ForeignKey)</span>
                    <span class="k">pass</span>
            <span class="k">for</span> <span class="n">dependency</span> <span class="ow">in</span> <span class="n">dependencies</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">dependency</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">model_order</span><span class="p">[:</span><span class="n">idx</span><span class="p">]:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Model </span><span class="si">{}</span><span class="s2"> requires </span><span class="si">{}</span><span class="s2"> but would be loaded &quot;</span>
                                     <span class="s2">&quot;first; stopping...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">model_name</span><span class="p">,</span>
                                                                 <span class="n">dependency</span><span class="p">))</span>

        <span class="c1">###################################################</span>
        <span class="c1"># CREATE IMPORT DATA DIRECT UNIQUE_FIELD MAPPINGS #</span>
        <span class="c1">###################################################</span>
        <span class="n">import_unique_ids_mappings</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">model_name</span><span class="p">,</span> <span class="n">import_data</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;export_data&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">model_name</span> <span class="ow">in</span> <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;unique_identifiers&#39;</span><span class="p">]:</span>
                <span class="c1"># I have to reconvert the pk to integer</span>
                <span class="n">import_unique_ids_mappings</span><span class="p">[</span><span class="n">model_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="nb">int</span><span class="p">(</span><span class="n">k</span><span class="p">):</span> <span class="n">v</span><span class="p">[</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;unique_identifiers&#39;</span><span class="p">][</span><span class="n">model_name</span><span class="p">]]</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span>
                    <span class="n">import_data</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

        <span class="c1">###############</span>
        <span class="c1"># IMPORT DATA #</span>
        <span class="c1">###############</span>
        <span class="c1"># DO ALL WITH A TRANSACTION</span>
        <span class="k">with</span> <span class="n">transaction</span><span class="o">.</span><span class="n">atomic</span><span class="p">():</span>
            <span class="n">foreign_ids_reverse_mappings</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">new_entries</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">existing_entries</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="c1"># I first generate the list of data</span>
            <span class="k">for</span> <span class="n">model_name</span> <span class="ow">in</span> <span class="n">model_order</span><span class="p">:</span>
                <span class="n">cls_signature</span> <span class="o">=</span> <span class="n">entity_names_to_signatures</span><span class="p">[</span><span class="n">model_name</span><span class="p">]</span>
                <span class="n">Model</span> <span class="o">=</span> <span class="n">get_object_from_string</span><span class="p">(</span><span class="n">cls_signature</span><span class="p">)</span>
                <span class="n">fields_info</span> <span class="o">=</span> <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;all_fields_info&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">model_name</span><span class="p">,</span> <span class="p">{})</span>
                <span class="n">unique_identifier</span> <span class="o">=</span> <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;unique_identifiers&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                    <span class="n">model_name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

                <span class="n">new_entries</span><span class="p">[</span><span class="n">model_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="n">existing_entries</span><span class="p">[</span><span class="n">model_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

                <span class="n">foreign_ids_reverse_mappings</span><span class="p">[</span><span class="n">model_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

                <span class="c1"># Not necessarily all models are exported</span>
                <span class="k">if</span> <span class="n">model_name</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;export_data&#39;</span><span class="p">]:</span>

                    <span class="c1"># skip nodes that are already present in the DB</span>
                    <span class="k">if</span> <span class="n">unique_identifier</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">import_unique_ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">unique_identifier</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span>
                                                <span class="n">data</span><span class="p">[</span><span class="s1">&#39;export_data&#39;</span><span class="p">][</span><span class="n">model_name</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

                        <span class="n">relevant_db_entries_result</span> <span class="o">=</span> <span class="n">Model</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
                            <span class="o">**</span><span class="p">{</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">__in&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">unique_identifier</span><span class="p">):</span> <span class="n">import_unique_ids</span><span class="p">})</span>
                        <span class="c1"># Note: uuids need to be converted to strings</span>
                        <span class="n">relevant_db_entries</span> <span class="o">=</span> <span class="p">{</span><span class="nb">str</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">unique_identifier</span><span class="p">)):</span>
                                <span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">relevant_db_entries_result</span><span class="p">}</span>

                        <span class="n">foreign_ids_reverse_mappings</span><span class="p">[</span><span class="n">model_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                            <span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="o">.</span><span class="n">pk</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">relevant_db_entries</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
                        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;export_data&#39;</span><span class="p">][</span><span class="n">model_name</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                            <span class="k">if</span> <span class="n">v</span><span class="p">[</span><span class="n">unique_identifier</span><span class="p">]</span> <span class="ow">in</span> <span class="n">relevant_db_entries</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                                <span class="c1"># Already in DB</span>
                                <span class="n">existing_entries</span><span class="p">[</span><span class="n">model_name</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="c1"># To be added</span>
                                <span class="n">new_entries</span><span class="p">[</span><span class="n">model_name</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">new_entries</span><span class="p">[</span><span class="n">model_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;export_data&#39;</span><span class="p">][</span><span class="n">model_name</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="c1"># Show Comment mode if not silent and Comments exist in existing_entries</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">silent</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">COMMENT_ENTITY_NAME</span> <span class="ow">in</span> <span class="n">existing_entries</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Comment mode: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">comment_mode</span><span class="p">))</span>

            <span class="c1"># I import data from the given model</span>
            <span class="k">for</span> <span class="n">model_name</span> <span class="ow">in</span> <span class="n">model_order</span><span class="p">:</span>
                <span class="n">cls_signature</span> <span class="o">=</span> <span class="n">entity_names_to_signatures</span><span class="p">[</span><span class="n">model_name</span><span class="p">]</span>
                <span class="n">Model</span> <span class="o">=</span> <span class="n">get_object_from_string</span><span class="p">(</span><span class="n">cls_signature</span><span class="p">)</span>
                <span class="c1"># Model = get_object_from_string(model_name)</span>
                <span class="n">fields_info</span> <span class="o">=</span> <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;all_fields_info&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">model_name</span><span class="p">,</span> <span class="p">{})</span>
                <span class="n">unique_identifier</span> <span class="o">=</span> <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;unique_identifiers&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                    <span class="n">model_name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">import_entry_id</span><span class="p">,</span> <span class="n">entry_data</span> <span class="ow">in</span> <span class="n">existing_entries</span><span class="p">[</span><span class="n">model_name</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">unique_id</span> <span class="o">=</span> <span class="n">entry_data</span><span class="p">[</span><span class="n">unique_identifier</span><span class="p">]</span>
                    <span class="n">existing_entry_id</span> <span class="o">=</span> <span class="n">foreign_ids_reverse_mappings</span><span class="p">[</span><span class="n">model_name</span><span class="p">][</span><span class="n">unique_id</span><span class="p">]</span>
                    <span class="n">import_data</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">deserialize_field</span><span class="p">(</span>
                        <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">fields_info</span><span class="o">=</span><span class="n">fields_info</span><span class="p">,</span>
                        <span class="n">import_unique_ids_mappings</span><span class="o">=</span><span class="n">import_unique_ids_mappings</span><span class="p">,</span>
                        <span class="n">foreign_ids_reverse_mappings</span><span class="o">=</span><span class="n">foreign_ids_reverse_mappings</span><span class="p">)</span>
                                       <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">entry_data</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
                    <span class="c1"># TODO COMPARE, AND COMPARE ATTRIBUTES</span>

                    <span class="k">if</span> <span class="n">Model</span> <span class="ow">is</span> <span class="n">models</span><span class="o">.</span><span class="n">DbComment</span><span class="p">:</span>
                        <span class="n">new_entry_uuid</span> <span class="o">=</span> <span class="n">_merge_comment</span><span class="p">(</span><span class="n">import_data</span><span class="p">,</span> <span class="n">comment_mode</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">new_entry_uuid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">entry_data</span><span class="p">[</span><span class="n">unique_identifier</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_entry_uuid</span>
                            <span class="n">new_entries</span><span class="p">[</span><span class="n">model_name</span><span class="p">][</span><span class="n">import_entry_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">entry_data</span>

                    <span class="k">if</span> <span class="n">model_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ret_dict</span><span class="p">:</span>
                        <span class="n">ret_dict</span><span class="p">[</span><span class="n">model_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;new&#39;</span><span class="p">:</span> <span class="p">[],</span> <span class="s1">&#39;existing&#39;</span><span class="p">:</span> <span class="p">[]}</span>
                    <span class="n">ret_dict</span><span class="p">[</span><span class="n">model_name</span><span class="p">][</span><span class="s1">&#39;existing&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">import_entry_id</span><span class="p">,</span>
                                                             <span class="n">existing_entry_id</span><span class="p">))</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">silent</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;existing </span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2"> (</span><span class="si">%s</span><span class="s2">-&gt;</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">model_name</span><span class="p">,</span> <span class="n">unique_id</span><span class="p">,</span>
                                                            <span class="n">import_entry_id</span><span class="p">,</span>
                                                            <span class="n">existing_entry_id</span><span class="p">))</span>
                        <span class="c1"># print(&quot;  `-&gt; WARNING: NO DUPLICITY CHECK DONE!&quot;)</span>
                        <span class="c1"># CHECK ALSO FILES!</span>

                <span class="c1"># Store all objects for this model in a list, and store them</span>
                <span class="c1"># all in once at the end.</span>
                <span class="n">objects_to_create</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="c1"># This is needed later to associate the import entry with the new pk</span>
                <span class="n">import_entry_ids</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="n">imported_comp_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">import_entry_id</span><span class="p">,</span> <span class="n">entry_data</span> <span class="ow">in</span> <span class="n">new_entries</span><span class="p">[</span><span class="n">model_name</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">unique_id</span> <span class="o">=</span> <span class="n">entry_data</span><span class="p">[</span><span class="n">unique_identifier</span><span class="p">]</span>
                    <span class="n">import_data</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">deserialize_field</span><span class="p">(</span>
                        <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">fields_info</span><span class="o">=</span><span class="n">fields_info</span><span class="p">,</span>
                        <span class="n">import_unique_ids_mappings</span><span class="o">=</span><span class="n">import_unique_ids_mappings</span><span class="p">,</span>
                        <span class="n">foreign_ids_reverse_mappings</span><span class="o">=</span><span class="n">foreign_ids_reverse_mappings</span><span class="p">)</span>
                                       <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">entry_data</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>

                    <span class="k">if</span> <span class="n">Model</span> <span class="ow">is</span> <span class="n">models</span><span class="o">.</span><span class="n">DbGroup</span><span class="p">:</span>
                        <span class="c1"># Check if there is already a group with the same name</span>
                        <span class="n">dupl_counter</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="n">orig_label</span> <span class="o">=</span> <span class="n">import_data</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]</span>
                        <span class="k">while</span> <span class="n">Model</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="n">import_data</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]):</span>
                            <span class="n">import_data</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">orig_label</span> <span class="o">+</span> <span class="n">DUPL_SUFFIX</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dupl_counter</span><span class="p">)</span>
                            <span class="n">dupl_counter</span> <span class="o">+=</span> <span class="mi">1</span>
                            <span class="k">if</span> <span class="n">dupl_counter</span> <span class="o">==</span> <span class="mi">100</span><span class="p">:</span>
                                <span class="k">raise</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">UniquenessError</span><span class="p">(</span><span class="s2">&quot;A group of that label ( </span><span class="si">{}</span><span class="s2"> ) already exists&quot;</span>
                                    <span class="s2">&quot; and I could not create a new one&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">orig_label</span><span class="p">))</span>

                    <span class="k">elif</span> <span class="n">Model</span> <span class="ow">is</span> <span class="n">models</span><span class="o">.</span><span class="n">DbComputer</span><span class="p">:</span>
                        <span class="c1"># Check if there is already a computer with the same name in the database</span>
                        <span class="n">dupl</span> <span class="o">=</span> <span class="p">(</span><span class="n">Model</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">import_data</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">])</span>
                                <span class="ow">or</span> <span class="n">import_data</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">imported_comp_names</span><span class="p">)</span>
                        <span class="n">orig_name</span> <span class="o">=</span> <span class="n">import_data</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span>
                        <span class="n">dupl_counter</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="k">while</span> <span class="n">dupl</span><span class="p">:</span>
                            <span class="c1"># Rename the new computer</span>
                            <span class="n">import_data</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                                    <span class="n">orig_name</span> <span class="o">+</span>
                                    <span class="n">DUPL_SUFFIX</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dupl_counter</span><span class="p">))</span>
                            <span class="n">dupl</span> <span class="o">=</span> <span class="p">(</span><span class="n">Model</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">import_data</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">])</span>
                                    <span class="ow">or</span> <span class="n">import_data</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">imported_comp_names</span><span class="p">)</span>
                            <span class="n">dupl_counter</span> <span class="o">+=</span> <span class="mi">1</span>
                            <span class="k">if</span> <span class="n">dupl_counter</span> <span class="o">==</span> <span class="mi">100</span><span class="p">:</span>
                                <span class="k">raise</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">UniquenessError</span><span class="p">(</span><span class="s2">&quot;A computer of that name ( </span><span class="si">{}</span><span class="s2"> ) already exists&quot;</span>
                                    <span class="s2">&quot; and I could not create a new one&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">orig_name</span><span class="p">))</span>

                        <span class="n">imported_comp_names</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">import_data</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">])</span>

                    <span class="n">objects_to_create</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Model</span><span class="p">(</span><span class="o">**</span><span class="n">import_data</span><span class="p">))</span>
                    <span class="n">import_entry_ids</span><span class="p">[</span><span class="n">unique_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">import_entry_id</span>

                <span class="c1"># Before storing entries in the DB, I store the files (if these</span>
                <span class="c1"># are nodes). Note: only for new entries!</span>
                <span class="k">if</span> <span class="n">model_name</span> <span class="o">==</span> <span class="n">NODE_ENTITY_NAME</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">silent</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;STORING NEW NODE FILES...&quot;</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">objects_to_create</span><span class="p">:</span>

                        <span class="n">subfolder</span> <span class="o">=</span> <span class="n">folder</span><span class="o">.</span><span class="n">get_subfolder</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                            <span class="n">nodes_export_subfolder</span><span class="p">,</span> <span class="n">export_shard_uuid</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">uuid</span><span class="p">)))</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">subfolder</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unable to find the repository &quot;</span>
                                             <span class="s2">&quot;folder for node with UUID=</span><span class="si">{}</span><span class="s2"> &quot;</span> \
                                             <span class="s2">&quot;in the exported &quot;</span>
                                             <span class="s2">&quot;file&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">uuid</span><span class="p">))</span>
                        <span class="n">destdir</span> <span class="o">=</span> <span class="n">RepositoryFolder</span><span class="p">(</span>
                            <span class="n">section</span><span class="o">=</span><span class="n">Repository</span><span class="o">.</span><span class="n">_section_name</span><span class="p">,</span>
                            <span class="n">uuid</span><span class="o">=</span><span class="n">o</span><span class="o">.</span><span class="n">uuid</span><span class="p">)</span>
                        <span class="c1"># Replace the folder, possibly destroying existing</span>
                        <span class="c1"># previous folders, and move the files (faster if we</span>
                        <span class="c1"># are on the same filesystem, and</span>
                        <span class="c1"># in any case the source is a SandboxFolder)</span>
                        <span class="n">destdir</span><span class="o">.</span><span class="n">replace_with_folder</span><span class="p">(</span><span class="n">subfolder</span><span class="o">.</span><span class="n">abspath</span><span class="p">,</span>
                                                    <span class="n">move</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                <span class="c1"># If there is an mtime in the field, disable the automatic update</span>
                <span class="c1"># to keep the mtime that we have set here</span>
                <span class="k">if</span> <span class="s1">&#39;mtime&#39;</span> <span class="ow">in</span> <span class="p">[</span><span class="n">field</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">Model</span><span class="o">.</span><span class="n">_meta</span><span class="o">.</span><span class="n">local_fields</span><span class="p">]:</span>
                    <span class="k">with</span> <span class="n">suppress_auto_now</span><span class="p">([(</span><span class="n">Model</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;mtime&#39;</span><span class="p">])]):</span>
                        <span class="c1"># Store them all in once; however, the PK are not set in this way...</span>
                        <span class="n">Model</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">bulk_create</span><span class="p">(</span><span class="n">objects_to_create</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">Model</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">bulk_create</span><span class="p">(</span><span class="n">objects_to_create</span><span class="p">)</span>

                <span class="c1"># Get back the just-saved entries</span>
                <span class="n">just_saved_queryset</span> <span class="o">=</span> <span class="n">Model</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
                    <span class="o">**</span><span class="p">{</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">__in&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">unique_identifier</span><span class="p">):</span>
                           <span class="n">import_entry_ids</span><span class="o">.</span><span class="n">keys</span><span class="p">()})</span><span class="o">.</span><span class="n">values_list</span><span class="p">(</span><span class="n">unique_identifier</span><span class="p">,</span> <span class="s1">&#39;pk&#39;</span><span class="p">)</span>
                <span class="c1"># note: convert uuids from type UUID to strings</span>
                <span class="n">just_saved</span> <span class="o">=</span> <span class="p">{</span> <span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">just_saved_queryset</span> <span class="p">}</span>

                <span class="c1"># Now I have the PKs, print the info</span>
                <span class="c1"># Moreover, set the foreign_ids_reverse_mappings</span>
                <span class="k">for</span> <span class="n">unique_id</span><span class="p">,</span> <span class="n">new_pk</span> <span class="ow">in</span> <span class="n">just_saved</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">import_entry_id</span> <span class="o">=</span> <span class="n">import_entry_ids</span><span class="p">[</span><span class="n">unique_id</span><span class="p">]</span>
                    <span class="n">foreign_ids_reverse_mappings</span><span class="p">[</span><span class="n">model_name</span><span class="p">][</span><span class="n">unique_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_pk</span>
                    <span class="k">if</span> <span class="n">model_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ret_dict</span><span class="p">:</span>
                        <span class="n">ret_dict</span><span class="p">[</span><span class="n">model_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;new&#39;</span><span class="p">:</span> <span class="p">[],</span> <span class="s1">&#39;existing&#39;</span><span class="p">:</span> <span class="p">[]}</span>
                    <span class="n">ret_dict</span><span class="p">[</span><span class="n">model_name</span><span class="p">][</span><span class="s1">&#39;new&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">import_entry_id</span><span class="p">,</span>
                                                        <span class="n">new_pk</span><span class="p">))</span>

                    <span class="k">if</span> <span class="ow">not</span> <span class="n">silent</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;NEW </span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2"> (</span><span class="si">%s</span><span class="s2">-&gt;</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">model_name</span><span class="p">,</span> <span class="n">unique_id</span><span class="p">,</span>
                                                       <span class="n">import_entry_id</span><span class="p">,</span>
                                                       <span class="n">new_pk</span><span class="p">))</span>

                <span class="c1"># For DbNodes, we also have to store its attributes</span>
                <span class="k">if</span> <span class="n">model_name</span> <span class="o">==</span> <span class="n">NODE_ENTITY_NAME</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">silent</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;STORING NEW NODE ATTRIBUTES...&quot;</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">unique_id</span><span class="p">,</span> <span class="n">new_pk</span> <span class="ow">in</span> <span class="n">just_saved</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="n">import_entry_id</span> <span class="o">=</span> <span class="n">import_entry_ids</span><span class="p">[</span><span class="n">unique_id</span><span class="p">]</span>
                        <span class="c1"># Get attributes from import file</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">attributes</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;node_attributes&#39;</span><span class="p">][</span>
                                <span class="nb">str</span><span class="p">(</span><span class="n">import_entry_id</span><span class="p">)]</span>
                            <span class="n">attributes_conversion</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span>
                                <span class="s1">&#39;node_attributes_conversion&#39;</span><span class="p">][</span>
                                <span class="nb">str</span><span class="p">(</span><span class="n">import_entry_id</span><span class="p">)]</span>
                        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unable to find attribute info &quot;</span>
                                             <span class="s2">&quot;for DbNode with UUID = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">unique_id</span><span class="p">))</span>

                        <span class="c1"># Here I have to deserialize the attributes</span>
                        <span class="n">deserialized_attributes</span> <span class="o">=</span> <span class="n">deserialize_attributes</span><span class="p">(</span>
                            <span class="n">attributes</span><span class="p">,</span> <span class="n">attributes_conversion</span><span class="p">)</span>
                        <span class="n">models</span><span class="o">.</span><span class="n">DbAttribute</span><span class="o">.</span><span class="n">reset_values_for_node</span><span class="p">(</span>
                            <span class="n">dbnode</span><span class="o">=</span><span class="n">new_pk</span><span class="p">,</span>
                            <span class="n">attributes</span><span class="o">=</span><span class="n">deserialized_attributes</span><span class="p">,</span>
                            <span class="n">with_transaction</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

                <span class="c1"># For DbNodes, we also have to store its extras</span>
                <span class="k">if</span> <span class="n">model_name</span> <span class="o">==</span> <span class="n">NODE_ENTITY_NAME</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">extras_mode_new</span> <span class="o">==</span> <span class="s1">&#39;import&#39;</span><span class="p">:</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">silent</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;STORING NEW NODE EXTRAS...&quot;</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">unique_id</span><span class="p">,</span> <span class="n">new_pk</span> <span class="ow">in</span> <span class="n">just_saved</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                            <span class="n">import_entry_id</span> <span class="o">=</span> <span class="n">import_entry_ids</span><span class="p">[</span><span class="n">unique_id</span><span class="p">]</span>
                            <span class="c1"># Get extras from import file</span>
                            <span class="k">try</span><span class="p">:</span>
                                <span class="n">extras</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;node_extras&#39;</span><span class="p">][</span>
                                    <span class="nb">str</span><span class="p">(</span><span class="n">import_entry_id</span><span class="p">)]</span>
                                <span class="n">extras_conversion</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span>
                                    <span class="s1">&#39;node_extras_conversion&#39;</span><span class="p">][</span>
                                    <span class="nb">str</span><span class="p">(</span><span class="n">import_entry_id</span><span class="p">)]</span>
                            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unable to find extras info &quot;</span>
                                                 <span class="s2">&quot;for DbNode with UUID = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">unique_id</span><span class="p">))</span>
                            <span class="n">deserialized_extras</span> <span class="o">=</span> <span class="n">deserialize_attributes</span><span class="p">(</span><span class="n">extras</span><span class="p">,</span> <span class="n">extras_conversion</span><span class="p">)</span>
                            <span class="c1"># TODO: remove when aiida extras will be moved somewhere else</span>
                            <span class="c1"># from here</span>
                            <span class="n">deserialized_extras</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span><span class="n">value</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span><span class="n">value</span> <span class="ow">in</span> <span class="n">deserialized_extras</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span>
                                    <span class="n">key</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;_aiida_&#39;</span><span class="p">)}</span>
                            <span class="k">if</span> <span class="n">models</span><span class="o">.</span><span class="n">DbNode</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">uuid</span><span class="o">=</span><span class="n">unique_id</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">node_type</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;code.Code.&#39;</span><span class="p">):</span>
                                <span class="n">deserialized_extras</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span><span class="n">value</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span><span class="n">value</span> <span class="ow">in</span> <span class="n">deserialized_extras</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span>
                                        <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;hidden&#39;</span><span class="p">}</span>
                            <span class="c1"># till here</span>
                            <span class="n">models</span><span class="o">.</span><span class="n">DbExtra</span><span class="o">.</span><span class="n">reset_values_for_node</span><span class="p">(</span>
                                <span class="n">dbnode</span><span class="o">=</span><span class="n">new_pk</span><span class="p">,</span>
                                <span class="n">attributes</span><span class="o">=</span><span class="n">deserialized_extras</span><span class="p">,</span>
                                <span class="n">with_transaction</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">extras_mode_new</span> <span class="o">==</span> <span class="s1">&#39;none&#39;</span><span class="p">:</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">silent</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;SKIPPING NEW NODE EXTRAS...&quot;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown extras_mode_new value: </span><span class="si">{}</span><span class="s2">, should be either &#39;import&#39; or &quot;</span>
                                <span class="s2">&quot;&#39;none&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">extras_mode_new</span><span class="p">))</span>

                    <span class="c1"># For the existing DbNodes we may want to choose the import mode</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">silent</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;UPDATING EXISTING NODE EXTRAS (mode: </span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">extras_mode_existing</span><span class="p">))</span>

                    <span class="k">for</span> <span class="n">import_entry_id</span><span class="p">,</span> <span class="n">entry_data</span> <span class="ow">in</span> <span class="n">existing_entries</span><span class="p">[</span><span class="n">model_name</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="n">unique_id</span> <span class="o">=</span> <span class="n">entry_data</span><span class="p">[</span><span class="n">unique_identifier</span><span class="p">]</span>
                        <span class="n">existing_entry_id</span> <span class="o">=</span> <span class="n">foreign_ids_reverse_mappings</span><span class="p">[</span><span class="n">model_name</span><span class="p">][</span><span class="n">unique_id</span><span class="p">]</span>
                        <span class="c1"># Get extras from import file</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">extras</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;node_extras&#39;</span><span class="p">][</span>
                                <span class="nb">str</span><span class="p">(</span><span class="n">import_entry_id</span><span class="p">)]</span>
                            <span class="n">extras_conversion</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span>
                                <span class="s1">&#39;node_extras_conversion&#39;</span><span class="p">][</span>
                                <span class="nb">str</span><span class="p">(</span><span class="n">import_entry_id</span><span class="p">)]</span>
                        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unable to find extras info &quot;</span>
                                             <span class="s2">&quot;for DbNode with UUID = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">unique_id</span><span class="p">))</span>

                        <span class="c1"># Here I have to deserialize the extras</span>
                        <span class="n">old_extras</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">DbExtra</span><span class="o">.</span><span class="n">get_all_values_for_nodepk</span><span class="p">(</span><span class="n">existing_entry_id</span><span class="p">)</span>
                        <span class="n">deserialized_extras</span> <span class="o">=</span> <span class="n">deserialize_attributes</span><span class="p">(</span><span class="n">extras</span><span class="p">,</span> <span class="n">extras_conversion</span><span class="p">)</span>
                        <span class="c1"># TODO: remove when aiida extras will be moved somewhere else</span>
                        <span class="c1"># from here</span>
                        <span class="n">deserialized_extras</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span><span class="n">value</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span><span class="n">value</span> <span class="ow">in</span> <span class="n">deserialized_extras</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span>
                                <span class="n">key</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;_aiida_&#39;</span><span class="p">)}</span>
                        <span class="k">if</span> <span class="n">models</span><span class="o">.</span><span class="n">DbNode</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">uuid</span><span class="o">=</span><span class="n">unique_id</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">node_type</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;code.Code.&#39;</span><span class="p">):</span>
                            <span class="n">deserialized_extras</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span><span class="n">value</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span><span class="n">value</span> <span class="ow">in</span> <span class="n">deserialized_extras</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span>
                                    <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;hidden&#39;</span><span class="p">}</span>
                        <span class="c1"># till here</span>
                        <span class="n">merged_extras</span> <span class="o">=</span> <span class="n">merge_extras</span><span class="p">(</span><span class="n">old_extras</span><span class="p">,</span> <span class="n">deserialized_extras</span><span class="p">,</span> <span class="n">extras_mode_existing</span><span class="p">)</span>

                        <span class="n">models</span><span class="o">.</span><span class="n">DbExtra</span><span class="o">.</span><span class="n">reset_values_for_node</span><span class="p">(</span>
                            <span class="n">dbnode</span><span class="o">=</span><span class="n">existing_entry_id</span><span class="p">,</span>
                            <span class="n">attributes</span><span class="o">=</span><span class="n">merged_extras</span><span class="p">,</span>
                            <span class="n">with_transaction</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">silent</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;STORING NODE LINKS...&quot;</span><span class="p">)</span>
            <span class="c1">## TODO: check that we are not creating input links of an already</span>
            <span class="c1">##       existing node...</span>
            <span class="n">import_links</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;links_uuid&#39;</span><span class="p">]</span>
            <span class="n">links_to_store</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># Needed for fast checks of existing links</span>
            <span class="n">existing_links_raw</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">DbLink</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()</span><span class="o">.</span><span class="n">values_list</span><span class="p">(</span>
                <span class="s1">&#39;input&#39;</span><span class="p">,</span> <span class="s1">&#39;output&#39;</span><span class="p">,</span> <span class="s1">&#39;label&#39;</span><span class="p">,</span> <span class="s1">&#39;type&#39;</span><span class="p">)</span>
            <span class="n">existing_links_labels</span> <span class="o">=</span> <span class="p">{(</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span> <span class="n">l</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">existing_links_raw</span><span class="p">}</span>
            <span class="n">existing_input_links</span> <span class="o">=</span> <span class="p">{(</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">existing_links_raw</span><span class="p">}</span>

            <span class="c1"># ~ print(foreign_ids_reverse_mappings)</span>
            <span class="n">dbnode_reverse_mappings</span> <span class="o">=</span> <span class="n">foreign_ids_reverse_mappings</span><span class="p">[</span><span class="n">NODE_ENTITY_NAME</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="n">import_links</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">in_id</span> <span class="o">=</span> <span class="n">dbnode_reverse_mappings</span><span class="p">[</span><span class="n">link</span><span class="p">[</span><span class="s1">&#39;input&#39;</span><span class="p">]]</span>
                    <span class="n">out_id</span> <span class="o">=</span> <span class="n">dbnode_reverse_mappings</span><span class="p">[</span><span class="n">link</span><span class="p">[</span><span class="s1">&#39;output&#39;</span><span class="p">]]</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">ignore_unknown_nodes</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Trying to create a link with one &quot;</span>
                                         <span class="s2">&quot;or both unknown nodes, stopping &quot;</span>
                                         <span class="s2">&quot;(in_uuid=</span><span class="si">{}</span><span class="s2">, out_uuid=</span><span class="si">{}</span><span class="s2">, &quot;</span>
                                         <span class="s2">&quot;label=</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">link</span><span class="p">[</span><span class="s1">&#39;input&#39;</span><span class="p">],</span>
                                                            <span class="n">link</span><span class="p">[</span><span class="s1">&#39;output&#39;</span><span class="p">],</span>
                                                            <span class="n">link</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]))</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="n">existing_label</span> <span class="o">=</span> <span class="n">existing_links_labels</span><span class="p">[</span><span class="n">in_id</span><span class="p">,</span> <span class="n">out_id</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">existing_label</span> <span class="o">!=</span> <span class="n">link</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Trying to rename an existing link &quot;</span>
                                         <span class="s2">&quot;name, stopping (in=</span><span class="si">{}</span><span class="s2">, out=</span><span class="si">{}</span><span class="s2">, &quot;</span>
                                         <span class="s2">&quot;old_label=</span><span class="si">{}</span><span class="s2">, new_label=</span><span class="si">{}</span><span class="s2">)&quot;</span>
                                         <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">in_id</span><span class="p">,</span> <span class="n">out_id</span><span class="p">,</span> <span class="n">existing_label</span><span class="p">,</span>
                                                 <span class="n">link</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]))</span>
                        <span class="c1"># Do nothing, the link is already in place and has</span>
                        <span class="c1"># the correct name</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="c1"># We try to get the existing input of the link that</span>
                        <span class="c1"># points to &quot;out&quot; and has label link[&#39;label&#39;].</span>
                        <span class="c1"># If there is no existing_input, it means that the</span>
                        <span class="c1"># link doesn&#39;t exist and it has to be created. If</span>
                        <span class="c1"># it exists, then the only case that we can have more</span>
                        <span class="c1"># than one links with the same name entering a node</span>
                        <span class="c1"># is the case of the RETURN links of workflows/</span>
                        <span class="c1"># workchains. If it is not this case, then it is</span>
                        <span class="c1"># an error.</span>
                        <span class="n">existing_input</span> <span class="o">=</span> <span class="n">existing_input_links</span><span class="p">[</span><span class="n">out_id</span><span class="p">,</span>
                                                              <span class="n">link</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]]</span>

                        <span class="k">if</span> <span class="n">link</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">LinkType</span><span class="o">.</span><span class="n">RETURN</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                                <span class="s2">&quot;There exists already an input link to node &quot;</span>
                                <span class="s2">&quot;with UUID </span><span class="si">{}</span><span class="s2"> with label </span><span class="si">{}</span><span class="s2"> but it does not &quot;</span>
                                <span class="s2">&quot;come from the expected input with UUID </span><span class="si">{}</span><span class="s2"> &quot;</span>
                                <span class="s2">&quot;but from a node with UUID </span><span class="si">{}</span><span class="s2">.&quot;</span>
                                    <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">link</span><span class="p">[</span><span class="s1">&#39;output&#39;</span><span class="p">],</span> <span class="n">link</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">],</span>
                                            <span class="n">link</span><span class="p">[</span><span class="s1">&#39;input&#39;</span><span class="p">],</span> <span class="n">existing_input</span><span class="p">))</span>
                    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                        <span class="c1"># New link</span>
                        <span class="n">links_to_store</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">DbLink</span><span class="p">(</span>
                            <span class="n">input_id</span><span class="o">=</span><span class="n">in_id</span><span class="p">,</span> <span class="n">output_id</span><span class="o">=</span><span class="n">out_id</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">link</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">],</span> <span class="nb">type</span><span class="o">=</span><span class="n">LinkType</span><span class="p">(</span><span class="n">link</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
                        <span class="k">if</span> <span class="n">LINK_ENTITY_NAME</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ret_dict</span><span class="p">:</span>
                            <span class="n">ret_dict</span><span class="p">[</span><span class="n">LINK_ENTITY_NAME</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;new&#39;</span><span class="p">:</span> <span class="p">[]}</span>
                        <span class="n">ret_dict</span><span class="p">[</span><span class="n">LINK_ENTITY_NAME</span><span class="p">][</span><span class="s1">&#39;new&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">in_id</span><span class="p">,</span> <span class="n">out_id</span><span class="p">))</span>

            <span class="c1"># Store new links</span>
            <span class="k">if</span> <span class="n">links_to_store</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">silent</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;   (</span><span class="si">{}</span><span class="s2"> new links...)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">links_to_store</span><span class="p">)))</span>

                <span class="n">models</span><span class="o">.</span><span class="n">DbLink</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">bulk_create</span><span class="p">(</span><span class="n">links_to_store</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">silent</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;   (0 new links...)&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">silent</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;STORING GROUP ELEMENTS...&quot;</span><span class="p">)</span>
            <span class="n">import_groups</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;groups_uuid&#39;</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">groupuuid</span><span class="p">,</span> <span class="n">groupnodes</span> <span class="ow">in</span> <span class="n">import_groups</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="c1"># TODO: cache these to avoid too many queries</span>
                <span class="n">group</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">DbGroup</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">uuid</span><span class="o">=</span><span class="n">groupuuid</span><span class="p">)</span>
                <span class="n">nodes_to_store</span> <span class="o">=</span> <span class="p">[</span><span class="n">dbnode_reverse_mappings</span><span class="p">[</span><span class="n">node_uuid</span><span class="p">]</span>
                                  <span class="k">for</span> <span class="n">node_uuid</span> <span class="ow">in</span> <span class="n">groupnodes</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">nodes_to_store</span><span class="p">:</span>
                    <span class="n">group</span><span class="o">.</span><span class="n">dbnodes</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="o">*</span><span class="n">nodes_to_store</span><span class="p">)</span>

            <span class="c1">######################################################</span>
            <span class="c1"># Put everything in a specific group</span>
            <span class="n">dbnode_model_name</span> <span class="o">=</span> <span class="n">NODE_ENTITY_NAME</span>

            <span class="n">existing</span> <span class="o">=</span> <span class="n">existing_entries</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">dbnode_model_name</span><span class="p">,</span> <span class="p">{})</span>
            <span class="n">existing_pk</span> <span class="o">=</span> <span class="p">[</span><span class="n">foreign_ids_reverse_mappings</span><span class="p">[</span>
                               <span class="n">dbnode_model_name</span><span class="p">][</span><span class="n">v</span><span class="p">[</span><span class="s1">&#39;uuid&#39;</span><span class="p">]]</span>
                           <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">itervalues</span><span class="p">(</span><span class="n">existing</span><span class="p">)]</span>
            <span class="n">new</span> <span class="o">=</span> <span class="n">new_entries</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">dbnode_model_name</span><span class="p">,</span> <span class="p">{})</span>
            <span class="n">new_pk</span> <span class="o">=</span> <span class="p">[</span><span class="n">foreign_ids_reverse_mappings</span><span class="p">[</span>
                          <span class="n">dbnode_model_name</span><span class="p">][</span><span class="n">v</span><span class="p">[</span><span class="s1">&#39;uuid&#39;</span><span class="p">]]</span>
                      <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">itervalues</span><span class="p">(</span><span class="n">new</span><span class="p">)]</span>

            <span class="n">pks_for_group</span> <span class="o">=</span> <span class="n">existing_pk</span> <span class="o">+</span> <span class="n">new_pk</span>

            <span class="c1"># So that we do not create empty groups</span>
            <span class="k">if</span> <span class="n">pks_for_group</span><span class="p">:</span>
                <span class="c1"># If user specified a group, import all things in it</span>
                <span class="k">if</span> <span class="n">user_group</span><span class="p">:</span>
                    <span class="n">group</span> <span class="o">=</span> <span class="n">user_group</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Get an unique name for the import group, based on the</span>
                    <span class="c1"># current (local) time</span>
                    <span class="n">basename</span> <span class="o">=</span> <span class="n">timezone</span><span class="o">.</span><span class="n">localtime</span><span class="p">(</span><span class="n">timezone</span><span class="o">.</span><span class="n">now</span><span class="p">())</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span>
                        <span class="s2">&quot;%Y%m</span><span class="si">%d</span><span class="s2">-%H%M%S&quot;</span><span class="p">)</span>
                    <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">created</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">while</span> <span class="ow">not</span> <span class="n">created</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">counter</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">group_label</span> <span class="o">=</span> <span class="n">basename</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">group_label</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">basename</span><span class="p">,</span> <span class="n">counter</span><span class="p">)</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">group</span> <span class="o">=</span> <span class="n">Group</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="n">group_label</span><span class="p">,</span> <span class="n">type_string</span><span class="o">=</span><span class="n">IMPORTGROUP_TYPE</span><span class="p">)</span><span class="o">.</span><span class="n">store</span><span class="p">()</span>
                            <span class="n">created</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">except</span> <span class="p">(</span><span class="n">exceptions</span><span class="o">.</span><span class="n">UniquenessError</span><span class="p">,</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">IntegrityError</span><span class="p">):</span>
                            <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="c1"># Add all the nodes to the new group</span>
                <span class="c1"># TODO: decide if we want to return the group label</span>
                <span class="n">nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">QueryBuilder</span><span class="p">()</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Node</span><span class="p">,</span> <span class="n">filters</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;id&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="n">pks_for_group</span><span class="p">}})</span><span class="o">.</span><span class="n">all</span><span class="p">()]</span>
                <span class="n">group</span><span class="o">.</span><span class="n">add_nodes</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">silent</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;IMPORTED NODES GROUPED IN IMPORT GROUP NAMED &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">group</span><span class="o">.</span><span class="n">label</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">silent</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;NO DBNODES TO IMPORT, SO NO GROUP CREATED&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">silent</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;*** WARNING: MISSING EXISTING UUID CHECKS!!&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;*** WARNING: TODO: UPDATE IMPORT_DATA WITH DEFAULT VALUES! (e.g. calc status, user pwd, ...)&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;DONE.&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ret_dict</span></div>


<div class="viewcode-block" id="validate_uuid"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.importexport.validate_uuid">[docs]</a><span class="k">def</span> <span class="nf">validate_uuid</span><span class="p">(</span><span class="n">given_uuid</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A simple check for the UUID validity.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">uuid</span> <span class="k">import</span> <span class="n">UUID</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">parsed_uuid</span> <span class="o">=</span> <span class="n">UUID</span><span class="p">(</span><span class="n">given_uuid</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="c1"># If not a valid UUID</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="c1"># Check if there was any kind of conversion of the hex during</span>
    <span class="c1"># the validation</span>
    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">parsed_uuid</span><span class="p">)</span> <span class="o">==</span> <span class="n">given_uuid</span></div>


<div class="viewcode-block" id="import_data_sqla"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.importexport.import_data_sqla">[docs]</a><span class="k">def</span> <span class="nf">import_data_sqla</span><span class="p">(</span><span class="n">in_path</span><span class="p">,</span> <span class="n">user_group</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ignore_unknown_nodes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">extras_mode_existing</span><span class="o">=</span><span class="s1">&#39;kcl&#39;</span><span class="p">,</span> <span class="n">extras_mode_new</span><span class="o">=</span><span class="s1">&#39;import&#39;</span><span class="p">,</span>
        <span class="n">comment_mode</span><span class="o">=</span><span class="s1">&#39;newest&#39;</span><span class="p">,</span> <span class="n">silent</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Import exported AiiDA environment to the AiiDA database.</span>
<span class="sd">    If the &#39;in_path&#39; is a folder, calls extract_tree; otherwise, tries to</span>
<span class="sd">    detect the compression format (zip, tar.gz, tar.bz2, ...) and calls the</span>
<span class="sd">    correct function.</span>
<span class="sd">    :param in_path: the path to a file or folder that can be imported in AiiDA</span>
<span class="sd">    :param extras_mode_existing: 3 letter code that will identify what to do with the extras import.</span>
<span class="sd">    The first letter acts on extras that are present in the original node and not present in the imported node.</span>
<span class="sd">    Can be either:</span>
<span class="sd">    &#39;k&#39; (keep it) or</span>
<span class="sd">    &#39;n&#39; (do not keep it).</span>
<span class="sd">    The second letter acts on the imported extras that are not present in the original node.</span>
<span class="sd">    Can be either:</span>
<span class="sd">    &#39;c&#39; (create it) or</span>
<span class="sd">    &#39;n&#39; (do not create it).</span>
<span class="sd">    The third letter defines what to do in case of a name collision.</span>
<span class="sd">    Can be either:</span>
<span class="sd">    &#39;l&#39; (leave the old value),</span>
<span class="sd">    &#39;u&#39; (update with a new value),</span>
<span class="sd">    &#39;d&#39; (delete the extra), or</span>
<span class="sd">    &#39;a&#39; (ask what to do if the content is different).</span>
<span class="sd">    :param extras_mode_new: &#39;import&#39; to import extras of new nodes or &#39;none&#39; to ignore them</span>
<span class="sd">    :param comment_mode: Comment import modes (when same UUIDs are found):</span>
<span class="sd">    &#39;newest&#39;: Will keep the Comment with the most recent modification time (mtime)</span>
<span class="sd">    &#39;overwrite&#39;: Will overwrite existing Comments with the ones from the import file</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">os</span>
    <span class="kn">import</span> <span class="nn">tarfile</span>
    <span class="kn">import</span> <span class="nn">zipfile</span>
    <span class="kn">from</span> <span class="nn">itertools</span> <span class="k">import</span> <span class="n">chain</span>

    <span class="kn">from</span> <span class="nn">aiida.common</span> <span class="k">import</span> <span class="n">timezone</span>

    <span class="kn">from</span> <span class="nn">aiida.backends.sqlalchemy.models.node</span> <span class="k">import</span> <span class="n">DbNode</span>
    <span class="kn">from</span> <span class="nn">aiida.backends.sqlalchemy.utils</span> <span class="k">import</span> <span class="n">flag_modified</span>
    <span class="kn">from</span> <span class="nn">aiida.common.archive</span> <span class="k">import</span> <span class="n">extract_tree</span><span class="p">,</span> <span class="n">extract_tar</span><span class="p">,</span> <span class="n">extract_zip</span>
    <span class="kn">from</span> <span class="nn">aiida.common.folders</span> <span class="k">import</span> <span class="n">SandboxFolder</span><span class="p">,</span> <span class="n">RepositoryFolder</span>
    <span class="kn">from</span> <span class="nn">aiida.common.utils</span> <span class="k">import</span> <span class="n">get_object_from_string</span>
    <span class="kn">from</span> <span class="nn">aiida.common.links</span> <span class="k">import</span> <span class="n">LinkType</span>
    <span class="kn">from</span> <span class="nn">aiida.common</span> <span class="k">import</span> <span class="n">json</span>

    <span class="c1"># This is the export version expected by this function</span>
    <span class="n">expected_export_version</span> <span class="o">=</span> <span class="n">StrictVersion</span><span class="p">(</span><span class="s1">&#39;0.4&#39;</span><span class="p">)</span>

    <span class="c1"># The name of the subfolder in which the node files are stored</span>
    <span class="n">nodes_export_subfolder</span> <span class="o">=</span> <span class="s1">&#39;nodes&#39;</span>

    <span class="c1"># The returned dictionary with new and existing nodes and links</span>
    <span class="n">ret_dict</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1">################</span>
    <span class="c1"># EXTRACT DATA #</span>
    <span class="c1">################</span>
    <span class="c1"># The sandbox has to remain open until the end</span>
    <span class="k">with</span> <span class="n">SandboxFolder</span><span class="p">()</span> <span class="k">as</span> <span class="n">folder</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">in_path</span><span class="p">):</span>
            <span class="n">extract_tree</span><span class="p">(</span><span class="n">in_path</span><span class="p">,</span> <span class="n">folder</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">tarfile</span><span class="o">.</span><span class="n">is_tarfile</span><span class="p">(</span><span class="n">in_path</span><span class="p">):</span>
                <span class="n">extract_tar</span><span class="p">(</span><span class="n">in_path</span><span class="p">,</span> <span class="n">folder</span><span class="p">,</span> <span class="n">silent</span><span class="o">=</span><span class="n">silent</span><span class="p">,</span>
                            <span class="n">nodes_export_subfolder</span><span class="o">=</span><span class="n">nodes_export_subfolder</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">zipfile</span><span class="o">.</span><span class="n">is_zipfile</span><span class="p">(</span><span class="n">in_path</span><span class="p">):</span>
                <span class="n">extract_zip</span><span class="p">(</span><span class="n">in_path</span><span class="p">,</span> <span class="n">folder</span><span class="p">,</span> <span class="n">silent</span><span class="o">=</span><span class="n">silent</span><span class="p">,</span>
                            <span class="n">nodes_export_subfolder</span><span class="o">=</span><span class="n">nodes_export_subfolder</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unable to detect the input file format, it &quot;</span>
                                 <span class="s2">&quot;is neither a (possibly compressed) tar &quot;</span>
                                 <span class="s2">&quot;file, nor a zip file.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">folder</span><span class="o">.</span><span class="n">get_content_list</span><span class="p">():</span>
            <span class="kn">from</span> <span class="nn">aiida.common.exceptions</span> <span class="k">import</span> <span class="n">ContentNotExistent</span>
            <span class="k">raise</span> <span class="n">ContentNotExistent</span><span class="p">(</span><span class="s2">&quot;The provided file/folder (</span><span class="si">{}</span><span class="s2">) is empty&quot;</span>
                                     <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">in_path</span><span class="p">))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">io</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">folder</span><span class="o">.</span><span class="n">get_abs_path</span><span class="p">(</span><span class="s1">&#39;metadata.json&#39;</span><span class="p">),</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;utf8&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fhandle</span><span class="p">:</span>
                <span class="n">metadata</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fhandle</span><span class="p">)</span>

            <span class="k">with</span> <span class="n">io</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">folder</span><span class="o">.</span><span class="n">get_abs_path</span><span class="p">(</span><span class="s1">&#39;data.json&#39;</span><span class="p">),</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;utf8&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fhandle</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fhandle</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">IOError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unable to find the file </span><span class="si">{}</span><span class="s2"> in the import &quot;</span>
                             <span class="s2">&quot;file or folder&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">filename</span><span class="p">))</span>

        <span class="c1">######################</span>
        <span class="c1"># PRELIMINARY CHECKS #</span>
        <span class="c1">######################</span>
        <span class="n">export_version</span> <span class="o">=</span> <span class="n">StrictVersion</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;export_version&#39;</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">export_version</span> <span class="o">!=</span> <span class="n">expected_export_version</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Export file version is </span><span class="si">{}</span><span class="s2">, can import only version </span><span class="si">{}</span><span class="s2">&quot;</span>\
                    <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;export_version&#39;</span><span class="p">],</span> <span class="n">expected_export_version</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">export_version</span> <span class="o">&lt;</span> <span class="n">expected_export_version</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Use &#39;verdi export migrate&#39; to update this export file.&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Update your AiiDA version in order to import this file.&quot;</span>

            <span class="k">raise</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">IncompatibleArchiveVersionError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c1">###################################################################</span>
        <span class="c1">#           CREATE UUID REVERSE TABLES AND CHECK IF               #</span>
        <span class="c1">#              I HAVE ALL NODES FOR THE LINKS                     #</span>
        <span class="c1">###################################################################</span>
        <span class="n">linked_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">((</span><span class="n">l</span><span class="p">[</span><span class="s1">&#39;input&#39;</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="s1">&#39;output&#39;</span><span class="p">])</span>
                                               <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;links_uuid&#39;</span><span class="p">]))</span>
        <span class="n">group_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span>
            <span class="n">six</span><span class="o">.</span><span class="n">itervalues</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;groups_uuid&#39;</span><span class="p">])))</span>

        <span class="c1"># Check that UUIDs are valid</span>
        <span class="n">linked_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">linked_nodes</span> <span class="k">if</span> <span class="n">validate_uuid</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="n">group_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">group_nodes</span> <span class="k">if</span> <span class="n">validate_uuid</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

        <span class="c1"># I preload the nodes, I need to check each of them later, and I also</span>
        <span class="c1"># store them in a reverse table</span>
        <span class="c1"># I break up the query due to SQLite limitations..</span>
        <span class="c1"># relevant_db_nodes = {}</span>
        <span class="n">db_nodes_uuid</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">import_nodes_uuid</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">linked_nodes</span><span class="p">:</span>
            <span class="n">qb</span> <span class="o">=</span> <span class="n">QueryBuilder</span><span class="p">()</span>
            <span class="n">qb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Node</span><span class="p">,</span> <span class="n">filters</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;uuid&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;in&quot;</span><span class="p">:</span> <span class="n">linked_nodes</span><span class="p">}},</span>
                      <span class="n">project</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;uuid&quot;</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="n">qb</span><span class="o">.</span><span class="n">iterall</span><span class="p">():</span>
                <span class="n">db_nodes_uuid</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">NODE_ENTITY_NAME</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;export_data&#39;</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;export_data&#39;</span><span class="p">][</span><span class="n">NODE_ENTITY_NAME</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="n">import_nodes_uuid</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="s1">&#39;uuid&#39;</span><span class="p">])</span>

        <span class="n">unknown_nodes</span> <span class="o">=</span> <span class="n">linked_nodes</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">group_nodes</span><span class="p">)</span> <span class="o">-</span> <span class="n">db_nodes_uuid</span><span class="o">.</span><span class="n">union</span><span class="p">(</span>
            <span class="n">import_nodes_uuid</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">unknown_nodes</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">ignore_unknown_nodes</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The import file refers to </span><span class="si">{}</span><span class="s2"> nodes with unknown UUID, &quot;</span>
                <span class="s2">&quot;therefore it cannot be imported. Either first import the &quot;</span>
                <span class="s2">&quot;unknown nodes, or export also the parents when exporting. &quot;</span>
                <span class="s2">&quot;The unknown UUIDs are:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">unknown_nodes</span><span class="p">))</span> <span class="o">+</span>
                <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;* </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">uuid</span><span class="p">)</span> <span class="k">for</span> <span class="n">uuid</span> <span class="ow">in</span> <span class="n">unknown_nodes</span><span class="p">))</span>

        <span class="c1">###################################</span>
        <span class="c1"># DOUBLE-CHECK MODEL DEPENDENCIES #</span>
        <span class="c1">###################################</span>
        <span class="c1"># The entity import order. It is defined by the database model</span>
        <span class="c1"># relationships.</span>
        <span class="c1"># It is a list of strings, e.g.:</span>
        <span class="c1"># [&#39;aiida.backends.djsite.db.models.DbUser&#39;, &#39;aiida.backends.djsite.db.models.DbComputer&#39;, &#39;aiida.backends.djsite.db.models.DbNode&#39;, &#39;aiida.backends.djsite.db.models.DbGroup&#39;]</span>
        <span class="n">entity_sig_order</span> <span class="o">=</span> <span class="p">[</span><span class="n">entity_names_to_signatures</span><span class="p">[</span><span class="n">m</span><span class="p">]</span>
                            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="p">(</span><span class="n">USER_ENTITY_NAME</span><span class="p">,</span> <span class="n">COMPUTER_ENTITY_NAME</span><span class="p">,</span>
                                      <span class="n">NODE_ENTITY_NAME</span><span class="p">,</span> <span class="n">GROUP_ENTITY_NAME</span><span class="p">,</span>
                                      <span class="n">LOG_ENTITY_NAME</span><span class="p">,</span> <span class="n">COMMENT_ENTITY_NAME</span><span class="p">)]</span>
        <span class="c1"># &quot;Entities&quot; that do appear in the import file, but whose import is</span>
        <span class="c1"># managed manually</span>
        <span class="n">entity_sig_manual</span> <span class="o">=</span> <span class="p">[</span><span class="n">entity_names_to_signatures</span><span class="p">[</span><span class="n">m</span><span class="p">]</span>
                         <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="p">(</span><span class="n">LINK_ENTITY_NAME</span><span class="p">,</span> <span class="n">ATTRIBUTE_ENTITY_NAME</span><span class="p">)]</span>

        <span class="n">all_known_entity_sigs</span> <span class="o">=</span> <span class="n">entity_sig_order</span> <span class="o">+</span> <span class="n">entity_sig_manual</span>

        <span class="c1">#  I make a new list that contains the entity names:</span>
        <span class="c1"># eg: [&#39;User&#39;, &#39;Computer&#39;, &#39;Node&#39;, &#39;Group&#39;, &#39;Link&#39;, &#39;Attribute&#39;]</span>
        <span class="n">all_entity_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">signatures_to_entity_names</span><span class="p">[</span><span class="n">entity_sig</span><span class="p">]</span> <span class="k">for</span> <span class="n">entity_sig</span> <span class="ow">in</span> <span class="n">all_known_entity_sigs</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">import_field_name</span> <span class="ow">in</span> <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;all_fields_info&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">import_field_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">all_entity_names</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Apparently, you are importing a &quot;</span>
                                          <span class="s2">&quot;file with a model &#39;</span><span class="si">{}</span><span class="s2">&#39;, but this &quot;</span>
                                          <span class="s2">&quot;does not appear in &quot;</span>
                                          <span class="s2">&quot;all_known_models!&quot;</span>
                                          <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">import_field_name</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">entity_sig</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">entity_sig_order</span><span class="p">):</span>
            <span class="n">dependencies</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">entity_name</span> <span class="o">=</span> <span class="n">signatures_to_entity_names</span><span class="p">[</span><span class="n">entity_sig</span><span class="p">]</span>
            <span class="c1"># for every field, I checked the dependencies given as value for key requires</span>
            <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;all_fields_info&#39;</span><span class="p">][</span><span class="n">entity_name</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">dependencies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="s1">&#39;requires&#39;</span><span class="p">])</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="c1"># (No ForeignKey)</span>
                    <span class="k">pass</span>
            <span class="k">for</span> <span class="n">dependency</span> <span class="ow">in</span> <span class="n">dependencies</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">dependency</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">all_entity_names</span><span class="p">[:</span><span class="n">idx</span><span class="p">]:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Entity </span><span class="si">{}</span><span class="s2"> requires </span><span class="si">{}</span><span class="s2"> but would be &quot;</span>
                                     <span class="s2">&quot;loaded first; stopping...&quot;</span>
                                     <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">entity_sig</span><span class="p">,</span> <span class="n">dependency</span><span class="p">))</span>

        <span class="c1">###################################################</span>
        <span class="c1"># CREATE IMPORT DATA DIRECT UNIQUE_FIELD MAPPINGS #</span>
        <span class="c1">###################################################</span>
        <span class="c1"># This is nested dictionary of entity_name:{id:uuid}</span>
        <span class="c1"># to map one id (the pk) to a different one.</span>
        <span class="c1"># One of the things to remove for v0.4</span>
        <span class="c1"># {</span>
        <span class="c1"># u&#39;Node&#39;: {2362: u&#39;82a897b5-fb3a-47d7-8b22-c5fe1b4f2c14&#39;, 2363: u&#39;ef04aa5d-99e7-4bfd-95ef-fe412a6a3524&#39;, 2364: u&#39;1dc59576-af21-4d71-81c2-bac1fc82a84a&#39;},</span>
        <span class="c1"># u&#39;User&#39;: {1: u&#39;aiida@localhost&#39;}</span>
        <span class="c1"># }</span>
        <span class="n">import_unique_ids_mappings</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># Export data since v0.3 contains the keys entity_name</span>
        <span class="k">for</span> <span class="n">entity_name</span><span class="p">,</span> <span class="n">import_data</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;export_data&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Again I need the entity_name since that&#39;s what&#39;s being stored since 0.3</span>
            <span class="k">if</span> <span class="n">entity_name</span> <span class="ow">in</span> <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;unique_identifiers&#39;</span><span class="p">]:</span>
                <span class="c1"># I have to reconvert the pk to integer</span>
                <span class="n">import_unique_ids_mappings</span><span class="p">[</span><span class="n">entity_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="nb">int</span><span class="p">(</span><span class="n">k</span><span class="p">):</span> <span class="n">v</span><span class="p">[</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;unique_identifiers&#39;</span><span class="p">][</span><span class="n">entity_name</span><span class="p">]]</span>
                    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">import_data</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="c1">###############</span>
        <span class="c1"># IMPORT DATA #</span>
        <span class="c1">###############</span>
        <span class="c1"># DO ALL WITH A TRANSACTION</span>
        <span class="kn">import</span> <span class="nn">aiida.backends.sqlalchemy</span>

        <span class="n">session</span> <span class="o">=</span> <span class="n">aiida</span><span class="o">.</span><span class="n">backends</span><span class="o">.</span><span class="n">sqlalchemy</span><span class="o">.</span><span class="n">get_scoped_session</span><span class="p">()</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">foreign_ids_reverse_mappings</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">new_entries</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">existing_entries</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="c1"># I first generate the list of data</span>
            <span class="k">for</span> <span class="n">entity_sig</span> <span class="ow">in</span> <span class="n">entity_sig_order</span><span class="p">:</span>
                <span class="n">entity_name</span> <span class="o">=</span> <span class="n">signatures_to_entity_names</span><span class="p">[</span><span class="n">entity_sig</span><span class="p">]</span>
                <span class="n">entity</span> <span class="o">=</span> <span class="n">entity_names_to_entities</span><span class="p">[</span><span class="n">entity_name</span><span class="p">]</span>
                <span class="c1"># I get the unique identifier, since v0.3 stored under entity_name</span>
                <span class="n">unique_identifier</span> <span class="o">=</span> <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;unique_identifiers&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">entity_name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

                <span class="c1"># so, new_entries. Also, since v0.3 it makes more sense to use the entity_name</span>
                <span class="c1">#~ new_entries[entity_sig] = {}</span>
                <span class="n">new_entries</span><span class="p">[</span><span class="n">entity_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="c1"># existing_entries[entity_sig] = {}</span>
                <span class="n">existing_entries</span><span class="p">[</span><span class="n">entity_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="c1"># ~ foreign_ids_reverse_mappings[entity_sig] = {}</span>
                <span class="n">foreign_ids_reverse_mappings</span><span class="p">[</span><span class="n">entity_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

                <span class="c1"># Not necessarily all models are exported</span>
                <span class="k">if</span> <span class="n">entity_name</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;export_data&#39;</span><span class="p">]:</span>

                    <span class="k">if</span> <span class="n">unique_identifier</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">import_unique_ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">unique_identifier</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;export_data&#39;</span><span class="p">][</span><span class="n">entity_name</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

                        <span class="n">relevant_db_entries</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">import_unique_ids</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">qb</span> <span class="o">=</span> <span class="n">QueryBuilder</span><span class="p">()</span>
                            <span class="n">qb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entity</span><span class="p">,</span> <span class="n">filters</span><span class="o">=</span><span class="p">{</span>
                                <span class="n">unique_identifier</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;in&quot;</span><span class="p">:</span> <span class="n">import_unique_ids</span><span class="p">}},</span>
                                      <span class="n">project</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;*&quot;</span><span class="p">],</span> <span class="n">tag</span><span class="o">=</span><span class="s2">&quot;res&quot;</span><span class="p">)</span>
                            <span class="n">relevant_db_entries</span> <span class="o">=</span> <span class="p">{</span>
                                <span class="nb">str</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">unique_identifier</span><span class="p">)):</span>  <span class="c1"># str() to convert UUID() to string</span>
                                    <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">qb</span><span class="o">.</span><span class="n">all</span><span class="p">()}</span>

                            <span class="n">foreign_ids_reverse_mappings</span><span class="p">[</span><span class="n">entity_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                                <span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="o">.</span><span class="n">pk</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span>
                                <span class="n">relevant_db_entries</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

                        <span class="n">imported_comp_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
                        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;export_data&#39;</span><span class="p">][</span><span class="n">entity_name</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                            <span class="k">if</span> <span class="n">entity_name</span> <span class="o">==</span> <span class="n">GROUP_ENTITY_NAME</span><span class="p">:</span>
                                <span class="c1"># Check if there is already a group with the same name,</span>
                                <span class="c1"># and if so, recreate the name</span>
                                <span class="n">orig_label</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">]</span>
                                <span class="n">dupl_counter</span> <span class="o">=</span> <span class="mi">0</span>
                                <span class="k">while</span> <span class="n">QueryBuilder</span><span class="p">()</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entity</span><span class="p">,</span>
                                            <span class="n">filters</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;==&quot;</span><span class="p">:</span> <span class="n">v</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">]}})</span><span class="o">.</span><span class="n">count</span><span class="p">():</span>
                                    <span class="c1"># Rename the new group</span>
                                    <span class="n">v</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">orig_label</span> <span class="o">+</span> <span class="n">DUPL_SUFFIX</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dupl_counter</span><span class="p">)</span>
                                    <span class="n">dupl_counter</span> <span class="o">+=</span> <span class="mi">1</span>
                                    <span class="k">if</span> <span class="n">dupl_counter</span> <span class="o">==</span> <span class="mi">100</span><span class="p">:</span>
                                        <span class="k">raise</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">UniquenessError</span><span class="p">(</span><span class="s2">&quot;A group of that label ( </span><span class="si">{}</span><span class="s2"> )&quot;</span>
                                                <span class="s2">&quot;  already exists and I could not create a new one&quot;</span>
                                                <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">orig_label</span><span class="p">))</span>


                            <span class="k">elif</span> <span class="n">entity_name</span> <span class="o">==</span> <span class="n">COMPUTER_ENTITY_NAME</span><span class="p">:</span>
                                <span class="c1"># The following is done for compatibility</span>
                                <span class="c1"># reasons in case the export file was generated</span>
                                <span class="c1"># with the Django export method. In Django the</span>
                                <span class="c1"># metadata and the transport parameters are</span>
                                <span class="c1"># stored as (unicode) strings of the serialized</span>
                                <span class="c1"># JSON objects and not as simple serialized</span>
                                <span class="c1"># JSON objects.</span>
                                <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="s1">&#39;metadata&#39;</span><span class="p">],</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">)</span> <span class="ow">or</span>
                                        <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="s1">&#39;metadata&#39;</span><span class="p">],</span> <span class="n">six</span><span class="o">.</span><span class="n">binary_type</span><span class="p">)):</span>
                                    <span class="n">v</span><span class="p">[</span><span class="s1">&#39;metadata&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="s1">&#39;metadata&#39;</span><span class="p">])</span>  <span class="c1"># loads() can handle str and unicode/bytes</span>

                                <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="s1">&#39;transport_params&#39;</span><span class="p">],</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">)</span> <span class="ow">or</span>
                                        <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="s1">&#39;transport_params&#39;</span><span class="p">],</span> <span class="n">six</span><span class="o">.</span><span class="n">binary_type</span><span class="p">)):</span>
                                    <span class="n">v</span><span class="p">[</span><span class="s1">&#39;transport_params&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="s1">&#39;transport_params&#39;</span><span class="p">])</span>

                                <span class="c1"># Check if there is already a computer with the</span>
                                <span class="c1"># same name in the database</span>
                                <span class="n">qb</span> <span class="o">=</span> <span class="n">QueryBuilder</span><span class="p">()</span>
                                <span class="n">qb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entity</span><span class="p">,</span>
                                          <span class="n">filters</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;==&quot;</span><span class="p">:</span> <span class="n">v</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]}},</span>
                                          <span class="n">project</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;*&quot;</span><span class="p">],</span> <span class="n">tag</span><span class="o">=</span><span class="s2">&quot;res&quot;</span><span class="p">)</span>
                                <span class="n">dupl</span> <span class="o">=</span> <span class="p">(</span><span class="n">qb</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
                                        <span class="ow">or</span> <span class="n">v</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">imported_comp_names</span><span class="p">)</span>
                                <span class="n">dupl_counter</span> <span class="o">=</span> <span class="mi">0</span>
                                <span class="n">orig_name</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span>
                                <span class="k">while</span> <span class="n">dupl</span><span class="p">:</span>
                                    <span class="c1"># Rename the new computer</span>
                                    <span class="n">v</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                                            <span class="n">orig_name</span> <span class="o">+</span>
                                            <span class="n">DUPL_SUFFIX</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                                <span class="n">dupl_counter</span><span class="p">))</span>
                                    <span class="n">dupl_counter</span> <span class="o">+=</span> <span class="mi">1</span>
                                    <span class="n">qb</span> <span class="o">=</span> <span class="n">QueryBuilder</span><span class="p">()</span>
                                    <span class="n">qb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entity</span><span class="p">,</span>
                                              <span class="n">filters</span><span class="o">=</span><span class="p">{</span>
                                                  <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;==&quot;</span><span class="p">:</span> <span class="n">v</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]}},</span>
                                              <span class="n">project</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;*&quot;</span><span class="p">],</span> <span class="n">tag</span><span class="o">=</span><span class="s2">&quot;res&quot;</span><span class="p">)</span>
                                    <span class="n">dupl</span> <span class="o">=</span> <span class="p">(</span><span class="n">qb</span><span class="o">.</span><span class="n">count</span><span class="p">()</span> <span class="ow">or</span>
                                            <span class="n">v</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">imported_comp_names</span><span class="p">)</span>

                                <span class="n">imported_comp_names</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">])</span>

                            <span class="k">if</span> <span class="n">v</span><span class="p">[</span><span class="n">unique_identifier</span><span class="p">]</span> <span class="ow">in</span> <span class="n">relevant_db_entries</span><span class="p">:</span>
                                <span class="c1"># Already in DB</span>
                                <span class="c1"># again, switched to entity_name in v0.3</span>
                                <span class="n">existing_entries</span><span class="p">[</span><span class="n">entity_name</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="c1"># To be added</span>
                                <span class="n">new_entries</span><span class="p">[</span><span class="n">entity_name</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Why the copy:</span>
                        <span class="n">new_entries</span><span class="p">[</span><span class="n">entity_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;export_data&#39;</span><span class="p">][</span><span class="n">entity_name</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="c1"># Show Comment mode if not silent and Comments exist in existing_entries</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">silent</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">COMMENT_ENTITY_NAME</span> <span class="ow">in</span> <span class="n">existing_entries</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Comment mode: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">comment_mode</span><span class="p">))</span>

            <span class="c1"># I import data from the given model</span>
            <span class="k">for</span> <span class="n">entity_sig</span> <span class="ow">in</span> <span class="n">entity_sig_order</span><span class="p">:</span>
                <span class="n">entity_name</span> <span class="o">=</span> <span class="n">signatures_to_entity_names</span><span class="p">[</span><span class="n">entity_sig</span><span class="p">]</span>
                <span class="n">entity</span> <span class="o">=</span> <span class="n">entity_names_to_entities</span><span class="p">[</span><span class="n">entity_name</span><span class="p">]</span>
                <span class="n">fields_info</span> <span class="o">=</span> <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;all_fields_info&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">entity_name</span><span class="p">,</span> <span class="p">{})</span>
                <span class="n">unique_identifier</span> <span class="o">=</span> <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;unique_identifiers&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">entity_name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">import_entry_id</span><span class="p">,</span> <span class="n">entry_data</span> <span class="ow">in</span> <span class="n">existing_entries</span><span class="p">[</span><span class="n">entity_name</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">unique_id</span> <span class="o">=</span> <span class="n">entry_data</span><span class="p">[</span><span class="n">unique_identifier</span><span class="p">]</span>
                    <span class="n">existing_entry_id</span> <span class="o">=</span> <span class="n">foreign_ids_reverse_mappings</span><span class="p">[</span><span class="n">entity_name</span><span class="p">][</span><span class="n">unique_id</span><span class="p">]</span>
                    <span class="n">import_data</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">deserialize_field</span><span class="p">(</span>
                        <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">fields_info</span><span class="o">=</span><span class="n">fields_info</span><span class="p">,</span>
                        <span class="n">import_unique_ids_mappings</span><span class="o">=</span><span class="n">import_unique_ids_mappings</span><span class="p">,</span>
                        <span class="n">foreign_ids_reverse_mappings</span><span class="o">=</span><span class="n">foreign_ids_reverse_mappings</span><span class="p">)</span>
                                       <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">entry_data</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
                    <span class="c1"># TODO COMPARE, AND COMPARE ATTRIBUTES</span>

                    <span class="k">if</span> <span class="n">entity_sig</span> <span class="ow">is</span> <span class="n">entity_names_to_signatures</span><span class="p">[</span><span class="n">COMMENT_ENTITY_NAME</span><span class="p">]:</span>
                        <span class="n">new_entry_uuid</span> <span class="o">=</span> <span class="n">_merge_comment</span><span class="p">(</span><span class="n">import_data</span><span class="p">,</span> <span class="n">comment_mode</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">new_entry_uuid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">entry_data</span><span class="p">[</span><span class="n">unique_identifier</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_entry_uuid</span>
                            <span class="n">new_entries</span><span class="p">[</span><span class="n">entity_name</span><span class="p">][</span><span class="n">import_entry_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">entry_data</span>

                    <span class="k">if</span> <span class="n">entity_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ret_dict</span><span class="p">:</span>
                        <span class="n">ret_dict</span><span class="p">[</span><span class="n">entity_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;new&#39;</span><span class="p">:</span> <span class="p">[],</span> <span class="s1">&#39;existing&#39;</span><span class="p">:</span> <span class="p">[]}</span>
                    <span class="n">ret_dict</span><span class="p">[</span><span class="n">entity_name</span><span class="p">][</span><span class="s1">&#39;existing&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">import_entry_id</span><span class="p">,</span> <span class="n">existing_entry_id</span><span class="p">))</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">silent</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;existing </span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2"> (</span><span class="si">%s</span><span class="s2">-&gt;</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">entity_sig</span><span class="p">,</span>
                                                            <span class="n">unique_id</span><span class="p">,</span>
                                                            <span class="n">import_entry_id</span><span class="p">,</span>
                                                            <span class="n">existing_entry_id</span><span class="p">))</span>

                <span class="c1"># Store all objects for this model in a list, and store them</span>
                <span class="c1"># all in once at the end.</span>
                <span class="n">objects_to_create</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
                <span class="c1"># This is needed later to associate the import entry with the new pk</span>
                <span class="n">import_entry_ids</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

                <span class="k">for</span> <span class="n">import_entry_id</span><span class="p">,</span> <span class="n">entry_data</span> <span class="ow">in</span> <span class="n">new_entries</span><span class="p">[</span><span class="n">entity_name</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">unique_id</span> <span class="o">=</span> <span class="n">entry_data</span><span class="p">[</span><span class="n">unique_identifier</span><span class="p">]</span>
                    <span class="n">import_data</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">deserialize_field</span><span class="p">(</span>
                        <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">fields_info</span><span class="o">=</span><span class="n">fields_info</span><span class="p">,</span>
                        <span class="n">import_unique_ids_mappings</span><span class="o">=</span><span class="n">import_unique_ids_mappings</span><span class="p">,</span>
                        <span class="n">foreign_ids_reverse_mappings</span><span class="o">=</span><span class="n">foreign_ids_reverse_mappings</span><span class="p">)</span>
                                       <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">entry_data</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>

                    <span class="c1"># We convert the Django fields to SQLA. Note that some of</span>
                    <span class="c1"># the Django fields were converted to SQLA compatible</span>
                    <span class="c1"># fields by the deserialize_field method. This was done</span>
                    <span class="c1"># for optimization reasons in Django but makes them</span>
                    <span class="c1"># compatible with the SQLA schema and they don&#39;t need any</span>
                    <span class="c1"># further conversion.</span>
                    <span class="k">if</span> <span class="n">entity_name</span> <span class="ow">in</span> <span class="n">file_fields_to_model_fields</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">file_fkey</span> <span class="ow">in</span> <span class="n">file_fields_to_model_fields</span><span class="p">[</span><span class="n">entity_name</span><span class="p">]:</span>

                            <span class="c1"># This is an exception because the DbLog model defines the `_metadata` column instead of the</span>
                            <span class="c1"># `metadata` column used in the Django model. This is because the SqlAlchemy model base</span>
                            <span class="c1"># class already has a metadata attribute that cannot be overridden. For consistency, the</span>
                            <span class="c1"># `DbLog` class however expects the `metadata` keyword in its constructor, so we should</span>
                            <span class="c1"># ignore the mapping here</span>
                            <span class="k">if</span> <span class="n">entity_name</span> <span class="o">==</span> <span class="n">LOG_ENTITY_NAME</span> <span class="ow">and</span> <span class="n">file_fkey</span> <span class="o">==</span> <span class="s1">&#39;metadata&#39;</span><span class="p">:</span>
                                <span class="k">continue</span>

                            <span class="n">model_fkey</span> <span class="o">=</span> <span class="n">file_fields_to_model_fields</span><span class="p">[</span><span class="n">entity_name</span><span class="p">][</span><span class="n">file_fkey</span><span class="p">]</span>
                            <span class="k">if</span> <span class="n">model_fkey</span> <span class="ow">in</span> <span class="n">import_data</span><span class="p">:</span>
                                <span class="k">continue</span>
                            <span class="n">import_data</span><span class="p">[</span><span class="n">model_fkey</span><span class="p">]</span> <span class="o">=</span> <span class="n">import_data</span><span class="p">[</span><span class="n">file_fkey</span><span class="p">]</span>
                            <span class="n">import_data</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">file_fkey</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

                    <span class="n">db_entity</span> <span class="o">=</span> <span class="n">get_object_from_string</span><span class="p">(</span>
                        <span class="n">entity_names_to_sqla_schema</span><span class="p">[</span><span class="n">entity_name</span><span class="p">])</span>

                    <span class="n">objects_to_create</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">db_entity</span><span class="p">(</span><span class="o">**</span><span class="n">import_data</span><span class="p">))</span>
                    <span class="n">import_entry_ids</span><span class="p">[</span><span class="n">unique_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">import_entry_id</span>

                <span class="c1"># Before storing entries in the DB, I store the files (if these</span>
                <span class="c1"># are nodes). Note: only for new entries!</span>
                <span class="k">if</span> <span class="n">entity_sig</span> <span class="o">==</span> <span class="n">entity_names_to_signatures</span><span class="p">[</span><span class="n">NODE_ENTITY_NAME</span><span class="p">]:</span>

                    <span class="k">if</span> <span class="ow">not</span> <span class="n">silent</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;STORING NEW NODE FILES &amp; ATTRIBUTES...&quot;</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">objects_to_create</span><span class="p">:</span>

                        <span class="c1"># Creating the needed files</span>
                        <span class="n">subfolder</span> <span class="o">=</span> <span class="n">folder</span><span class="o">.</span><span class="n">get_subfolder</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                            <span class="n">nodes_export_subfolder</span><span class="p">,</span> <span class="n">export_shard_uuid</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">uuid</span><span class="p">)))</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">subfolder</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unable to find the repository &quot;</span>
                                             <span class="s2">&quot;folder for node with UUID=</span><span class="si">{}</span><span class="s2"> &quot;</span>
                                             <span class="s2">&quot;in the exported file&quot;</span>
                                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">uuid</span><span class="p">))</span>
                        <span class="n">destdir</span> <span class="o">=</span> <span class="n">RepositoryFolder</span><span class="p">(</span>
                            <span class="n">section</span><span class="o">=</span><span class="n">Repository</span><span class="o">.</span><span class="n">_section_name</span><span class="p">,</span>
                            <span class="n">uuid</span><span class="o">=</span><span class="n">o</span><span class="o">.</span><span class="n">uuid</span><span class="p">)</span>
                        <span class="c1"># Replace the folder, possibly destroying existing</span>
                        <span class="c1"># previous folders, and move the files (faster if we</span>
                        <span class="c1"># are on the same filesystem, and</span>
                        <span class="c1"># in any case the source is a SandboxFolder)</span>
                        <span class="n">destdir</span><span class="o">.</span><span class="n">replace_with_folder</span><span class="p">(</span><span class="n">subfolder</span><span class="o">.</span><span class="n">abspath</span><span class="p">,</span>
                                                    <span class="n">move</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                        <span class="c1"># For DbNodes, we also have to store Attributes!</span>
                        <span class="n">import_entry_id</span> <span class="o">=</span> <span class="n">import_entry_ids</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">uuid</span><span class="p">)]</span>
                        <span class="c1"># Get attributes from import file</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">attributes</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;node_attributes&#39;</span><span class="p">][</span>
                                <span class="nb">str</span><span class="p">(</span><span class="n">import_entry_id</span><span class="p">)]</span>

                            <span class="n">attributes_conversion</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span>
                                <span class="s1">&#39;node_attributes_conversion&#39;</span><span class="p">][</span>
                                <span class="nb">str</span><span class="p">(</span><span class="n">import_entry_id</span><span class="p">)]</span>
                        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                                <span class="s2">&quot;Unable to find attribute info &quot;</span>
                                <span class="s2">&quot;for DbNode with UUID = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                    <span class="n">o</span><span class="o">.</span><span class="n">uuid</span><span class="p">))</span>

                        <span class="c1"># Here I have to deserialize the attributes</span>
                        <span class="n">deserialized_attributes</span> <span class="o">=</span> <span class="n">deserialize_attributes</span><span class="p">(</span>
                            <span class="n">attributes</span><span class="p">,</span> <span class="n">attributes_conversion</span><span class="p">)</span>

                        <span class="k">if</span> <span class="n">deserialized_attributes</span><span class="p">:</span>
                            <span class="n">o</span><span class="o">.</span><span class="n">attributes</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
                            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">deserialized_attributes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                                <span class="n">o</span><span class="o">.</span><span class="n">attributes</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

                        <span class="c1"># For DbNodes, we also have to store extras</span>
                        <span class="c1"># Get extras from import file</span>
                        <span class="k">if</span> <span class="n">extras_mode_new</span> <span class="o">==</span> <span class="s1">&#39;import&#39;</span><span class="p">:</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="n">silent</span><span class="p">:</span>
                                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;STORING NEW NODE EXTRAS...&quot;</span><span class="p">)</span>
                            <span class="k">try</span><span class="p">:</span>
                                <span class="n">extras</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;node_extras&#39;</span><span class="p">][</span>
                                    <span class="nb">str</span><span class="p">(</span><span class="n">import_entry_id</span><span class="p">)]</span>

                                <span class="n">extras_conversion</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span>
                                    <span class="s1">&#39;node_extras_conversion&#39;</span><span class="p">][</span>
                                    <span class="nb">str</span><span class="p">(</span><span class="n">import_entry_id</span><span class="p">)]</span>
                            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                                    <span class="s2">&quot;Unable to find extras info &quot;</span>
                                    <span class="s2">&quot;for DbNode with UUID = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                        <span class="n">o</span><span class="o">.</span><span class="n">uuid</span><span class="p">))</span>
                            <span class="c1"># Here I have to deserialize the extras</span>
                            <span class="n">deserialized_extras</span> <span class="o">=</span> <span class="n">deserialize_attributes</span><span class="p">(</span><span class="n">extras</span><span class="p">,</span> <span class="n">extras_conversion</span><span class="p">)</span>
                            <span class="c1"># TODO: remove when aiida extras will be moved somewhere else</span>
                            <span class="c1"># from here</span>
                            <span class="n">deserialized_extras</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span><span class="n">value</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">deserialized_extras</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span>
                                    <span class="n">key</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;_aiida_&#39;</span><span class="p">)}</span>
                            <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">node_type</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;code.Code.&#39;</span><span class="p">):</span>
                                <span class="n">deserialized_extras</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span><span class="n">value</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span><span class="n">value</span> <span class="ow">in</span> <span class="n">deserialized_extras</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span>
                                        <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;hidden&#39;</span><span class="p">}</span>
                            <span class="c1"># till here</span>
                            <span class="n">o</span><span class="o">.</span><span class="n">extras</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
                            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">deserialized_extras</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                                <span class="n">o</span><span class="o">.</span><span class="n">extras</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
                        <span class="k">elif</span> <span class="n">extras_mode_new</span> <span class="o">==</span> <span class="s1">&#39;none&#39;</span><span class="p">:</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="n">silent</span><span class="p">:</span>
                                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;SKIPPING NEW NODE EXTRAS...&quot;</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown extras_mode_new value: </span><span class="si">{}</span><span class="s2">, should be either &#39;import&#39; or &quot;</span>
                                    <span class="s2">&quot;&#39;none&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">extras_mode_new</span><span class="p">))</span>

                    <span class="k">if</span> <span class="ow">not</span> <span class="n">silent</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;UPDATING EXISTING NODE EXTRAS (mode: </span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">extras_mode_existing</span><span class="p">))</span>

                    <span class="n">uuid_import_pk_match</span> <span class="o">=</span> <span class="p">{</span><span class="n">entry_data</span><span class="p">[</span><span class="n">unique_identifier</span><span class="p">]:</span><span class="n">import_entry_id</span> <span class="k">for</span>
                            <span class="n">import_entry_id</span><span class="p">,</span> <span class="n">entry_data</span> <span class="ow">in</span> <span class="n">existing_entries</span><span class="p">[</span><span class="n">entity_name</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
                    <span class="k">for</span> <span class="n">db_node</span> <span class="ow">in</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">DbNode</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">DbNode</span><span class="o">.</span><span class="n">uuid</span><span class="o">.</span><span class="n">in_</span><span class="p">(</span><span class="n">uuid_import_pk_match</span><span class="p">))</span><span class="o">.</span><span class="n">distinct</span><span class="p">()</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                        <span class="n">import_entry_id</span> <span class="o">=</span> <span class="n">uuid_import_pk_match</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">db_node</span><span class="o">.</span><span class="n">uuid</span><span class="p">)]</span>
                        <span class="c1"># Get extras from import file</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">extras</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;node_extras&#39;</span><span class="p">][</span>
                                <span class="nb">str</span><span class="p">(</span><span class="n">import_entry_id</span><span class="p">)]</span>
                            <span class="n">extras_conversion</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span>
                                <span class="s1">&#39;node_extras_conversion&#39;</span><span class="p">][</span>
                                <span class="nb">str</span><span class="p">(</span><span class="n">import_entry_id</span><span class="p">)]</span>
                        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unable to find extras info &quot;</span>
                                             <span class="s2">&quot;for DbNode with UUID = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">db_node</span><span class="o">.</span><span class="n">uuid</span><span class="p">))</span>

                        <span class="c1"># Here I have to deserialize the extras</span>
                        <span class="n">old_extras</span> <span class="o">=</span> <span class="n">db_node</span><span class="o">.</span><span class="n">extras</span>
                        <span class="n">deserialized_extras</span> <span class="o">=</span> <span class="n">deserialize_attributes</span><span class="p">(</span><span class="n">extras</span><span class="p">,</span> <span class="n">extras_conversion</span><span class="p">)</span>
                        <span class="c1"># TODO: remove when aiida extras will be moved somewhere else</span>
                        <span class="c1"># from here</span>
                        <span class="n">deserialized_extras</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span><span class="n">value</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">deserialized_extras</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span>
                                <span class="n">key</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;_aiida_&#39;</span><span class="p">)}</span>
                        <span class="k">if</span> <span class="n">db_node</span><span class="o">.</span><span class="n">node_type</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;code.Code.&#39;</span><span class="p">):</span>
                            <span class="n">deserialized_extras</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span><span class="n">value</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span><span class="n">value</span> <span class="ow">in</span> <span class="n">deserialized_extras</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span>
                                    <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;hidden&#39;</span><span class="p">}</span>
                        <span class="c1"># till here</span>
                        <span class="n">db_node</span><span class="o">.</span><span class="n">extras</span> <span class="o">=</span> <span class="n">merge_extras</span><span class="p">(</span><span class="n">old_extras</span><span class="p">,</span> <span class="n">deserialized_extras</span><span class="p">,</span> <span class="n">extras_mode_existing</span><span class="p">)</span>
                        <span class="n">flag_modified</span><span class="p">(</span><span class="n">db_node</span><span class="p">,</span> <span class="s2">&quot;extras&quot;</span><span class="p">)</span>

                <span class="c1"># Store them all in once; However, the PK</span>
                <span class="c1"># are not set in this way...</span>
                <span class="k">if</span> <span class="n">objects_to_create</span><span class="p">:</span>
                    <span class="n">session</span><span class="o">.</span><span class="n">add_all</span><span class="p">(</span><span class="n">objects_to_create</span><span class="p">)</span>

                <span class="n">session</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

                <span class="k">if</span> <span class="n">import_entry_ids</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">qb</span> <span class="o">=</span> <span class="n">QueryBuilder</span><span class="p">()</span>
                    <span class="n">qb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entity</span><span class="p">,</span> <span class="n">filters</span><span class="o">=</span><span class="p">{</span>
                        <span class="n">unique_identifier</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;in&quot;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">import_entry_ids</span><span class="o">.</span><span class="n">keys</span><span class="p">())}},</span>
                              <span class="n">project</span><span class="o">=</span><span class="p">[</span><span class="n">unique_identifier</span><span class="p">,</span> <span class="s2">&quot;id&quot;</span><span class="p">],</span> <span class="n">tag</span><span class="o">=</span><span class="s2">&quot;res&quot;</span><span class="p">)</span>
                    <span class="n">just_saved</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">qb</span><span class="o">.</span><span class="n">all</span><span class="p">()}</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">just_saved</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

                <span class="c1"># Now I have the PKs, print the info</span>
                <span class="c1"># Moreover, set the foreign_ids_reverse_mappings</span>
                <span class="k">for</span> <span class="n">unique_id</span><span class="p">,</span> <span class="n">new_pk</span> <span class="ow">in</span> <span class="n">just_saved</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="kn">from</span> <span class="nn">uuid</span> <span class="k">import</span> <span class="n">UUID</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">unique_id</span><span class="p">,</span> <span class="n">UUID</span><span class="p">):</span>
                        <span class="n">unique_id</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">unique_id</span><span class="p">)</span>
                    <span class="n">import_entry_id</span> <span class="o">=</span> <span class="n">import_entry_ids</span><span class="p">[</span><span class="n">unique_id</span><span class="p">]</span>
                    <span class="n">foreign_ids_reverse_mappings</span><span class="p">[</span><span class="n">entity_name</span><span class="p">][</span><span class="n">unique_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_pk</span>
                    <span class="k">if</span> <span class="n">entity_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ret_dict</span><span class="p">:</span>
                        <span class="n">ret_dict</span><span class="p">[</span><span class="n">entity_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;new&#39;</span><span class="p">:</span> <span class="p">[],</span> <span class="s1">&#39;existing&#39;</span><span class="p">:</span> <span class="p">[]}</span>
                    <span class="n">ret_dict</span><span class="p">[</span><span class="n">entity_name</span><span class="p">][</span><span class="s1">&#39;new&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">import_entry_id</span><span class="p">,</span>
                                                         <span class="n">new_pk</span><span class="p">))</span>

                    <span class="k">if</span> <span class="ow">not</span> <span class="n">silent</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;NEW </span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2"> (</span><span class="si">%s</span><span class="s2">-&gt;</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">entity_sig</span><span class="p">,</span> <span class="n">unique_id</span><span class="p">,</span>
                                                       <span class="n">import_entry_id</span><span class="p">,</span>
                                                       <span class="n">new_pk</span><span class="p">))</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">silent</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;STORING NODE LINKS...&quot;</span><span class="p">)</span>
            <span class="c1">## TODO: check that we are not creating input links of an already</span>
            <span class="c1">##       existing node...</span>
            <span class="n">import_links</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;links_uuid&#39;</span><span class="p">]</span>
            <span class="n">links_to_store</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># Needed for fast checks of existing links</span>
            <span class="kn">from</span> <span class="nn">aiida.backends.sqlalchemy.models.node</span> <span class="k">import</span> <span class="n">DbLink</span>
            <span class="n">existing_links_raw</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
                <span class="n">DbLink</span><span class="o">.</span><span class="n">input_id</span><span class="p">,</span> <span class="n">DbLink</span><span class="o">.</span><span class="n">output_id</span><span class="p">,</span><span class="n">DbLink</span><span class="o">.</span><span class="n">label</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
            <span class="n">existing_links_labels</span> <span class="o">=</span> <span class="p">{(</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span> <span class="n">l</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                                     <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">existing_links_raw</span><span class="p">}</span>
            <span class="n">existing_input_links</span> <span class="o">=</span> <span class="p">{(</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                                    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">existing_links_raw</span><span class="p">}</span>

            <span class="n">dbnode_reverse_mappings</span> <span class="o">=</span> <span class="n">foreign_ids_reverse_mappings</span><span class="p">[</span><span class="n">NODE_ENTITY_NAME</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="n">import_links</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">in_id</span> <span class="o">=</span> <span class="n">dbnode_reverse_mappings</span><span class="p">[</span><span class="n">link</span><span class="p">[</span><span class="s1">&#39;input&#39;</span><span class="p">]]</span>
                    <span class="n">out_id</span> <span class="o">=</span> <span class="n">dbnode_reverse_mappings</span><span class="p">[</span><span class="n">link</span><span class="p">[</span><span class="s1">&#39;output&#39;</span><span class="p">]]</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">ignore_unknown_nodes</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Trying to create a link with one &quot;</span>
                                         <span class="s2">&quot;or both unknown nodes, stopping &quot;</span>
                                         <span class="s2">&quot;(in_uuid=</span><span class="si">{}</span><span class="s2">, out_uuid=</span><span class="si">{}</span><span class="s2">, &quot;</span>
                                         <span class="s2">&quot;label=</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">link</span><span class="p">[</span><span class="s1">&#39;input&#39;</span><span class="p">],</span>
                                                            <span class="n">link</span><span class="p">[</span><span class="s1">&#39;output&#39;</span><span class="p">],</span>
                                                            <span class="n">link</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]))</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="n">existing_label</span> <span class="o">=</span> <span class="n">existing_links_labels</span><span class="p">[</span><span class="n">in_id</span><span class="p">,</span> <span class="n">out_id</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">existing_label</span> <span class="o">!=</span> <span class="n">link</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Trying to rename an existing link &quot;</span>
                                         <span class="s2">&quot;name, stopping (in=</span><span class="si">{}</span><span class="s2">, out=</span><span class="si">{}</span><span class="s2">, &quot;</span>
                                         <span class="s2">&quot;old_label=</span><span class="si">{}</span><span class="s2">, new_label=</span><span class="si">{}</span><span class="s2">)&quot;</span>
                                         <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">in_id</span><span class="p">,</span> <span class="n">out_id</span><span class="p">,</span> <span class="n">existing_label</span><span class="p">,</span>
                                                 <span class="n">link</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]))</span>
                        <span class="c1"># Do nothing, the link is already in place and has</span>
                        <span class="c1"># the correct name</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="c1"># We try to get the existing input of the link that</span>
                        <span class="c1"># points to &quot;out&quot; and has label link[&#39;label&#39;].</span>
                        <span class="c1"># If there is no existing_input, it means that the</span>
                        <span class="c1"># link doesn&#39;t exist and it has to be created. If</span>
                        <span class="c1"># it exists, then the only case that we can have more</span>
                        <span class="c1"># than one links with the same name entering a node</span>
                        <span class="c1"># is the case of the RETURN links of workflows/</span>
                        <span class="c1"># workchains. If it is not this case, then it is</span>
                        <span class="c1"># an error.</span>
                        <span class="n">existing_input</span> <span class="o">=</span> <span class="n">existing_input_links</span><span class="p">[</span><span class="n">out_id</span><span class="p">,</span>
                                                              <span class="n">link</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]]</span>

                        <span class="k">if</span> <span class="n">link</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">LinkType</span><span class="o">.</span><span class="n">RETURN</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                                <span class="s2">&quot;There exists already an input link to node &quot;</span>
                                <span class="s2">&quot;with UUID </span><span class="si">{}</span><span class="s2"> with label </span><span class="si">{}</span><span class="s2"> but it does not &quot;</span>
                                <span class="s2">&quot;come from the expected input with UUID </span><span class="si">{}</span><span class="s2"> &quot;</span>
                                <span class="s2">&quot;but from a node with UUID </span><span class="si">{}</span><span class="s2">.&quot;</span>
                                    <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">link</span><span class="p">[</span><span class="s1">&#39;output&#39;</span><span class="p">],</span> <span class="n">link</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">],</span>
                                            <span class="n">link</span><span class="p">[</span><span class="s1">&#39;input&#39;</span><span class="p">],</span> <span class="n">existing_input</span><span class="p">))</span>
                    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                        <span class="c1"># New link</span>
                        <span class="n">links_to_store</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">DbLink</span><span class="p">(</span>
                            <span class="n">input_id</span><span class="o">=</span><span class="n">in_id</span><span class="p">,</span> <span class="n">output_id</span><span class="o">=</span><span class="n">out_id</span><span class="p">,</span>
                            <span class="n">label</span><span class="o">=</span><span class="n">link</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">],</span> <span class="nb">type</span><span class="o">=</span><span class="n">LinkType</span><span class="p">(</span><span class="n">link</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
                        <span class="k">if</span> <span class="n">LINK_ENTITY_NAME</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ret_dict</span><span class="p">:</span>
                            <span class="n">ret_dict</span><span class="p">[</span><span class="n">LINK_ENTITY_NAME</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;new&#39;</span><span class="p">:</span> <span class="p">[]}</span>
                        <span class="n">ret_dict</span><span class="p">[</span><span class="n">LINK_ENTITY_NAME</span><span class="p">][</span><span class="s1">&#39;new&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">in_id</span><span class="p">,</span> <span class="n">out_id</span><span class="p">))</span>

            <span class="c1"># Store new links</span>
            <span class="k">if</span> <span class="n">links_to_store</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">silent</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;   (</span><span class="si">{}</span><span class="s2"> new links...)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">links_to_store</span><span class="p">)))</span>
                <span class="n">session</span><span class="o">.</span><span class="n">add_all</span><span class="p">(</span><span class="n">links_to_store</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">silent</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;   (0 new links...)&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">silent</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;STORING GROUP ELEMENTS...&quot;</span><span class="p">)</span>
            <span class="n">import_groups</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;groups_uuid&#39;</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">groupuuid</span><span class="p">,</span> <span class="n">groupnodes</span> <span class="ow">in</span> <span class="n">import_groups</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="c1"># # TODO: cache these to avoid too many queries</span>
                <span class="n">qb_group</span> <span class="o">=</span> <span class="n">QueryBuilder</span><span class="p">()</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">Group</span><span class="p">,</span> <span class="n">filters</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;uuid&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;==&#39;</span><span class="p">:</span> <span class="n">groupuuid</span><span class="p">}})</span>
                <span class="n">group</span> <span class="o">=</span> <span class="n">qb_group</span><span class="o">.</span><span class="n">first</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">nodes_ids_to_add</span> <span class="o">=</span> <span class="p">[</span><span class="n">dbnode_reverse_mappings</span><span class="p">[</span><span class="n">node_uuid</span><span class="p">]</span>
                                    <span class="k">for</span> <span class="n">node_uuid</span> <span class="ow">in</span> <span class="n">groupnodes</span><span class="p">]</span>
                <span class="n">qb_nodes</span> <span class="o">=</span> <span class="n">QueryBuilder</span><span class="p">()</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">Node</span><span class="p">,</span> <span class="n">filters</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;id&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="n">nodes_ids_to_add</span><span class="p">}})</span>
                <span class="c1"># Adding nodes to group avoiding the SQLA ORM to increase speed</span>
                <span class="n">nodes_to_add</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">backend_entity</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">qb_nodes</span><span class="o">.</span><span class="n">all</span><span class="p">()]</span>
                <span class="n">group</span><span class="o">.</span><span class="n">backend_entity</span><span class="o">.</span><span class="n">add_nodes</span><span class="p">(</span><span class="n">nodes_to_add</span><span class="p">,</span> <span class="n">skip_orm</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1">######################################################</span>
            <span class="c1"># Put everything in a specific group</span>
            <span class="n">existing</span> <span class="o">=</span> <span class="n">existing_entries</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">NODE_ENTITY_NAME</span><span class="p">,</span> <span class="p">{})</span>
            <span class="n">existing_pk</span> <span class="o">=</span> <span class="p">[</span><span class="n">foreign_ids_reverse_mappings</span><span class="p">[</span><span class="n">NODE_ENTITY_NAME</span><span class="p">][</span><span class="n">v</span><span class="p">[</span><span class="s1">&#39;uuid&#39;</span><span class="p">]]</span>
                           <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">itervalues</span><span class="p">(</span><span class="n">existing</span><span class="p">)]</span>
            <span class="n">new</span> <span class="o">=</span> <span class="n">new_entries</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">NODE_ENTITY_NAME</span><span class="p">,</span> <span class="p">{})</span>
            <span class="n">new_pk</span> <span class="o">=</span> <span class="p">[</span><span class="n">foreign_ids_reverse_mappings</span><span class="p">[</span><span class="n">NODE_ENTITY_NAME</span><span class="p">][</span><span class="n">v</span><span class="p">[</span><span class="s1">&#39;uuid&#39;</span><span class="p">]]</span>
                      <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">itervalues</span><span class="p">(</span><span class="n">new</span><span class="p">)]</span>

            <span class="n">pks_for_group</span> <span class="o">=</span> <span class="n">existing_pk</span> <span class="o">+</span> <span class="n">new_pk</span>

            <span class="c1"># So that we do not create empty groups</span>
            <span class="k">if</span> <span class="n">pks_for_group</span><span class="p">:</span>
                <span class="c1"># If user specified a group, import all things in it</span>
                <span class="k">if</span> <span class="n">user_group</span><span class="p">:</span>
                    <span class="n">group</span> <span class="o">=</span> <span class="n">user_group</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Get an unique name for the import group, based on the</span>
                    <span class="c1"># current (local) time</span>
                    <span class="n">basename</span> <span class="o">=</span> <span class="n">timezone</span><span class="o">.</span><span class="n">localtime</span><span class="p">(</span><span class="n">timezone</span><span class="o">.</span><span class="n">now</span><span class="p">())</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span>
                        <span class="s2">&quot;%Y%m</span><span class="si">%d</span><span class="s2">-%H%M%S&quot;</span><span class="p">)</span>
                    <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">created</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">while</span> <span class="ow">not</span> <span class="n">created</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">counter</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">group_label</span> <span class="o">=</span> <span class="n">basename</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">group_label</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">basename</span><span class="p">,</span> <span class="n">counter</span><span class="p">)</span>

                        <span class="n">group</span> <span class="o">=</span> <span class="n">Group</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="n">group_label</span><span class="p">,</span>
                                      <span class="n">type_string</span><span class="o">=</span><span class="n">IMPORTGROUP_TYPE</span><span class="p">)</span>
                        <span class="kn">from</span> <span class="nn">aiida.backends.sqlalchemy.models.group</span> <span class="k">import</span> <span class="n">DbGroup</span>
                        <span class="k">if</span> <span class="n">session</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">DbGroup</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
                                <span class="n">DbGroup</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="n">group</span><span class="o">.</span><span class="n">backend_entity</span><span class="o">.</span><span class="n">_dbmodel</span><span class="o">.</span><span class="n">label</span><span class="p">)</span><span class="o">.</span><span class="n">count</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">session</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">group</span><span class="o">.</span><span class="n">backend_entity</span><span class="o">.</span><span class="n">_dbmodel</span><span class="p">)</span>
                            <span class="n">created</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="c1"># Adding nodes to group avoiding the SQLA ORM to increase speed</span>
                <span class="n">nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">backend_entity</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">QueryBuilder</span><span class="p">()</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Node</span><span class="p">,</span> <span class="n">filters</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;id&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="n">pks_for_group</span><span class="p">}})</span><span class="o">.</span><span class="n">all</span><span class="p">()]</span>
                <span class="n">group</span><span class="o">.</span><span class="n">backend_entity</span><span class="o">.</span><span class="n">add_nodes</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">skip_orm</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">silent</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;IMPORTED NODES GROUPED IN IMPORT GROUP NAMED &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">group</span><span class="o">.</span><span class="n">label</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">silent</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;NO DBNODES TO IMPORT, SO NO GROUP CREATED&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">silent</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;COMMITTING EVERYTHING...&quot;</span><span class="p">)</span>
            <span class="n">session</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Rolling back&quot;</span><span class="p">)</span>
            <span class="n">session</span><span class="o">.</span><span class="n">rollback</span><span class="p">()</span>
            <span class="k">raise</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">silent</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;*** WARNING: MISSING EXISTING UUID CHECKS!!&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;*** WARNING: TODO: UPDATE IMPORT_DATA WITH DEFAULT VALUES! (e.g. calc status, user pwd, ...)&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;DONE.&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ret_dict</span></div>


<div class="viewcode-block" id="HTMLGetLinksParser"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.importexport.HTMLGetLinksParser">[docs]</a><span class="k">class</span> <span class="nc">HTMLGetLinksParser</span><span class="p">(</span><span class="n">HTMLParser</span><span class="p">):</span>
<div class="viewcode-block" id="HTMLGetLinksParser.__init__"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.importexport.HTMLGetLinksParser.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_extension</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If a filter_extension is passed, only links with extension matching</span>
<span class="sd">        the given one will be returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter_extension</span> <span class="o">=</span> <span class="n">filter_extension</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">links</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">HTMLGetLinksParser</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span></div>

<div class="viewcode-block" id="HTMLGetLinksParser.handle_starttag"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.importexport.HTMLGetLinksParser.handle_starttag">[docs]</a>    <span class="k">def</span> <span class="nf">handle_starttag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">attrs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Store the urls encountered, if they match the request.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">tag</span> <span class="o">==</span> <span class="s1">&#39;a&#39;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">attrs</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="s1">&#39;href&#39;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter_extension</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span>
                            <span class="n">v</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter_extension</span><span class="p">))):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">links</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span></div>

<div class="viewcode-block" id="HTMLGetLinksParser.get_links"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.importexport.HTMLGetLinksParser.get_links">[docs]</a>    <span class="k">def</span> <span class="nf">get_links</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the links that were found during the parsing phase.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">links</span></div></div>


<div class="viewcode-block" id="get_valid_import_links"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.importexport.get_valid_import_links">[docs]</a><span class="k">def</span> <span class="nf">get_valid_import_links</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Open the given URL, parse the HTML and return a list of valid links where</span>
<span class="sd">    the link file has a .aiida extension.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">six.moves</span> <span class="k">import</span> <span class="n">urllib</span>

    <span class="n">request</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
    <span class="n">parser</span> <span class="o">=</span> <span class="n">HTMLGetLinksParser</span><span class="p">(</span><span class="n">filter_extension</span><span class="o">=</span><span class="s1">&#39;aiida&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">feed</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>

    <span class="n">return_urls</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="n">parser</span><span class="o">.</span><span class="n">get_links</span><span class="p">():</span>
        <span class="n">return_urls</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">urllib</span><span class="o">.</span><span class="n">parse</span><span class="o">.</span><span class="n">urljoin</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">geturl</span><span class="p">(),</span> <span class="n">link</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">return_urls</span></div>


<div class="viewcode-block" id="serialize_field"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.importexport.serialize_field">[docs]</a><span class="k">def</span> <span class="nf">serialize_field</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">track_conversion</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Serialize a single field.</span>

<span class="sd">    :todo: Generalize such that it the proper function is selected also during</span>
<span class="sd">        import</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">datetime</span>
    <span class="kn">import</span> <span class="nn">pytz</span>
    <span class="kn">from</span> <span class="nn">uuid</span> <span class="k">import</span> <span class="n">UUID</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">track_conversion</span><span class="p">:</span>
            <span class="n">ret_data</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">ret_conversion</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">ret_data</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">ret_conversion</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">serialize_field</span><span class="p">(</span>
                    <span class="n">data</span><span class="o">=</span><span class="n">v</span><span class="p">,</span> <span class="n">track_conversion</span><span class="o">=</span><span class="n">track_conversion</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret_data</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">serialize_field</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">v</span><span class="p">,</span>
                                           <span class="n">track_conversion</span><span class="o">=</span><span class="n">track_conversion</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">track_conversion</span><span class="p">:</span>
            <span class="n">ret_data</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">ret_conversion</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
                <span class="n">this_data</span><span class="p">,</span> <span class="n">this_conversion</span> <span class="o">=</span> <span class="n">serialize_field</span><span class="p">(</span>
                    <span class="n">data</span><span class="o">=</span><span class="n">value</span><span class="p">,</span> <span class="n">track_conversion</span><span class="o">=</span><span class="n">track_conversion</span><span class="p">)</span>
                <span class="n">ret_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this_data</span><span class="p">)</span>
                <span class="n">ret_conversion</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this_conversion</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">serialize_field</span><span class="p">(</span>
                <span class="n">data</span><span class="o">=</span><span class="n">value</span><span class="p">,</span> <span class="n">track_conversion</span><span class="o">=</span><span class="n">track_conversion</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">data</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">):</span>
        <span class="c1"># Note: requires timezone-aware objects!</span>
        <span class="n">ret_data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">astimezone</span><span class="p">(</span><span class="n">pytz</span><span class="o">.</span><span class="n">utc</span><span class="p">)</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span>
            <span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1">T%H:%M:%S.</span><span class="si">%f</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">ret_conversion</span> <span class="o">=</span> <span class="s1">&#39;date&#39;</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">UUID</span><span class="p">):</span>
        <span class="n">ret_data</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">ret_conversion</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ret_data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="n">ret_conversion</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">track_conversion</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">ret_data</span><span class="p">,</span> <span class="n">ret_conversion</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ret_data</span></div>


<div class="viewcode-block" id="serialize_dict"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.importexport.serialize_dict">[docs]</a><span class="k">def</span> <span class="nf">serialize_dict</span><span class="p">(</span><span class="n">datadict</span><span class="p">,</span> <span class="n">remove_fields</span><span class="o">=</span><span class="p">[],</span> <span class="n">rename_fields</span><span class="o">=</span><span class="p">{},</span>
                   <span class="n">track_conversion</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Serialize the dict using the serialize_field function to serialize</span>
<span class="sd">    each field.</span>

<span class="sd">    :param remove_fields: a list of strings.</span>
<span class="sd">      If a field with key inside the remove_fields list is found,</span>
<span class="sd">      it is removed from the dict.</span>

<span class="sd">      This is only used at level-0, no removal</span>
<span class="sd">      is possible at deeper levels.</span>

<span class="sd">    :param rename_fields: a dictionary in the format</span>
<span class="sd">      ``{&quot;oldname&quot;: &quot;newname&quot;}``.</span>

<span class="sd">      If the &quot;oldname&quot; key is found, it is replaced with the</span>
<span class="sd">      &quot;newname&quot; string in the output dictionary.</span>

<span class="sd">      This is only used at level-0, no renaming</span>
<span class="sd">      is possible at deeper levels.</span>
<span class="sd">    :param track_conversion: if True, a tuple is returned, where the first</span>
<span class="sd">      element is the serialized dictionary, and the second element is a</span>
<span class="sd">      dictionary with the information on the serialized fields.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ret_dict</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="n">conversions</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">datadict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">remove_fields</span><span class="p">:</span>
            <span class="c1"># rename_fields.get(k,k): use the replacement if found in rename_fields,</span>
            <span class="c1"># otherwise use &#39;k&#39; as the default value.</span>
            <span class="k">if</span> <span class="n">track_conversion</span><span class="p">:</span>
                <span class="p">(</span><span class="n">ret_dict</span><span class="p">[</span><span class="n">rename_fields</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">)],</span>
                 <span class="n">conversions</span><span class="p">[</span><span class="n">rename_fields</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">)])</span> <span class="o">=</span> <span class="n">serialize_field</span><span class="p">(</span>
                    <span class="n">data</span><span class="o">=</span><span class="n">v</span><span class="p">,</span> <span class="n">track_conversion</span><span class="o">=</span><span class="n">track_conversion</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ret_dict</span><span class="p">[</span><span class="n">rename_fields</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">)]</span> <span class="o">=</span> <span class="n">serialize_field</span><span class="p">(</span>
                    <span class="n">data</span><span class="o">=</span><span class="n">v</span><span class="p">,</span> <span class="n">track_conversion</span><span class="o">=</span><span class="n">track_conversion</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">track_conversion</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">ret_dict</span><span class="p">,</span> <span class="n">conversions</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ret_dict</span></div>


<div class="viewcode-block" id="fill_in_query"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.importexport.fill_in_query">[docs]</a><span class="k">def</span> <span class="nf">fill_in_query</span><span class="p">(</span><span class="n">partial_query</span><span class="p">,</span> <span class="n">originating_entity_str</span><span class="p">,</span> <span class="n">current_entity_str</span><span class="p">,</span>
                  <span class="n">tag_suffixes</span><span class="o">=</span><span class="p">[],</span> <span class="n">entity_separator</span><span class="o">=</span><span class="s2">&quot;_&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function recursively constructs QueryBuilder queries that are needed</span>
<span class="sd">    for the SQLA export function. To manage to construct such queries, the</span>
<span class="sd">    relationship dictionary is consulted (which shows how to reference</span>
<span class="sd">    different AiiDA entities in QueryBuilder.</span>
<span class="sd">    To find the dependencies of the relationships of the exported data, the</span>
<span class="sd">    get_all_fields_info_sqla (which described the exported schema and its</span>
<span class="sd">    dependencies) is consulted.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">relationship_dic</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;Node&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;Computer&quot;</span><span class="p">:</span> <span class="s2">&quot;with_computer&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Group&quot;</span><span class="p">:</span> <span class="s2">&quot;with_group&quot;</span><span class="p">,</span>
            <span class="s2">&quot;User&quot;</span><span class="p">:</span> <span class="s2">&quot;with_user&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Log&quot;</span><span class="p">:</span> <span class="s2">&quot;with_log&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Comment&quot;</span><span class="p">:</span> <span class="s2">&quot;with_comment&quot;</span>
        <span class="p">},</span>
        <span class="s2">&quot;Group&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;Node&quot;</span><span class="p">:</span> <span class="s2">&quot;with_node&quot;</span>
        <span class="p">},</span>
        <span class="s2">&quot;Computer&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;Node&quot;</span><span class="p">:</span> <span class="s2">&quot;with_node&quot;</span>
        <span class="p">},</span>
        <span class="s2">&quot;User&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;Node&quot;</span><span class="p">:</span> <span class="s2">&quot;with_node&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Group&quot;</span><span class="p">:</span> <span class="s2">&quot;with_group&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Comment&quot;</span><span class="p">:</span> <span class="s2">&quot;with_comment&quot;</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="s2">&quot;Log&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;Node&quot;</span><span class="p">:</span> <span class="s2">&quot;with_node&quot;</span>
        <span class="p">},</span>
        <span class="s2">&quot;Comment&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;Node&quot;</span><span class="p">:</span> <span class="s2">&quot;with_node&quot;</span><span class="p">,</span>
            <span class="s2">&quot;User&quot;</span><span class="p">:</span> <span class="s2">&quot;with_user&quot;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">all_fields_info</span><span class="p">,</span> <span class="n">unique_identifiers</span> <span class="o">=</span> <span class="n">get_all_fields_info</span><span class="p">()</span>

    <span class="n">entity_prop</span> <span class="o">=</span> <span class="n">all_fields_info</span><span class="p">[</span><span class="n">current_entity_str</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

    <span class="n">project_cols</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">prop</span> <span class="ow">in</span> <span class="n">entity_prop</span><span class="p">:</span>
        <span class="n">nprop</span> <span class="o">=</span> <span class="n">prop</span>
        <span class="k">if</span> <span class="n">current_entity_str</span> <span class="ow">in</span> <span class="n">file_fields_to_model_fields</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">prop</span> <span class="ow">in</span> <span class="n">file_fields_to_model_fields</span><span class="p">[</span><span class="n">current_entity_str</span><span class="p">]:</span>
                <span class="n">nprop</span> <span class="o">=</span> <span class="n">file_fields_to_model_fields</span><span class="p">[</span><span class="n">current_entity_str</span><span class="p">][</span><span class="n">prop</span><span class="p">]</span>

        <span class="n">project_cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nprop</span><span class="p">)</span>

    <span class="c1"># Here we should reference the entity of the main query</span>
    <span class="n">current_entity_mod</span> <span class="o">=</span> <span class="n">entity_names_to_entities</span><span class="p">[</span><span class="n">current_entity_str</span><span class="p">]</span>

    <span class="n">rel_string</span> <span class="o">=</span> <span class="n">relationship_dic</span><span class="p">[</span><span class="n">current_entity_str</span><span class="p">][</span><span class="n">originating_entity_str</span><span class="p">]</span>
    <span class="n">mydict</span> <span class="o">=</span> <span class="p">{</span><span class="n">rel_string</span><span class="p">:</span> <span class="n">entity_separator</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tag_suffixes</span><span class="p">)}</span>

    <span class="n">partial_query</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current_entity_mod</span><span class="p">,</span>
                         <span class="n">tag</span><span class="o">=</span><span class="n">entity_separator</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tag_suffixes</span><span class="p">)</span> <span class="o">+</span>
                             <span class="n">entity_separator</span> <span class="o">+</span> <span class="n">current_entity_str</span><span class="p">,</span>
                         <span class="n">project</span><span class="o">=</span><span class="n">project_cols</span><span class="p">,</span> <span class="n">outerjoin</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">mydict</span><span class="p">)</span>

    <span class="c1"># prepare the recursion for the referenced entities</span>
    <span class="n">foreign_fields</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span>
                      <span class="n">all_fields_info</span><span class="p">[</span>
                          <span class="n">current_entity_str</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                      <span class="c1"># all_fields_info[model_name].items()</span>
                      <span class="k">if</span> <span class="s1">&#39;requires&#39;</span> <span class="ow">in</span> <span class="n">v</span><span class="p">}</span>

    <span class="n">new_tag_suffixes</span> <span class="o">=</span> <span class="n">tag_suffixes</span> <span class="o">+</span> <span class="p">[</span><span class="n">current_entity_str</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">foreign_fields</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">ref_model_name</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="s1">&#39;requires&#39;</span><span class="p">]</span>
        <span class="n">fill_in_query</span><span class="p">(</span><span class="n">partial_query</span><span class="p">,</span> <span class="n">current_entity_str</span><span class="p">,</span> <span class="n">ref_model_name</span><span class="p">,</span>
                      <span class="n">new_tag_suffixes</span><span class="p">)</span></div>


<div class="viewcode-block" id="export_tree"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.importexport.export_tree">[docs]</a><span class="k">def</span> <span class="nf">export_tree</span><span class="p">(</span><span class="n">what</span><span class="p">,</span> <span class="n">folder</span><span class="p">,</span> <span class="n">allowed_licenses</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">forbidden_licenses</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">silent</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">input_forward</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">create_reversed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">return_reversed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">call_reversed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">include_comments</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">include_logs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Export the entries passed in the &#39;what&#39; list to a file tree.</span>
<span class="sd">    :todo: limit the export to finished or failed calculations.</span>
<span class="sd">    :param what: a list of entity instances; they can belong to</span>
<span class="sd">    different models/entities.</span>
<span class="sd">    :param folder: a :py:class:`Folder &lt;aiida.common.folders.Folder&gt;` object</span>
<span class="sd">    :param input_forward: Follow forward INPUT links (recursively) when</span>
<span class="sd">    calculating the node set to export.</span>
<span class="sd">    :param create_reversed: Follow reversed CREATE links (recursively) when</span>
<span class="sd">    calculating the node set to export.</span>
<span class="sd">    :param return_reversed: Follow reversed RETURN links (recursively) when</span>
<span class="sd">    calculating the node set to export.</span>
<span class="sd">    :param call_reversed: Follow reversed CALL links (recursively) when</span>
<span class="sd">    calculating the node set to export.</span>
<span class="sd">    :param allowed_licenses: a list or a function. If a list, then checks</span>
<span class="sd">    whether all licenses of Data nodes are in the list. If a function,</span>
<span class="sd">    then calls function for licenses of Data nodes expecting True if</span>
<span class="sd">    license is allowed, False otherwise.</span>
<span class="sd">    :param forbidden_licenses: a list or a function. If a list, then checks</span>
<span class="sd">    whether all licenses of Data nodes are in the list. If a function,</span>
<span class="sd">    then calls function for licenses of Data nodes expecting True if</span>
<span class="sd">    license is allowed, False otherwise.</span>
<span class="sd">    :param include_comments: Bool: In-/exclude export of comments for given node(s).</span>
<span class="sd">    Default: True, *include* comments in export (as well as relevant users).</span>
<span class="sd">    :param include_logs: Bool: In-/exclude export of logs for given node(s).</span>
<span class="sd">    Default: True, *include* logs in export.</span>
<span class="sd">    :param silent: suppress debug prints</span>
<span class="sd">    :raises LicensingException: if any node is licensed under forbidden</span>
<span class="sd">    license</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">os</span>
    <span class="kn">import</span> <span class="nn">aiida</span>
    <span class="kn">from</span> <span class="nn">aiida.orm</span> <span class="k">import</span> <span class="n">Node</span><span class="p">,</span> <span class="n">Data</span><span class="p">,</span> <span class="n">Group</span><span class="p">,</span> <span class="n">Log</span><span class="p">,</span> <span class="n">Comment</span>
    <span class="kn">from</span> <span class="nn">aiida.orm</span> <span class="k">import</span> <span class="n">ProcessNode</span>
    <span class="kn">from</span> <span class="nn">aiida.common.exceptions</span> <span class="k">import</span> <span class="n">ContentNotExistent</span>
    <span class="kn">from</span> <span class="nn">aiida.common.links</span> <span class="k">import</span> <span class="n">LinkType</span>
    <span class="kn">from</span> <span class="nn">aiida.common.folders</span> <span class="k">import</span> <span class="n">RepositoryFolder</span>
    <span class="kn">from</span> <span class="nn">aiida.orm.querybuilder</span> <span class="k">import</span> <span class="n">QueryBuilder</span>
    <span class="kn">from</span> <span class="nn">aiida.common</span> <span class="k">import</span> <span class="n">json</span>
    <span class="kn">from</span> <span class="nn">django.core.exceptions</span> <span class="k">import</span> <span class="n">ImproperlyConfigured</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">silent</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;STARTING EXPORT...&quot;</span><span class="p">)</span>

    <span class="n">EXPORT_VERSION</span> <span class="o">=</span> <span class="s1">&#39;0.4&#39;</span>

    <span class="n">all_fields_info</span><span class="p">,</span> <span class="n">unique_identifiers</span> <span class="o">=</span> <span class="n">get_all_fields_info</span><span class="p">()</span>

    <span class="c1"># The set that contains the nodes ids of the nodes that should be exported</span>
    <span class="n">to_be_exported</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="n">given_data_entry_ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">given_calculation_entry_ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">given_group_entry_ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">given_computer_entry_ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">given_groups</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">given_log_entry_ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">given_comment_entry_ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="c1"># I store a list of the actual dbnodes</span>
    <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">what</span><span class="p">:</span>
        <span class="c1"># This returns the class name (as in imports). E.g. for a model node:</span>
        <span class="c1"># aiida.backends.djsite.db.models.DbNode</span>
        <span class="n">entry_class_string</span> <span class="o">=</span> <span class="n">get_class_string</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>
        <span class="c1"># Now a load the backend-independent name into entry_entity_name, e.g. Node!</span>
        <span class="n">entry_entity_name</span> <span class="o">=</span> <span class="n">schema_to_entity_names</span><span class="p">(</span><span class="n">entry_class_string</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">entry</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">Group</span><span class="p">):</span>
            <span class="n">given_group_entry_ids</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">entry</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
            <span class="n">given_groups</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">entry</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">Node</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">entry</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">Data</span><span class="p">):</span>
                <span class="n">given_data_entry_ids</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">entry</span><span class="o">.</span><span class="n">pk</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">entry</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">ProcessNode</span><span class="p">):</span>
                <span class="n">given_calculation_entry_ids</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">entry</span><span class="o">.</span><span class="n">pk</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">entry</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">Computer</span><span class="p">):</span>
            <span class="n">given_computer_entry_ids</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">entry</span><span class="o">.</span><span class="n">pk</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;I was given </span><span class="si">{}</span><span class="s2"> (</span><span class="si">{}</span><span class="s2">), which is not a Node, Computer, or Group instance&quot;</span>
                            <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">entry</span><span class="p">)))</span>

    <span class="c1"># Add all the nodes contained within the specified groups</span>
    <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">given_groups</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">group</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">entry</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">Data</span><span class="p">):</span>
                <span class="n">given_data_entry_ids</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">entry</span><span class="o">.</span><span class="n">pk</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">entry</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">ProcessNode</span><span class="p">):</span>
                <span class="n">given_calculation_entry_ids</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">entry</span><span class="o">.</span><span class="n">pk</span><span class="p">)</span>

    <span class="c1"># We will iteratively explore the AiiDA graph to find further nodes that</span>
    <span class="c1"># should also be exported.</span>

    <span class="c1"># We repeat until there are no further nodes to be visited</span>
    <span class="k">while</span> <span class="n">given_calculation_entry_ids</span> <span class="ow">or</span> <span class="n">given_data_entry_ids</span><span class="p">:</span>

        <span class="c1"># If is is a calculation node</span>
        <span class="k">if</span> <span class="n">given_calculation_entry_ids</span><span class="p">:</span>
            <span class="n">curr_node_id</span> <span class="o">=</span> <span class="n">given_calculation_entry_ids</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="c1"># If it is already visited continue to the next node</span>
            <span class="k">if</span> <span class="n">curr_node_id</span> <span class="ow">in</span> <span class="n">to_be_exported</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="c1"># Otherwise say that it is a node to be exported</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">to_be_exported</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">curr_node_id</span><span class="p">)</span>

            <span class="c1"># INPUT(Data, ProcessNode) - Reversed</span>
            <span class="n">qb</span> <span class="o">=</span> <span class="n">QueryBuilder</span><span class="p">()</span>
            <span class="n">qb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Data</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="s1">&#39;predecessor&#39;</span><span class="p">,</span> <span class="n">project</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">])</span>
            <span class="n">qb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ProcessNode</span><span class="p">,</span> <span class="n">with_incoming</span><span class="o">=</span><span class="s1">&#39;predecessor&#39;</span><span class="p">,</span>
                      <span class="n">filters</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;id&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;==&#39;</span><span class="p">:</span> <span class="n">curr_node_id</span><span class="p">}},</span>
                      <span class="n">edge_filters</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">LinkType</span><span class="o">.</span><span class="n">INPUT_CALC</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">LinkType</span><span class="o">.</span><span class="n">INPUT_WORK</span><span class="o">.</span><span class="n">value</span><span class="p">]}})</span>
            <span class="n">res</span> <span class="o">=</span> <span class="p">{</span><span class="n">_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">qb</span><span class="o">.</span><span class="n">all</span><span class="p">()}</span>
            <span class="n">given_data_entry_ids</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">res</span> <span class="o">-</span> <span class="n">to_be_exported</span><span class="p">)</span>

            <span class="c1"># INPUT(Data, ProcessNode) - Forward</span>
            <span class="k">if</span> <span class="n">input_forward</span><span class="p">:</span>
                <span class="n">qb</span> <span class="o">=</span> <span class="n">QueryBuilder</span><span class="p">()</span>
                <span class="n">qb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Data</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="s1">&#39;predecessor&#39;</span><span class="p">,</span> <span class="n">project</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">],</span>
                          <span class="n">filters</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;id&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;==&#39;</span><span class="p">:</span> <span class="n">curr_node_id</span><span class="p">}})</span>
                <span class="n">qb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ProcessNode</span><span class="p">,</span> <span class="n">with_incoming</span><span class="o">=</span><span class="s1">&#39;predecessor&#39;</span><span class="p">,</span>
                      <span class="n">edge_filters</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">LinkType</span><span class="o">.</span><span class="n">INPUT_CALC</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">LinkType</span><span class="o">.</span><span class="n">INPUT_WORK</span><span class="o">.</span><span class="n">value</span><span class="p">]}})</span>
                <span class="n">res</span> <span class="o">=</span> <span class="p">{</span><span class="n">_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">qb</span><span class="o">.</span><span class="n">all</span><span class="p">()}</span>
                <span class="n">given_data_entry_ids</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">res</span> <span class="o">-</span> <span class="n">to_be_exported</span><span class="p">)</span>

            <span class="c1"># CREATE/RETURN(ProcessNode, Data) - Forward</span>
            <span class="n">qb</span> <span class="o">=</span> <span class="n">QueryBuilder</span><span class="p">()</span>
            <span class="n">qb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ProcessNode</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="s1">&#39;predecessor&#39;</span><span class="p">,</span>
                      <span class="n">filters</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;id&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;==&#39;</span><span class="p">:</span> <span class="n">curr_node_id</span><span class="p">}})</span>
            <span class="n">qb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Data</span><span class="p">,</span> <span class="n">with_incoming</span><span class="o">=</span><span class="s1">&#39;predecessor&#39;</span><span class="p">,</span> <span class="n">project</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">],</span>
                      <span class="n">edge_filters</span><span class="o">=</span><span class="p">{</span>
                          <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="p">{</span>
                              <span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">LinkType</span><span class="o">.</span><span class="n">CREATE</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                                     <span class="n">LinkType</span><span class="o">.</span><span class="n">RETURN</span><span class="o">.</span><span class="n">value</span><span class="p">]}})</span>
            <span class="n">res</span> <span class="o">=</span> <span class="p">{</span><span class="n">_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">qb</span><span class="o">.</span><span class="n">all</span><span class="p">()}</span>
            <span class="n">given_data_entry_ids</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">res</span> <span class="o">-</span> <span class="n">to_be_exported</span><span class="p">)</span>

            <span class="c1"># CREATE(ProcessNode, Data) - Reversed</span>
            <span class="k">if</span> <span class="n">create_reversed</span><span class="p">:</span>
                <span class="n">qb</span> <span class="o">=</span> <span class="n">QueryBuilder</span><span class="p">()</span>
                <span class="n">qb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ProcessNode</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="s1">&#39;predecessor&#39;</span><span class="p">)</span>
                <span class="n">qb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Data</span><span class="p">,</span> <span class="n">with_incoming</span><span class="o">=</span><span class="s1">&#39;predecessor&#39;</span><span class="p">,</span> <span class="n">project</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">],</span>
                          <span class="n">filters</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;id&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;==&#39;</span><span class="p">:</span> <span class="n">curr_node_id</span><span class="p">}},</span>
                          <span class="n">edge_filters</span><span class="o">=</span><span class="p">{</span>
                              <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="p">{</span>
                                  <span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">LinkType</span><span class="o">.</span><span class="n">CREATE</span><span class="o">.</span><span class="n">value</span><span class="p">]}})</span>
                <span class="n">res</span> <span class="o">=</span> <span class="p">{</span><span class="n">_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">qb</span><span class="o">.</span><span class="n">all</span><span class="p">()}</span>
                <span class="n">given_data_entry_ids</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">res</span> <span class="o">-</span> <span class="n">to_be_exported</span><span class="p">)</span>

            <span class="c1"># RETURN(ProcessNode, Data) - Reversed</span>
            <span class="k">if</span> <span class="n">return_reversed</span><span class="p">:</span>
                <span class="n">qb</span> <span class="o">=</span> <span class="n">QueryBuilder</span><span class="p">()</span>
                <span class="n">qb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ProcessNode</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="s1">&#39;predecessor&#39;</span><span class="p">)</span>
                <span class="n">qb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Data</span><span class="p">,</span> <span class="n">with_incoming</span><span class="o">=</span><span class="s1">&#39;predecessor&#39;</span><span class="p">,</span> <span class="n">project</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">],</span>
                          <span class="n">filters</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;id&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;==&#39;</span><span class="p">:</span> <span class="n">curr_node_id</span><span class="p">}},</span>
                          <span class="n">edge_filters</span><span class="o">=</span><span class="p">{</span>
                              <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="p">{</span>
                                  <span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">LinkType</span><span class="o">.</span><span class="n">RETURN</span><span class="o">.</span><span class="n">value</span><span class="p">]}})</span>
                <span class="n">res</span> <span class="o">=</span> <span class="p">{</span><span class="n">_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">qb</span><span class="o">.</span><span class="n">all</span><span class="p">()}</span>
                <span class="n">given_data_entry_ids</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">res</span> <span class="o">-</span> <span class="n">to_be_exported</span><span class="p">)</span>

            <span class="c1"># CALL(ProcessNode, ProcessNode) - Forward</span>
            <span class="n">qb</span> <span class="o">=</span> <span class="n">QueryBuilder</span><span class="p">()</span>
            <span class="n">qb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ProcessNode</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="s1">&#39;predecessor&#39;</span><span class="p">,</span>
                      <span class="n">filters</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;id&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;==&#39;</span><span class="p">:</span> <span class="n">curr_node_id</span><span class="p">}})</span>
            <span class="n">qb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ProcessNode</span><span class="p">,</span> <span class="n">with_incoming</span><span class="o">=</span><span class="s1">&#39;predecessor&#39;</span><span class="p">,</span> <span class="n">project</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">],</span>
                <span class="n">edge_filters</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">LinkType</span><span class="o">.</span><span class="n">CALL_CALC</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">LinkType</span><span class="o">.</span><span class="n">CALL_WORK</span><span class="o">.</span><span class="n">value</span><span class="p">]}})</span>
            <span class="n">res</span> <span class="o">=</span> <span class="p">{</span><span class="n">_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">qb</span><span class="o">.</span><span class="n">all</span><span class="p">()}</span>
            <span class="n">given_calculation_entry_ids</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">res</span> <span class="o">-</span> <span class="n">to_be_exported</span><span class="p">)</span>

            <span class="c1"># CALL(ProcessNode, ProcessNode) - Reversed</span>
            <span class="k">if</span> <span class="n">call_reversed</span><span class="p">:</span>
                <span class="n">qb</span> <span class="o">=</span> <span class="n">QueryBuilder</span><span class="p">()</span>
                <span class="n">qb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ProcessNode</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="s1">&#39;predecessor&#39;</span><span class="p">)</span>
                <span class="n">qb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ProcessNode</span><span class="p">,</span> <span class="n">with_incoming</span><span class="o">=</span><span class="s1">&#39;predecessor&#39;</span><span class="p">,</span> <span class="n">project</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">],</span>
                    <span class="n">filters</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;id&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;==&#39;</span><span class="p">:</span> <span class="n">curr_node_id</span><span class="p">}},</span>
                    <span class="n">edge_filters</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">LinkType</span><span class="o">.</span><span class="n">CALL_CALC</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">LinkType</span><span class="o">.</span><span class="n">CALL_WORK</span><span class="o">.</span><span class="n">value</span><span class="p">]}})</span>
                <span class="n">res</span> <span class="o">=</span> <span class="p">{</span><span class="n">_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">qb</span><span class="o">.</span><span class="n">all</span><span class="p">()}</span>
                <span class="n">given_calculation_entry_ids</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">res</span> <span class="o">-</span> <span class="n">to_be_exported</span><span class="p">)</span>


        <span class="c1"># If it is a Data node</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">curr_node_id</span> <span class="o">=</span> <span class="n">given_data_entry_ids</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="c1"># If it is already visited continue to the next node</span>
            <span class="k">if</span> <span class="n">curr_node_id</span> <span class="ow">in</span> <span class="n">to_be_exported</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="c1"># Otherwise say that it is a node to be exported</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">to_be_exported</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">curr_node_id</span><span class="p">)</span>

            <span class="c1"># Case 2:</span>
            <span class="c1"># CREATE(ProcessNode, Data) - Reversed</span>
            <span class="k">if</span> <span class="n">create_reversed</span><span class="p">:</span>
                <span class="n">qb</span> <span class="o">=</span> <span class="n">QueryBuilder</span><span class="p">()</span>
                <span class="n">qb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ProcessNode</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="s1">&#39;predecessor&#39;</span><span class="p">,</span> <span class="n">project</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">])</span>
                <span class="n">qb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Data</span><span class="p">,</span> <span class="n">with_incoming</span><span class="o">=</span><span class="s1">&#39;predecessor&#39;</span><span class="p">,</span>
                          <span class="n">filters</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;id&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;==&#39;</span><span class="p">:</span> <span class="n">curr_node_id</span><span class="p">}},</span>
                          <span class="n">edge_filters</span><span class="o">=</span><span class="p">{</span>
                              <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="p">{</span>
                                  <span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">LinkType</span><span class="o">.</span><span class="n">CREATE</span><span class="o">.</span><span class="n">value</span><span class="p">]}})</span>
                <span class="n">res</span> <span class="o">=</span> <span class="p">{</span><span class="n">_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">qb</span><span class="o">.</span><span class="n">all</span><span class="p">()}</span>
                <span class="n">given_calculation_entry_ids</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">res</span> <span class="o">-</span> <span class="n">to_be_exported</span><span class="p">)</span>

            <span class="c1"># Case 3:</span>
            <span class="c1"># RETURN(ProcessNode, Data) - Reversed</span>
            <span class="k">if</span> <span class="n">return_reversed</span><span class="p">:</span>
                <span class="n">qb</span> <span class="o">=</span> <span class="n">QueryBuilder</span><span class="p">()</span>
                <span class="n">qb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ProcessNode</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="s1">&#39;predecessor&#39;</span><span class="p">,</span> <span class="n">project</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">])</span>
                <span class="n">qb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Data</span><span class="p">,</span> <span class="n">with_incoming</span><span class="o">=</span><span class="s1">&#39;predecessor&#39;</span><span class="p">,</span>
                          <span class="n">filters</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;id&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;==&#39;</span><span class="p">:</span> <span class="n">curr_node_id</span><span class="p">}},</span>
                          <span class="n">edge_filters</span><span class="o">=</span><span class="p">{</span>
                              <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="p">{</span>
                                  <span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">LinkType</span><span class="o">.</span><span class="n">RETURN</span><span class="o">.</span><span class="n">value</span><span class="p">]}})</span>
                <span class="n">res</span> <span class="o">=</span> <span class="p">{</span><span class="n">_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">qb</span><span class="o">.</span><span class="n">all</span><span class="p">()}</span>
                <span class="n">given_calculation_entry_ids</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">res</span> <span class="o">-</span> <span class="n">to_be_exported</span><span class="p">)</span>

    <span class="c1">## Universal &quot;entities&quot; attributed to all types of nodes</span>
    <span class="c1"># Logs</span>
    <span class="k">if</span> <span class="n">include_logs</span> <span class="ow">and</span> <span class="n">to_be_exported</span><span class="p">:</span>
        <span class="c1"># Get related log(s) - universal for all nodes</span>
        <span class="n">builder</span> <span class="o">=</span> <span class="n">QueryBuilder</span><span class="p">()</span>
        <span class="n">builder</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Log</span><span class="p">,</span> <span class="n">filters</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dbnode_id&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="n">to_be_exported</span><span class="p">}},</span> <span class="n">project</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">])</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">{</span><span class="n">_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">builder</span><span class="o">.</span><span class="n">all</span><span class="p">()}</span>
        <span class="n">given_log_entry_ids</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>

    <span class="c1"># Comments</span>
    <span class="k">if</span> <span class="n">include_comments</span> <span class="ow">and</span> <span class="n">to_be_exported</span><span class="p">:</span>
        <span class="c1"># Get related log(s) - universal for all nodes</span>
        <span class="n">builder</span> <span class="o">=</span> <span class="n">QueryBuilder</span><span class="p">()</span>
        <span class="n">builder</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Comment</span><span class="p">,</span> <span class="n">filters</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;dbnode_id&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="n">to_be_exported</span><span class="p">}},</span> <span class="n">project</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">])</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">{</span><span class="n">_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">builder</span><span class="o">.</span><span class="n">all</span><span class="p">()}</span>
        <span class="n">given_comment_entry_ids</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>

    <span class="c1"># Here we get all the columns that we plan to project per entity that we</span>
    <span class="c1"># would like to extract</span>
    <span class="n">given_entities</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">given_group_entry_ids</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">given_entities</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">GROUP_ENTITY_NAME</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_be_exported</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">given_entities</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">NODE_ENTITY_NAME</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">given_computer_entry_ids</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">given_entities</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">COMPUTER_ENTITY_NAME</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">given_log_entry_ids</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">given_entities</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">LOG_ENTITY_NAME</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">given_comment_entry_ids</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">given_entities</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">COMMENT_ENTITY_NAME</span><span class="p">)</span>

    <span class="n">entries_to_add</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">given_entity</span> <span class="ow">in</span> <span class="n">given_entities</span><span class="p">:</span>
        <span class="n">project_cols</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span>
        <span class="c1"># The following gets a list of fields that we need,</span>
        <span class="c1"># e.g. user, mtime, uuid, computer</span>
        <span class="n">entity_prop</span> <span class="o">=</span> <span class="n">all_fields_info</span><span class="p">[</span><span class="n">given_entity</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

        <span class="c1"># Here we do the necessary renaming of properties</span>
        <span class="k">for</span> <span class="n">prop</span> <span class="ow">in</span> <span class="n">entity_prop</span><span class="p">:</span>
            <span class="c1"># nprop contains the list of projections</span>
            <span class="n">nprop</span> <span class="o">=</span> <span class="p">(</span><span class="n">file_fields_to_model_fields</span><span class="p">[</span><span class="n">given_entity</span><span class="p">][</span><span class="n">prop</span><span class="p">]</span>
                     <span class="k">if</span> <span class="n">prop</span> <span class="ow">in</span> <span class="n">file_fields_to_model_fields</span><span class="p">[</span><span class="n">given_entity</span><span class="p">]</span>
                     <span class="k">else</span> <span class="n">prop</span><span class="p">)</span>
            <span class="n">project_cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nprop</span><span class="p">)</span>

        <span class="c1"># Getting the ids that correspond to the right entity</span>
        <span class="k">if</span> <span class="n">given_entity</span> <span class="o">==</span> <span class="n">GROUP_ENTITY_NAME</span><span class="p">:</span>
            <span class="n">entry_ids_to_add</span> <span class="o">=</span> <span class="n">given_group_entry_ids</span>
        <span class="k">elif</span> <span class="n">given_entity</span> <span class="o">==</span> <span class="n">NODE_ENTITY_NAME</span><span class="p">:</span>
            <span class="n">entry_ids_to_add</span> <span class="o">=</span> <span class="n">to_be_exported</span>
        <span class="k">elif</span> <span class="n">given_entity</span> <span class="o">==</span> <span class="n">COMPUTER_ENTITY_NAME</span><span class="p">:</span>
            <span class="n">entry_ids_to_add</span> <span class="o">=</span> <span class="n">given_computer_entry_ids</span>
        <span class="k">elif</span> <span class="n">given_entity</span> <span class="o">==</span> <span class="n">LOG_ENTITY_NAME</span><span class="p">:</span>
            <span class="n">entry_ids_to_add</span> <span class="o">=</span> <span class="n">given_log_entry_ids</span>
        <span class="k">elif</span> <span class="n">given_entity</span> <span class="o">==</span> <span class="n">COMMENT_ENTITY_NAME</span><span class="p">:</span>
            <span class="n">entry_ids_to_add</span> <span class="o">=</span> <span class="n">given_comment_entry_ids</span>

        <span class="n">qb</span> <span class="o">=</span> <span class="n">QueryBuilder</span><span class="p">()</span>
        <span class="n">qb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entity_names_to_entities</span><span class="p">[</span><span class="n">given_entity</span><span class="p">],</span>
                  <span class="n">filters</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;in&quot;</span><span class="p">:</span> <span class="n">entry_ids_to_add</span><span class="p">}},</span>
                  <span class="n">project</span><span class="o">=</span><span class="n">project_cols</span><span class="p">,</span>
                  <span class="n">tag</span><span class="o">=</span><span class="n">given_entity</span><span class="p">,</span> <span class="n">outerjoin</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">entries_to_add</span><span class="p">[</span><span class="n">given_entity</span><span class="p">]</span> <span class="o">=</span> <span class="n">qb</span>

    <span class="c1"># TODO (Spyros) To see better! Especially for functional licenses</span>
    <span class="c1"># Check the licenses of exported data.</span>
    <span class="k">if</span> <span class="n">allowed_licenses</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">forbidden_licenses</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">qb</span> <span class="o">=</span> <span class="n">QueryBuilder</span><span class="p">()</span>
        <span class="n">qb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Node</span><span class="p">,</span> <span class="n">project</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="s2">&quot;attributes.source.license&quot;</span><span class="p">],</span>
                  <span class="n">filters</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;in&quot;</span><span class="p">:</span> <span class="n">to_be_exported</span><span class="p">}})</span>
        <span class="c1"># Skip those nodes where the license is not set (this is the standard behavior with Django)</span>
        <span class="n">node_licenses</span> <span class="o">=</span> <span class="nb">list</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span> <span class="ow">in</span> <span class="n">qb</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="k">if</span> <span class="n">b</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">check_licences</span><span class="p">(</span><span class="n">node_licenses</span><span class="p">,</span> <span class="n">allowed_licenses</span><span class="p">,</span> <span class="n">forbidden_licenses</span><span class="p">)</span>

    <span class="c1">############################################################</span>
    <span class="c1">##### Start automatic recursive export data generation #####</span>
    <span class="c1">############################################################</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">silent</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;STORING DATABASE ENTRIES...&quot;</span><span class="p">)</span>

    <span class="n">export_data</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">entity_separator</span> <span class="o">=</span> <span class="s1">&#39;_&#39;</span>
    <span class="k">for</span> <span class="n">entity_name</span><span class="p">,</span> <span class="n">partial_query</span> <span class="ow">in</span> <span class="n">entries_to_add</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

        <span class="n">foreign_fields</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span>
                          <span class="n">all_fields_info</span><span class="p">[</span><span class="n">entity_name</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                          <span class="c1"># all_fields_info[model_name].items()</span>
                          <span class="k">if</span> <span class="s1">&#39;requires&#39;</span> <span class="ow">in</span> <span class="n">v</span><span class="p">}</span>

        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">foreign_fields</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">ref_model_name</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="s1">&#39;requires&#39;</span><span class="p">]</span>
            <span class="n">fill_in_query</span><span class="p">(</span><span class="n">partial_query</span><span class="p">,</span> <span class="n">entity_name</span><span class="p">,</span> <span class="n">ref_model_name</span><span class="p">,</span>
                          <span class="p">[</span><span class="n">entity_name</span><span class="p">],</span> <span class="n">entity_separator</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">temp_d</span> <span class="ow">in</span> <span class="n">partial_query</span><span class="o">.</span><span class="n">iterdict</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">temp_d</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="c1"># Get current entity</span>
                <span class="n">current_entity</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">entity_separator</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                <span class="c1"># This is a empty result of an outer join.</span>
                <span class="c1"># It should not be taken into account.</span>
                <span class="k">if</span> <span class="n">temp_d</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;id&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="n">temp_d2</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="n">temp_d</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="s2">&quot;id&quot;</span><span class="p">]:</span>
                        <span class="n">serialize_dict</span><span class="p">(</span><span class="n">temp_d</span><span class="p">[</span><span class="n">k</span><span class="p">],</span>
                                       <span class="n">remove_fields</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">],</span>
                                       <span class="n">rename_fields</span><span class="o">=</span>
                                       <span class="n">model_fields_to_file_fields</span><span class="p">[</span><span class="n">current_entity</span><span class="p">])}</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">export_data</span><span class="p">[</span><span class="n">current_entity</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">temp_d2</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="n">export_data</span><span class="p">[</span><span class="n">current_entity</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp_d2</span>

    <span class="c1">######################################</span>
    <span class="c1"># Manually manage links and attributes</span>
    <span class="c1">######################################</span>
    <span class="c1"># I use .get because there may be no nodes to export</span>
    <span class="n">all_nodes_pk</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">NODE_ENTITY_NAME</span> <span class="ow">in</span> <span class="n">export_data</span><span class="p">:</span>
        <span class="n">all_nodes_pk</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">export_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">NODE_ENTITY_NAME</span><span class="p">)</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">model_data</span><span class="p">)</span> <span class="k">for</span> <span class="n">model_data</span> <span class="ow">in</span> <span class="n">export_data</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">silent</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No nodes to store, exiting...&quot;</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">silent</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Exporting a total of </span><span class="si">{}</span><span class="s2"> db entries, of which </span><span class="si">{}</span><span class="s2"> nodes.&quot;</span>
              <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">model_data</span><span class="p">)</span> <span class="k">for</span> <span class="n">model_data</span> <span class="ow">in</span> <span class="n">export_data</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span>
                      <span class="nb">len</span><span class="p">(</span><span class="n">all_nodes_pk</span><span class="p">)))</span>

    <span class="c1">## ATTRIBUTES</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">silent</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;STORING NODE ATTRIBUTES...&quot;</span><span class="p">)</span>
    <span class="n">node_attributes</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">node_attributes_conversion</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># A second QueryBuilder query to get the attributes. See if this can be</span>
    <span class="c1"># optimized</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_nodes_pk</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">all_nodes_query</span> <span class="o">=</span> <span class="n">QueryBuilder</span><span class="p">()</span>
        <span class="n">all_nodes_query</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Node</span><span class="p">,</span> <span class="n">filters</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;in&quot;</span><span class="p">:</span> <span class="n">all_nodes_pk</span><span class="p">}},</span>
                               <span class="n">project</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;*&quot;</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="n">all_nodes_query</span><span class="o">.</span><span class="n">iterall</span><span class="p">():</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="p">(</span><span class="n">node_attributes</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">pk</span><span class="p">)],</span>
             <span class="n">node_attributes_conversion</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">pk</span><span class="p">)])</span> <span class="o">=</span> <span class="n">serialize_dict</span><span class="p">(</span>
                <span class="n">n</span><span class="o">.</span><span class="n">attributes</span><span class="p">,</span> <span class="n">track_conversion</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1">## EXTRAS</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">silent</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;STORING NODE EXTRAS...&quot;</span><span class="p">)</span>
    <span class="n">node_extras</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">node_extras_conversion</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># A second QueryBuilder query to get the extras. See if this can be</span>
    <span class="c1"># optimized</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_nodes_pk</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">all_nodes_query</span> <span class="o">=</span> <span class="n">QueryBuilder</span><span class="p">()</span>
        <span class="n">all_nodes_query</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Node</span><span class="p">,</span> <span class="n">filters</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;in&quot;</span><span class="p">:</span> <span class="n">all_nodes_pk</span><span class="p">}},</span>
                               <span class="n">project</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;*&quot;</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="n">all_nodes_query</span><span class="o">.</span><span class="n">iterall</span><span class="p">():</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="p">(</span><span class="n">node_extras</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">pk</span><span class="p">)],</span>
             <span class="n">node_extras_conversion</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">pk</span><span class="p">)])</span> <span class="o">=</span> <span class="n">serialize_dict</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">extras</span><span class="p">,</span> <span class="n">track_conversion</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">silent</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;STORING NODE LINKS...&quot;</span><span class="p">)</span>

    <span class="n">links_uuid_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_nodes_pk</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># INPUT (Data, ProcessNode) - Forward, by the ProcessNode node</span>
        <span class="k">if</span> <span class="n">input_forward</span><span class="p">:</span>
            <span class="c1"># INPUT (Data, ProcessNode)</span>
            <span class="n">links_qb</span> <span class="o">=</span> <span class="n">QueryBuilder</span><span class="p">()</span>
            <span class="n">links_qb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Data</span><span class="p">,</span>
                            <span class="n">project</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;uuid&#39;</span><span class="p">],</span> <span class="n">tag</span><span class="o">=</span><span class="s1">&#39;input&#39;</span><span class="p">,</span>
                            <span class="n">filters</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;id&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="n">all_nodes_pk</span><span class="p">}})</span>
            <span class="n">links_qb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ProcessNode</span><span class="p">,</span>
                            <span class="n">project</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;uuid&#39;</span><span class="p">],</span> <span class="n">tag</span><span class="o">=</span><span class="s1">&#39;output&#39;</span><span class="p">,</span>
                            <span class="n">edge_filters</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">LinkType</span><span class="o">.</span><span class="n">INPUT_CALC</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">LinkType</span><span class="o">.</span><span class="n">INPUT_WORK</span><span class="o">.</span><span class="n">value</span><span class="p">]}},</span>
                            <span class="n">edge_project</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">,</span> <span class="s1">&#39;type&#39;</span><span class="p">],</span> <span class="n">with_incoming</span><span class="o">=</span><span class="s1">&#39;input&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">input_uuid</span><span class="p">,</span> <span class="n">output_uuid</span><span class="p">,</span> <span class="n">link_label</span><span class="p">,</span> <span class="n">link_type</span> <span class="ow">in</span> <span class="n">links_qb</span><span class="o">.</span><span class="n">iterall</span><span class="p">():</span>
                <span class="n">val</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s1">&#39;input&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">input_uuid</span><span class="p">),</span>
                    <span class="s1">&#39;output&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">output_uuid</span><span class="p">),</span>
                    <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">link_label</span><span class="p">),</span>
                    <span class="s1">&#39;type&#39;</span><span class="p">:</span><span class="nb">str</span><span class="p">(</span><span class="n">link_type</span><span class="p">)</span>
                <span class="p">}</span>
                <span class="n">links_uuid_dict</span><span class="p">[</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">items</span><span class="p">())]</span> <span class="o">=</span> <span class="n">val</span>

        <span class="c1"># INPUT (Data, ProcessNode) - Backward, by the ProcessNode node</span>
        <span class="n">links_qb</span> <span class="o">=</span> <span class="n">QueryBuilder</span><span class="p">()</span>
        <span class="n">links_qb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Data</span><span class="p">,</span>
                        <span class="n">project</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;uuid&#39;</span><span class="p">],</span> <span class="n">tag</span><span class="o">=</span><span class="s1">&#39;input&#39;</span><span class="p">)</span>
        <span class="n">links_qb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ProcessNode</span><span class="p">,</span>
                        <span class="n">project</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;uuid&#39;</span><span class="p">],</span> <span class="n">tag</span><span class="o">=</span><span class="s1">&#39;output&#39;</span><span class="p">,</span>
                        <span class="n">filters</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;id&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="n">all_nodes_pk</span><span class="p">}},</span>
                        <span class="n">edge_filters</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">LinkType</span><span class="o">.</span><span class="n">INPUT_CALC</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">LinkType</span><span class="o">.</span><span class="n">INPUT_WORK</span><span class="o">.</span><span class="n">value</span><span class="p">]}},</span>
                        <span class="n">edge_project</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">,</span> <span class="s1">&#39;type&#39;</span><span class="p">],</span> <span class="n">with_incoming</span><span class="o">=</span><span class="s1">&#39;input&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">input_uuid</span><span class="p">,</span> <span class="n">output_uuid</span><span class="p">,</span> <span class="n">link_label</span><span class="p">,</span> <span class="n">link_type</span> <span class="ow">in</span> <span class="n">links_qb</span><span class="o">.</span><span class="n">iterall</span><span class="p">():</span>
            <span class="n">val</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;input&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">input_uuid</span><span class="p">),</span>
                <span class="s1">&#39;output&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">output_uuid</span><span class="p">),</span>
                <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">link_label</span><span class="p">),</span>
                <span class="s1">&#39;type&#39;</span><span class="p">:</span><span class="nb">str</span><span class="p">(</span><span class="n">link_type</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="n">links_uuid_dict</span><span class="p">[</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">items</span><span class="p">())]</span> <span class="o">=</span> <span class="n">val</span>

        <span class="c1"># CREATE (ProcessNode, Data) - Forward, by the ProcessNode node</span>
        <span class="n">links_qb</span> <span class="o">=</span> <span class="n">QueryBuilder</span><span class="p">()</span>
        <span class="n">links_qb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ProcessNode</span><span class="p">,</span>
                        <span class="n">project</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;uuid&#39;</span><span class="p">],</span> <span class="n">tag</span><span class="o">=</span><span class="s1">&#39;input&#39;</span><span class="p">,</span>
                        <span class="n">filters</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;id&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="n">all_nodes_pk</span><span class="p">}})</span>
        <span class="n">links_qb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Data</span><span class="p">,</span>
                        <span class="n">project</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;uuid&#39;</span><span class="p">],</span> <span class="n">tag</span><span class="o">=</span><span class="s1">&#39;output&#39;</span><span class="p">,</span>
                        <span class="n">edge_filters</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;==&#39;</span><span class="p">:</span> <span class="n">LinkType</span><span class="o">.</span><span class="n">CREATE</span><span class="o">.</span><span class="n">value</span><span class="p">}},</span>
                        <span class="n">edge_project</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">,</span> <span class="s1">&#39;type&#39;</span><span class="p">],</span> <span class="n">with_incoming</span><span class="o">=</span><span class="s1">&#39;input&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">input_uuid</span><span class="p">,</span> <span class="n">output_uuid</span><span class="p">,</span> <span class="n">link_label</span><span class="p">,</span> <span class="n">link_type</span> <span class="ow">in</span> <span class="n">links_qb</span><span class="o">.</span><span class="n">iterall</span><span class="p">():</span>
            <span class="n">val</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;input&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">input_uuid</span><span class="p">),</span>
                <span class="s1">&#39;output&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">output_uuid</span><span class="p">),</span>
                <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">link_label</span><span class="p">),</span>
                <span class="s1">&#39;type&#39;</span><span class="p">:</span><span class="nb">str</span><span class="p">(</span><span class="n">link_type</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="n">links_uuid_dict</span><span class="p">[</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">items</span><span class="p">())]</span> <span class="o">=</span> <span class="n">val</span>

        <span class="c1"># CREATE (ProcessNode, Data) - Backward, by the Data node</span>
        <span class="k">if</span> <span class="n">create_reversed</span><span class="p">:</span>
            <span class="n">links_qb</span> <span class="o">=</span> <span class="n">QueryBuilder</span><span class="p">()</span>
            <span class="n">links_qb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ProcessNode</span><span class="p">,</span>
                            <span class="n">project</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;uuid&#39;</span><span class="p">],</span> <span class="n">tag</span><span class="o">=</span><span class="s1">&#39;input&#39;</span><span class="p">,</span>
                            <span class="n">filters</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;id&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="n">all_nodes_pk</span><span class="p">}})</span>
            <span class="n">links_qb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Data</span><span class="p">,</span>
                            <span class="n">project</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;uuid&#39;</span><span class="p">],</span> <span class="n">tag</span><span class="o">=</span><span class="s1">&#39;output&#39;</span><span class="p">,</span>
                            <span class="n">edge_filters</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;==&#39;</span><span class="p">:</span> <span class="n">LinkType</span><span class="o">.</span><span class="n">CREATE</span><span class="o">.</span><span class="n">value</span><span class="p">}},</span>
                            <span class="n">edge_project</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">,</span> <span class="s1">&#39;type&#39;</span><span class="p">],</span> <span class="n">with_incoming</span><span class="o">=</span><span class="s1">&#39;input&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">input_uuid</span><span class="p">,</span> <span class="n">output_uuid</span><span class="p">,</span> <span class="n">link_label</span><span class="p">,</span> <span class="n">link_type</span> <span class="ow">in</span> <span class="n">links_qb</span><span class="o">.</span><span class="n">iterall</span><span class="p">():</span>
                <span class="n">val</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s1">&#39;input&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">input_uuid</span><span class="p">),</span>
                    <span class="s1">&#39;output&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">output_uuid</span><span class="p">),</span>
                    <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">link_label</span><span class="p">),</span>
                    <span class="s1">&#39;type&#39;</span><span class="p">:</span><span class="nb">str</span><span class="p">(</span><span class="n">link_type</span><span class="p">)</span>
                <span class="p">}</span>
                <span class="n">links_uuid_dict</span><span class="p">[</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">items</span><span class="p">())]</span> <span class="o">=</span> <span class="n">val</span>

        <span class="c1"># RETURN (ProcessNode, Data) - Forward, by the ProcessNode node</span>
        <span class="n">links_qb</span> <span class="o">=</span> <span class="n">QueryBuilder</span><span class="p">()</span>
        <span class="n">links_qb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ProcessNode</span><span class="p">,</span>
                        <span class="n">project</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;uuid&#39;</span><span class="p">],</span> <span class="n">tag</span><span class="o">=</span><span class="s1">&#39;input&#39;</span><span class="p">,</span>
                        <span class="n">filters</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;id&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="n">all_nodes_pk</span><span class="p">}})</span>
        <span class="n">links_qb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Data</span><span class="p">,</span>
                        <span class="n">project</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;uuid&#39;</span><span class="p">],</span> <span class="n">tag</span><span class="o">=</span><span class="s1">&#39;output&#39;</span><span class="p">,</span>
                        <span class="n">edge_filters</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;==&#39;</span><span class="p">:</span> <span class="n">LinkType</span><span class="o">.</span><span class="n">RETURN</span><span class="o">.</span><span class="n">value</span><span class="p">}},</span>
                        <span class="n">edge_project</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">,</span> <span class="s1">&#39;type&#39;</span><span class="p">],</span> <span class="n">with_incoming</span><span class="o">=</span><span class="s1">&#39;input&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">input_uuid</span><span class="p">,</span> <span class="n">output_uuid</span><span class="p">,</span> <span class="n">link_label</span><span class="p">,</span> <span class="n">link_type</span> <span class="ow">in</span> <span class="n">links_qb</span><span class="o">.</span><span class="n">iterall</span><span class="p">():</span>
            <span class="n">val</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;input&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">input_uuid</span><span class="p">),</span>
                <span class="s1">&#39;output&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">output_uuid</span><span class="p">),</span>
                <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">link_label</span><span class="p">),</span>
                <span class="s1">&#39;type&#39;</span><span class="p">:</span><span class="nb">str</span><span class="p">(</span><span class="n">link_type</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="n">links_uuid_dict</span><span class="p">[</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">items</span><span class="p">())]</span> <span class="o">=</span> <span class="n">val</span>

        <span class="c1"># RETURN (ProcessNode, Data) - Backward, by the Data node</span>
        <span class="k">if</span> <span class="n">return_reversed</span><span class="p">:</span>
            <span class="n">links_qb</span> <span class="o">=</span> <span class="n">QueryBuilder</span><span class="p">()</span>
            <span class="n">links_qb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ProcessNode</span><span class="p">,</span>
                            <span class="n">project</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;uuid&#39;</span><span class="p">],</span> <span class="n">tag</span><span class="o">=</span><span class="s1">&#39;input&#39;</span><span class="p">)</span>
            <span class="n">links_qb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Data</span><span class="p">,</span>
                            <span class="n">project</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;uuid&#39;</span><span class="p">],</span> <span class="n">tag</span><span class="o">=</span><span class="s1">&#39;output&#39;</span><span class="p">,</span>
                            <span class="n">filters</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;id&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="n">all_nodes_pk</span><span class="p">}},</span>
                            <span class="n">edge_filters</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;==&#39;</span><span class="p">:</span> <span class="n">LinkType</span><span class="o">.</span><span class="n">RETURN</span><span class="o">.</span><span class="n">value</span><span class="p">}},</span>
                            <span class="n">edge_project</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">,</span> <span class="s1">&#39;type&#39;</span><span class="p">],</span> <span class="n">with_incoming</span><span class="o">=</span><span class="s1">&#39;input&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">input_uuid</span><span class="p">,</span> <span class="n">output_uuid</span><span class="p">,</span> <span class="n">link_label</span><span class="p">,</span> <span class="n">link_type</span> <span class="ow">in</span> <span class="n">links_qb</span><span class="o">.</span><span class="n">iterall</span><span class="p">():</span>
                <span class="n">val</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s1">&#39;input&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">input_uuid</span><span class="p">),</span>
                    <span class="s1">&#39;output&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">output_uuid</span><span class="p">),</span>
                    <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">link_label</span><span class="p">),</span>
                    <span class="s1">&#39;type&#39;</span><span class="p">:</span><span class="nb">str</span><span class="p">(</span><span class="n">link_type</span><span class="p">)</span>
                <span class="p">}</span>
                <span class="n">links_uuid_dict</span><span class="p">[</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">items</span><span class="p">())]</span> <span class="o">=</span> <span class="n">val</span>

        <span class="c1"># CALL (ProcessNode [caller], ProcessNode [called]) - Forward, by</span>
        <span class="c1"># the ProcessNode node</span>
        <span class="n">links_qb</span> <span class="o">=</span> <span class="n">QueryBuilder</span><span class="p">()</span>
        <span class="n">links_qb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ProcessNode</span><span class="p">,</span>
                        <span class="n">project</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;uuid&#39;</span><span class="p">],</span> <span class="n">tag</span><span class="o">=</span><span class="s1">&#39;input&#39;</span><span class="p">,</span>
                        <span class="n">filters</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;id&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="n">all_nodes_pk</span><span class="p">}})</span>
        <span class="n">links_qb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ProcessNode</span><span class="p">,</span>
                        <span class="n">project</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;uuid&#39;</span><span class="p">],</span> <span class="n">tag</span><span class="o">=</span><span class="s1">&#39;output&#39;</span><span class="p">,</span>
                        <span class="n">edge_filters</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">LinkType</span><span class="o">.</span><span class="n">CALL_CALC</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">LinkType</span><span class="o">.</span><span class="n">CALL_WORK</span><span class="o">.</span><span class="n">value</span><span class="p">]}},</span>
                        <span class="n">edge_project</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">,</span> <span class="s1">&#39;type&#39;</span><span class="p">],</span> <span class="n">with_incoming</span><span class="o">=</span><span class="s1">&#39;input&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">input_uuid</span><span class="p">,</span> <span class="n">output_uuid</span><span class="p">,</span> <span class="n">link_label</span><span class="p">,</span> <span class="n">link_type</span> <span class="ow">in</span> <span class="n">links_qb</span><span class="o">.</span><span class="n">iterall</span><span class="p">():</span>
            <span class="n">val</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;input&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">input_uuid</span><span class="p">),</span>
                <span class="s1">&#39;output&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">output_uuid</span><span class="p">),</span>
                <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">link_label</span><span class="p">),</span>
                <span class="s1">&#39;type&#39;</span><span class="p">:</span><span class="nb">str</span><span class="p">(</span><span class="n">link_type</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="n">links_uuid_dict</span><span class="p">[</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">items</span><span class="p">())]</span> <span class="o">=</span> <span class="n">val</span>

        <span class="c1"># CALL (ProcessNode [caller], ProcessNode [called]) - Backward,</span>
        <span class="c1"># by the ProcessNode [called] node</span>
        <span class="k">if</span> <span class="n">call_reversed</span><span class="p">:</span>
            <span class="n">links_qb</span> <span class="o">=</span> <span class="n">QueryBuilder</span><span class="p">()</span>
            <span class="n">links_qb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ProcessNode</span><span class="p">,</span>
                            <span class="n">project</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;uuid&#39;</span><span class="p">],</span> <span class="n">tag</span><span class="o">=</span><span class="s1">&#39;input&#39;</span><span class="p">)</span>
            <span class="n">links_qb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ProcessNode</span><span class="p">,</span>
                            <span class="n">project</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;uuid&#39;</span><span class="p">],</span> <span class="n">tag</span><span class="o">=</span><span class="s1">&#39;output&#39;</span><span class="p">,</span>
                            <span class="n">filters</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;id&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="n">all_nodes_pk</span><span class="p">}},</span>
                            <span class="n">edge_filters</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;in&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">LinkType</span><span class="o">.</span><span class="n">CALL_CALC</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">LinkType</span><span class="o">.</span><span class="n">CALL_WORK</span><span class="o">.</span><span class="n">value</span><span class="p">]}},</span>
                            <span class="n">edge_project</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">,</span> <span class="s1">&#39;type&#39;</span><span class="p">],</span> <span class="n">with_incoming</span><span class="o">=</span><span class="s1">&#39;input&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">input_uuid</span><span class="p">,</span> <span class="n">output_uuid</span><span class="p">,</span> <span class="n">link_label</span><span class="p">,</span> <span class="n">link_type</span> <span class="ow">in</span> <span class="n">links_qb</span><span class="o">.</span><span class="n">iterall</span><span class="p">():</span>
                <span class="n">val</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s1">&#39;input&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">input_uuid</span><span class="p">),</span>
                    <span class="s1">&#39;output&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">output_uuid</span><span class="p">),</span>
                    <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">link_label</span><span class="p">),</span>
                    <span class="s1">&#39;type&#39;</span><span class="p">:</span><span class="nb">str</span><span class="p">(</span><span class="n">link_type</span><span class="p">)</span>
                <span class="p">}</span>
                <span class="n">links_uuid_dict</span><span class="p">[</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">items</span><span class="p">())]</span> <span class="o">=</span> <span class="n">val</span>

    <span class="n">links_uuid</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">links_uuid_dict</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">silent</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;STORING GROUP ELEMENTS...&quot;</span><span class="p">)</span>
    <span class="n">groups_uuid</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="c1"># If a group is in the exported date, we export the group/node correlation</span>
    <span class="k">if</span> <span class="n">GROUP_ENTITY_NAME</span> <span class="ow">in</span> <span class="n">export_data</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">curr_group</span> <span class="ow">in</span> <span class="n">export_data</span><span class="p">[</span><span class="n">GROUP_ENTITY_NAME</span><span class="p">]:</span>
            <span class="n">group_uuid_qb</span> <span class="o">=</span> <span class="n">QueryBuilder</span><span class="p">()</span>
            <span class="n">group_uuid_qb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entity_names_to_entities</span><span class="p">[</span><span class="n">GROUP_ENTITY_NAME</span><span class="p">],</span>
                                 <span class="n">filters</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;id&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;==&#39;</span><span class="p">:</span> <span class="n">curr_group</span><span class="p">}},</span>
                                 <span class="n">project</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;uuid&#39;</span><span class="p">],</span> <span class="n">tag</span><span class="o">=</span><span class="s1">&#39;group&#39;</span><span class="p">)</span>
            <span class="n">group_uuid_qb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entity_names_to_entities</span><span class="p">[</span><span class="n">NODE_ENTITY_NAME</span><span class="p">],</span>
                                 <span class="n">project</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;uuid&#39;</span><span class="p">],</span> <span class="n">with_group</span><span class="o">=</span><span class="s1">&#39;group&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="n">group_uuid_qb</span><span class="o">.</span><span class="n">iterall</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">in</span> <span class="n">groups_uuid</span><span class="p">:</span>
                    <span class="n">groups_uuid</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">groups_uuid</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>

    <span class="c1">######################################</span>
    <span class="c1"># Now I store</span>
    <span class="c1">######################################</span>
    <span class="c1"># subfolder inside the export package</span>
    <span class="n">nodesubfolder</span> <span class="o">=</span> <span class="n">folder</span><span class="o">.</span><span class="n">get_subfolder</span><span class="p">(</span><span class="s1">&#39;nodes&#39;</span><span class="p">,</span> <span class="n">create</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                         <span class="n">reset_limit</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Add the proper signatures to the exported data</span>
    <span class="k">for</span> <span class="n">entity_name</span> <span class="ow">in</span> <span class="n">export_data</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">export_data</span><span class="p">[</span><span class="n">entity_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">export_data</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">entity_name</span><span class="p">))</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">silent</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;STORING DATA...&quot;</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;node_attributes&#39;</span><span class="p">:</span> <span class="n">node_attributes</span><span class="p">,</span>
        <span class="s1">&#39;node_attributes_conversion&#39;</span><span class="p">:</span> <span class="n">node_attributes_conversion</span><span class="p">,</span>
        <span class="s1">&#39;node_extras&#39;</span><span class="p">:</span> <span class="n">node_extras</span><span class="p">,</span>
        <span class="s1">&#39;node_extras_conversion&#39;</span><span class="p">:</span> <span class="n">node_extras_conversion</span><span class="p">,</span>
        <span class="s1">&#39;export_data&#39;</span><span class="p">:</span> <span class="n">export_data</span><span class="p">,</span>
        <span class="s1">&#39;links_uuid&#39;</span><span class="p">:</span> <span class="n">links_uuid</span><span class="p">,</span>
        <span class="s1">&#39;groups_uuid&#39;</span><span class="p">:</span> <span class="n">groups_uuid</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="c1"># N.B. We&#39;re really calling zipfolder.open</span>
    <span class="k">with</span> <span class="n">folder</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;data.json&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fhandle</span><span class="p">:</span>
        <span class="c1"># fhandle.write(json.dumps(data, cls=UUIDEncoder))</span>
        <span class="n">fhandle</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>

    <span class="c1"># Add proper signature to unique identifiers &amp; all_fields_info</span>
    <span class="c1"># Ignore if a key doesn&#39;t exist in any of the two dictionaries</span>

    <span class="n">metadata</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;aiida_version&#39;</span><span class="p">:</span> <span class="n">aiida</span><span class="o">.</span><span class="n">get_version</span><span class="p">(),</span>
        <span class="s1">&#39;export_version&#39;</span><span class="p">:</span> <span class="n">EXPORT_VERSION</span><span class="p">,</span>
        <span class="s1">&#39;all_fields_info&#39;</span><span class="p">:</span> <span class="n">all_fields_info</span><span class="p">,</span>
        <span class="s1">&#39;unique_identifiers&#39;</span><span class="p">:</span> <span class="n">unique_identifiers</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">with</span> <span class="n">folder</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;metadata.json&#39;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fhandle</span><span class="p">:</span>
        <span class="n">fhandle</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">metadata</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">silent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">True</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;STORING FILES...&quot;</span><span class="p">)</span>

    <span class="c1"># If there are no nodes, there are no files to store</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_nodes_pk</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Large speed increase by not getting the node itself and looping in memory</span>
        <span class="c1"># in python, but just getting the uuid</span>
        <span class="n">uuid_query</span> <span class="o">=</span> <span class="n">QueryBuilder</span><span class="p">()</span>
        <span class="n">uuid_query</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Node</span><span class="p">,</span> <span class="n">filters</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;in&quot;</span><span class="p">:</span> <span class="n">all_nodes_pk</span><span class="p">}},</span>
                          <span class="n">project</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;uuid&quot;</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="n">uuid_query</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="n">uuid</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">sharded_uuid</span> <span class="o">=</span> <span class="n">export_shard_uuid</span><span class="p">(</span><span class="n">uuid</span><span class="p">)</span>

            <span class="c1"># Important to set create=False, otherwise creates</span>
            <span class="c1"># twice a subfolder. Maybe this is a bug of insert_path??</span>
            <span class="n">thisnodefolder</span> <span class="o">=</span> <span class="n">nodesubfolder</span><span class="o">.</span><span class="n">get_subfolder</span><span class="p">(</span>
                <span class="n">sharded_uuid</span><span class="p">,</span> <span class="n">create</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">reset_limit</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># In this way, I copy the content of the folder, and not the folder itself</span>
            <span class="n">src</span> <span class="o">=</span> <span class="n">RepositoryFolder</span><span class="p">(</span><span class="n">section</span><span class="o">=</span><span class="n">Repository</span><span class="o">.</span><span class="n">_section_name</span><span class="p">,</span> <span class="n">uuid</span><span class="o">=</span><span class="n">uuid</span><span class="p">)</span><span class="o">.</span><span class="n">abspath</span>
            <span class="n">thisnodefolder</span><span class="o">.</span><span class="n">insert_path</span><span class="p">(</span><span class="n">src</span><span class="o">=</span><span class="n">src</span><span class="p">,</span> <span class="n">dest_name</span><span class="o">=</span><span class="s1">&#39;.&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="check_licences"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.importexport.check_licences">[docs]</a><span class="k">def</span> <span class="nf">check_licences</span><span class="p">(</span><span class="n">node_licenses</span><span class="p">,</span> <span class="n">allowed_licenses</span><span class="p">,</span> <span class="n">forbidden_licenses</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">aiida.common.exceptions</span> <span class="k">import</span> <span class="n">LicensingException</span>
    <span class="kn">from</span> <span class="nn">inspect</span> <span class="k">import</span> <span class="n">isfunction</span>

    <span class="k">for</span> <span class="n">pk</span><span class="p">,</span> <span class="n">license</span> <span class="ow">in</span> <span class="n">node_licenses</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">allowed_licenses</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">isfunction</span><span class="p">(</span><span class="n">allowed_licenses</span><span class="p">):</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">allowed_licenses</span><span class="p">(</span><span class="n">license</span><span class="p">):</span>
                            <span class="k">raise</span> <span class="n">LicensingException</span>
                    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">LicensingException</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">license</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">allowed_licenses</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">LicensingException</span>
            <span class="k">except</span> <span class="n">LicensingException</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">LicensingException</span><span class="p">(</span><span class="s2">&quot;Node </span><span class="si">{}</span><span class="s2"> is licensed &quot;</span>
                                         <span class="s2">&quot;under </span><span class="si">{}</span><span class="s2"> license, which &quot;</span>
                                         <span class="s2">&quot;is not in the list of &quot;</span>
                                         <span class="s2">&quot;allowed licenses&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">pk</span><span class="p">,</span> <span class="n">license</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">forbidden_licenses</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">isfunction</span><span class="p">(</span><span class="n">forbidden_licenses</span><span class="p">):</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">forbidden_licenses</span><span class="p">(</span><span class="n">license</span><span class="p">):</span>
                            <span class="k">raise</span> <span class="n">LicensingException</span>
                    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">LicensingException</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">license</span> <span class="ow">in</span> <span class="n">forbidden_licenses</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">LicensingException</span>
            <span class="k">except</span> <span class="n">LicensingException</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">LicensingException</span><span class="p">(</span><span class="s2">&quot;Node </span><span class="si">{}</span><span class="s2"> is licensed &quot;</span>
                                         <span class="s2">&quot;under </span><span class="si">{}</span><span class="s2"> license, which &quot;</span>
                                         <span class="s2">&quot;is in the list of &quot;</span>
                                         <span class="s2">&quot;forbidden licenses&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">pk</span><span class="p">,</span> <span class="n">license</span><span class="p">))</span></div>


<div class="viewcode-block" id="get_all_parents_dj"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.importexport.get_all_parents_dj">[docs]</a><span class="k">def</span> <span class="nf">get_all_parents_dj</span><span class="p">(</span><span class="n">node_pks</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get all the parents of given nodes</span>
<span class="sd">    :param node_pks: one node pk or an iterable of node pks</span>
<span class="sd">    :return: a list of aiida objects with all the parents of the nodes</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">aiida.backends.djsite.db</span> <span class="k">import</span> <span class="n">models</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">the_node_pks</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">node_pks</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="n">the_node_pks</span> <span class="o">=</span> <span class="p">[</span><span class="n">node_pks</span><span class="p">]</span>

    <span class="n">parents</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">DbNode</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">none</span><span class="p">()</span>
    <span class="n">q_inputs</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">DbNode</span><span class="o">.</span><span class="n">aiidaobjects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">outputs__pk__in</span><span class="o">=</span><span class="n">the_node_pks</span><span class="p">)</span><span class="o">.</span><span class="n">distinct</span><span class="p">()</span>
    <span class="k">while</span> <span class="n">q_inputs</span><span class="o">.</span><span class="n">count</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">inputs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">q_inputs</span><span class="p">)</span>
        <span class="n">parents</span> <span class="o">=</span> <span class="n">q_inputs</span> <span class="o">|</span> <span class="n">parents</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
        <span class="n">q_inputs</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">DbNode</span><span class="o">.</span><span class="n">aiidaobjects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">outputs__in</span><span class="o">=</span><span class="n">inputs</span><span class="p">)</span><span class="o">.</span><span class="n">distinct</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">parents</span></div>


<div class="viewcode-block" id="MyWritingZipFile"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.importexport.MyWritingZipFile">[docs]</a><span class="k">class</span> <span class="nc">MyWritingZipFile</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<div class="viewcode-block" id="MyWritingZipFile.__init__"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.importexport.MyWritingZipFile.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">zipfile</span><span class="p">,</span> <span class="n">fname</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_zipfile</span> <span class="o">=</span> <span class="n">zipfile</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fname</span> <span class="o">=</span> <span class="n">fname</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span> <span class="o">=</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="MyWritingZipFile.open"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.importexport.MyWritingZipFile.open">[docs]</a>    <span class="k">def</span> <span class="nf">open</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">six.moves</span> <span class="k">import</span> <span class="n">StringIO</span> <span class="k">as</span> <span class="n">StringIO</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;Cannot open again!&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">()</span></div>

<div class="viewcode-block" id="MyWritingZipFile.write"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.importexport.MyWritingZipFile.write">[docs]</a>    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">data</span><span class="p">)</span></div>

<div class="viewcode-block" id="MyWritingZipFile.close"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.importexport.MyWritingZipFile.close">[docs]</a>    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_zipfile</span><span class="o">.</span><span class="n">writestr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fname</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span> <span class="o">=</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="MyWritingZipFile.__enter__"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.importexport.MyWritingZipFile.__enter__">[docs]</a>    <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">open</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="MyWritingZipFile.__exit__"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.importexport.MyWritingZipFile.__exit__">[docs]</a>    <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">traceback</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="ZipFolder"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.importexport.ZipFolder">[docs]</a><span class="k">class</span> <span class="nc">ZipFolder</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    To improve: if zipfile is closed, do something</span>
<span class="sd">    (e.g. add explicit open method, rename open to openfile,</span>
<span class="sd">    set _zipfile to None, ...)</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="ZipFolder.__init__"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.importexport.ZipFolder.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">zipfolder_or_fname</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">subfolder</span><span class="o">=</span><span class="s1">&#39;.&#39;</span><span class="p">,</span>
                <span class="n">use_compression</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allowZip64</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param zipfolder_or_fname: either another ZipFolder instance,</span>
<span class="sd">          of which you want to get a subfolder, or a filename to create.</span>
<span class="sd">        :param mode: the file mode; see the zipfile.ZipFile docs for valid</span>
<span class="sd">          strings. Note: can be specified only if zipfolder_or_fname is a</span>
<span class="sd">          string (the filename to generate)</span>
<span class="sd">        :param subfolder: the subfolder that specified the &quot;current working</span>
<span class="sd">          directory&quot; in the zip file. If zipfolder_or_fname is a ZipFolder,</span>
<span class="sd">          subfolder is a relative path from zipfolder_or_fname.subfolder</span>
<span class="sd">        :param use_compression: either True, to compress files in the Zip, or</span>
<span class="sd">          False if you just want to pack them together without compressing.</span>
<span class="sd">          It is ignored if zipfolder_or_fname is a ZipFolder isntance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">zipfile</span>
        <span class="kn">import</span> <span class="nn">os</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">zipfolder_or_fname</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
            <span class="n">the_mode</span> <span class="o">=</span> <span class="n">mode</span>
            <span class="k">if</span> <span class="n">the_mode</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">the_mode</span> <span class="o">=</span> <span class="s2">&quot;r&quot;</span>
            <span class="k">if</span> <span class="n">use_compression</span><span class="p">:</span>
                <span class="n">compression</span> <span class="o">=</span> <span class="n">zipfile</span><span class="o">.</span><span class="n">ZIP_DEFLATED</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">compression</span> <span class="o">=</span> <span class="n">zipfile</span><span class="o">.</span><span class="n">ZIP_STORED</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_zipfile</span> <span class="o">=</span> <span class="n">zipfile</span><span class="o">.</span><span class="n">ZipFile</span><span class="p">(</span><span class="n">zipfolder_or_fname</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">the_mode</span><span class="p">,</span>
                                            <span class="n">compression</span><span class="o">=</span><span class="n">compression</span><span class="p">,</span>
                                            <span class="n">allowZip64</span><span class="o">=</span><span class="n">allowZip64</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pwd</span> <span class="o">=</span> <span class="n">subfolder</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">mode</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot specify &#39;mode&#39; when passing a ZipFolder&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_zipfile</span> <span class="o">=</span> <span class="n">zipfolder_or_fname</span><span class="o">.</span><span class="n">_zipfile</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pwd</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">zipfolder_or_fname</span><span class="o">.</span><span class="n">pwd</span><span class="p">,</span> <span class="n">subfolder</span><span class="p">)</span></div>

<div class="viewcode-block" id="ZipFolder.__enter__"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.importexport.ZipFolder.__enter__">[docs]</a>    <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="ZipFolder.__exit__"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.importexport.ZipFolder.__exit__">[docs]</a>    <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">traceback</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>

<div class="viewcode-block" id="ZipFolder.close"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.importexport.ZipFolder.close">[docs]</a>    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_zipfile</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pwd</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pwd</span>

<div class="viewcode-block" id="ZipFolder.open"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.importexport.ZipFolder.open">[docs]</a>    <span class="k">def</span> <span class="nf">open</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;w&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">MyWritingZipFile</span><span class="p">(</span>
                <span class="n">zipfile</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_zipfile</span><span class="p">,</span> <span class="n">fname</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_internal_path</span><span class="p">(</span><span class="n">fname</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zipfile</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_internal_path</span><span class="p">(</span><span class="n">fname</span><span class="p">),</span> <span class="n">mode</span><span class="p">)</span></div>

<div class="viewcode-block" id="ZipFolder._get_internal_path"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.importexport.ZipFolder._get_internal_path">[docs]</a>    <span class="k">def</span> <span class="nf">_get_internal_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">os</span>
        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">normpath</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pwd</span><span class="p">,</span> <span class="n">filename</span><span class="p">))</span></div>

<div class="viewcode-block" id="ZipFolder.get_subfolder"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.importexport.ZipFolder.get_subfolder">[docs]</a>    <span class="k">def</span> <span class="nf">get_subfolder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subfolder</span><span class="p">,</span> <span class="n">create</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">reset_limit</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># reset_limit: ignored</span>
        <span class="c1"># create: ignored, for the time being</span>
        <span class="n">subfolder</span> <span class="o">=</span> <span class="n">ZipFolder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subfolder</span><span class="o">=</span><span class="n">subfolder</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">subfolder</span></div>

<div class="viewcode-block" id="ZipFolder.insert_path"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.importexport.ZipFolder.insert_path">[docs]</a>    <span class="k">def</span> <span class="nf">insert_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">dest_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">os</span>

        <span class="k">if</span> <span class="n">dest_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">base_filename</span> <span class="o">=</span> <span class="n">six</span><span class="o">.</span><span class="n">text_type</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">src</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">base_filename</span> <span class="o">=</span> <span class="n">six</span><span class="o">.</span><span class="n">text_type</span><span class="p">(</span><span class="n">dest_name</span><span class="p">)</span>

        <span class="n">base_filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_internal_path</span><span class="p">(</span><span class="n">base_filename</span><span class="p">)</span>

        <span class="n">src</span> <span class="o">=</span> <span class="n">six</span><span class="o">.</span><span class="n">text_type</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isabs</span><span class="p">(</span><span class="n">src</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;src must be an absolute path in insert_file&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">overwrite</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_zipfile</span><span class="o">.</span><span class="n">getinfo</span><span class="p">(</span><span class="n">base_filename</span><span class="p">)</span>
                <span class="n">exists</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">exists</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">exists</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;destination already exists: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">base_filename</span><span class="p">))</span>

        <span class="c1"># print src, filename</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">src</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">dirpath</span><span class="p">,</span> <span class="n">dirnames</span><span class="p">,</span> <span class="n">filenames</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="n">src</span><span class="p">):</span>
                <span class="n">relpath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">relpath</span><span class="p">(</span><span class="n">dirpath</span><span class="p">,</span> <span class="n">src</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="n">dirnames</span> <span class="o">+</span> <span class="n">filenames</span><span class="p">:</span>
                    <span class="n">real_src</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dirpath</span><span class="p">,</span> <span class="n">fn</span><span class="p">)</span>
                    <span class="n">real_dest</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">base_filename</span><span class="p">,</span> <span class="n">relpath</span><span class="p">,</span> <span class="n">fn</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_zipfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">real_src</span><span class="p">,</span>
                                        <span class="n">real_dest</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_zipfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">base_filename</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="export_zip"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.importexport.export_zip">[docs]</a><span class="k">def</span> <span class="nf">export_zip</span><span class="p">(</span><span class="n">what</span><span class="p">,</span> <span class="n">outfile</span><span class="o">=</span><span class="s1">&#39;testzip&#39;</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
               <span class="n">silent</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">use_compression</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">os</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">overwrite</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">outfile</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;the output file &#39;</span><span class="si">{}</span><span class="s2">&#39; already exists&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">outfile</span><span class="p">))</span>

    <span class="kn">import</span> <span class="nn">time</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">with</span> <span class="n">ZipFolder</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">use_compression</span><span class="o">=</span><span class="n">use_compression</span><span class="p">)</span> <span class="k">as</span> <span class="n">folder</span><span class="p">:</span>
        <span class="n">export_tree</span><span class="p">(</span><span class="n">what</span><span class="p">,</span> <span class="n">folder</span><span class="o">=</span><span class="n">folder</span><span class="p">,</span> <span class="n">silent</span><span class="o">=</span><span class="n">silent</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">silent</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;File written in </span><span class="si">{:10.3g}</span><span class="s2"> s.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t</span><span class="p">))</span></div>


<div class="viewcode-block" id="export"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.importexport.export">[docs]</a><span class="k">def</span> <span class="nf">export</span><span class="p">(</span><span class="n">what</span><span class="p">,</span> <span class="n">outfile</span><span class="o">=</span><span class="s1">&#39;export_data.aiida.tar.gz&#39;</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
           <span class="n">silent</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Export the entries passed in the &#39;what&#39; list to a file tree.</span>
<span class="sd">    :todo: limit the export to finished or failed calculations.</span>
<span class="sd">    :param what: a list of entity instances; they can belong to</span>
<span class="sd">    different models/entities.</span>
<span class="sd">    :param input_forward: Follow forward INPUT links (recursively) when</span>
<span class="sd">    calculating the node set to export.</span>
<span class="sd">    :param create_reversed: Follow reversed CREATE links (recursively) when</span>
<span class="sd">    calculating the node set to export.</span>
<span class="sd">    :param return_reversed: Follow reversed RETURN links (recursively) when</span>
<span class="sd">    calculating the node set to export.</span>
<span class="sd">    :param call_reversed: Follow reversed CALL links (recursively) when</span>
<span class="sd">    calculating the node set to export.</span>
<span class="sd">    :param allowed_licenses: a list or a function. If a list, then checks</span>
<span class="sd">    whether all licenses of Data nodes are in the list. If a function,</span>
<span class="sd">    then calls function for licenses of Data nodes expecting True if</span>
<span class="sd">    license is allowed, False otherwise.</span>
<span class="sd">    :param forbidden_licenses: a list or a function. If a list, then checks</span>
<span class="sd">    whether all licenses of Data nodes are in the list. If a function,</span>
<span class="sd">    then calls function for licenses of Data nodes expecting True if</span>
<span class="sd">    license is allowed, False otherwise.</span>
<span class="sd">    :param outfile: the filename of the file on which to export</span>
<span class="sd">    :param overwrite: if True, overwrite the output file without asking.</span>
<span class="sd">    if False, raise an IOError in this case.</span>
<span class="sd">    :param silent: suppress debug print</span>

<span class="sd">    :raise IOError: if overwrite==False and the filename already exists.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">os</span>
    <span class="kn">import</span> <span class="nn">tarfile</span>
    <span class="kn">import</span> <span class="nn">time</span>

    <span class="kn">from</span> <span class="nn">aiida.common.folders</span> <span class="k">import</span> <span class="n">SandboxFolder</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">overwrite</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">outfile</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;The output file &#39;</span><span class="si">{}</span><span class="s2">&#39; already &quot;</span>
                      <span class="s2">&quot;exists&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">outfile</span><span class="p">))</span>

    <span class="n">folder</span> <span class="o">=</span> <span class="n">SandboxFolder</span><span class="p">()</span>
    <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">export_tree</span><span class="p">(</span><span class="n">what</span><span class="p">,</span> <span class="n">folder</span><span class="o">=</span><span class="n">folder</span><span class="p">,</span> <span class="n">silent</span><span class="o">=</span><span class="n">silent</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="n">t2</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">silent</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;COMPRESSING...&quot;</span><span class="p">)</span>

    <span class="n">t3</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">with</span> <span class="n">tarfile</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="s2">&quot;w:gz&quot;</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="n">tarfile</span><span class="o">.</span><span class="n">PAX_FORMAT</span><span class="p">,</span>
                      <span class="n">dereference</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">as</span> <span class="n">tar</span><span class="p">:</span>
        <span class="n">tar</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">folder</span><span class="o">.</span><span class="n">abspath</span><span class="p">,</span> <span class="n">arcname</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="n">t4</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">silent</span><span class="p">:</span>
        <span class="n">filecr_time</span> <span class="o">=</span> <span class="n">t2</span> <span class="o">-</span> <span class="n">t1</span>
        <span class="n">filecomp_time</span> <span class="o">=</span> <span class="n">t4</span> <span class="o">-</span> <span class="n">t3</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Exported in </span><span class="si">{:6.2g}</span><span class="s2">s, compressed in </span><span class="si">{:6.2g}</span><span class="s2">s, total: </span><span class="si">{:6.2g}</span><span class="s2">s.&quot;</span>
              <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">filecr_time</span><span class="p">,</span> <span class="n">filecomp_time</span><span class="p">,</span> <span class="n">filecr_time</span> <span class="o">+</span> <span class="n">filecomp_time</span><span class="p">))</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">silent</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;DONE.&quot;</span><span class="p">)</span></div>

<span class="c1"># Following code: to serialize the date directly when dumping into JSON.</span>
<span class="c1"># In our case, it is better to have a finer control on how to parse fields.</span>

<span class="c1"># def default_jsondump(data):</span>
<span class="c1">#    import datetime</span>
<span class="c1">#</span>
<span class="c1">#    if isinstance(data, datetime.datetime):</span>
<span class="c1">#        return data.strftime(&#39;%Y-%m-%dT%H:%M:%S.%f%z&#39;)</span>
<span class="c1">#</span>
<span class="c1">#    raise TypeError(repr(data) + &quot; is not JSON serializable&quot;)</span>
<span class="c1"># with open(&#39;testout.json&#39;, &#39;w&#39;) as f:</span>
<span class="c1">#    json.dump({</span>
<span class="c1">#            &#39;entries&#39;: serialized_entries,</span>
<span class="c1">#        },</span>
<span class="c1">#        f,</span>
<span class="c1">#        default=default_jsondump)</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, ECOLE POLYTECHNIQUE FEDERALE DE LAUSANNE (Theory and Simulation of Materials (THEOS) and National Centre for Computational Design and Discovery of Novel Materials (NCCR MARVEL)), Switzerland and ROBERT BOSCH LLC, USA. All rights reserved

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>