

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>aiida.orm.querybuilder &mdash; AiiDA 1.0.0b2 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../_static/language_data.js"></script>
        <script type="text/javascript" src="../../../_static/contentui.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/contentui.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> AiiDA
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Installation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install/quick_installation.html">Quick installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../install/prerequisites.html">Prerequisites</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../install/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../install/updating_installation.html">Updating AiiDA</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../install/troubleshooting.html">Troubleshooting</a></li>
</ul>
<p class="caption"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../get_started/index.html">First things first</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../get_started/daemon.html">Setup the daemon</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../get_started/computers.html">Setup a computer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../get_started/codes.html">Setup a code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../get_started/plugins.html">Plugins</a></li>
</ul>
<p class="caption"><span class="caption-text">Concepts</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../concepts/provenance.html">Provenance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../concepts/processes.html">Processes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../concepts/calculations.html">Calculations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../concepts/workflows.html">Workflows</a></li>
</ul>
<p class="caption"><span class="caption-text">Working with</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../working/processes.html">Processes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../working/functions.html">Calculation and work functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../working/calculations.html">Calculations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../working/workflows.html">Workflows</a></li>
</ul>
<p class="caption"><span class="caption-text">Working with AiiDA</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../working_with_aiida/index.html">Command line interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../working_with_aiida/index.html#scripting">Scripting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../working_with_aiida/index.html#data-types">Data types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../working_with_aiida/index.html#groups">Groups</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../working_with_aiida/index.html#schedulers">Schedulers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../working_with_aiida/index.html#querying-data">Querying data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../working_with_aiida/index.html#caching">Caching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../working_with_aiida/index.html#result-manager">Result manager</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../working_with_aiida/index.html#backups">Backups</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../working_with_aiida/index.html#troubleshooting">Troubleshooting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../working_with_aiida/index.html#rest-api">REST API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../working_with_aiida/index.html#cookbook">Cookbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../import_export/index.html">Import and Export</a></li>
</ul>
<p class="caption"><span class="caption-text">Development</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../developer_guide/index.html">AiiDA design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../developer_guide/index.html#aiida-core">AiiDA core</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../developer_guide/index.html#aiida-plugins">AiiDA plugins</a></li>
</ul>
<p class="caption"><span class="caption-text">Tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial/index.html">StructureData</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial/index.html#pseudopotentials">Pseudopotentials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial/index.html#plugin-development">Plugin development</a></li>
</ul>
<p class="caption"><span class="caption-text">API reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="`aiida package &lt;https://aiida-core.readthedocs.io/en/latest/apidoc/aiida.html&gt;`_">`aiida package &lt;https://aiida-core.readthedocs.io/en/latest/apidoc/aiida.html&gt;`_</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">AiiDA</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../../aiida.html">aiida</a> &raquo;</li>
        
      <li>aiida.orm.querybuilder</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for aiida.orm.querybuilder</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1">###########################################################################</span>
<span class="c1"># Copyright (c), The AiiDA team. All rights reserved.                     #</span>
<span class="c1"># This file is part of the AiiDA code.                                    #</span>
<span class="c1">#                                                                         #</span>
<span class="c1"># The code is hosted on GitHub at https://github.com/aiidateam/aiida_core #</span>
<span class="c1"># For further information on the license, see the LICENSE.txt file        #</span>
<span class="c1"># For further information please visit http://www.aiida.net               #</span>
<span class="c1">###########################################################################</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">The QueryBuilder: A class that allows you to query the AiiDA database, independent from backend.</span>
<span class="sd">Note that the backend implementation is enforced and handled with a composition model!</span>
<span class="sd">:func:`QueryBuilder` is the frontend class that the user can use. It inherits from *object* and contains</span>
<span class="sd">backend-specific functionality. Backend specific functionality is provided by the implementation classes.</span>

<span class="sd">These inherit from :func:`aiida.orm.implementation.BackendQueryBuilder`,</span>
<span class="sd">an interface classes which enforces the implementation of its defined methods.</span>
<span class="sd">An instance of one of the implementation classes becomes a member of the :func:`QueryBuilder` instance</span>
<span class="sd">when instantiated by the user.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span>
<span class="c1"># Checking for correct input with the inspect module</span>
<span class="kn">from</span> <span class="nn">inspect</span> <span class="k">import</span> <span class="n">isclass</span> <span class="k">as</span> <span class="n">inspect_isclass</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">six</span>
<span class="kn">from</span> <span class="nn">six.moves</span> <span class="k">import</span> <span class="nb">range</span><span class="p">,</span> <span class="nb">zip</span>
<span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="k">import</span> <span class="n">and_</span><span class="p">,</span> <span class="n">or_</span><span class="p">,</span> <span class="n">not_</span><span class="p">,</span> <span class="n">func</span> <span class="k">as</span> <span class="n">sa_func</span><span class="p">,</span> <span class="n">select</span><span class="p">,</span> <span class="n">join</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.types</span> <span class="k">import</span> <span class="n">Integer</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="k">import</span> <span class="n">aliased</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.sql.expression</span> <span class="k">import</span> <span class="n">cast</span>
<span class="kn">from</span> <span class="nn">sqlalchemy.dialects.postgresql</span> <span class="k">import</span> <span class="n">array</span>

<span class="kn">from</span> <span class="nn">aiida.common.exceptions</span> <span class="k">import</span> <span class="n">InputValidationError</span>
<span class="c1"># The way I get column as a an attribute to the orm class</span>
<span class="kn">from</span> <span class="nn">aiida.common.links</span> <span class="k">import</span> <span class="n">LinkType</span>
<span class="kn">from</span> <span class="nn">aiida.manage.manager</span> <span class="k">import</span> <span class="n">get_manager</span>
<span class="kn">from</span> <span class="nn">aiida.common.exceptions</span> <span class="k">import</span> <span class="n">ConfigurationError</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">authinfos</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">comments</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">computers</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">groups</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">logs</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">users</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">entities</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">convert</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;QueryBuilder&#39;</span><span class="p">,)</span>

<span class="n">_LOGGER</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">get_querybuilder_classifiers_from_cls</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">qb</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the correct classifiers for the QueryBuilder from an ORM class.</span>

<span class="sd">    :param cls: an AiiDA ORM class or backend ORM class.</span>
<span class="sd">    :param qb: an instance of the appropriate QueryBuilder backend.</span>
<span class="sd">    :returns: the ORM class as well as a dictionary with additional classifier strings</span>
<span class="sd">    :rtype: cls, dict</span>

<span class="sd">    Note: the ormclass_type_string is currently hardcoded for group, computer etc. One could instead use something like</span>
<span class="sd">        aiida.orm.utils.node.get_type_string_from_class(cls.__module__, cls.__name__)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Note: Unable to move this import to the top of the module for some reason</span>
    <span class="kn">from</span> <span class="nn">aiida.engine</span> <span class="k">import</span> <span class="n">Process</span>
    <span class="kn">from</span> <span class="nn">aiida.orm.utils.node</span> <span class="k">import</span> <span class="n">is_valid_node_type_string</span>

    <span class="n">classifiers</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="n">classifiers</span><span class="p">[</span><span class="s1">&#39;process_type_string&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># Nodes</span>
    <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">qb</span><span class="o">.</span><span class="n">Node</span><span class="p">):</span>
        <span class="c1"># If a backend ORM node (i.e. DbNode) is passed.</span>
        <span class="c1"># Users shouldn&#39;t do that, by why not...</span>
        <span class="n">classifiers</span><span class="p">[</span><span class="s1">&#39;ormclass_type_string&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">qb</span><span class="o">.</span><span class="n">AiidaNode</span><span class="o">.</span><span class="n">_plugin_type_string</span>
        <span class="n">ormclass</span> <span class="o">=</span> <span class="bp">cls</span>

    <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">qb</span><span class="o">.</span><span class="n">AiidaNode</span><span class="p">):</span>
        <span class="n">classifiers</span><span class="p">[</span><span class="s1">&#39;ormclass_type_string&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_plugin_type_string</span>
        <span class="n">ormclass</span> <span class="o">=</span> <span class="n">qb</span><span class="o">.</span><span class="n">Node</span>

    <span class="c1"># Groups:</span>
    <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">qb</span><span class="o">.</span><span class="n">Group</span><span class="p">):</span>
        <span class="n">classifiers</span><span class="p">[</span><span class="s1">&#39;ormclass_type_string&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;group&#39;</span>
        <span class="n">ormclass</span> <span class="o">=</span> <span class="bp">cls</span>
    <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">groups</span><span class="o">.</span><span class="n">Group</span><span class="p">):</span>
        <span class="n">classifiers</span><span class="p">[</span><span class="s1">&#39;ormclass_type_string&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;group&#39;</span>
        <span class="n">ormclass</span> <span class="o">=</span> <span class="n">qb</span><span class="o">.</span><span class="n">Group</span>

    <span class="c1"># Computers:</span>
    <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">qb</span><span class="o">.</span><span class="n">Computer</span><span class="p">):</span>
        <span class="n">classifiers</span><span class="p">[</span><span class="s1">&#39;ormclass_type_string&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;computer&#39;</span>
        <span class="n">ormclass</span> <span class="o">=</span> <span class="bp">cls</span>
    <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">computers</span><span class="o">.</span><span class="n">Computer</span><span class="p">):</span>
        <span class="n">classifiers</span><span class="p">[</span><span class="s1">&#39;ormclass_type_string&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;computer&#39;</span>
        <span class="n">ormclass</span> <span class="o">=</span> <span class="n">qb</span><span class="o">.</span><span class="n">Computer</span>

    <span class="c1"># Users</span>
    <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">qb</span><span class="o">.</span><span class="n">User</span><span class="p">):</span>
        <span class="n">classifiers</span><span class="p">[</span><span class="s1">&#39;ormclass_type_string&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;user&#39;</span>
        <span class="n">ormclass</span> <span class="o">=</span> <span class="bp">cls</span>
    <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">users</span><span class="o">.</span><span class="n">User</span><span class="p">):</span>
        <span class="n">classifiers</span><span class="p">[</span><span class="s1">&#39;ormclass_type_string&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;user&#39;</span>
        <span class="n">ormclass</span> <span class="o">=</span> <span class="n">qb</span><span class="o">.</span><span class="n">User</span>

    <span class="c1"># AuthInfo</span>
    <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">qb</span><span class="o">.</span><span class="n">AuthInfo</span><span class="p">):</span>
        <span class="n">classifiers</span><span class="p">[</span><span class="s1">&#39;ormclass_type_string&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;authinfo&#39;</span>
        <span class="n">ormclass</span> <span class="o">=</span> <span class="bp">cls</span>
    <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">authinfos</span><span class="o">.</span><span class="n">AuthInfo</span><span class="p">):</span>
        <span class="n">classifiers</span><span class="p">[</span><span class="s1">&#39;ormclass_type_string&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;authinfo&#39;</span>
        <span class="n">ormclass</span> <span class="o">=</span> <span class="n">qb</span><span class="o">.</span><span class="n">AuthInfo</span>

    <span class="c1"># Comment</span>
    <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">qb</span><span class="o">.</span><span class="n">Comment</span><span class="p">):</span>
        <span class="n">classifiers</span><span class="p">[</span><span class="s1">&#39;ormclass_type_string&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;comment&#39;</span>
        <span class="n">ormclass</span> <span class="o">=</span> <span class="bp">cls</span>
    <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">comments</span><span class="o">.</span><span class="n">Comment</span><span class="p">):</span>
        <span class="n">classifiers</span><span class="p">[</span><span class="s1">&#39;ormclass_type_string&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;comment&#39;</span>
        <span class="n">ormclass</span> <span class="o">=</span> <span class="n">qb</span><span class="o">.</span><span class="n">Comment</span>

    <span class="c1"># Log</span>
    <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">qb</span><span class="o">.</span><span class="n">Log</span><span class="p">):</span>
        <span class="n">classifiers</span><span class="p">[</span><span class="s1">&#39;ormclass_type_string&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;log&#39;</span>
        <span class="n">ormclass</span> <span class="o">=</span> <span class="bp">cls</span>
    <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">logs</span><span class="o">.</span><span class="n">Log</span><span class="p">):</span>
        <span class="n">classifiers</span><span class="p">[</span><span class="s1">&#39;ormclass_type_string&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;log&#39;</span>
        <span class="n">ormclass</span> <span class="o">=</span> <span class="n">qb</span><span class="o">.</span><span class="n">Log</span>

    <span class="c1"># Process</span>
    <span class="c1"># This is a special case, since Process is not an ORM class.</span>
    <span class="c1"># We need to deduce the ORM class used by the Process.</span>
    <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">Process</span><span class="p">):</span>
        <span class="n">classifiers</span><span class="p">[</span><span class="s1">&#39;ormclass_type_string&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_node_class</span><span class="o">.</span><span class="n">_plugin_type_string</span>
        <span class="n">classifiers</span><span class="p">[</span><span class="s1">&#39;process_type_string&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">build_process_type</span><span class="p">()</span>
        <span class="n">ormclass</span> <span class="o">=</span> <span class="n">qb</span><span class="o">.</span><span class="n">Node</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">InputValidationError</span><span class="p">(</span><span class="s2">&quot;I do not know what to do with </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">cls</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">ormclass</span> <span class="o">==</span> <span class="n">qb</span><span class="o">.</span><span class="n">Node</span><span class="p">:</span>
        <span class="n">is_valid_node_type_string</span><span class="p">(</span><span class="n">classifiers</span><span class="p">[</span><span class="s1">&#39;ormclass_type_string&#39;</span><span class="p">],</span> <span class="n">raise_on_false</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ormclass</span><span class="p">,</span> <span class="n">classifiers</span>


<span class="k">def</span> <span class="nf">get_querybuilder_classifiers_from_type</span><span class="p">(</span><span class="n">ormclass_type_string</span><span class="p">,</span> <span class="n">qb</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the correct classifiers for the QueryBuilder from an ORM type string.</span>

<span class="sd">    :param ormclass_type_string: type string for ORM class</span>
<span class="sd">    :param qb: an instance of the appropriate QueryBuilder backend.</span>
<span class="sd">    :returns: the ORM class as well as a dictionary with additional classifier strings</span>
<span class="sd">    :rtype: cls, dict</span>


<span class="sd">    Same as get_querybuilder_classifiers_from_cls, but accepts a string instead of a class.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">aiida.orm.utils.node</span> <span class="k">import</span> <span class="n">is_valid_node_type_string</span>
    <span class="n">classifiers</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="n">classifiers</span><span class="p">[</span><span class="s1">&#39;process_type_string&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">classifiers</span><span class="p">[</span><span class="s1">&#39;ormclass_type_string&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ormclass_type_string</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">classifiers</span><span class="p">[</span><span class="s1">&#39;ormclass_type_string&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;group&#39;</span><span class="p">:</span>
        <span class="n">ormclass</span> <span class="o">=</span> <span class="n">qb</span><span class="o">.</span><span class="n">Group</span>
    <span class="k">elif</span> <span class="n">classifiers</span><span class="p">[</span><span class="s1">&#39;ormclass_type_string&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;computer&#39;</span><span class="p">:</span>
        <span class="n">ormclass</span> <span class="o">=</span> <span class="n">qb</span><span class="o">.</span><span class="n">Computer</span>
    <span class="k">elif</span> <span class="n">classifiers</span><span class="p">[</span><span class="s1">&#39;ormclass_type_string&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;user&#39;</span><span class="p">:</span>
        <span class="n">ormclass</span> <span class="o">=</span> <span class="n">qb</span><span class="o">.</span><span class="n">User</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># At this point, we assume it is a node. The only valid type string then is a string</span>
        <span class="c1"># that matches exactly the _plugin_type_string of a node class</span>
        <span class="n">classifiers</span><span class="p">[</span><span class="s1">&#39;ormclass_type_string&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ormclass_type_string</span>  <span class="c1"># no lowercase</span>
        <span class="n">ormclass</span> <span class="o">=</span> <span class="n">qb</span><span class="o">.</span><span class="n">Node</span>

    <span class="k">if</span> <span class="n">ormclass</span> <span class="o">==</span> <span class="n">qb</span><span class="o">.</span><span class="n">Node</span><span class="p">:</span>
        <span class="n">is_valid_node_type_string</span><span class="p">(</span><span class="n">classifiers</span><span class="p">[</span><span class="s1">&#39;ormclass_type_string&#39;</span><span class="p">],</span> <span class="n">raise_on_false</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


    <span class="k">return</span> <span class="n">ormclass</span><span class="p">,</span> <span class="n">classifiers</span>


<span class="k">def</span> <span class="nf">get_type_filter</span><span class="p">(</span><span class="n">classifiers</span><span class="p">,</span> <span class="n">subclassing</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return filter dictionaries given a set of classifiers.</span>

<span class="sd">    :param classifiers: a dictionary with classifiers (note: does *not* support lists)</span>
<span class="sd">    :param subclassing: if True, allow for subclasses of the ormclass</span>

<span class="sd">    :returns: dictionary in QueryBuilder filter language to pass into {&quot;type&quot;: ... }</span>
<span class="sd">    :rtype: dict</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">aiida.orm.utils.node</span> <span class="k">import</span> <span class="n">get_query_type_from_type_string</span>
    <span class="kn">from</span> <span class="nn">aiida.common.escaping</span> <span class="k">import</span> <span class="n">escape_for_sql_like</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">classifiers</span><span class="p">[</span><span class="s1">&#39;ormclass_type_string&#39;</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">subclassing</span><span class="p">:</span>
        <span class="nb">filter</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;==&#39;</span><span class="p">:</span> <span class="n">value</span><span class="p">}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Note: the query_type_string always ends with a dot. This ensures that &quot;like {str}%&quot; matches *only*</span>
        <span class="c1"># the query type string</span>
        <span class="nb">filter</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;like&#39;</span><span class="p">:</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">%&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">escape_for_sql_like</span><span class="p">(</span><span class="n">get_query_type_from_type_string</span><span class="p">(</span><span class="n">value</span><span class="p">)))}</span>

    <span class="k">return</span> <span class="nb">filter</span>

<span class="k">def</span> <span class="nf">get_process_type_filter</span><span class="p">(</span><span class="n">classifiers</span><span class="p">,</span> <span class="n">subclassing</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return filter dictionaries given a set of classifiers.</span>

<span class="sd">    :param classifiers: a dictionary with classifiers (note: does *not* support lists)</span>
<span class="sd">    :param subclassing: if True, allow for subclasses of the process type</span>
<span class="sd">            This is activated only, if an entry point can be found for the process type</span>
<span class="sd">            (as well as for a selection of built-in process types)</span>


<span class="sd">    :returns: dictionary in QueryBuilder filter language to pass into {&quot;process_type&quot;: ... }</span>
<span class="sd">    :rtype: dict</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">aiida.common.escaping</span> <span class="k">import</span> <span class="n">escape_for_sql_like</span>
    <span class="kn">from</span> <span class="nn">aiida.common.warnings</span> <span class="k">import</span> <span class="n">AiidaEntryPointWarning</span>
    <span class="kn">from</span> <span class="nn">aiida.engine.processes.process</span> <span class="k">import</span> <span class="n">get_query_string_from_process_type_string</span>
    <span class="kn">import</span> <span class="nn">warnings</span>

    <span class="n">value</span> <span class="o">=</span> <span class="n">classifiers</span><span class="p">[</span><span class="s1">&#39;process_type_string&#39;</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">subclassing</span><span class="p">:</span>
        <span class="nb">filter</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;==&#39;</span><span class="p">:</span> <span class="n">value</span><span class="p">}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="s2">&quot;:&quot;</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
            <span class="c1"># if value is an entry point, do usual subclassing</span>

            <span class="c1"># Note: the process_type_string stored in the database does *not* end in a dot.</span>
            <span class="c1"># In order to avoid that querying for class &#39;Begin&#39; will also find class &#39;BeginEnd&#39;,</span>
            <span class="c1"># we need to search separately for equality and &#39;like&#39;.</span>
            <span class="nb">filter</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;or&#39;</span><span class="p">:</span> <span class="p">[</span>
                <span class="p">{</span><span class="s1">&#39;==&#39;</span><span class="p">:</span> <span class="n">value</span><span class="p">},</span>
                <span class="p">{</span><span class="s1">&#39;like&#39;</span><span class="p">:</span> <span class="n">escape_for_sql_like</span><span class="p">(</span><span class="n">get_query_string_from_process_type_string</span><span class="p">(</span><span class="n">value</span><span class="p">))},</span>
            <span class="p">]}</span>
        <span class="k">elif</span> <span class="n">value</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;aiida.engine&#39;</span><span class="p">):</span>
            <span class="c1"># For core process types, a filter is not is needed since each process type has a corresponding</span>
            <span class="c1"># ormclass type that already specifies everything.</span>
            <span class="c1"># Note: This solution is fragile and will break as soon as there is not an exact one-to-one correspondence</span>
            <span class="c1"># between process classes and node classes</span>

            <span class="c1"># Note: Improve this when issue #2475 is addressed</span>
            <span class="nb">filter</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;like&#39;</span><span class="p">:</span> <span class="s1">&#39;%&#39;</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Process type &#39;</span><span class="si">{}</span><span class="s2">&#39; does not correspond to a registered entry. &quot;</span>
                          <span class="s2">&quot;This risks queries to fail once the location of the process class changes. &quot;</span>
                          <span class="s2">&quot;Add an entry point for &#39;</span><span class="si">{}</span><span class="s2">&#39; to remove this warning.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">value</span><span class="p">),</span>
                          <span class="n">AiidaEntryPointWarning</span><span class="p">)</span>
            <span class="nb">filter</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;or&#39;</span><span class="p">:</span> <span class="p">[</span>
                <span class="p">{</span><span class="s1">&#39;==&#39;</span><span class="p">:</span> <span class="n">value</span><span class="p">},</span>
                <span class="p">{</span><span class="s1">&#39;like&#39;</span><span class="p">:</span> <span class="n">escape_for_sql_like</span><span class="p">(</span><span class="n">get_query_string_from_process_type_string</span><span class="p">(</span><span class="n">value</span><span class="p">))},</span>
            <span class="p">]}</span>


    <span class="k">return</span> <span class="nb">filter</span>


<div class="viewcode-block" id="QueryBuilder"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.QueryBuilder">[docs]</a><span class="k">class</span> <span class="nc">QueryBuilder</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The class to query the AiiDA database.</span>

<span class="sd">    Usage::</span>

<span class="sd">        from aiida.orm.querybuilder import QueryBuilder</span>
<span class="sd">        qb = QueryBuilder()</span>
<span class="sd">        # Querying nodes:</span>
<span class="sd">        qb.append(Node)</span>
<span class="sd">        # retrieving the results:</span>
<span class="sd">        results = qb.all()</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># This tag defines how edges are tagged (labeled) by the QueryBuilder default</span>
    <span class="c1"># namely tag of first entity + _EDGE_TAG_DELIM + tag of second entity</span>
    <span class="n">_EDGE_TAG_DELIM</span> <span class="o">=</span> <span class="s1">&#39;--&#39;</span>
    <span class="n">_VALID_PROJECTION_KEYS</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;func&#39;</span><span class="p">,</span> <span class="s1">&#39;cast&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="QueryBuilder.__init__"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.QueryBuilder.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Instantiates a QueryBuilder instance.</span>

<span class="sd">        Which backend is used decided here based on backend-settings (taken from the user profile).</span>
<span class="sd">        This cannot be overriden so far by the user.</span>

<span class="sd">        :param bool debug:</span>
<span class="sd">            Turn on debug mode. This feature prints information on the screen about the stages</span>
<span class="sd">            of the QueryBuilder. Does not affect results.</span>
<span class="sd">        :param list path:</span>
<span class="sd">            A list of the vertices to traverse. Leave empty if you plan on using the method</span>
<span class="sd">            :func:`QueryBuilder.append`.</span>
<span class="sd">        :param filters:</span>
<span class="sd">            The filters to apply. You can specify the filters here, when appending to the query</span>
<span class="sd">            using :func:`QueryBuilder.append` or even later using :func:`QueryBuilder.add_filter`.</span>
<span class="sd">            Check latter gives API-details.</span>
<span class="sd">        :param project:</span>
<span class="sd">            The projections to apply. You can specify the projections here, when appending to the query</span>
<span class="sd">            using :func:`QueryBuilder.append` or even later using :func:`QueryBuilder.add_projection`.</span>
<span class="sd">            Latter gives you API-details.</span>
<span class="sd">        :param int limit:</span>
<span class="sd">            Limit the number of rows to this number. Check :func:`QueryBuilder.limit`</span>
<span class="sd">            for more information.</span>
<span class="sd">        :param int offset:</span>
<span class="sd">            Set an offset for the results returned. Details in :func:`QueryBuilder.offset`.</span>
<span class="sd">        :param order_by:</span>
<span class="sd">            How to order the results. As the 2 above, can be set also at later stage,</span>
<span class="sd">            check :func:`QueryBuilder.order_by` for more information.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">backend</span> <span class="o">=</span> <span class="n">backend</span> <span class="ow">or</span> <span class="n">get_manager</span><span class="p">()</span><span class="o">.</span><span class="n">get_backend</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span> <span class="o">=</span> <span class="n">backend</span><span class="o">.</span><span class="n">query</span><span class="p">()</span>

        <span class="c1"># A list storing the path being traversed by the query</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_path</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># A list of unique aliases in same order as path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_aliased_path</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># A dictionary tag:alias of ormclass</span>
        <span class="c1"># redundant but makes life easier</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tag_to_alias_map</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># A dictionary tag: filter specification for this alias</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_filters</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># A dictionary tag: projections for this alias</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_projections</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># A dictionary for classes passed to the tag given to them</span>
        <span class="c1"># Everything is specified with unique tags, which are strings.</span>
        <span class="c1"># But somebody might not care about giving tags, so to do</span>
        <span class="c1"># everything with classes one needs a map, that also defines classes</span>
        <span class="c1"># as tags, to allow the following example:</span>

        <span class="c1"># qb = QueryBuilder()</span>
        <span class="c1"># qb.append(PwCalculation)</span>
        <span class="c1"># qb.append(StructureData, with_outgoing=PwCalculation)</span>

        <span class="c1"># The cls_to_tag_map in this case would be:</span>
        <span class="c1"># {PwCalculation:&#39;PwCalculation&#39;, StructureData:&#39;StructureData&#39;}</span>
        <span class="c1"># Keep in mind that it needs to be checked (and this is done) whether the class</span>
        <span class="c1"># is used twice. In that case, the user has to provide a tag!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cls_to_tag_map</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Hashing the the internal queryhelp allows me to avoid to build a query again, if i have used</span>
        <span class="c1"># it already.</span>
        <span class="c1"># Example:</span>

        <span class="c1">## User is building a query:</span>
        <span class="c1"># qb = QueryBuilder().append(.....)</span>
        <span class="c1">## User asks for the first results:</span>
        <span class="c1"># qb.first()</span>
        <span class="c1">## User asks for all results, of the same query:</span>
        <span class="c1"># qb.all()</span>
        <span class="c1"># In above example, I can reuse the query, and to track whether somethis was changed</span>
        <span class="c1"># I record a hash:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1">## The hash being None implies that the query will be build (Check the code in .get_query</span>
        <span class="c1"># The user can inject a query, this keyword stores whether this was done.</span>
        <span class="c1"># Check QueryBuilder.inject_query</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_injected</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Setting debug levels:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_debug</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;debug&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>

        <span class="c1"># One can apply the path as a keyword. Allows for jsons to be given to the QueryBuilder.</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;path&#39;</span><span class="p">,</span> <span class="p">[])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="n">InputValidationError</span><span class="p">(</span><span class="s2">&quot;Path needs to be a tuple or a list&quot;</span><span class="p">)</span>
        <span class="c1"># If the user specified a path, I use the append method to analyze, see QueryBuilder.append</span>
        <span class="k">for</span> <span class="n">path_spec</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">path_spec</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">**</span><span class="n">path_spec</span><span class="p">)</span>
            <span class="c1"># ~ except TypeError as e:</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">path_spec</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
                <span class="c1"># Maybe it is just a string,</span>
                <span class="c1"># I assume user means the type</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entity_type</span><span class="o">=</span><span class="n">path_spec</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Or a class, let&#39;s try</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">cls</span><span class="o">=</span><span class="n">path_spec</span><span class="p">)</span>

        <span class="c1"># Projections. The user provides a dictionary, but the specific checks is</span>
        <span class="c1"># left to QueryBuilder.add_project.</span>
        <span class="n">projection_dict</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;project&#39;</span><span class="p">,</span> <span class="p">{})</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">projection_dict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">InputValidationError</span><span class="p">(</span><span class="s2">&quot;You need to provide the projections as dictionary&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">projection_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_projection</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

        <span class="c1"># For filters, I also expect a dictionary, and the checks are done lower.</span>
        <span class="n">filter_dict</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;filters&#39;</span><span class="p">,</span> <span class="p">{})</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">filter_dict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">InputValidationError</span><span class="p">(</span><span class="s2">&quot;You need to provide the filters as dictionary&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">filter_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_filter</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

        <span class="c1"># The limit is caps the number of results returned, and can also be set with QueryBuilder.limit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">limit</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;limit&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>

        <span class="c1"># The offset returns results after the offset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">offset</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;offset&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>

        <span class="c1"># The user can also specify the order.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_order_by</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">order_spec</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;order_by&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">order_spec</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">order_spec</span><span class="p">)</span>

        <span class="c1"># I&#39;ve gone through all the keywords, popping each item</span>
        <span class="c1"># If kwargs is not empty, there is a problem:</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">valid_keys</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;path&#39;</span><span class="p">,</span> <span class="s1">&#39;filters&#39;</span><span class="p">,</span> <span class="s1">&#39;project&#39;</span><span class="p">,</span> <span class="s1">&#39;limit&#39;</span><span class="p">,</span> <span class="s1">&#39;offset&#39;</span><span class="p">,</span> <span class="s1">&#39;order_by&#39;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">InputValidationError</span><span class="p">(</span><span class="s2">&quot;Received additional keywords: </span><span class="si">{}</span><span class="s2">&quot;</span>
                                       <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">which I cannot process&quot;</span>
                                       <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Valid keywords are: </span><span class="si">{}</span><span class="s2">&quot;</span>
                                       <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span> <span class="n">valid_keys</span><span class="p">))</span></div>

<div class="viewcode-block" id="QueryBuilder.__str__"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.QueryBuilder.__str__">[docs]</a>    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        When somebody hits: print(QueryBuilder) or print(str(QueryBuilder))</span>
<span class="sd">        I want to print the SQL-query. Because it looks cool...</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">aiida.manage.configuration</span> <span class="k">import</span> <span class="n">get_config</span>

        <span class="n">config</span> <span class="o">=</span> <span class="n">get_config</span><span class="p">()</span>
        <span class="n">engine</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">current_profile</span><span class="o">.</span><span class="n">database_engine</span>

        <span class="k">if</span> <span class="n">engine</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;mysql&quot;</span><span class="p">):</span>
            <span class="kn">from</span> <span class="nn">sqlalchemy.dialects</span> <span class="k">import</span> <span class="n">mysql</span> <span class="k">as</span> <span class="n">mydialect</span>
        <span class="k">elif</span> <span class="n">engine</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;postgre&quot;</span><span class="p">):</span>
            <span class="kn">from</span> <span class="nn">sqlalchemy.dialects</span> <span class="k">import</span> <span class="n">postgresql</span> <span class="k">as</span> <span class="n">mydialect</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ConfigurationError</span><span class="p">(</span><span class="s2">&quot;Unknown DB engine: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">engine</span><span class="p">))</span>

        <span class="n">que</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_query</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">que</span><span class="o">.</span><span class="n">statement</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">compile_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;literal_binds&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span> <span class="n">dialect</span><span class="o">=</span><span class="n">mydialect</span><span class="o">.</span><span class="n">dialect</span><span class="p">()))</span></div>

<div class="viewcode-block" id="QueryBuilder._get_ormclass"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.QueryBuilder._get_ormclass">[docs]</a>    <span class="k">def</span> <span class="nf">_get_ormclass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">cls</span><span class="p">,</span> <span class="n">ormclass_type_string</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get ORM classifiers from either class(es) or ormclass_type_string(s).</span>

<span class="sd">        :param cls: a class or tuple/set/list of classes that are either AiiDA ORM classes or backend ORM classes.</span>
<span class="sd">        :param ormclass_type_string: type string for ORM class</span>

<span class="sd">        :returns: the ORM class as well as a dictionary with additional classifier strings</span>

<span class="sd">        Handles the case of lists as well.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">cls</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">func</span> <span class="o">=</span> <span class="n">get_querybuilder_classifiers_from_cls</span>
            <span class="n">input_info</span> <span class="o">=</span> <span class="bp">cls</span>
        <span class="k">elif</span> <span class="n">ormclass_type_string</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">func</span> <span class="o">=</span> <span class="n">get_querybuilder_classifiers_from_type</span>
            <span class="n">input_info</span> <span class="o">=</span> <span class="n">ormclass_type_string</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Neither cls nor ormclass_type_string specified&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">input_info</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">set</span><span class="p">)):</span>
            <span class="c1"># Going through each element of the list/tuple/set:</span>
            <span class="n">ormclass</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">classifiers</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">input_info</span><span class="p">):</span>
                <span class="n">new_ormclass</span><span class="p">,</span> <span class="n">new_classifiers</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">i</span><span class="p">:</span>
                    <span class="c1"># This is not my first iteration!</span>
                    <span class="c1"># I check consistency with what was specified before</span>
                    <span class="k">if</span> <span class="n">new_ormclass</span> <span class="o">!=</span> <span class="n">ormclass</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">InputValidationError</span><span class="p">(</span><span class="s2">&quot;Non-matching types have been passed as list/tuple/set.&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># first iteration</span>
                    <span class="n">ormclass</span> <span class="o">=</span> <span class="n">new_ormclass</span>

                <span class="n">classifiers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_classifiers</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ormclass</span><span class="p">,</span> <span class="n">classifiers</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">input_info</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ormclass</span><span class="p">,</span> <span class="n">classifiers</span></div>

<div class="viewcode-block" id="QueryBuilder._get_unique_tag"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.QueryBuilder._get_unique_tag">[docs]</a>    <span class="k">def</span> <span class="nf">_get_unique_tag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">classifiers</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Using the function get_tag_from_type, I get a tag.</span>
<span class="sd">        I increment an index that is appended to that tag until I have an unused tag.</span>
<span class="sd">        This function is called in :func:`QueryBuilder.append` when autotag is set to True.</span>

<span class="sd">        :param dict classifiers:</span>
<span class="sd">            Classifiers, containing the string that defines the type of the AiiDA ORM class.</span>
<span class="sd">            For subclasses of Node, this is the Node._plugin_type_string, for other they are</span>
<span class="sd">            as defined as returned by :func:`QueryBuilder._get_ormclass`.</span>

<span class="sd">            Can also be a list of dictionaries, when multiple classes are passed to QueryBuilder.append</span>

<span class="sd">        :returns: A tag as a string (it is a single string also when passing multiple classes).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">get_tag_from_type</span><span class="p">(</span><span class="n">classifiers</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Assign a tag to the given vertex of a path, based mainly on the type</span>
<span class="sd">            *   data.structure.StructureData -&gt; StructureData</span>
<span class="sd">            *   data.structure.StructureData. -&gt; StructureData</span>
<span class="sd">            *   calculation.job.quantumespresso.pw.PwCalculation. -. PwCalculation</span>
<span class="sd">            *   node.Node. -&gt; Node</span>
<span class="sd">            *   Node -&gt; Node</span>
<span class="sd">            *   computer -&gt; computer</span>
<span class="sd">            *   etc.</span>

<span class="sd">            :param str ormclass_type_string:</span>
<span class="sd">                The string that defines the type of the AiiDA ORM class.</span>
<span class="sd">                For subclasses of Node, this is the Node._plugin_type_string, for other they are</span>
<span class="sd">                as defined as returned by :func:`QueryBuilder._get_ormclass`.</span>
<span class="sd">            :returns: A tag, as a string.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">classifiers</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">return</span> <span class="s1">&#39;-&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">t</span><span class="p">[</span><span class="s1">&#39;ormclass_type_string&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">or</span> <span class="s2">&quot;node&quot;</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">classifiers</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">classifiers</span><span class="p">[</span><span class="s1">&#39;ormclass_type_string&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">or</span> <span class="s2">&quot;node&quot;</span>

        <span class="n">basetag</span> <span class="o">=</span> <span class="n">get_tag_from_type</span><span class="p">(</span><span class="n">classifiers</span><span class="p">)</span>
        <span class="n">tags_used</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tag_to_alias_map</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">100</span><span class="p">):</span>
            <span class="n">tag</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">basetag</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">tag</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tags_used</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">tag</span>

        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Cannot find a tag after 100 tries&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="QueryBuilder.append"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.QueryBuilder.append">[docs]</a>    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
               <span class="bp">cls</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">entity_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">tag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">filters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">project</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">subclassing</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
               <span class="n">edge_tag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">edge_filters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">edge_project</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">outerjoin</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
               <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Any iterative procedure to build the path for a graph query</span>
<span class="sd">        needs to invoke this method to append to the path.</span>

<span class="sd">        :param cls:</span>
<span class="sd">            The Aiida-class (or backend-class) defining the appended vertice.</span>
<span class="sd">            Also supports a tuple/list of classes. This results in an all instances of</span>
<span class="sd">            this class being accepted in a query. However the classes have to have the same orm-class</span>
<span class="sd">            for the joining to work. I.e. both have to subclasses of Node. Valid is::</span>

<span class="sd">                cls=(StructureData, Dict)</span>

<span class="sd">            This is invalid:</span>

<span class="sd">                cls=(Group, Node)</span>

<span class="sd">        :param entity_type: The node type of the class, if cls is not given. Also here, a tuple or list is accepted.</span>
<span class="sd">        :type type: str</span>
<span class="sd">        :param bool autotag: Whether to find automatically a unique tag. If this is set to True (default False),</span>
<span class="sd">        :param str tag:</span>
<span class="sd">            A unique tag. If none is given, I will create a unique tag myself.</span>
<span class="sd">        :param filters:</span>
<span class="sd">            Filters to apply for this vertex.</span>
<span class="sd">            See :meth:`.add_filter`, the method invoked in the background, or usage examples for details.</span>
<span class="sd">        :param project:</span>
<span class="sd">            Projections to apply. See usage examples for details.</span>
<span class="sd">            More information also in :meth:`.add_projection`.</span>
<span class="sd">        :param bool subclassing:</span>
<span class="sd">            Whether to include subclasses of the given class</span>
<span class="sd">            (default **True**).</span>
<span class="sd">            E.g. Specifying a  ProcessNode as cls will include CalcJobNode, WorkChainNode, CalcFunctionNode, etc..</span>
<span class="sd">        :param bool outerjoin:</span>
<span class="sd">            If True, (default is False), will do a left outerjoin</span>
<span class="sd">            instead of an inner join</span>
<span class="sd">        :param str edge_tag:</span>
<span class="sd">            The tag that the edge will get. If nothing is specified</span>
<span class="sd">            (and there is a meaningful edge) the default is tag1--tag2 with tag1 being the entity joining</span>
<span class="sd">            from and tag2 being the entity joining to (this entity).</span>
<span class="sd">        :param str edge_filters:</span>
<span class="sd">            The filters to apply on the edge. Also here, details in :meth:`.add_filter`.</span>
<span class="sd">        :param str edge_project:</span>
<span class="sd">            The project from the edges. API-details in :meth:`.add_projection`.</span>

<span class="sd">        A small usage example how this can be invoked::</span>

<span class="sd">            qb = QueryBuilder()             # Instantiating empty querybuilder instance</span>
<span class="sd">            qb.append(cls=StructureData)    # First item is StructureData node</span>
<span class="sd">            # The</span>
<span class="sd">            # next node in the path is a PwCalculation, with</span>
<span class="sd">            # the structure joined as an input</span>
<span class="sd">            qb.append(</span>
<span class="sd">                cls=PwCalculation,</span>
<span class="sd">                with_incoming=StructureData</span>
<span class="sd">            )</span>

<span class="sd">        :return: self</span>
<span class="sd">        :rtype: :class:`aiida.orm.QueryBuilder`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># INPUT CHECKS ##########################</span>
        <span class="c1"># This function can be called by users, so I am checking the</span>
        <span class="c1"># input now.</span>
        <span class="c1"># First of all, let&#39;s make sure the specified</span>
        <span class="c1"># the class or the type (not both)</span>
        <span class="k">if</span> <span class="bp">cls</span> <span class="ow">and</span> <span class="n">entity_type</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InputValidationError</span><span class="p">(</span><span class="s2">&quot;You cannot specify both a class (</span><span class="si">{}</span><span class="s2">) and a entity_type (</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">entity_type</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">cls</span> <span class="ow">or</span> <span class="n">entity_type</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">InputValidationError</span><span class="p">(</span><span class="s2">&quot;You need to specify at least a class or a entity_type&quot;</span><span class="p">)</span>

        <span class="c1"># Let&#39;s check if it is a valid class or type</span>
        <span class="k">if</span> <span class="bp">cls</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">set</span><span class="p">)):</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">cls</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">inspect_isclass</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="n">InputValidationError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> was passed with kw &#39;cls&#39;, but is not a class&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">inspect_isclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="n">InputValidationError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> was passed with kw &#39;cls&#39;, but is not a class&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">cls</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">entity_type</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">entity_type</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">set</span><span class="p">)):</span>
                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">entity_type</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="n">InputValidationError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> was passed as entity_type, but is not a string&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">entity_type</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="n">InputValidationError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> was passed as entity_type, but is not a string&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">entity_type</span><span class="p">))</span>

        <span class="n">ormclass</span><span class="p">,</span> <span class="n">classifiers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_ormclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">entity_type</span><span class="p">)</span>

        <span class="c1"># TAG #################################</span>
        <span class="c1"># Let&#39;s get a tag</span>
        <span class="k">if</span> <span class="n">tag</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_EDGE_TAG_DELIM</span> <span class="ow">in</span> <span class="n">tag</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">InputValidationError</span><span class="p">(</span><span class="s2">&quot;tag cannot contain </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span>
                                           <span class="s2">&quot;since this is used as a delimiter for links&quot;</span>
                                           <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_EDGE_TAG_DELIM</span><span class="p">))</span>
            <span class="n">tag</span> <span class="o">=</span> <span class="n">tag</span>
            <span class="k">if</span> <span class="n">tag</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tag_to_alias_map</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">raise</span> <span class="n">InputValidationError</span><span class="p">(</span><span class="s2">&quot;This tag (</span><span class="si">{}</span><span class="s2">) is already in use&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_unique_tag</span><span class="p">(</span><span class="n">classifiers</span><span class="p">)</span>

        <span class="c1"># Checks complete</span>
        <span class="c1"># This is where I start doing changes to self!</span>
        <span class="c1"># Now, several things can go wrong along the way, so I need to split into</span>
        <span class="c1"># atomic blocks that I can reverse if something goes wrong.</span>
        <span class="c1"># TAG MAPPING #################################</span>
        <span class="c1"># TODO check with duplicate classes</span>

        <span class="c1"># Let&#39;s fill the cls_to_tag_map so that one can specify</span>
        <span class="c1"># this vertice in a joining specification later</span>
        <span class="c1"># First this only makes sense if a class was specified:</span>

        <span class="n">l_class_added_to_map</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">cls</span><span class="p">:</span>
            <span class="c1"># Note: tuples can be used as array keys, lists &amp; sets can&#39;t</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">set</span><span class="p">)):</span>
                <span class="n">tag_key</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tag_key</span> <span class="o">=</span> <span class="bp">cls</span>

            <span class="k">if</span> <span class="n">tag_key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cls_to_tag_map</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="c1"># In this case, this class already stands for another</span>
                <span class="c1"># tag that was used before.</span>
                <span class="c1"># This means that the first tag will be the correct</span>
                <span class="c1"># one. This is dangerous and maybe should be avoided in</span>
                <span class="c1"># the future</span>
                <span class="k">pass</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cls_to_tag_map</span><span class="p">[</span><span class="n">tag_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">tag</span>
                <span class="n">l_class_added_to_map</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># ALIASING ##############################</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tag_to_alias_map</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">aliased</span><span class="p">(</span><span class="n">ormclass</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;DEBUG: Exception caught in append, cleaning up&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  &quot;</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">l_class_added_to_map</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cls_to_tag_map</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tag_to_alias_map</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">raise</span>

        <span class="c1"># FILTERS ######################################</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_filters</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="c1"># So far, only Node and its subclasses need additional filters on column type</span>
            <span class="c1"># (for other classes, the &quot;classifi.</span>
            <span class="c1"># This so far only is necessary for AiidaNodes not for groups.</span>
            <span class="c1"># Now here there is the issue that for everything else,</span>
            <span class="c1"># the query_type_string is either None (e.g. if Group was passed)</span>
            <span class="c1"># or a list of None (if (Group, ) was passed.</span>
            <span class="c1"># Here we have to only call the function _add_type_filter essentially if it makes sense to</span>
            <span class="c1"># For now that is only nodes, and it is hardcoded. In the future (e.g. we subclass group)</span>
            <span class="c1"># this has to be added</span>
            <span class="k">if</span> <span class="n">ormclass</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">Node</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_add_type_filter</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="n">classifiers</span><span class="p">,</span> <span class="n">subclassing</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_add_process_type_filter</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="n">classifiers</span><span class="p">,</span> <span class="n">subclassing</span><span class="p">)</span>

            <span class="c1"># The order has to be first _add_type_filter and then add_filter.</span>
            <span class="c1"># If the user adds a query on the type column, it overwrites what I did</span>
            <span class="c1"># if the user specified a filter, add it:</span>
            <span class="k">if</span> <span class="n">filters</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_filter</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="n">filters</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;DEBUG: Exception caught in append (part filters), cleaning up&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  &quot;</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">l_class_added_to_map</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cls_to_tag_map</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tag_to_alias_map</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_filters</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span>
            <span class="k">raise</span>

        <span class="c1"># PROJECTIONS ##############################</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_projections</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="n">project</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_projection</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="n">project</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;DEBUG: Exception caught in append (part projections), cleaning up&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  &quot;</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">l_class_added_to_map</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cls_to_tag_map</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tag_to_alias_map</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_filters</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_projections</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">e</span>

        <span class="c1"># JOINING #####################################</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Get the functions that are implemented:</span>
            <span class="n">spec_to_function_map</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">secondary_dict</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_function_map</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">secondary_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">spec_to_function_map</span><span class="p">:</span>
                        <span class="n">spec_to_function_map</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="n">joining_keyword</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;joining_keyword&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">joining_value</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;joining_value&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">spec_to_function_map</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">InputValidationError</span><span class="p">(</span>
                        <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> is not a valid keyword &quot;</span>
                        <span class="s2">&quot;for joining specification</span><span class="se">\n</span><span class="s2">&quot;</span>
                        <span class="s2">&quot;Valid keywords are: &quot;</span>
                        <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">,</span>
                                    <span class="n">spec_to_function_map</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;cls&#39;</span><span class="p">,</span> <span class="s1">&#39;type&#39;</span><span class="p">,</span> <span class="s1">&#39;tag&#39;</span><span class="p">,</span> <span class="s1">&#39;autotag&#39;</span><span class="p">,</span> <span class="s1">&#39;filters&#39;</span><span class="p">,</span> <span class="s1">&#39;project&#39;</span><span class="p">]))</span>
                <span class="k">elif</span> <span class="n">joining_keyword</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">InputValidationError</span><span class="p">(</span><span class="s2">&quot;You already specified joining specification </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span>
                                               <span class="s2">&quot;But you now also want to specify </span><span class="si">{}</span><span class="s2">&quot;</span>
                                               <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">joining_keyword</span><span class="p">,</span> <span class="n">key</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">joining_keyword</span> <span class="o">=</span> <span class="n">key</span>
                    <span class="n">joining_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_tag_from_specification</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
            <span class="c1"># the default is that this vertice is &#39;with_incoming&#39; as the previous one</span>
            <span class="k">if</span> <span class="n">joining_keyword</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_path</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">joining_keyword</span> <span class="o">=</span> <span class="s1">&#39;with_incoming&#39;</span>
                <span class="n">joining_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;tag&#39;</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">joining_keyword</span> <span class="o">==</span> <span class="s1">&#39;direction&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">joining_value</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="n">InputValidationError</span><span class="p">(</span><span class="s2">&quot;direction=n expects n to be an integer&quot;</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">joining_value</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">joining_keyword</span> <span class="o">=</span> <span class="s1">&#39;with_outgoing&#39;</span>
                    <span class="k">elif</span> <span class="n">joining_value</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">joining_keyword</span> <span class="o">=</span> <span class="s1">&#39;with_incoming&#39;</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">InputValidationError</span><span class="p">(</span><span class="s2">&quot;direction=0 is not valid&quot;</span><span class="p">)</span>
                    <span class="n">joining_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_path</span><span class="p">[</span><span class="o">-</span><span class="nb">abs</span><span class="p">(</span><span class="n">joining_value</span><span class="p">)][</span><span class="s1">&#39;tag&#39;</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">IndexError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">InputValidationError</span><span class="p">(</span><span class="s2">&quot;You have specified a non-existent entity with</span><span class="se">\n</span><span class="s2">&quot;</span>
                                               <span class="s2">&quot;direction=</span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span>
                                               <span class="s2">&quot;</span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">joining_value</span><span class="p">,</span> <span class="n">exc</span><span class="p">))</span>

        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;DEBUG: Exception caught in append (part joining), cleaning up&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  &quot;</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">l_class_added_to_map</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cls_to_tag_map</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tag_to_alias_map</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_filters</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_projections</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span>
            <span class="c1"># There&#39;s not more to clean up here!</span>
            <span class="k">raise</span> <span class="n">e</span>

        <span class="c1"># EDGES #################################</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_path</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;DEBUG: Choosing an edge_tag&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">edge_tag</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">edge_destination_tag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_tag_from_specification</span><span class="p">(</span><span class="n">joining_value</span><span class="p">)</span>
                    <span class="n">edge_tag</span> <span class="o">=</span> <span class="n">edge_destination_tag</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_EDGE_TAG_DELIM</span> <span class="o">+</span> <span class="n">tag</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">edge_tag</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tag_to_alias_map</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                        <span class="k">raise</span> <span class="n">InputValidationError</span><span class="p">(</span><span class="s2">&quot;The tag </span><span class="si">{}</span><span class="s2"> is already in use&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">edge_tag</span><span class="p">))</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;I have chosen&quot;</span><span class="p">,</span> <span class="n">edge_tag</span><span class="p">)</span>

                <span class="c1"># My edge is None for now, since this is created on the FLY,</span>
                <span class="c1"># the _tag_to_alias_map will be updated later (in _build)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_tag_to_alias_map</span><span class="p">[</span><span class="n">edge_tag</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

                <span class="c1"># Filters on links:</span>
                <span class="c1"># Beware, I alway add this entry now, but filtering here might be</span>
                <span class="c1"># non-sensical, since this ONLY works for m2m relationship where</span>
                <span class="c1"># I go through a different table</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_filters</span><span class="p">[</span><span class="n">edge_tag</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">if</span> <span class="n">edge_filters</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">add_filter</span><span class="p">(</span><span class="n">edge_tag</span><span class="p">,</span> <span class="n">edge_filters</span><span class="p">)</span>
                <span class="c1"># Projections on links</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_projections</span><span class="p">[</span><span class="n">edge_tag</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">if</span> <span class="n">edge_project</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">add_projection</span><span class="p">(</span><span class="n">edge_tag</span><span class="p">,</span> <span class="n">edge_project</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;DEBUG: Exception caught in append (part joining), cleaning up&quot;</span><span class="p">)</span>
                    <span class="kn">import</span> <span class="nn">traceback</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">traceback</span><span class="o">.</span><span class="n">format_exc</span><span class="p">())</span>
                <span class="k">if</span> <span class="n">l_class_added_to_map</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_cls_to_tag_map</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_tag_to_alias_map</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_filters</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_projections</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">edge_tag</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_tag_to_alias_map</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">edge_tag</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_filters</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">edge_tag</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_projections</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">edge_tag</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="c1"># There&#39;s not more to clean up here!</span>
                <span class="k">raise</span> <span class="n">e</span>

        <span class="c1"># EXTENDING THE PATH #################################</span>
        <span class="c1"># Note: &#39;type&#39; being a list is a relict of an earlier implementation</span>
        <span class="c1"># Could simply pass all classifiers here.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">classifiers</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">path_type</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="s1">&#39;ormclass_type_string&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">classifiers</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">path_type</span> <span class="o">=</span> <span class="n">classifiers</span><span class="p">[</span><span class="s1">&#39;ormclass_type_string&#39;</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="nb">dict</span><span class="p">(</span>
                <span class="n">entity_type</span><span class="o">=</span><span class="n">path_type</span><span class="p">,</span>
                <span class="n">tag</span><span class="o">=</span><span class="n">tag</span><span class="p">,</span>
                <span class="n">joining_keyword</span><span class="o">=</span><span class="n">joining_keyword</span><span class="p">,</span>
                <span class="n">joining_value</span><span class="o">=</span><span class="n">joining_value</span><span class="p">,</span>
                <span class="n">outerjoin</span><span class="o">=</span><span class="n">outerjoin</span><span class="p">,</span>
                <span class="n">edge_tag</span><span class="o">=</span><span class="n">edge_tag</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="QueryBuilder.order_by"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.QueryBuilder.order_by">[docs]</a>    <span class="k">def</span> <span class="nf">order_by</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order_by</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the entity to order by</span>

<span class="sd">        :param order_by:</span>
<span class="sd">            This is a list of items, where each item is a dictionary specifies</span>
<span class="sd">            what to sort for an entity</span>

<span class="sd">        In each dictionary in that list, keys represent valid tags of</span>
<span class="sd">        entities (tables), and values are list of columns.</span>

<span class="sd">        Usage::</span>

<span class="sd">            #Sorting by id (ascending):</span>
<span class="sd">            qb = QueryBuilder()</span>
<span class="sd">            qb.append(Node, tag=&#39;node&#39;)</span>
<span class="sd">            qb.order_by({&#39;node&#39;:[&#39;id&#39;]})</span>

<span class="sd">            # or</span>
<span class="sd">            #Sorting by id (ascending):</span>
<span class="sd">            qb = QueryBuilder()</span>
<span class="sd">            qb.append(Node, tag=&#39;node&#39;)</span>
<span class="sd">            qb.order_by({&#39;node&#39;:[{&#39;id&#39;:{&#39;order&#39;:&#39;asc&#39;}}]})</span>

<span class="sd">            # for descending order:</span>
<span class="sd">            qb = QueryBuilder()</span>
<span class="sd">            qb.append(Node, tag=&#39;node&#39;)</span>
<span class="sd">            qb.order_by({&#39;node&#39;:[{&#39;id&#39;:{&#39;order&#39;:&#39;desc&#39;}}]})</span>

<span class="sd">            # or (shorter)</span>
<span class="sd">            qb = QueryBuilder()</span>
<span class="sd">            qb.append(Node, tag=&#39;node&#39;)</span>
<span class="sd">            qb.order_by({&#39;node&#39;:[{&#39;id&#39;:&#39;desc&#39;}]})</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_order_by</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">allowed_keys</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;cast&#39;</span><span class="p">,</span> <span class="s1">&#39;order&#39;</span><span class="p">)</span>
        <span class="n">possible_orders</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;asc&#39;</span><span class="p">,</span> <span class="s1">&#39;desc&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">order_by</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">order_by</span> <span class="o">=</span> <span class="p">[</span><span class="n">order_by</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">order_spec</span> <span class="ow">in</span> <span class="n">order_by</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">order_spec</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">InputValidationError</span><span class="p">(</span><span class="s2">&quot;Invalid input for order_by statement: </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span>
                                           <span class="s2">&quot;I am expecting a dictionary ORMClass,&quot;</span>
                                           <span class="s2">&quot;[columns to sort]&quot;</span>
                                           <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">order_spec</span><span class="p">))</span>
            <span class="n">_order_spec</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">tagspec</span><span class="p">,</span> <span class="n">items_to_order_by</span> <span class="ow">in</span> <span class="n">order_spec</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">items_to_order_by</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
                    <span class="n">items_to_order_by</span> <span class="o">=</span> <span class="p">[</span><span class="n">items_to_order_by</span><span class="p">]</span>
                <span class="n">tag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_tag_from_specification</span><span class="p">(</span><span class="n">tagspec</span><span class="p">)</span>
                <span class="n">_order_spec</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">item_to_order_by</span> <span class="ow">in</span> <span class="n">items_to_order_by</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item_to_order_by</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
                        <span class="n">item_to_order_by</span> <span class="o">=</span> <span class="p">{</span><span class="n">item_to_order_by</span><span class="p">:</span> <span class="p">{}}</span>
                    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item_to_order_by</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                        <span class="k">pass</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">InputValidationError</span><span class="p">(</span><span class="s2">&quot;Cannot deal with input to order_by </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span>
                                                   <span class="s2">&quot;of type</span><span class="si">{}</span><span class="s2">&quot;</span>
                                                   <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">item_to_order_by</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">item_to_order_by</span><span class="p">)))</span>
                    <span class="k">for</span> <span class="n">entityname</span><span class="p">,</span> <span class="n">orderspec</span> <span class="ow">in</span> <span class="n">item_to_order_by</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="c1"># if somebody specifies eg {&#39;node&#39;:{&#39;id&#39;:&#39;asc&#39;}}</span>
                        <span class="c1"># tranform to {&#39;node&#39;:{&#39;id&#39;:{&#39;order&#39;:&#39;asc&#39;}}}</span>

                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">orderspec</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
                            <span class="n">this_order_spec</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;order&#39;</span><span class="p">:</span> <span class="n">orderspec</span><span class="p">}</span>
                        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">orderspec</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                            <span class="n">this_order_spec</span> <span class="o">=</span> <span class="n">orderspec</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="n">InputValidationError</span><span class="p">(</span><span class="s2">&quot;I was expecting a string or a dictionary</span><span class="se">\n</span><span class="s2">&quot;</span>
                                                       <span class="s2">&quot;You provided </span><span class="si">{}</span><span class="s2"> </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span>
                                                       <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">orderspec</span><span class="p">),</span> <span class="n">orderspec</span><span class="p">))</span>
                        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">this_order_spec</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">allowed_keys</span><span class="p">:</span>
                                <span class="k">raise</span> <span class="n">InputValidationError</span><span class="p">(</span><span class="s2">&quot;The allowed keys for an order specification</span><span class="se">\n</span><span class="s2">&quot;</span>
                                                           <span class="s2">&quot;are </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span>
                                                           <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> is not valid</span><span class="se">\n</span><span class="s2">&quot;</span>
                                                           <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">allowed_keys</span><span class="p">),</span> <span class="n">key</span><span class="p">))</span>
                        <span class="n">this_order_spec</span><span class="p">[</span><span class="s1">&#39;order&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">this_order_spec</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;order&#39;</span><span class="p">,</span> <span class="s1">&#39;asc&#39;</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">this_order_spec</span><span class="p">[</span><span class="s1">&#39;order&#39;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">possible_orders</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="n">InputValidationError</span><span class="p">(</span><span class="s2">&quot;You gave </span><span class="si">{}</span><span class="s2"> as an order parameters,</span><span class="se">\n</span><span class="s2">&quot;</span>
                                                       <span class="s2">&quot;but it is not a valid order parameter</span><span class="se">\n</span><span class="s2">&quot;</span>
                                                       <span class="s2">&quot;Valid orders are: </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span>
                                                       <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">this_order_spec</span><span class="p">[</span><span class="s1">&#39;order&#39;</span><span class="p">],</span> <span class="n">possible_orders</span><span class="p">))</span>
                        <span class="n">item_to_order_by</span><span class="p">[</span><span class="n">entityname</span><span class="p">]</span> <span class="o">=</span> <span class="n">this_order_spec</span>

                    <span class="n">_order_spec</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item_to_order_by</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_order_by</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_order_spec</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="QueryBuilder.add_filter"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.QueryBuilder.add_filter">[docs]</a>    <span class="k">def</span> <span class="nf">add_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tagspec</span><span class="p">,</span> <span class="n">filter_spec</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adding a filter to my filters.</span>

<span class="sd">        :param tagspec: The tag, which has to exist already as a key in self._filters</span>
<span class="sd">        :param filter_spec: The specifications for the filter, has to be a dictionary</span>

<span class="sd">        Usage::</span>

<span class="sd">            qb = QueryBuilder()         # Instantiating the QueryBuilder instance</span>
<span class="sd">            qb.append(Node, tag=&#39;node&#39;) # Appending a Node</span>
<span class="sd">            #let&#39;s put some filters:</span>
<span class="sd">            qb.add_filter(&#39;node&#39;,{&#39;id&#39;:{&#39;&gt;&#39;:12}})</span>
<span class="sd">            # 2 filters together:</span>
<span class="sd">            qb.add_filter(&#39;node&#39;,{&#39;label&#39;:&#39;foo&#39;, &#39;uuid&#39;:{&#39;like&#39;:&#39;ab%&#39;}})</span>
<span class="sd">            # Now I am overriding the first filter I set:</span>
<span class="sd">            qb.add_filter(&#39;node&#39;,{&#39;id&#39;:13})</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">filters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_filters</span><span class="p">(</span><span class="n">filter_spec</span><span class="p">)</span>
        <span class="n">tag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_tag_from_specification</span><span class="p">(</span><span class="n">tagspec</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_filters</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">filters</span><span class="p">)</span></div>

<div class="viewcode-block" id="QueryBuilder._process_filters"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.QueryBuilder._process_filters">[docs]</a>    <span class="k">def</span> <span class="nf">_process_filters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filters</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">filters</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">InputValidationError</span><span class="p">(</span><span class="s2">&quot;Filters have to be passed as dictionaries&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">filters</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">entities</span><span class="o">.</span><span class="n">Entity</span><span class="p">):</span>
                <span class="c1"># Convert to be the id of the joined entity because we can&#39;t query</span>
                <span class="c1"># for the object instance directly</span>
                <span class="n">filters</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="n">filters</span><span class="p">[</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_id&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">)]</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">id</span>

        <span class="k">return</span> <span class="n">filters</span></div>

<div class="viewcode-block" id="QueryBuilder._add_type_filter"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.QueryBuilder._add_type_filter">[docs]</a>    <span class="k">def</span> <span class="nf">_add_type_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tagspec</span><span class="p">,</span> <span class="n">classifiers</span><span class="p">,</span> <span class="n">subclassing</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a filter based on type.</span>

<span class="sd">        :param tagspec: The tag, which has to exist already as a key in self._filters</span>
<span class="sd">        :param classifiers: a dictionary with classifiers</span>
<span class="sd">        :param subclassing: if True, allow for subclasses of the ormclass</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_tag_from_specification</span><span class="p">(</span><span class="n">tagspec</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">classifiers</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="c1"># If a list was passed to QueryBuilder.append, this propagates to a list in the classifiers</span>
            <span class="n">entity_type_filter</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;or&#39;</span><span class="p">:</span> <span class="p">[]}</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">classifiers</span><span class="p">:</span>
                <span class="n">entity_type_filter</span><span class="p">[</span><span class="s1">&#39;or&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">get_type_filter</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">subclassing</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">entity_type_filter</span> <span class="o">=</span> <span class="n">get_type_filter</span><span class="p">(</span><span class="n">classifiers</span><span class="p">,</span> <span class="n">subclassing</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_filter</span><span class="p">(</span><span class="n">tagspec</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;node_type&#39;</span><span class="p">:</span> <span class="n">entity_type_filter</span><span class="p">})</span></div>

<div class="viewcode-block" id="QueryBuilder._add_process_type_filter"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.QueryBuilder._add_process_type_filter">[docs]</a>    <span class="k">def</span> <span class="nf">_add_process_type_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tagspec</span><span class="p">,</span> <span class="n">classifiers</span><span class="p">,</span> <span class="n">subclassing</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a filter based on process type.</span>

<span class="sd">        :param tagspec: The tag, which has to exist already as a key in self._filters</span>
<span class="sd">        :param classifiers: a dictionary with classifiers</span>
<span class="sd">        :param subclassing: if True, allow for subclasses of the process type</span>

<span class="sd">        Note: This function handles the case when process_type_string is None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_tag_from_specification</span><span class="p">(</span><span class="n">tagspec</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">classifiers</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="c1"># If a list was passed to QueryBuilder.append, this propagates to a list in the classifiers</span>
            <span class="n">process_type_filter</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;or&#39;</span><span class="p">:</span> <span class="p">[]}</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">classifiers</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">c</span><span class="p">[</span><span class="s1">&#39;process_type_string&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">process_type_filter</span><span class="p">[</span><span class="s1">&#39;or&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">get_process_type_filter</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">subclassing</span><span class="p">))</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">process_type_filter</span><span class="p">[</span><span class="s1">&#39;or&#39;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_filter</span><span class="p">(</span><span class="n">tagspec</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;process_type&#39;</span><span class="p">:</span> <span class="n">process_type_filter</span><span class="p">})</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">classifiers</span><span class="p">[</span><span class="s1">&#39;process_type_string&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">process_type_filter</span> <span class="o">=</span> <span class="n">get_process_type_filter</span><span class="p">(</span><span class="n">classifiers</span><span class="p">,</span> <span class="n">subclassing</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_filter</span><span class="p">(</span><span class="n">tagspec</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;process_type&#39;</span><span class="p">:</span> <span class="n">process_type_filter</span><span class="p">})</span></div>


<div class="viewcode-block" id="QueryBuilder.add_projection"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.QueryBuilder.add_projection">[docs]</a>    <span class="k">def</span> <span class="nf">add_projection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tag_spec</span><span class="p">,</span> <span class="n">projection_spec</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a projection</span>

<span class="sd">        :param tag_spec: A valid specification for a tag</span>
<span class="sd">        :param projection_spec:</span>
<span class="sd">            The specification for the projection.</span>
<span class="sd">            A projection is a list of dictionaries, with each dictionary</span>
<span class="sd">            containing key-value pairs where the key is database entity</span>
<span class="sd">            (e.g. a column / an attribute) and the value is (optional)</span>
<span class="sd">            additional information on how to process this database entity.</span>

<span class="sd">        If the given *projection_spec* is not a list, it will be expanded to</span>
<span class="sd">        a list.</span>
<span class="sd">        If the listitems are not dictionaries, but strings (No additional</span>
<span class="sd">        processing of the projected results desired), they will be expanded to</span>
<span class="sd">        dictionaries.</span>

<span class="sd">        Usage::</span>

<span class="sd">            qb = QueryBuilder()</span>
<span class="sd">            qb.append(StructureData, tag=&#39;struc&#39;)</span>

<span class="sd">            # Will project the uuid and the kinds</span>
<span class="sd">            qb.add_projection(&#39;struc&#39;, [&#39;uuid&#39;, &#39;attributes.kinds&#39;])</span>

<span class="sd">        The above example will project the uuid and the kinds-attribute of all matching structures.</span>
<span class="sd">        There are 2 (so far) special keys.</span>

<span class="sd">        The single star *\** will project the *ORM-instance*::</span>

<span class="sd">            qb = QueryBuilder()</span>
<span class="sd">            qb.append(StructureData, tag=&#39;struc&#39;)</span>
<span class="sd">            # Will project the ORM instance</span>
<span class="sd">            qb.add_projection(&#39;struc&#39;, &#39;*&#39;)</span>
<span class="sd">            print type(qb.first()[0])</span>
<span class="sd">            # &gt;&gt;&gt; aiida.orm.nodes.data.structure.StructureData</span>

<span class="sd">        The double start *\*\** projects all possible projections of this entity:</span>

<span class="sd">            QueryBuilder().append(StructureData,tag=&#39;s&#39;, project=&#39;**&#39;).limit(1).dict()[0][&#39;s&#39;].keys()</span>

<span class="sd">            # &gt;&gt;&gt; u&#39;user_id, description, ctime, label, extras, mtime, id, attributes, dbcomputer_id, nodeversion, type, public, uuid&#39;</span>

<span class="sd">        Be aware that the result of *\*\** depends on the backend implementation.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_tag_from_specification</span><span class="p">(</span><span class="n">tag_spec</span><span class="p">)</span>
        <span class="n">_projections</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;DEBUG: Adding projection of&quot;</span><span class="p">,</span> <span class="n">tag_spec</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;   projection&quot;</span><span class="p">,</span> <span class="n">projection_spec</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">projection_spec</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">projection_spec</span> <span class="o">=</span> <span class="p">[</span><span class="n">projection_spec</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">projection</span> <span class="ow">in</span> <span class="n">projection_spec</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">projection</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">_thisprojection</span> <span class="o">=</span> <span class="n">projection</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">projection</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
                <span class="n">_thisprojection</span> <span class="o">=</span> <span class="p">{</span><span class="n">projection</span><span class="p">:</span> <span class="p">{}}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">InputValidationError</span><span class="p">(</span><span class="s2">&quot;Cannot deal with projection specification </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">projection</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">spec</span> <span class="ow">in</span> <span class="n">_thisprojection</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="n">InputValidationError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">The value of a key-value pair in a projection</span><span class="se">\n</span><span class="s2">&quot;</span>
                                               <span class="s2">&quot;has to be a dictionary</span><span class="se">\n</span><span class="s2">&quot;</span>
                                               <span class="s2">&quot;You gave: </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span>
                                               <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spec</span><span class="p">))</span>

                <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">spec</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_VALID_PROJECTION_KEYS</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">InputValidationError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> is not a valid key </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_VALID_PROJECTION_KEYS</span><span class="p">))</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="n">InputValidationError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> has to be a string&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>
            <span class="n">_projections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_thisprojection</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;   projections have become:&quot;</span><span class="p">,</span> <span class="n">_projections</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_projections</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">_projections</span></div>

<div class="viewcode-block" id="QueryBuilder._get_projectable_entity"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.QueryBuilder._get_projectable_entity">[docs]</a>    <span class="k">def</span> <span class="nf">_get_projectable_entity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alias</span><span class="p">,</span> <span class="n">column_name</span><span class="p">,</span> <span class="n">attrpath</span><span class="p">,</span> <span class="o">**</span><span class="n">entityspec</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">attrpath</span> <span class="ow">or</span> <span class="n">column_name</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;attributes&#39;</span><span class="p">,</span> <span class="s1">&#39;extras&#39;</span><span class="p">):</span>
            <span class="n">entity</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">get_projectable_attribute</span><span class="p">(</span><span class="n">alias</span><span class="p">,</span> <span class="n">column_name</span><span class="p">,</span> <span class="n">attrpath</span><span class="p">,</span> <span class="o">**</span><span class="n">entityspec</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">entity</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">get_column</span><span class="p">(</span><span class="n">column_name</span><span class="p">,</span> <span class="n">alias</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">entity</span></div>

<div class="viewcode-block" id="QueryBuilder._add_to_projections"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.QueryBuilder._add_to_projections">[docs]</a>    <span class="k">def</span> <span class="nf">_add_to_projections</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alias</span><span class="p">,</span> <span class="n">projectable_entity_name</span><span class="p">,</span> <span class="n">cast</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param alias: A instance of *sqlalchemy.orm.util.AliasedClass*, alias for an ormclass</span>
<span class="sd">        :type alias: :class:`sqlalchemy.orm.util.AliasedClass`</span>
<span class="sd">        :param projectable_entity_name:</span>
<span class="sd">            User specification of what to project.</span>
<span class="sd">            Appends to query&#39;s entities what the user wants to project</span>
<span class="sd">            (have returned by the query)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">column_name</span> <span class="o">=</span> <span class="n">projectable_entity_name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">attr_key</span> <span class="o">=</span> <span class="n">projectable_entity_name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span>

        <span class="k">if</span> <span class="n">column_name</span> <span class="o">==</span> <span class="s1">&#39;*&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">InputValidationError</span><span class="p">(</span><span class="s2">&quot;Very sorry, but functions on the aliased class</span><span class="se">\n</span><span class="s2">&quot;</span>
                                           <span class="s2">&quot;(You specified &#39;*&#39;)</span><span class="se">\n</span><span class="s2">&quot;</span>
                                           <span class="s2">&quot;will not work!</span><span class="se">\n</span><span class="s2">&quot;</span>
                                           <span class="s2">&quot;I suggest you apply functions on a column, e.g. (&#39;id&#39;)</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query</span><span class="o">.</span><span class="n">add_entity</span><span class="p">(</span><span class="n">alias</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">entity_to_project</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_projectable_entity</span><span class="p">(</span><span class="n">alias</span><span class="p">,</span> <span class="n">column_name</span><span class="p">,</span> <span class="n">attr_key</span><span class="p">,</span> <span class="n">cast</span><span class="o">=</span><span class="n">cast</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">elif</span> <span class="n">func</span> <span class="o">==</span> <span class="s1">&#39;max&#39;</span><span class="p">:</span>
                <span class="n">entity_to_project</span> <span class="o">=</span> <span class="n">sa_func</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">entity_to_project</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">func</span> <span class="o">==</span> <span class="s1">&#39;min&#39;</span><span class="p">:</span>
                <span class="n">entity_to_project</span> <span class="o">=</span> <span class="n">sa_func</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">entity_to_project</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">func</span> <span class="o">==</span> <span class="s1">&#39;count&#39;</span><span class="p">:</span>
                <span class="n">entity_to_project</span> <span class="o">=</span> <span class="n">sa_func</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">entity_to_project</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">InputValidationError</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Invalid function specification </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">func</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query</span><span class="o">.</span><span class="n">add_columns</span><span class="p">(</span><span class="n">entity_to_project</span><span class="p">)</span></div>

<div class="viewcode-block" id="QueryBuilder._build_projections"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.QueryBuilder._build_projections">[docs]</a>    <span class="k">def</span> <span class="nf">_build_projections</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">items_to_project</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">items_to_project</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">items_to_project</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_projections</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="p">[])</span>

        <span class="c1"># Return here if there is nothing to project,</span>
        <span class="c1"># reduces number of key in return dictionary</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="n">items_to_project</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">items_to_project</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">alias</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tag_to_alias_map</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tag_to_projected_entity_dict</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">projectable_spec</span> <span class="ow">in</span> <span class="n">items_to_project</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">projectable_entity_name</span><span class="p">,</span> <span class="n">extraspec</span> <span class="ow">in</span> <span class="n">projectable_spec</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">projectable_entity_name</span> <span class="o">==</span> <span class="s1">&#39;**&#39;</span><span class="p">:</span>
                    <span class="c1"># Need to expand</span>
                    <span class="n">entity_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">modify_expansions</span><span class="p">(</span>
                        <span class="n">alias</span><span class="p">,</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">alias</span><span class="o">.</span><span class="n">__table__</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">alias</span><span class="o">.</span><span class="n">__table__</span><span class="o">.</span><span class="n">columns</span><span class="p">])</span>
                    <span class="c1"># ~ for s in (&#39;attributes&#39;, &#39;extras&#39;):</span>
                    <span class="c1"># ~ try:</span>
                    <span class="c1"># ~ entity_names.remove(s)</span>
                    <span class="c1"># ~ except ValueError:</span>
                    <span class="c1"># ~ pass</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">entity_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">projectable_entity_name</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">entity_name</span> <span class="ow">in</span> <span class="n">entity_names</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_add_to_projections</span><span class="p">(</span><span class="n">alias</span><span class="p">,</span> <span class="n">entity_name</span><span class="p">,</span> <span class="o">**</span><span class="n">extraspec</span><span class="p">)</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">tag_to_projected_entity_dict</span><span class="p">[</span><span class="n">tag</span><span class="p">][</span><span class="n">entity_name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_of_projections</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">nr_of_projections</span> <span class="o">+=</span> <span class="mi">1</span></div>

<div class="viewcode-block" id="QueryBuilder._get_tag_from_specification"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.QueryBuilder._get_tag_from_specification">[docs]</a>    <span class="k">def</span> <span class="nf">_get_tag_from_specification</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">specification</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param specification: If that is a string, I assume the user has</span>
<span class="sd">            deliberately specified it with tag=specification.</span>
<span class="sd">            In that case, I simply check that it&#39;s not a duplicate.</span>
<span class="sd">            If it is a class, I check if it&#39;s in the _cls_to_tag_map!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">specification</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">specification</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tag_to_alias_map</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">tag</span> <span class="o">=</span> <span class="n">specification</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">InputValidationError</span><span class="p">(</span><span class="s2">&quot;tag </span><span class="si">{}</span><span class="s2"> is not among my known tags</span><span class="se">\n</span><span class="s2">&quot;</span>
                                           <span class="s2">&quot;My tags are: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">specification</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tag_to_alias_map</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">specification</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cls_to_tag_map</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">tag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cls_to_tag_map</span><span class="p">[</span><span class="n">specification</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">InputValidationError</span><span class="p">(</span><span class="s2">&quot;You specified as a class for which I have to find a tag</span><span class="se">\n</span><span class="s2">&quot;</span>
                                           <span class="s2">&quot;The classes that I can do this for are:</span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span>
                                           <span class="s2">&quot;The tags I have are: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">specification</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cls_to_tag_map</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span>
                                                                            <span class="bp">self</span><span class="o">.</span><span class="n">_tag_to_alias_map</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
        <span class="k">return</span> <span class="n">tag</span></div>

<div class="viewcode-block" id="QueryBuilder.set_debug"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.QueryBuilder.set_debug">[docs]</a>    <span class="k">def</span> <span class="nf">set_debug</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">debug</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run in debug mode. This does not affect functionality, but prints intermediate stages</span>
<span class="sd">        when creating a query on screen.</span>

<span class="sd">        :param bool debug: Turn debug on or off</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">debug</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">InputValidationError</span><span class="p">(</span><span class="s2">&quot;I expect a boolean&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_debug</span> <span class="o">=</span> <span class="n">debug</span>

        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="QueryBuilder.limit"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.QueryBuilder.limit">[docs]</a>    <span class="k">def</span> <span class="nf">limit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">limit</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the limit (nr of rows to return)</span>

<span class="sd">        :param int limit: integers of number of rows of rows to return</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">limit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">limit</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="n">InputValidationError</span><span class="p">(</span><span class="s2">&quot;The limit has to be an integer, or None&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_limit</span> <span class="o">=</span> <span class="n">limit</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="QueryBuilder.offset"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.QueryBuilder.offset">[docs]</a>    <span class="k">def</span> <span class="nf">offset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the offset. If offset is set, that many rows are skipped before returning.</span>
<span class="sd">        *offset* = 0 is the same as omitting setting the offset.</span>
<span class="sd">        If both offset and limit appear,</span>
<span class="sd">        then *offset* rows are skipped before starting to count the *limit* rows</span>
<span class="sd">        that are returned.</span>

<span class="sd">        :param int offset: integers of nr of rows to skip</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="n">InputValidationError</span><span class="p">(</span><span class="s2">&quot;offset has to be an integer, or None&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">=</span> <span class="n">offset</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="QueryBuilder._build_filters"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.QueryBuilder._build_filters">[docs]</a>    <span class="k">def</span> <span class="nf">_build_filters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alias</span><span class="p">,</span> <span class="n">filter_spec</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recurse through the filter specification and apply filter operations.</span>

<span class="sd">        :param alias: The alias of the ORM class the filter will be applied on</span>
<span class="sd">        :param filter_spec: the specification as given by the queryhelp</span>

<span class="sd">        :returns: an instance of *sqlalchemy.sql.elements.BinaryExpression*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">expressions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">path_spec</span><span class="p">,</span> <span class="n">filter_operation_dict</span> <span class="ow">in</span> <span class="n">filter_spec</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">path_spec</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;and&#39;</span><span class="p">,</span> <span class="s1">&#39;or&#39;</span><span class="p">,</span> <span class="s1">&#39;~or&#39;</span><span class="p">,</span> <span class="s1">&#39;~and&#39;</span><span class="p">,</span> <span class="s1">&#39;!and&#39;</span><span class="p">,</span> <span class="s1">&#39;!or&#39;</span><span class="p">):</span>
                <span class="n">subexpressions</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_build_filters</span><span class="p">(</span><span class="n">alias</span><span class="p">,</span> <span class="n">sub_filter_spec</span><span class="p">)</span> <span class="k">for</span> <span class="n">sub_filter_spec</span> <span class="ow">in</span> <span class="n">filter_operation_dict</span>
                <span class="p">]</span>
                <span class="k">if</span> <span class="n">path_spec</span> <span class="o">==</span> <span class="s1">&#39;and&#39;</span><span class="p">:</span>
                    <span class="n">expressions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">and_</span><span class="p">(</span><span class="o">*</span><span class="n">subexpressions</span><span class="p">))</span>
                <span class="k">elif</span> <span class="n">path_spec</span> <span class="o">==</span> <span class="s1">&#39;or&#39;</span><span class="p">:</span>
                    <span class="n">expressions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">or_</span><span class="p">(</span><span class="o">*</span><span class="n">subexpressions</span><span class="p">))</span>
                <span class="k">elif</span> <span class="n">path_spec</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;~and&#39;</span><span class="p">,</span> <span class="s1">&#39;!and&#39;</span><span class="p">):</span>
                    <span class="n">expressions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">not_</span><span class="p">(</span><span class="n">and_</span><span class="p">(</span><span class="o">*</span><span class="n">subexpressions</span><span class="p">)))</span>
                <span class="k">elif</span> <span class="n">path_spec</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;~or&#39;</span><span class="p">,</span> <span class="s1">&#39;!or&#39;</span><span class="p">):</span>
                    <span class="n">expressions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">not_</span><span class="p">(</span><span class="n">or_</span><span class="p">(</span><span class="o">*</span><span class="n">subexpressions</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">column_name</span> <span class="o">=</span> <span class="n">path_spec</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

                <span class="n">attr_key</span> <span class="o">=</span> <span class="n">path_spec</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span>
                <span class="n">is_attribute</span> <span class="o">=</span> <span class="p">(</span><span class="n">attr_key</span> <span class="ow">or</span> <span class="n">column_name</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;attributes&#39;</span><span class="p">,</span> <span class="s1">&#39;extras&#39;</span><span class="p">))</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">column</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">get_column</span><span class="p">(</span><span class="n">column_name</span><span class="p">,</span> <span class="n">alias</span><span class="p">)</span>
                <span class="k">except</span> <span class="n">InputValidationError</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">is_attribute</span><span class="p">:</span>
                        <span class="n">column</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">filter_operation_dict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="n">filter_operation_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;==&#39;</span><span class="p">:</span> <span class="n">filter_operation_dict</span><span class="p">}</span>
                <span class="p">[</span>
                    <span class="n">expressions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">get_filter_expr</span><span class="p">(</span>
                            <span class="n">operator</span><span class="p">,</span>
                            <span class="n">value</span><span class="p">,</span>
                            <span class="n">attr_key</span><span class="p">,</span>
                            <span class="n">is_attribute</span><span class="o">=</span><span class="n">is_attribute</span><span class="p">,</span>
                            <span class="n">column</span><span class="o">=</span><span class="n">column</span><span class="p">,</span>
                            <span class="n">column_name</span><span class="o">=</span><span class="n">column_name</span><span class="p">,</span>
                            <span class="n">alias</span><span class="o">=</span><span class="n">alias</span><span class="p">))</span> <span class="k">for</span> <span class="n">operator</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">filter_operation_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="p">]</span>
        <span class="k">return</span> <span class="n">and_</span><span class="p">(</span><span class="o">*</span><span class="n">expressions</span><span class="p">)</span></div>

<div class="viewcode-block" id="QueryBuilder._check_dbentities"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.QueryBuilder._check_dbentities">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_check_dbentities</span><span class="p">(</span><span class="n">entities_cls_joined</span><span class="p">,</span> <span class="n">entities_cls_to_join</span><span class="p">,</span> <span class="n">relationship</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param entities_cls_joined:</span>
<span class="sd">            A tuple of the aliased class passed as joined_entity and</span>
<span class="sd">            the ormclass that was expected</span>
<span class="sd">        :type entities_cls_to_join: tuple</span>
<span class="sd">        :param entities_cls_joined:</span>
<span class="sd">            A tuple of the aliased class passed as entity_to_join and</span>
<span class="sd">            the ormclass that was expected</span>
<span class="sd">        :type entities_cls_to_join: tuple</span>
<span class="sd">        :param str relationship:</span>
<span class="sd">            The relationship between the two entities to make the Exception</span>
<span class="sd">            comprehensible</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">entity</span><span class="p">,</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="p">(</span><span class="n">entities_cls_joined</span><span class="p">,</span> <span class="n">entities_cls_to_join</span><span class="p">):</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">entity</span><span class="o">.</span><span class="n">_sa_class_manager</span><span class="o">.</span><span class="n">class_</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">InputValidationError</span><span class="p">(</span><span class="s2">&quot;You are attempting to join </span><span class="si">{}</span><span class="s2"> as &#39;</span><span class="si">{}</span><span class="s2">&#39; of </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span>
                                           <span class="s2">&quot;This failed because you passed:</span><span class="se">\n</span><span class="s2">&quot;</span>
                                           <span class="s2">&quot; - </span><span class="si">{}</span><span class="s2"> as entity joined (expected </span><span class="si">{}</span><span class="s2">)</span><span class="se">\n</span><span class="s2">&quot;</span>
                                           <span class="s2">&quot; - </span><span class="si">{}</span><span class="s2"> as entity to join (expected </span><span class="si">{}</span><span class="s2">)</span><span class="se">\n</span><span class="s2">&quot;</span>
                                           <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                               <span class="n">entities_cls_joined</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                                               <span class="n">relationship</span><span class="p">,</span>
                                               <span class="n">entities_cls_to_join</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                                               <span class="n">entities_cls_joined</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_sa_class_manager</span><span class="o">.</span><span class="n">class_</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                                               <span class="n">entities_cls_joined</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                                               <span class="n">entities_cls_to_join</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_sa_class_manager</span><span class="o">.</span><span class="n">class_</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                                               <span class="n">entities_cls_to_join</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                                           <span class="p">))</span></div>

<div class="viewcode-block" id="QueryBuilder._join_outputs"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.QueryBuilder._join_outputs">[docs]</a>    <span class="k">def</span> <span class="nf">_join_outputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">joined_entity</span><span class="p">,</span> <span class="n">entity_to_join</span><span class="p">,</span> <span class="n">isouterjoin</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param joined_entity: The (aliased) ORMclass that is an input</span>
<span class="sd">        :param entity_to_join: The (aliased) ORMClass that is an output.</span>

<span class="sd">        **joined_entity** and **entity_to_join** are joined with a link</span>
<span class="sd">        from **joined_entity** as input to **enitity_to_join** as output</span>
<span class="sd">        (**enitity_to_join** is *with_incoming* **joined_entity**)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_dbentities</span><span class="p">((</span><span class="n">joined_entity</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">Node</span><span class="p">),</span> <span class="p">(</span><span class="n">entity_to_join</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">Node</span><span class="p">),</span> <span class="s1">&#39;with_incoming&#39;</span><span class="p">)</span>

        <span class="n">aliased_edge</span> <span class="o">=</span> <span class="n">aliased</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">Link</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="n">aliased_edge</span><span class="p">,</span> <span class="n">aliased_edge</span><span class="o">.</span><span class="n">input_id</span> <span class="o">==</span> <span class="n">joined_entity</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">isouter</span><span class="o">=</span><span class="n">isouterjoin</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="n">entity_to_join</span><span class="p">,</span> <span class="n">aliased_edge</span><span class="o">.</span><span class="n">output_id</span> <span class="o">==</span> <span class="n">entity_to_join</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">isouter</span><span class="o">=</span><span class="n">isouterjoin</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">aliased_edge</span></div>

<div class="viewcode-block" id="QueryBuilder._join_inputs"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.QueryBuilder._join_inputs">[docs]</a>    <span class="k">def</span> <span class="nf">_join_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">joined_entity</span><span class="p">,</span> <span class="n">entity_to_join</span><span class="p">,</span> <span class="n">isouterjoin</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param joined_entity: The (aliased) ORMclass that is an output</span>
<span class="sd">        :param entity_to_join: The (aliased) ORMClass that is an input.</span>

<span class="sd">        **joined_entity** and **entity_to_join** are joined with a link</span>
<span class="sd">        from **joined_entity** as output to **enitity_to_join** as input</span>
<span class="sd">        (**enitity_to_join** is *with_outgoing* **joined_entity**)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_check_dbentities</span><span class="p">((</span><span class="n">joined_entity</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">Node</span><span class="p">),</span> <span class="p">(</span><span class="n">entity_to_join</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">Node</span><span class="p">),</span> <span class="s1">&#39;with_outgoing&#39;</span><span class="p">)</span>
        <span class="n">aliased_edge</span> <span class="o">=</span> <span class="n">aliased</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">Link</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="n">aliased_edge</span><span class="p">,</span>
            <span class="n">aliased_edge</span><span class="o">.</span><span class="n">output_id</span> <span class="o">==</span> <span class="n">joined_entity</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
        <span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="n">entity_to_join</span><span class="p">,</span> <span class="n">aliased_edge</span><span class="o">.</span><span class="n">input_id</span> <span class="o">==</span> <span class="n">entity_to_join</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">isouter</span><span class="o">=</span><span class="n">isouterjoin</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">aliased_edge</span></div>

<div class="viewcode-block" id="QueryBuilder._join_descendants_recursive"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.QueryBuilder._join_descendants_recursive">[docs]</a>    <span class="k">def</span> <span class="nf">_join_descendants_recursive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">joined_entity</span><span class="p">,</span> <span class="n">entity_to_join</span><span class="p">,</span> <span class="n">isouterjoin</span><span class="p">,</span> <span class="n">filter_dict</span><span class="p">,</span> <span class="n">expand_path</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        joining descendants using the recursive functionality</span>
<span class="sd">        :TODO: Move the filters to be done inside the recursive query (for example on depth)</span>
<span class="sd">        :TODO: Pass an option to also show the path, if this is wanted.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_check_dbentities</span><span class="p">((</span><span class="n">joined_entity</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">Node</span><span class="p">),</span> <span class="p">(</span><span class="n">entity_to_join</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">Node</span><span class="p">),</span>
                               <span class="s1">&#39;with_ancestors&#39;</span><span class="p">)</span>

        <span class="n">link1</span> <span class="o">=</span> <span class="n">aliased</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">Link</span><span class="p">)</span>
        <span class="n">link2</span> <span class="o">=</span> <span class="n">aliased</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">Link</span><span class="p">)</span>
        <span class="n">node1</span> <span class="o">=</span> <span class="n">aliased</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">Node</span><span class="p">)</span>
        <span class="n">in_recursive_filters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_filters</span><span class="p">(</span><span class="n">node1</span><span class="p">,</span> <span class="n">filter_dict</span><span class="p">)</span>

        <span class="n">selection_walk_list</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">link1</span><span class="o">.</span><span class="n">input_id</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="s1">&#39;ancestor_id&#39;</span><span class="p">),</span>
            <span class="n">link1</span><span class="o">.</span><span class="n">output_id</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="s1">&#39;descendant_id&#39;</span><span class="p">),</span>
            <span class="n">cast</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Integer</span><span class="p">)</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="s1">&#39;depth&#39;</span><span class="p">),</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="n">expand_path</span><span class="p">:</span>
            <span class="n">selection_walk_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">array</span><span class="p">((</span><span class="n">link1</span><span class="o">.</span><span class="n">input_id</span><span class="p">,</span> <span class="n">link1</span><span class="o">.</span><span class="n">output_id</span><span class="p">))</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="s1">&#39;path&#39;</span><span class="p">))</span>

        <span class="n">walk</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">selection_walk_list</span><span class="p">)</span><span class="o">.</span><span class="n">select_from</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">node1</span><span class="p">,</span> <span class="n">link1</span><span class="p">,</span> <span class="n">link1</span><span class="o">.</span><span class="n">input_id</span> <span class="o">==</span> <span class="n">node1</span><span class="o">.</span><span class="n">id</span><span class="p">))</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="n">and_</span><span class="p">(</span>
                <span class="n">in_recursive_filters</span><span class="p">,</span>  <span class="c1"># I apply filters for speed here</span>
                <span class="n">link1</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">in_</span><span class="p">((</span><span class="n">LinkType</span><span class="o">.</span><span class="n">CREATE</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">LinkType</span><span class="o">.</span><span class="n">INPUT_CALC</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>  <span class="c1"># I follow input and create links</span>
            <span class="p">))</span><span class="o">.</span><span class="n">cte</span><span class="p">(</span><span class="n">recursive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">aliased_walk</span> <span class="o">=</span> <span class="n">aliased</span><span class="p">(</span><span class="n">walk</span><span class="p">)</span>

        <span class="n">selection_union_list</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">aliased_walk</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">ancestor_id</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="s1">&#39;ancestor_id&#39;</span><span class="p">),</span>
            <span class="n">link2</span><span class="o">.</span><span class="n">output_id</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="s1">&#39;descendant_id&#39;</span><span class="p">),</span> <span class="p">(</span><span class="n">aliased_walk</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">depth</span> <span class="o">+</span> <span class="n">cast</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Integer</span><span class="p">))</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="s1">&#39;current_depth&#39;</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="n">expand_path</span><span class="p">:</span>
            <span class="n">selection_union_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">aliased_walk</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">path</span> <span class="o">+</span> <span class="n">array</span><span class="p">((</span><span class="n">link2</span><span class="o">.</span><span class="n">output_id</span><span class="p">,)))</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="s1">&#39;path&#39;</span><span class="p">))</span>

        <span class="n">descendants_recursive</span> <span class="o">=</span> <span class="n">aliased</span><span class="p">(</span>
            <span class="n">aliased_walk</span><span class="o">.</span><span class="n">union_all</span><span class="p">(</span>
                <span class="n">select</span><span class="p">(</span><span class="n">selection_union_list</span><span class="p">)</span><span class="o">.</span><span class="n">select_from</span><span class="p">(</span>
                    <span class="n">join</span><span class="p">(</span>
                        <span class="n">aliased_walk</span><span class="p">,</span>
                        <span class="n">link2</span><span class="p">,</span>
                        <span class="n">link2</span><span class="o">.</span><span class="n">input_id</span> <span class="o">==</span> <span class="n">aliased_walk</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">descendant_id</span><span class="p">,</span>
                    <span class="p">))</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">link2</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">in_</span><span class="p">((</span><span class="n">LinkType</span><span class="o">.</span><span class="n">CREATE</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">LinkType</span><span class="o">.</span><span class="n">INPUT_CALC</span><span class="o">.</span><span class="n">value</span><span class="p">)))))</span>  <span class="c1"># .alias()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">descendants_recursive</span><span class="p">,</span>
                                       <span class="n">descendants_recursive</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">ancestor_id</span> <span class="o">==</span> <span class="n">joined_entity</span><span class="o">.</span><span class="n">id</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                                           <span class="n">entity_to_join</span><span class="p">,</span>
                                           <span class="n">descendants_recursive</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">descendant_id</span> <span class="o">==</span> <span class="n">entity_to_join</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
                                           <span class="n">isouter</span><span class="o">=</span><span class="n">isouterjoin</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">descendants_recursive</span><span class="o">.</span><span class="n">c</span></div>

<div class="viewcode-block" id="QueryBuilder._join_ancestors_recursive"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.QueryBuilder._join_ancestors_recursive">[docs]</a>    <span class="k">def</span> <span class="nf">_join_ancestors_recursive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">joined_entity</span><span class="p">,</span> <span class="n">entity_to_join</span><span class="p">,</span> <span class="n">isouterjoin</span><span class="p">,</span> <span class="n">filter_dict</span><span class="p">,</span> <span class="n">expand_path</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        joining ancestors using the recursive functionality</span>
<span class="sd">        :TODO: Move the filters to be done inside the recursive query (for example on depth)</span>
<span class="sd">        :TODO: Pass an option to also show the path, if this is wanted.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_dbentities</span><span class="p">((</span><span class="n">joined_entity</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">Node</span><span class="p">),</span> <span class="p">(</span><span class="n">entity_to_join</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">Node</span><span class="p">),</span>
                               <span class="s1">&#39;with_ancestors&#39;</span><span class="p">)</span>

        <span class="n">link1</span> <span class="o">=</span> <span class="n">aliased</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">Link</span><span class="p">)</span>
        <span class="n">link2</span> <span class="o">=</span> <span class="n">aliased</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">Link</span><span class="p">)</span>
        <span class="n">node1</span> <span class="o">=</span> <span class="n">aliased</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">Node</span><span class="p">)</span>
        <span class="n">in_recursive_filters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_filters</span><span class="p">(</span><span class="n">node1</span><span class="p">,</span> <span class="n">filter_dict</span><span class="p">)</span>

        <span class="n">selection_walk_list</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">link1</span><span class="o">.</span><span class="n">input_id</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="s1">&#39;ancestor_id&#39;</span><span class="p">),</span>
            <span class="n">link1</span><span class="o">.</span><span class="n">output_id</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="s1">&#39;descendant_id&#39;</span><span class="p">),</span>
            <span class="n">cast</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Integer</span><span class="p">)</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="s1">&#39;depth&#39;</span><span class="p">),</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="n">expand_path</span><span class="p">:</span>
            <span class="n">selection_walk_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">array</span><span class="p">((</span><span class="n">link1</span><span class="o">.</span><span class="n">output_id</span><span class="p">,</span> <span class="n">link1</span><span class="o">.</span><span class="n">input_id</span><span class="p">))</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="s1">&#39;path&#39;</span><span class="p">))</span>

        <span class="n">walk</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">selection_walk_list</span><span class="p">)</span><span class="o">.</span><span class="n">select_from</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">node1</span><span class="p">,</span> <span class="n">link1</span><span class="p">,</span> <span class="n">link1</span><span class="o">.</span><span class="n">output_id</span> <span class="o">==</span> <span class="n">node1</span><span class="o">.</span><span class="n">id</span><span class="p">))</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="n">and_</span><span class="p">(</span><span class="n">in_recursive_filters</span><span class="p">,</span> <span class="n">link1</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">in_</span><span class="p">((</span><span class="n">LinkType</span><span class="o">.</span><span class="n">CREATE</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                                                       <span class="n">LinkType</span><span class="o">.</span><span class="n">INPUT_CALC</span><span class="o">.</span><span class="n">value</span><span class="p">))))</span><span class="o">.</span><span class="n">cte</span><span class="p">(</span><span class="n">recursive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">aliased_walk</span> <span class="o">=</span> <span class="n">aliased</span><span class="p">(</span><span class="n">walk</span><span class="p">)</span>

        <span class="n">selection_union_list</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">link2</span><span class="o">.</span><span class="n">input_id</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="s1">&#39;ancestor_id&#39;</span><span class="p">),</span>
            <span class="n">aliased_walk</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">descendant_id</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="s1">&#39;descendant_id&#39;</span><span class="p">),</span>
            <span class="p">(</span><span class="n">aliased_walk</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">depth</span> <span class="o">+</span> <span class="n">cast</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Integer</span><span class="p">))</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="s1">&#39;current_depth&#39;</span><span class="p">),</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="n">expand_path</span><span class="p">:</span>
            <span class="n">selection_union_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">aliased_walk</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">path</span> <span class="o">+</span> <span class="n">array</span><span class="p">((</span><span class="n">link2</span><span class="o">.</span><span class="n">input_id</span><span class="p">,)))</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="s1">&#39;path&#39;</span><span class="p">))</span>

        <span class="n">ancestors_recursive</span> <span class="o">=</span> <span class="n">aliased</span><span class="p">(</span>
            <span class="n">aliased_walk</span><span class="o">.</span><span class="n">union_all</span><span class="p">(</span>
                <span class="n">select</span><span class="p">(</span><span class="n">selection_union_list</span><span class="p">)</span><span class="o">.</span><span class="n">select_from</span><span class="p">(</span>
                    <span class="n">join</span><span class="p">(</span>
                        <span class="n">aliased_walk</span><span class="p">,</span>
                        <span class="n">link2</span><span class="p">,</span>
                        <span class="n">link2</span><span class="o">.</span><span class="n">output_id</span> <span class="o">==</span> <span class="n">aliased_walk</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">ancestor_id</span><span class="p">,</span>
                    <span class="p">))</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">link2</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">in_</span><span class="p">((</span><span class="n">LinkType</span><span class="o">.</span><span class="n">CREATE</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">LinkType</span><span class="o">.</span><span class="n">INPUT_CALC</span><span class="o">.</span><span class="n">value</span><span class="p">)))</span>
                <span class="c1"># I can&#39;t follow RETURN or CALL links</span>
            <span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">ancestors_recursive</span><span class="p">,</span>
                                       <span class="n">ancestors_recursive</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">descendant_id</span> <span class="o">==</span> <span class="n">joined_entity</span><span class="o">.</span><span class="n">id</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                                           <span class="n">entity_to_join</span><span class="p">,</span>
                                           <span class="n">ancestors_recursive</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">ancestor_id</span> <span class="o">==</span> <span class="n">entity_to_join</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
                                           <span class="n">isouter</span><span class="o">=</span><span class="n">isouterjoin</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ancestors_recursive</span><span class="o">.</span><span class="n">c</span></div>

<div class="viewcode-block" id="QueryBuilder._join_group_members"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.QueryBuilder._join_group_members">[docs]</a>    <span class="k">def</span> <span class="nf">_join_group_members</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">joined_entity</span><span class="p">,</span> <span class="n">entity_to_join</span><span class="p">,</span> <span class="n">isouterjoin</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param joined_entity:</span>
<span class="sd">            The (aliased) ORMclass that is</span>
<span class="sd">            a group in the database</span>
<span class="sd">        :param entity_to_join:</span>
<span class="sd">            The (aliased) ORMClass that is a node and member of the group</span>

<span class="sd">        **joined_entity** and **entity_to_join**</span>
<span class="sd">        are joined via the table_groups_nodes table.</span>
<span class="sd">        from **joined_entity** as group to **enitity_to_join** as node.</span>
<span class="sd">        (**enitity_to_join** is *with_group* **joined_entity**)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_dbentities</span><span class="p">((</span><span class="n">joined_entity</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">Group</span><span class="p">),</span> <span class="p">(</span><span class="n">entity_to_join</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">Node</span><span class="p">),</span> <span class="s1">&#39;with_group&#39;</span><span class="p">)</span>
        <span class="n">aliased_group_nodes</span> <span class="o">=</span> <span class="n">aliased</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">table_groups_nodes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">aliased_group_nodes</span><span class="p">,</span> <span class="n">aliased_group_nodes</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">dbgroup_id</span> <span class="o">==</span> <span class="n">joined_entity</span><span class="o">.</span><span class="n">id</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="n">entity_to_join</span><span class="p">,</span> <span class="n">entity_to_join</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">aliased_group_nodes</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">dbnode_id</span><span class="p">,</span> <span class="n">isouter</span><span class="o">=</span><span class="n">isouterjoin</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">aliased_group_nodes</span></div>

<div class="viewcode-block" id="QueryBuilder._join_groups"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.QueryBuilder._join_groups">[docs]</a>    <span class="k">def</span> <span class="nf">_join_groups</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">joined_entity</span><span class="p">,</span> <span class="n">entity_to_join</span><span class="p">,</span> <span class="n">isouterjoin</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param joined_entity: The (aliased) node in the database</span>
<span class="sd">        :param entity_to_join: The (aliased) Group</span>

<span class="sd">        **joined_entity** and **entity_to_join** are</span>
<span class="sd">        joined via the table_groups_nodes table.</span>
<span class="sd">        from **joined_entity** as node to **enitity_to_join** as group.</span>
<span class="sd">        (**enitity_to_join** is a group *with_node* **joined_entity**)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_dbentities</span><span class="p">((</span><span class="n">joined_entity</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">Node</span><span class="p">),</span> <span class="p">(</span><span class="n">entity_to_join</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">Group</span><span class="p">),</span> <span class="s1">&#39;with_node&#39;</span><span class="p">)</span>
        <span class="n">aliased_group_nodes</span> <span class="o">=</span> <span class="n">aliased</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">table_groups_nodes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">aliased_group_nodes</span><span class="p">,</span> <span class="n">aliased_group_nodes</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">dbnode_id</span> <span class="o">==</span> <span class="n">joined_entity</span><span class="o">.</span><span class="n">id</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="n">entity_to_join</span><span class="p">,</span> <span class="n">entity_to_join</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">aliased_group_nodes</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">dbgroup_id</span><span class="p">,</span> <span class="n">isouter</span><span class="o">=</span><span class="n">isouterjoin</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">aliased_group_nodes</span></div>

<div class="viewcode-block" id="QueryBuilder._join_creator_of"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.QueryBuilder._join_creator_of">[docs]</a>    <span class="k">def</span> <span class="nf">_join_creator_of</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">joined_entity</span><span class="p">,</span> <span class="n">entity_to_join</span><span class="p">,</span> <span class="n">isouterjoin</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param joined_entity: the aliased node</span>
<span class="sd">        :param entity_to_join: the aliased user to join to that node</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_dbentities</span><span class="p">((</span><span class="n">joined_entity</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">Node</span><span class="p">),</span> <span class="p">(</span><span class="n">entity_to_join</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">User</span><span class="p">),</span> <span class="s1">&#39;with_node&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">entity_to_join</span><span class="p">,</span> <span class="n">entity_to_join</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">joined_entity</span><span class="o">.</span><span class="n">user_id</span><span class="p">,</span> <span class="n">isouter</span><span class="o">=</span><span class="n">isouterjoin</span><span class="p">)</span></div>

<div class="viewcode-block" id="QueryBuilder._join_created_by"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.QueryBuilder._join_created_by">[docs]</a>    <span class="k">def</span> <span class="nf">_join_created_by</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">joined_entity</span><span class="p">,</span> <span class="n">entity_to_join</span><span class="p">,</span> <span class="n">isouterjoin</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param joined_entity: the aliased user you want to join to</span>
<span class="sd">        :param entity_to_join: the (aliased) node or group in the DB to join with</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_dbentities</span><span class="p">((</span><span class="n">joined_entity</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">User</span><span class="p">),</span> <span class="p">(</span><span class="n">entity_to_join</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">Node</span><span class="p">),</span> <span class="s1">&#39;with_user&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">entity_to_join</span><span class="p">,</span> <span class="n">entity_to_join</span><span class="o">.</span><span class="n">user_id</span> <span class="o">==</span> <span class="n">joined_entity</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">isouter</span><span class="o">=</span><span class="n">isouterjoin</span><span class="p">)</span></div>

<div class="viewcode-block" id="QueryBuilder._join_to_computer_used"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.QueryBuilder._join_to_computer_used">[docs]</a>    <span class="k">def</span> <span class="nf">_join_to_computer_used</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">joined_entity</span><span class="p">,</span> <span class="n">entity_to_join</span><span class="p">,</span> <span class="n">isouterjoin</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param joined_entity: the (aliased) computer entity</span>
<span class="sd">        :param entity_to_join: the (aliased) node entity</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_dbentities</span><span class="p">((</span><span class="n">joined_entity</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">Computer</span><span class="p">),</span> <span class="p">(</span><span class="n">entity_to_join</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">Node</span><span class="p">),</span> <span class="s1">&#39;with_computer&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="n">entity_to_join</span><span class="p">,</span> <span class="n">entity_to_join</span><span class="o">.</span><span class="n">dbcomputer_id</span> <span class="o">==</span> <span class="n">joined_entity</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">isouter</span><span class="o">=</span><span class="n">isouterjoin</span><span class="p">)</span></div>

<div class="viewcode-block" id="QueryBuilder._join_computer"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.QueryBuilder._join_computer">[docs]</a>    <span class="k">def</span> <span class="nf">_join_computer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">joined_entity</span><span class="p">,</span> <span class="n">entity_to_join</span><span class="p">,</span> <span class="n">isouterjoin</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param joined_entity: An entity that can use a computer (eg a node)</span>
<span class="sd">        :param entity_to_join: aliased dbcomputer entity</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_dbentities</span><span class="p">((</span><span class="n">joined_entity</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">Node</span><span class="p">),</span> <span class="p">(</span><span class="n">entity_to_join</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">Computer</span><span class="p">),</span> <span class="s1">&#39;with_node&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="n">entity_to_join</span><span class="p">,</span> <span class="n">joined_entity</span><span class="o">.</span><span class="n">dbcomputer_id</span> <span class="o">==</span> <span class="n">entity_to_join</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">isouter</span><span class="o">=</span><span class="n">isouterjoin</span><span class="p">)</span></div>

<div class="viewcode-block" id="QueryBuilder._join_group_user"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.QueryBuilder._join_group_user">[docs]</a>    <span class="k">def</span> <span class="nf">_join_group_user</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">joined_entity</span><span class="p">,</span> <span class="n">entity_to_join</span><span class="p">,</span> <span class="n">isouterjoin</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param joined_entity: An aliased dbgroup</span>
<span class="sd">        :param entity_to_join: aliased dbuser</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_dbentities</span><span class="p">((</span><span class="n">joined_entity</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">Group</span><span class="p">),</span> <span class="p">(</span><span class="n">entity_to_join</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">User</span><span class="p">),</span> <span class="s1">&#39;with_group&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">entity_to_join</span><span class="p">,</span> <span class="n">joined_entity</span><span class="o">.</span><span class="n">user_id</span> <span class="o">==</span> <span class="n">entity_to_join</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">isouter</span><span class="o">=</span><span class="n">isouterjoin</span><span class="p">)</span></div>

<div class="viewcode-block" id="QueryBuilder._join_user_group"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.QueryBuilder._join_user_group">[docs]</a>    <span class="k">def</span> <span class="nf">_join_user_group</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">joined_entity</span><span class="p">,</span> <span class="n">entity_to_join</span><span class="p">,</span> <span class="n">isouterjoin</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param joined_entity: An aliased user</span>
<span class="sd">        :param entity_to_join: aliased group</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_dbentities</span><span class="p">((</span><span class="n">joined_entity</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">User</span><span class="p">),</span> <span class="p">(</span><span class="n">entity_to_join</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">Group</span><span class="p">),</span> <span class="s1">&#39;with_user&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">entity_to_join</span><span class="p">,</span> <span class="n">joined_entity</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">entity_to_join</span><span class="o">.</span><span class="n">user_id</span><span class="p">,</span> <span class="n">isouter</span><span class="o">=</span><span class="n">isouterjoin</span><span class="p">)</span></div>

<div class="viewcode-block" id="QueryBuilder._join_node_comment"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.QueryBuilder._join_node_comment">[docs]</a>    <span class="k">def</span> <span class="nf">_join_node_comment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">joined_entity</span><span class="p">,</span> <span class="n">entity_to_join</span><span class="p">,</span> <span class="n">isouterjoin</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param joined_entity: An aliased node</span>
<span class="sd">        :param entity_to_join: aliased comment</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_dbentities</span><span class="p">((</span><span class="n">joined_entity</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">Node</span><span class="p">),</span> <span class="p">(</span><span class="n">entity_to_join</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">Comment</span><span class="p">),</span> <span class="s1">&#39;with_node&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="n">entity_to_join</span><span class="p">,</span> <span class="n">joined_entity</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">entity_to_join</span><span class="o">.</span><span class="n">dbnode_id</span><span class="p">,</span> <span class="n">isouter</span><span class="o">=</span><span class="n">isouterjoin</span><span class="p">)</span></div>

<div class="viewcode-block" id="QueryBuilder._join_comment_node"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.QueryBuilder._join_comment_node">[docs]</a>    <span class="k">def</span> <span class="nf">_join_comment_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">joined_entity</span><span class="p">,</span> <span class="n">entity_to_join</span><span class="p">,</span> <span class="n">isouterjoin</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param joined_entity: An aliased comment</span>
<span class="sd">        :param entity_to_join: aliased node</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_dbentities</span><span class="p">((</span><span class="n">joined_entity</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">Comment</span><span class="p">),</span> <span class="p">(</span><span class="n">entity_to_join</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">Node</span><span class="p">),</span> <span class="s1">&#39;with_comment&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="n">entity_to_join</span><span class="p">,</span> <span class="n">joined_entity</span><span class="o">.</span><span class="n">dbnode_id</span> <span class="o">==</span> <span class="n">entity_to_join</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">isouter</span><span class="o">=</span><span class="n">isouterjoin</span><span class="p">)</span></div>

<div class="viewcode-block" id="QueryBuilder._join_node_log"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.QueryBuilder._join_node_log">[docs]</a>    <span class="k">def</span> <span class="nf">_join_node_log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">joined_entity</span><span class="p">,</span> <span class="n">entity_to_join</span><span class="p">,</span> <span class="n">isouterjoin</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param joined_entity: An aliased node</span>
<span class="sd">        :param entity_to_join: aliased log</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_dbentities</span><span class="p">((</span><span class="n">joined_entity</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">Node</span><span class="p">),</span> <span class="p">(</span><span class="n">entity_to_join</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">Log</span><span class="p">),</span> <span class="s1">&#39;with_node&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="n">entity_to_join</span><span class="p">,</span> <span class="n">joined_entity</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">entity_to_join</span><span class="o">.</span><span class="n">dbnode_id</span><span class="p">,</span> <span class="n">isouter</span><span class="o">=</span><span class="n">isouterjoin</span><span class="p">)</span></div>

<div class="viewcode-block" id="QueryBuilder._join_log_node"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.QueryBuilder._join_log_node">[docs]</a>    <span class="k">def</span> <span class="nf">_join_log_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">joined_entity</span><span class="p">,</span> <span class="n">entity_to_join</span><span class="p">,</span> <span class="n">isouterjoin</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param joined_entity: An aliased log</span>
<span class="sd">        :param entity_to_join: aliased node</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_dbentities</span><span class="p">((</span><span class="n">joined_entity</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">Log</span><span class="p">),</span> <span class="p">(</span><span class="n">entity_to_join</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">Node</span><span class="p">),</span> <span class="s1">&#39;with_log&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="n">entity_to_join</span><span class="p">,</span> <span class="n">joined_entity</span><span class="o">.</span><span class="n">dbnode_id</span> <span class="o">==</span> <span class="n">entity_to_join</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">isouter</span><span class="o">=</span><span class="n">isouterjoin</span><span class="p">)</span></div>

<div class="viewcode-block" id="QueryBuilder._join_user_comment"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.QueryBuilder._join_user_comment">[docs]</a>    <span class="k">def</span> <span class="nf">_join_user_comment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">joined_entity</span><span class="p">,</span> <span class="n">entity_to_join</span><span class="p">,</span> <span class="n">isouterjoin</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param joined_entity: An aliased user</span>
<span class="sd">        :param entity_to_join: aliased comment</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_dbentities</span><span class="p">((</span><span class="n">joined_entity</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">User</span><span class="p">),</span> <span class="p">(</span><span class="n">entity_to_join</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">Comment</span><span class="p">),</span> <span class="s1">&#39;with_user&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">entity_to_join</span><span class="p">,</span> <span class="n">joined_entity</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">entity_to_join</span><span class="o">.</span><span class="n">user_id</span><span class="p">,</span> <span class="n">isouter</span><span class="o">=</span><span class="n">isouterjoin</span><span class="p">)</span></div>

<div class="viewcode-block" id="QueryBuilder._join_comment_user"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.QueryBuilder._join_comment_user">[docs]</a>    <span class="k">def</span> <span class="nf">_join_comment_user</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">joined_entity</span><span class="p">,</span> <span class="n">entity_to_join</span><span class="p">,</span> <span class="n">isouterjoin</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param joined_entity: An aliased comment</span>
<span class="sd">        :param entity_to_join: aliased user</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_dbentities</span><span class="p">((</span><span class="n">joined_entity</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">Comment</span><span class="p">),</span> <span class="p">(</span><span class="n">entity_to_join</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">User</span><span class="p">),</span> <span class="s1">&#39;with_comment&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">entity_to_join</span><span class="p">,</span> <span class="n">joined_entity</span><span class="o">.</span><span class="n">user_id</span> <span class="o">==</span> <span class="n">entity_to_join</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">isouter</span><span class="o">=</span><span class="n">isouterjoin</span><span class="p">)</span></div>

<div class="viewcode-block" id="QueryBuilder._get_function_map"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.QueryBuilder._get_function_map">[docs]</a>    <span class="k">def</span> <span class="nf">_get_function_map</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Map relationship type keywords to functions</span>
<span class="sd">        The new mapping (since 1.0.0a5) is a two level dictionary. The first level defines the entity which has been passed to</span>
<span class="sd">        the qb.append functon, and the second defines the relationship with respect to a given tag.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mapping</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;node&#39;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s1">&#39;with_log&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_join_log_node</span><span class="p">,</span>
                <span class="s1">&#39;with_comment&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_join_comment_node</span><span class="p">,</span>
                <span class="s1">&#39;with_incoming&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_join_outputs</span><span class="p">,</span>
                <span class="s1">&#39;with_outgoing&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_join_inputs</span><span class="p">,</span>
                <span class="s1">&#39;with_descendants&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_join_ancestors_recursive</span><span class="p">,</span>
                <span class="s1">&#39;with_ancestors&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_join_descendants_recursive</span><span class="p">,</span>
                <span class="s1">&#39;with_computer&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_join_to_computer_used</span><span class="p">,</span>
                <span class="s1">&#39;with_user&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_join_created_by</span><span class="p">,</span>
                <span class="s1">&#39;with_group&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_join_group_members</span><span class="p">,</span>
                <span class="s1">&#39;direction&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;ancestor_of&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deprecate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_join_ancestors_recursive</span><span class="p">,</span> <span class="s1">&#39;ancestor_of&#39;</span><span class="p">,</span> <span class="s1">&#39;with_descendants&#39;</span><span class="p">),</span>
                <span class="s1">&#39;descendant_of&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deprecate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_join_descendants_recursive</span><span class="p">,</span> <span class="s1">&#39;descendant_of&#39;</span><span class="p">,</span> <span class="s1">&#39;with_ancestors&#39;</span><span class="p">),</span>
                <span class="s1">&#39;input_of&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deprecate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_join_inputs</span><span class="p">,</span> <span class="s1">&#39;input_of&#39;</span><span class="p">,</span> <span class="s1">&#39;with_outgoing&#39;</span><span class="p">),</span>
                <span class="s1">&#39;output_of&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deprecate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_join_outputs</span><span class="p">,</span> <span class="s1">&#39;output_of&#39;</span><span class="p">,</span> <span class="s1">&#39;with_incoming&#39;</span><span class="p">),</span>
                <span class="s1">&#39;has_computer&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deprecate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_join_to_computer_used</span><span class="p">,</span> <span class="s1">&#39;has_computer&#39;</span><span class="p">,</span> <span class="s1">&#39;with_computer&#39;</span><span class="p">),</span>
                <span class="s1">&#39;created_by&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deprecate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_join_created_by</span><span class="p">,</span> <span class="s1">&#39;created_by&#39;</span><span class="p">,</span> <span class="s1">&#39;with_user&#39;</span><span class="p">),</span>
                <span class="s1">&#39;member_of&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deprecate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_join_group_members</span><span class="p">,</span> <span class="s1">&#39;member_of&#39;</span><span class="p">,</span> <span class="s1">&#39;with_group&#39;</span><span class="p">)</span>
            <span class="p">},</span>
            <span class="s1">&#39;computer&#39;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s1">&#39;with_node&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_join_computer</span><span class="p">,</span>
                <span class="s1">&#39;direction&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;computer_of&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deprecate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_join_computer</span><span class="p">,</span> <span class="s1">&#39;computer_of&#39;</span><span class="p">,</span> <span class="s1">&#39;with_node&#39;</span><span class="p">)</span>
            <span class="p">},</span>
            <span class="s1">&#39;user&#39;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s1">&#39;with_comment&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_join_comment_user</span><span class="p">,</span>
                <span class="s1">&#39;with_node&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_join_creator_of</span><span class="p">,</span>
                <span class="s1">&#39;with_group&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_join_group_user</span><span class="p">,</span>
                <span class="s1">&#39;direction&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;creator_of&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deprecate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_join_creator_of</span><span class="p">,</span> <span class="s1">&#39;creator_of&#39;</span><span class="p">,</span> <span class="s1">&#39;with_node&#39;</span><span class="p">),</span>
                <span class="s1">&#39;owner_of&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deprecate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_join_group_user</span><span class="p">,</span> <span class="s1">&#39;owner_of&#39;</span><span class="p">,</span> <span class="s1">&#39;with_group&#39;</span><span class="p">)</span>
            <span class="p">},</span>
            <span class="s1">&#39;group&#39;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s1">&#39;with_node&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_join_groups</span><span class="p">,</span>
                <span class="s1">&#39;with_user&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_join_user_group</span><span class="p">,</span>
                <span class="s1">&#39;direction&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;group_of&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deprecate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_join_groups</span><span class="p">,</span> <span class="s1">&#39;group_of&#39;</span><span class="p">,</span> <span class="s1">&#39;with_node&#39;</span><span class="p">),</span>
                <span class="s1">&#39;belongs_to&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deprecate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_join_user_group</span><span class="p">,</span> <span class="s1">&#39;belongs_to&#39;</span><span class="p">,</span> <span class="s1">&#39;with_user&#39;</span><span class="p">)</span>
            <span class="p">},</span>
            <span class="s1">&#39;comment&#39;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s1">&#39;with_user&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_join_user_comment</span><span class="p">,</span>
                <span class="s1">&#39;with_node&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_join_node_comment</span><span class="p">,</span>
                <span class="s1">&#39;direction&#39;</span><span class="p">:</span> <span class="kc">None</span>
            <span class="p">},</span>
            <span class="s1">&#39;log&#39;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s1">&#39;with_node&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_join_node_log</span><span class="p">,</span>
                <span class="s1">&#39;direction&#39;</span><span class="p">:</span> <span class="kc">None</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">mapping</span></div>

<div class="viewcode-block" id="QueryBuilder._get_connecting_node"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.QueryBuilder._get_connecting_node">[docs]</a>    <span class="k">def</span> <span class="nf">_get_connecting_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">joining_keyword</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">joining_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param querydict:</span>
<span class="sd">            A dictionary specifying how the current node</span>
<span class="sd">            is linked to other nodes.</span>
<span class="sd">        :param index: Index of this node within the path specification</span>
<span class="sd">        :param joining_keyword: the relation on which to join</span>
<span class="sd">        :param joining_value: the tag of the nodes to be joined</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Set the calling entity - to allow for the correct join relation to be set</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_path</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="s1">&#39;entity_type&#39;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;computer&#39;</span><span class="p">,</span> <span class="s1">&#39;user&#39;</span><span class="p">,</span> <span class="s1">&#39;group&#39;</span><span class="p">,</span> <span class="s1">&#39;comment&#39;</span><span class="p">,</span> <span class="s1">&#39;log&#39;</span><span class="p">]:</span>
            <span class="n">calling_entity</span> <span class="o">=</span> <span class="s1">&#39;node&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">calling_entity</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_path</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="s1">&#39;entity_type&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">joining_keyword</span> <span class="o">==</span> <span class="s1">&#39;direction&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">joining_value</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">returnval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aliased_path</span><span class="p">[</span><span class="n">index</span> <span class="o">-</span> <span class="n">joining_value</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_join_outputs</span>
            <span class="k">elif</span> <span class="n">joining_value</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">returnval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aliased_path</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="n">joining_value</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_join_inputs</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Direction 0 is not valid&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_function_map</span><span class="p">()[</span><span class="n">calling_entity</span><span class="p">][</span><span class="n">joining_keyword</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">InputValidationError</span><span class="p">(</span><span class="s2">&quot;&#39;</span><span class="si">{}</span><span class="s2">&#39; is not a valid joining keyword for a &#39;</span><span class="si">{}</span><span class="s2">&#39; type entity&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">joining_keyword</span><span class="p">,</span> <span class="n">calling_entity</span><span class="p">))</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">joining_value</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">returnval</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_aliased_path</span><span class="p">[</span><span class="n">joining_value</span><span class="p">],</span> <span class="n">func</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">joining_value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">returnval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tag_to_alias_map</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_tag_from_specification</span><span class="p">(</span><span class="n">joining_value</span><span class="p">)],</span> <span class="n">func</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">InputValidationError</span><span class="p">(</span><span class="s1">&#39;Key </span><span class="si">{}</span><span class="s1"> is unknown to the types I know about:</span><span class="se">\n</span><span class="s1">&#39;</span>
                                               <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                                   <span class="bp">self</span><span class="o">.</span><span class="n">_get_tag_from_specification</span><span class="p">(</span><span class="n">joining_value</span><span class="p">),</span>
                                                   <span class="bp">self</span><span class="o">.</span><span class="n">_tag_to_alias_map</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
        <span class="k">return</span> <span class="n">returnval</span></div>

<div class="viewcode-block" id="QueryBuilder._get_json_compatible"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.QueryBuilder._get_json_compatible">[docs]</a>    <span class="k">def</span> <span class="nf">_get_json_compatible</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inp</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param inp:</span>
<span class="sd">            The input value that will be converted.</span>
<span class="sd">            Recurses into each value if **inp** is an iterable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">aiida</span> <span class="k">import</span> <span class="n">orm</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">inp</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">inp</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_json_compatible</span><span class="p">(</span><span class="n">key</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_json_compatible</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">inp</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_json_compatible</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">inp</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">inspect_isclass</span><span class="p">(</span><span class="n">inp</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">AiidaNode</span><span class="p">):</span>
                <span class="k">return</span> <span class="s1">&#39;.&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">_plugin_type_string</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">orm</span><span class="o">.</span><span class="n">Group</span><span class="p">):</span>
                <span class="k">return</span> <span class="s1">&#39;group&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">InputValidationError</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;unsupported type </span><span class="si">{}</span><span class="s1"> for input value&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">inp</span><span class="p">)))</span>

        <span class="k">return</span> <span class="n">inp</span></div>

<div class="viewcode-block" id="QueryBuilder.get_json_compatible_queryhelp"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.QueryBuilder.get_json_compatible_queryhelp">[docs]</a>    <span class="k">def</span> <span class="nf">get_json_compatible_queryhelp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Makes the queryhelp a json-compatible dictionary.</span>

<span class="sd">        In this way,the queryhelp can be stored</span>
<span class="sd">        in the database or a json-object, retrieved or shared and used later.</span>
<span class="sd">        See this usage::</span>

<span class="sd">            qb = QueryBuilder(limit=3).append(StructureData, project=&#39;id&#39;).order_by({StructureData:&#39;id&#39;})</span>
<span class="sd">            queryhelp  = qb.get_json_compatible_queryhelp()</span>

<span class="sd">            # Now I could save this dictionary somewhere and use it later:</span>

<span class="sd">            qb2=QueryBuilder(**queryhelp)</span>

<span class="sd">            # This is True if no change has been made to the database.</span>
<span class="sd">            # Note that such a comparison can only be True if the order of results is enforced</span>
<span class="sd">            qb.all()==qb2.all()</span>

<span class="sd">        :returns: the json-compatible queryhelp</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">({</span>
            <span class="s1">&#39;path&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_path</span><span class="p">,</span>
            <span class="s1">&#39;filters&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filters</span><span class="p">,</span>
            <span class="s1">&#39;project&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_projections</span><span class="p">,</span>
            <span class="s1">&#39;order_by&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_order_by</span><span class="p">,</span>
            <span class="s1">&#39;limit&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_limit</span><span class="p">,</span>
            <span class="s1">&#39;offset&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span><span class="p">,</span>
        <span class="p">})</span></div>

<div class="viewcode-block" id="QueryBuilder._build_order"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.QueryBuilder._build_order">[docs]</a>    <span class="k">def</span> <span class="nf">_build_order</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alias</span><span class="p">,</span> <span class="n">entitytag</span><span class="p">,</span> <span class="n">entityspec</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build the order parameter of the query</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">column_name</span> <span class="o">=</span> <span class="n">entitytag</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">attrpath</span> <span class="o">=</span> <span class="n">entitytag</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">if</span> <span class="n">attrpath</span> <span class="ow">and</span> <span class="s1">&#39;cast&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">entityspec</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">InputValidationError</span><span class="p">(</span><span class="s2">&quot;In order to project (</span><span class="si">{}</span><span class="s2">), I have to cast the the values,</span><span class="se">\n</span><span class="s2">&quot;</span>
                                       <span class="s2">&quot;but you have not specified the datatype to cast to</span><span class="se">\n</span><span class="s2">&quot;</span>
                                       <span class="s2">&quot;You can do this with keyword &#39;cast&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">entitytag</span><span class="p">))</span>

        <span class="n">entity</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_projectable_entity</span><span class="p">(</span><span class="n">alias</span><span class="p">,</span> <span class="n">column_name</span><span class="p">,</span> <span class="n">attrpath</span><span class="p">,</span> <span class="o">**</span><span class="n">entityspec</span><span class="p">)</span>
        <span class="n">order</span> <span class="o">=</span> <span class="n">entityspec</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;order&#39;</span><span class="p">,</span> <span class="s1">&#39;asc&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">order</span> <span class="o">==</span> <span class="s1">&#39;desc&#39;</span><span class="p">:</span>
            <span class="n">entity</span> <span class="o">=</span> <span class="n">entity</span><span class="o">.</span><span class="n">desc</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">entity</span><span class="p">)</span></div>

<div class="viewcode-block" id="QueryBuilder._build"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.QueryBuilder._build">[docs]</a>    <span class="k">def</span> <span class="nf">_build</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        build the query and return a sqlalchemy.Query instance</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># self.tags_location_dict is a dictionary that</span>
        <span class="c1"># maps the tag to its index in the list</span>
        <span class="c1"># this is basically the mapping between the count</span>
        <span class="c1"># of nodes traversed</span>
        <span class="c1"># and the tag used for that node</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tags_location_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">path</span><span class="p">[</span><span class="s1">&#39;tag&#39;</span><span class="p">]:</span> <span class="n">index</span> <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">path</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_path</span><span class="p">)}</span>

        <span class="c1"># Starting the query by receiving a session</span>
        <span class="c1"># Every subclass needs to have _get_session and give me the</span>
        <span class="c1"># right session</span>
        <span class="n">firstalias</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tag_to_alias_map</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_path</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;tag&#39;</span><span class="p">]]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">get_session</span><span class="p">()</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">firstalias</span><span class="p">)</span>

        <span class="c1"># JOINS ################################</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">verticespec</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_path</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">alias</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tag_to_alias_map</span><span class="p">[</span><span class="n">verticespec</span><span class="p">[</span><span class="s1">&#39;tag&#39;</span><span class="p">]]</span>
            <span class="c1"># looping through the queryhelp</span>
            <span class="c1"># ~ if index:</span>
            <span class="c1"># There is nothing to join if that is the first table</span>
            <span class="n">toconnectwith</span><span class="p">,</span> <span class="n">connection_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_connecting_node</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="o">**</span><span class="n">verticespec</span><span class="p">)</span>
            <span class="n">isouterjoin</span> <span class="o">=</span> <span class="n">verticespec</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;outerjoin&#39;</span><span class="p">)</span>
            <span class="n">edge_tag</span> <span class="o">=</span> <span class="n">verticespec</span><span class="p">[</span><span class="s1">&#39;edge_tag&#39;</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">verticespec</span><span class="p">[</span><span class="s1">&#39;joining_keyword&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;with_ancestors&#39;</span><span class="p">,</span> <span class="s1">&#39;with_descendants&#39;</span><span class="p">,</span> <span class="s1">&#39;ancestor_of&#39;</span><span class="p">,</span> <span class="s1">&#39;descendant_of&#39;</span><span class="p">):</span>
                <span class="c1"># I treat those two cases in a special way.</span>
                <span class="c1"># I give them a filter_dict, to help the recursive function find a good</span>
                <span class="c1"># starting point. TODO: document this!</span>
                <span class="n">filter_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filters</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">verticespec</span><span class="p">[</span><span class="s1">&#39;joining_value&#39;</span><span class="p">],</span> <span class="p">{})</span>
                <span class="c1"># I also find out whether the path is used in a filter or a project</span>
                <span class="c1"># if so, I instruct the recursive function to build the path on the fly!</span>
                <span class="c1"># The default is False, cause it&#39;s super expensive</span>
                <span class="n">expand_path</span> <span class="o">=</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_filters</span><span class="p">[</span><span class="n">edge_tag</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;path&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span>
                               <span class="nb">any</span><span class="p">([</span><span class="s1">&#39;path&#39;</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_projections</span><span class="p">[</span><span class="n">edge_tag</span><span class="p">]]))</span>
                <span class="n">aliased_edge</span> <span class="o">=</span> <span class="n">connection_func</span><span class="p">(</span>
                    <span class="n">toconnectwith</span><span class="p">,</span> <span class="n">alias</span><span class="p">,</span> <span class="n">isouterjoin</span><span class="o">=</span><span class="n">isouterjoin</span><span class="p">,</span> <span class="n">filter_dict</span><span class="o">=</span><span class="n">filter_dict</span><span class="p">,</span> <span class="n">expand_path</span><span class="o">=</span><span class="n">expand_path</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">aliased_edge</span> <span class="o">=</span> <span class="n">connection_func</span><span class="p">(</span><span class="n">toconnectwith</span><span class="p">,</span> <span class="n">alias</span><span class="p">,</span> <span class="n">isouterjoin</span><span class="o">=</span><span class="n">isouterjoin</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">aliased_edge</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_tag_to_alias_map</span><span class="p">[</span><span class="n">edge_tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">aliased_edge</span>

        <span class="c1">######################### FILTERS ##############################</span>

        <span class="k">for</span> <span class="n">tag</span><span class="p">,</span> <span class="n">filter_specs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filters</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">alias</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tag_to_alias_map</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="c1"># TODO Check KeyError before?</span>
                <span class="k">raise</span> <span class="n">InputValidationError</span><span class="p">(</span><span class="s1">&#39;You looked for tag </span><span class="si">{}</span><span class="s1"> among the alias list</span><span class="se">\n</span><span class="s1">&#39;</span>
                                           <span class="s1">&#39;The tags I know are:</span><span class="se">\n</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tag_to_alias_map</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_build_filters</span><span class="p">(</span><span class="n">alias</span><span class="p">,</span> <span class="n">filter_specs</span><span class="p">))</span>

        <span class="c1">######################### PROJECTIONS ##########################</span>
        <span class="c1"># first clear the entities in the case the first item in the</span>
        <span class="c1"># path was not meant to be projected</span>
        <span class="c1"># attribute of Query instance storing entities to project:</span>

        <span class="c1"># Will be later set to this list:</span>
        <span class="n">entities</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Mapping between enitites and the tag used/ given by user:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tag_to_projected_entity_dict</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nr_of_projections</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;DEBUG:&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;   Printing the content of self._projections&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_projections</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_projections</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="c1"># If user has not set projection,</span>
            <span class="c1"># I will simply project the last item specified!</span>
            <span class="c1"># Don&#39;t change, path traversal querying</span>
            <span class="c1"># relies on this behavior!</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_build_projections</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;tag&#39;</span><span class="p">],</span> <span class="n">items_to_project</span><span class="o">=</span><span class="p">[{</span><span class="s1">&#39;*&#39;</span><span class="p">:</span> <span class="p">{}}])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_path</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_build_projections</span><span class="p">(</span><span class="n">vertex</span><span class="p">[</span><span class="s1">&#39;tag&#39;</span><span class="p">])</span>

            <span class="c1"># LINK-PROJECTIONS #########################</span>

            <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_path</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">edge_tag</span> <span class="o">=</span> <span class="n">vertex</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;edge_tag&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;DEBUG: Checking projections for edges:&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;   This is edge </span><span class="si">{}</span><span class="s2"> from </span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2"> of </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">edge_tag</span><span class="p">,</span> <span class="n">vertex</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;tag&#39;</span><span class="p">),</span>
                                                                        <span class="n">vertex</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;joining_keyword&#39;</span><span class="p">),</span>
                                                                        <span class="n">vertex</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;joining_value&#39;</span><span class="p">)))</span>
                <span class="k">if</span> <span class="n">edge_tag</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_build_projections</span><span class="p">(</span><span class="n">edge_tag</span><span class="p">)</span>

        <span class="c1"># ORDER ################################</span>
        <span class="k">for</span> <span class="n">order_spec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_order_by</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">tag</span><span class="p">,</span> <span class="n">entities</span> <span class="ow">in</span> <span class="n">order_spec</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">alias</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tag_to_alias_map</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">entitydict</span> <span class="ow">in</span> <span class="n">entities</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">entitytag</span><span class="p">,</span> <span class="n">entityspec</span> <span class="ow">in</span> <span class="n">entitydict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_build_order</span><span class="p">(</span><span class="n">alias</span><span class="p">,</span> <span class="n">entitytag</span><span class="p">,</span> <span class="n">entityspec</span><span class="p">)</span>

        <span class="c1"># LIMIT ################################</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_limit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query</span><span class="o">.</span><span class="n">limit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_limit</span><span class="p">)</span>

        <span class="c1">######################## OFFSET ################################</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query</span><span class="o">.</span><span class="n">offset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_offset</span><span class="p">)</span>

        <span class="c1">################ LAST BUT NOT LEAST ############################</span>
        <span class="c1"># pop the entity that I added to start the query</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_query</span><span class="o">.</span><span class="n">_entities</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Dirty solution coming up:</span>
        <span class="c1"># Sqlalchemy is by default de-duplicating results if possible.</span>
        <span class="c1"># This can lead to strange results, as shown in:</span>
        <span class="c1"># https://github.com/aiidateam/aiida_core/issues/1600</span>
        <span class="c1"># essentially qb.count() != len(qb.all()) in some cases.</span>
        <span class="c1"># We also addressed this with sqlachemy:</span>
        <span class="c1"># https://github.com/sqlalchemy/sqlalchemy/issues/4395#event-2002418814</span>
        <span class="c1"># where the following solution was sanctioned:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_query</span><span class="o">.</span><span class="n">_has_mapper_entities</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># We should monitor SQLAlchemy, for when a solution is officially supported by the API!</span>

        <span class="c1"># Make a list that helps the projection postprocessing</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_attrkeys_as_in_sql_result</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">index_in_sql_result</span><span class="p">:</span> <span class="n">attrkey</span> <span class="k">for</span> <span class="n">tag</span><span class="p">,</span> <span class="n">projected_entities_dict</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tag_to_projected_entity_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">attrkey</span><span class="p">,</span> <span class="n">index_in_sql_result</span> <span class="ow">in</span> <span class="n">projected_entities_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nr_of_projections</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_attrkeys_as_in_sql_result</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">InputValidationError</span><span class="p">(</span><span class="s2">&quot;You are projecting the same key multiple times within the same node&quot;</span><span class="p">)</span>
        <span class="c1">######################### DONE #################################</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query</span></div>

<div class="viewcode-block" id="QueryBuilder.except_if_input_to"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.QueryBuilder.except_if_input_to">[docs]</a>    <span class="k">def</span> <span class="nf">except_if_input_to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calc_class</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Makes counterquery based on the own path, only selecting</span>
<span class="sd">        entries that have been input to *calc_class*</span>

<span class="sd">        :param calc_class: The calculation class to check against</span>

<span class="sd">        :returns: self</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">build_counterquery</span><span class="p">(</span><span class="n">calc_class</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">calc_class</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Node</span><span class="p">):</span>
                <span class="n">orm_calc_class</span> <span class="o">=</span> <span class="n">calc_class</span>
                <span class="n">type_spec</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">calc_class</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">AiidaNode</span><span class="p">):</span>
                <span class="n">orm_calc_class</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Node</span>
                <span class="n">type_spec</span> <span class="o">=</span> <span class="n">calc_class</span><span class="o">.</span><span class="n">_plugin_type_string</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;You have given me </span><span class="si">{}</span><span class="se">\n</span><span class="s1">&#39;</span>
                                <span class="s1">&#39;of type </span><span class="si">{}</span><span class="se">\n</span><span class="s1">&#39;</span>
                                <span class="s2">&quot;and I don&#39;t know what to do with that&quot;</span>
                                <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">calc_class</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">calc_class</span><span class="p">)))</span>

            <span class="n">input_alias_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_path</span><span class="p">:</span>
                <span class="n">tag</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;tag&#39;</span><span class="p">]</span>
                <span class="n">requested_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">key</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_projections</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">item</span><span class="o">.</span><span class="n">keys</span><span class="p">()]</span>
                <span class="k">if</span> <span class="s1">&#39;*&#39;</span> <span class="ow">in</span> <span class="n">requested_cols</span><span class="p">:</span>
                    <span class="n">input_alias_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">aliased</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tag_to_alias_map</span><span class="p">[</span><span class="n">tag</span><span class="p">]))</span>

            <span class="n">counterquery</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_imp</span><span class="o">.</span><span class="n">_get_session</span><span class="p">()</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">orm_calc_class</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">type_spec</span><span class="p">:</span>
                <span class="n">counterquery</span> <span class="o">=</span> <span class="n">counterquery</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">orm_calc_class</span><span class="o">.</span><span class="n">entity_type</span> <span class="o">==</span> <span class="n">type_spec</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">alias</span> <span class="ow">in</span> <span class="n">input_alias_list</span><span class="p">:</span>
                <span class="n">link</span> <span class="o">=</span> <span class="n">aliased</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Link</span><span class="p">)</span>
                <span class="n">counterquery</span> <span class="o">=</span> <span class="n">counterquery</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">orm_calc_class</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">link</span><span class="o">.</span><span class="n">output_id</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="n">alias</span><span class="p">,</span> <span class="n">alias</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">link</span><span class="o">.</span><span class="n">input_id</span><span class="p">)</span>
                <span class="n">counterquery</span> <span class="o">=</span> <span class="n">counterquery</span><span class="o">.</span><span class="n">add_entity</span><span class="p">(</span><span class="n">alias</span><span class="p">)</span>
            <span class="n">counterquery</span><span class="o">.</span><span class="n">_entities</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">counterquery</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_query</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query</span><span class="o">.</span><span class="n">except_</span><span class="p">(</span><span class="n">build_counterquery</span><span class="p">(</span><span class="n">calc_class</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="QueryBuilder.get_aliases"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.QueryBuilder.get_aliases">[docs]</a>    <span class="k">def</span> <span class="nf">get_aliases</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :returns: the list of aliases</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aliased_path</span></div>

<div class="viewcode-block" id="QueryBuilder.get_alias"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.QueryBuilder.get_alias">[docs]</a>    <span class="k">def</span> <span class="nf">get_alias</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tag</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        In order to continue a query by the user, this utility function</span>
<span class="sd">        returns the aliased ormclasses.</span>

<span class="sd">        :param tag: The tag for a vertice in the path</span>
<span class="sd">        :returns: the alias given for that vertice</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_tag_from_specification</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tag_to_alias_map</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span></div>

<div class="viewcode-block" id="QueryBuilder.get_used_tags"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.QueryBuilder.get_used_tags">[docs]</a>    <span class="k">def</span> <span class="nf">get_used_tags</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertices</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of all the vertices that are being used.</span>
<span class="sd">        Some parameter allow to select only subsets.</span>
<span class="sd">        :param bool vertices: Defaults to True. If True, adds the tags of vertices to the returned list</span>
<span class="sd">        :param bool edges: Defaults to True. If True,  adds the tags of edges to the returnend list.</span>

<span class="sd">        :returns: A list of all tags, including (if there is) also the tag give for the edges</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">given_tags</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">path</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_path</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">vertices</span><span class="p">:</span>
                <span class="n">given_tags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="s1">&#39;tag&#39;</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">edges</span> <span class="ow">and</span> <span class="n">idx</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">given_tags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="s1">&#39;edge_tag&#39;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">given_tags</span></div>

<div class="viewcode-block" id="QueryBuilder.get_query"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.QueryBuilder.get_query">[docs]</a>    <span class="k">def</span> <span class="nf">get_query</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Instantiates and manipulates a sqlalchemy.orm.Query instance if this is needed.</span>
<span class="sd">        First,  I check if the query instance is still valid by hashing the queryhelp.</span>
<span class="sd">        In this way, if a user asks for the same query twice, I am not recreating an instance.</span>

<span class="sd">        :returns: an instance of sqlalchemy.orm.Query that is specific to the backend used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">aiida.common.hashing</span> <span class="k">import</span> <span class="n">make_hash</span>

        <span class="c1"># Need_to_build is True by default.</span>
        <span class="c1"># It describes whether the current query</span>
        <span class="c1"># which is an attribute _query of this instance is still valid</span>
        <span class="c1"># The queryhelp_hash is used to determine</span>
        <span class="c1"># whether the query is still valid</span>

        <span class="n">queryhelp_hash</span> <span class="o">=</span> <span class="n">make_hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_json_compatible_queryhelp</span><span class="p">())</span>
        <span class="c1"># if self._hash (which is None if this function has not been invoked</span>
        <span class="c1"># and is a string (hash) if it has) is the same as the queryhelp</span>
        <span class="c1"># I can use the query again:</span>
        <span class="c1"># If the query was injected I never build:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">need_to_build</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_injected</span><span class="p">:</span>
            <span class="n">need_to_build</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span> <span class="o">==</span> <span class="n">queryhelp_hash</span><span class="p">:</span>
            <span class="n">need_to_build</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">need_to_build</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">need_to_build</span><span class="p">:</span>
            <span class="n">query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span> <span class="o">=</span> <span class="n">queryhelp_hash</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="n">_LOGGER</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;AttributeError thrown even though I should have _query as an attribute&quot;</span><span class="p">)</span>
                <span class="n">query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span> <span class="o">=</span> <span class="n">queryhelp_hash</span>
        <span class="k">return</span> <span class="n">query</span></div>

<div class="viewcode-block" id="QueryBuilder.get_aiida_entity_res"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.QueryBuilder.get_aiida_entity_res">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_aiida_entity_res</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert a projected query result to front end class if it is an instance of a `BackendEntity`.</span>

<span class="sd">        Values that are not an `BackendEntity` instance will be returned unaltered</span>

<span class="sd">        :param value: a projected query result to convert</span>
<span class="sd">        :return: the converted value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">convert</span><span class="o">.</span><span class="n">get_orm_entity</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">value</span></div>

<div class="viewcode-block" id="QueryBuilder.inject_query"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.QueryBuilder.inject_query">[docs]</a>    <span class="k">def</span> <span class="nf">inject_query</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Manipulate the query an inject it back.</span>
<span class="sd">        This can be done to add custom filters using SQLA.</span>
<span class="sd">        :param query: A sqlalchemy.orm.Query instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="k">import</span> <span class="n">Query</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">Query</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">InputValidationError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> must be a subclass of </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">Query</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_query</span> <span class="o">=</span> <span class="n">query</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_injected</span> <span class="o">=</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="QueryBuilder.distinct"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.QueryBuilder.distinct">[docs]</a>    <span class="k">def</span> <span class="nf">distinct</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Asks for distinct rows, which is the same as asking the backend to remove</span>
<span class="sd">        duplicates.</span>
<span class="sd">        Does not execute the query!</span>

<span class="sd">        If you want a distinct query::</span>

<span class="sd">            qb = QueryBuilder()</span>
<span class="sd">            # append stuff!</span>
<span class="sd">            qb.append(...)</span>
<span class="sd">            qb.append(...)</span>
<span class="sd">            ...</span>
<span class="sd">            qb.distinct().all() #or</span>
<span class="sd">            qb.distinct().dict()</span>

<span class="sd">        :returns: self</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_query</span><span class="p">()</span><span class="o">.</span><span class="n">distinct</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="QueryBuilder.first"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.QueryBuilder.first">[docs]</a>    <span class="k">def</span> <span class="nf">first</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Executes query asking for one instance.</span>
<span class="sd">        Use as follows::</span>

<span class="sd">            qb = QueryBuilder(**queryhelp)</span>
<span class="sd">            qb.first()</span>

<span class="sd">        :returns:</span>
<span class="sd">            One row of results as a list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_query</span><span class="p">()</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">first</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">result</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_attrkeys_as_in_sql_result</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;length of query result does not match the number of specified projections&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_aiida_entity_res</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">get_aiida_res</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_attrkeys_as_in_sql_result</span><span class="p">[</span><span class="n">colindex</span><span class="p">],</span> <span class="n">rowitem</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">colindex</span><span class="p">,</span> <span class="n">rowitem</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="p">]</span></div>

<div class="viewcode-block" id="QueryBuilder.one"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.QueryBuilder.one">[docs]</a>    <span class="k">def</span> <span class="nf">one</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Executes the query asking for exactly one results. Will raise an exception if this is not the case</span>
<span class="sd">        :raises: MultipleObjectsError if more then one row can be returned</span>
<span class="sd">        :raises: NotExistent if no result was found</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">aiida.common.exceptions</span> <span class="k">import</span> <span class="n">MultipleObjectsError</span><span class="p">,</span> <span class="n">NotExistent</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">limit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MultipleObjectsError</span><span class="p">(</span><span class="s2">&quot;More than one result was found&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NotExistent</span><span class="p">(</span><span class="s2">&quot;No result was found&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="QueryBuilder.count"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.QueryBuilder.count">[docs]</a>    <span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Counts the number of rows returned by the backend.</span>

<span class="sd">        :returns: the number of rows as an integer</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_query</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">query</span><span class="p">)</span></div>

<div class="viewcode-block" id="QueryBuilder.iterall"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.QueryBuilder.iterall">[docs]</a>    <span class="k">def</span> <span class="nf">iterall</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Same as :meth:`.all`, but returns a generator.</span>
<span class="sd">        Be aware that this is only safe if no commit will take place during this</span>
<span class="sd">        transaction. You might also want to read the SQLAlchemy documentation on</span>
<span class="sd">        http://docs.sqlalchemy.org/en/latest/orm/query.html#sqlalchemy.orm.query.Query.yield_per</span>


<span class="sd">        :param int batch_size:</span>
<span class="sd">            The size of the batches to ask the backend to batch results in subcollections.</span>
<span class="sd">            You can optimize the speed of the query by tuning this parameter.</span>

<span class="sd">        :returns: a generator of lists</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_query</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">iterall</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attrkeys_as_in_sql_result</span><span class="p">):</span>
            <span class="c1"># Convert to AiiDA frontend entities (if they are such)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">item_entry</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
                <span class="n">item</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_aiida_entity_res</span><span class="p">(</span><span class="n">item_entry</span><span class="p">)</span>

            <span class="k">yield</span> <span class="n">item</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="QueryBuilder.iterdict"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.QueryBuilder.iterdict">[docs]</a>    <span class="k">def</span> <span class="nf">iterdict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Same as :meth:`.dict`, but returns a generator.</span>
<span class="sd">        Be aware that this is only safe if no commit will take place during this</span>
<span class="sd">        transaction. You might also want to read the SQLAlchemy documentation on</span>
<span class="sd">        http://docs.sqlalchemy.org/en/latest/orm/query.html#sqlalchemy.orm.query.Query.yield_per</span>


<span class="sd">        :param int batch_size:</span>
<span class="sd">            The size of the batches to ask the backend to batch results in subcollections.</span>
<span class="sd">            You can optimize the speed of the query by tuning this parameter.</span>

<span class="sd">        :returns: a generator of dictionaries</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_query</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_impl</span><span class="o">.</span><span class="n">iterdict</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tag_to_projected_entity_dict</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">item</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">item</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_aiida_entity_res</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

            <span class="k">yield</span> <span class="n">item</span></div>

<div class="viewcode-block" id="QueryBuilder.all"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.QueryBuilder.all">[docs]</a>    <span class="k">def</span> <span class="nf">all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Executes the full query with the order of the rows as returned by the backend.</span>
<span class="sd">        the order inside each row is given by the order of the vertices in the path</span>
<span class="sd">        and the order of the projections for each vertice in the path.</span>

<span class="sd">        :param int batch_size:</span>
<span class="sd">            The size of the batches to ask the backend to batch results in subcollections.</span>
<span class="sd">            You can optimize the speed of the query by tuning this parameter.</span>
<span class="sd">            Leave the default (*None*) if speed is not critical or if you don&#39;t know</span>
<span class="sd">            what you&#39;re doing!</span>

<span class="sd">        :returns: a list of lists of all projected entities.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iterall</span><span class="p">(</span><span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">))</span></div>

<div class="viewcode-block" id="QueryBuilder.dict"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.QueryBuilder.dict">[docs]</a>    <span class="k">def</span> <span class="nf">dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Executes the full query with the order of the rows as returned by the backend.</span>
<span class="sd">        the order inside each row is given by the order of the vertices in the path</span>
<span class="sd">        and the order of the projections for each vertice in the path.</span>

<span class="sd">        :param int batch_size:</span>
<span class="sd">            The size of the batches to ask the backend to batch results in subcollections.</span>
<span class="sd">            You can optimize the speed of the query by tuning this parameter.</span>
<span class="sd">            Leave the default (*None*) if speed is not critical or if you don&#39;t know</span>
<span class="sd">            what you&#39;re doing!</span>

<span class="sd">        :returns:</span>
<span class="sd">            a list of dictionaries of all projected entities.</span>
<span class="sd">            Each dictionary consists of key value pairs, where the key is the tag</span>
<span class="sd">            of the vertice and the value a dictionary of key-value pairs where key</span>
<span class="sd">            is the entity description (a column name or attribute path)</span>
<span class="sd">            and the value the value in the DB.</span>

<span class="sd">        Usage::</span>

<span class="sd">            qb = QueryBuilder()</span>
<span class="sd">            qb.append(</span>
<span class="sd">                StructureData,</span>
<span class="sd">                tag=&#39;structure&#39;,</span>
<span class="sd">                filters={&#39;uuid&#39;:{&#39;==&#39;:myuuid}},</span>
<span class="sd">            )</span>
<span class="sd">            qb.append(</span>
<span class="sd">                Node,</span>
<span class="sd">                with_ancestors=&#39;structure&#39;,</span>
<span class="sd">                project=[&#39;entity_type&#39;, &#39;id&#39;],  # returns entity_type (string) and id (string)</span>
<span class="sd">                tag=&#39;descendant&#39;</span>
<span class="sd">            )</span>

<span class="sd">            # Return the dictionaries:</span>
<span class="sd">            print &quot;qb.iterdict()&quot;</span>
<span class="sd">            for d in qb.iterdict():</span>
<span class="sd">                print &#39;&gt;&gt;&gt;&#39;, d</span>

<span class="sd">        results in the following output::</span>

<span class="sd">            qb.iterdict()</span>
<span class="sd">            &gt;&gt;&gt; {&#39;descendant&#39;: {</span>
<span class="sd">                    &#39;entity_type&#39;: u&#39;calculation.job.quantumespresso.pw.PwCalculation.&#39;,</span>
<span class="sd">                    &#39;id&#39;: 7716}</span>
<span class="sd">                }</span>
<span class="sd">            &gt;&gt;&gt; {&#39;descendant&#39;: {</span>
<span class="sd">                    &#39;entity_type&#39;: u&#39;data.remote.RemoteData.&#39;,</span>
<span class="sd">                    &#39;id&#39;: 8510}</span>
<span class="sd">                }</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iterdict</span><span class="p">(</span><span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">))</span></div>

<div class="viewcode-block" id="QueryBuilder.inputs"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.QueryBuilder.inputs">[docs]</a>    <span class="k">def</span> <span class="nf">inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Join to inputs of previous vertice in path.</span>

<span class="sd">        :returns: self</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">aiida.orm</span> <span class="k">import</span> <span class="n">Node</span>
        <span class="n">join_to</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;tag&#39;</span><span class="p">]</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;cls&#39;</span><span class="p">,</span> <span class="n">Node</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">cls</span><span class="o">=</span><span class="bp">cls</span><span class="p">,</span> <span class="n">with_outgoing</span><span class="o">=</span><span class="n">join_to</span><span class="p">,</span> <span class="n">autotag</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="QueryBuilder.outputs"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.QueryBuilder.outputs">[docs]</a>    <span class="k">def</span> <span class="nf">outputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Join to outputs of previous vertice in path.</span>

<span class="sd">        :returns: self</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">aiida.orm</span> <span class="k">import</span> <span class="n">Node</span>
        <span class="n">join_to</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;tag&#39;</span><span class="p">]</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;cls&#39;</span><span class="p">,</span> <span class="n">Node</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">cls</span><span class="o">=</span><span class="bp">cls</span><span class="p">,</span> <span class="n">with_incoming</span><span class="o">=</span><span class="n">join_to</span><span class="p">,</span> <span class="n">autotag</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="QueryBuilder.children"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.QueryBuilder.children">[docs]</a>    <span class="k">def</span> <span class="nf">children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Join to children/descendants of previous vertice in path.</span>

<span class="sd">        :returns: self</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">aiida.orm</span> <span class="k">import</span> <span class="n">Node</span>
        <span class="n">join_to</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;tag&#39;</span><span class="p">]</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;cls&#39;</span><span class="p">,</span> <span class="n">Node</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">cls</span><span class="o">=</span><span class="bp">cls</span><span class="p">,</span> <span class="n">with_ancestors</span><span class="o">=</span><span class="n">join_to</span><span class="p">,</span> <span class="n">autotag</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="QueryBuilder.parents"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.QueryBuilder.parents">[docs]</a>    <span class="k">def</span> <span class="nf">parents</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Join to parents/ancestors of previous vertice in path.</span>

<span class="sd">        :returns: self</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">aiida.orm</span> <span class="k">import</span> <span class="n">Node</span>
        <span class="n">join_to</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;tag&#39;</span><span class="p">]</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;cls&#39;</span><span class="p">,</span> <span class="n">Node</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">cls</span><span class="o">=</span><span class="bp">cls</span><span class="p">,</span> <span class="n">with_descendants</span><span class="o">=</span><span class="n">join_to</span><span class="p">,</span> <span class="n">autotag</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="QueryBuilder._deprecate"><a class="viewcode-back" href="../../../apidoc/aiida.orm.html#aiida.orm.QueryBuilder._deprecate">[docs]</a>    <span class="k">def</span> <span class="nf">_deprecate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">deprecated_name</span><span class="p">,</span> <span class="n">preferred_name</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="s1">&#39;1.0.0a5&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wrapper to return a decorated functon which will print a deprecation warning when it is called.</span>

<span class="sd">        Specifically for when an  old relationship type is used.</span>
<span class="sd">        Note that it is the way of calling the function which is deprecated, not the function itself</span>

<span class="sd">        :param function: a deprecated function to call</span>
<span class="sd">        :param deprecated_name: the name which is deprecated</span>
<span class="sd">        :param preferred_name: the new name which is preferred</span>
<span class="sd">        :param version: aiida version for which this takes effect.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Decorator to print a deprecation warning</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="kn">import</span> <span class="nn">warnings</span>
            <span class="kn">from</span> <span class="nn">aiida.common.warnings</span> <span class="k">import</span> <span class="n">AiidaDeprecationWarning</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;The relationship name &#39;</span><span class="si">{}</span><span class="s2">&#39; is deprecated from version </span><span class="si">{}</span><span class="s2"> onwards. Use &#39;</span><span class="si">{}</span><span class="s2">&#39; instead.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">deprecated_name</span><span class="p">,</span> <span class="n">version</span><span class="p">,</span> <span class="n">preferred_name</span><span class="p">),</span>
                <span class="n">AiidaDeprecationWarning</span><span class="p">,</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">function</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">wrapper</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, ECOLE POLYTECHNIQUE FEDERALE DE LAUSANNE (Theory and Simulation of Materials (THEOS) and National Centre for Computational Design and Discovery of Novel Materials (NCCR MARVEL)), Switzerland and ROBERT BOSCH LLC, USA. All rights reserved

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>