

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>aiida.common.folders &mdash; AiiDA 1.0.0b2 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../_static/language_data.js"></script>
        <script type="text/javascript" src="../../../_static/contentui.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/contentui.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> AiiDA
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Installation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install/quick_installation.html">Quick installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../install/prerequisites.html">Prerequisites</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../install/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../install/updating_installation.html">Updating AiiDA</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../install/troubleshooting.html">Troubleshooting</a></li>
</ul>
<p class="caption"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../get_started/index.html">First things first</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../get_started/daemon.html">Setup the daemon</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../get_started/computers.html">Setup a computer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../get_started/codes.html">Setup a code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../get_started/plugins.html">Plugins</a></li>
</ul>
<p class="caption"><span class="caption-text">Concepts</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../concepts/provenance.html">Provenance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../concepts/processes.html">Processes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../concepts/calculations.html">Calculations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../concepts/workflows.html">Workflows</a></li>
</ul>
<p class="caption"><span class="caption-text">Working with</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../working/processes.html">Processes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../working/functions.html">Calculation and work functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../working/calculations.html">Calculations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../working/workflows.html">Workflows</a></li>
</ul>
<p class="caption"><span class="caption-text">Working with AiiDA</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../working_with_aiida/index.html">Command line interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../working_with_aiida/index.html#scripting">Scripting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../working_with_aiida/index.html#data-types">Data types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../working_with_aiida/index.html#groups">Groups</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../working_with_aiida/index.html#schedulers">Schedulers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../working_with_aiida/index.html#querying-data">Querying data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../working_with_aiida/index.html#caching">Caching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../working_with_aiida/index.html#result-manager">Result manager</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../working_with_aiida/index.html#backups">Backups</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../working_with_aiida/index.html#troubleshooting">Troubleshooting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../working_with_aiida/index.html#rest-api">REST API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../working_with_aiida/index.html#cookbook">Cookbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../import_export/index.html">Import and Export</a></li>
</ul>
<p class="caption"><span class="caption-text">Development</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../developer_guide/index.html">AiiDA design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../developer_guide/index.html#aiida-core">AiiDA core</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../developer_guide/index.html#aiida-plugins">AiiDA plugins</a></li>
</ul>
<p class="caption"><span class="caption-text">Tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial/index.html">StructureData</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial/index.html#pseudopotentials">Pseudopotentials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial/index.html#plugin-development">Plugin development</a></li>
</ul>
<p class="caption"><span class="caption-text">API reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="`aiida package &lt;https://aiida-core.readthedocs.io/en/latest/apidoc/aiida.html&gt;`_">`aiida package &lt;https://aiida-core.readthedocs.io/en/latest/apidoc/aiida.html&gt;`_</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">AiiDA</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../../aiida.html">aiida</a> &raquo;</li>
        
      <li>aiida.common.folders</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for aiida.common.folders</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1">###########################################################################</span>
<span class="c1"># Copyright (c), The AiiDA team. All rights reserved.                     #</span>
<span class="c1"># This file is part of the AiiDA code.                                    #</span>
<span class="c1">#                                                                         #</span>
<span class="c1"># The code is hosted on GitHub at https://github.com/aiidateam/aiida_core #</span>
<span class="c1"># For further information on the license, see the LICENSE.txt file        #</span>
<span class="c1"># For further information please visit http://www.aiida.net               #</span>
<span class="c1">###########################################################################</span>
<span class="sd">&quot;&quot;&quot;Utility functions to operate on filesystem folders.&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span>

<span class="kn">import</span> <span class="nn">errno</span>
<span class="kn">import</span> <span class="nn">fnmatch</span>
<span class="kn">import</span> <span class="nn">io</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">shutil</span>
<span class="kn">import</span> <span class="nn">tempfile</span>

<span class="kn">import</span> <span class="nn">six</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">timezone</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="k">import</span> <span class="n">get_repository_folder</span>

<span class="c1"># If True, tries to make everything (dirs, files) group-writable.</span>
<span class="c1"># Otherwise, tries to make everything only readable and writable by the user.</span>
<span class="n">GROUP_WRITABLE</span> <span class="o">=</span> <span class="kc">True</span>

<span class="c1"># Name of directory in which to place the input files created by running a dry run for a `CalcJob`</span>
<span class="n">CALC_JOB_DRY_RUN_BASE_PATH</span> <span class="o">=</span> <span class="s1">&#39;submit_test&#39;</span>

<span class="n">VALID_SECTIONS</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;node&#39;</span><span class="p">]</span>


<div class="viewcode-block" id="Folder"><a class="viewcode-back" href="../../../apidoc/aiida.common.html#aiida.common.folders.Folder">[docs]</a><span class="k">class</span> <span class="nc">Folder</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>  <span class="c1"># pylint: disable=useless-object-inheritance</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class to manage generic folders, avoiding to get out of</span>
<span class="sd">    specific given folder borders.</span>

<span class="sd">    .. todo::</span>
<span class="sd">        fix this, os.path.commonprefix of /a/b/c and /a/b2/c will give</span>
<span class="sd">        a/b, check if this is wanted or if we want to put trailing slashes.</span>
<span class="sd">        (or if we want to use os.path.relpath and check for a string starting</span>
<span class="sd">        with os.pardir?)</span>

<span class="sd">    .. todo::</span>
<span class="sd">        rethink whether the folder_limit option is still useful. If not, remove</span>
<span class="sd">        it alltogether (it was a nice feature, but unfortunately all the calls</span>
<span class="sd">        to os.path.abspath or normpath are quite slow).</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Folder.__init__"><a class="viewcode-back" href="../../../apidoc/aiida.common.html#aiida.common.folders.Folder.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">abspath</span><span class="p">,</span> <span class="n">folder_limit</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">abspath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">abspath</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">folder_limit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">folder_limit</span> <span class="o">=</span> <span class="n">abspath</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">folder_limit</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">folder_limit</span><span class="p">)</span>

            <span class="c1"># check that it is a subfolder</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">commonprefix</span><span class="p">([</span><span class="n">abspath</span><span class="p">,</span> <span class="n">folder_limit</span><span class="p">])</span> <span class="o">==</span> <span class="n">folder_limit</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The absolute path for this folder is not within the &quot;</span>
                                 <span class="s2">&quot;folder_limit. abspath=</span><span class="si">{}</span><span class="s2">, folder_limit=</span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">abspath</span><span class="p">,</span> <span class="n">folder_limit</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_abspath</span> <span class="o">=</span> <span class="n">abspath</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_folder_limit</span> <span class="o">=</span> <span class="n">folder_limit</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mode_dir</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the mode with which the folders should be created</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">GROUP_WRITABLE</span><span class="p">:</span>
            <span class="k">return</span> <span class="mo">0o770</span>

        <span class="k">return</span> <span class="mo">0o700</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mode_file</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the mode with which the files should be created</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">GROUP_WRITABLE</span><span class="p">:</span>
            <span class="k">return</span> <span class="mo">0o660</span>

        <span class="k">return</span> <span class="mo">0o600</span>

<div class="viewcode-block" id="Folder.get_subfolder"><a class="viewcode-back" href="../../../apidoc/aiida.common.html#aiida.common.folders.Folder.get_subfolder">[docs]</a>    <span class="k">def</span> <span class="nf">get_subfolder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subfolder</span><span class="p">,</span> <span class="n">create</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">reset_limit</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a Folder object pointing to a subfolder.</span>

<span class="sd">        :param subfolder: a string with the relative path of the subfolder,</span>
<span class="sd">                relative to the absolute path of this object. Note that</span>
<span class="sd">                this may also contain &#39;..&#39; parts,</span>
<span class="sd">                as far as this does not go beyond the folder_limit.</span>
<span class="sd">        :param create: if True, the new subfolder is created, if it does not exist.</span>
<span class="sd">        :param reset_limit: when doing ``b = a.get_subfolder(&#39;xxx&#39;, reset_limit=False)``,</span>
<span class="sd">                the limit of b will be the same limit of a.</span>
<span class="sd">                if True, the limit will be set to the boundaries of folder b.</span>

<span class="sd">        :Returns: a Folder object pointing to the subfolder.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dest_abs_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">abspath</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">text_type</span><span class="p">(</span><span class="n">subfolder</span><span class="p">)))</span>

        <span class="k">if</span> <span class="n">reset_limit</span><span class="p">:</span>
            <span class="c1"># Create a new Folder object, with a limit to itself (cannot go</span>
            <span class="c1"># back to this folder)</span>
            <span class="n">folder_limit</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Create a new Folder object, with the same limit of the parent</span>
            <span class="n">folder_limit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">folder_limit</span>

        <span class="n">new_folder</span> <span class="o">=</span> <span class="n">Folder</span><span class="p">(</span><span class="n">abspath</span><span class="o">=</span><span class="n">dest_abs_dir</span><span class="p">,</span> <span class="n">folder_limit</span><span class="o">=</span><span class="n">folder_limit</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">create</span><span class="p">:</span>
            <span class="n">new_folder</span><span class="o">.</span><span class="n">create</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">new_folder</span></div>

<div class="viewcode-block" id="Folder.get_content_list"><a class="viewcode-back" href="../../../apidoc/aiida.common.html#aiida.common.folders.Folder.get_content_list">[docs]</a>    <span class="k">def</span> <span class="nf">get_content_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pattern</span><span class="o">=</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="n">only_paths</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of files (and subfolders) in the folder,</span>
<span class="sd">        matching a given pattern.</span>

<span class="sd">        Example: If you want to exclude files starting with a dot, you can</span>
<span class="sd">        call this method with ``pattern=&#39;[!.]*&#39;``</span>

<span class="sd">        :param pattern: a pattern for the file/folder names, using Unix filename</span>
<span class="sd">                pattern matching (see Python standard module fnmatch).</span>
<span class="sd">                By default, pattern is &#39;*&#39;, matching all files and folders.</span>
<span class="sd">        :param only_paths: if False (default), return pairs (name, is_file).</span>
<span class="sd">                if True, return only a flat list.</span>

<span class="sd">        :Returns:</span>
<span class="sd">            a list of tuples of two elements, the first is the file name and</span>
<span class="sd">            the second is True if the element is a file, False if it is a</span>
<span class="sd">            directory.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">file_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">fname</span> <span class="k">for</span> <span class="n">fname</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">abspath</span><span class="p">)</span> <span class="k">if</span> <span class="n">fnmatch</span><span class="o">.</span><span class="n">fnmatch</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">pattern</span><span class="p">)]</span>

        <span class="k">if</span> <span class="n">only_paths</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">file_list</span>

        <span class="k">return</span> <span class="p">[(</span><span class="n">fname</span><span class="p">,</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">abspath</span><span class="p">,</span> <span class="n">fname</span><span class="p">)))</span> <span class="k">for</span> <span class="n">fname</span> <span class="ow">in</span> <span class="n">file_list</span><span class="p">]</span></div>

<div class="viewcode-block" id="Folder.create_symlink"><a class="viewcode-back" href="../../../apidoc/aiida.common.html#aiida.common.folders.Folder.create_symlink">[docs]</a>    <span class="k">def</span> <span class="nf">create_symlink</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a symlink inside the folder to the location &#39;src&#39;.</span>

<span class="sd">        :param src: the location to which the symlink must point. Can be</span>
<span class="sd">                either a relative or an absolute path. Should, however,</span>
<span class="sd">                be relative to work properly also when the repository is</span>
<span class="sd">                moved!</span>
<span class="sd">        :param name: the filename of the symlink to be created.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dest_abs_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_abs_path</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">symlink</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dest_abs_path</span><span class="p">)</span></div>

        <span class="c1"># For symlinks, permissions should not be set</span>

<div class="viewcode-block" id="Folder.insert_path"><a class="viewcode-back" href="../../../apidoc/aiida.common.html#aiida.common.folders.Folder.insert_path">[docs]</a>    <span class="k">def</span> <span class="nf">insert_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">dest_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Copy a file to the folder.</span>

<span class="sd">        :param src: the source filename to copy</span>
<span class="sd">        :param dest_name: if None, the same basename of src is used. Otherwise,</span>
<span class="sd">                the destination filename will have this file name.</span>
<span class="sd">        :param overwrite: if ``False``, raises an error on existing destination;</span>
<span class="sd">                otherwise, delete it first.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># pylint: disable=too-many-branches</span>
        <span class="k">if</span> <span class="n">dest_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="n">six</span><span class="o">.</span><span class="n">text_type</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">src</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="n">six</span><span class="o">.</span><span class="n">text_type</span><span class="p">(</span><span class="n">dest_name</span><span class="p">)</span>

        <span class="n">src</span> <span class="o">=</span> <span class="n">six</span><span class="o">.</span><span class="n">text_type</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>

        <span class="n">dest_abs_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_abs_path</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isabs</span><span class="p">(</span><span class="n">src</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;src must be an absolute path in insert_file&quot;</span><span class="p">)</span>

        <span class="c1"># In this way, the destination is always correct (i.e., if I copy to a</span>
        <span class="c1"># folder, I point to the correct location inside it)</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">dest_abs_path</span><span class="p">):</span>
            <span class="n">dest_abs_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dest_abs_path</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">src</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">src</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">dest_abs_path</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">overwrite</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">dest_abs_path</span><span class="p">):</span>
                        <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="n">dest_abs_path</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">dest_abs_path</span><span class="p">)</span>
                    <span class="c1"># This automatically overwrites files</span>
                    <span class="n">shutil</span><span class="o">.</span><span class="n">copyfile</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dest_abs_path</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;destination already exists: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dest_abs_path</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">shutil</span><span class="o">.</span><span class="n">copyfile</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dest_abs_path</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">src</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">dest_abs_path</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">overwrite</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">dest_abs_path</span><span class="p">):</span>
                        <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="n">dest_abs_path</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">dest_abs_path</span><span class="p">)</span>
                    <span class="c1"># This automatically overwrites files</span>
                    <span class="n">shutil</span><span class="o">.</span><span class="n">copytree</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dest_abs_path</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;destination already exists: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dest_abs_path</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">shutil</span><span class="o">.</span><span class="n">copytree</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dest_abs_path</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;insert_path can only insert files or paths, not symlinks or the like&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dest_abs_path</span></div>

<div class="viewcode-block" id="Folder.create_file_from_filelike"><a class="viewcode-back" href="../../../apidoc/aiida.common.html#aiida.common.folders.Folder.create_file_from_filelike">[docs]</a>    <span class="k">def</span> <span class="nf">create_file_from_filelike</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filelike</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;wb&#39;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a file with the given filename from a filelike object.</span>

<span class="sd">        :param filelike: a filelike object whose contents to copy</span>
<span class="sd">        :param filename: the filename for the file that is to be created</span>
<span class="sd">        :param mode: the mode with which the target file will be written</span>
<span class="sd">        :param encoding: the encoding with which the target file will be written</span>
<span class="sd">        :return: the absolute filepath of the created file</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">six</span><span class="o">.</span><span class="n">text_type</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="n">filepath</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_abs_path</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">io</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span><span class="p">)</span> <span class="k">as</span> <span class="n">handle</span><span class="p">:</span>

            <span class="c1"># In python 2 a string literal can either be of unicode or string (bytes) type. Since we do not know what</span>
            <span class="c1"># will be coming in, if the requested mode is not binary, in the case of incoming bytes, the content will</span>
            <span class="c1"># have to be encoded. Therefore in the case of a non-binary mode for python2, we attempt to encode the</span>
            <span class="c1"># incoming filelike object and in case of failure do nothing.</span>
            <span class="k">if</span> <span class="n">six</span><span class="o">.</span><span class="n">PY2</span> <span class="ow">and</span> <span class="s1">&#39;b&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mode</span><span class="p">:</span>
                <span class="kn">import</span> <span class="nn">codecs</span>
                <span class="n">utf8reader</span> <span class="o">=</span> <span class="n">codecs</span><span class="o">.</span><span class="n">getreader</span><span class="p">(</span><span class="s1">&#39;utf8&#39;</span><span class="p">)</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="n">shutil</span><span class="o">.</span><span class="n">copyfileobj</span><span class="p">(</span><span class="n">utf8reader</span><span class="p">(</span><span class="n">filelike</span><span class="p">),</span> <span class="n">handle</span><span class="p">)</span>
                <span class="k">except</span> <span class="p">(</span><span class="ne">UnicodeDecodeError</span><span class="p">,</span> <span class="ne">UnicodeEncodeError</span><span class="p">):</span>
                    <span class="n">shutil</span><span class="o">.</span><span class="n">copyfileobj</span><span class="p">(</span><span class="n">filelike</span><span class="p">,</span> <span class="n">handle</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">shutil</span><span class="o">.</span><span class="n">copyfileobj</span><span class="p">(</span><span class="n">filelike</span><span class="p">,</span> <span class="n">handle</span><span class="p">)</span>

        <span class="n">os</span><span class="o">.</span><span class="n">chmod</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode_file</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">filepath</span></div>

<div class="viewcode-block" id="Folder.remove_path"><a class="viewcode-back" href="../../../apidoc/aiida.common.html#aiida.common.folders.Folder.remove_path">[docs]</a>    <span class="k">def</span> <span class="nf">remove_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove a file or folder from the folder.</span>

<span class="sd">        :param filename: the relative path name to remove</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># I get the full path of the filename, checking also that I don&#39;t</span>
        <span class="c1"># go beyond the folder limits</span>
        <span class="n">dest_abs_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_abs_path</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">check_existence</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">dest_abs_path</span><span class="p">):</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="n">dest_abs_path</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">dest_abs_path</span><span class="p">)</span></div>

<div class="viewcode-block" id="Folder.get_abs_path"><a class="viewcode-back" href="../../../apidoc/aiida.common.html#aiida.common.folders.Folder.get_abs_path">[docs]</a>    <span class="k">def</span> <span class="nf">get_abs_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">relpath</span><span class="p">,</span> <span class="n">check_existence</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an absolute path for a file or folder in this folder.</span>

<span class="sd">        The advantage of using this method is that it checks that filename</span>
<span class="sd">        is a valid filename within this folder,</span>
<span class="sd">        and not something e.g. containing slashes.</span>

<span class="sd">        :param filename: The file or directory.</span>
<span class="sd">        :param check_existence: if False, just return the file path.</span>
<span class="sd">            Otherwise, also check if the file or directory actually exists.</span>
<span class="sd">            Raise OSError if it does not.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isabs</span><span class="p">(</span><span class="n">relpath</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;relpath must be a relative path&quot;</span><span class="p">)</span>
        <span class="n">dest_abs_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">abspath</span><span class="p">,</span> <span class="n">relpath</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">commonprefix</span><span class="p">([</span><span class="n">dest_abs_path</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">folder_limit</span><span class="p">])</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">folder_limit</span><span class="p">:</span>
            <span class="n">errstr</span> <span class="o">=</span> <span class="s2">&quot;You didn&#39;t specify a valid filename: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">relpath</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">errstr</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">check_existence</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">dest_abs_path</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> does not exist within the folder </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">relpath</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">abspath</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">dest_abs_path</span></div>

<div class="viewcode-block" id="Folder.open"><a class="viewcode-back" href="../../../apidoc/aiida.common.html#aiida.common.folders.Folder.open">[docs]</a>    <span class="k">def</span> <span class="nf">open</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;utf8&#39;</span><span class="p">,</span> <span class="n">check_existence</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Open a file in the current folder and return the corresponding file object.</span>

<span class="sd">        :param check_existence: if False, just return the file path.</span>
<span class="sd">            Otherwise, also check if the file or directory actually exists.</span>
<span class="sd">            Raise OSError if it does not.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;b&#39;</span> <span class="ow">in</span> <span class="n">mode</span><span class="p">:</span>
            <span class="n">encoding</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">io</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_abs_path</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">check_existence</span><span class="o">=</span><span class="n">check_existence</span><span class="p">),</span> <span class="n">mode</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">abspath</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The absolute path of the folder.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_abspath</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">folder_limit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The folder limit that cannot be crossed when creating files and folders.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_folder_limit</span>

<div class="viewcode-block" id="Folder.exists"><a class="viewcode-back" href="../../../apidoc/aiida.common.html#aiida.common.folders.Folder.exists">[docs]</a>    <span class="k">def</span> <span class="nf">exists</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if the folder exists, False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">abspath</span><span class="p">)</span></div>

<div class="viewcode-block" id="Folder.isfile"><a class="viewcode-back" href="../../../apidoc/aiida.common.html#aiida.common.folders.Folder.isfile">[docs]</a>    <span class="k">def</span> <span class="nf">isfile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">relpath</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if &#39;relpath&#39; exists inside the folder and is a file,</span>
<span class="sd">        False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">abspath</span><span class="p">,</span> <span class="n">relpath</span><span class="p">))</span></div>

<div class="viewcode-block" id="Folder.isdir"><a class="viewcode-back" href="../../../apidoc/aiida.common.html#aiida.common.folders.Folder.isdir">[docs]</a>    <span class="k">def</span> <span class="nf">isdir</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">relpath</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if &#39;relpath&#39; exists inside the folder and is a directory,</span>
<span class="sd">        False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">abspath</span><span class="p">,</span> <span class="n">relpath</span><span class="p">))</span></div>

<div class="viewcode-block" id="Folder.erase"><a class="viewcode-back" href="../../../apidoc/aiida.common.html#aiida.common.folders.Folder.erase">[docs]</a>    <span class="k">def</span> <span class="nf">erase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">create_empty_folder</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Erases the folder. Should be called only in very specific cases,</span>
<span class="sd">        in general folder should not be erased!</span>

<span class="sd">        Doesn&#39;t complain if the folder does not exist.</span>

<span class="sd">        :param create_empty_folder: if True, after erasing, creates an empty dir.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">abspath</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">create_empty_folder</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">create</span><span class="p">()</span></div>

<div class="viewcode-block" id="Folder.create"><a class="viewcode-back" href="../../../apidoc/aiida.common.html#aiida.common.folders.Folder.create">[docs]</a>    <span class="k">def</span> <span class="nf">create</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates the folder, if it does not exist on the disk yet.</span>

<span class="sd">        It will also create top directories, if absent.</span>

<span class="sd">        It is always safe to call it, it will do nothing if the folder</span>
<span class="sd">        already exists.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">abspath</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mode_dir</span><span class="p">)</span></div>

<div class="viewcode-block" id="Folder.replace_with_folder"><a class="viewcode-back" href="../../../apidoc/aiida.common.html#aiida.common.folders.Folder.replace_with_folder">[docs]</a>    <span class="k">def</span> <span class="nf">replace_with_folder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">srcdir</span><span class="p">,</span> <span class="n">move</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This routine copies or moves the source folder &#39;srcdir&#39; to the local</span>
<span class="sd">        folder pointed by this Folder object.</span>

<span class="sd">        :param srcdir: the source folder on the disk; this must be a string with</span>
<span class="sd">                an absolute path</span>
<span class="sd">        :param move: if True, the srcdir is moved to the repository. Otherwise, it</span>
<span class="sd">                is only copied.</span>
<span class="sd">        :param overwrite: if True, the folder will be erased first.</span>
<span class="sd">                if False, a IOError is raised if the folder already exists.</span>
<span class="sd">                Whatever the value of this flag, parent directories will be</span>
<span class="sd">                created, if needed.</span>

<span class="sd">        :Raises:</span>
<span class="sd">            OSError or IOError: in case of problems accessing or writing</span>
<span class="sd">            the files.</span>
<span class="sd">        :Raises:</span>
<span class="sd">            ValueError: if the section is not recognized.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isabs</span><span class="p">(</span><span class="n">srcdir</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;srcdir must be an absolute path&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">overwrite</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">erase</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;Location </span><span class="si">{}</span><span class="s2"> already exists, and overwrite is set to False&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">abspath</span><span class="p">))</span>

        <span class="c1"># Create parent dir, if needed, with the right mode</span>
        <span class="n">pardir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">abspath</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">pardir</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">pardir</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mode_dir</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">move</span><span class="p">:</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">srcdir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">abspath</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">copytree</span><span class="p">(</span><span class="n">srcdir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">abspath</span><span class="p">)</span>

        <span class="c1"># Set the mode also for the current dir, recursively</span>
        <span class="k">for</span> <span class="n">dirpath</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">filenames</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">abspath</span><span class="p">,</span> <span class="n">followlinks</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
            <span class="c1"># dirpath should already be absolute, because I am passing</span>
            <span class="c1"># an absolute path to os.walk</span>
            <span class="n">os</span><span class="o">.</span><span class="n">chmod</span><span class="p">(</span><span class="n">dirpath</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode_dir</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">filenames</span><span class="p">:</span>
                <span class="c1"># do not change permissions of symlinks (this would</span>
                <span class="c1"># actually change permissions of the linked file/dir)</span>
                <span class="c1"># Toc check whether this is a big speed loss</span>
                <span class="n">full_file_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dirpath</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">islink</span><span class="p">(</span><span class="n">full_file_path</span><span class="p">):</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">chmod</span><span class="p">(</span><span class="n">full_file_path</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode_file</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="SandboxFolder"><a class="viewcode-back" href="../../../apidoc/aiida.common.html#aiida.common.folders.SandboxFolder">[docs]</a><span class="k">class</span> <span class="nc">SandboxFolder</span><span class="p">(</span><span class="n">Folder</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class to manage the creation and management of a sandbox folder.</span>

<span class="sd">    Note: this class must be used within a context manager, i.e.:</span>

<span class="sd">    with SandboxFolder as f:</span>
<span class="sd">        ## do something with f</span>

<span class="sd">    In this way, the sandbox folder is removed from disk</span>
<span class="sd">    (if it wasn&#39;t removed already) when exiting the &#39;with&#39; block.</span>

<span class="sd">    .. todo:: Implement check of whether the folder has been removed.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="SandboxFolder.__init__"><a class="viewcode-back" href="../../../apidoc/aiida.common.html#aiida.common.folders.SandboxFolder.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sandbox_in_repo</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes the object by creating a new temporary folder in the</span>
<span class="sd">        sandbox.</span>

<span class="sd">        :param bool sandbox_in_repo:</span>
<span class="sd">            If True (default), creates the folder in the repository.</span>
<span class="sd">            If false,  relies on the defaults of tempfile.mkdtemp</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># First check if the sandbox folder already exists</span>
        <span class="k">if</span> <span class="n">sandbox_in_repo</span><span class="p">:</span>
            <span class="n">sandbox</span> <span class="o">=</span> <span class="n">get_repository_folder</span><span class="p">(</span><span class="s1">&#39;sandbox&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">sandbox</span><span class="p">):</span>
                <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">sandbox</span><span class="p">)</span>
            <span class="n">abspath</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">mkdtemp</span><span class="p">(</span><span class="nb">dir</span><span class="o">=</span><span class="n">sandbox</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">abspath</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">mkdtemp</span><span class="p">()</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SandboxFolder</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">abspath</span><span class="o">=</span><span class="n">abspath</span><span class="p">)</span></div>

<div class="viewcode-block" id="SandboxFolder.__enter__"><a class="viewcode-back" href="../../../apidoc/aiida.common.html#aiida.common.folders.SandboxFolder.__enter__">[docs]</a>    <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Called when entering in the with statement</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="SandboxFolder.__exit__"><a class="viewcode-back" href="../../../apidoc/aiida.common.html#aiida.common.folders.SandboxFolder.__exit__">[docs]</a>    <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc_value</span><span class="p">,</span> <span class="n">traceback</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        In exit, I remove the sandbox folder from disk, if it still exists</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">erase</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="SubmitTestFolder"><a class="viewcode-back" href="../../../apidoc/aiida.common.html#aiida.common.folders.SubmitTestFolder">[docs]</a><span class="k">class</span> <span class="nc">SubmitTestFolder</span><span class="p">(</span><span class="n">Folder</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Sandbox folder that can be used for the test submission of `CalcJobs`.</span>

<span class="sd">    The directory will be created in the current working directory with a configurable basename.</span>
<span class="sd">    Then a sub folder will be created within this base folder based on the current date and an index in order to</span>
<span class="sd">    not overwrite already existing created test folders.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_sub_folder</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="SubmitTestFolder.__init__"><a class="viewcode-back" href="../../../apidoc/aiida.common.html#aiida.common.folders.SubmitTestFolder.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">basepath</span><span class="o">=</span><span class="n">CALC_JOB_DRY_RUN_BASE_PATH</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Construct and create the sandbox folder.</span>

<span class="sd">        The directory will be created in the current working directory with the name given by `basepath`.</span>
<span class="sd">        Then a sub folder will be created within this base folder based on the current date and an index in order to</span>
<span class="sd">        not overwrite already existing created test folders.</span>

<span class="sd">        :param basepath: name of the base directory that will be created in the current working directory</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SubmitTestFolder</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">abspath</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">basepath</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">create</span><span class="p">()</span>

        <span class="c1"># Iteratively try to create a new sub folder based on the current date and an index that automatically increases</span>
        <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">subfolder_basename</span> <span class="o">=</span> <span class="n">timezone</span><span class="o">.</span><span class="n">localtime</span><span class="p">(</span><span class="n">timezone</span><span class="o">.</span><span class="n">now</span><span class="p">())</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;%Y%m</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">subfolder_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">abspath</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">-</span><span class="si">{:05d}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">subfolder_basename</span><span class="p">,</span> <span class="n">counter</span><span class="p">))</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">subfolder_path</span><span class="p">)</span>
                <span class="k">break</span>
            <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">error</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">error</span><span class="o">.</span><span class="n">errno</span> <span class="o">==</span> <span class="n">errno</span><span class="o">.</span><span class="n">EEXIST</span><span class="p">:</span>
                    <span class="c1"># The directory already exists, try the next iteration</span>
                    <span class="k">continue</span>
                <span class="c1"># For all other errors re-raise to prevent endless loops</span>
                <span class="k">raise</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_sub_folder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_subfolder</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">relpath</span><span class="p">(</span><span class="n">subfolder_path</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">abspath</span><span class="p">),</span> <span class="n">reset_limit</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="SubmitTestFolder.__enter__"><a class="viewcode-back" href="../../../apidoc/aiida.common.html#aiida.common.folders.SubmitTestFolder.__enter__">[docs]</a>    <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the sub folder that should be Called when entering in the with statement.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sub_folder</span></div>

<div class="viewcode-block" id="SubmitTestFolder.__exit__"><a class="viewcode-back" href="../../../apidoc/aiida.common.html#aiida.common.folders.SubmitTestFolder.__exit__">[docs]</a>    <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc_value</span><span class="p">,</span> <span class="n">traceback</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;When context manager is exited, do not delete the folder.&quot;&quot;&quot;</span></div></div>


<div class="viewcode-block" id="RepositoryFolder"><a class="viewcode-back" href="../../../apidoc/aiida.common.html#aiida.common.folders.RepositoryFolder">[docs]</a><span class="k">class</span> <span class="nc">RepositoryFolder</span><span class="p">(</span><span class="n">Folder</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class to manage the local AiiDA repository folders.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="RepositoryFolder.__init__"><a class="viewcode-back" href="../../../apidoc/aiida.common.html#aiida.common.folders.RepositoryFolder.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">section</span><span class="p">,</span> <span class="n">uuid</span><span class="p">,</span> <span class="n">subfolder</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">curdir</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes the object by pointing it to a folder in the repository.</span>

<span class="sd">        Pass the uuid as a string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">section</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">VALID_SECTIONS</span><span class="p">:</span>
            <span class="n">retstr</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Repository section &#39;</span><span class="si">{}</span><span class="s2">&#39; not allowed. &quot;</span>
                      <span class="s2">&quot;Valid sections are: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">section</span><span class="p">,</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">VALID_SECTIONS</span><span class="p">)))</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">retstr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_section</span> <span class="o">=</span> <span class="n">section</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_uuid</span> <span class="o">=</span> <span class="n">uuid</span>

        <span class="c1"># If you want to change the sharding scheme, this is the only place</span>
        <span class="c1"># where changes should be needed FOR NODES AND WORKFLOWS</span>
        <span class="c1"># Of course, remember to migrate data!</span>
        <span class="c1"># We set a sharding of level 2+2</span>
        <span class="c1"># Note that a similar sharding should probably has to be done</span>
        <span class="c1"># independently for calculations sent to remote computers in the</span>
        <span class="c1"># execmanager.</span>
        <span class="c1"># Note: I don&#39;t do any os.path.abspath (that internally calls</span>
        <span class="c1"># normpath, that may be slow): this is done abywat by the super</span>
        <span class="c1"># class.</span>
        <span class="n">entity_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="n">get_repository_folder</span><span class="p">(</span><span class="s1">&#39;repository&#39;</span><span class="p">),</span> <span class="n">six</span><span class="o">.</span><span class="n">text_type</span><span class="p">(</span><span class="n">section</span><span class="p">),</span>
            <span class="n">six</span><span class="o">.</span><span class="n">text_type</span><span class="p">(</span><span class="n">uuid</span><span class="p">)[:</span><span class="mi">2</span><span class="p">],</span>
            <span class="n">six</span><span class="o">.</span><span class="n">text_type</span><span class="p">(</span><span class="n">uuid</span><span class="p">)[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">],</span>
            <span class="n">six</span><span class="o">.</span><span class="n">text_type</span><span class="p">(</span><span class="n">uuid</span><span class="p">)[</span><span class="mi">4</span><span class="p">:])</span>
        <span class="n">dest</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">entity_dir</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">text_type</span><span class="p">(</span><span class="n">subfolder</span><span class="p">))</span>

        <span class="c1"># Internal variable of this class</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_subfolder</span> <span class="o">=</span> <span class="n">subfolder</span>

        <span class="c1"># This will also do checks on the folder limits</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">RepositoryFolder</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">abspath</span><span class="o">=</span><span class="n">dest</span><span class="p">,</span> <span class="n">folder_limit</span><span class="o">=</span><span class="n">entity_dir</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">section</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The section to which this folder belongs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_section</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">uuid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The uuid to which this folder belongs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_uuid</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">subfolder</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The subfolder within the section/uuid folder.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subfolder</span>

<div class="viewcode-block" id="RepositoryFolder.get_topdir"><a class="viewcode-back" href="../../../apidoc/aiida.common.html#aiida.common.folders.RepositoryFolder.get_topdir">[docs]</a>    <span class="k">def</span> <span class="nf">get_topdir</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the top directory, i.e., the section/uuid folder object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">RepositoryFolder</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">section</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">uuid</span><span class="p">)</span></div></div>

        <span class="c1"># NOTE! The get_subfolder method will return a Folder object, and not a RepositoryFolder object</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, ECOLE POLYTECHNIQUE FEDERALE DE LAUSANNE (Theory and Simulation of Materials (THEOS) and National Centre for Computational Design and Discovery of Novel Materials (NCCR MARVEL)), Switzerland and ROBERT BOSCH LLC, USA. All rights reserved

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>