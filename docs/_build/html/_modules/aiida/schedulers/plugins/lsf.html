

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>aiida.schedulers.plugins.lsf &mdash; AiiDA 1.0.0b2 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../../_static/language_data.js"></script>
        <script type="text/javascript" src="../../../../_static/contentui.js"></script>
    
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/contentui.css" type="text/css" />
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../../index.html" class="icon icon-home"> AiiDA
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Installation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../install/quick_installation.html">Quick installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../install/prerequisites.html">Prerequisites</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../install/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../install/updating_installation.html">Updating AiiDA</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../install/troubleshooting.html">Troubleshooting</a></li>
</ul>
<p class="caption"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../get_started/index.html">First things first</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../get_started/daemon.html">Setup the daemon</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../get_started/computers.html">Setup a computer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../get_started/codes.html">Setup a code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../get_started/plugins.html">Plugins</a></li>
</ul>
<p class="caption"><span class="caption-text">Concepts</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../concepts/provenance.html">Provenance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../concepts/processes.html">Processes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../concepts/calculations.html">Calculations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../concepts/workflows.html">Workflows</a></li>
</ul>
<p class="caption"><span class="caption-text">Working with</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../working/processes.html">Processes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../working/functions.html">Calculation and work functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../working/calculations.html">Calculations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../working/workflows.html">Workflows</a></li>
</ul>
<p class="caption"><span class="caption-text">Working with AiiDA</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../working_with_aiida/index.html">Command line interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../working_with_aiida/index.html#scripting">Scripting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../working_with_aiida/index.html#data-types">Data types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../working_with_aiida/index.html#groups">Groups</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../working_with_aiida/index.html#schedulers">Schedulers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../working_with_aiida/index.html#querying-data">Querying data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../working_with_aiida/index.html#caching">Caching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../working_with_aiida/index.html#result-manager">Result manager</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../working_with_aiida/index.html#backups">Backups</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../working_with_aiida/index.html#troubleshooting">Troubleshooting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../working_with_aiida/index.html#rest-api">REST API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../working_with_aiida/index.html#cookbook">Cookbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../import_export/index.html">Import and Export</a></li>
</ul>
<p class="caption"><span class="caption-text">Development</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../developer_guide/index.html">AiiDA design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../developer_guide/index.html#aiida-core">AiiDA core</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../developer_guide/index.html#aiida-plugins">AiiDA plugins</a></li>
</ul>
<p class="caption"><span class="caption-text">Tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorial/index.html">StructureData</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorial/index.html#pseudopotentials">Pseudopotentials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorial/index.html#plugin-development">Plugin development</a></li>
</ul>
<p class="caption"><span class="caption-text">API reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="`aiida package &lt;https://aiida-core.readthedocs.io/en/latest/apidoc/aiida.html&gt;`_">`aiida package &lt;https://aiida-core.readthedocs.io/en/latest/apidoc/aiida.html&gt;`_</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">AiiDA</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../../../aiida.html">aiida</a> &raquo;</li>
        
      <li>aiida.schedulers.plugins.lsf</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for aiida.schedulers.plugins.lsf</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1">###########################################################################</span>
<span class="c1"># Copyright (c), The AiiDA team. All rights reserved.                     #</span>
<span class="c1"># This file is part of the AiiDA code.                                    #</span>
<span class="c1">#                                                                         #</span>
<span class="c1"># The code is hosted on GitHub at https://github.com/aiidateam/aiida_core #</span>
<span class="c1"># For further information on the license, see the LICENSE.txt file        #</span>
<span class="c1"># For further information please visit http://www.aiida.net               #</span>
<span class="c1">###########################################################################</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Plugin for LSF.</span>
<span class="sd">This has been tested on the CERN lxplus cluster (LSF 9.1.3)</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span>

<span class="kn">import</span> <span class="nn">six</span>

<span class="kn">import</span> <span class="nn">aiida.schedulers</span>
<span class="kn">from</span> <span class="nn">aiida.common.escaping</span> <span class="k">import</span> <span class="n">escape_for_bash</span>
<span class="kn">from</span> <span class="nn">aiida.schedulers</span> <span class="k">import</span> <span class="n">SchedulerError</span><span class="p">,</span> <span class="n">SchedulerParsingError</span>
<span class="kn">from</span> <span class="nn">aiida.schedulers.datastructures</span> <span class="k">import</span> <span class="p">(</span><span class="n">JobInfo</span><span class="p">,</span> <span class="n">JobState</span><span class="p">,</span> <span class="n">JobResource</span><span class="p">)</span>

<span class="c1"># This maps LSF status codes to our own state list</span>
<span class="c1">#</span>
<span class="c1"># List of states from</span>
<span class="c1"># &#39;https://www-01.ibm.com/support/knowledgecenter/SSETD4_9.1.2/lsf_command_ref/bjobs.1.dita&#39;</span>
<span class="c1">#</span>
<span class="c1"># PEND    The job is pending. That is, it has not yet been started.</span>
<span class="c1">#</span>
<span class="c1"># PROV    The job has been dispatched to a power-saved host that is waking up.</span>
<span class="c1">#         Before the job can be sent to the sbatchd, it is in a PROV state.</span>
<span class="c1">#</span>
<span class="c1"># PSUSP   The job has been suspended, either by its owner or the LSF administrator,</span>
<span class="c1">#         while pending.</span>
<span class="c1">#</span>
<span class="c1"># RUN     The job is currently running.</span>
<span class="c1">#</span>
<span class="c1"># USUSP   The job has been suspended, either by its owner or the LSF administrator,</span>
<span class="c1">#         while running.</span>
<span class="c1">#</span>
<span class="c1"># SSUSP   The job has been suspended by LSF due to either of the following two</span>
<span class="c1">#         causes:</span>
<span class="c1">#         - The load conditions on the execution host or hosts have exceeded a</span>
<span class="c1">#           threshold according to the loadStop vector defined for the host or queue.</span>
<span class="c1">#         - The run window of the job’s queue is closed. See bqueues(1), bhosts(1),</span>
<span class="c1">#           and lsb.queues(5).</span>
<span class="c1">#</span>
<span class="c1"># DONE    The job has terminated with status of 0.</span>
<span class="c1">#</span>
<span class="c1"># EXIT    The job has terminated with a non-zero status – it may have been aborted</span>
<span class="c1">#         due to an error in its execution, or killed by its owner or the LSF</span>
<span class="c1">#         administrator.</span>
<span class="c1">#         For example, exit code 131 means that the job exceeded a configured</span>
<span class="c1">#         resource usage limit and LSF killed the job.</span>
<span class="c1">#</span>
<span class="c1"># UNKWN   mbatchd has lost contact with the sbatchd on the host on which the job runs.</span>
<span class="c1">#</span>
<span class="c1"># WAIT    For jobs submitted to a chunk job queue, members of a chunk job that</span>
<span class="c1">#         are waiting to run.</span>
<span class="c1">#</span>
<span class="c1"># ZOMBI   A job becomes ZOMBI if:</span>
<span class="c1">#         - A non-rerunnable job is killed by bkill while the sbatchd on the</span>
<span class="c1">#           execution host is unreachable and the job is shown as UNKWN.</span>
<span class="c1">#         - The host on which a rerunnable job is running is unavailable and the</span>
<span class="c1">#           job has been requeued by LSF with a new job ID, as if the job were submitted as a new job.</span>
<span class="c1">#         - After the execution host becomes available, LSF tries to kill the</span>
<span class="c1">#           ZOMBI job. Upon successful termination of the ZOMBI job, the job’s</span>
<span class="c1">#           status is changed to EXIT.</span>
<span class="c1">#         With MultiCluster, when a job running on a remote execution cluster</span>
<span class="c1">#         becomes a ZOMBI job, the execution cluster treats the job the same way</span>
<span class="c1">#         as local ZOMBI jobs. In addition, it notifies the submission cluster</span>
<span class="c1">#         that the job is in ZOMBI state and the submission cluster requeues the job.</span>
<span class="n">_MAP_STATUS_LSF</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;PEND&#39;</span><span class="p">:</span> <span class="n">JobState</span><span class="o">.</span><span class="n">QUEUED</span><span class="p">,</span>
    <span class="s1">&#39;PROV&#39;</span><span class="p">:</span> <span class="n">JobState</span><span class="o">.</span><span class="n">QUEUED</span><span class="p">,</span>
    <span class="s1">&#39;PSUSP&#39;</span><span class="p">:</span> <span class="n">JobState</span><span class="o">.</span><span class="n">QUEUED_HELD</span><span class="p">,</span>
    <span class="s1">&#39;USUSP&#39;</span><span class="p">:</span> <span class="n">JobState</span><span class="o">.</span><span class="n">SUSPENDED</span><span class="p">,</span>
    <span class="s1">&#39;SSUSP&#39;</span><span class="p">:</span> <span class="n">JobState</span><span class="o">.</span><span class="n">SUSPENDED</span><span class="p">,</span>
    <span class="s1">&#39;RUN&#39;</span><span class="p">:</span> <span class="n">JobState</span><span class="o">.</span><span class="n">RUNNING</span><span class="p">,</span>
    <span class="s1">&#39;DONE&#39;</span><span class="p">:</span> <span class="n">JobState</span><span class="o">.</span><span class="n">DONE</span><span class="p">,</span>
    <span class="s1">&#39;EXIT&#39;</span><span class="p">:</span> <span class="n">JobState</span><span class="o">.</span><span class="n">DONE</span><span class="p">,</span>
    <span class="s1">&#39;UNKWN&#39;</span><span class="p">:</span> <span class="n">JobState</span><span class="o">.</span><span class="n">UNDETERMINED</span><span class="p">,</span>
    <span class="s1">&#39;WAIT&#39;</span><span class="p">:</span> <span class="n">JobState</span><span class="o">.</span><span class="n">QUEUED</span><span class="p">,</span>
    <span class="s1">&#39;ZOMBI&#39;</span><span class="p">:</span> <span class="n">JobState</span><span class="o">.</span><span class="n">UNDETERMINED</span><span class="p">,</span>
<span class="p">}</span>

<span class="c1"># Separator between fields in the output of bjobs</span>
<span class="n">_FIELD_SEPARATOR</span> <span class="o">=</span> <span class="s2">&quot;|&quot;</span>


<div class="viewcode-block" id="LsfJobResource"><a class="viewcode-back" href="../../../../apidoc/aiida.schedulers.plugins.html#aiida.schedulers.plugins.lsf.LsfJobResource">[docs]</a><span class="k">class</span> <span class="nc">LsfJobResource</span><span class="p">(</span><span class="n">JobResource</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An implementation of JobResource for LSF, that supports</span>
<span class="sd">    the OPTIONAL specification of a parallel environment (a string) + the total</span>
<span class="sd">    number of processors.</span>

<span class="sd">    &#39;parallel_env&#39; should contain a string of the form</span>
<span class="sd">    &quot;host1 host2! hostgroupA! host3 host4&quot; where the &quot;!&quot; symbol indicates the</span>
<span class="sd">    first execution host candidates. Other hosts are added only if the number of</span>
<span class="sd">    processors asked is more than those of the first execution host.</span>
<span class="sd">    See https://www-01.ibm.com/support/knowledgecenter/SSETD4_9.1.2/lsf_command_ref/bsub.1.dita?lang=en</span>
<span class="sd">    for more details about the parallel environment definition (the -m option of bsub).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_default_fields</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s1">&#39;parallel_env&#39;</span><span class="p">,</span>
        <span class="s1">&#39;tot_num_mpiprocs&#39;</span><span class="p">,</span>
        <span class="s1">&#39;default_mpiprocs_per_machine&#39;</span><span class="p">,</span>
    <span class="p">)</span>

<div class="viewcode-block" id="LsfJobResource.__init__"><a class="viewcode-back" href="../../../../apidoc/aiida.schedulers.plugins.html#aiida.schedulers.plugins.lsf.LsfJobResource.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the job resources from the passed arguments (the valid keys can be</span>
<span class="sd">        obtained with the function self.get_valid_keys()).</span>

<span class="sd">        :raise ValueError: on invalid parameters.</span>
<span class="sd">        :raise TypeError: on invalid parameters.</span>
<span class="sd">        :raise aiida.common.ConfigurationError: if default_mpiprocs_per_machine was set for this</span>
<span class="sd">            computer, since LsfJobResource cannot accept this parameter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">aiida.common.exceptions</span> <span class="k">import</span> <span class="n">ConfigurationError</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">LsfJobResource</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parallel_env</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;parallel_env&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">))</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;When specified, &#39;parallel_env&#39; must be a string&quot;</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tot_num_mpiprocs</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;tot_num_mpiprocs&#39;</span><span class="p">))</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;tot_num_mpiprocs must be specified and must be an integer&quot;</span><span class="p">)</span>

        <span class="n">default_mpiprocs_per_machine</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;default_mpiprocs_per_machine&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">default_mpiprocs_per_machine</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ConfigurationError</span><span class="p">(</span><span class="s2">&quot;default_mpiprocs_per_machine cannot be set for LSF scheduler&quot;</span><span class="p">)</span>

        <span class="n">num_machines</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;num_machines&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">num_machines</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ConfigurationError</span><span class="p">(</span><span class="s2">&quot;num_machines cannot be set for LSF scheduler&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tot_num_mpiprocs</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;tot_num_mpiprocs must be &gt;= 1&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="LsfJobResource.get_tot_num_mpiprocs"><a class="viewcode-back" href="../../../../apidoc/aiida.schedulers.plugins.html#aiida.schedulers.plugins.lsf.LsfJobResource.get_tot_num_mpiprocs">[docs]</a>    <span class="k">def</span> <span class="nf">get_tot_num_mpiprocs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the total number of cpus of this job resource.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tot_num_mpiprocs</span></div>

<div class="viewcode-block" id="LsfJobResource.accepts_default_mpiprocs_per_machine"><a class="viewcode-back" href="../../../../apidoc/aiida.schedulers.plugins.html#aiida.schedulers.plugins.lsf.LsfJobResource.accepts_default_mpiprocs_per_machine">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">accepts_default_mpiprocs_per_machine</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if this JobResource accepts a &#39;default_mpiprocs_per_machine&#39;</span>
<span class="sd">        key, False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">False</span></div></div>


<div class="viewcode-block" id="LsfScheduler"><a class="viewcode-back" href="../../../../apidoc/aiida.schedulers.plugins.html#aiida.schedulers.plugins.lsf.LsfScheduler">[docs]</a><span class="k">class</span> <span class="nc">LsfScheduler</span><span class="p">(</span><span class="n">aiida</span><span class="o">.</span><span class="n">schedulers</span><span class="o">.</span><span class="n">Scheduler</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Support for the IBM LSF scheduler</span>
<span class="sd">    &#39;https://www-01.ibm.com/support/knowledgecenter/SSETD4_9.1.2/lsf_welcome.html&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_logger</span> <span class="o">=</span> <span class="n">aiida</span><span class="o">.</span><span class="n">schedulers</span><span class="o">.</span><span class="n">Scheduler</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">getChild</span><span class="p">(</span><span class="s1">&#39;lsf&#39;</span><span class="p">)</span>

    <span class="c1"># Query only by list of jobs and not by user</span>
    <span class="n">_features</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;can_query_by_user&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="c1"># The class to be used for the job resource.</span>
    <span class="n">_job_resource_class</span> <span class="o">=</span> <span class="n">LsfJobResource</span>

    <span class="c1"># Unavailable field: substate</span>
    <span class="c1"># Note! If you change the fields or fields length, update accordingly</span>
    <span class="c1"># also the parsing function!</span>
    <span class="c1">#     _joblist_fields= [&quot;id&quot;, # job id</span>
    <span class="c1">#                       &quot;stat&quot;, # job state</span>
    <span class="c1">#                       &quot;exit_code&quot;, # exit code</span>
    <span class="c1">#                       &quot;exit_reason&quot;, # reason for the job being in an exit state</span>
    <span class="c1">#                       &quot;exec_host&quot;, # list of executing hosts (separated by &#39;:&#39;)</span>
    <span class="c1">#                       &quot;user&quot;, # user name</span>
    <span class="c1">#                       &quot;slots&quot;, # number of nodes allocated</span>
    <span class="c1">#                       &quot;queue&quot;, # queue of the job</span>
    <span class="c1">#                       &quot;finish_time&quot;, # time at which the job has or should have</span>
    <span class="c1">#                                      # finished (date followed by hours:minutes)</span>
    <span class="c1">#                                      # It may also give one of the following symbols:</span>
    <span class="c1">#                                      # - E: The job has an estimated run time that</span>
    <span class="c1">#                                      #      has not been exceeded.</span>
    <span class="c1">#                                      # - L: The job has a hard run time limit</span>
    <span class="c1">#                                      #      specified but either has no estimated</span>
    <span class="c1">#                                      #      run time or the estimated run time is</span>
    <span class="c1">#                                      #      more than the hard run time limit.</span>
    <span class="c1">#                                      # - X: The job has exceeded its estimated run</span>
    <span class="c1">#                                      #      time and the time displayed is the time</span>
    <span class="c1">#                                      #      remaining until the job reaches its hard</span>
    <span class="c1">#                                      #      run time limit.</span>
    <span class="c1">#                                      # Also, a dash alone indicates that the job has no</span>
    <span class="c1">#                                      #   estimated run time and no run limit, or</span>
    <span class="c1">#                                      # that it has exceeded its run time but does</span>
    <span class="c1">#                                      # not have a hard limit and therefore runs until completion.</span>
    <span class="c1">#                       &quot;time_left&quot;, # time left before completion, i.e. to reach</span>
    <span class="c1">#                                    # finish_time (hours:minutes)</span>
    <span class="c1">#                                    # See also &#39;finish_time&#39; (symbols, and dash).</span>
    <span class="c1">#                       &quot;run_time&quot;, # total time used by the job (in seconds)</span>
    <span class="c1">#                       &quot;cpu_used&quot;, # CPU time in seconds (all CPUs cumulated, idle</span>
    <span class="c1">#                                   # time subtracted)</span>
    <span class="c1">#                       &quot;submit_time&quot;, # submission time (date followed by hours:minutes)</span>
    <span class="c1">#                       &quot;estart_time&quot;, # estimated start time (date followed by hours:minutes)</span>
    <span class="c1">#                       &quot;start_time&quot;, # actual start time (date followed by hours:minutes)</span>
    <span class="c1">#                       &quot;name&quot;, # job name</span>
    <span class="c1">#                       ]</span>
    <span class="n">_joblist_fields</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;id&quot;</span><span class="p">,</span>  <span class="c1"># job id</span>
        <span class="s2">&quot;stat&quot;</span><span class="p">,</span>  <span class="c1"># job state</span>
        <span class="c1"># &quot;exit_code&quot;, # exit code</span>
        <span class="s2">&quot;exit_reason&quot;</span><span class="p">,</span>  <span class="c1"># reason for the job being in an exit state</span>
        <span class="s2">&quot;exec_host&quot;</span><span class="p">,</span>  <span class="c1"># list of executing hosts (separated by &#39;:&#39;)</span>
        <span class="s2">&quot;user&quot;</span><span class="p">,</span>  <span class="c1"># user name</span>
        <span class="s2">&quot;slots&quot;</span><span class="p">,</span>  <span class="c1"># number of nodes allocated</span>
        <span class="s2">&quot;max_req_proc&quot;</span><span class="p">,</span>  <span class="c1"># max number of CPU requested</span>
        <span class="s2">&quot;exec_host&quot;</span><span class="p">,</span>  <span class="c1"># names of the hosting nodes</span>
        <span class="s2">&quot;queue&quot;</span><span class="p">,</span>  <span class="c1"># queue of the job</span>
        <span class="s2">&quot;finish_time&quot;</span><span class="p">,</span>  <span class="c1"># time at which the job has or should have</span>
        <span class="c1"># finished (date followed by hours:minutes)</span>
        <span class="c1"># It may also give one of the following symbols:</span>
        <span class="c1"># - E: The job has an estimated run time that</span>
        <span class="c1">#      has not been exceeded.</span>
        <span class="c1"># - L: The job has a hard run time limit</span>
        <span class="c1">#      specified but either has no estimated</span>
        <span class="c1">#      run time or the estimated run time is</span>
        <span class="c1">#      more than the hard run time limit.</span>
        <span class="c1"># - X: The job has exceeded its estimated run</span>
        <span class="c1">#      time and the time displayed is the time</span>
        <span class="c1">#      remaining until the job reaches its hard</span>
        <span class="c1">#      run time limit.</span>
        <span class="c1"># Also, a dash alone indicates that the job has no</span>
        <span class="c1">#   estimated run time and no run limit, or</span>
        <span class="c1"># that it has exceeded its run time but does</span>
        <span class="c1"># not have a hard limit and therefore runs until completion.</span>
        <span class="s2">&quot;start_time&quot;</span><span class="p">,</span>
        <span class="s2">&quot;</span><span class="si">%c</span><span class="s2">omplete&quot;</span><span class="p">,</span>
        <span class="s2">&quot;submit_time&quot;</span><span class="p">,</span>  <span class="c1"># submission time (date followed by hours:minutes)</span>
        <span class="s2">&quot;name&quot;</span><span class="p">,</span>  <span class="c1"># job name</span>
    <span class="p">]</span>

<div class="viewcode-block" id="LsfScheduler._get_joblist_command"><a class="viewcode-back" href="../../../../apidoc/aiida.schedulers.plugins.html#aiida.schedulers.plugins.lsf.LsfScheduler._get_joblist_command">[docs]</a>    <span class="k">def</span> <span class="nf">_get_joblist_command</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">jobs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">user</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The command to report full information on existing jobs.</span>

<span class="sd">        Separates the fields with the _field_separator string order:</span>
<span class="sd">        jobnum, state, walltime, queue[=partition], user, numnodes, numcores, title</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">aiida.common.exceptions</span> <span class="k">import</span> <span class="n">FeatureNotAvailable</span>

        <span class="c1"># I add the environment variable SLURM_TIME_FORMAT in front to be</span>
        <span class="c1"># sure to get the times in &#39;standard&#39; format</span>
        <span class="n">command</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;bjobs&quot;</span><span class="p">,</span> <span class="s2">&quot;-noheader&quot;</span><span class="p">,</span> <span class="s2">&quot;-o &#39;</span><span class="si">{}</span><span class="s2"> delimiter=</span><span class="se">\&quot;</span><span class="si">{}</span><span class="se">\&quot;</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_joblist_fields</span><span class="p">),</span> <span class="n">_FIELD_SEPARATOR</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="k">if</span> <span class="n">user</span> <span class="ow">and</span> <span class="n">jobs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">FeatureNotAvailable</span><span class="p">(</span><span class="s2">&quot;Cannot query by user and job(s) in LSF&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">user</span><span class="p">:</span>
            <span class="n">command</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;-u</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">user</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">jobs</span><span class="p">:</span>
            <span class="n">joblist</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">jobs</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
                <span class="n">joblist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">jobs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">jobs</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;If provided, the &#39;jobs&#39; variable must be a string or a list of strings&quot;</span><span class="p">)</span>
                <span class="n">joblist</span> <span class="o">=</span> <span class="n">jobs</span>
            <span class="n">command</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">joblist</span><span class="p">))</span>

        <span class="n">comm</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">command</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;bjobs command: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">comm</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">comm</span></div>

<div class="viewcode-block" id="LsfScheduler._get_detailed_jobinfo_command"><a class="viewcode-back" href="../../../../apidoc/aiida.schedulers.plugins.html#aiida.schedulers.plugins.lsf.LsfScheduler._get_detailed_jobinfo_command">[docs]</a>    <span class="k">def</span> <span class="nf">_get_detailed_jobinfo_command</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">jobid</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the command to run to get the detailed information on a job,</span>
<span class="sd">        even after the job has finished.</span>

<span class="sd">        The output text is just retrieved, and returned for logging purposes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;bjobs -l </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">escape_for_bash</span><span class="p">(</span><span class="n">jobid</span><span class="p">))</span></div>

<div class="viewcode-block" id="LsfScheduler._get_submit_script_header"><a class="viewcode-back" href="../../../../apidoc/aiida.schedulers.plugins.html#aiida.schedulers.plugins.lsf.LsfScheduler._get_submit_script_header">[docs]</a>    <span class="k">def</span> <span class="nf">_get_submit_script_header</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">job_tmpl</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the submit script header, using the parameters from the</span>
<span class="sd">        job_tmpl. See the following manual</span>
<span class="sd">        https://www-01.ibm.com/support/knowledgecenter/SSETD4_9.1.2/lsf_command_ref/bsub.1.dita?lang=en</span>
<span class="sd">        for more details about the possible options to bsub, in particular for</span>
<span class="sd">        the parallel environment definition (with the -m option).</span>

<span class="sd">        :param job_tmpl: an JobTemplate instance with relevant parameters set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">string</span>
        <span class="kn">import</span> <span class="nn">re</span>

        <span class="n">empty_line</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">job_tmpl</span><span class="o">.</span><span class="n">submit_as_hold</span><span class="p">:</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;#BSUB -H&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">job_tmpl</span><span class="o">.</span><span class="n">rerunnable</span><span class="p">:</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;#BSUB -r&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;#BSUB -rn&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">job_tmpl</span><span class="o">.</span><span class="n">email</span><span class="p">:</span>
            <span class="c1"># If not specified, but email events are set, SLURM</span>
            <span class="c1"># sends the mail to the job owner by default</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;#BSUB -u </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">job_tmpl</span><span class="o">.</span><span class="n">email</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">job_tmpl</span><span class="o">.</span><span class="n">email_on_started</span><span class="p">:</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;#BSUB -B&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">job_tmpl</span><span class="o">.</span><span class="n">email_on_terminated</span><span class="p">:</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;#BSUB -N&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">job_tmpl</span><span class="o">.</span><span class="n">job_name</span><span class="p">:</span>
            <span class="c1"># The man page specifies only a limitation</span>
            <span class="c1"># on the job name to 4094 characters.</span>
            <span class="c1"># To be safe, I remove unwanted characters, and I</span>
            <span class="c1"># trim it to length 128.</span>

            <span class="c1"># I leave only letters, numbers, dots, dashes and underscores</span>
            <span class="c1"># Note: I don&#39;t compile the regexp, I am going to use it only once</span>
            <span class="n">job_title</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;[^a-zA-Z0-9_.-]+&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">job_tmpl</span><span class="o">.</span><span class="n">job_name</span><span class="p">)</span>

            <span class="c1"># prepend a &#39;j&#39; (for &#39;job&#39;) before the string if the string</span>
            <span class="c1"># is now empty or does not start with a valid character</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">job_title</span> <span class="ow">or</span> <span class="p">(</span><span class="n">job_title</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">string</span><span class="o">.</span><span class="n">ascii_letters</span> <span class="o">+</span> <span class="n">string</span><span class="o">.</span><span class="n">digits</span><span class="p">):</span>
                <span class="n">job_title</span> <span class="o">=</span> <span class="s1">&#39;j&#39;</span> <span class="o">+</span> <span class="n">job_title</span>

            <span class="c1"># Truncate to the first 128 characters</span>
            <span class="c1"># Nothing is done if the string is shorter.</span>
            <span class="n">job_title</span> <span class="o">=</span> <span class="n">job_title</span><span class="p">[:</span><span class="mi">128</span><span class="p">]</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;#BSUB -J &quot;</span><span class="si">{}</span><span class="s1">&quot;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">job_title</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">job_tmpl</span><span class="o">.</span><span class="n">import_sys_environment</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;LSF scheduler cannot ignore the user environment&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">job_tmpl</span><span class="o">.</span><span class="n">sched_output_path</span><span class="p">:</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;#BSUB -o </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">job_tmpl</span><span class="o">.</span><span class="n">sched_output_path</span><span class="p">))</span>

        <span class="n">sched_error_path</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">job_tmpl</span><span class="p">,</span> <span class="s1">&#39;sched_error_path&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">job_tmpl</span><span class="o">.</span><span class="n">sched_join_files</span><span class="p">:</span>
            <span class="n">sched_error_path</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">job_tmpl</span><span class="o">.</span><span class="n">sched_output_path</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;LSF scheduler does not support joining &quot;</span>
                                <span class="s2">&quot;the standard output and standard error &quot;</span>
                                <span class="s2">&quot;files; std error file assigned instead &quot;</span>
                                <span class="s2">&quot;to the file </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sched_error_path</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">sched_error_path</span><span class="p">:</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;#BSUB -e </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">job_tmpl</span><span class="o">.</span><span class="n">sched_error_path</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">job_tmpl</span><span class="o">.</span><span class="n">queue_name</span><span class="p">:</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;#BSUB -q </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">job_tmpl</span><span class="o">.</span><span class="n">queue_name</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">job_tmpl</span><span class="o">.</span><span class="n">priority</span><span class="p">:</span>
            <span class="c1"># Specifies user-assigned job priority that orders all jobs</span>
            <span class="c1"># (from all users) in a queue. Valid values for priority</span>
            <span class="c1"># are any integers between 1 and MAX_USER_PRIORITY</span>
            <span class="c1"># (configured in lsb.params, displayed by &quot;bparams -l&quot;).</span>
            <span class="c1"># Jobs are scheduled based first on their queue priority first, then</span>
            <span class="c1"># job priority, and lastly in first-come first-served order.</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;#BSUB -sp </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">job_tmpl</span><span class="o">.</span><span class="n">priority</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">job_tmpl</span><span class="o">.</span><span class="n">job_resource</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Job resources (as the tot_num_mpiprocs) are required for the LSF scheduler plugin&quot;</span><span class="p">)</span>

        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;#BSUB -n </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">job_tmpl</span><span class="o">.</span><span class="n">job_resource</span><span class="o">.</span><span class="n">get_tot_num_mpiprocs</span><span class="p">()))</span>
        <span class="c1"># Note:  make sure that PARALLEL_SCHED_BY_SLOT=Y is NOT</span>
        <span class="c1"># defined in lsb.params (you can check with the output of bparams -l).</span>
        <span class="c1"># Note: the -n option of bsub can also contain a maximum number of</span>
        <span class="c1"># procs to be used</span>
        <span class="k">if</span> <span class="n">job_tmpl</span><span class="o">.</span><span class="n">job_resource</span><span class="o">.</span><span class="n">parallel_env</span><span class="p">:</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;#BSUB -m &quot;</span><span class="si">{}</span><span class="s1">&quot;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">job_tmpl</span><span class="o">.</span><span class="n">job_resource</span><span class="o">.</span><span class="n">parallel_env</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">job_tmpl</span><span class="o">.</span><span class="n">max_wallclock_seconds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># ABS_RUNLIMIT=Y should be set, in lsb.params (check with bparams -l)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">tot_secs</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">job_tmpl</span><span class="o">.</span><span class="n">max_wallclock_seconds</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">tot_secs</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;max_wallclock_seconds must be &quot;</span>
                                 <span class="s2">&quot;a positive integer (in seconds)! It is instead &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span>
                                 <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">((</span><span class="n">job_tmpl</span><span class="o">.</span><span class="n">max_wallclock_seconds</span><span class="p">)))</span>
            <span class="n">hours</span> <span class="o">=</span> <span class="n">tot_secs</span> <span class="o">//</span> <span class="mi">3600</span>
            <span class="c1"># The double negation results in the ceiling rather than the floor</span>
            <span class="c1"># of the division</span>
            <span class="n">minutes</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">tot_secs</span> <span class="o">%</span> <span class="mi">3600</span><span class="p">)</span> <span class="o">//</span> <span class="mi">60</span><span class="p">)</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;#BSUB -W </span><span class="si">{:02d}</span><span class="s2">:</span><span class="si">{:02d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">hours</span><span class="p">,</span> <span class="n">minutes</span><span class="p">))</span>

        <span class="c1"># TODO: check if this is the memory per node</span>
        <span class="k">if</span> <span class="n">job_tmpl</span><span class="o">.</span><span class="n">max_memory_kb</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">virtual_memory_kb</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">job_tmpl</span><span class="o">.</span><span class="n">max_memory_kb</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">virtual_memory_kb</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;max_memory_kb must be &quot;</span>
                                 <span class="s2">&quot;a positive integer (in kB)! It is instead &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span>
                                 <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">((</span><span class="n">job_tmpl</span><span class="o">.</span><span class="n">MaxMemoryKb</span><span class="p">)))</span>
            <span class="c1"># The -M option sets a per-process (soft) memory limit for all the</span>
            <span class="c1"># processes that belong to this job</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;#BSUB -M </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">virtual_memory_kb</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">job_tmpl</span><span class="o">.</span><span class="n">custom_scheduler_commands</span><span class="p">:</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">job_tmpl</span><span class="o">.</span><span class="n">custom_scheduler_commands</span><span class="p">)</span>

        <span class="c1"># Job environment variables are to be set on one single line.</span>
        <span class="c1"># This is a tough job due to the escaping of commas, etc.</span>
        <span class="c1"># moreover, I am having issues making it work.</span>
        <span class="c1"># Therefore, I assume that this is bash and export variables by</span>
        <span class="c1"># hand.</span>
        <span class="k">if</span> <span class="n">job_tmpl</span><span class="o">.</span><span class="n">job_environment</span><span class="p">:</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">empty_line</span><span class="p">)</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;# ENVIRONMENT VARIABLES BEGIN ###&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">job_tmpl</span><span class="o">.</span><span class="n">job_environment</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;If you provide job_environment, it must be a dictionary&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">job_tmpl</span><span class="o">.</span><span class="n">job_environment</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;export </span><span class="si">{}</span><span class="s2">=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">strip</span><span class="p">(),</span> <span class="n">escape_for_bash</span><span class="p">(</span><span class="n">value</span><span class="p">)))</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;# ENVIRONMENT VARIABLES END  ###&quot;</span><span class="p">)</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">empty_line</span><span class="p">)</span>

        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">empty_line</span><span class="p">)</span>

        <span class="c1"># The following seems to be the only way to copy the input files</span>
        <span class="c1"># to the node where the computation are actually launched (the</span>
        <span class="c1"># -f option of bsub that does not always work...)</span>
        <span class="c1"># TODO: implement the case when LSB_OUTDIR is not properly defined...</span>
        <span class="c1"># (need to add the line &quot;#BSUB -outdir PATH_TO_REMOTE_DIRECTORY&quot;)</span>
        <span class="c1"># IMPORTANT! the -z is needed, because if LSB_OUTDIR is not defined,</span>
        <span class="c1"># you would do &#39;cp -R /* .&#39; basically copying ALL FILES in your</span>
        <span class="c1"># computer (including mounted partitions) in the current dir!!</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">if [ ! -z &quot;$LSB_OUTDIR&quot; ]</span>
<span class="s2">then</span>
<span class="s2">  cp -R &quot;$LSB_OUTDIR&quot;/* .</span>
<span class="s2">fi</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span></div>

<div class="viewcode-block" id="LsfScheduler._get_submit_script_footer"><a class="viewcode-back" href="../../../../apidoc/aiida.schedulers.plugins.html#aiida.schedulers.plugins.lsf.LsfScheduler._get_submit_script_footer">[docs]</a>    <span class="k">def</span> <span class="nf">_get_submit_script_footer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">job_tmpl</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the submit script final part, using the parameters from the</span>
<span class="sd">        job_tmpl.</span>

<span class="sd">        :param job_tmpl: a JobTemplate instance with relevant parameters set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># line to retrieve back the output of the computation (rather than</span>
        <span class="c1"># the -f option of bsub that does not always work...)</span>
        <span class="c1"># TODO: implement the case when LSB_OUTDIR is not properly defined...</span>
        <span class="c1"># (need to add the line &quot;#BSUB -outdir PATH_TO_REMOTE_DIRECTORY&quot;)</span>
        <span class="c1"># As above, important to check if the folder variable is defined</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">if [ ! -z &quot;$LSB_OUTDIR&quot; ]</span>
<span class="s2">then</span>
<span class="s2">   cp -R * &quot;$LSB_OUTDIR&quot;</span>
<span class="s2">fi</span>
<span class="s2">&quot;&quot;&quot;</span></div>

<div class="viewcode-block" id="LsfScheduler._get_submit_command"><a class="viewcode-back" href="../../../../apidoc/aiida.schedulers.plugins.html#aiida.schedulers.plugins.lsf.LsfScheduler._get_submit_command">[docs]</a>    <span class="k">def</span> <span class="nf">_get_submit_command</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">submit_script</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the string to execute to submit a given script.</span>

<span class="sd">        :param submit_script: the path of the submit script relative to the working</span>
<span class="sd">                directory.</span>
<span class="sd">                IMPORTANT: submit_script should be already escaped.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">submit_command</span> <span class="o">=</span> <span class="s1">&#39;bsub &lt; </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">submit_script</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;submitting with: &quot;</span> <span class="o">+</span> <span class="n">submit_command</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">submit_command</span></div>

<div class="viewcode-block" id="LsfScheduler._parse_joblist_output"><a class="viewcode-back" href="../../../../apidoc/aiida.schedulers.plugins.html#aiida.schedulers.plugins.lsf.LsfScheduler._parse_joblist_output">[docs]</a>    <span class="k">def</span> <span class="nf">_parse_joblist_output</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">retval</span><span class="p">,</span> <span class="n">stdout</span><span class="p">,</span> <span class="n">stderr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parse the queue output string, as returned by executing the</span>
<span class="sd">        command returned by _get_joblist_command command,</span>
<span class="sd">        that is here implemented as a list of lines, one for each</span>
<span class="sd">        job, with _field_separator as separator. The order is described</span>
<span class="sd">        in the _get_joblist_command function.</span>

<span class="sd">        Return a list of JobInfo objects, one of each job,</span>
<span class="sd">        each relevant parameters implemented.</span>

<span class="sd">        Note: depending on the scheduler configuration, finished jobs may</span>
<span class="sd">            either appear here, or not.</span>
<span class="sd">            This function will only return one element for each job find</span>
<span class="sd">            in the qstat output; missing jobs (for whatever reason) simply</span>
<span class="sd">            will not appear here.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">num_fields</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_joblist_fields</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">retval</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Error in _parse_joblist_output: retval=</span><span class="si">{}</span><span class="s2">; &quot;</span>
                                <span class="s2">&quot;stdout=</span><span class="si">{}</span><span class="s2">; stderr=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="n">stdout</span><span class="p">,</span> <span class="n">stderr</span><span class="p">))</span>
            <span class="k">raise</span> <span class="n">SchedulerError</span><span class="p">(</span><span class="s2">&quot;Error during parsing joblist output, &quot;</span>
                                 <span class="s2">&quot;retval=</span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span>
                                 <span class="s2">&quot;stdout=</span><span class="si">{}</span><span class="se">\n</span><span class="s2">stderr=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="n">stdout</span><span class="p">,</span> <span class="n">stderr</span><span class="p">))</span>

        <span class="c1"># will contain raw data parsed from output: only lines with the</span>
        <span class="c1"># separator, and already split in fields</span>
        <span class="c1"># I put num_fields, because in this way</span>
        <span class="c1"># if the symbol _field_separator appears in the title (that is</span>
        <span class="c1"># the last field), I don&#39;t split the title.</span>
        <span class="c1"># This assumes that _field_separator never</span>
        <span class="c1"># appears in any previous field.</span>
        <span class="n">jobdata_raw</span> <span class="o">=</span> <span class="p">[</span><span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">_FIELD_SEPARATOR</span><span class="p">,</span> <span class="n">num_fields</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">stdout</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span> <span class="k">if</span> <span class="n">_FIELD_SEPARATOR</span> <span class="ow">in</span> <span class="n">l</span><span class="p">]</span>

        <span class="c1"># Create dictionary and parse specific fields</span>
        <span class="n">job_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">job</span> <span class="ow">in</span> <span class="n">jobdata_raw</span><span class="p">:</span>

            <span class="c1"># Each job should have all fields.</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">job</span><span class="p">)</span> <span class="o">!=</span> <span class="n">num_fields</span><span class="p">:</span>
                <span class="c1"># I skip this calculation</span>
                <span class="c1"># (I don&#39;t append anything to job_list before continuing)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Wrong line length in squeue output! &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">job</span><span class="p">))</span>
                <span class="k">continue</span>

            <span class="n">this_job</span> <span class="o">=</span> <span class="n">JobInfo</span><span class="p">()</span>
            <span class="n">this_job</span><span class="o">.</span><span class="n">job_id</span> <span class="o">=</span> <span class="n">job</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">this_job</span><span class="o">.</span><span class="n">annotation</span> <span class="o">=</span> <span class="n">job</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">job_state_raw</span> <span class="o">=</span> <span class="n">job</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">job_state_string</span> <span class="o">=</span> <span class="n">_MAP_STATUS_LSF</span><span class="p">[</span><span class="n">job_state_raw</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Unrecognized job_state &#39;</span><span class="si">{}</span><span class="s2">&#39; for job &quot;</span>
                                    <span class="s2">&quot;id </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">job_state_raw</span><span class="p">,</span> <span class="n">this_job</span><span class="o">.</span><span class="n">job_id</span><span class="p">))</span>
                <span class="n">job_state_string</span> <span class="o">=</span> <span class="n">JobState</span><span class="o">.</span><span class="n">UNDETERMINED</span>

            <span class="n">this_job</span><span class="o">.</span><span class="n">job_state</span> <span class="o">=</span> <span class="n">job_state_string</span>

            <span class="c1"># I get the remaining fields</span>
            <span class="c1"># The first three were already obtained</span>
            <span class="c1"># I know that the length is exactly num_fields because</span>
            <span class="c1"># I used split(_field_separator, num_fields) before</span>
            <span class="c1"># when creting &#39;job&#39;</span>
            <span class="c1">#            (_, _, _, executing_host, username, number_nodes,</span>
            <span class="c1">#             number_cpus, allocated_machines, partition,</span>
            <span class="c1">#             time_limit, time_used, dispatch_time, job_name) = job</span>
            <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">username</span><span class="p">,</span> <span class="n">number_nodes</span><span class="p">,</span> <span class="n">number_cpus</span><span class="p">,</span> <span class="n">allocated_machines</span><span class="p">,</span> <span class="n">partition</span><span class="p">,</span> <span class="n">finish_time</span><span class="p">,</span> <span class="n">start_time</span><span class="p">,</span>
             <span class="n">percent_complete</span><span class="p">,</span> <span class="n">submission_time</span><span class="p">,</span> <span class="n">job_name</span><span class="p">)</span> <span class="o">=</span> <span class="n">job</span>

            <span class="n">this_job</span><span class="o">.</span><span class="n">job_owner</span> <span class="o">=</span> <span class="n">username</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">this_job</span><span class="o">.</span><span class="n">num_machines</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">number_nodes</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;The number of allocated nodes is not &quot;</span>
                                    <span class="s2">&quot;an integer (</span><span class="si">{}</span><span class="s2">) for job id </span><span class="si">{}</span><span class="s2">!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">number_nodes</span><span class="p">,</span> <span class="n">this_job</span><span class="o">.</span><span class="n">job_id</span><span class="p">))</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">this_job</span><span class="o">.</span><span class="n">num_mpiprocs</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">number_cpus</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;The number of allocated cores is not &quot;</span>
                                    <span class="s2">&quot;an integer (</span><span class="si">{}</span><span class="s2">) for job id </span><span class="si">{}</span><span class="s2">!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">number_cpus</span><span class="p">,</span> <span class="n">this_job</span><span class="o">.</span><span class="n">job_id</span><span class="p">))</span>

            <span class="c1"># ALLOCATED NODES HERE</span>
            <span class="c1"># string may be in the format</span>
            <span class="c1"># nid00[684-685,722-723,748-749,958-959]</span>
            <span class="c1"># therefore it requires some parsing, that is unnecessary now.</span>
            <span class="c1"># I just store is as a raw string for the moment, and I leave</span>
            <span class="c1"># this_job.allocated_machines undefined</span>
            <span class="k">if</span> <span class="n">this_job</span><span class="o">.</span><span class="n">job_state</span> <span class="o">==</span> <span class="n">JobState</span><span class="o">.</span><span class="n">RUNNING</span><span class="p">:</span>
                <span class="n">this_job</span><span class="o">.</span><span class="n">allocated_machines_raw</span> <span class="o">=</span> <span class="n">allocated_machines</span>

            <span class="n">this_job</span><span class="o">.</span><span class="n">queue_name</span> <span class="o">=</span> <span class="n">partition</span>

            <span class="n">psd_finish_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_time_string</span><span class="p">(</span><span class="n">finish_time</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;%b </span><span class="si">%d</span><span class="s1"> %H:%M&#39;</span><span class="p">)</span>
            <span class="n">psd_start_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_time_string</span><span class="p">(</span><span class="n">start_time</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;%b </span><span class="si">%d</span><span class="s1"> %H:%M&#39;</span><span class="p">)</span>
            <span class="n">psd_submission_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_time_string</span><span class="p">(</span><span class="n">submission_time</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;%b </span><span class="si">%d</span><span class="s1"> %H:%M&#39;</span><span class="p">)</span>

            <span class="c1"># Now get the time in seconds which has been used</span>
            <span class="c1"># Only if it is RUNNING; otherwise it is not meaningful,</span>
            <span class="c1"># and may be not set (in my test, it is set to zero)</span>
            <span class="k">if</span> <span class="n">this_job</span><span class="o">.</span><span class="n">job_state</span> <span class="o">==</span> <span class="n">JobState</span><span class="o">.</span><span class="n">RUNNING</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">requested_walltime</span> <span class="o">=</span> <span class="n">psd_finish_time</span> <span class="o">-</span> <span class="n">psd_start_time</span>
                    <span class="c1"># fix of a weird bug. Since the year is not parsed, it is assumed</span>
                    <span class="c1"># to always be 1900. Therefore, job submitted</span>
                    <span class="c1"># in december and finishing in january would produce negative time differences</span>
                    <span class="k">if</span> <span class="n">requested_walltime</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="kn">import</span> <span class="nn">datetime</span>
                        <span class="n">old_month</span> <span class="o">=</span> <span class="n">psd_finish_time</span><span class="o">.</span><span class="n">month</span>
                        <span class="n">old_day</span> <span class="o">=</span> <span class="n">psd_finish_time</span><span class="o">.</span><span class="n">day</span>
                        <span class="n">old_hour</span> <span class="o">=</span> <span class="n">psd_finish_time</span><span class="o">.</span><span class="n">hour</span>
                        <span class="n">old_minute</span> <span class="o">=</span> <span class="n">psd_finish_time</span><span class="o">.</span><span class="n">minute</span>
                        <span class="n">new_year</span> <span class="o">=</span> <span class="n">psd_start_time</span><span class="o">.</span><span class="n">year</span> <span class="o">+</span> <span class="mi">1</span>
                        <span class="c1"># note: we assume that no job will last more than 1 year...</span>
                        <span class="n">psd_finish_time</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span>
                            <span class="n">year</span><span class="o">=</span><span class="n">new_year</span><span class="p">,</span> <span class="n">month</span><span class="o">=</span><span class="n">old_month</span><span class="p">,</span> <span class="n">day</span><span class="o">=</span><span class="n">old_day</span><span class="p">,</span> <span class="n">hour</span><span class="o">=</span><span class="n">old_hour</span><span class="p">,</span> <span class="n">minute</span><span class="o">=</span><span class="n">old_minute</span><span class="p">)</span>
                        <span class="n">requested_walltime</span> <span class="o">=</span> <span class="n">psd_finish_time</span> <span class="o">-</span> <span class="n">psd_start_time</span>

                    <span class="n">this_job</span><span class="o">.</span><span class="n">requested_wallclock_time_seconds</span> <span class="o">=</span> <span class="n">requested_walltime</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">()</span>
                <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Error parsing the time limit for job id </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">this_job</span><span class="o">.</span><span class="n">job_id</span><span class="p">))</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="n">psd_percent_complete</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">percent_complete</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39; L&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s2">&quot;%&quot;</span><span class="p">))</span>
                    <span class="n">this_job</span><span class="o">.</span><span class="n">wallclock_time_seconds</span> <span class="o">=</span> <span class="n">requested_walltime</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">()</span> <span class="o">*</span> <span class="n">psd_percent_complete</span> <span class="o">/</span> <span class="mf">100.</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Error parsing the time used for job id </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">this_job</span><span class="o">.</span><span class="n">job_id</span><span class="p">))</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">this_job</span><span class="o">.</span><span class="n">submission_time</span> <span class="o">=</span> <span class="n">psd_submission_time</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Error parsing submission time for job id </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">this_job</span><span class="o">.</span><span class="n">job_id</span><span class="p">))</span>

            <span class="n">this_job</span><span class="o">.</span><span class="n">title</span> <span class="o">=</span> <span class="n">job_name</span>

            <span class="c1"># Everything goes here anyway for debugging purposes</span>
            <span class="n">this_job</span><span class="o">.</span><span class="n">raw_data</span> <span class="o">=</span> <span class="n">job</span>

            <span class="c1"># Double check of redundant info</span>
            <span class="c1"># Not really useful now, allocated_machines in this</span>
            <span class="c1"># version of the plugin is never set</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">this_job</span><span class="o">.</span><span class="n">allocated_machines</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">this_job</span><span class="o">.</span><span class="n">num_machines</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">this_job</span><span class="o">.</span><span class="n">allocated_machines</span><span class="p">)</span> <span class="o">!=</span> <span class="n">this_job</span><span class="o">.</span><span class="n">num_machines</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;The length of the list of allocated &quot;</span>
                                      <span class="s2">&quot;nodes (</span><span class="si">{}</span><span class="s2">) is different from the &quot;</span>
                                      <span class="s2">&quot;expected number of nodes (</span><span class="si">{}</span><span class="s2">)!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                          <span class="nb">len</span><span class="p">(</span><span class="n">this_job</span><span class="o">.</span><span class="n">allocated_machines</span><span class="p">),</span> <span class="n">this_job</span><span class="o">.</span><span class="n">num_machines</span><span class="p">))</span>

            <span class="c1"># I append to the list of jobs to return</span>
            <span class="n">job_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this_job</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">job_list</span></div>

<div class="viewcode-block" id="LsfScheduler._parse_submit_output"><a class="viewcode-back" href="../../../../apidoc/aiida.schedulers.plugins.html#aiida.schedulers.plugins.lsf.LsfScheduler._parse_submit_output">[docs]</a>    <span class="k">def</span> <span class="nf">_parse_submit_output</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">retval</span><span class="p">,</span> <span class="n">stdout</span><span class="p">,</span> <span class="n">stderr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parse the output of the submit command, as returned by executing the</span>
<span class="sd">        command returned by _get_submit_command command.</span>

<span class="sd">        To be implemented by the plugin.</span>

<span class="sd">        Return a string with the JobID.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">retval</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Error in _parse_submit_output: retval=</span><span class="si">{}</span><span class="s2">; &quot;</span>
                              <span class="s2">&quot;stdout=</span><span class="si">{}</span><span class="s2">; stderr=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="n">stdout</span><span class="p">,</span> <span class="n">stderr</span><span class="p">))</span>
            <span class="k">raise</span> <span class="n">SchedulerError</span><span class="p">(</span><span class="s2">&quot;Error during submission, retval=</span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span>
                                 <span class="s2">&quot;stdout=</span><span class="si">{}</span><span class="se">\n</span><span class="s2">stderr=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="n">stdout</span><span class="p">,</span> <span class="n">stderr</span><span class="p">))</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">transport_string</span> <span class="o">=</span> <span class="s2">&quot; for </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transport</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">SchedulerError</span><span class="p">:</span>
            <span class="n">transport_string</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="k">if</span> <span class="n">stderr</span><span class="o">.</span><span class="n">strip</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;in _parse_submit_output</span><span class="si">{}</span><span class="s2">: &quot;</span>
                                <span class="s2">&quot;there was some text in stderr: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">transport_string</span><span class="p">,</span> <span class="n">stderr</span><span class="p">))</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">stdout</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;Job &lt;&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;&gt;&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SchedulerParsingError</span><span class="p">(</span><span class="s2">&quot;Cannot parse submission output: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">stdout</span><span class="p">))</span></div>

<div class="viewcode-block" id="LsfScheduler._parse_time_string"><a class="viewcode-back" href="../../../../apidoc/aiida.schedulers.plugins.html#aiida.schedulers.plugins.lsf.LsfScheduler._parse_time_string">[docs]</a>    <span class="k">def</span> <span class="nf">_parse_time_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">string</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;%b </span><span class="si">%d</span><span class="s1"> %H:%M&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parse a time string and returns a datetime object.</span>
<span class="sd">        Example format: &#39;Feb  2 07:39&#39; or &#39;Feb  2 07:39 L&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">datetime</span>

        <span class="k">if</span> <span class="n">string</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># The year is not specified. I have to add it, and I set it to the</span>
        <span class="c1"># current year. This is actually not correct, if we are close</span>
        <span class="c1"># new year... we should ask the scheduler also the year.</span>
        <span class="n">actual_string</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">year</span><span class="p">,</span> <span class="n">string</span><span class="p">)</span>
        <span class="n">actual_fmt</span> <span class="o">=</span> <span class="s1">&#39;%Y </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fmt</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">thetime</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">actual_string</span><span class="p">,</span> <span class="n">actual_fmt</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="n">thetime</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">actual_string</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> L&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">actual_fmt</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Unable to parse time string </span><span class="si">{}</span><span class="s2">, the message was </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="n">exc</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Problem parsing the time string.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">thetime</span></div>

<div class="viewcode-block" id="LsfScheduler._get_kill_command"><a class="viewcode-back" href="../../../../apidoc/aiida.schedulers.plugins.html#aiida.schedulers.plugins.lsf.LsfScheduler._get_kill_command">[docs]</a>    <span class="k">def</span> <span class="nf">_get_kill_command</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">jobid</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the command to kill the job with specified jobid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">submit_command</span> <span class="o">=</span> <span class="s1">&#39;bkill </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">jobid</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;killing job </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">jobid</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">submit_command</span></div>

<div class="viewcode-block" id="LsfScheduler._parse_kill_output"><a class="viewcode-back" href="../../../../apidoc/aiida.schedulers.plugins.html#aiida.schedulers.plugins.lsf.LsfScheduler._parse_kill_output">[docs]</a>    <span class="k">def</span> <span class="nf">_parse_kill_output</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">retval</span><span class="p">,</span> <span class="n">stdout</span><span class="p">,</span> <span class="n">stderr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parse the output of the kill command.</span>

<span class="sd">        :return: True if everything seems ok, False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">retval</span> <span class="o">==</span> <span class="mi">255</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Error in _parse_kill_output: retval=</span><span class="si">{}</span><span class="s2"> (Job already finished); &quot;</span>
                              <span class="s2">&quot;stdout=</span><span class="si">{}</span><span class="s2">; stderr=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="n">stdout</span><span class="p">,</span> <span class="n">stderr</span><span class="p">))</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">retval</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Error in _parse_kill_output: retval=</span><span class="si">{}</span><span class="s2">; &quot;</span>
                              <span class="s2">&quot;stdout=</span><span class="si">{}</span><span class="s2">; stderr=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="n">stdout</span><span class="p">,</span> <span class="n">stderr</span><span class="p">))</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">transport_string</span> <span class="o">=</span> <span class="s2">&quot; for </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transport</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">SchedulerError</span><span class="p">:</span>
            <span class="n">transport_string</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="k">if</span> <span class="n">stderr</span><span class="o">.</span><span class="n">strip</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;in _parse_kill_output</span><span class="si">{}</span><span class="s2">: &quot;</span>
                                <span class="s2">&quot;there was some text in stderr: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">transport_string</span><span class="p">,</span> <span class="n">stderr</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">stdout</span><span class="o">.</span><span class="n">strip</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;in _parse_kill_output</span><span class="si">{}</span><span class="s2">: &quot;</span>
                                <span class="s2">&quot;there was some text in stdout: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">transport_string</span><span class="p">,</span> <span class="n">stdout</span><span class="p">))</span>

        <span class="k">return</span> <span class="kc">True</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, ECOLE POLYTECHNIQUE FEDERALE DE LAUSANNE (Theory and Simulation of Materials (THEOS) and National Centre for Computational Design and Discovery of Novel Materials (NCCR MARVEL)), Switzerland and ROBERT BOSCH LLC, USA. All rights reserved

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>