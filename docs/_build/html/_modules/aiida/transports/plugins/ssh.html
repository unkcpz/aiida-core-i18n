

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>aiida.transports.plugins.ssh &mdash; AiiDA 1.0.0b2 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../../_static/language_data.js"></script>
        <script type="text/javascript" src="../../../../_static/contentui.js"></script>
    
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/contentui.css" type="text/css" />
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../../index.html" class="icon icon-home"> AiiDA
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Installation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../install/quick_installation.html">Quick installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../install/prerequisites.html">Prerequisites</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../install/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../install/updating_installation.html">Updating AiiDA</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../install/troubleshooting.html">Troubleshooting</a></li>
</ul>
<p class="caption"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../get_started/index.html">First things first</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../get_started/daemon.html">Setup the daemon</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../get_started/computers.html">Setup a computer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../get_started/codes.html">Setup a code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../get_started/plugins.html">Plugins</a></li>
</ul>
<p class="caption"><span class="caption-text">Concepts</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../concepts/provenance.html">Provenance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../concepts/processes.html">Processes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../concepts/calculations.html">Calculations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../concepts/workflows.html">Workflows</a></li>
</ul>
<p class="caption"><span class="caption-text">Working with</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../working/processes.html">Processes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../working/functions.html">Calculation and work functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../working/calculations.html">Calculations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../working/workflows.html">Workflows</a></li>
</ul>
<p class="caption"><span class="caption-text">Working with AiiDA</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../working_with_aiida/index.html">Command line interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../working_with_aiida/index.html#scripting">Scripting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../working_with_aiida/index.html#data-types">Data types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../working_with_aiida/index.html#groups">Groups</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../working_with_aiida/index.html#schedulers">Schedulers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../working_with_aiida/index.html#querying-data">Querying data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../working_with_aiida/index.html#caching">Caching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../working_with_aiida/index.html#result-manager">Result manager</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../working_with_aiida/index.html#backups">Backups</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../working_with_aiida/index.html#troubleshooting">Troubleshooting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../working_with_aiida/index.html#rest-api">REST API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../working_with_aiida/index.html#cookbook">Cookbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../import_export/index.html">Import and Export</a></li>
</ul>
<p class="caption"><span class="caption-text">Development</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../developer_guide/index.html">AiiDA design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../developer_guide/index.html#aiida-core">AiiDA core</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../developer_guide/index.html#aiida-plugins">AiiDA plugins</a></li>
</ul>
<p class="caption"><span class="caption-text">Tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorial/index.html">StructureData</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorial/index.html#pseudopotentials">Pseudopotentials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorial/index.html#plugin-development">Plugin development</a></li>
</ul>
<p class="caption"><span class="caption-text">API reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="`aiida package &lt;https://aiida-core.readthedocs.io/en/latest/apidoc/aiida.html&gt;`_">`aiida package &lt;https://aiida-core.readthedocs.io/en/latest/apidoc/aiida.html&gt;`_</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">AiiDA</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../../../aiida.html">aiida</a> &raquo;</li>
        
      <li>aiida.transports.plugins.ssh</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for aiida.transports.plugins.ssh</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1">###########################################################################</span>
<span class="c1"># Copyright (c), The AiiDA team. All rights reserved.                     #</span>
<span class="c1"># This file is part of the AiiDA code.                                    #</span>
<span class="c1">#                                                                         #</span>
<span class="c1"># The code is hosted on GitHub at https://github.com/aiidateam/aiida_core #</span>
<span class="c1"># For further information on the license, see the LICENSE.txt file        #</span>
<span class="c1"># For further information please visit http://www.aiida.net               #</span>
<span class="c1">###########################################################################</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span>

<span class="kn">import</span> <span class="nn">io</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">click</span>
<span class="kn">import</span> <span class="nn">glob</span>
<span class="kn">from</span> <span class="nn">stat</span> <span class="k">import</span> <span class="n">S_ISDIR</span><span class="p">,</span> <span class="n">S_ISREG</span>

<span class="kn">import</span> <span class="nn">six</span>
<span class="kn">from</span> <span class="nn">six.moves</span> <span class="k">import</span> <span class="n">cStringIO</span> <span class="k">as</span> <span class="n">StringIO</span>

<span class="kn">from</span> <span class="nn">aiida.cmdline.params</span> <span class="k">import</span> <span class="n">options</span>
<span class="kn">from</span> <span class="nn">aiida.cmdline.params.types.path</span> <span class="k">import</span> <span class="n">AbsolutePathParamType</span>
<span class="kn">from</span> <span class="nn">aiida.common.escaping</span> <span class="k">import</span> <span class="n">escape_for_bash</span>
<span class="kn">from</span> <span class="nn">..transport</span> <span class="k">import</span> <span class="n">Transport</span><span class="p">,</span> <span class="n">TransportInternalError</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;parse_sshconfig&#39;</span><span class="p">,</span> <span class="s1">&#39;convert_to_bool&#39;</span><span class="p">,</span> <span class="s1">&#39;SshTransport&#39;</span><span class="p">)</span>


<span class="c1"># TODO : callback functions in paramiko are currently not used much and probably broken</span>
<div class="viewcode-block" id="parse_sshconfig"><a class="viewcode-back" href="../../../../apidoc/aiida.transports.plugins.html#aiida.transports.plugins.ssh.parse_sshconfig">[docs]</a><span class="k">def</span> <span class="nf">parse_sshconfig</span><span class="p">(</span><span class="n">computername</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">paramiko</span>
    <span class="n">config</span> <span class="o">=</span> <span class="n">paramiko</span><span class="o">.</span><span class="n">SSHConfig</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">config</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">io</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="s1">&#39;~/.ssh/config&#39;</span><span class="p">),</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;utf8&#39;</span><span class="p">))</span>
    <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
        <span class="c1"># No file found, so empty configuration</span>
        <span class="k">pass</span>

    <span class="k">return</span> <span class="n">config</span><span class="o">.</span><span class="n">lookup</span><span class="p">(</span><span class="n">computername</span><span class="p">)</span></div>


<div class="viewcode-block" id="convert_to_bool"><a class="viewcode-back" href="../../../../apidoc/aiida.transports.plugins.html#aiida.transports.plugins.ssh.convert_to_bool">[docs]</a><span class="k">def</span> <span class="nf">convert_to_bool</span><span class="p">(</span><span class="n">string</span><span class="p">):</span>
    <span class="n">upstring</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">string</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">upstring</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;YES&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;TRUE&#39;</span><span class="p">]:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">elif</span> <span class="n">upstring</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;N&#39;</span><span class="p">,</span> <span class="s1">&#39;NO&#39;</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="s1">&#39;FALSE&#39;</span><span class="p">]:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid boolean value provided&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="SshTransport"><a class="viewcode-back" href="../../../../developer_guide/core/transport.html#aiida.transports.plugins.ssh.SshTransport">[docs]</a><span class="k">class</span> <span class="nc">SshTransport</span><span class="p">(</span><span class="n">Transport</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Support connection, command execution and data transfer to remote computers via SSH+SFTP.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Valid keywords accepted by the connect method of paramiko.SSHClient</span>
    <span class="c1"># I disable &#39;password&#39; and &#39;pkey&#39; to avoid these data to get logged in the</span>
    <span class="c1"># aiida log file.</span>
    <span class="n">_valid_connect_options</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="s1">&#39;username&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;prompt&#39;</span><span class="p">:</span> <span class="s1">&#39;User name&#39;</span><span class="p">,</span> <span class="s1">&#39;help&#39;</span><span class="p">:</span> <span class="s1">&#39;user name for the computer&#39;</span><span class="p">,</span> <span class="s1">&#39;non_interactive_default&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}),</span>
        <span class="p">(</span><span class="s1">&#39;port&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;option&#39;</span><span class="p">:</span> <span class="n">options</span><span class="o">.</span><span class="n">PORT</span><span class="p">,</span> <span class="s1">&#39;prompt&#39;</span><span class="p">:</span> <span class="s1">&#39;port Nr&#39;</span><span class="p">,</span> <span class="s1">&#39;non_interactive_default&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}),</span>
        <span class="p">(</span><span class="s1">&#39;look_for_keys&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;switch&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="s1">&#39;prompt&#39;</span><span class="p">:</span> <span class="s1">&#39;Look for keys&#39;</span><span class="p">,</span> <span class="s1">&#39;help&#39;</span><span class="p">:</span> <span class="s1">&#39;switch automatic key file discovery on / off&#39;</span><span class="p">,</span> <span class="s1">&#39;non_interactive_default&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}),</span>
        <span class="p">(</span><span class="s1">&#39;key_filename&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="n">AbsolutePathParamType</span><span class="p">(</span><span class="n">dir_okay</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">exists</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span> <span class="s1">&#39;prompt&#39;</span><span class="p">:</span> <span class="s1">&#39;SSH key file&#39;</span><span class="p">,</span> <span class="s1">&#39;help&#39;</span><span class="p">:</span> <span class="s1">&#39;Manually pass a key file if default path is not set in ssh config&#39;</span><span class="p">,</span> <span class="s1">&#39;non_interactive_default&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}),</span>
        <span class="p">(</span><span class="s1">&#39;timeout&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;prompt&#39;</span><span class="p">:</span> <span class="s1">&#39;Connection timeout in s&#39;</span><span class="p">,</span> <span class="s1">&#39;help&#39;</span><span class="p">:</span> <span class="s1">&#39;time in seconds to wait for connection before giving up&#39;</span><span class="p">,</span> <span class="s1">&#39;non_interactive_default&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}),</span>
        <span class="p">(</span><span class="s1">&#39;allow_agent&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;switch&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="s1">&#39;prompt&#39;</span><span class="p">:</span> <span class="s1">&#39;Allow ssh agent&#39;</span><span class="p">,</span> <span class="s1">&#39;help&#39;</span><span class="p">:</span> <span class="s1">&#39;switch to allow or disallow ssh agent&#39;</span><span class="p">,</span> <span class="s1">&#39;non_interactive_default&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}),</span>
        <span class="p">(</span><span class="s1">&#39;proxy_command&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;prompt&#39;</span><span class="p">:</span> <span class="s1">&#39;SSH proxy command&#39;</span><span class="p">,</span> <span class="s1">&#39;help&#39;</span><span class="p">:</span> <span class="s1">&#39;SSH proxy command&#39;</span><span class="p">,</span> <span class="s1">&#39;non_interactive_default&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}),</span>  <span class="c1"># Managed &#39;manually&#39; in connect</span>
        <span class="p">(</span><span class="s1">&#39;compress&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;switch&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="s1">&#39;prompt&#39;</span><span class="p">:</span> <span class="s1">&#39;Compress file transfers&#39;</span><span class="p">,</span> <span class="s1">&#39;help&#39;</span><span class="p">:</span> <span class="s1">&#39;switch file transfer compression on / off&#39;</span><span class="p">,</span> <span class="s1">&#39;non_interactive_default&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}),</span>
        <span class="p">(</span><span class="s1">&#39;gss_auth&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="s1">&#39;prompt&#39;</span><span class="p">:</span> <span class="s1">&#39;GSS auth&#39;</span><span class="p">,</span> <span class="s1">&#39;help&#39;</span><span class="p">:</span> <span class="s1">&#39;GSS auth for kerberos&#39;</span><span class="p">,</span> <span class="s1">&#39;non_interactive_default&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}),</span>
        <span class="p">(</span><span class="s1">&#39;gss_kex&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="s1">&#39;prompt&#39;</span><span class="p">:</span> <span class="s1">&#39;GSS kex&#39;</span><span class="p">,</span> <span class="s1">&#39;help&#39;</span><span class="p">:</span> <span class="s1">&#39;GSS kex for kerberos&#39;</span><span class="p">,</span> <span class="s1">&#39;non_interactive_default&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}),</span>
        <span class="p">(</span><span class="s1">&#39;gss_deleg_creds&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="s1">&#39;prompt&#39;</span><span class="p">:</span> <span class="s1">&#39;GSS deleg_creds&#39;</span><span class="p">,</span> <span class="s1">&#39;help&#39;</span><span class="p">:</span> <span class="s1">&#39;GSS deleg_creds for kerberos&#39;</span><span class="p">,</span> <span class="s1">&#39;non_interactive_default&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}),</span>
        <span class="p">(</span><span class="s1">&#39;gss_host&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;prompt&#39;</span><span class="p">:</span> <span class="s1">&#39;GSS host&#39;</span><span class="p">,</span> <span class="s1">&#39;help&#39;</span><span class="p">:</span> <span class="s1">&#39;GSS host for kerberos&#39;</span><span class="p">,</span> <span class="s1">&#39;non_interactive_default&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}),</span>
        <span class="c1"># for Kerberos support through python-gssapi</span>
    <span class="p">]</span>

    <span class="n">_valid_connect_params</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">_valid_connect_options</span><span class="p">]</span>

    <span class="c1"># Valid parameters for the ssh transport</span>
    <span class="c1"># For each param, a class method with name</span>
    <span class="c1"># _convert_PARAMNAME_fromstring</span>
    <span class="c1"># should be defined, that returns the value converted from a string to</span>
    <span class="c1"># a correct type, or raise a ValidationError</span>
    <span class="c1">#</span>
    <span class="c1"># moreover, if you want to help in the default configuration, you can</span>
    <span class="c1"># define a _get_PARAMNAME_suggestion_string</span>
    <span class="c1"># to return a suggestion; it must accept only one parameter, being a Computer</span>
    <span class="c1"># instance</span>
    <span class="n">_valid_auth_options</span> <span class="o">=</span> <span class="n">_valid_connect_options</span> <span class="o">+</span> <span class="p">[</span>
        <span class="p">(</span><span class="s1">&#39;load_system_host_keys&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;switch&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="s1">&#39;prompt&#39;</span><span class="p">:</span> <span class="s1">&#39;Load system host keys&#39;</span><span class="p">,</span> <span class="s1">&#39;help&#39;</span><span class="p">:</span> <span class="s1">&#39;switch loading system host keys on / off&#39;</span><span class="p">,</span> <span class="s1">&#39;non_interactive_default&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}),</span>
        <span class="p">(</span><span class="s1">&#39;key_policy&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="n">click</span><span class="o">.</span><span class="n">Choice</span><span class="p">([</span><span class="s1">&#39;RejectPolicy&#39;</span><span class="p">,</span> <span class="s1">&#39;WarningPolicy&#39;</span><span class="p">,</span> <span class="s1">&#39;AutoAddPolicy&#39;</span><span class="p">]),</span> <span class="s1">&#39;prompt&#39;</span><span class="p">:</span> <span class="s1">&#39;Key policy&#39;</span><span class="p">,</span> <span class="s1">&#39;help&#39;</span><span class="p">:</span> <span class="s1">&#39;SSH key policy&#39;</span><span class="p">,</span> <span class="s1">&#39;non_interactive_default&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">})</span>
    <span class="p">]</span>

    <span class="c1"># I set the (default) value here to 5 secs between consecutive SSH checks.</span>
    <span class="c1"># This should be incremented to 30, probably.</span>
    <span class="n">_DEFAULT_SAFE_OPEN_INTERVAL</span> <span class="o">=</span> <span class="mi">5</span>

<div class="viewcode-block" id="SshTransport._get_username_suggestion_string"><a class="viewcode-back" href="../../../../apidoc/aiida.transports.plugins.html#aiida.transports.plugins.ssh.SshTransport._get_username_suggestion_string">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_get_username_suggestion_string</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">computer</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a suggestion for the specific field.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">getpass</span>

        <span class="n">config</span> <span class="o">=</span> <span class="n">parse_sshconfig</span><span class="p">(</span><span class="n">computer</span><span class="o">.</span><span class="n">hostname</span><span class="p">)</span>
        <span class="c1"># Either the configured user in the .ssh/config, or the current username</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;user&#39;</span><span class="p">,</span> <span class="n">getpass</span><span class="o">.</span><span class="n">getuser</span><span class="p">()))</span></div>

<div class="viewcode-block" id="SshTransport._get_port_suggestion_string"><a class="viewcode-back" href="../../../../apidoc/aiida.transports.plugins.html#aiida.transports.plugins.ssh.SshTransport._get_port_suggestion_string">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_get_port_suggestion_string</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">computer</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a suggestion for the specific field.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">config</span> <span class="o">=</span> <span class="n">parse_sshconfig</span><span class="p">(</span><span class="n">computer</span><span class="o">.</span><span class="n">hostname</span><span class="p">)</span>
        <span class="c1"># Either the configured user in the .ssh/config, or the default SSH port</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;port&#39;</span><span class="p">,</span> <span class="mi">22</span><span class="p">))</span></div>

<div class="viewcode-block" id="SshTransport._get_key_filename_suggestion_string"><a class="viewcode-back" href="../../../../apidoc/aiida.transports.plugins.html#aiida.transports.plugins.ssh.SshTransport._get_key_filename_suggestion_string">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_get_key_filename_suggestion_string</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">computer</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a suggestion for the specific field.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">config</span> <span class="o">=</span> <span class="n">parse_sshconfig</span><span class="p">(</span><span class="n">computer</span><span class="o">.</span><span class="n">hostname</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">identities</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;identityfile&#39;</span><span class="p">]</span>
            <span class="c1"># In paramiko &gt; 0.10, identity file is a list of strings.</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">identities</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
                <span class="n">identity</span> <span class="o">=</span> <span class="n">identities</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">identities</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">identities</span><span class="p">:</span>
                    <span class="c1"># An empty list should not be provided; to be sure,</span>
                    <span class="c1"># anyway, behave as if no identityfile were defined</span>
                    <span class="k">raise</span> <span class="ne">KeyError</span>
                <span class="c1"># By default we suggest only the first one</span>
                <span class="n">identity</span> <span class="o">=</span> <span class="n">identities</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># If the parser provides an unknown type, just skip to</span>
                <span class="c1"># the &#39;except KeyError&#39; section, as if no identityfile</span>
                <span class="c1"># were provided (hopefully, this should never happen)</span>
                <span class="k">raise</span> <span class="ne">KeyError</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="c1"># No IdentityFile defined: return an empty string</span>
            <span class="k">return</span> <span class="s2">&quot;&quot;</span>

        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="n">identity</span><span class="p">)</span></div>

<div class="viewcode-block" id="SshTransport._get_timeout_suggestion_string"><a class="viewcode-back" href="../../../../apidoc/aiida.transports.plugins.html#aiida.transports.plugins.ssh.SshTransport._get_timeout_suggestion_string">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_get_timeout_suggestion_string</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">computer</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a suggestion for the specific field.</span>

<span class="sd">        Provide 60s as a default timeout for connections.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">config</span> <span class="o">=</span> <span class="n">parse_sshconfig</span><span class="p">(</span><span class="n">computer</span><span class="o">.</span><span class="n">hostname</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;connecttimeout&#39;</span><span class="p">,</span> <span class="s2">&quot;60&quot;</span><span class="p">))</span></div>

<div class="viewcode-block" id="SshTransport._get_allow_agent_suggestion_string"><a class="viewcode-back" href="../../../../apidoc/aiida.transports.plugins.html#aiida.transports.plugins.ssh.SshTransport._get_allow_agent_suggestion_string">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_get_allow_agent_suggestion_string</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">computer</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a suggestion for the specific field.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">config</span> <span class="o">=</span> <span class="n">parse_sshconfig</span><span class="p">(</span><span class="n">computer</span><span class="o">.</span><span class="n">hostname</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">convert_to_bool</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;allow_agent&#39;</span><span class="p">,</span> <span class="s2">&quot;no&quot;</span><span class="p">)))</span></div>

<div class="viewcode-block" id="SshTransport._get_look_for_keys_suggestion_string"><a class="viewcode-back" href="../../../../apidoc/aiida.transports.plugins.html#aiida.transports.plugins.ssh.SshTransport._get_look_for_keys_suggestion_string">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_get_look_for_keys_suggestion_string</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">computer</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a suggestion for the specific field.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">config</span> <span class="o">=</span> <span class="n">parse_sshconfig</span><span class="p">(</span><span class="n">computer</span><span class="o">.</span><span class="n">hostname</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">convert_to_bool</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;look_for_keys&#39;</span><span class="p">,</span> <span class="s2">&quot;no&quot;</span><span class="p">)))</span></div>

<div class="viewcode-block" id="SshTransport._get_proxy_command_suggestion_string"><a class="viewcode-back" href="../../../../apidoc/aiida.transports.plugins.html#aiida.transports.plugins.ssh.SshTransport._get_proxy_command_suggestion_string">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_get_proxy_command_suggestion_string</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">computer</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a suggestion for the specific field.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">config</span> <span class="o">=</span> <span class="n">parse_sshconfig</span><span class="p">(</span><span class="n">computer</span><span class="o">.</span><span class="n">hostname</span><span class="p">)</span>
        <span class="c1"># Either the configured user in the .ssh/config, or the default SSH port</span>
        <span class="n">raw_string</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;proxycommand&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">))</span>
        <span class="c1"># Note: %h and %p get already automatically substituted with</span>
        <span class="c1"># hostname and port by the config parser!</span>

        <span class="n">pieces</span> <span class="o">=</span> <span class="n">raw_string</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
        <span class="n">new_pieces</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">piece</span> <span class="ow">in</span> <span class="n">pieces</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;&gt;&#39;</span> <span class="ow">in</span> <span class="n">piece</span><span class="p">:</span>
                <span class="c1"># If there is a piece with &gt; to readdress stderr or stdout,</span>
                <span class="c1"># skip from here on (anything else can only be readdressing)</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_pieces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">piece</span><span class="p">)</span>
        <span class="k">return</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">new_pieces</span><span class="p">)</span></div>

<div class="viewcode-block" id="SshTransport._get_compress_suggestion_string"><a class="viewcode-back" href="../../../../apidoc/aiida.transports.plugins.html#aiida.transports.plugins.ssh.SshTransport._get_compress_suggestion_string">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_get_compress_suggestion_string</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">computer</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a suggestion for the specific field.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;True&quot;</span></div>

<div class="viewcode-block" id="SshTransport._get_load_system_host_keys_suggestion_string"><a class="viewcode-back" href="../../../../apidoc/aiida.transports.plugins.html#aiida.transports.plugins.ssh.SshTransport._get_load_system_host_keys_suggestion_string">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_get_load_system_host_keys_suggestion_string</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">computer</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a suggestion for the specific field.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;True&quot;</span></div>

<div class="viewcode-block" id="SshTransport._get_key_policy_suggestion_string"><a class="viewcode-back" href="../../../../apidoc/aiida.transports.plugins.html#aiida.transports.plugins.ssh.SshTransport._get_key_policy_suggestion_string">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_get_key_policy_suggestion_string</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">computer</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a suggestion for the specific field.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;RejectPolicy&quot;</span></div>

<div class="viewcode-block" id="SshTransport._get_gss_auth_suggestion_string"><a class="viewcode-back" href="../../../../apidoc/aiida.transports.plugins.html#aiida.transports.plugins.ssh.SshTransport._get_gss_auth_suggestion_string">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_get_gss_auth_suggestion_string</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">computer</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a suggestion for the specific field.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">config</span> <span class="o">=</span> <span class="n">parse_sshconfig</span><span class="p">(</span><span class="n">computer</span><span class="o">.</span><span class="n">hostname</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">convert_to_bool</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;gssapiauthentication&#39;</span><span class="p">,</span> <span class="s2">&quot;no&quot;</span><span class="p">)))</span></div>

<div class="viewcode-block" id="SshTransport._get_gss_kex_suggestion_string"><a class="viewcode-back" href="../../../../apidoc/aiida.transports.plugins.html#aiida.transports.plugins.ssh.SshTransport._get_gss_kex_suggestion_string">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_get_gss_kex_suggestion_string</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">computer</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a suggestion for the specific field.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">config</span> <span class="o">=</span> <span class="n">parse_sshconfig</span><span class="p">(</span><span class="n">computer</span><span class="o">.</span><span class="n">hostname</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">convert_to_bool</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;gssapikeyexchange&#39;</span><span class="p">,</span> <span class="s2">&quot;no&quot;</span><span class="p">)))</span></div>

<div class="viewcode-block" id="SshTransport._get_gss_deleg_creds_suggestion_string"><a class="viewcode-back" href="../../../../apidoc/aiida.transports.plugins.html#aiida.transports.plugins.ssh.SshTransport._get_gss_deleg_creds_suggestion_string">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_get_gss_deleg_creds_suggestion_string</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">computer</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a suggestion for the specific field.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">config</span> <span class="o">=</span> <span class="n">parse_sshconfig</span><span class="p">(</span><span class="n">computer</span><span class="o">.</span><span class="n">hostname</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">convert_to_bool</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;gssapidelegatecredentials&#39;</span><span class="p">,</span> <span class="s2">&quot;no&quot;</span><span class="p">)))</span></div>

<div class="viewcode-block" id="SshTransport._get_gss_host_suggestion_string"><a class="viewcode-back" href="../../../../apidoc/aiida.transports.plugins.html#aiida.transports.plugins.ssh.SshTransport._get_gss_host_suggestion_string">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_get_gss_host_suggestion_string</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">computer</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a suggestion for the specific field.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">config</span> <span class="o">=</span> <span class="n">parse_sshconfig</span><span class="p">(</span><span class="n">computer</span><span class="o">.</span><span class="n">hostname</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;gssapihostname&#39;</span><span class="p">,</span> <span class="n">computer</span><span class="o">.</span><span class="n">hostname</span><span class="p">))</span></div>

<div class="viewcode-block" id="SshTransport._get_safe_interval_suggestion_string"><a class="viewcode-back" href="../../../../apidoc/aiida.transports.plugins.html#aiida.transports.plugins.ssh.SshTransport._get_safe_interval_suggestion_string">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_get_safe_interval_suggestion_string</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">computer</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_DEFAULT_SAFE_OPEN_INTERVAL</span></div>

<div class="viewcode-block" id="SshTransport.__init__"><a class="viewcode-back" href="../../../../apidoc/aiida.transports.plugins.html#aiida.transports.plugins.ssh.SshTransport.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">machine</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the SshTransport class.</span>

<span class="sd">        :param machine: the machine to connect to</span>
<span class="sd">        :param load_system_host_keys: (optional, default False)</span>
<span class="sd">           if False, do not load the system host keys</span>
<span class="sd">        :param key_policy: (optional, default = paramiko.RejectPolicy())</span>
<span class="sd">           the policy to use for unknown keys</span>

<span class="sd">        Other parameters valid for the ssh connect function (see the</span>
<span class="sd">        self._valid_connect_params list) are passed to the connect</span>
<span class="sd">        function (as port, username, password, ...); taken from the</span>
<span class="sd">        accepted paramiko.SSHClient.connect() params.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">paramiko</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SshTransport</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_is_open</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sftp</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_proxy</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_machine</span> <span class="o">=</span> <span class="n">machine</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_client</span> <span class="o">=</span> <span class="n">paramiko</span><span class="o">.</span><span class="n">SSHClient</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_load_system_host_keys</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;load_system_host_keys&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_system_host_keys</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_client</span><span class="o">.</span><span class="n">load_system_host_keys</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_safe_open_interval</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;safe_interval&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_DEFAULT_SAFE_OPEN_INTERVAL</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_missing_key_policy</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;key_policy&#39;</span><span class="p">,</span> <span class="s1">&#39;RejectPolicy&#39;</span><span class="p">)</span>  <span class="c1"># This is paramiko default</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_missing_key_policy</span> <span class="o">==</span> <span class="s1">&#39;RejectPolicy&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_client</span><span class="o">.</span><span class="n">set_missing_host_key_policy</span><span class="p">(</span><span class="n">paramiko</span><span class="o">.</span><span class="n">RejectPolicy</span><span class="p">())</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_missing_key_policy</span> <span class="o">==</span> <span class="s1">&#39;WarningPolicy&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_client</span><span class="o">.</span><span class="n">set_missing_host_key_policy</span><span class="p">(</span><span class="n">paramiko</span><span class="o">.</span><span class="n">WarningPolicy</span><span class="p">())</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_missing_key_policy</span> <span class="o">==</span> <span class="s1">&#39;AutoAddPolicy&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_client</span><span class="o">.</span><span class="n">set_missing_host_key_policy</span><span class="p">(</span><span class="n">paramiko</span><span class="o">.</span><span class="n">AutoAddPolicy</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown value of the key policy, allowed values &quot;</span>
                             <span class="s2">&quot;are: RejectPolicy, WarningPolicy, AutoAddPolicy&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_connect_args</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_valid_connect_params</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_connect_args</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">pass</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The following parameters were not accepted by &quot;</span>
                             <span class="s2">&quot;the transport: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">)))</span></div>

<div class="viewcode-block" id="SshTransport.open"><a class="viewcode-back" href="../../../../developer_guide/core/transport.html#aiida.transports.plugins.ssh.SshTransport.open">[docs]</a>    <span class="k">def</span> <span class="nf">open</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Open a SSHClient to the machine possibly using the parameters given</span>
<span class="sd">        in the __init__.</span>

<span class="sd">        Also opens a sftp channel, ready to be used.</span>
<span class="sd">        The current working directory is set explicitly, so it is not None.</span>

<span class="sd">        :raise aiida.common.InvalidOperation: if the channel is already open</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">aiida.common.exceptions</span> <span class="k">import</span> <span class="n">InvalidOperation</span>
        <span class="kn">from</span> <span class="nn">aiida.transports.util</span> <span class="k">import</span> <span class="n">_DetachedProxyCommand</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_open</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidOperation</span><span class="p">(</span><span class="s2">&quot;Cannot open the transport twice&quot;</span><span class="p">)</span>
        <span class="c1"># Open a SSHClient</span>
        <span class="n">connection_arguments</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connect_args</span>
        <span class="n">proxystring</span> <span class="o">=</span> <span class="n">connection_arguments</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;proxy_command&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">proxystring</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_proxy</span> <span class="o">=</span> <span class="n">_DetachedProxyCommand</span><span class="p">(</span><span class="n">proxystring</span><span class="p">)</span>
            <span class="n">connection_arguments</span><span class="p">[</span><span class="s1">&#39;sock&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_proxy</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_client</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_machine</span><span class="p">,</span> <span class="o">**</span><span class="n">connection_arguments</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Error connecting through SSH: [</span><span class="si">{}</span><span class="s2">] </span><span class="si">{}</span><span class="s2">, &quot;</span>
                              <span class="s2">&quot;connect_args were: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">exc</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">exc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connect_args</span><span class="p">))</span>
            <span class="k">raise</span>

        <span class="c1"># Open also a SFTPClient</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sftp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_client</span><span class="o">.</span><span class="n">open_sftp</span><span class="p">()</span>
        <span class="c1"># Set the current directory to a explicit path, and not to None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sftp</span><span class="o">.</span><span class="n">chdir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sftp</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_is_open</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="SshTransport.close"><a class="viewcode-back" href="../../../../developer_guide/core/transport.html#aiida.transports.plugins.ssh.SshTransport.close">[docs]</a>    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Close the SFTP channel, and the SSHClient.</span>

<span class="sd">        :todo: correctly manage exceptions</span>

<span class="sd">        :raise aiida.common.InvalidOperation: if the channel is already open</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">aiida.common.exceptions</span> <span class="k">import</span> <span class="n">InvalidOperation</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_open</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidOperation</span><span class="p">(</span><span class="s2">&quot;Cannot close the transport: it is already closed&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_sftp</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_client</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_open</span> <span class="o">=</span> <span class="kc">False</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sshclient</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_open</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TransportInternalError</span><span class="p">(</span><span class="s2">&quot;Error, ssh method called for SshTransport without opening the channel first&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_client</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sftp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_open</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TransportInternalError</span><span class="p">(</span><span class="s2">&quot;Error, sftp method called for SshTransport without opening the channel first&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sftp</span>

<div class="viewcode-block" id="SshTransport.__str__"><a class="viewcode-back" href="../../../../apidoc/aiida.transports.plugins.html#aiida.transports.plugins.ssh.SshTransport.__str__">[docs]</a>    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a useful string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">conn_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_machine</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">conn_info</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">@</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_connect_args</span><span class="p">[</span><span class="s1">&#39;username&#39;</span><span class="p">],</span> <span class="n">conn_info</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="c1"># No username explicitly defined: ignore</span>
            <span class="k">pass</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">conn_info</span> <span class="o">+=</span> <span class="s1">&#39;:</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_connect_args</span><span class="p">[</span><span class="s1">&#39;port&#39;</span><span class="p">])</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="c1"># No port explicitly defined: ignore</span>
            <span class="k">pass</span>

        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> [</span><span class="si">{}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;OPEN&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_open</span> <span class="k">else</span> <span class="s2">&quot;CLOSED&quot;</span><span class="p">,</span> <span class="n">conn_info</span><span class="p">)</span></div>

<div class="viewcode-block" id="SshTransport.chdir"><a class="viewcode-back" href="../../../../developer_guide/core/transport.html#aiida.transports.plugins.ssh.SshTransport.chdir">[docs]</a>    <span class="k">def</span> <span class="nf">chdir</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Change directory of the SFTP session. Emulated internally by paramiko.</span>

<span class="sd">        Differently from paramiko, if you pass None to chdir, nothing</span>
<span class="sd">        happens and the cwd is unchanged.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">paramiko.sftp</span> <span class="k">import</span> <span class="n">SFTPError</span>
        <span class="n">old_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sftp</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sftp</span><span class="o">.</span><span class="n">chdir</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">SFTPError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="c1"># e.args[0] is an error code. For instance,</span>
                <span class="c1"># 20 is &#39;the object is not a directory&#39;</span>
                <span class="c1"># Here I just re-raise the message as IOError</span>
                <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># Paramiko already checked that path is a folder, otherwise I would</span>
        <span class="c1"># have gotten an exception. Now, I want to check that I have read</span>
        <span class="c1"># permissions in this folder (nothing is said on write permissions,</span>
        <span class="c1"># though).</span>
        <span class="c1"># Otherwise, if I do _exec_command_internal, that as a first operation</span>
        <span class="c1"># cd&#39;s in a folder, I get a wrong retval, that is an unwanted behavior.</span>
        <span class="c1">#</span>
        <span class="c1"># Note: I don&#39;t store the result of the function; if I have no</span>
        <span class="c1"># read permissions, this will raise an exception.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sftp</span><span class="o">.</span><span class="n">stat</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">IOError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;Permission denied&#39;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">exc</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">chdir</span><span class="p">(</span><span class="n">old_path</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">exc</span><span class="p">))</span></div>

<div class="viewcode-block" id="SshTransport.normalize"><a class="viewcode-back" href="../../../../developer_guide/core/transport.html#aiida.transports.plugins.ssh.SshTransport.normalize">[docs]</a>    <span class="k">def</span> <span class="nf">normalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the normalized path (removing double slashes, etc...)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sftp</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">path</span><span class="p">)</span></div>

<div class="viewcode-block" id="SshTransport.getcwd"><a class="viewcode-back" href="../../../../developer_guide/core/transport.html#aiida.transports.plugins.ssh.SshTransport.getcwd">[docs]</a>    <span class="k">def</span> <span class="nf">getcwd</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the current working directory for this SFTP session, as</span>
<span class="sd">        emulated by paramiko. If no directory has been set with chdir,</span>
<span class="sd">        this method will return None. But in __enter__ this is set explicitly,</span>
<span class="sd">        so this should never happen within this class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sftp</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span></div>

<div class="viewcode-block" id="SshTransport.makedirs"><a class="viewcode-back" href="../../../../developer_guide/core/transport.html#aiida.transports.plugins.ssh.SshTransport.makedirs">[docs]</a>    <span class="k">def</span> <span class="nf">makedirs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">ignore_existing</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Super-mkdir; create a leaf directory and all intermediate ones.</span>
<span class="sd">        Works like mkdir, except that any intermediate path segment (not</span>
<span class="sd">        just the rightmost) will be created if it does not exist.</span>

<span class="sd">        NOTE: since os.path.split uses the separators as the host system</span>
<span class="sd">        (that could be windows), I assume the remote computer is Linux-based</span>
<span class="sd">        and use &#39;/&#39; as separators!</span>

<span class="sd">        :param path: directory to create (string)</span>
<span class="sd">        :param ignore_existing: if set to true, it doesn&#39;t give any error</span>
<span class="sd">            if the leaf directory does already exist (bool)</span>

<span class="sd">        :raise OSError: If the directory already exists.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check to avoid creation of empty dirs</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">normpath</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">path</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">):</span>
            <span class="n">to_create</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">this_dir</span> <span class="o">=</span> <span class="s1">&#39;/&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">to_create</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
            <span class="n">this_dir</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

        <span class="k">for</span> <span class="n">count</span><span class="p">,</span> <span class="n">element</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">to_create</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">this_dir</span> <span class="o">+=</span> <span class="s1">&#39;/&#39;</span>
            <span class="n">this_dir</span> <span class="o">+=</span> <span class="n">element</span>
            <span class="k">if</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_create</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">this_dir</span><span class="p">)</span> <span class="ow">and</span> <span class="n">ignore_existing</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="k">if</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_create</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">this_dir</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">ignore_existing</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">this_dir</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">this_dir</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">this_dir</span><span class="p">)</span></div>

<div class="viewcode-block" id="SshTransport.mkdir"><a class="viewcode-back" href="../../../../developer_guide/core/transport.html#aiida.transports.plugins.ssh.SshTransport.mkdir">[docs]</a>    <span class="k">def</span> <span class="nf">mkdir</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">ignore_existing</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a folder (directory) named path.</span>

<span class="sd">        :param path: name of the folder to create</span>
<span class="sd">        :param ignore_existing: if True, does not give any error if the directory</span>
<span class="sd">                  already exists</span>

<span class="sd">        :raise OSError: If the directory already exists.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ignore_existing</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
            <span class="k">return</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sftp</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">IOError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isabs</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="s2">&quot;Error during mkdir of &#39;</span><span class="si">{}</span><span class="s2">&#39;, &quot;</span>
                              <span class="s2">&quot;maybe you don&#39;t have the permissions to do it, &quot;</span>
                              <span class="s2">&quot;or the directory already exists? (</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">exc</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="s2">&quot;Error during mkdir of &#39;</span><span class="si">{}</span><span class="s2">&#39; from folder &#39;</span><span class="si">{}</span><span class="s2">&#39;, &quot;</span>
                              <span class="s2">&quot;maybe you don&#39;t have the permissions to do it, &quot;</span>
                              <span class="s2">&quot;or the directory already exists? (</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">getcwd</span><span class="p">(),</span> <span class="n">exc</span><span class="p">))</span></div>

    <span class="c1"># TODO : implement rmtree</span>
<div class="viewcode-block" id="SshTransport.rmtree"><a class="viewcode-back" href="../../../../developer_guide/core/transport.html#aiida.transports.plugins.ssh.SshTransport.rmtree">[docs]</a>    <span class="k">def</span> <span class="nf">rmtree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove a file or a directory at path, recursively</span>
<span class="sd">        Flags used: -r: recursive copy; -f: force, makes the command non interactive;</span>

<span class="sd">        :param path: remote path to delete</span>

<span class="sd">        :raise IOError: if the rm execution failed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Assuming linux rm command!</span>

        <span class="c1"># TODO : do we need to avoid the aliases when calling rm_exe=&#39;rm&#39;? Call directly /bin/rm?</span>

        <span class="n">rm_exe</span> <span class="o">=</span> <span class="s1">&#39;rm&#39;</span>
        <span class="n">rm_flags</span> <span class="o">=</span> <span class="s1">&#39;-r -f&#39;</span>
        <span class="c1"># if in input I give an invalid object raise ValueError</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">path</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input to rmtree() must be a non empty string. &#39;</span> <span class="o">+</span> <span class="s1">&#39;Found instead </span><span class="si">%s</span><span class="s1"> as path&#39;</span> <span class="o">%</span> <span class="n">path</span><span class="p">)</span>

        <span class="n">command</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rm_exe</span><span class="p">,</span> <span class="n">rm_flags</span><span class="p">,</span> <span class="n">escape_for_bash</span><span class="p">(</span><span class="n">path</span><span class="p">))</span>

        <span class="n">retval</span><span class="p">,</span> <span class="n">stdout</span><span class="p">,</span> <span class="n">stderr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exec_command_wait</span><span class="p">(</span><span class="n">command</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">retval</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">stderr</span><span class="o">.</span><span class="n">strip</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;There was nonempty stderr in the rm command: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">stderr</span><span class="p">))</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Problem executing rm. Exit code: </span><span class="si">{}</span><span class="s2">, stdout: &#39;</span><span class="si">{}</span><span class="s2">&#39;, &quot;</span>
                              <span class="s2">&quot;stderr: &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="n">stdout</span><span class="p">,</span> <span class="n">stderr</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;Error while executing rm. Exit code: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">retval</span><span class="p">))</span></div>

<div class="viewcode-block" id="SshTransport.rmdir"><a class="viewcode-back" href="../../../../developer_guide/core/transport.html#aiida.transports.plugins.ssh.SshTransport.rmdir">[docs]</a>    <span class="k">def</span> <span class="nf">rmdir</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove the folder named &#39;path&#39; if empty.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sftp</span><span class="o">.</span><span class="n">rmdir</span><span class="p">(</span><span class="n">path</span><span class="p">)</span></div>

<div class="viewcode-block" id="SshTransport.isdir"><a class="viewcode-back" href="../../../../developer_guide/core/transport.html#aiida.transports.plugins.ssh.SshTransport.isdir">[docs]</a>    <span class="k">def</span> <span class="nf">isdir</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if the given path is a directory, False otherwise.</span>
<span class="sd">        Return False also if the path does not exist.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Return False on empty string (paramiko would map this to the local</span>
        <span class="c1"># folder instead)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">path</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">S_ISDIR</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sftp</span><span class="o">.</span><span class="n">stat</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">.</span><span class="n">st_mode</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">IOError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="s2">&quot;errno&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># errno=2 means path does not exist: I return False</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span>  <span class="c1"># Typically if I don&#39;t have permissions (errno=13)</span></div>

<div class="viewcode-block" id="SshTransport.chmod"><a class="viewcode-back" href="../../../../developer_guide/core/transport.html#aiida.transports.plugins.ssh.SshTransport.chmod">[docs]</a>    <span class="k">def</span> <span class="nf">chmod</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">mode</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Change permissions to path</span>

<span class="sd">        :param path: path to file</span>
<span class="sd">        :param mode: new permission bits (integer)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">path</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;Input path is an empty argument.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sftp</span><span class="o">.</span><span class="n">chmod</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span></div>

<div class="viewcode-block" id="SshTransport._os_path_split_asunder"><a class="viewcode-back" href="../../../../apidoc/aiida.transports.plugins.html#aiida.transports.plugins.ssh.SshTransport._os_path_split_asunder">[docs]</a>    <span class="k">def</span> <span class="nf">_os_path_split_asunder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Used by makedirs. Takes path (a str)</span>
<span class="sd">        and returns a list deconcatenating the path</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">parts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">newpath</span><span class="p">,</span> <span class="n">tail</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">newpath</span> <span class="o">==</span> <span class="n">path</span><span class="p">:</span>
                <span class="k">assert</span> <span class="ow">not</span> <span class="n">tail</span>
                <span class="k">if</span> <span class="n">path</span><span class="p">:</span> <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
                <span class="k">break</span>
            <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tail</span><span class="p">)</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">newpath</span>
        <span class="n">parts</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">parts</span></div>

<div class="viewcode-block" id="SshTransport.put"><a class="viewcode-back" href="../../../../developer_guide/core/transport.html#aiida.transports.plugins.ssh.SshTransport.put">[docs]</a>    <span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">localpath</span><span class="p">,</span> <span class="n">remotepath</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dereference</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ignore_nonexisting</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Put a file or a folder from local to remote.</span>
<span class="sd">        Redirects to putfile or puttree.</span>

<span class="sd">        :param localpath: an (absolute) local path</span>
<span class="sd">        :param remotepath: a remote path</span>
<span class="sd">        :param dereference: follow symbolic links (boolean).</span>
<span class="sd">            Default = True (default behaviour in paramiko). False is not implemented.</span>
<span class="sd">        :param  overwrite: if True overwrites files and folders (boolean).</span>
<span class="sd">            Default = False.</span>

<span class="sd">        :raise ValueError: if local path is invalid</span>
<span class="sd">        :raise OSError: if the localpath does not exist</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: flag confirm exists since v1.7.7. What is the paramiko</span>
        <span class="c1"># version supported?</span>

        <span class="c1"># TODO : add dereference</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">dereference</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isabs</span><span class="p">(</span><span class="n">localpath</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The localpath must be an absolute path&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_magic</span><span class="p">(</span><span class="n">localpath</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_magic</span><span class="p">(</span><span class="n">remotepath</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Pathname patterns are not allowed in the destination&quot;</span><span class="p">)</span>

            <span class="c1"># use the imported glob to analyze the path locally</span>
            <span class="n">to_copy_list</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">localpath</span><span class="p">)</span>

            <span class="n">rename_remote</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_copy_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># I can&#39;t scp more than one file on a single file</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">remotepath</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="s2">&quot;Remote destination is not a directory&quot;</span><span class="p">)</span>
                <span class="c1"># I can&#39;t scp more than one file in a non existing directory</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">path_exists</span><span class="p">(</span><span class="n">remotepath</span><span class="p">):</span>  <span class="c1"># questo dovrebbe valere solo per file</span>
                    <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="s2">&quot;Remote directory does not exist&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># the remote path is a directory</span>
                    <span class="n">rename_remote</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">to_copy_list</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">rename_remote</span><span class="p">:</span>  <span class="c1"># copying more than one file in one directory</span>
                        <span class="c1"># here is the case isfile and more than one file</span>
                        <span class="n">r</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">remotepath</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">s</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">putfile</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="n">dereference</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">)</span>

                    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">remotepath</span><span class="p">):</span>  <span class="c1"># one file to copy in &#39;.&#39;</span>
                        <span class="n">r</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">remotepath</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">s</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">putfile</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="n">dereference</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>  <span class="c1"># one file to copy on one file</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">putfile</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">remotepath</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="n">dereference</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">puttree</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">remotepath</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="n">dereference</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">localpath</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">puttree</span><span class="p">(</span><span class="n">localpath</span><span class="p">,</span> <span class="n">remotepath</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="n">dereference</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">localpath</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">remotepath</span><span class="p">):</span>
                    <span class="n">r</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">remotepath</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">localpath</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">putfile</span><span class="p">(</span><span class="n">localpath</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="n">dereference</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">putfile</span><span class="p">(</span><span class="n">localpath</span><span class="p">,</span> <span class="n">remotepath</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="n">dereference</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ignore_nonexisting</span><span class="p">:</span>
                    <span class="k">pass</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="s2">&quot;The local path </span><span class="si">{}</span><span class="s2"> does not exist&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">localpath</span><span class="p">))</span></div>

<div class="viewcode-block" id="SshTransport.putfile"><a class="viewcode-back" href="../../../../developer_guide/core/transport.html#aiida.transports.plugins.ssh.SshTransport.putfile">[docs]</a>    <span class="k">def</span> <span class="nf">putfile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">localpath</span><span class="p">,</span> <span class="n">remotepath</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dereference</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Put a file from local to remote.</span>

<span class="sd">        :param localpath: an (absolute) local path</span>
<span class="sd">        :param remotepath: a remote path</span>
<span class="sd">        :param overwrite: if True overwrites files and folders (boolean).</span>
<span class="sd">            Default = True.</span>

<span class="sd">        :raise ValueError: if local path is invalid</span>
<span class="sd">        :raise OSError: if the localpath does not exist,</span>
<span class="sd">                    or unintentionally overwriting</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO : add dereference</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">dereference</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>

        <span class="c1"># TODO : check what happens if I give in input a directory</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isabs</span><span class="p">(</span><span class="n">localpath</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The localpath must be an absolute path&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">remotepath</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">overwrite</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="s1">&#39;Destination already exists: not overwriting it&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sftp</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">localpath</span><span class="p">,</span> <span class="n">remotepath</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">)</span></div>

<div class="viewcode-block" id="SshTransport.puttree"><a class="viewcode-back" href="../../../../developer_guide/core/transport.html#aiida.transports.plugins.ssh.SshTransport.puttree">[docs]</a>    <span class="k">def</span> <span class="nf">puttree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">localpath</span><span class="p">,</span> <span class="n">remotepath</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dereference</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>  <span class="c1"># by default overwrite</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Put a folder recursively from local to remote.</span>

<span class="sd">        :param localpath: an (absolute) local path</span>
<span class="sd">        :param remotepath: a remote path</span>
<span class="sd">        :param dereference: follow symbolic links (boolean)</span>
<span class="sd">            Default = True (default behaviour in paramiko). False is not implemented.</span>
<span class="sd">        :param overwrite: if True overwrites files and folders (boolean).</span>
<span class="sd">            Default = True</span>

<span class="sd">        :raise ValueError: if local path is invalid</span>
<span class="sd">        :raise OSError: if the localpath does not exist, or trying to overwrite</span>
<span class="sd">        :raise IOError: if remotepath is invalid</span>

<span class="sd">        .. note:: setting dereference equal to True could cause infinite loops.</span>
<span class="sd">              see os.walk() documentation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO : add dereference</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">dereference</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isabs</span><span class="p">(</span><span class="n">localpath</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The localpath must be an absolute path&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">localpath</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="s2">&quot;The localpath does not exists&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">localpath</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input localpath is not a folder: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">localpath</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">remotepath</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;remotepath must be a non empty string&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">path_exists</span><span class="p">(</span><span class="n">remotepath</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">overwrite</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t overwrite existing files&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">remotepath</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="s2">&quot;Cannot copy a directory into a file&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">remotepath</span><span class="p">):</span>  <span class="c1"># in this case copy things in the remotepath directly</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">remotepath</span><span class="p">)</span>  <span class="c1"># and make a directory at its place</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># remotepath exists already: copy the folder inside of it!</span>
            <span class="n">remotepath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">remotepath</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">localpath</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">remotepath</span><span class="p">)</span>  <span class="c1"># create a nested folder</span>

        <span class="c1"># TODO, NOTE: we are not using &#39;onerror&#39; because we checked above that</span>
        <span class="c1"># the folder exists, but it would be better to use it</span>
        <span class="k">for</span> <span class="n">this_source</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="n">localpath</span><span class="p">):</span>
            <span class="c1"># Get the relative path</span>
            <span class="n">this_basename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">relpath</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="n">this_source</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">start</span><span class="o">=</span><span class="n">localpath</span><span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sftp</span><span class="o">.</span><span class="n">stat</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">remotepath</span><span class="p">,</span> <span class="n">this_basename</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">IOError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="kn">import</span> <span class="nn">errno</span>
                <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">errno</span> <span class="o">==</span> <span class="n">errno</span><span class="o">.</span><span class="n">ENOENT</span><span class="p">:</span>  <span class="c1"># Missing file</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">remotepath</span><span class="p">,</span> <span class="n">this_basename</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span>

            <span class="k">for</span> <span class="n">this_file</span> <span class="ow">in</span> <span class="n">this_source</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
                <span class="n">this_local_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">localpath</span><span class="p">,</span> <span class="n">this_basename</span><span class="p">,</span> <span class="n">this_file</span><span class="p">)</span>
                <span class="n">this_remote_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">remotepath</span><span class="p">,</span> <span class="n">this_basename</span><span class="p">,</span> <span class="n">this_file</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">putfile</span><span class="p">(</span><span class="n">this_local_file</span><span class="p">,</span> <span class="n">this_remote_file</span><span class="p">)</span></div>

<div class="viewcode-block" id="SshTransport.get"><a class="viewcode-back" href="../../../../developer_guide/core/transport.html#aiida.transports.plugins.ssh.SshTransport.get">[docs]</a>    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">remotepath</span><span class="p">,</span> <span class="n">localpath</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dereference</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ignore_nonexisting</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a file or folder from remote to local.</span>
<span class="sd">        Redirects to getfile or gettree.</span>

<span class="sd">        :param remotepath: a remote path</span>
<span class="sd">        :param localpath: an (absolute) local path</span>
<span class="sd">        :param dereference: follow symbolic links.</span>
<span class="sd">            Default = True (default behaviour in paramiko).</span>
<span class="sd">            False is not implemented.</span>
<span class="sd">        :param overwrite: if True overwrites files and folders.</span>
<span class="sd">            Default = False</span>

<span class="sd">        :raise ValueError: if local path is invalid</span>
<span class="sd">        :raise IOError: if the remotepath is not found</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO : add dereference</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">dereference</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isabs</span><span class="p">(</span><span class="n">localpath</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The localpath must be an absolute path&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_magic</span><span class="p">(</span><span class="n">remotepath</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_magic</span><span class="p">(</span><span class="n">localpath</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Pathname patterns are not allowed in the destination&quot;</span><span class="p">)</span>
            <span class="c1"># use the self glob to analyze the path remotely</span>
            <span class="n">to_copy_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">remotepath</span><span class="p">)</span>

            <span class="n">rename_local</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_copy_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># I can&#39;t scp more than one file on a single file</span>
                <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">localpath</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;Remote destination is not a directory&quot;</span><span class="p">)</span>
                <span class="c1"># I can&#39;t scp more than one file in a non existing directory</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">localpath</span><span class="p">):</span>  <span class="c1"># this should hold only for files</span>
                    <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="s2">&quot;Remote directory does not exist&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># the remote path is a directory</span>
                    <span class="n">rename_local</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">to_copy_list</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">rename_local</span><span class="p">:</span>  <span class="c1"># copying more than one file in one directory</span>
                        <span class="c1"># here is the case isfile and more than one file</span>
                        <span class="n">r</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">localpath</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">s</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">getfile</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="n">dereference</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>  <span class="c1"># one file to copy on one file</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">getfile</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">localpath</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="n">dereference</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">gettree</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">localpath</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="n">dereference</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">remotepath</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gettree</span><span class="p">(</span><span class="n">remotepath</span><span class="p">,</span> <span class="n">localpath</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="n">dereference</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">remotepath</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">localpath</span><span class="p">):</span>
                    <span class="n">r</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">localpath</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">remotepath</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">getfile</span><span class="p">(</span><span class="n">remotepath</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="n">dereference</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">getfile</span><span class="p">(</span><span class="n">remotepath</span><span class="p">,</span> <span class="n">localpath</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="n">dereference</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ignore_nonexisting</span><span class="p">:</span>
                    <span class="k">pass</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;The remote path </span><span class="si">{}</span><span class="s2"> does not exist&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">remotepath</span><span class="p">))</span></div>

<div class="viewcode-block" id="SshTransport.getfile"><a class="viewcode-back" href="../../../../developer_guide/core/transport.html#aiida.transports.plugins.ssh.SshTransport.getfile">[docs]</a>    <span class="k">def</span> <span class="nf">getfile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">remotepath</span><span class="p">,</span> <span class="n">localpath</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dereference</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a file from remote to local.</span>

<span class="sd">        :param remotepath: a remote path</span>
<span class="sd">        :param  localpath: an (absolute) local path</span>
<span class="sd">        :param  overwrite: if True overwrites files and folders.</span>
<span class="sd">                Default = False</span>

<span class="sd">        :raise ValueError: if local path is invalid</span>
<span class="sd">        :raise OSError: if unintentionally overwriting</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO : add dereference</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isabs</span><span class="p">(</span><span class="n">localpath</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;localpath must be an absolute path&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">localpath</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">overwrite</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="s1">&#39;Destination already exists: not overwriting it&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">dereference</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>

        <span class="c1"># Workaround for bug #724 in paramiko -- remove localpath on IOError</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sftp</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">remotepath</span><span class="p">,</span> <span class="n">localpath</span><span class="p">,</span> <span class="n">callback</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">localpath</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">raise</span></div>

<div class="viewcode-block" id="SshTransport.gettree"><a class="viewcode-back" href="../../../../developer_guide/core/transport.html#aiida.transports.plugins.ssh.SshTransport.gettree">[docs]</a>    <span class="k">def</span> <span class="nf">gettree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">remotepath</span><span class="p">,</span> <span class="n">localpath</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dereference</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a folder recursively from remote to local.</span>

<span class="sd">        :param remotepath: a remote path</span>
<span class="sd">        :param localpath: an (absolute) local path</span>
<span class="sd">        :param dereference: follow symbolic links.</span>
<span class="sd">            Default = True (default behaviour in paramiko).</span>
<span class="sd">            False is not implemented.</span>
<span class="sd">        :param  overwrite: if True overwrites files and folders.</span>
<span class="sd">            Default = False</span>

<span class="sd">        :raise ValueError: if local path is invalid</span>
<span class="sd">        :raise IOError: if the remotepath is not found</span>
<span class="sd">        :raise OSError: if unintentionally overwriting</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO : add dereference</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">dereference</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">remotepath</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;Remotepath must be a non empty string&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">localpath</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Localpaths must be a non empty string&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isabs</span><span class="p">(</span><span class="n">localpath</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Localpaths must be an absolute path&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">remotepath</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;Input remotepath is not a folder: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">localpath</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">localpath</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">overwrite</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t overwrite existing files&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">localpath</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="s2">&quot;Cannot copy a directory into a file&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">localpath</span><span class="p">):</span>  <span class="c1"># in this case copy things in the remotepath directly</span>
            <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">localpath</span><span class="p">)</span>  <span class="c1"># and make a directory at its place</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># localpath exists already: copy the folder inside of it!</span>
            <span class="n">localpath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">localpath</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">remotepath</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">localpath</span><span class="p">)</span>  <span class="c1"># create a nested folder</span>

        <span class="n">item_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">remotepath</span><span class="p">)</span>
        <span class="n">dest</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">localpath</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">item_list</span><span class="p">:</span>
            <span class="n">item</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">remotepath</span><span class="p">,</span> <span class="n">item</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gettree</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">remotepath</span><span class="p">,</span> <span class="n">item</span><span class="p">),</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">item</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">getfile</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">remotepath</span><span class="p">,</span> <span class="n">item</span><span class="p">),</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">item</span><span class="p">))</span></div>

<div class="viewcode-block" id="SshTransport.get_attribute"><a class="viewcode-back" href="../../../../developer_guide/core/transport.html#aiida.transports.plugins.ssh.SshTransport.get_attribute">[docs]</a>    <span class="k">def</span> <span class="nf">get_attribute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the object Fileattribute, specified in aiida.transports</span>
<span class="sd">        Receives in input the path of a given file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">aiida.transports.util</span> <span class="k">import</span> <span class="n">FileAttribute</span>

        <span class="n">paramiko_attr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sftp</span><span class="o">.</span><span class="n">lstat</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="n">aiida_attr</span> <span class="o">=</span> <span class="n">FileAttribute</span><span class="p">()</span>
        <span class="c1"># map the paramiko class into the aiida one</span>
        <span class="c1"># note that paramiko object contains more informations than the aiida</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">aiida_attr</span><span class="o">.</span><span class="n">_valid_fields</span><span class="p">:</span>
            <span class="n">aiida_attr</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">paramiko_attr</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">aiida_attr</span></div>

<div class="viewcode-block" id="SshTransport.copyfile"><a class="viewcode-back" href="../../../../developer_guide/core/transport.html#aiida.transports.plugins.ssh.SshTransport.copyfile">[docs]</a>    <span class="k">def</span> <span class="nf">copyfile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">remotesource</span><span class="p">,</span> <span class="n">remotedestination</span><span class="p">,</span> <span class="n">dereference</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">remotesource</span><span class="p">,</span> <span class="n">remotedestination</span><span class="p">,</span> <span class="n">dereference</span><span class="p">)</span></div>

<div class="viewcode-block" id="SshTransport.copytree"><a class="viewcode-back" href="../../../../developer_guide/core/transport.html#aiida.transports.plugins.ssh.SshTransport.copytree">[docs]</a>    <span class="k">def</span> <span class="nf">copytree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">remotesource</span><span class="p">,</span> <span class="n">remotedestination</span><span class="p">,</span> <span class="n">dereference</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">remotesource</span><span class="p">,</span> <span class="n">remotedestination</span><span class="p">,</span> <span class="n">dereference</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="SshTransport.copy"><a class="viewcode-back" href="../../../../developer_guide/core/transport.html#aiida.transports.plugins.ssh.SshTransport.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">remotesource</span><span class="p">,</span> <span class="n">remotedestination</span><span class="p">,</span> <span class="n">dereference</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Copy a file or a directory from remote source to remote destination.</span>
<span class="sd">        Flags used: ``-r``: recursive copy; ``-f``: force, makes the command non interactive;</span>
<span class="sd">        ``-L`` follows symbolic links</span>

<span class="sd">        :param  remotesource: file to copy from</span>
<span class="sd">        :param remotedestination: file to copy to</span>
<span class="sd">        :param dereference: if True, copy content instead of copying the symlinks only</span>
<span class="sd">            Default = False.</span>
<span class="sd">        :param recursive: if True copy directories recursively, otherwise only copy the specified file(s)</span>
<span class="sd">        :type recursive: bool</span>
<span class="sd">        :raise IOError: if the cp execution failed.</span>

<span class="sd">        .. note:: setting dereference equal to True could cause infinite loops.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># In the majority of cases, we should deal with linux cp commands</span>
        <span class="c1"># TODO : do we need to avoid the aliases when calling cp_exe=&#39;cp&#39;? Call directly /bin/cp?</span>

        <span class="n">cp_flags</span> <span class="o">=</span> <span class="s1">&#39;-f&#39;</span>
        <span class="k">if</span> <span class="n">recursive</span><span class="p">:</span>
            <span class="n">cp_flags</span> <span class="o">+=</span> <span class="s1">&#39; -r&#39;</span>

        <span class="c1"># For the moment, this is hardcoded. May become a parameter</span>
        <span class="n">cp_exe</span> <span class="o">=</span> <span class="s1">&#39;cp&#39;</span>

        <span class="c1"># To evaluate if we also want -p: preserves mode,ownership and timestamp</span>
        <span class="k">if</span> <span class="n">dereference</span><span class="p">:</span>
            <span class="c1"># use -L; --dereference is not supported on mac</span>
            <span class="n">cp_flags</span> <span class="o">+=</span> <span class="s1">&#39; -L&#39;</span>

        <span class="c1"># if in input I give an invalid object raise ValueError</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">remotesource</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;Input to copy() must be a non empty string. &#39;</span> <span class="o">+</span> <span class="s1">&#39;Found instead </span><span class="si">%s</span><span class="s1"> as remotesource&#39;</span> <span class="o">%</span> <span class="n">remotesource</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">remotedestination</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input to copy() must be a non empty string. &#39;</span> <span class="o">+</span>
                             <span class="s1">&#39;Found instead </span><span class="si">%s</span><span class="s1"> as remotedestination&#39;</span> <span class="o">%</span> <span class="n">remotedestination</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_magic</span><span class="p">(</span><span class="n">remotedestination</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Pathname patterns are not allowed in the destination&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_magic</span><span class="p">(</span><span class="n">remotesource</span><span class="p">):</span>
            <span class="n">to_copy_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">remotesource</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_copy_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">path_exists</span><span class="p">(</span><span class="n">remotedestination</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">remotedestination</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t copy more than one file in the same destination file&quot;</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">to_copy_list</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_exec_cp</span><span class="p">(</span><span class="n">cp_exe</span><span class="p">,</span> <span class="n">cp_flags</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">remotedestination</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_exec_cp</span><span class="p">(</span><span class="n">cp_exe</span><span class="p">,</span> <span class="n">cp_flags</span><span class="p">,</span> <span class="n">remotesource</span><span class="p">,</span> <span class="n">remotedestination</span><span class="p">)</span></div>

<div class="viewcode-block" id="SshTransport._exec_cp"><a class="viewcode-back" href="../../../../apidoc/aiida.transports.plugins.html#aiida.transports.plugins.ssh.SshTransport._exec_cp">[docs]</a>    <span class="k">def</span> <span class="nf">_exec_cp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cp_exe</span><span class="p">,</span> <span class="n">cp_flags</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">):</span>
        <span class="c1"># to simplify writing the above copy function</span>
        <span class="n">command</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cp_exe</span><span class="p">,</span> <span class="n">cp_flags</span><span class="p">,</span> <span class="n">escape_for_bash</span><span class="p">(</span><span class="n">src</span><span class="p">),</span> <span class="n">escape_for_bash</span><span class="p">(</span><span class="n">dst</span><span class="p">))</span>

        <span class="n">retval</span><span class="p">,</span> <span class="n">stdout</span><span class="p">,</span> <span class="n">stderr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exec_command_wait</span><span class="p">(</span><span class="n">command</span><span class="p">)</span>

        <span class="c1"># TODO : check and fix below</span>

        <span class="k">if</span> <span class="n">retval</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">stderr</span><span class="o">.</span><span class="n">strip</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;There was nonempty stderr in the cp command: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">stderr</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Problem executing cp. Exit code: </span><span class="si">{}</span><span class="s2">, stdout: &#39;</span><span class="si">{}</span><span class="s2">&#39;, &quot;</span>
                              <span class="s2">&quot;stderr: &#39;</span><span class="si">{}</span><span class="s2">&#39;, command: &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="n">stdout</span><span class="p">,</span> <span class="n">stderr</span><span class="p">,</span> <span class="n">command</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;Error while executing cp. Exit code: </span><span class="si">{}</span><span class="s2">, &quot;</span>
                          <span class="s2">&quot;stdout: &#39;</span><span class="si">{}</span><span class="s2">&#39;, stderr: &#39;</span><span class="si">{}</span><span class="s2">&#39;, &quot;</span>
                          <span class="s2">&quot;command: &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="n">stdout</span><span class="p">,</span> <span class="n">stderr</span><span class="p">,</span> <span class="n">command</span><span class="p">))</span></div>

<div class="viewcode-block" id="SshTransport._local_listdir"><a class="viewcode-back" href="../../../../apidoc/aiida.transports.plugins.html#aiida.transports.plugins.ssh.SshTransport._local_listdir">[docs]</a>    <span class="k">def</span> <span class="nf">_local_listdir</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">pattern</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Acts on the local folder, for the rest, same as listdir</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">pattern</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">re</span>
            <span class="k">if</span> <span class="n">path</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">):</span>  <span class="c1"># always this is the case in the local case</span>
                <span class="n">base_dir</span> <span class="o">=</span> <span class="n">path</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">base_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">(),</span> <span class="n">path</span><span class="p">)</span>

            <span class="n">filtered_list</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">base_dir</span><span class="p">,</span> <span class="n">pattern</span><span class="p">))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">base_dir</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">sep</span><span class="p">):</span>
                <span class="n">base_dir</span> <span class="o">+=</span> <span class="n">os</span><span class="o">.</span><span class="n">sep</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">base_dir</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">filtered_list</span><span class="p">]</span></div>

<div class="viewcode-block" id="SshTransport.listdir"><a class="viewcode-back" href="../../../../developer_guide/core/transport.html#aiida.transports.plugins.ssh.SshTransport.listdir">[docs]</a>    <span class="k">def</span> <span class="nf">listdir</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="n">pattern</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the list of files at path.</span>

<span class="sd">        :param path: default = &#39;.&#39;</span>
<span class="sd">        :param pattern: returns the list of files matching pattern.</span>
<span class="sd">                             Unix only. (Use to emulate ``ls *`` for example)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">pattern</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sftp</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">re</span>
            <span class="k">if</span> <span class="n">path</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">):</span>
                <span class="n">base_dir</span> <span class="o">=</span> <span class="n">path</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">base_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getcwd</span><span class="p">(),</span> <span class="n">path</span><span class="p">)</span>

            <span class="n">filtered_list</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">base_dir</span><span class="p">,</span> <span class="n">pattern</span><span class="p">))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">base_dir</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">):</span>
                <span class="n">base_dir</span> <span class="o">+=</span> <span class="s1">&#39;/&#39;</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">base_dir</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">filtered_list</span><span class="p">]</span></div>

<div class="viewcode-block" id="SshTransport.remove"><a class="viewcode-back" href="../../../../developer_guide/core/transport.html#aiida.transports.plugins.ssh.SshTransport.remove">[docs]</a>    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove a single file at &#39;path&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sftp</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">path</span><span class="p">)</span></div>

<div class="viewcode-block" id="SshTransport.rename"><a class="viewcode-back" href="../../../../developer_guide/core/transport.html#aiida.transports.plugins.ssh.SshTransport.rename">[docs]</a>    <span class="k">def</span> <span class="nf">rename</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rename a file or folder from src to dst.</span>

<span class="sd">        :param str oldpath: existing name of the file or folder</span>
<span class="sd">        :param str newpath: new name for the file or folder</span>

<span class="sd">        :raises IOError: if src/dst is not found</span>
<span class="sd">        :raises ValueError: if src/dst is not a valid string</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">src</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Source </span><span class="si">{}</span><span class="s2"> is not a valid string&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">src</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">dst</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Destination </span><span class="si">{}</span><span class="s2"> is not a valid string&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dst</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">src</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">src</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;Source </span><span class="si">{}</span><span class="s2"> does not exist&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">src</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">dst</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">dst</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;Destination </span><span class="si">{}</span><span class="s2"> does not exist&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dst</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sftp</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">)</span></div>

<div class="viewcode-block" id="SshTransport.isfile"><a class="viewcode-back" href="../../../../developer_guide/core/transport.html#aiida.transports.plugins.ssh.SshTransport.isfile">[docs]</a>    <span class="k">def</span> <span class="nf">isfile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if the given path is a file, False otherwise.</span>
<span class="sd">        Return False also if the path does not exist.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># This should not be needed for files, since an empty string should</span>
        <span class="c1"># be mapped by paramiko to the local directory - which is not a file -</span>
        <span class="c1"># but this is just to be sure</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">path</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;stat for path &#39;</span><span class="si">{}</span><span class="s2">&#39; (&#39;</span><span class="si">{}</span><span class="s2">&#39;): </span><span class="si">{}</span><span class="s2"> [</span><span class="si">{}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sftp</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">path</span><span class="p">),</span>
                                                                          <span class="bp">self</span><span class="o">.</span><span class="n">sftp</span><span class="o">.</span><span class="n">stat</span><span class="p">(</span><span class="n">path</span><span class="p">),</span>
                                                                          <span class="bp">self</span><span class="o">.</span><span class="n">sftp</span><span class="o">.</span><span class="n">stat</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">.</span><span class="n">st_mode</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">S_ISREG</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sftp</span><span class="o">.</span><span class="n">stat</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">.</span><span class="n">st_mode</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">IOError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="s2">&quot;errno&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># errno=2 means path does not exist: I return False</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span>  <span class="c1"># Typically if I don&#39;t have permissions (errno=13)</span></div>

<div class="viewcode-block" id="SshTransport._exec_command_internal"><a class="viewcode-back" href="../../../../apidoc/aiida.transports.plugins.html#aiida.transports.plugins.ssh.SshTransport._exec_command_internal">[docs]</a>    <span class="k">def</span> <span class="nf">_exec_command_internal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">command</span><span class="p">,</span> <span class="n">combine_stderr</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">bufsize</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Executes the specified command in bash login shell.</span>

<span class="sd">        Before the command is executed, changes directory to the current</span>
<span class="sd">        working directory as returned by self.getcwd().</span>

<span class="sd">        For executing commands and waiting for them to finish, use</span>
<span class="sd">        exec_command_wait.</span>

<span class="sd">        :param  command: the command to execute. The command is assumed to be</span>
<span class="sd">            already escaped using :py:func:`aiida.common.escaping.escape_for_bash`.</span>
<span class="sd">        :param combine_stderr: (default False) if True, combine stdout and</span>
<span class="sd">                stderr on the same buffer (i.e., stdout).</span>
<span class="sd">                Note: If combine_stderr is True, stderr will always be empty.</span>
<span class="sd">        :param bufsize: same meaning of the one used by paramiko.</span>

<span class="sd">        :return: a tuple with (stdin, stdout, stderr, channel),</span>
<span class="sd">            where stdin, stdout and stderr behave as file-like objects,</span>
<span class="sd">            plus the methods provided by paramiko, and channel is a</span>
<span class="sd">            paramiko.Channel object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">channel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sshclient</span><span class="o">.</span><span class="n">get_transport</span><span class="p">()</span><span class="o">.</span><span class="n">open_session</span><span class="p">()</span>
        <span class="n">channel</span><span class="o">.</span><span class="n">set_combine_stderr</span><span class="p">(</span><span class="n">combine_stderr</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">escaped_folder</span> <span class="o">=</span> <span class="n">escape_for_bash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getcwd</span><span class="p">())</span>
            <span class="n">command_to_execute</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;cd </span><span class="si">{escaped_folder}</span><span class="s2"> &amp;&amp; &quot;</span>
                                  <span class="s2">&quot;</span><span class="si">{real_command}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">escaped_folder</span><span class="o">=</span><span class="n">escaped_folder</span><span class="p">,</span> <span class="n">real_command</span><span class="o">=</span><span class="n">command</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">command_to_execute</span> <span class="o">=</span> <span class="n">command</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Command to be executed: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">command_to_execute</span><span class="p">))</span>

        <span class="c1"># Note: The default shell will eat one level of escaping, while</span>
        <span class="c1"># &#39;bash -l -c ...&#39; will eat another. Thus, we need to escape again.</span>
        <span class="n">channel</span><span class="o">.</span><span class="n">exec_command</span><span class="p">(</span><span class="s1">&#39;bash -l -c &#39;</span> <span class="o">+</span> <span class="n">escape_for_bash</span><span class="p">(</span><span class="n">command_to_execute</span><span class="p">))</span>

        <span class="n">stdin</span> <span class="o">=</span> <span class="n">channel</span><span class="o">.</span><span class="n">makefile</span><span class="p">(</span><span class="s1">&#39;wb&#39;</span><span class="p">,</span> <span class="n">bufsize</span><span class="p">)</span>
        <span class="n">stdout</span> <span class="o">=</span> <span class="n">channel</span><span class="o">.</span><span class="n">makefile</span><span class="p">(</span><span class="s1">&#39;rb&#39;</span><span class="p">,</span> <span class="n">bufsize</span><span class="p">)</span>
        <span class="n">stderr</span> <span class="o">=</span> <span class="n">channel</span><span class="o">.</span><span class="n">makefile_stderr</span><span class="p">(</span><span class="s1">&#39;rb&#39;</span><span class="p">,</span> <span class="n">bufsize</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">stdin</span><span class="p">,</span> <span class="n">stdout</span><span class="p">,</span> <span class="n">stderr</span><span class="p">,</span> <span class="n">channel</span></div>

<div class="viewcode-block" id="SshTransport.exec_command_wait"><a class="viewcode-back" href="../../../../developer_guide/core/transport.html#aiida.transports.plugins.ssh.SshTransport.exec_command_wait">[docs]</a>    <span class="k">def</span> <span class="nf">exec_command_wait</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">command</span><span class="p">,</span> <span class="n">stdin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">combine_stderr</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">bufsize</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Executes the specified command and waits for it to finish.</span>

<span class="sd">        :param command: the command to execute</span>
<span class="sd">        :param stdin: (optional,default=None) can be a string or a</span>
<span class="sd">                   file-like object.</span>
<span class="sd">        :param combine_stderr: (optional, default=False) see docstring of</span>
<span class="sd">                   self._exec_command_internal()</span>
<span class="sd">        :param bufsize: same meaning of paramiko.</span>

<span class="sd">        :return: a tuple with (return_value, stdout, stderr) where stdout and stderr</span>
<span class="sd">            are strings.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: To see if like this it works or hangs because of buffer problems.</span>

        <span class="n">ssh_stdin</span><span class="p">,</span> <span class="n">stdout</span><span class="p">,</span> <span class="n">stderr</span><span class="p">,</span> <span class="n">channel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_exec_command_internal</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="n">combine_stderr</span><span class="p">,</span> <span class="n">bufsize</span><span class="o">=</span><span class="n">bufsize</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">stdin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stdin</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
                <span class="n">filelike_stdin</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">(</span><span class="n">stdin</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">filelike_stdin</span> <span class="o">=</span> <span class="n">stdin</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">filelike_stdin</span><span class="o">.</span><span class="n">readlines</span><span class="p">():</span>
                    <span class="n">ssh_stdin</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;stdin can only be either a string of a file-like object!&quot;</span><span class="p">)</span>

        <span class="c1"># I flush and close them anyway; important to call shutdown_write</span>
        <span class="c1"># to avoid hangouts</span>
        <span class="n">ssh_stdin</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
        <span class="n">ssh_stdin</span><span class="o">.</span><span class="n">channel</span><span class="o">.</span><span class="n">shutdown_write</span><span class="p">()</span>

        <span class="c1"># I get the return code (blocking)</span>
        <span class="n">retval</span> <span class="o">=</span> <span class="n">channel</span><span class="o">.</span><span class="n">recv_exit_status</span><span class="p">()</span>

        <span class="c1"># needs to be after &#39;recv_exit_status&#39;, otherwise it might hang</span>
        <span class="n">output_text</span> <span class="o">=</span> <span class="n">stdout</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
        <span class="n">stderr_text</span> <span class="o">=</span> <span class="n">stderr</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">retval</span><span class="p">,</span> <span class="n">output_text</span><span class="p">,</span> <span class="n">stderr_text</span></div>

<div class="viewcode-block" id="SshTransport.gotocomputer_command"><a class="viewcode-back" href="../../../../developer_guide/core/transport.html#aiida.transports.plugins.ssh.SshTransport.gotocomputer_command">[docs]</a>    <span class="k">def</span> <span class="nf">gotocomputer_command</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">remotedir</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Specific gotocomputer string to connect to a given remote computer via</span>
<span class="sd">        ssh and directly go to the calculation folder.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># TODO: add also ProxyCommand and Timeout support</span>

        <span class="n">further_params</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="s1">&#39;username&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connect_args</span><span class="p">:</span>
            <span class="n">further_params</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;-l </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">escape_for_bash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_connect_args</span><span class="p">[</span><span class="s1">&#39;username&#39;</span><span class="p">])))</span>

        <span class="k">if</span> <span class="s1">&#39;port&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connect_args</span><span class="p">:</span>
            <span class="n">further_params</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;-p </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_connect_args</span><span class="p">[</span><span class="s1">&#39;port&#39;</span><span class="p">]))</span>

        <span class="k">if</span> <span class="s1">&#39;key_filename&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connect_args</span><span class="p">:</span>
            <span class="n">further_params</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;-i </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">escape_for_bash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_connect_args</span><span class="p">[</span><span class="s1">&#39;key_filename&#39;</span><span class="p">])))</span>

        <span class="n">further_params_str</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">further_params</span><span class="p">)</span>
        <span class="n">connect_string</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;ssh -t </span><span class="si">{machine}</span><span class="s2"> </span><span class="si">{further_params}</span><span class="s2"> &quot;if [ -d </span><span class="si">{escaped_remotedir}</span><span class="s2"> ] ; then cd </span><span class="si">{escaped_remotedir}</span><span class="s2"> ; bash -l ; else echo &#39;  ** The directory&#39; ; echo &#39;  ** </span><span class="si">{remotedir}</span><span class="s2">&#39; ; echo &#39;  ** seems to have been deleted, I logout...&#39; ; fi&quot; &quot;&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">further_params</span><span class="o">=</span><span class="n">further_params_str</span><span class="p">,</span>
            <span class="n">machine</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_machine</span><span class="p">,</span>
            <span class="n">escaped_remotedir</span><span class="o">=</span><span class="s2">&quot;&#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">remotedir</span><span class="p">),</span>
            <span class="n">remotedir</span><span class="o">=</span><span class="n">remotedir</span><span class="p">)</span>

        <span class="c1"># print connect_string</span>
        <span class="k">return</span> <span class="n">connect_string</span></div>

<div class="viewcode-block" id="SshTransport.symlink"><a class="viewcode-back" href="../../../../developer_guide/core/transport.html#aiida.transports.plugins.ssh.SshTransport.symlink">[docs]</a>    <span class="k">def</span> <span class="nf">symlink</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">remotesource</span><span class="p">,</span> <span class="n">remotedestination</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a symbolic link between the remote source and the remote</span>
<span class="sd">        destination.</span>

<span class="sd">        :param remotesource: remote source. Can contain a pattern.</span>
<span class="sd">        :param remotedestination: remote destination</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># paramiko gives some errors if path is starting with &#39;.&#39;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">normpath</span><span class="p">(</span><span class="n">remotesource</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">normpath</span><span class="p">(</span><span class="n">remotedestination</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_magic</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_magic</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
                <span class="c1"># if there are patterns in dest, I don&#39;t know which name to assign</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Remotedestination cannot have patterns&quot;</span><span class="p">)</span>

            <span class="c1"># find all files matching pattern</span>
            <span class="k">for</span> <span class="n">this_s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
                <span class="c1"># create the name of the link: take the last part of the path</span>
                <span class="n">this_d</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">remotedestination</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">this_s</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sftp</span><span class="o">.</span><span class="n">symlink</span><span class="p">(</span><span class="n">this_s</span><span class="p">,</span> <span class="n">this_d</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sftp</span><span class="o">.</span><span class="n">symlink</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span></div>

<div class="viewcode-block" id="SshTransport.path_exists"><a class="viewcode-back" href="../../../../developer_guide/core/transport.html#aiida.transports.plugins.ssh.SshTransport.path_exists">[docs]</a>    <span class="k">def</span> <span class="nf">path_exists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if path exists</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">errno</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sftp</span><span class="o">.</span><span class="n">stat</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">IOError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">errno</span> <span class="o">==</span> <span class="n">errno</span><span class="o">.</span><span class="n">ENOENT</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">raise</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, ECOLE POLYTECHNIQUE FEDERALE DE LAUSANNE (Theory and Simulation of Materials (THEOS) and National Centre for Computational Design and Discovery of Novel Materials (NCCR MARVEL)), Switzerland and ROBERT BOSCH LLC, USA. All rights reserved

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>