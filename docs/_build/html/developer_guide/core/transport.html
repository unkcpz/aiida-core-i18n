

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Transport plugins &mdash; AiiDA 1.0.0b2 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
        <script type="text/javascript" src="../../_static/contentui.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/contentui.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Database schema" href="database_schema.html" />
    <link rel="prev" title="ORM documentation: generic aiida.orm" href="orm_overview.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> AiiDA
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Installation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../install/quick_installation.html">Quick installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../install/prerequisites.html">Prerequisites</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../install/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../install/updating_installation.html">Updating AiiDA</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../install/troubleshooting.html">Troubleshooting</a></li>
</ul>
<p class="caption"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../get_started/index.html">First things first</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../get_started/daemon.html">Setup the daemon</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../get_started/computers.html">Setup a computer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../get_started/codes.html">Setup a code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../get_started/plugins.html">Plugins</a></li>
</ul>
<p class="caption"><span class="caption-text">Concepts</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../concepts/provenance.html">Provenance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../concepts/processes.html">Processes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../concepts/calculations.html">Calculations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../concepts/workflows.html">Workflows</a></li>
</ul>
<p class="caption"><span class="caption-text">Working with</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../working/processes.html">Processes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../working/functions.html">Calculation and work functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../working/calculations.html">Calculations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../working/workflows.html">Workflows</a></li>
</ul>
<p class="caption"><span class="caption-text">Working with AiiDA</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../working_with_aiida/index.html">Command line interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../working_with_aiida/index.html#scripting">Scripting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../working_with_aiida/index.html#data-types">Data types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../working_with_aiida/index.html#groups">Groups</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../working_with_aiida/index.html#schedulers">Schedulers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../working_with_aiida/index.html#querying-data">Querying data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../working_with_aiida/index.html#caching">Caching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../working_with_aiida/index.html#result-manager">Result manager</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../working_with_aiida/index.html#backups">Backups</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../working_with_aiida/index.html#troubleshooting">Troubleshooting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../working_with_aiida/index.html#rest-api">REST API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../working_with_aiida/index.html#cookbook">Cookbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../import_export/index.html">Import and Export</a></li>
</ul>
<p class="caption"><span class="caption-text">Development</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../index.html">AiiDA design</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html#aiida-core">AiiDA core</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="internals.html">AiiDA internals</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Transport plugins</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#generic-transport-class">Generic transport class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#existing-plugins">Existing plugins</a></li>
<li class="toctree-l3"><a class="reference internal" href="#developing-a-plugin">Developing a plugin</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="database_schema.html">Database schema</a></li>
<li class="toctree-l2"><a class="reference internal" href="modifying_the_schema.html">Modifying the schema</a></li>
<li class="toctree-l2"><a class="reference internal" href="extend_restapi.html">How to extend the AiiDA REST API</a></li>
<li class="toctree-l2"><a class="reference internal" href="caching.html">Caching: implementation details</a></li>
<li class="toctree-l2"><a class="reference internal" href="plugin_system.html">Developing The Plugin System</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tools/sphinx_cheatsheet.html">Sphinx cheatsheet</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../index.html#aiida-plugins">AiiDA plugins</a></li>
</ul>
<p class="caption"><span class="caption-text">Tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial/index.html">StructureData</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial/index.html#pseudopotentials">Pseudopotentials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial/index.html#plugin-development">Plugin development</a></li>
</ul>
<p class="caption"><span class="caption-text">API reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="`aiida package &lt;https://aiida-core.readthedocs.io/en/latest/apidoc/aiida.html&gt;`_">`aiida package &lt;https://aiida-core.readthedocs.io/en/latest/apidoc/aiida.html&gt;`_</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">AiiDA</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">AiiDA design</a> &raquo;</li>
        
      <li>Transport plugins</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/developer_guide/core/transport.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="transport-plugins">
<h1>Transport plugins<a class="headerlink" href="#transport-plugins" title="Permalink to this headline">¶</a></h1>
<div class="toctree-wrapper compound">
</div>
<p>This chapter describes the generic implementation of a transport plugin.
The currently implemented are the local and the ssh plugin.
The local plugin makes use only of some standard python modules like os and shutil.
The ssh plugin is a wrapper to the library paramiko, that you installed with AiiDA.</p>
<p>A generic set of tests is contained in plugin_test.py, while plugin-specific tests are written separately.</p>
<div class="section" id="generic-transport-class">
<h2>Generic transport class<a class="headerlink" href="#generic-transport-class" title="Permalink to this headline">¶</a></h2>
<p>Module for classes and utilities to define transports to other machines.</p>
<dl class="class">
<dt>
<em class="property">class </em><code class="descclassname">aiida.transports.</code><code class="descname">Transport</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/transport.html#Transport"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Abstract class for a generic transport (ssh, local, …)
Contains the set of minimal methods</p>
<dl class="method">
<dt>
<code class="descname">__enter__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/transport.html#Transport.__enter__"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>For transports that require opening a connection, opens
all required channels (used in ‘with’ statements).</p>
<p>This object can be used in nested <cite>with</cite> statements and the connection
will only be opened once and closed when the final <cite>with</cite> scope
finishes e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">t</span> <span class="o">=</span> <span class="n">Transport</span><span class="p">()</span>
<span class="k">with</span> <span class="n">t</span><span class="p">:</span>
    <span class="c1"># Connection is now open..</span>
    <span class="k">with</span> <span class="n">t</span><span class="p">:</span>
        <span class="c1"># ..still open..</span>
        <span class="k">pass</span>
    <span class="c1"># ..still open..</span>
<span class="c1"># ...closed</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">__exit__</code><span class="sig-paren">(</span><em>type_</em>, <em>value</em>, <em>traceback</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/transport.html#Transport.__exit__"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Closes connections, if needed (used in ‘with’ statements).</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">chdir</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/transport.html#Transport.chdir"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Change directory to ‘path’</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>path</strong> (<em>str</em>) – path to change working directory into.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">IOError, if the requested path does not exist</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">str</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">chmod</code><span class="sig-paren">(</span><em>path</em>, <em>mode</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/transport.html#Transport.chmod"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Change permissions of a path.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>path</strong> (<em>str</em>) – path to file</li>
<li><strong>mode</strong> (<em>int</em>) – new permissions</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">chown</code><span class="sig-paren">(</span><em>path</em>, <em>uid</em>, <em>gid</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/transport.html#Transport.chown"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Change the owner (uid) and group (gid) of a file.
As with python’s os.chown function, you must pass both arguments,
so if you only want to change one, use stat first to retrieve the
current owner and group.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>path</strong> (<em>str</em>) – path to the file to change the owner and group of</li>
<li><strong>uid</strong> (<em>int</em>) – new owner’s uid</li>
<li><strong>gid</strong> (<em>int</em>) – new group id</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/transport.html#Transport.close"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Closes the local transport channel</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">copy</code><span class="sig-paren">(</span><em>remotesource</em>, <em>remotedestination</em>, <em>dereference=False</em>, <em>recursive=True</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/transport.html#Transport.copy"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Copy a file or a directory from remote source to remote destination
(On the same remote machine)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>remotesource</strong> (<em>str</em>) – path of the remote source directory / file</li>
<li><strong>remotedestination</strong> (<em>str</em>) – path of the remote destination directory / file</li>
<li><strong>dereference</strong> (<em>bool</em>) – if True copy the contents of any symlinks found, otherwise copy the symlinks themselves</li>
<li><strong>recursive</strong> (<em>bool</em>) – if True copy directories recursively, otherwise only copy the specified file(s)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last">IOError, if one of src or dst does not exist</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">copy_from_remote_to_remote</code><span class="sig-paren">(</span><em>transportdestination</em>, <em>remotesource</em>, <em>remotedestination</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/transport.html#Transport.copy_from_remote_to_remote"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Copy files or folders from a remote computer to another remote computer.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>transportdestination</strong> – transport to be used for the destination computer</li>
<li><strong>remotesource</strong> (<em>str</em>) – path to the remote source directory / file</li>
<li><strong>remotedestination</strong> (<em>str</em>) – path to the remote destination directory / file</li>
<li><strong>kwargs</strong> – keyword parameters passed to the call to transportdestination.put,
except for ‘dereference’ that is passed to self.get</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">the keyword ‘dereference’ SHOULD be set to False for the
final put (onto the destination), while it can be set to the
value given in kwargs for the get from the source. In that
way, a symbolic link would never be followed in the final
copy to the remote destination. That way we could avoid getting
unknown (potentially malicious) files into the destination computer.
HOWEVER, since dereference=False is currently NOT
supported by all plugins, we still force it to True for the final put.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">the supported keys in kwargs are callback, dereference,
overwrite and ignore_nonexisting.</p>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">copyfile</code><span class="sig-paren">(</span><em>remotesource</em>, <em>remotedestination</em>, <em>dereference=False</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/transport.html#Transport.copyfile"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Copy a file from remote source to remote destination
(On the same remote machine)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>remotesource</strong> (<em>str</em>) – path of the remote source directory / file</li>
<li><strong>remotedestination</strong> (<em>str</em>) – path of the remote destination directory / file</li>
<li><strong>dereference</strong> (<em>bool</em>) – if True copy the contents of any symlinks found, otherwise copy the symlinks themselves</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><strong>IOError</strong> – if one of src or dst does not exist</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">copytree</code><span class="sig-paren">(</span><em>remotesource</em>, <em>remotedestination</em>, <em>dereference=False</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/transport.html#Transport.copytree"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Copy a folder from remote source to remote destination
(On the same remote machine)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>remotesource</strong> (<em>str</em>) – path of the remote source directory / file</li>
<li><strong>remotedestination</strong> (<em>str</em>) – path of the remote destination directory / file</li>
<li><strong>dereference</strong> (<em>bool</em>) – if True copy the contents of any symlinks found, otherwise copy the symlinks themselves</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><strong>IOError</strong> – if one of src or dst does not exist</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">exec_command_wait</code><span class="sig-paren">(</span><em>command</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/transport.html#Transport.exec_command_wait"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Execute the command on the shell, waits for it to finish,
and return the retcode, the stdout and the stderr.</p>
<p>Enforce the execution to be run from the pwd (as given by
self.getcwd), if this is not None.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>command</strong> (<em>str</em>) – execute the command given as a string</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">a list: the retcode (int), stdout (str) and stderr (str).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">get</code><span class="sig-paren">(</span><em>remotepath</em>, <em>localpath</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/transport.html#Transport.get"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Retrieve a file or folder from remote source to local destination
dst must be an absolute path (src not necessarily)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>remotepath</strong> – (str) remote_folder_path</li>
<li><strong>localpath</strong> – (str) local_folder_path</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">get_attribute</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/transport.html#Transport.get_attribute"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Return an object FixedFieldsAttributeDict for file in a given path,
as defined in aiida.common.extendeddicts
Each attribute object consists in a dictionary with the following keys:</p>
<ul class="simple">
<li>st_size: size of files, in bytes</li>
<li>st_uid: user id of owner</li>
<li>st_gid: group id of owner</li>
<li>st_mode: protection bits</li>
<li>st_atime: time of most recent access</li>
<li>st_mtime: time of most recent modification</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>path</strong> (<em>str</em>) – path to file</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">object FixedFieldsAttributeDict</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">get_mode</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/transport.html#Transport.get_mode"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Return the portion of the file’s mode that can be set by chmod().</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>path</strong> (<em>str</em>) – path to file</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">the portion of the file’s mode that can be set by chmod()</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">get_safe_open_interval</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/transport.html#Transport.get_safe_open_interval"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Get an interval (in seconds) that suggests how long the user should wait
between consecutive calls to open the transport.  This can be used as
a way to get the user to not swamp a limited number of connections, etc.
However it is just advisory.</p>
<p>If returns 0, it is taken that there are no reasons to limit the
frequency of open calls.</p>
<p>In the main class, it returns a default value (&gt;0 for safety), set in
the _DEFAULT_SAFE_OPEN_INTERVAL attribute of the class. Plugins should override it.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The safe interval between calling open, in seconds</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">float</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt>
<em class="property">classmethod </em><code class="descname">get_short_doc</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/transport.html#Transport.get_short_doc"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Return the first non-empty line of the class docstring, if available</p>
</dd></dl>

<dl class="classmethod">
<dt>
<em class="property">classmethod </em><code class="descname">get_valid_auth_params</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/transport.html#Transport.get_valid_auth_params"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Return the internal list of valid auth_params</p>
</dd></dl>

<dl class="classmethod">
<dt>
<em class="property">classmethod </em><code class="descname">get_valid_transports</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/transport.html#Transport.get_valid_transports"><span class="viewcode-link">[source]</span></a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a list of existing plugin names</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">getcwd</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/transport.html#Transport.getcwd"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Get working directory</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a string identifying the current working directory</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">getfile</code><span class="sig-paren">(</span><em>remotepath</em>, <em>localpath</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/transport.html#Transport.getfile"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Retrieve a file from remote source to local destination
dst must be an absolute path (src not necessarily)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>remotepath</strong> (<em>str</em>) – remote_folder_path</li>
<li><strong>localpath</strong> (<em>str</em>) – local_folder_path</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">gettree</code><span class="sig-paren">(</span><em>remotepath</em>, <em>localpath</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/transport.html#Transport.gettree"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Retrieve a folder recursively from remote source to local destination
dst must be an absolute path (src not necessarily)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>remotepath</strong> (<em>str</em>) – remote_folder_path</li>
<li><strong>localpath</strong> (<em>str</em>) – local_folder_path</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">glob</code><span class="sig-paren">(</span><em>pathname</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/transport.html#Transport.glob"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Return a list of paths matching a pathname pattern.</p>
<p>The pattern may contain simple shell-style wildcards a la fnmatch.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">glob0</code><span class="sig-paren">(</span><em>dirname</em>, <em>basename</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/transport.html#Transport.glob0"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Wrap basename i a list if it is empty or if dirname/basename is an existing path, else return empty list.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">glob1</code><span class="sig-paren">(</span><em>dirname</em>, <em>pattern</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/transport.html#Transport.glob1"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Match subpaths of dirname against pattern.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">gotocomputer_command</code><span class="sig-paren">(</span><em>remotedir</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/transport.html#Transport.gotocomputer_command"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Return a string to be run using os.system in order to connect
via the transport to the remote directory.</p>
<p>Expected behaviors:</p>
<ul class="simple">
<li>A new bash session is opened</li>
<li>A reasonable error message is produced if the folder does not exist</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>remotedir</strong> (<em>str</em>) – the full path of the remote directory</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">iglob</code><span class="sig-paren">(</span><em>pathname</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/transport.html#Transport.iglob"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Return an iterator which yields the paths matching a pathname pattern.</p>
<p>The pattern may contain simple shell-style wildcards a la fnmatch.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">isdir</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/transport.html#Transport.isdir"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>True if path is an existing directory.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>path</strong> (<em>str</em>) – path to directory</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">boolean</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">isfile</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/transport.html#Transport.isfile"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Return True if path is an existing file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>path</strong> (<em>str</em>) – path to file</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">boolean</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">listdir</code><span class="sig-paren">(</span><em>path='.'</em>, <em>pattern=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/transport.html#Transport.listdir"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Return a list of the names of the entries in the given path.
The list is in arbitrary order. It does not include the special
entries ‘.’ and ‘..’ even if they are present in the directory.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>path</strong> (<em>str</em>) – path to list (default to ‘.’)</li>
<li><strong>pattern</strong> (<em>str</em>) – if used, listdir returns a list of files matching
filters in Unix style. Unix only.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a list of strings</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">listdir_withattributes</code><span class="sig-paren">(</span><em>path='.'</em>, <em>pattern=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/transport.html#Transport.listdir_withattributes"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Return a list of the names of the entries in the given path.
The list is in arbitrary order. It does not include the special
entries ‘.’ and ‘..’ even if they are present in the directory.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>path</strong> (<em>str</em>) – path to list (default to ‘.’)</li>
<li><strong>pattern</strong> (<em>str</em>) – if used, listdir returns a list of files matching
filters in Unix style. Unix only.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><p>a list of dictionaries, one per entry.
The schema of the dictionary is
the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
   <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span>
   <span class="s1">&#39;attributes&#39;</span><span class="p">:</span> <span class="n">FileAttributeObject</span><span class="p">,</span>
   <span class="s1">&#39;isdir&#39;</span><span class="p">:</span> <span class="n">Bool</span>
<span class="p">}</span>
</pre></div>
</div>
<p>where ‘name’ is the file or folder directory, and any other information is metadata
(if the file is a folder, a directory, …). ‘attributes’ behaves as the output of
transport.get_attribute(); isdir is a boolean indicating if the object is a directory or not.</p>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">logger</code></dt>
<dd><p>Return the internal logger.
If you have set extra parameters using set_logger_extra(), a
suitable LoggerAdapter instance is created, bringing with itself
also the extras.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">makedirs</code><span class="sig-paren">(</span><em>path</em>, <em>ignore_existing=False</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/transport.html#Transport.makedirs"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Super-mkdir; create a leaf directory and all intermediate ones.
Works like mkdir, except that any intermediate path segment (not
just the rightmost) will be created if it does not exist.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>path</strong> (<em>str</em>) – directory to create</li>
<li><strong>ignore_existing</strong> (<em>bool</em>) – if set to true, it doesn’t give any error
if the leaf directory does already exist</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last">OSError, if directory at path already exists</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">mkdir</code><span class="sig-paren">(</span><em>path</em>, <em>ignore_existing=False</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/transport.html#Transport.mkdir"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Create a folder (directory) named path.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>path</strong> (<em>str</em>) – name of the folder to create</li>
<li><strong>ignore_existing</strong> (<em>bool</em>) – if True, does not give any error if the
directory already exists</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last">OSError, if directory at path already exists</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">normalize</code><span class="sig-paren">(</span><em>path='.'</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/transport.html#Transport.normalize"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Return the normalized path (on the server) of a given path.
This can be used to quickly resolve symbolic links or determine
what the server is considering to be the “current folder”.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>path</strong> (<em>str</em>) – path to be normalized</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><strong>IOError</strong> – if the path can’t be resolved on the server</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">open</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/transport.html#Transport.open"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Opens a local transport channel</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">path_exists</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/transport.html#Transport.path_exists"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Returns True if path exists, False otherwise.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">put</code><span class="sig-paren">(</span><em>localpath</em>, <em>remotepath</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/transport.html#Transport.put"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Put a file or a directory from local src to remote dst.
src must be an absolute path (dst not necessarily))
Redirects to putfile and puttree.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>localpath</strong> (<em>str</em>) – absolute path to local source</li>
<li><strong>remotepath</strong> (<em>str</em>) – path to remote destination</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">putfile</code><span class="sig-paren">(</span><em>localpath</em>, <em>remotepath</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/transport.html#Transport.putfile"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Put a file from local src to remote dst.
src must be an absolute path (dst not necessarily))</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>localpath</strong> (<em>str</em>) – absolute path to local file</li>
<li><strong>remotepath</strong> (<em>str</em>) – path to remote file</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">puttree</code><span class="sig-paren">(</span><em>localpath</em>, <em>remotepath</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/transport.html#Transport.puttree"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Put a folder recursively from local src to remote dst.
src must be an absolute path (dst not necessarily))</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>localpath</strong> (<em>str</em>) – absolute path to local folder</li>
<li><strong>remotepath</strong> (<em>str</em>) – path to remote folder</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">remove</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/transport.html#Transport.remove"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Remove the file at the given path. This only works on files;
for removing folders (directories), use rmdir.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>path</strong> (<em>str</em>) – path to file to remove</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><strong>IOError</strong> – if the path is a directory</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">rename</code><span class="sig-paren">(</span><em>oldpath</em>, <em>newpath</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/transport.html#Transport.rename"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Rename a file or folder from oldpath to newpath.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>oldpath</strong> (<em>str</em>) – existing name of the file or folder</li>
<li><strong>newpath</strong> (<em>str</em>) – new name for the file or folder</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><strong>IOError</strong> – if oldpath/newpath is not found</li>
<li><strong>ValueError</strong> – if oldpath/newpath is not a valid string</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">rmdir</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/transport.html#Transport.rmdir"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Remove the folder named path.
This works only for empty folders. For recursive remove, use rmtree.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>path</strong> (<em>str</em>) – absolute path to the folder to remove</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">rmtree</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/transport.html#Transport.rmtree"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Remove recursively the content at path</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>path</strong> (<em>str</em>) – absolute path to remove</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">set_logger_extra</code><span class="sig-paren">(</span><em>logger_extra</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/transport.html#Transport.set_logger_extra"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Pass the data that should be passed automatically to self.logger
as ‘extra’ keyword. This is typically useful if you pass data
obtained using get_dblogger_extra in aiida.backends.djsite.utils, to automatically
log also to the DbLog table.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>logger_extra</strong> – data that you want to pass as extra to the
self.logger. To write to DbLog, it should be created by the
aiida.backends.djsite.utils.get_dblogger_extra function. Pass None if you
do not want to have extras passed.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">symlink</code><span class="sig-paren">(</span><em>remotesource</em>, <em>remotedestination</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/transport.html#Transport.symlink"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Create a symbolic link between the remote source and the remote
destination.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>remotesource</strong> – remote source</li>
<li><strong>remotedestination</strong> – remote destination</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">whoami</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/transport.html#Transport.whoami"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Get the remote username</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">list of username (str),
retval (int),
stderr (str)</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="existing-plugins">
<h2>Existing plugins<a class="headerlink" href="#existing-plugins" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt>
<em class="property">class </em><code class="descclassname">aiida.transports.plugins.ssh.</code><code class="descname">SshTransport</code><span class="sig-paren">(</span><em>machine</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/plugins/ssh.html#SshTransport"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Support connection, command execution and data transfer to remote computers via SSH+SFTP.</p>
<dl class="method">
<dt>
<code class="descname">chdir</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/plugins/ssh.html#SshTransport.chdir"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Change directory of the SFTP session. Emulated internally by paramiko.</p>
<p>Differently from paramiko, if you pass None to chdir, nothing
happens and the cwd is unchanged.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">chmod</code><span class="sig-paren">(</span><em>path</em>, <em>mode</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/plugins/ssh.html#SshTransport.chmod"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Change permissions to path</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>path</strong> – path to file</li>
<li><strong>mode</strong> – new permission bits (integer)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/plugins/ssh.html#SshTransport.close"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Close the SFTP channel, and the SSHClient.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Todo:</th><td class="field-body">correctly manage exceptions</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><a class="reference internal" href="../../apidoc/aiida.common.html#aiida.common.InvalidOperation" title="aiida.common.InvalidOperation"><strong>aiida.common.InvalidOperation</strong></a> – if the channel is already open</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">copy</code><span class="sig-paren">(</span><em>remotesource</em>, <em>remotedestination</em>, <em>dereference=False</em>, <em>recursive=True</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/plugins/ssh.html#SshTransport.copy"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Copy a file or a directory from remote source to remote destination.
Flags used: <code class="docutils literal notranslate"><span class="pre">-r</span></code>: recursive copy; <code class="docutils literal notranslate"><span class="pre">-f</span></code>: force, makes the command non interactive;
<code class="docutils literal notranslate"><span class="pre">-L</span></code> follows symbolic links</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>remotesource</strong> – file to copy from</li>
<li><strong>remotedestination</strong> – file to copy to</li>
<li><strong>dereference</strong> – if True, copy content instead of copying the symlinks only
Default = False.</li>
<li><strong>recursive</strong> (<em>bool</em>) – if True copy directories recursively, otherwise only copy the specified file(s)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><strong>IOError</strong> – if the cp execution failed.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">setting dereference equal to True could cause infinite loops.</p>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">copyfile</code><span class="sig-paren">(</span><em>remotesource</em>, <em>remotedestination</em>, <em>dereference=False</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/plugins/ssh.html#SshTransport.copyfile"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Copy a file from remote source to remote destination
(On the same remote machine)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>remotesource</strong> (<em>str</em>) – path of the remote source directory / file</li>
<li><strong>remotedestination</strong> (<em>str</em>) – path of the remote destination directory / file</li>
<li><strong>dereference</strong> (<em>bool</em>) – if True copy the contents of any symlinks found, otherwise copy the symlinks themselves</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><strong>IOError</strong> – if one of src or dst does not exist</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">copytree</code><span class="sig-paren">(</span><em>remotesource</em>, <em>remotedestination</em>, <em>dereference=False</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/plugins/ssh.html#SshTransport.copytree"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Copy a folder from remote source to remote destination
(On the same remote machine)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>remotesource</strong> (<em>str</em>) – path of the remote source directory / file</li>
<li><strong>remotedestination</strong> (<em>str</em>) – path of the remote destination directory / file</li>
<li><strong>dereference</strong> (<em>bool</em>) – if True copy the contents of any symlinks found, otherwise copy the symlinks themselves</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><strong>IOError</strong> – if one of src or dst does not exist</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">exec_command_wait</code><span class="sig-paren">(</span><em>command</em>, <em>stdin=None</em>, <em>combine_stderr=False</em>, <em>bufsize=-1</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/plugins/ssh.html#SshTransport.exec_command_wait"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Executes the specified command and waits for it to finish.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>command</strong> – the command to execute</li>
<li><strong>stdin</strong> – (optional,default=None) can be a string or a
file-like object.</li>
<li><strong>combine_stderr</strong> – (optional, default=False) see docstring of
self._exec_command_internal()</li>
<li><strong>bufsize</strong> – same meaning of paramiko.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a tuple with (return_value, stdout, stderr) where stdout and stderr
are strings.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">get</code><span class="sig-paren">(</span><em>remotepath</em>, <em>localpath</em>, <em>callback=None</em>, <em>dereference=True</em>, <em>overwrite=True</em>, <em>ignore_nonexisting=False</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/plugins/ssh.html#SshTransport.get"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Get a file or folder from remote to local.
Redirects to getfile or gettree.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>remotepath</strong> – a remote path</li>
<li><strong>localpath</strong> – an (absolute) local path</li>
<li><strong>dereference</strong> – follow symbolic links.
Default = True (default behaviour in paramiko).
False is not implemented.</li>
<li><strong>overwrite</strong> – if True overwrites files and folders.
Default = False</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><strong>ValueError</strong> – if local path is invalid</li>
<li><strong>IOError</strong> – if the remotepath is not found</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">get_attribute</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/plugins/ssh.html#SshTransport.get_attribute"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Returns the object Fileattribute, specified in aiida.transports
Receives in input the path of a given file.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">getcwd</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/plugins/ssh.html#SshTransport.getcwd"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Return the current working directory for this SFTP session, as
emulated by paramiko. If no directory has been set with chdir,
this method will return None. But in __enter__ this is set explicitly,
so this should never happen within this class.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">getfile</code><span class="sig-paren">(</span><em>remotepath</em>, <em>localpath</em>, <em>callback=None</em>, <em>dereference=True</em>, <em>overwrite=True</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/plugins/ssh.html#SshTransport.getfile"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Get a file from remote to local.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>remotepath</strong> – a remote path</li>
<li><strong>localpath</strong> – an (absolute) local path</li>
<li><strong>overwrite</strong> – if True overwrites files and folders.
Default = False</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><strong>ValueError</strong> – if local path is invalid</li>
<li><strong>OSError</strong> – if unintentionally overwriting</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">gettree</code><span class="sig-paren">(</span><em>remotepath</em>, <em>localpath</em>, <em>callback=None</em>, <em>dereference=True</em>, <em>overwrite=True</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/plugins/ssh.html#SshTransport.gettree"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Get a folder recursively from remote to local.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>remotepath</strong> – a remote path</li>
<li><strong>localpath</strong> – an (absolute) local path</li>
<li><strong>dereference</strong> – follow symbolic links.
Default = True (default behaviour in paramiko).
False is not implemented.</li>
<li><strong>overwrite</strong> – if True overwrites files and folders.
Default = False</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><strong>ValueError</strong> – if local path is invalid</li>
<li><strong>IOError</strong> – if the remotepath is not found</li>
<li><strong>OSError</strong> – if unintentionally overwriting</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">gotocomputer_command</code><span class="sig-paren">(</span><em>remotedir</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/plugins/ssh.html#SshTransport.gotocomputer_command"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Specific gotocomputer string to connect to a given remote computer via
ssh and directly go to the calculation folder.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">isdir</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/plugins/ssh.html#SshTransport.isdir"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Return True if the given path is a directory, False otherwise.
Return False also if the path does not exist.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">isfile</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/plugins/ssh.html#SshTransport.isfile"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Return True if the given path is a file, False otherwise.
Return False also if the path does not exist.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">listdir</code><span class="sig-paren">(</span><em>path='.'</em>, <em>pattern=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/plugins/ssh.html#SshTransport.listdir"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Get the list of files at path.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>path</strong> – default = ‘.’</li>
<li><strong>pattern</strong> – returns the list of files matching pattern.
Unix only. (Use to emulate <code class="docutils literal notranslate"><span class="pre">ls</span> <span class="pre">*</span></code> for example)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">makedirs</code><span class="sig-paren">(</span><em>path</em>, <em>ignore_existing=False</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/plugins/ssh.html#SshTransport.makedirs"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Super-mkdir; create a leaf directory and all intermediate ones.
Works like mkdir, except that any intermediate path segment (not
just the rightmost) will be created if it does not exist.</p>
<p>NOTE: since os.path.split uses the separators as the host system
(that could be windows), I assume the remote computer is Linux-based
and use ‘/’ as separators!</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>path</strong> – directory to create (string)</li>
<li><strong>ignore_existing</strong> – if set to true, it doesn’t give any error
if the leaf directory does already exist (bool)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><strong>OSError</strong> – If the directory already exists.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">mkdir</code><span class="sig-paren">(</span><em>path</em>, <em>ignore_existing=False</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/plugins/ssh.html#SshTransport.mkdir"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Create a folder (directory) named path.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>path</strong> – name of the folder to create</li>
<li><strong>ignore_existing</strong> – if True, does not give any error if the directory
already exists</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><strong>OSError</strong> – If the directory already exists.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">normalize</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/plugins/ssh.html#SshTransport.normalize"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Returns the normalized path (removing double slashes, etc…)</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">open</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/plugins/ssh.html#SshTransport.open"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Open a SSHClient to the machine possibly using the parameters given
in the __init__.</p>
<p>Also opens a sftp channel, ready to be used.
The current working directory is set explicitly, so it is not None.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><a class="reference internal" href="../../apidoc/aiida.common.html#aiida.common.InvalidOperation" title="aiida.common.InvalidOperation"><strong>aiida.common.InvalidOperation</strong></a> – if the channel is already open</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">path_exists</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/plugins/ssh.html#SshTransport.path_exists"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Check if path exists</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">put</code><span class="sig-paren">(</span><em>localpath</em>, <em>remotepath</em>, <em>callback=None</em>, <em>dereference=True</em>, <em>overwrite=True</em>, <em>ignore_nonexisting=False</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/plugins/ssh.html#SshTransport.put"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Put a file or a folder from local to remote.
Redirects to putfile or puttree.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>localpath</strong> – an (absolute) local path</li>
<li><strong>remotepath</strong> – a remote path</li>
<li><strong>dereference</strong> – follow symbolic links (boolean).
Default = True (default behaviour in paramiko). False is not implemented.</li>
<li><strong>overwrite</strong> – if True overwrites files and folders (boolean).
Default = False.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><strong>ValueError</strong> – if local path is invalid</li>
<li><strong>OSError</strong> – if the localpath does not exist</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">putfile</code><span class="sig-paren">(</span><em>localpath</em>, <em>remotepath</em>, <em>callback=None</em>, <em>dereference=True</em>, <em>overwrite=True</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/plugins/ssh.html#SshTransport.putfile"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Put a file from local to remote.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>localpath</strong> – an (absolute) local path</li>
<li><strong>remotepath</strong> – a remote path</li>
<li><strong>overwrite</strong> – if True overwrites files and folders (boolean).
Default = True.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><strong>ValueError</strong> – if local path is invalid</li>
<li><strong>OSError</strong> – if the localpath does not exist,
or unintentionally overwriting</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">puttree</code><span class="sig-paren">(</span><em>localpath</em>, <em>remotepath</em>, <em>callback=None</em>, <em>dereference=True</em>, <em>overwrite=True</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/plugins/ssh.html#SshTransport.puttree"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Put a folder recursively from local to remote.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>localpath</strong> – an (absolute) local path</li>
<li><strong>remotepath</strong> – a remote path</li>
<li><strong>dereference</strong> – follow symbolic links (boolean)
Default = True (default behaviour in paramiko). False is not implemented.</li>
<li><strong>overwrite</strong> – if True overwrites files and folders (boolean).
Default = True</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><strong>ValueError</strong> – if local path is invalid</li>
<li><strong>OSError</strong> – if the localpath does not exist, or trying to overwrite</li>
<li><strong>IOError</strong> – if remotepath is invalid</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">setting dereference equal to True could cause infinite loops.
see os.walk() documentation</p>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">remove</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/plugins/ssh.html#SshTransport.remove"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Remove a single file at ‘path’</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">rename</code><span class="sig-paren">(</span><em>src</em>, <em>dst</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/plugins/ssh.html#SshTransport.rename"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Rename a file or folder from src to dst.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>oldpath</strong> (<em>str</em>) – existing name of the file or folder</li>
<li><strong>newpath</strong> (<em>str</em>) – new name for the file or folder</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><strong>IOError</strong> – if src/dst is not found</li>
<li><strong>ValueError</strong> – if src/dst is not a valid string</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">rmdir</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/plugins/ssh.html#SshTransport.rmdir"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Remove the folder named ‘path’ if empty.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">rmtree</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/plugins/ssh.html#SshTransport.rmtree"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Remove a file or a directory at path, recursively
Flags used: -r: recursive copy; -f: force, makes the command non interactive;</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>path</strong> – remote path to delete</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><strong>IOError</strong> – if the rm execution failed.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">symlink</code><span class="sig-paren">(</span><em>remotesource</em>, <em>remotedestination</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/plugins/ssh.html#SshTransport.symlink"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Create a symbolic link between the remote source and the remote
destination.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>remotesource</strong> – remote source. Can contain a pattern.</li>
<li><strong>remotedestination</strong> – remote destination</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<p>Local transport</p>
<dl class="class">
<dt>
<em class="property">class </em><code class="descclassname">aiida.transports.plugins.local.</code><code class="descname">LocalTransport</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/plugins/local.html#LocalTransport"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Support copy and command execution on the same host on which AiiDA is running via direct file copy and
execution commands.</p>
<p>Note that the environment variables are copied from the submitting process, so you might need to clean it
with a <code class="docutils literal notranslate"><span class="pre">prepend_text</span></code>. For example, the AiiDA daemon sets a <code class="docutils literal notranslate"><span class="pre">PYTHONPATH</span></code>, so you might want to add
<code class="docutils literal notranslate"><span class="pre">unset</span> <span class="pre">PYTHONPATH</span></code> if you plan on running calculations that use Python.</p>
<dl class="method">
<dt>
<code class="descname">chdir</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/plugins/local.html#LocalTransport.chdir"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Changes directory to path, emulated internally.
:param path: path to cd into
:raise OSError: if the directory does not have read attributes.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">chmod</code><span class="sig-paren">(</span><em>path</em>, <em>mode</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/plugins/local.html#LocalTransport.chmod"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Changes permission bits of object at path
:param path: path to modify
:param mode: permission bits</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><strong>IOError</strong> – if path does not exist.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">chown</code><span class="sig-paren">(</span><em>path</em>, <em>uid</em>, <em>gid</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/plugins/local.html#LocalTransport.chown"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Change the owner (uid) and group (gid) of a file.
As with python’s os.chown function, you must pass both arguments,
so if you only want to change one, use stat first to retrieve the
current owner and group.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>path</strong> (<em>str</em>) – path to the file to change the owner and group of</li>
<li><strong>uid</strong> (<em>int</em>) – new owner’s uid</li>
<li><strong>gid</strong> (<em>int</em>) – new group id</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/plugins/local.html#LocalTransport.close"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Closes the local transport channel</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><a class="reference internal" href="../../apidoc/aiida.common.html#aiida.common.InvalidOperation" title="aiida.common.InvalidOperation"><strong>aiida.common.InvalidOperation</strong></a> – if the channel is already open</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">copy</code><span class="sig-paren">(</span><em>remotesource</em>, <em>remotedestination</em>, <em>dereference=False</em>, <em>recursive=True</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/plugins/local.html#LocalTransport.copy"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Copies a file or a folder from ‘remote’ remotesource to ‘remote’ remotedestination.
Automatically redirects to copyfile or copytree.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>remotesource</strong> – path to local file</li>
<li><strong>remotedestination</strong> – path to remote file</li>
<li><strong>dereference</strong> – follow symbolic links. Default = False</li>
<li><strong>recursive</strong> (<em>bool</em>) – if True copy directories recursively, otherwise only copy the specified file(s)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><strong>ValueError</strong> – if ‘remote’ remotesource or remotedestinationis not valid</li>
<li><strong>OSError</strong> – if remotesource does not exist</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">copyfile</code><span class="sig-paren">(</span><em>remotesource</em>, <em>remotedestination</em>, <em>dereference=False</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/plugins/local.html#LocalTransport.copyfile"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Copies a file from ‘remote’ remotesource to
‘remote’ remotedestination.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>remotesource</strong> – path to local file</li>
<li><strong>remotedestination</strong> – path to remote file</li>
<li><strong>dereference</strong> (<em>bool</em>) – if True copy the contents of any symlinks found, otherwise copy the symlinks themselves</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><strong>ValueError</strong> – if ‘remote’ remotesource or remotedestination is not valid</li>
<li><strong>OSError</strong> – if remotesource does not exist</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">copytree</code><span class="sig-paren">(</span><em>remotesource</em>, <em>remotedestination</em>, <em>dereference=False</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/plugins/local.html#LocalTransport.copytree"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Copies a folder from ‘remote’ remotesource to
‘remote’ remotedestination.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>remotesource</strong> – path to local file</li>
<li><strong>remotedestination</strong> – path to remote file</li>
<li><strong>dereference</strong> – follow symbolic links. Default = False</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><strong>ValueError</strong> – if ‘remote’ remotesource or remotedestination is not valid</li>
<li><strong>OSError</strong> – if remotesource does not exist</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt>
<code class="descname">curdir</code></dt>
<dd><p>Returns the _internal_dir, if the channel is open.
If possible, use getcwd() instead!</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">exec_command_wait</code><span class="sig-paren">(</span><em>command</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/plugins/local.html#LocalTransport.exec_command_wait"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Executes the specified command and waits for it to finish.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>command</strong> – the command to execute</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">a tuple with (return_value, stdout, stderr) where stdout and
stderr are strings.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">get</code><span class="sig-paren">(</span><em>remotepath</em>, <em>localpath</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/plugins/local.html#LocalTransport.get"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Copies a folder or a file recursively from ‘remote’ remotepath to
‘local’ localpath.
Automatically redirects to getfile or gettree.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>remotepath</strong> – path to local file</li>
<li><strong>localpath</strong> – absolute path to remote file</li>
<li><strong>dereference</strong> – follow symbolic links
default = True</li>
<li><strong>overwrite</strong> – if True overwrites localpath
default = False</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><strong>IOError</strong> – if ‘remote’ remotepath is not valid</li>
<li><strong>ValueError</strong> – if ‘local’ localpath is not valid</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">get_attribute</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/plugins/local.html#LocalTransport.get_attribute"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Returns an object FileAttribute,
as specified in aiida.transports.
:param path: the path of the given file.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">getcwd</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/plugins/local.html#LocalTransport.getcwd"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Returns the current working directory, emulated by the transport</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">getfile</code><span class="sig-paren">(</span><em>remotepath</em>, <em>localpath</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/plugins/local.html#LocalTransport.getfile"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Copies a file recursively from ‘remote’ remotepath to
‘local’ localpath.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>remotepath</strong> – path to local file</li>
<li><strong>localpath</strong> – absolute path to remote file</li>
<li><strong>overwrite</strong> – if True overwrites localpath.
Default = False</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>:raise IOError if ‘remote’ remotepath is not valid or not found
:raise ValueError: if ‘local’ localpath is not valid
:raise OSError: if unintentionally overwriting</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">gettree</code><span class="sig-paren">(</span><em>remotepath</em>, <em>localpath</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/plugins/local.html#LocalTransport.gettree"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Copies a folder recursively from ‘remote’ remotepath to
‘local’ localpath.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>remotepath</strong> – path to local file</li>
<li><strong>localpath</strong> – absolute path to remote file</li>
<li><strong>dereference</strong> – follow symbolic links. Default = True</li>
<li><strong>overwrite</strong> – if True overwrites localpath. Default = False</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><strong>IOError</strong> – if ‘remote’ remotepath is not valid</li>
<li><strong>ValueError</strong> – if ‘local’ localpath is not valid</li>
<li><strong>OSError</strong> – if unintentionally overwriting</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">gotocomputer_command</code><span class="sig-paren">(</span><em>remotedir</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/plugins/local.html#LocalTransport.gotocomputer_command"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Return a string to be run using os.system in order to connect
via the transport to the remote directory.</p>
<p>Expected behaviors:</p>
<ul class="simple">
<li>A new bash session is opened</li>
<li>A reasonable error message is produced if the folder does not exist</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>remotedir</strong> (<em>str</em>) – the full path of the remote directory</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">isdir</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/plugins/local.html#LocalTransport.isdir"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Checks if ‘path’ is a directory.
:return: a boolean</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">isfile</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/plugins/local.html#LocalTransport.isfile"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Checks if object at path is a file.
Returns a boolean.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">listdir</code><span class="sig-paren">(</span><em>path='.'</em>, <em>pattern=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/plugins/local.html#LocalTransport.listdir"><span class="viewcode-link">[source]</span></a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">a list containing the names of the entries in the directory.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>path</strong> – default =’.’</li>
<li><strong>pattern</strong> – if set, returns the list of files matching pattern.
Unix only. (Use to emulate ls * for example)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">makedirs</code><span class="sig-paren">(</span><em>path</em>, <em>ignore_existing=False</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/plugins/local.html#LocalTransport.makedirs"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Super-mkdir; create a leaf directory and all intermediate ones.
Works like mkdir, except that any intermediate path segment (not
just the rightmost) will be created if it does not exist.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>path</strong> – directory to create</li>
<li><strong>ignore_existing</strong> – if set to true, it doesn’t give any error
if the leaf directory does already exist</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><strong>OSError</strong> – If the directory already exists and is not ignore_existing</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">mkdir</code><span class="sig-paren">(</span><em>path</em>, <em>ignore_existing=False</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/plugins/local.html#LocalTransport.mkdir"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Create a folder (directory) named path.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>path</strong> – name of the folder to create</li>
<li><strong>ignore_existing</strong> – if True, does not give any error if the
directory already exists</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><strong>OSError</strong> – If the directory already exists.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">normalize</code><span class="sig-paren">(</span><em>path='.'</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/plugins/local.html#LocalTransport.normalize"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Normalizes path, eliminating double slashes, etc..
:param path: path to normalize</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">open</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/plugins/local.html#LocalTransport.open"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Opens a local transport channel</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><a class="reference internal" href="../../apidoc/aiida.common.html#aiida.common.InvalidOperation" title="aiida.common.InvalidOperation"><strong>aiida.common.InvalidOperation</strong></a> – if the channel is already open</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">path_exists</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/plugins/local.html#LocalTransport.path_exists"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Check if path exists</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">put</code><span class="sig-paren">(</span><em>localpath</em>, <em>remotepath</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/plugins/local.html#LocalTransport.put"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Copies a file or a folder from localpath to remotepath.
Automatically redirects to putfile or puttree.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>localpath</strong> – absolute path to local file</li>
<li><strong>remotepath</strong> – path to remote file</li>
<li><strong>dereference</strong> – if True follows symbolic links.
Default = True</li>
<li><strong>overwrite</strong> – if True overwrites remotepath.
Default = False</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><strong>IOError</strong> – if remotepath is not valid</li>
<li><strong>ValueError</strong> – if localpath is not valid</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">putfile</code><span class="sig-paren">(</span><em>localpath</em>, <em>remotepath</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/plugins/local.html#LocalTransport.putfile"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Copies a file from localpath to remotepath.
Automatically redirects to putfile or puttree.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>localpath</strong> – absolute path to local file</li>
<li><strong>remotepath</strong> – path to remote file</li>
<li><strong>overwrite</strong> – if True overwrites remotepath
Default = False</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><strong>IOError</strong> – if remotepath is not valid</li>
<li><strong>ValueError</strong> – if localpath is not valid</li>
<li><strong>OSError</strong> – if localpath does not exist</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">puttree</code><span class="sig-paren">(</span><em>localpath</em>, <em>remotepath</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/plugins/local.html#LocalTransport.puttree"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Copies a folder recursively from localpath to remotepath.
Automatically redirects to putfile or puttree.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>localpath</strong> – absolute path to local file</li>
<li><strong>remotepath</strong> – path to remote file</li>
<li><strong>dereference</strong> – follow symbolic links.
Default = True</li>
<li><strong>overwrite</strong> – if True overwrites remotepath.
Default = False</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><strong>IOError</strong> – if remotepath is not valid</li>
<li><strong>ValueError</strong> – if localpath is not valid</li>
<li><strong>OSError</strong> – if localpath does not exist</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">remove</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/plugins/local.html#LocalTransport.remove"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Removes a file at position path.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">rename</code><span class="sig-paren">(</span><em>oldpath</em>, <em>newpath</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/plugins/local.html#LocalTransport.rename"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Rename a file or folder from oldpath to newpath.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>oldpath</strong> (<em>str</em>) – existing name of the file or folder</li>
<li><strong>newpath</strong> (<em>str</em>) – new name for the file or folder</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><strong>IOError</strong> – if src/dst is not found</li>
<li><strong>ValueError</strong> – if src/dst is not a valid string</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">rmdir</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/plugins/local.html#LocalTransport.rmdir"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Removes a folder at location path.
:param path: path to remove</p>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">rmtree</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/plugins/local.html#LocalTransport.rmtree"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Remove tree as rm -r would do</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>path</strong> – a string to path</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<code class="descname">symlink</code><span class="sig-paren">(</span><em>remotesource</em>, <em>remotedestination</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/aiida/transports/plugins/local.html#LocalTransport.symlink"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Create a symbolic link between the remote source and the remote
remotedestination</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>remotesource</strong> – remote source. Can contain a pattern.</li>
<li><strong>remotedestination</strong> – remote destination</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="developing-a-plugin">
<h2>Developing a plugin<a class="headerlink" href="#developing-a-plugin" title="Permalink to this headline">¶</a></h2>
<p>The transport class is actually almost never used directly by the user.
It is mostly utilized by the ExecutionManager, that use the transport plugin to connect to the remote computer to manage the calculation.
The ExecutionManager has to be able to use always the same function, or the same interface, regardless of which kind of connection is actually really using.</p>
<p>The generic transport class contains a set of minimal methods that an implementation must support, in order to be fully compatible with the other plugins.
If not, a NotImplementedError will be raised, interrupting the managing of the calculation or whatever is using the transport plugin.</p>
<p>Since it is important that all plugins have the same interface, or the same response behavior, a set of generic tests has been written (alongside with set of tests that are implementation specific).
After <strong>every</strong> modification, or when implementing a new plugin, it is crucial to run the tests and verify that everything is passed.
The modification of tests possibly means breaking back-compatibility and/or modifications to every piece of code using a transport plugin.</p>
<p>If an unexpected behavior is observed during the usage, the way of fixing it is:</p>
<ol class="arabic simple">
<li>Write a new test that shows the problem (one test for one problem when possible)</li>
<li>Fix the bug</li>
<li>Verify that the test is passed correctly</li>
</ol>
<p>The importance of point 1) is often neglected, but unittesting is a useful tool that helps you avoiding the repetition of errors. Despite the appearence, it’s a time-saver!
Not only, the tests help you seeing how the plugin is used.</p>
<p>As for the general functioning of the plugin, the <code class="docutils literal notranslate"><span class="pre">__init__</span></code> method is used only to initialize the class instance, without actually opening the transport channel. The connection must be opened only by the <code class="docutils literal notranslate"><span class="pre">__enter__</span></code> method, (and closed by <code class="docutils literal notranslate"><span class="pre">__exit__</span></code>.
The <code class="docutils literal notranslate"><span class="pre">__enter__</span></code> method let you use the transport class using the <code class="docutils literal notranslate"><span class="pre">with</span></code> statement (see <a class="reference external" href="http://docs.python.org/release/2.5/whatsnew/pep-343.html">Python docs</a>), in a way similar to the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">t</span> <span class="o">=</span> <span class="n">TransportPlugin</span><span class="p">()</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="n">t</span><span class="o">.</span><span class="n">do_something_remotely</span>
</pre></div>
</div>
<p>To ensure this, for example, the local plugin uses a hidden boolean variable <code class="docutils literal notranslate"><span class="pre">_is_open</span></code> that is set when the <code class="docutils literal notranslate"><span class="pre">__enter__</span></code> and <code class="docutils literal notranslate"><span class="pre">__exit__</span></code> methods are called. The Ssh logic is instead given by the property sftp.</p>
<p>The other functions that require some care are the copying functions, called using the following terminology:</p>
<ol class="arabic simple">
<li><code class="docutils literal notranslate"><span class="pre">put</span></code>: from local source to remote destination</li>
<li><code class="docutils literal notranslate"><span class="pre">get</span></code>: from remote source to local destination</li>
<li><code class="docutils literal notranslate"><span class="pre">copy</span></code>: copying files from remote source to remote destination</li>
</ol>
<p>Note that these functions must copy files or folders regardless, internally, they will fallback to functions like <code class="docutils literal notranslate"><span class="pre">putfile</span></code> or <code class="docutils literal notranslate"><span class="pre">puttree</span></code>.</p>
<p>The last function requiring care is <code class="docutils literal notranslate"><span class="pre">exec_command_wait</span></code>, which is an analogue to the <a class="reference external" href="http://docs.python.org/2/library/subprocess.html">subprocess</a> Python module.
The function gives the freedom to execute a string as a remote command, thus it could produce nasty effects if not written with care.
Be sure to escape any string for bash!</p>
<p>Currently, the implemented plugins are the Local and the Ssh transports.
The Local one is simply a wrapper to some standard Python modules, like <code class="docutils literal notranslate"><span class="pre">shutil</span></code> or <code class="docutils literal notranslate"><span class="pre">os</span></code>, those functions are simply interfaced in a different way with AiiDA.
The SSh instead is an interface to the <a class="reference external" href="http://www.lag.net/paramiko/">Paramiko</a> library.</p>
<p>Below, you can find a template to fill for a new transport plugin, with a minimal docstring that also work for the sphinx documentation.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">NewTransport</span><span class="p">(</span><span class="n">aiida</span><span class="o">.</span><span class="n">transports</span><span class="o">.</span><span class="n">Transport</span><span class="p">):</span>

  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">machine</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Initialize the Transport class.</span>

<span class="sd">      :param machine: the machine to connect to</span>
<span class="sd">      &quot;&quot;&quot;</span>

  <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Open the connection</span>
<span class="sd">      &quot;&quot;&quot;</span>

  <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">traceback</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Close the connection</span>
<span class="sd">      &quot;&quot;&quot;</span>

  <span class="k">def</span> <span class="nf">chdir</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">path</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Change directory to &#39;path&#39;</span>

<span class="sd">      :param str path: path to change working directory into.</span>
<span class="sd">      :raises: IOError, if the requested path does not exist</span>
<span class="sd">      :rtype: string</span>
<span class="sd">      &quot;&quot;&quot;</span>

  <span class="k">def</span> <span class="nf">chmod</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">path</span><span class="p">,</span><span class="n">mode</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Change permissions of a path.</span>

<span class="sd">      :param str path: path to file</span>
<span class="sd">      :param int mode: new permissions</span>
<span class="sd">      &quot;&quot;&quot;</span>

  <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">remotesource</span><span class="p">,</span><span class="n">remotedestination</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Copy a file or a directory from remote source to remote destination</span>
<span class="sd">      (On the same remote machine)</span>

<span class="sd">      :param str remotesource: path of the remote source directory / file</span>
<span class="sd">      :param str remotedestination: path of the remote destination directory / file</span>

<span class="sd">      :raises: IOError, if source or destination does not exist</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="k">raise</span> <span class="ne">NotImplementedError</span>

  <span class="k">def</span> <span class="nf">copyfile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">remotesource</span><span class="p">,</span><span class="n">remotedestination</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Copy a file from remote source to remote destination</span>
<span class="sd">      (On the same remote machine)</span>

<span class="sd">      :param str remotesource: path of the remote source directory / file</span>
<span class="sd">      :param str remotedestination: path of the remote destination directory / file</span>

<span class="sd">      :raises IOError: if one of src or dst does not exist</span>
<span class="sd">      &quot;&quot;&quot;</span>

  <span class="k">def</span> <span class="nf">copytree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">remotesource</span><span class="p">,</span><span class="n">remotedestination</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Copy a folder from remote source to remote destination</span>
<span class="sd">      (On the same remote machine)</span>

<span class="sd">      :param str remotesource: path of the remote source directory / file</span>
<span class="sd">      :param str remotedestination: path of the remote destination directory / file</span>

<span class="sd">      :raise IOError: if one of src or dst does not exist</span>
<span class="sd">      &quot;&quot;&quot;</span>

  <span class="k">def</span> <span class="nf">exec_command_wait</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">command</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Execute the command on the shell, waits for it to finish,</span>
<span class="sd">      and return the retcode, the stdout and the stderr.</span>

<span class="sd">      Enforce the execution to be run from the pwd (as given by</span>
<span class="sd">      self.getcwd), if this is not None.</span>

<span class="sd">      :param str command: execute the command given as a string</span>
<span class="sd">      :return: a tuple: the retcode (int), stdout (str) and stderr (str).</span>
<span class="sd">      &quot;&quot;&quot;</span>

  <span class="k">def</span> <span class="nf">get_attribute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">path</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Return an object FixedFieldsAttributeDict for file in a given path,</span>
<span class="sd">      as defined in aiida.common.extendeddicts</span>
<span class="sd">      Each attribute object consists in a dictionary with the following keys:</span>

<span class="sd">      * st_size: size of files, in bytes</span>

<span class="sd">      * st_uid: user id of owner</span>

<span class="sd">      * st_gid: group id of owner</span>

<span class="sd">      * st_mode: protection bits</span>

<span class="sd">      * st_atime: time of most recent access</span>

<span class="sd">      * st_mtime: time of most recent modification</span>

<span class="sd">      :param str path: path to file</span>
<span class="sd">      :return: object FixedFieldsAttributeDict</span>
<span class="sd">      &quot;&quot;&quot;</span>

  <span class="k">def</span> <span class="nf">getcwd</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Get working directory</span>

<span class="sd">      :return: a string identifying the current working directory</span>
<span class="sd">      &quot;&quot;&quot;</span>

  <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">remotepath</span><span class="p">,</span> <span class="n">localpath</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Retrieve a file or folder from remote source to local destination</span>
<span class="sd">      dst must be an absolute path (src not necessarily)</span>

<span class="sd">      :param remotepath: (str) remote_folder_path</span>
<span class="sd">      :param localpath: (str) local_folder_path</span>
<span class="sd">      &quot;&quot;&quot;</span>

  <span class="k">def</span> <span class="nf">getfile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">remotepath</span><span class="p">,</span> <span class="n">localpath</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Retrieve a file from remote source to local destination</span>
<span class="sd">      dst must be an absolute path (src not necessarily)</span>

<span class="sd">      :param str remotepath: remote_folder_path</span>
<span class="sd">      :param str localpath: local_folder_path</span>
<span class="sd">      &quot;&quot;&quot;</span>

  <span class="k">def</span> <span class="nf">gettree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">remotepath</span><span class="p">,</span> <span class="n">localpath</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Retrieve a folder recursively from remote source to local destination</span>
<span class="sd">      dst must be an absolute path (src not necessarily)</span>

<span class="sd">      :param str remotepath: remote_folder_path</span>
<span class="sd">      :param str localpath: local_folder_path</span>
<span class="sd">      &quot;&quot;&quot;</span>

  <span class="k">def</span> <span class="nf">gotocomputer_command</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">remotedir</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Return a string to be run using os.system in order to connect</span>
<span class="sd">      via the transport to the remote directory.</span>

<span class="sd">      Expected behaviors:</span>

<span class="sd">      * A new bash session is opened</span>

<span class="sd">      * A reasonable error message is produced if the folder does not exist</span>

<span class="sd">      :param str remotedir: the full path of the remote directory</span>
<span class="sd">      &quot;&quot;&quot;</span>

  <span class="k">def</span> <span class="nf">isdir</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">path</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      True if path is an existing directory.</span>

<span class="sd">      :param str path: path to directory</span>
<span class="sd">      :return: boolean</span>
<span class="sd">      &quot;&quot;&quot;</span>

  <span class="k">def</span> <span class="nf">isfile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">path</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Return True if path is an existing file.</span>

<span class="sd">      :param str path: path to file</span>
<span class="sd">      :return: boolean</span>
<span class="sd">      &quot;&quot;&quot;</span>

  <span class="k">def</span> <span class="nf">listdir</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="s1">&#39;.&#39;</span><span class="p">,</span><span class="n">pattern</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Return a list of the names of the entries in the given path.</span>
<span class="sd">      The list is in arbitrary order. It does not include the special</span>
<span class="sd">      entries &#39;.&#39; and &#39;..&#39; even if they are present in the directory.</span>

<span class="sd">      :param str path: path to list (default to &#39;.&#39;)</span>
<span class="sd">      :param str pattern: if used, listdir returns a list of files matching</span>
<span class="sd">                          filters in Unix style. Unix only.</span>
<span class="sd">      :return: a list of strings</span>
<span class="sd">      &quot;&quot;&quot;</span>

  <span class="k">def</span> <span class="nf">makedirs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">path</span><span class="p">,</span><span class="n">ignore_existing</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Super-mkdir; create a leaf directory and all intermediate ones.</span>
<span class="sd">      Works like mkdir, except that any intermediate path segment (not</span>
<span class="sd">      just the rightmost) will be created if it does not exist.</span>

<span class="sd">      :param str path: directory to create</span>
<span class="sd">      :param bool ignore_existing: if set to true, it doesn&#39;t give any error</span>
<span class="sd">                                   if the leaf directory does already exist</span>

<span class="sd">      :raises: OSError, if directory at path already exists</span>
<span class="sd">      &quot;&quot;&quot;</span>

  <span class="k">def</span> <span class="nf">mkdir</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">path</span><span class="p">,</span><span class="n">ignore_existing</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Create a folder (directory) named path.</span>

<span class="sd">      :param str path: name of the folder to create</span>
<span class="sd">      :param bool ignore_existing: if True, does not give any error if the</span>
<span class="sd">                                   directory already exists</span>

<span class="sd">      :raises: OSError, if directory at path already exists</span>
<span class="sd">      &quot;&quot;&quot;</span>

  <span class="k">def</span> <span class="nf">normalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">path</span><span class="o">=</span><span class="s1">&#39;.&#39;</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Return the normalized path (on the server) of a given path.</span>
<span class="sd">      This can be used to quickly resolve symbolic links or determine</span>
<span class="sd">      what the server is considering to be the &quot;current folder&quot;.</span>

<span class="sd">      :param str path: path to be normalized</span>

<span class="sd">      :raise IOError: if the path can&#39;t be resolved on the server</span>
<span class="sd">      &quot;&quot;&quot;</span>

  <span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">localpath</span><span class="p">,</span> <span class="n">remotepath</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span> <span class="n">kwargs</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Put a file or a directory from local src to remote dst.</span>
<span class="sd">      src must be an absolute path (dst not necessarily))</span>
<span class="sd">      Redirects to putfile and puttree.</span>

<span class="sd">      :param str localpath: path to remote destination</span>
<span class="sd">      :param str remotepath: absolute path to local source</span>
<span class="sd">      &quot;&quot;&quot;</span>

  <span class="k">def</span> <span class="nf">putfile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">localpath</span><span class="p">,</span> <span class="n">remotepath</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span> <span class="n">kwargs</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Put a file from local src to remote dst.</span>
<span class="sd">      src must be an absolute path (dst not necessarily))</span>

<span class="sd">      :param str localpath: path to remote file</span>
<span class="sd">      :param str remotepath: absolute path to local file</span>
<span class="sd">      &quot;&quot;&quot;</span>

  <span class="k">def</span> <span class="nf">puttree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">localpath</span><span class="p">,</span> <span class="n">remotepath</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span> <span class="n">kwargs</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Put a folder recursively from local src to remote dst.</span>
<span class="sd">      src must be an absolute path (dst not necessarily))</span>

<span class="sd">      :param str localpath: path to remote folder</span>
<span class="sd">      :param str remotepath: absolute path to local folder</span>
<span class="sd">      &quot;&quot;&quot;</span>

 <span class="k">def</span> <span class="nf">rename</span><span class="p">(</span><span class="n">src</span><span class="p">,</span><span class="n">dst</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Rename a file or folder from src to dst.</span>

<span class="sd">      :param str oldpath: existing name of the file or folder</span>
<span class="sd">      :param str newpath: new name for the file or folder</span>

<span class="sd">      :raises IOError: if src/dst is not found</span>
<span class="sd">      :raises ValueError: if src/dst is not a valid string</span>
<span class="sd">      &quot;&quot;&quot;</span>

  <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">path</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Remove the file at the given path. This only works on files;</span>
<span class="sd">      for removing folders (directories), use rmdir.</span>

<span class="sd">      :param str path: path to file to remove</span>

<span class="sd">      :raise IOError: if the path is a directory</span>
<span class="sd">      &quot;&quot;&quot;</span>

  <span class="k">def</span> <span class="nf">rmdir</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">path</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Remove the folder named path.</span>
<span class="sd">      This works only for empty folders. For recursive remove, use rmtree.</span>

<span class="sd">      :param str path: absolute path to the folder to remove</span>
<span class="sd">      &quot;&quot;&quot;</span>
      <span class="k">raise</span> <span class="ne">NotImplementedError</span>

  <span class="k">def</span> <span class="nf">rmtree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">path</span><span class="p">):</span>
      <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Remove recursively the content at path</span>

<span class="sd">      :param str path: absolute path to remove</span>
<span class="sd">      &quot;&quot;&quot;</span>
</pre></div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="database_schema.html" class="btn btn-neutral float-right" title="Database schema" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="orm_overview.html" class="btn btn-neutral float-left" title="ORM documentation: generic aiida.orm" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, ECOLE POLYTECHNIQUE FEDERALE DE LAUSANNE (Theory and Simulation of Materials (THEOS) and National Centre for Computational Design and Discovery of Novel Materials (NCCR MARVEL)), Switzerland and ROBERT BOSCH LLC, USA. All rights reserved

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>