

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Workflows &mdash; AiiDA 1.0.0b2 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script type="text/javascript" src="../_static/contentui.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/contentui.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Processes" href="../working/processes.html" />
    <link rel="prev" title="Calculations" href="calculations.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> AiiDA
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Installation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../install/quick_installation.html">Quick installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../install/prerequisites.html">Prerequisites</a></li>
<li class="toctree-l1"><a class="reference internal" href="../install/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../install/updating_installation.html">Updating AiiDA</a></li>
<li class="toctree-l1"><a class="reference internal" href="../install/troubleshooting.html">Troubleshooting</a></li>
</ul>
<p class="caption"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../get_started/index.html">First things first</a></li>
<li class="toctree-l1"><a class="reference internal" href="../get_started/daemon.html">Setup the daemon</a></li>
<li class="toctree-l1"><a class="reference internal" href="../get_started/computers.html">Setup a computer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../get_started/codes.html">Setup a code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../get_started/plugins.html">Plugins</a></li>
</ul>
<p class="caption"><span class="caption-text">Concepts</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="provenance.html">Provenance</a></li>
<li class="toctree-l1"><a class="reference internal" href="processes.html">Processes</a></li>
<li class="toctree-l1"><a class="reference internal" href="calculations.html">Calculations</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Workflows</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#work-functions">Work functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#work-chains">Work chains</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#why">Why?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#implementation">Implementation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#advantages">Advantages</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#when-to-use-which">When to use which</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Working with</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../working/processes.html">Processes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../working/functions.html">Calculation and work functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../working/calculations.html">Calculations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../working/workflows.html">Workflows</a></li>
</ul>
<p class="caption"><span class="caption-text">Working with AiiDA</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../working_with_aiida/index.html">Command line interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../working_with_aiida/index.html#scripting">Scripting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../working_with_aiida/index.html#data-types">Data types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../working_with_aiida/index.html#groups">Groups</a></li>
<li class="toctree-l1"><a class="reference internal" href="../working_with_aiida/index.html#schedulers">Schedulers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../working_with_aiida/index.html#querying-data">Querying data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../working_with_aiida/index.html#caching">Caching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../working_with_aiida/index.html#result-manager">Result manager</a></li>
<li class="toctree-l1"><a class="reference internal" href="../working_with_aiida/index.html#backups">Backups</a></li>
<li class="toctree-l1"><a class="reference internal" href="../working_with_aiida/index.html#troubleshooting">Troubleshooting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../working_with_aiida/index.html#rest-api">REST API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../working_with_aiida/index.html#cookbook">Cookbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../import_export/index.html">Import and Export</a></li>
</ul>
<p class="caption"><span class="caption-text">Development</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../developer_guide/index.html">AiiDA design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../developer_guide/index.html#aiida-core">AiiDA core</a></li>
<li class="toctree-l1"><a class="reference internal" href="../developer_guide/index.html#aiida-plugins">AiiDA plugins</a></li>
</ul>
<p class="caption"><span class="caption-text">Tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../tutorial/index.html">StructureData</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial/index.html#pseudopotentials">Pseudopotentials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial/index.html#plugin-development">Plugin development</a></li>
</ul>
<p class="caption"><span class="caption-text">API reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="`aiida package &lt;https://aiida-core.readthedocs.io/en/latest/apidoc/aiida.html&gt;`_">`aiida package &lt;https://aiida-core.readthedocs.io/en/latest/apidoc/aiida.html&gt;`_</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">AiiDA</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>Workflows</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/concepts/workflows.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="workflows">
<span id="concepts-workflows"></span><h1>Workflows<a class="headerlink" href="#workflows" title="Permalink to this headline">¶</a></h1>
<p>A workflow in AiiDA is a process (see the <a class="reference internal" href="processes.html#concepts-processes"><span class="std std-ref">process section</span></a> for details) that calls other workflows and calculations and optionally <em>returns</em> data and as such can encode the logic of a typical scientific workflow.
Currently, there are two ways of implementing a workflow process:</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="#concepts-workfunctions"><span class="std std-ref">work functions</span></a></li>
<li><a class="reference internal" href="#concepts-workchains"><span class="std std-ref">work chains</span></a></li>
</ul>
</div></blockquote>
<p>The first one is the simplest of the two and is basically a python function that is magically transformed into a process.
This is ideal for workflows that are not very computationally intensive and can be easily implemented in a python function.
For more complex workflows, the work chain is a better alternative.
By chaining work chains and work functions together, that each can run other sub processes, we can define a workflow.
For simplicity, from here on out, we will use the terms, workflows, work chains and work functions interchangeably, as a ‘pars pro toto’ and ‘totum pro parte’.</p>
<p>In the following sections, both concepts will be explained but without going too much into detail on how to implement or run them.
For a more detailed exposé, please refer to the respective advanced sections on <a class="reference internal" href="../working/workflows.html#working-workfunctions"><span class="std std-ref">work functions</span></a> and <a class="reference internal" href="../working/workflows.html#working-workchains"><span class="std std-ref">work chains</span></a>.</p>
<div class="section" id="work-functions">
<span id="concepts-workfunctions"></span><h2>Work functions<a class="headerlink" href="#work-functions" title="Permalink to this headline">¶</a></h2>
<p>A work function is implemented just as a <a class="reference internal" href="calculations.html#concepts-calcfunctions"><span class="std std-ref">calculation function</span></a>, however, they have very distinct use cases.
Since the work function is a ‘workflow-like’ process, it can only <em>return</em> existing data, whereas the calculation function creates a ‘calculation-like’ process which can only <em>create</em> new data.
This difference is addressed in greater detail in the <a class="reference internal" href="processes.html#concepts-process-types"><span class="std std-ref">process</span></a> section and it is very important that you understand this distinction.</p>
<p>To explain the use of the <code class="docutils literal notranslate"><span class="pre">workfunction</span></code>, we will continue with the example of the <a class="reference internal" href="calculations.html#concepts-calcfunctions"><span class="std std-ref">calculation functions</span></a>, so before continuing, read that section first.
The example showed how the <code class="docutils literal notranslate"><span class="pre">calcfunction</span></code> decorator can be used to create two functions that, for three given integers, computes the sum of the first two which is then multiplied with the third, while keeping the provenance.
Even though the calculation functions ensured that the provenance of the data was kept, the logic of <em>who</em> called these functions was not explicitly kept.
From the provenance graph generated by the calculation functions, it is impossible to deduce of the functions where called straight after another in a single script, or whether first the <code class="docutils literal notranslate"><span class="pre">add</span></code> function was called and a long time later, the output was used as an input for the <code class="docutils literal notranslate"><span class="pre">multiply</span></code> call.
Capturing this logical provenance of the <em>sequence of calls</em> of processes is exactly what workflow-like processes, such as the <code class="docutils literal notranslate"><span class="pre">workfunction</span></code> are designed for.</p>
<p>Consider the following example, where we implement a function called <code class="docutils literal notranslate"><span class="pre">add_and_multiply</span></code> that we decorate with the <code class="docutils literal notranslate"><span class="pre">workfunction</span></code> decorator.</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">aiida.engine</span> <span class="k">import</span> <span class="n">calcfunction</span><span class="p">,</span> <span class="n">workfunction</span>
<span class="kn">from</span> <span class="nn">aiida.orm</span> <span class="k">import</span> <span class="n">Int</span>

<span class="nd">@calcfunction</span>
<span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Int</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>

<span class="nd">@calcfunction</span>
<span class="k">def</span> <span class="nf">multiply</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Int</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span>

<span class="nd">@workfunction</span>
<span class="k">def</span> <span class="nf">add_and_multiply</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
    <span class="nb">sum</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="n">product</span> <span class="o">=</span> <span class="n">multiply</span><span class="p">(</span><span class="nb">sum</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">product</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">add_and_multiply</span><span class="p">(</span><span class="n">Int</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">Int</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">Int</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
</pre></div>
</div>
<p>Instead of calling the calculation functions directly in the script, we call the work function, which then consecutively calls the calculation functions, passing the intermediate result from the first to the second.
If we look at the provenance graph generated by this example, we would see something like the following:</p>
<div class="figure" id="id1">
<span id="fig-work-functions-provenance-add-multiply-full"></span><img alt="../_images/add_multiply_calcfunction_full.png" src="../_images/add_multiply_calcfunction_full.png" />
<p class="caption"><span class="caption-number">Fig. 9 </span><span class="caption-text">The full provenance generated by the work function example</span></p>
</div>
<p>It is clear that this provenance graph contains a lot more information than the one for the calculation function example.
Whether this information is actually necessary or useful depends on the situation and is entirely up to the user, but there is a big advantage.
The strict separation between calculation-like and workflow-like processes and the different allowed links between them, as codified in the <a class="reference internal" href="provenance.html#concepts-provenance-implementation"><span class="std std-ref">provenance graph implementation</span></a>, may seem a bit excessive at a first glance and to new users.
However, the addition of this parallel yet distinct workflow layer, that represents the logical provenance, allows one to ignore all the details of the computation.
This is demonstrated by the provenance graph below, which is the exact same as the one before, except only data and workflow nodes are shown:</p>
<div class="figure" id="id2">
<span id="fig-work-functions-provenance-add-multiply-logical"></span><img alt="../_images/add_multiply_calcfunction_logical.png" src="../_images/add_multiply_calcfunction_logical.png" />
<p class="caption"><span class="caption-number">Fig. 10 </span><span class="caption-text">The ‘logical’ provenance generated by the work function example, where only the workflow and data nodes, with their links, are shown</span></p>
</div>
<p>With this reduced representation, the big picture of how the original inputs led to the final result becomes immediately clear.
Conversely, none of the actual data provenance is lost.
In the figure below, all the workflow nodes are omitted and what we end up with is the exact same provenance graph in <a class="reference internal" href="calculations.html#fig-calculation-functions-provenance-add-multiply"><span class="std std-numref">Fig. 7</span></a> of the <a class="reference internal" href="calculations.html#concepts-calcfunctions"><span class="std std-ref">original example</span></a> that only used calculation functions.</p>
<div class="figure" id="id3">
<span id="fig-work-functions-provenance-add-multiply-data"></span><img alt="../_images/add_multiply_calcfunction_data.png" src="../_images/add_multiply_calcfunction_data.png" />
<p class="caption"><span class="caption-number">Fig. 11 </span><span class="caption-text">The ‘data’ provenance generated by the work function example, where only the calculation and data nodes, with their links, are shown</span></p>
</div>
<p>In this simple example, the power of being able to select what part of the provenance graph one is interested in is obviously limited.
But workflows can quickly become complex and deeply nested at which point the ability to ‘hide’ parts of the provenance graph in a transparent way, becomes invaluable.</p>
<p>In addition to the ‘orchestration’ role that the work function can fullfill, it can also be used as a filter or selection function.
Imagine that you want to write a process function that takes a set of input integer nodes and returns the one with the highest value.
We cannot employ the <code class="docutils literal notranslate"><span class="pre">calcfunction</span></code> for this, because it would have to return one of its input nodes, which is explicitly forbidden.
However, for the <code class="docutils literal notranslate"><span class="pre">workfunction</span></code>, returning existing nodes, even one of its inputs, is perfectly fine.
An example implementation might look like the following:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">aiida.engine</span> <span class="k">import</span> <span class="n">workfunction</span>
<span class="kn">from</span> <span class="nn">aiida.orm</span> <span class="k">import</span> <span class="n">Int</span>

<span class="nd">@workfunction</span>
<span class="k">def</span> <span class="nf">maximum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">])[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">maximum</span><span class="p">(</span><span class="n">Int</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">Int</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">Int</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
</pre></div>
</div>
<p>The work function above will return the input node <code class="docutils literal notranslate"><span class="pre">x</span></code> as one of its outputs as it has the highest value.
The provenance of the execution of this select work function will look like the following:</p>
<div class="figure" id="id4">
<span id="fig-work-functions-provenance-select"></span><img alt="../_images/select_workfunction.png" src="../_images/select_workfunction.png" />
<p class="caption"><span class="caption-number">Fig. 12 </span><span class="caption-text">The provenance generated by the work function that selects one of its input nodes</span></p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">It is important to realize once again, that in the work function examples given above, all the nodes returned by the work functions are <em>already stored</em>.
That is to say, they were either created by a calculation function called by the work function or were passed in as one of the inputs.
This is no accident, as the work function <strong>can</strong> only return stored nodes.
Trying to return a node that was created by the work function itself, will raise an exception.
A more detailed explanation for the reasoning behind this design choice you can find in the documentation on the various <a class="reference internal" href="processes.html#concepts-process-types"><span class="std std-ref">process types</span></a> present in AiiDA and the <a class="reference internal" href="provenance.html#concepts-provenance-implementation"><span class="std std-ref">implementation of the provenance graph</span></a>.</p>
</div>
</div>
<div class="section" id="work-chains">
<span id="concepts-workchains"></span><h2>Work chains<a class="headerlink" href="#work-chains" title="Permalink to this headline">¶</a></h2>
<div class="section" id="why">
<h3>Why?<a class="headerlink" href="#why" title="Permalink to this headline">¶</a></h3>
<p>Now that we have demonstrated how easily <code class="docutils literal notranslate"><span class="pre">workfunctions</span></code> can be used to write your workflow that automatically keeps the provenance, it is time to confess that work functions are not perfect and have their shortcomings.
In the simple example of adding and multiplying numbers, the time to execute the functions is very short, but imagine that you are performing a more costly calculation, e.g. you want to run an actual <code class="docutils literal notranslate"><span class="pre">CalcJob</span></code> that will be submitted to the scheduler and may run for a long time.
If anywhere during the chain, the workflow is interrupted, for whatever reason, all progress is lost.
There are no ‘checkpoints’, so to speak, by simply chaining work functions together.</p>
<p>But fret not!
To tackle this problem, AiiDA defines the concept of the work chain.
As the name suggests, this construct is a way to chain multiple logical steps of a workflow together in a way that allows to save the progress between those steps as soon as they are successfully completed.
The work chain is therefore the preferred solution for parts of the workflow that involve more expensive and complex calculations.
To define a work chain, AiiDA provides the <a class="reference internal" href="../apidoc/aiida.engine.processes.workchains.html#aiida.engine.processes.workchains.workchain.WorkChain" title="aiida.engine.processes.workchains.workchain.WorkChain"><code class="xref py py-class docutils literal notranslate"><span class="pre">WorkChain</span></code></a> class.</p>
</div>
<div class="section" id="implementation">
<h3>Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline">¶</a></h3>
<p>If we were to reimplement our work function solution of the simple example problem of the previous section, but this time using a work chain, it would look something like the following:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">aiida.engine</span> <span class="k">import</span> <span class="n">WorkChain</span><span class="p">,</span> <span class="n">calcfunction</span>
<span class="kn">from</span> <span class="nn">aiida.orm</span> <span class="k">import</span> <span class="n">Int</span>

<span class="nd">@calcfunction</span>
<span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Int</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>

<span class="nd">@calcfunction</span>
<span class="k">def</span> <span class="nf">multiply</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Int</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">AddAndMultiplyWorkChain</span><span class="p">(</span><span class="n">WorkChain</span><span class="p">):</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">define</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">spec</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">AddAndMultiplyWorkChain</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="n">define</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">input</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">input</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">input</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">)</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">outline</span><span class="p">(</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">add</span><span class="p">,</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">multiply</span><span class="p">,</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">results</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">output</span><span class="p">(</span><span class="s1">&#39;result&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">sum</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">multiply</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">product</span> <span class="o">=</span> <span class="n">multiply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">sum</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">results</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">out</span><span class="p">(</span><span class="s1">&#39;result&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">product</span><span class="p">)</span>
</pre></div>
</div>
<p>Don’t be intimidated by all the code in this snippet.
The point of this example is not to explain the exact syntax, which will be done in greater detail in the <a class="reference internal" href="../working/workflows.html#working-workchains"><span class="std std-ref">advanced workflows</span></a> section, but to merely introduce the concept of the work chain.
The core attributes of a work chain are defined by its <a class="reference internal" href="../working/processes.html#working-processes-spec"><span class="std std-ref">process specification</span></a> which is setup in the <a class="reference internal" href="../apidoc/aiida.engine.processes.html#aiida.engine.processes.process.Process.define" title="aiida.engine.processes.process.Process.define"><code class="xref py py-meth docutils literal notranslate"><span class="pre">define()</span></code></a> method.
The only thing you need to notice here is that it defines the <em>inputs</em> that the work chain takes, its logical <em>outline</em> and the <em>outputs</em> that it will produce.
The steps of the outline are implemented as class methods of the work chain.
The <code class="docutils literal notranslate"><span class="pre">add</span></code> step will add the first two integers by calling the <code class="docutils literal notranslate"><span class="pre">add</span></code> calculation function, and store the sum temporarily in the <a class="reference internal" href="../working/workflows.html#working-workchains-context"><span class="std std-ref">context</span></a>.
The next step in the outline, <code class="docutils literal notranslate"><span class="pre">multiply</span></code>, will take the sum stored in the context that was computed in the first outline step and call the <code class="docutils literal notranslate"><span class="pre">multiply</span></code> calculation function with the third input integer.
Finally, the <code class="docutils literal notranslate"><span class="pre">result</span></code> step will take the product produced by the previous step and record it as an output of the work chain.
The resulting provenance when we run this work chain looks like the following:</p>
<div class="figure" id="id5">
<span id="fig-work-chains-provenance-add-multiply-workchain-full"></span><img alt="../_images/add_multiply_workchain_full.png" src="../_images/add_multiply_workchain_full.png" />
<p class="caption"><span class="caption-number">Fig. 13 </span><span class="caption-text">The provenance generated by the work chain example calling calculation functions to perform the addition and multiplication.</span></p>
</div>
<p>As you can see, the produced provenance graph is identical to that of <a class="reference internal" href="#fig-work-functions-provenance-add-multiply-full"><span class="std std-numref">Fig. 9</span></a> that was produced by the work function solution, except that the workflow node is a work chain instead of a work function node.
Full data provenance is kept as the calculation of the sum and the product through the work chain are represented explicitly by the calculation nodes of the <code class="docutils literal notranslate"><span class="pre">add</span></code> and <code class="docutils literal notranslate"><span class="pre">multiply</span></code> calculation functions that it called.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The usage of calculation functions for the computation of the sum and the product is not an accident but a concious design choice.
Since work chains are ‘workflow’-like process and as such cannot ‘create’ data, performing the calculations directly in the work chain outline steps itself would lose data provenance.</p>
</div>
<p>To illustrate what it means for worklow processes not being able to ‘create’ new data and how doing so causes a loss of data provenance, let’s change the previous implementation to perform the sum and product in the work chain outline steps itself, instead of calling the calculation functions.</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">aiida.engine</span> <span class="k">import</span> <span class="n">WorkChain</span>
<span class="kn">from</span> <span class="nn">aiida.orm</span> <span class="k">import</span> <span class="n">Int</span>


<span class="k">class</span> <span class="nc">AddAndMultiplyWorkChain</span><span class="p">(</span><span class="n">WorkChain</span><span class="p">):</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">define</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">spec</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">AddAndMultiplyWorkChain</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="n">define</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">input</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">input</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">input</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">)</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">outline</span><span class="p">(</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">add</span><span class="p">,</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">multiply</span><span class="p">,</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">results</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">output</span><span class="p">(</span><span class="s1">&#39;result&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">sum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">y</span>

    <span class="k">def</span> <span class="nf">multiply</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">product</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">sum</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">z</span>

    <span class="k">def</span> <span class="nf">results</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">out</span><span class="p">(</span><span class="s1">&#39;result&#39;</span><span class="p">,</span> <span class="n">Int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">product</span><span class="p">))</span>
</pre></div>
</div>
<p>The resulting provenance would look like the following:</p>
<div class="figure" id="id6">
<span id="fig-work-chains-provenance-add-multiply-workchain-logical"></span><img alt="../_images/add_multiply_workchain_logical.png" src="../_images/add_multiply_workchain_logical.png" />
<p class="caption"><span class="caption-number">Fig. 14 </span><span class="caption-text">The provenance generated by the work chain example that computers the sum and product directly in its outline steps instead of delegating it to calculation functions.</span></p>
</div>
<p>Note how, in contrast with the provenance of the previous correct solution from <a class="reference internal" href="#fig-work-chains-provenance-add-multiply-workchain-full"><span class="std std-numref">Fig. 13</span></a>, there are no explicit calculation nodes representing the computation of the sum and the product.
Instead, all that computation is abstracted and represented by the single workflow node that represents the execution of the work chain.
The logic inside of those outline steps is then ‘hidden’ or ‘encapsulated’ in the provenance graph by a single workflow node.
Additionally, the output node representing the final product, only has a <code class="docutils literal notranslate"><span class="pre">return</span></code> link, even though it was ‘created’ by the work chain.
This is because <a class="reference internal" href="../working/workflows.html#working-workfunctions-returning-data"><span class="std std-ref">workflow processes do not have the capacity to create new nodes</span></a>, and therefore in a sense in this example, the data provenance is lost.</p>
<p>An important thing to remember is that <em>any computation</em> that happens in the body of outline steps of a work chain, will not be explicitly represented but will be encapsulated by a single node in the graph that represents that work chain execution.
Whether that loss of data provenance is relevant depends on the use case and is left to the developer of the workflow.
These two examples demonstrate that AiiDA does not force any particular method but allows the user to choose exactly what level of granularity they would like to maintain in the provenance.
However, the rule of thumb is that if you want to reduce the loss, or ‘hiding’ of provenance to a minimum, one should keep real computation within the body of work functions and work chains to a minimum and delegate that to calculations.
For any real computational work that is relevant to the data provenance, it is better to implement it in explicit calculation processes, usually a separate calculation function.</p>
</div>
<div class="section" id="advantages">
<h3>Advantages<a class="headerlink" href="#advantages" title="Permalink to this headline">¶</a></h3>
<p>The work chain solution to the add-multiply problem, requires significantly more code compared to the work function solution presented in the beginning of this section.
Why should one bother using the work chain then?
The advantages for this trivial example may be difficult to see, but imagine that the logic of the workflow becomes more complicated and the calculations become more intensive.
The process specification of the work chain provides a central way of defining the inputs and outputs, making it easy to see at a glance how the work chain operates.
In addition, the <code class="docutils literal notranslate"><span class="pre">outline</span></code> can give a succinct summary of the logical steps that the work chain will perform, all of which a work function does not have.
The outline in this example was trivially simple, but the <a class="reference internal" href="../working/workflows.html#working-workchains"><span class="std std-ref">advanced work chain development section</span></a> will show how complex logic can be implemented directly in the process specification.
The process specification also makes it easy to ‘wrap’ existing work chains into more complex work chains through the <a class="reference internal" href="../working/workflows.html#working-workchains-expose-inputs-outputs"><span class="std std-ref">expose functionality</span></a>.</p>
<p>Finally, as mentioned before, the work chain provides the possibility of checkpoints, i.e. to save progress at certain points from which the computation can be continued after it had been interrupted.
The state of the work chain is saved after each outline step.
If expensive calculation jobs are performed in an individual outline step, they will be saved as soon as they finish.
This is impossible for work functions and if it were to be interrupted before <em>all</em> the computations had been completed, all intermediate progress would be lost.
The rule of thumb therefore is, as soon as the worfklow becomes only slightly complex or computationally intensive, preference should be given to <a class="reference internal" href="#concepts-workchains"><span class="std std-ref">work chains</span></a> and <a class="reference internal" href="calculations.html#concepts-calcjobs"><span class="std std-ref">calculation jobs</span></a>.</p>
<p>This was a very quick overview of the intended use is of work chain works and how they work, but of course it has a lot more features.
To learn how to write work chains for real life problems, continue reading at the <a class="reference internal" href="../working/workflows.html#working-workchains"><span class="std std-ref">work chain development</span></a> section, but before you do, read the following part on when to use a work function and when it is better to use a work chain.</p>
</div>
</div>
<div class="section" id="when-to-use-which">
<h2>When to use which<a class="headerlink" href="#when-to-use-which" title="Permalink to this headline">¶</a></h2>
<p>Now that we know how the two workflow components, workflows and work chains, work in AiiDA, you might wonder: when should I use which one?
For simple operations that do not take long, the simplicity of the work function may be all you need, so by all means use it.
However, a good rule of thumb is that as soon as the code is expected to take longer, for example when you want to launch a <a class="reference internal" href="calculations.html#concepts-calcjobs"><span class="std std-ref">calculation job</span></a> or another complex workflow, it is always best to go for the work chain.
The automatic checkpointing, which guarantees that work between steps is saved, becomes very important.
But the work chain offers a lot more features than just checkpointing that may make it more preferable over the work function, which you can read about in the advanced <a class="reference internal" href="../working/workflows.html#working-workchains"><span class="std std-ref">work chain development</span></a> section.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../working/processes.html" class="btn btn-neutral float-right" title="Processes" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="calculations.html" class="btn btn-neutral float-left" title="Calculations" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, ECOLE POLYTECHNIQUE FEDERALE DE LAUSANNE (Theory and Simulation of Materials (THEOS) and National Centre for Computational Design and Discovery of Novel Materials (NCCR MARVEL)), Switzerland and ROBERT BOSCH LLC, USA. All rights reserved

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>