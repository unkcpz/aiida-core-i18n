# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2020, ECOLE POLYTECHNIQUE FEDERALE DE LAUSANNE (Theory and Simulation of Materials (THEOS) and National Centre for Computational Design and Discovery of Novel Materials (NCCR MARVEL)), Switzerland and ROBERT BOSCH LLC, USA. All rights reserved
# This file is distributed under the same license as the AiiDA package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Guoyu(Gloria) YANG <ygy.11@163.com>, 2020
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: AiiDA 1.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-04-29 08:46+0000\n"
"PO-Revision-Date: 2020-07-01 16:11+0000\n"
"Last-Translator: Guoyu(Gloria) YANG <ygy.11@163.com>, 2020\n"
"Language-Team: Chinese (China) (https://www.transifex.com/aiidateam/teams/98967/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../docs/source/howto/cookbook.rst:5
msgid "Cookbook"
msgstr ""

#: ../docs/source/howto/cookbook.rst:7
msgid ""
"This how-to page collects useful short scripts and code snippets that may be"
" useful in the everyday usage of AiiDA."
msgstr ""

#: ../docs/source/howto/cookbook.rst:11
msgid "Checking the queued jobs on a scheduler"
msgstr ""

#: ../docs/source/howto/cookbook.rst:13
msgid ""
"If you want to know if which jobs are currently on the scheduler (e.g. to "
"dynamically decide on which computer to submit, or to delay submission, "
"etc.) you can use the following script as an example:"
msgstr ""

#: ../docs/source/howto/cookbook.rst:58
msgid "Use ``verdi run`` to execute it:"
msgstr ""

#: ../docs/source/howto/cookbook.rst:66
msgid ""
"Every time you call the function, two SSH connections are opened! So be "
"careful and run this function sparsely, or your supercomputer center might "
"block your account. A possible work around to this limitation is to pass the"
" transport as a parameter, and pass it in so that it can be reused."
msgstr ""

#: ../docs/source/howto/cookbook.rst:70
msgid "An example output would be::"
msgstr ""

#: ../docs/source/howto/cookbook.rst:93
msgid "Getting an ``AuthInfo`` knowing the computer and the user"
msgstr ""

#: ../docs/source/howto/cookbook.rst:95
msgid ""
"To open a transport to a computer, you need the corresponding "
":class:`~aiida.orm.authinfos.AuthInfo` object, which contains the required "
"information for a specific user. Once you have the relevant "
":class:`~aiida.orm.computers.Computer` and :class:`~aiida.orm.users.User` "
"objects, you can obtain as follows:"
msgstr ""

#: ../docs/source/howto/cookbook.rst:102
msgid "Here is, as an example, a useful utility function:"
msgstr ""

#: ../docs/source/howto/cookbook.rst:112
msgid "that you can then use, for instance, as follows:"
msgstr ""

#: ../docs/source/howto/data.rst:5
msgid "How to work with data"
msgstr ""

#: ../docs/source/howto/data.rst:11
msgid "Importing data"
msgstr ""

#: ../docs/source/howto/data.rst:13
msgid ""
"AiiDA allows users to export data from their database into an export archive"
" file, which can be imported into any other AiiDA database. If you have an "
"AiiDA export archive that you would like to import, you can use the ``verdi "
"archive import`` command (see :ref:`the reference section<reference:command-"
"line:verdi-import>` for details)."
msgstr ""

#: ../docs/source/howto/data.rst:16
msgid ""
"For information on exporting and importing data via AiiDA archives, see "
":ref:`\"How to share data\"<how-to:share:archives>`."
msgstr ""

#: ../docs/source/howto/data.rst:18
msgid ""
"If, instead, you have existing data that are not yet part of an AiiDA export"
" archive, such as files, folders, tabular data, arrays or any other kind of "
"data, this how-to guide will show you how to import them into AiiDA."
msgstr ""

#: ../docs/source/howto/data.rst:20
msgid ""
"To store any piece of data in AiiDA, it needs to be wrapped in a "
":py:class:`~aiida.orm.nodes.data.Data` node, such that it can be represented"
" in the :ref:`provenance graph <topics:provenance>`. There are different "
"varieties, or subclasses, of this ``Data`` class that are suited for "
"different types of data. AiiDA ships with a number of built-in data types. "
"You can list these using the :ref:`verdi plugin<reference:command-line"
":verdi-plugin>` command. Executing ``verdi plugin list aiida.data`` should "
"display something like::"
msgstr ""

#: ../docs/source/howto/data.rst:38
msgid ""
"As the output suggests, you can get more information about each type by "
"appending the name to the command, for example, ``verdi plugin list "
"aiida.data singlefile``::"
msgstr ""

#: ../docs/source/howto/data.rst:56
msgid ""
"As you can see, the ``singlefile`` type corresponds to the "
":py:class:`~aiida.orm.nodes.data.singlefile.SinglefileData` class and is "
"designed to wrap a single file that is stored on your local filesystem. If "
"you have such a file that you would like to store in AiiDA, you can use the "
"``verdi shell`` to create it:"
msgstr ""

#: ../docs/source/howto/data.rst:65
msgid ""
"The first step is to load the class that corresponds to the data type, which"
" you do by passing the name (listed by ``verdi plugin list aiida.data``) to "
"the :py:class:`~aiida.plugins.factories.DataFactory`. Then we just construct"
" an instance of that class, passing the file of interest as an argument."
msgstr ""

#: ../docs/source/howto/data.rst:68
msgid ""
"The exact manner of constructing an instance of any particular data type is "
"type dependent. Use the ``verdi plugin list aiida.data <ENTRY_POINT>`` "
"command to get more information for any specific type."
msgstr ""

#: ../docs/source/howto/data.rst:71
msgid ""
"Note that after construction, you will get an *unstored* node. This means "
"that at this point your data is not yet stored in the database and you can "
"first inspect it and optionally modify it. If you are happy with the "
"results, you can store the new data permanently by calling the "
":py:meth:`~aiida.orm.nodes.node.Node.store` method. Every node is assigned a"
" Universal Unique Identifier (UUID) upon creation and once stored it is also"
" assigned a primary key (PK), which can be retrieved through the "
"``node.uuid`` and ``node.pk`` properties, respectively. You can use these "
"identifiers to reference and or retrieve a node. Ways to find and retrieve "
"data that have previously been imported are described in section :ref:`\"How"
" to find data\"<how-to:data:find>`."
msgstr ""

#: ../docs/source/howto/data.rst:78
msgid ""
"If none of the currently available data types, as listed by ``verdi plugin "
"list``, seem to fit your needs, you can also create your own custom type. "
"For details refer to the next section :ref:`\"How to add support for custom "
"data types\"<topics:data_types:plugin>`."
msgstr ""

#: ../docs/source/howto/data.rst:85
msgid "Finding and querying for data"
msgstr ""

#: ../docs/source/howto/data.rst:87
msgid ""
"Once you have successfully completed a series of workflows for your project,"
" or have imported a dataset you are interested in, you want to quickly find "
"the data that is relevant for your analysis. The data in an AiiDA database "
"is stored as a graph of connected entities, which can be easily *queried* "
"with the :class:`~aiida.orm.querybuilder.QueryBuilder` class."
msgstr ""

#: ../docs/source/howto/data.rst:90
msgid ""
"The :class:`~aiida.orm.querybuilder.QueryBuilder` lets you query your AiiDA "
"database independently of the backend used under the hood. Before starting "
"to write a query, it helps to:"
msgstr ""

#: ../docs/source/howto/data.rst:93
msgid ""
"Know what you want to query for. In the language of databases, you need to "
"tell the backend what *entity* you are looking for and optionally which of "
"its properties you want to *project*. For example, you might be interested "
"in the label of a calculation and the PK's of all its outputs."
msgstr ""

#: ../docs/source/howto/data.rst:96
msgid ""
"Know the relationships between entities you are interested in. Nodes of an "
"AiiDA graph (vertices) are connected with links (edges). A node can for "
"example be either the input or output of another node, but also an ancestor "
"or a descendant."
msgstr ""

#: ../docs/source/howto/data.rst:99
msgid "Know how you want to filter the results of your query."
msgstr ""

#: ../docs/source/howto/data.rst:101
msgid ""
"Once you are clear about what you want and how you can get it, the "
":class:`~aiida.orm.querybuilder.QueryBuilder` will build an SQL-query for "
"you."
msgstr ""

#: ../docs/source/howto/data.rst:103
msgid ""
"There are two ways of using the "
":class:`~aiida.orm.querybuilder.QueryBuilder`:"
msgstr ""

#: ../docs/source/howto/data.rst:105
msgid ""
"In the *appender* method, you construct your query step by step using the "
"``QueryBuilder.append()`` method."
msgstr ""

#: ../docs/source/howto/data.rst:106
msgid ""
"In the *queryhelp* approach, you construct a dictionary that defines your "
"query and pass it to the :class:`~aiida.orm.querybuilder.QueryBuilder`."
msgstr ""

#: ../docs/source/howto/data.rst:108
msgid ""
"Both APIs provide the same functionality - the appender method may be more "
"suitable for interactive use, e.g., in the ``verdi shell``, whereas the "
"queryhelp method can be useful in scripting. In this section we will focus "
"on the basics of the appender method. For more advanced queries or more "
"details on the queryhelp, see the :ref:`topics section on advanced querying "
"<topics:database:advancedquery>`."
msgstr ""

#: ../docs/source/howto/data.rst:115
msgid "Selecting entities"
msgstr ""

#: ../docs/source/howto/data.rst:117
msgid ""
"Using the ``append()`` method of the "
":class:`~aiida.orm.querybuilder.QueryBuilder`, you can query for the "
"entities you are interested in. Suppose you want to query for calculation "
"job nodes in your database:"
msgstr ""

#: ../docs/source/howto/data.rst:126
msgid ""
"If you are interested in instances of different classes, you can also pass "
"an iterable of classes. However, they have to be of the same ORM-type (e.g. "
"all have to be subclasses of :class:`~aiida.orm.nodes.node.Node`):"
msgstr ""

#: ../docs/source/howto/data.rst:136
msgid ""
"Processes have both a run-time "
":class:`~aiida.engine.processes.process.Process` that executes them and a "
":class:`~aiida.orm.nodes.node.Node` that stores their data in the database "
"(see the :ref:`corresponding topics "
"section<topics:processes:concepts:types>` for a detailed explanation). The "
":class:`~aiida.orm.querybuilder.QueryBuilder` allows you to pass either the "
":class:`~aiida.orm.nodes.node.Node` class (e.g. "
":class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode`) or the "
":class:`~aiida.engine.processes.process.Process` class (e.g. "
":class:`~aiida.engine.processes.calcjobs.calcjob.CalcJob`), which will "
"automatically select the right entity for the query. Using either "
":class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode` or "
":class:`~aiida.engine.processes.calcjobs.calcjob.CalcJob` will produce the "
"same query results."
msgstr ""

#: ../docs/source/howto/data.rst:143
msgid "Retrieving results"
msgstr ""

#: ../docs/source/howto/data.rst:145
msgid ""
"Once you have *appended* the entity you want to query for to the "
":class:`~aiida.orm.querybuilder.QueryBuilder`, the next question is how to "
"get the results. There are several ways to obtain data from a query:"
msgstr ""

#: ../docs/source/howto/data.rst:159
msgid ""
"In case you are working with a large dataset, you can also return your query"
" as a generator:"
msgstr ""

#: ../docs/source/howto/data.rst:167
msgid ""
"This will retrieve the data in batches, and you can start working with the "
"data before the query has completely finished. For example, you can iterate "
"over the results of your query in a for loop:"
msgstr ""

#: ../docs/source/howto/data.rst:178
msgid "Filters"
msgstr ""

#: ../docs/source/howto/data.rst:180
msgid ""
"Usually you do not want to query for *all* entities of a certain class, but "
"rather *filter* the results based on certain properties. Suppose you do not "
"want all :class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode` "
"data, but only those that are ``finished``:"
msgstr ""

#: ../docs/source/howto/data.rst:193
msgid ""
"You can apply multiple filters to one entity in a query. Say you are "
"interested in all calculation jobs in your database that are ``finished`` "
"**and** have ``exit_status == 0``:"
msgstr ""

#: ../docs/source/howto/data.rst:207
msgid ""
"In case you want to query for calculation jobs that satisfy one of these "
"conditions, you can use the ``or`` operator:"
msgstr ""

#: ../docs/source/howto/data.rst:222
msgid ""
"If we had written ``and`` instead of ``or`` in the example above, we would "
"have performed the exact same query as the previous one, because ``and`` is "
"the default behavior if you provide several filters as key-value pairs in a "
"dictionary to the ``filters`` argument. In case you want all calculation "
"jobs with state ``finished`` or ``excepted``, you can also use the ``in`` "
"operator:"
msgstr ""

#: ../docs/source/howto/data.rst:235
msgid ""
"You can negate a filter by adding an exclamation mark in front of the "
"operator. So, to query for all calculation jobs that are not a ``finished`` "
"or ``excepted`` state:"
msgstr ""

#: ../docs/source/howto/data.rst:250
msgid ""
"The above rule applies to all operators. For example, you can check non-"
"equality with ``!==``, since this is the equality operator (``==``) with a "
"negation prepended."
msgstr ""

#: ../docs/source/howto/data.rst:253
msgid ""
"A complete list of all available operators can be found in the "
":ref:`advanced querying "
"section<topics:database:advancedquery:tables:operators>`."
msgstr ""

#: ../docs/source/howto/data.rst:258
msgid "Relationships"
msgstr ""

#: ../docs/source/howto/data.rst:260
msgid ""
"It is possible to query for data based on its relationship to another entity"
" in the database. Imagine you are not interested in the calculation jobs "
"themselves, but in one of the outputs they create. You can build upon your "
"initial query for all  "
":class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode`'s in the "
"database using the relationship of the output to the first step in the "
"query:"
msgstr ""

#: ../docs/source/howto/data.rst:270
msgid ""
"In the first ``append`` call, we query for all  "
":class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode`'s in the "
"database, and *tag* this step with the *unique* identifier ``'calcjob'``. "
"Next, we look for all ``Int`` nodes that are an output of the  "
":class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode`'s found in"
" the first step, using the ``with_incoming`` relationship argument. The "
"``Int`` node was created by the  "
":class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode` and as "
"such has an *incoming* create link."
msgstr ""

#: ../docs/source/howto/data.rst:274
msgid ""
"In the context of our query, we are building a *path* consisting of "
"*vertices* (i.e. the entities we query for) connected by *edges* defined by "
"the relationships between them. The complete set of all possible "
"relationships you can use query for, as well as the entities that they "
"connect to, can be found in the :ref:`advanced querying "
"section<topics:database:advancedquery:tables:relationships>`."
msgstr ""

#: ../docs/source/howto/data.rst:279
msgid ""
"The ``tag`` identifier can be any alphanumeric string, it is simply a label "
"used to refer to a previous vertex along the query path when defining a "
"relationship."
msgstr ""

#: ../docs/source/howto/data.rst:284
msgid "Projections"
msgstr ""

#: ../docs/source/howto/data.rst:286
msgid ""
"By default, the :class:`~aiida.orm.querybuilder.QueryBuilder` returns the "
"instances of the entities corresponding to the final append to the query "
"path. For example:"
msgstr ""

#: ../docs/source/howto/data.rst:295
msgid ""
"The above code snippet will return all ``Int`` nodes that are outputs of any"
"  :class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode`. "
"However, you can also *project* other entities in the path by adding "
"``project='*'`` to the corresponding ``append()`` call:"
msgstr ""

#: ../docs/source/howto/data.rst:304
msgid ""
"This will return all  "
":class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode`'s that "
"have an ``Int`` output node."
msgstr ""

#: ../docs/source/howto/data.rst:306
msgid ""
"However, in many cases we are not interested in the entities themselves, but"
" rather their PK, UUID, *attributes* or some other piece of information "
"stored by the entity. This can be achieved by providing the corresponding "
"*column* to the ``project`` keyword argument:"
msgstr ""

#: ../docs/source/howto/data.rst:315
msgid ""
"In the above example, executing the query returns all *PK's* of the ``Int`` "
"nodes which are outputs of all  "
":class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode`'s in the "
"database. Moreover, you can project more than one piece of information for "
"one vertex by providing a list:"
msgstr ""

#: ../docs/source/howto/data.rst:324
msgid ""
"For the query above, ``qb.all()`` will return a list of lists, for which "
"each element corresponds to one entity and contains two items: the PK of the"
" ``Int`` node and its value. Finally, you can project information for "
"multiple vertices along the query path:"
msgstr ""

#: ../docs/source/howto/data.rst:333
msgid ""
"All projections must start with one of the *columns* of the entities in the "
"database, or project the instances themselves using ``'*'``. Examples of "
"columns we have encountered so far are ``id``, ``uuid`` and ``attributes``. "
"If the column is a dictionary, you can expand the dictionary values using a "
"dot notation, as we have done in the previous example to obtain the "
"``attributes.value``. This can be used to project the values of nested "
"dictionaries as well."
msgstr ""

#: ../docs/source/howto/data.rst:340
msgid ""
"Be aware that for consistency, ``QueryBuilder.all()`` / ``iterall()`` always"
" returns a list of lists, even if you only project one property of a single "
"entity. Use ``QueryBuilder.all(flat=True)`` to return the query result as a "
"flat list in this case."
msgstr ""

#: ../docs/source/howto/data.rst:343
msgid ""
"As mentioned in the beginning, this section provides only a brief "
"introduction to the :class:`~aiida.orm.querybuilder.QueryBuilder`'s basic "
"functionality. To learn about more advanced queries, please see :ref:`the "
"corresponding topics section<topics:database:advancedquery>`."
msgstr ""

#: ../docs/source/howto/data.rst:350
msgid "Organizing data"
msgstr ""

#: ../docs/source/howto/data.rst:355
msgid "How to group nodes"
msgstr ""

#: ../docs/source/howto/data.rst:357
msgid ""
"AiiDA's database is great for automatically storing all your data, but "
"sometimes it can be tricky to navigate this flat data store. To create some "
"order in this mass of data, you can *group* sets of nodes together, just as "
"you would with files in folders on your filesystem. A folder, in this "
"analogy, is represented by the :py:class:`~aiida.orm.groups.Group` class. "
"Each group instance can hold any amount of nodes and any node can be "
"contained in any number of groups. A typical use case is to store all nodes "
"that share a common property in a single group."
msgstr ""

#: ../docs/source/howto/data.rst:363
msgid ""
"Below we show how to perform a typical set of operations one may want to "
"perform with groups."
msgstr ""

#: ../docs/source/howto/data.rst:366
msgid "Create a new group"
msgstr ""

#: ../docs/source/howto/data.rst:368 ../docs/source/howto/data.rst:432
#: ../docs/source/howto/data.rst:450 ../docs/source/howto/data.rst:484
#: ../docs/source/howto/data.rst:502 ../docs/source/howto/data.rst:525
msgid "From the command line interface:"
msgstr ""

#: ../docs/source/howto/data.rst:374 ../docs/source/howto/data.rst:457
#: ../docs/source/howto/data.rst:491 ../docs/source/howto/data.rst:532
msgid "From the Python interface:"
msgstr ""

#: ../docs/source/howto/data.rst:385
msgid "List available groups"
msgstr ""

#: ../docs/source/howto/data.rst:387
msgid "Example:"
msgstr ""

#: ../docs/source/howto/data.rst:393
msgid ""
"Groups come in different types, indicated by their type string. By default "
"``verdi group list`` only shows groups of the type *core*. In case you want "
"to show groups of another type use ``-T/--type-string`` option. If you want "
"to show groups of all types, use the ``-a/--all-types`` option."
msgstr ""

#: ../docs/source/howto/data.rst:398
msgid "For example, to list groups of type ``core.auto``, use:"
msgstr ""

#: ../docs/source/howto/data.rst:404
msgid ""
"Similarly, we can use the ``type_string`` key to filter groups with the "
"``QueryBuilder``:"
msgstr ""

#: ../docs/source/howto/data.rst:415
msgid "Add nodes to a group"
msgstr ""

#: ../docs/source/howto/data.rst:416
msgid ""
"Once the ``test_group`` has been created, we can add nodes to it. For "
"example, to add a node with ``pk=1`` to the group we could either use the "
"command line interface:"
msgstr ""

#: ../docs/source/howto/data.rst:424
msgid "Or the Python interface:"
msgstr ""

#: ../docs/source/howto/data.rst:431
msgid "Show information about a group"
msgstr ""

#: ../docs/source/howto/data.rst:449
msgid "Remove nodes from a group"
msgstr ""

#: ../docs/source/howto/data.rst:465
msgid ""
"Alternatively, you might want to remove *all* nodes from the group. In the "
"command line you just need to add ``-c/--clear`` option to ``verdi group "
"remove-nodes ..``"
msgstr ""

#: ../docs/source/howto/data.rst:473
msgid ""
"In the Python interface you can use ``.clear()`` method to achieve the same "
"goal:"
msgstr ""

#: ../docs/source/howto/data.rst:483
msgid "Rename a group"
msgstr ""

#: ../docs/source/howto/data.rst:501
msgid "Delete a group"
msgstr ""

#: ../docs/source/howto/data.rst:510
msgid ""
"Any deletion operation related to groups, by default, will not affect the "
"nodes themselves. For example if you delete a group, the nodes that belonged"
" to the group will remain in the database. The same happens if you remove "
"nodes from the group -- they will remain in the database but won't belong to"
" the group anymore."
msgstr ""

#: ../docs/source/howto/data.rst:514
msgid ""
"If you also wish to delete the nodes, when deleting the group, use the "
"``--delete-nodes`` option:"
msgstr ""

#: ../docs/source/howto/data.rst:521
msgid "Copy one group into another"
msgstr ""

#: ../docs/source/howto/data.rst:522
msgid ""
"This operation will copy the nodes of the source group into the destination "
"group. If the destination group does not yet exist, it will be created "
"automatically."
msgstr ""

#: ../docs/source/howto/data.rst:544
msgid "Examples for using groups"
msgstr ""

#: ../docs/source/howto/data.rst:546
msgid ""
"In this section, we will provide some practical examples of how one can use "
"Groups to structure and organize the nodes in the database."
msgstr ""

#: ../docs/source/howto/data.rst:551
msgid "Group structures with a similar property"
msgstr ""

#: ../docs/source/howto/data.rst:553
msgid ""
"Suppose, we wanted to group all structures for which the computed bandgap is"
" higher than ``1.0 eV`` in a group named ``promising_structures``, one could"
" use the following approach:"
msgstr ""

#: ../docs/source/howto/data.rst:569
msgid ""
"Any node can be included in a group only once and if it is added again, it "
"is simply ignored. This means that add_nodes can be safely called multiple "
"times, and only nodes that weren't already part of the group, will be added."
msgstr ""

#: ../docs/source/howto/data.rst:574
msgid "Use grouped data for further processing"
msgstr ""

#: ../docs/source/howto/data.rst:576
msgid ""
"Here we demonstrate how to submit calculations for structures that all "
"belong to a group named ``promising_structures``:"
msgstr ""

#: ../docs/source/howto/data.rst:592
msgid ""
"Note, however, that one can also use ``group.nodes`` to access the nodes of "
"the group. To achieve the same result as above one would need to do "
"something as follows:"
msgstr ""

#: ../docs/source/howto/data.rst:608
msgid ""
"To find all structures that have a property ``property_a`` with a value "
"lower than ``1`` and also belong to the ``promising_structures`` group, one "
"could build a query as follows:"
msgstr ""

#: ../docs/source/howto/data.rst:618
msgid ""
"The return value of ``qb.all(flat=True)`` would contain all the structures "
"matching the above mentioned criteria."
msgstr ""

#: ../docs/source/howto/data.rst:623
msgid "Organise groups in hierarchies"
msgstr ""

#: ../docs/source/howto/data.rst:625
msgid "grouppath"
msgstr ""

#: ../docs/source/howto/data.rst:628
msgid ""
"Groups in AiiDA are inherently \"flat\", in that groups may only contain "
"nodes and not other groups. However it is possible to construct *virtual* "
"group hierarchies based on delimited group labels, using the "
":py:class:`~aiida.tools.groups.paths.GroupPath` utility."
msgstr ""

#: ../docs/source/howto/data.rst:631
msgid ""
":py:class:`~aiida.tools.groups.paths.GroupPath` is designed to work in much "
"the same way as Python's :py:class:`pathlib.Path`, whereby paths are denoted"
" by forward slash characters '/' in group labels."
msgstr ""

#: ../docs/source/howto/data.rst:633
msgid "For example say we have the groups:"
msgstr ""

#: ../docs/source/howto/data.rst:645
msgid "We can also access them from the command-line as:"
msgstr ""

#: ../docs/source/howto/data.rst:658
msgid "Or from the python interface:"
msgstr ""

#: ../docs/source/howto/data.rst:668
msgid "The ``GroupPath`` can be constructed using indexing or \"divisors\":"
msgstr ""

#: ../docs/source/howto/data.rst:676
msgid ""
"Using the :py:func:`~aiida.tools.groups.paths.GroupPath.browse` attribute, "
"you can also construct the paths as preceding attributes. This is useful in "
"interactive environments, whereby available paths will be shown in the tab-"
"completion:"
msgstr ""

#: ../docs/source/howto/data.rst:684
msgid "To check the existence of a path element:"
msgstr ""

#: ../docs/source/howto/data.rst:691
msgid ""
"A group may be \"virtual\", in which case its label does not directly relate"
" to a group, or the group can be retrieved with the "
":py:func:`~aiida.tools.groups.paths.GroupPath.get_group` method:"
msgstr ""

#: ../docs/source/howto/data.rst:704
msgid "Groups can be created and destroyed:"
msgstr ""

#: ../docs/source/howto/data.rst:716
msgid ""
"To traverse paths, use the "
":py:func:`~aiida.tools.groups.paths.GroupPath.children` attribute - for "
"recursive traversal, use "
":py:func:`~aiida.tools.groups.paths.GroupPath.walk`:"
msgstr ""

#: ../docs/source/howto/data.rst:727
msgid ""
"You can also traverse directly through the nodes of a path, optionally "
"filtering by node class and any other filters allowed by the "
":ref:`QueryBuilder <how-to:data:find>`:"
msgstr ""

#: ../docs/source/howto/data.rst:741
msgid ""
"Finally, you can also specify the ``Group`` subclasses (as discussed above):"
msgstr ""

#: ../docs/source/howto/data.rst:752
msgid ""
"A :py:class:`~aiida.tools.groups.paths.GroupPath` instance will only "
"recognise groups of the instantiated ``cls`` type. The default ``cls`` is "
"``aiida.orm.Group``:"
msgstr ""

#: ../docs/source/howto/data.rst:768
msgid "Deleting data"
msgstr ""

#: ../docs/source/howto/data.rst:770
msgid ""
"By default, every time you run or submit a new calculation, AiiDA will "
"create for you new nodes in the database, and will never replace or delete "
"data. There are cases, however, when it might be useful to delete nodes that"
" are not useful anymore, for instance test runs or incorrect/wrong data and "
"calculations. For this case, AiiDA provides the ``verdi node delete`` "
"command and the :py:func:`~aiida.tools.graph.deletions.delete_nodes` "
"function, to remove the nodes from the provenance graph."
msgstr ""

#: ../docs/source/howto/data.rst:775
msgid ""
"Once the data is deleted, there is no way to recover it (unless you made a "
"backup)."
msgstr ""

#: ../docs/source/howto/data.rst:777
msgid ""
"Critically, note that even if you ask to delete only one node, ``verdi node "
"delete`` will typically delete a number of additional linked nodes, in order"
" to preserve a consistent state of the provenance graph. For instance, if "
"you delete an input of a calculation, AiiDA will delete also the calculation"
" itself (as otherwise you would be effectively changing the inputs to that "
"calculation in the provenance graph). The full set of consistency rules are "
"explained in detail :ref:`here <topics:provenance:consistency>`."
msgstr ""

#: ../docs/source/howto/data.rst:781
msgid ""
"Therefore: always check the output of ``verdi node delete`` to make sure "
"that it is not deleting more than you expect. You can also use the ``--dry-"
"run`` flag of ``verdi node delete`` to see what the command would do without"
" performing any actual operation."
msgstr ""

#: ../docs/source/howto/data.rst:784
msgid ""
"In addition, there are a number of additional rules that are not mandatory "
"to ensure consistency, but can be toggled by the user. For instance, you can"
" set ``--create-forward`` if, when deleting a calculation, you want to "
"delete also the data it produced (using instead ``--no-create-forward`` will"
" delete the calculation only, keeping the output data: note that this "
"effectively strips out the provenance information of the output data). The "
"full list of these flags is available from the help command ``verdi node "
"delete -h``."
msgstr ""

#: ../docs/source/howto/data.rst:796
msgid "Deleting computers"
msgstr ""

#: ../docs/source/howto/data.rst:797
msgid ""
"To delete a computer, you can use ``verdi computer delete``. This command is"
" mostly useful if, right after creating a computer, you realise that there "
"was an error and you want to remove it. In particular, note that ``verdi "
"computer delete`` will prevent execution if the computer has been already "
"used by at least one node. In this case, you will need to use ``verdi node "
"delete`` to delete first the corresponding nodes."
msgstr ""

#: ../docs/source/howto/data.rst:802
msgid "Deleting mutable data"
msgstr ""

#: ../docs/source/howto/data.rst:803
msgid ""
"A subset of data in AiiDA is mutable also after storing a node, and is used "
"as a convenience for the user to tag/group/comment on data. This data can be"
" safely deleted at any time. This includes, notably:"
msgstr ""

#: ../docs/source/howto/data.rst:807
msgid ""
"*Node extras*: These can be deleted using "
":py:meth:`~aiida.orm.entities.EntityExtrasMixin.delete_extra` and "
":py:meth:`~aiida.orm.entities.EntityExtrasMixin.delete_extra_many` methods."
msgstr ""

#: ../docs/source/howto/data.rst:808
msgid ""
"*Node comments*: These can be removed using "
":py:meth:`~aiida.orm.nodes.node.Node.remove_comment`."
msgstr ""

#: ../docs/source/howto/data.rst:809
msgid ""
"*Groups*: These can be deleted using :py:meth:`Group.objects.delete() "
"<aiida.orm.groups.Group.Collection.delete>`. This command will only delete "
"the group, not the nodes contained in the group."
msgstr ""

#: ../docs/source/howto/data.rst:813
msgid "Completely deleting an AiiDA profile"
msgstr ""

#: ../docs/source/howto/data.rst:814
msgid ""
"If you don't want to selectively delete some nodes, but instead want to "
"delete a whole AiiDA profile altogether, use the ``verdi profile delete`` "
"command. This command will delete both the file repository and the database."
msgstr ""

#: ../docs/source/howto/data.rst:819
msgid ""
"It is not possible to restore a deleted profile unless it was previously "
"backed up!"
msgstr ""

#: ../docs/source/howto/data.rst:824
msgid "Transferring data"
msgstr ""

#: ../docs/source/howto/data.rst:830
msgid ""
"This feature is still in beta version and its API might change in the near "
"future. It is therefore not recommended that you rely on it for your "
"public/production workflows."
msgstr ""

#: ../docs/source/howto/data.rst:833
msgid ""
"Moreover, feedback on its implementation is much appreciated (at "
"https://github.com/aiidateam/aiida-core/issues/4811)."
msgstr ""

#: ../docs/source/howto/data.rst:835
msgid ""
"When a calculation job is launched, AiiDA will create a "
":py:class:`~aiida.orm.nodes.data.remote.RemoteData` node that is attached as"
" an output node to the calculation node with the label ``remote_folder``. "
"The input files generated by the ``CalcJob`` plugin are copied to this "
"remote folder and, since the job is executed there as well, the code will "
"produce its output files in that same remote folder also. Since the "
":py:class:`~aiida.orm.nodes.data.remote.RemoteData` node only explicitly "
"stores the filepath on the remote computer, and not its actual contents, it "
"functions more or less like a symbolic link. That means that if the remote "
"folder gets deleted, there will be no way to retrieve its contents. The "
"``CalcJob`` plugin can for that reason specify some files that should be "
":ref:`retrieved<topics:calculations:usage:calcjobs:file_lists_retrieve>` and"
" stored locally in a :py:class:`~aiida.orm.nodes.data.folder.FolderData` "
"node for safekeeing, which is attached to the calculation node as an output "
"with the label ``retrieved_folder``."
msgstr ""

#: ../docs/source/howto/data.rst:841
msgid ""
"Although the "
":ref:`retrieve_list<topics:calculations:usage:calcjobs:file_lists_retrieve>`"
" allows to specify what output files are to be retrieved locally, this has "
"to be done *before* the calculation is submitted. In order to provide more "
"flexibility in deciding what files of completed calculation jobs are to be "
"stored locally, even after it has terminated, AiiDA ships with a the "
":py:class:`~aiida.calculations.transfer.TransferCalculation` plugin. This "
"calculation plugin enables to retrieve files from a remote machine and save "
"them in a local :py:class:`~aiida.orm.nodes.data.folder.FolderData`. The "
"specifications of what to copy are provided through an input of type"
msgstr ""

#: ../docs/source/howto/data.rst:855
msgid ""
"The ``'source/path/filename'`` and ``'target/path/filename'`` are both "
"relative paths (to their respective folders). The ``node_keyname`` is a "
"string that will be used when providing the source "
":py:class:`~aiida.orm.nodes.data.remote.RemoteData` node to the calculation."
" You also need to provide the computer between which the transfer will "
"occur:"
msgstr ""

#: ../docs/source/howto/data.rst:866
msgid ""
"The variable ``source_node`` here corresponds to the ``RemoteData`` node "
"whose contents need to be retrieved. Finally, you just run or submit the "
"calculation as you would do with any other:"
msgstr ""

#: ../docs/source/howto/data.rst:874
msgid ""
"You can also use this to copy local files into a new "
":py:class:`~aiida.orm.nodes.data.remote.RemoteData` folder. For this you "
"first have to adapt the instructions to set ``'retrieve_files'`` to "
"``False`` and use a ``'local_files'`` list instead of the "
"``'symlink_files'``:"
msgstr ""

#: ../docs/source/howto/data.rst:886
msgid ""
"It is also relevant to note that, in this case, the ``source_node`` will be "
"of type :py:class:`~aiida.orm.nodes.data.folder.FolderData` so you will have"
" to manually select the computer to where you want to copy the files. You "
"can do this by looking at your available computers running ``verdi computer "
"list`` and using the label shown to load it with "
":py:func:`~aiida.orm.utils.load_computer`:"
msgstr ""

#: ../docs/source/howto/data.rst:893
msgid ""
"Both when uploading or retrieving, you can copy multiple files by appending "
"them to the list of the ``local_files`` or ``symlink_files`` keys in the "
"instructions input, respectively. It is also possible to copy files from any"
" number of nodes by providing several ``source_node`` s, each with a "
"different ``'node_keyname'``. The target node will always be one (so you can"
" *\"gather\"* files in a single call, but not *\"distribute\"* them)."
msgstr ""

#: ../docs/source/howto/exploring.rst:5
msgid "How to explore the provenance graph"
msgstr ""

#: ../docs/source/howto/exploring.rst:10
msgid "Incoming and outgoing links"
msgstr ""

#: ../docs/source/howto/exploring.rst:12
msgid ""
"The provenance graph in AiiDA is a :ref:`directed graph "
"<topics:provenance:concepts>`. The vertices of the graph are the *nodes*, "
"and the edges that connect them are called *links*. Since the graph is "
"directed, any node can have *incoming* and *outgoing* links that connect it "
"to neighboring nodes."
msgstr ""

#: ../docs/source/howto/exploring.rst:16
msgid ""
"To discover the neighbors of a given node, you can use the methods "
":meth:`~aiida.orm.nodes.node.Node.get_incoming` and "
":meth:`~aiida.orm.nodes.node.Node.get_outgoing`. They have the exact same "
"interface but will return the neighbors connected to the current node with a"
" link coming into it or with links going out of it, respectively. For "
"example, for a given ``node``, to inspect all the neighboring nodes from "
"which a link is incoming to the ``node``:"
msgstr ""

#: ../docs/source/howto/exploring.rst:24
msgid ""
"This will return an instance of the "
":class:`~aiida.orm.utils.links.LinkManager`. From that manager, you can "
"request the results in a specific format. If you are only interested in the "
"neighboring nodes themselves, you can call the "
":class:`~aiida.orm.utils.links.LinkManager.all_nodes` method:"
msgstr ""

#: ../docs/source/howto/exploring.rst:32
msgid ""
"This will return a list of :class:`~aiida.orm.nodes.node.Node` instances "
"that correspond to the nodes that are neighbors of ``node``, where the link "
"is going towards ``node``. Calling the "
":meth:`~aiida.orm.utils.links.LinkManager.all` method of the manager instead"
" will return a list of :class:`~aiida.orm.utils.links.LinkTriple` named "
"tuples. These tuples contain, in addition to the neighboring node, also the "
"link label and the link type with which they are connected to the origin "
"``node``. For example, to list all the neighbors of a node from which a link"
" is incoming:"
msgstr ""

#: ../docs/source/howto/exploring.rst:42
msgid ""
"Note that the :class:`~aiida.orm.utils.links.LinkManager` provides many "
"convenience methods to get information from the neigboring nodes, such as "
":meth:`~aiida.orm.utils.links.LinkManager.all_link_labels` if you only need "
"the list of link labels."
msgstr ""

#: ../docs/source/howto/exploring.rst:44
msgid ""
"The :meth:`~aiida.orm.nodes.node.Node.get_incoming` and "
":meth:`~aiida.orm.nodes.node.Node.get_outgoing` methods accept various "
"arguments that allow one to filter what neighboring nodes should be matched:"
msgstr ""

#: ../docs/source/howto/exploring.rst:46
msgid ""
"``node_class``: accepts a subclass of :class:`~aiida.orm.nodes.node.Node`, "
"only neighboring nodes with a class that matches this will be returned"
msgstr ""

#: ../docs/source/howto/exploring.rst:47
msgid ""
"``link_type``: accepts a value of :class:`~aiida.common.links.LinkType`, "
"only neighboring nodes that are linked with this link type will be returned"
msgstr ""

#: ../docs/source/howto/exploring.rst:48
msgid ""
"``link_label_filter``: accepts a string  expression (with optional wildcards"
" using the syntax of SQL ``LIKE`` patterns, see below), only neighboring "
"nodes that are linked with a link label that matches the pattern will be "
"returned"
msgstr ""

#: ../docs/source/howto/exploring.rst:50
msgid "As an example:"
msgstr ""

#: ../docs/source/howto/exploring.rst:56
msgid ""
"will return only neighboring data nodes that are linked to the ``node`` with"
" a link of type ``LinkType.INPUT_CALC`` and where the link label matches the"
" pattern ``'output%node_'``. Reminder on the syntax of SQL `LIKE` patterns: "
"the ``%`` character matches any string of zero or more characters, while the"
" ``_`` character matches exactly one character. These two special characters"
" can be escaped by prepending them with a backslash (note that when putting "
"a backslash in a Python string you have to escape the backslash itself, so "
"you will need two backslashes: e.g., to match exactly a link label ``a_b`` "
"you need to pass ``link_label_filter='a\\\\_b'``)."
msgstr ""

#: ../docs/source/howto/exploring.rst:64
msgid "Inputs and outputs"
msgstr ""

#: ../docs/source/howto/exploring.rst:66
msgid ""
"The :meth:`~aiida.orm.nodes.node.Node.get_incoming` and "
":meth:`~aiida.orm.nodes.node.Node.get_outgoing` methods, described in the "
":ref:`previous section <how-to:exploring:incoming-outgoing>`, can be used to"
" access all neighbors from a certain node and provide advanced filtering "
"options. However, often one doesn't need this expressivity and simply wants "
"to retrieve all neighboring nodes with a syntax that is as succint as "
"possible. A prime example is to retrieve the *inputs* or *outputs* of "
":ref:`a process <topics:processes:concepts>`. Instead of using "
":meth:`~aiida.orm.nodes.node.Node.get_incoming` and "
":meth:`~aiida.orm.nodes.node.Node.get_outgoing`, to get the inputs and "
"outputs of a ``process_node`` one can do:"
msgstr ""

#: ../docs/source/howto/exploring.rst:76
msgid ""
"These properties do not return the actual inputs and outputs directly, but "
"instead return an instance of "
":class:`~aiida.orm.utils.managers.NodeLinksManager`. The reason is because "
"through the manager, the inputs or outputs are accessible through their link"
" label (that, for inputs and outputs of processes, is unique) and can be "
"tab-completed. For example, if the ``process_node`` has an output with the "
"label ``result``, it can be retrieved as:"
msgstr ""

#: ../docs/source/howto/exploring.rst:84
msgid "The inputs or outputs can also be accessed through key dereferencing:"
msgstr ""

#: ../docs/source/howto/exploring.rst:90
msgid ""
"If there is no neighboring output with the given link label, a "
":class:`~aiida.common.exceptions.NotExistentAttributeError` or "
":class:`~aiida.common.exceptions.NotExistentKeyError` will be raised, "
"respectively."
msgstr ""

#: ../docs/source/howto/exploring.rst:94
msgid ""
"The ``inputs`` and ``outputs`` properties are only defined for "
":class:`~aiida.orm.nodes.process.process.ProcessNode`'s. This means that you"
" cannot *chain* these calls, because an input or output of a process node is"
" guaranteed to be a :class:`~aiida.orm.nodes.data.Data` node, which does not"
" have inputs or outputs."
msgstr ""

#: ../docs/source/howto/exploring.rst:101
msgid "Creator, caller and called"
msgstr ""

#: ../docs/source/howto/exploring.rst:103
msgid ""
"Similar to the ``inputs`` and ``outputs`` properties of process nodes, there"
" are some more properties that make exploring the provenance graph easier:"
msgstr ""

#: ../docs/source/howto/exploring.rst:105
msgid ""
":meth:`~aiida.orm.nodes.process.process.ProcessNode.called`: defined for "
":class:`~aiida.orm.nodes.process.process.ProcessNode`'s and returns the list"
" of process nodes called by this node. If this process node did not call any"
" other processes, this property returns an empty list."
msgstr ""

#: ../docs/source/howto/exploring.rst:107
msgid ""
":meth:`~aiida.orm.nodes.process.process.ProcessNode.caller`: defined for "
":class:`~aiida.orm.nodes.process.process.ProcessNode`'s and returns the "
"process node that called this node. If this node was not called by a "
"process, this property returns ``None``."
msgstr ""

#: ../docs/source/howto/exploring.rst:109
msgid ""
":meth:`~aiida.orm.nodes.data.Data.creator`: defined for "
":class:`~aiida.orm.nodes.data.Data` nodes and returns the process node that "
"created it. If the node was not created by a process, this property returns "
"``None``."
msgstr ""

#: ../docs/source/howto/exploring.rst:114
msgid ""
"Using the ``creator`` and ``inputs`` properties, one can easily move *up* "
"the provenance graph. For example, starting from some data node that "
"represents the result of a long workflow, one can move up the provenance "
"graph to find an initial input node of interest: "
"``result.creator.inputs.some_input.creator.inputs.initial_input``."
msgstr ""

#: ../docs/source/howto/exploring.rst:120
msgid "Calculation job results"
msgstr ""

#: ../docs/source/howto/exploring.rst:122
msgid ""
":class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode`'s provide "
"the :meth:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.res` "
"property, that can give easy access to the results of the calculation job. "
"The requirement is that the "
":class:`~aiida.engine.processes.calcjobs.calcjob.CalcJob` class that "
"produced the node, defines a *default output node* in its spec. This node "
"should be a :class:`~aiida.orm.nodes.data.dict.Dict` output that will always"
" be created. An example is the "
":class:`~aiida.calculations.templatereplacer.TemplatereplacerCalculation` "
"plugin, that has the ``output_parameters`` output that is specified as its "
"default output node."
msgstr ""

#: ../docs/source/howto/exploring.rst:127
msgid ""
"The :meth:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.res` "
"property will give direct easy access to all the keys within this dictionary"
" output. For example, the following:"
msgstr ""

#: ../docs/source/howto/exploring.rst:134
msgid ""
"will return a list of all the keys in the output node. Individual keys can "
"then be accessed through attribute dereferencing:"
msgstr ""

#: ../docs/source/howto/exploring.rst:141
msgid ""
"In an interactive shell, the available keys are also tab-completed. If you "
"type ``node.res.`` followed by the tab key twice, a list of the available "
"keys is printed."
msgstr ""

#: ../docs/source/howto/exploring.rst:146
msgid ""
"The :meth:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.res` "
"property is really just a shortcut to quickly and easily access an attribute"
" of the default output node of a calculation job. For example, if the "
"default output node link label is ``output_parameters``, then "
"``node.res.some_key`` is exactly equivalent to "
"``node.outputs.output_parameters.dict.some_key``. That is to say, when using"
" ``res``, one is accessing attributes of one of the output nodes, and not of"
" the calculation job node itself."
msgstr ""

#: ../docs/source/howto/faq.rst:5
msgid "Frequently Asked Questions"
msgstr ""

#: ../docs/source/howto/faq.rst:7
msgid ""
"If the problem you are facing is not addressed below, you can send an email "
"to the `mailing list <http://www.aiida.net/mailing-list/>`_, or `open an "
"issue on Github <https://github.com/aiidateam/aiida-"
"core/issues/new/choose>`_ if you think it concerns a bug."
msgstr ""

#: ../docs/source/howto/faq.rst:11
msgid ""
"I have updated the version of AiiDA and now it is no longer working. What "
"should I do?"
msgstr ""

#: ../docs/source/howto/faq.rst:12
msgid ""
"First, make sure that your daemon is not running. You can check this with "
"``verdi daemon status``. If you find that your daemon was actually still "
"running, that is likely the problem, so stop it first using ``verdi daemon "
"stop``. It is very important that each time you want to :ref:`update your "
"AiiDA installation<how-to:installation:update>`, you should *always* first "
"finish all running processes and stop the daemon before doing so. After you "
"have stopped the daemon, make sure to run ``reentry scan`` before you "
"restart the daemon with ``verdi daemon start``."
msgstr ""

#: ../docs/source/howto/faq.rst:20
msgid ""
"I get a :py:class:`~aiida.common.exceptions.MissingEntryPointError` or "
":py:class:`~aiida.common.exceptions.MultipleEntryPointError` exception, "
"saying that a particular entry point cannot be found. How can I fix this?"
msgstr ""

#: ../docs/source/howto/faq.rst:21
msgid ""
"Often this is caused by an outdated entry point cache. This can happen for "
"example when you have updated your AiiDA installation or installed a new "
"plugin using ``pip install``. In both cases, you can fix the problem by "
"running ``reentry scan``. Make sure to also restart all daemons, to ensure "
"that the changes are picked up by the daemons as well."
msgstr ""

#: ../docs/source/howto/faq.rst:28
msgid ""
"I have updated the code of a "
":py:class:`~aiida.engine.processes.workchains.WorkChain`, "
":py:class:`~aiida.engine.processes.calcjobs.CalcJob` or whatever other "
"Python code, but the daemon does not seem to pick up the changes?"
msgstr ""

#: ../docs/source/howto/faq.rst:29
msgid ""
"Each time that you change your code, you should restart the daemon for the "
"changes to take effect. Each daemon worker actually is its own system "
"process with its own Python interpreter instance, and since we don't support"
" automated hot==swapping, the daemon workers will not automatically detect "
"the changes in the code. Simply calling ``verdi daemon restart`` will do the"
" trick."
msgstr ""

#: ../docs/source/howto/faq.rst:35
msgid ""
"I have updated the code of a "
":py:class:`~aiida.engine.processes.workchains.WorkChain`, "
":py:class:`~aiida.engine.processes.calcjobs.CalcJob` or whatever other "
"Python code, but my Python shell instance does not seem to pick up the "
"changes?"
msgstr ""

#: ../docs/source/howto/faq.rst:36
msgid ""
"The ``verdi shell`` is its own Python interpreter and does not automatically"
" detect code changes. Simply reloading your shell will solve the problem."
msgstr ""

#: ../docs/source/howto/faq.rst:41
msgid ""
"Why are calculation jobs taking very long to run on remote machines even "
"though the actual computation time should be fast?"
msgstr ""

#: ../docs/source/howto/faq.rst:42
msgid ""
"First, make sure that the calculation is not actually waiting in the queue "
"of the scheduler, but it is actually running or has already completed. If it"
" then still takes seemingly a lot of time for AiiDA to update your "
"calculations, there are a couple of explanations. First, if you are running "
"many processes, your daemon workers may simply be busy managing other "
"calculations and workflows. If that is not the case, you may be witnessing "
"the effects of the built-in throttling mechanisms of AiiDA's engine. To "
"ensure that the AiiDA daemon does not overload remote computers or their "
"schedulers, there are built-in limits to how often the daemon workers are "
"allowed to open an SSH connection, or poll the scheduler. To determine the "
"minimum transport and job polling interval, use ``verdi computer configure "
"show <COMPUTER>`` and ``computer.get_minimum_job_poll_interval()``, "
"respectively. You can lower these values using:"
msgstr ""

#: ../docs/source/howto/faq.rst:54
msgid "and"
msgstr ""

#: ../docs/source/howto/faq.rst:60
msgid ""
"respectively. However, be careful, if you make these intervals too short, "
"the daemon workers may spam the remote machine and/or scheduler, which could"
" have adverse effects on the machine itself or can get your account banned, "
"depending on the policy of the remote machine. An additional note of "
"importance is that each interval is guaranteed to be respected per daemon "
"worker individually, but not as a collective. That is to say, if the safe "
"interval is set to 60 seconds, any single worker is guaranteed to open a "
"connection to that machine at most once every minute, however, if you have "
"multiple active daemon workers, the machine may be accessed more than once "
"per minute."
msgstr ""

#: ../docs/source/howto/faq.rst:68
msgid ""
"Why would a process that runs fine locally raise an exception when submitted"
" to the daemon?"
msgstr ""

#: ../docs/source/howto/faq.rst:69
msgid ""
"This is almost always caused by an import issue. To determine exactly what "
"might be going wrong, first :ref:`set the loglevel <intro:increase-logging-"
"verbosity>` to ``DEBUG`` by executing the command:"
msgstr ""

#: ../docs/source/howto/faq.rst:76
msgid ""
"Then restart the daemon with ``verdi daemon restart`` for the changes to "
"take effect. Run the command ``verdi daemon logshow`` in a separate terminal"
" to see the logging output of the daemon and then submit the problematic "
"calculation or workflow again. If the root cause is indeed due to an import "
"problem, it will probably appear as an ``ImportError`` exception in the "
"daemon log. To solve these issues, make sure that all the Python code that "
"is being run is properly importable, which means that it is part of the "
"`PYTHONPATH <https://docs.python.org/3/using/cmdline.html#envvar-"
"PYTHONPATH>`_. Make sure that the PYTHONPATH is correctly defined "
"automatically when starting your shell, so for example if you are using "
"bash, add it to your ``.bashrc``."
msgstr ""

#: ../docs/source/howto/faq.rst:85
msgid "Why is caching not enabled by default?"
msgstr ""

#: ../docs/source/howto/faq.rst:87
msgid ""
"Caching is designed to work in an unobtrusive way and simply save time and "
"valuable computational resources. However, this design is a double-egded "
"sword, in that a user that might not be aware of this functionality, can be "
"caught off guard by the results of their calculations."
msgstr ""

#: ../docs/source/howto/faq.rst:90
msgid ""
"The caching mechanism comes with some limitations and caveats that are "
"important to understand. Refer to the "
":ref:`topics:provenance:caching:limitations` section for more details."
msgstr ""

#: ../docs/source/howto/index.rst:3
msgid "How-To Guides"
msgstr ""

#: ../docs/source/howto/installation.rst:5
msgid "How to manage your installation"
msgstr ""

#: ../docs/source/howto/installation.rst:11
msgid "Managing profiles"
msgstr ""

#: ../docs/source/howto/installation.rst:14
msgid "Creating profiles"
msgstr ""

#: ../docs/source/howto/installation.rst:15
msgid ""
"Each AiiDA installation can have multiple profiles, each of which can have "
"its own individual database and file repository to store the contents of the"
" :ref:`provenance graph<topics:provenance:concepts>`. Profiles allow you to "
"run multiple projects completely independently from one another with just a "
"single AiiDA installation and at least one profile is required to run AiiDA."
" A new profile can be created using :ref:`verdi quicksetup<reference"
":command-line:verdi-quicksetup>` or :ref:`verdi setup<reference:command-line"
":verdi-setup>`, which works similar to the former but gives more control to "
"the user."
msgstr ""

#: ../docs/source/howto/installation.rst:20
msgid "Listing profiles"
msgstr ""

#: ../docs/source/howto/installation.rst:21
msgid ""
"The :ref:`verdi profile<reference:command-line:verdi-profile>` command line "
"interface provides various commands to manage the profiles of an AiiDA "
"installation. To list the currently configured profiles, use ``verdi profile"
" list``:"
msgstr ""

#: ../docs/source/howto/installation.rst:30
msgid ""
"In this particular example, there are two configured profiles, ``project-"
"one`` and ``project-two``. The first one is highlighted and marked with a "
"``*`` symbol, meaning it is the default profile. A profile being the default"
" means simply that any ``verdi`` command will always be executed for that "
"profile. You can :ref:`change the profile on a per-call "
"basis<topics:cli:profile>` with the ``--p/--profile`` option. To change the "
"default profile use ``verdi profile setdefault PROFILE``."
msgstr ""

#: ../docs/source/howto/installation.rst:37
msgid "Showing profiles"
msgstr ""

#: ../docs/source/howto/installation.rst:38
msgid ""
"Each profile defines various parameters, such as the location of the file "
"repository on the file system and the connection parameters for the "
"database. To display these parameters, use ``verdi profile show``:"
msgstr ""

#: ../docs/source/howto/installation.rst:58
msgid ""
"By default, the parameters of the default profile are shown, but one can "
"pass the profile name of another, e.g., ``verdi profile show project-two`` "
"to change that."
msgstr ""

#: ../docs/source/howto/installation.rst:61
msgid "Deleting profiles"
msgstr ""

#: ../docs/source/howto/installation.rst:62
msgid ""
"A profile can be deleted using the ``verdi profile delete`` command. By "
"default, deleting a profile will also delete its file repository and the "
"database. This behavior can be changed using the ``--skip-repository`` and "
"``--skip-db`` options."
msgstr ""

#: ../docs/source/howto/installation.rst:68
msgid ""
"In order to delete the database, the system user needs to have the required "
"rights, which is not always guaranteed depending on the system. In such "
"cases, the database deletion may fail and the user will have to perform the "
"deletion manually through PostgreSQL."
msgstr ""

#: ../docs/source/howto/installation.rst:75
msgid "Configuring your installation"
msgstr ""

#: ../docs/source/howto/installation.rst:80
msgid "Activating tab-completion"
msgstr ""

#: ../docs/source/howto/installation.rst:81
msgid ""
"The ``verdi`` command line interface has many commands and parameters, which"
" can be tab-completed to simplify its use. To enable tab-completion, the "
"following shell command should be executed:"
msgstr ""

#: ../docs/source/howto/installation.rst:88
msgid ""
"Place this command in your shell or virtual environment activation script to"
" automatically enable tab completion when opening a new shell or activating "
"an environment. This file is shell specific, but likely one of the "
"following:"
msgstr ""

#: ../docs/source/howto/installation.rst:91
msgid ""
"the startup file of your shell (``.bashrc``, ``.zsh``, ...), if aiida is "
"installed system-wide"
msgstr ""

#: ../docs/source/howto/installation.rst:92
msgid ""
"the `activation script <https://virtualenv.pypa.io/en/latest/userguide"
"/#activate-script>`_ of your virtual environment"
msgstr ""

#: ../docs/source/howto/installation.rst:93
msgid ""
"a `startup file <https://conda.io/docs/user-guide/tasks/manage-"
"environments.html#saving-environment-variables>`_ for your conda environment"
msgstr ""

#: ../docs/source/howto/installation.rst:98
msgid ""
"After you have added the line to the start up script, make sure to restart "
"the terminal or source the script for the changes to take effect."
msgstr ""

#: ../docs/source/howto/installation.rst:104
msgid "Configuring profile options"
msgstr ""

#: ../docs/source/howto/installation.rst:106
msgid ""
"AiiDA provides various configurational options for profiles, which can be "
"controlled with the :ref:`verdi config<reference:command-line:verdi-config>`"
" command."
msgstr ""

#: ../docs/source/howto/installation.rst:108
msgid "To view all configuration options set for the current profile:"
msgstr ""

#: ../docs/source/howto/installation.rst:141
msgid ""
"Configuration option values are taken, in order of priority, from either the"
" profile specific setting, the global setting (applies to all profiles), or "
"the default value."
msgstr ""

#: ../docs/source/howto/installation.rst:143
msgid "You can also filter by a prefix:"
msgstr ""

#: ../docs/source/howto/installation.rst:153
msgid ""
"To show the full information for a configuration option or get its current "
"value:"
msgstr ""

#: ../docs/source/howto/installation.rst:170
msgid "You can also retrieve the value *via* the API:"
msgstr ""

#: ../docs/source/howto/installation.rst:178
msgid "To set a value, at the profile or global level:"
msgstr ""

#: ../docs/source/howto/installation.rst:201
msgid ""
"By default any option set through ``verdi config`` will be applied to the "
"current default profile. To change the profile you can use the :ref:`profile"
" option<topics:cli:profile>`."
msgstr ""

#: ../docs/source/howto/installation.rst:204
msgid "Similarly to unset a value:"
msgstr ""

#: ../docs/source/howto/installation.rst:227
msgid ""
"Changes that affect the daemon (e.g. ``logging.aiida_loglevel``) will only "
"take affect after restarting the daemon."
msgstr ""

#: ../docs/source/howto/installation.rst:229
msgid ":ref:`How-to configure caching <how-to:run-codes:caching>`"
msgstr ""

#: ../docs/source/howto/installation.rst:235
msgid "Isolating multiple instances"
msgstr ""

#: ../docs/source/howto/installation.rst:236
msgid ""
"An AiiDA instance is defined as the installed source code plus the "
"configuration folder that stores the configuration files with all the "
"configured profiles. It is possible to run multiple AiiDA instances on a "
"single machine, simply by isolating the code and configuration in a virtual "
"environment."
msgstr ""

#: ../docs/source/howto/installation.rst:239
msgid ""
"To isolate the code, make sure to install AiiDA into a virtual environment, "
"e.g., with conda or venv, as described :ref:`here "
"<intro:get_started:setup>`. Whenever you activate this particular "
"environment, you will be running the particular version of AiiDA (and all "
"the plugins) that you installed specifically for it."
msgstr ""

#: ../docs/source/howto/installation.rst:242
msgid ""
"This is separate from the configuration of AiiDA, which is stored in the "
"configuration directory which is always named ``.aiida`` and by default is "
"stored in the home directory. Therefore, the default path of the "
"configuration directory is ``~/.aiida``. By default, each AiiDA instance "
"(each installation) will store associated profiles in this folder. A best "
"practice is to always separate the profiles together with the code to which "
"they belong. The typical approach is to place the configuration folder in "
"the virtual environment itself and have it automatically selected whenever "
"the environment is activated."
msgstr ""

#: ../docs/source/howto/installation.rst:248
msgid ""
"The location of the AiiDA configuration folder can be controlled with the "
"``AIIDA_PATH`` environment variable. This allows us to change the "
"configuration folder automatically, by adding the following lines to the "
"activation script of a virtual environment. For example, if the path of your"
" virtual environment is ``/home/user/.virtualenvs/aiida``, add the following"
" line:"
msgstr ""

#: ../docs/source/howto/installation.rst:256
msgid ""
"Make sure to reactivate the virtual environment, if it was already active, "
"for the changes to take effect."
msgstr ""

#: ../docs/source/howto/installation.rst:260
msgid ""
"For ``conda``, create a directory structure ``etc/conda/activate.d`` in the "
"root folder of your conda environment (e.g. "
"``/home/user/miniconda/envs/aiida``), and place a file ``aiida-init.sh`` in "
"that folder which exports the ``AIIDA_PATH``."
msgstr ""

#: ../docs/source/howto/installation.rst:262
msgid ""
"You can test that everything works by first echoing the environment variable"
" with ``echo $AIIDA_PATH`` to confirm it prints the correct path. Finally, "
"you can check that AiiDA know also properly realizes the new location for "
"the configuration folder by calling ``verdi profile list``. This should "
"display the current location of the configuration directory:"
msgstr ""

#: ../docs/source/howto/installation.rst:271
msgid ""
"The second line you will only see if you haven't yet setup a profile for "
"this AiiDA instance. For information on setting up a profile, refer to "
":ref:`creating profiles<how-to:installation:profile>`."
msgstr ""

#: ../docs/source/howto/installation.rst:274
msgid ""
"Besides a single path, the value of ``AIIDA_PATH`` can also be a colon-"
"separated list of paths. AiiDA will go through each of the paths and check "
"whether they contain a configuration directory, i.e., a folder with the name"
" ``.aiida``. The first configuration directory that is encountered will be "
"used as the configuration directory. If no configuration directory is found,"
" one will be created in the last path that was considered. For example, the "
"directory structure in your home folder ``~/`` might look like this::"
msgstr ""

#: ../docs/source/howto/installation.rst:286
msgid ""
"If you leave the ``AIIDA_PATH`` variable unset, the default location "
"``~/.aiida`` will be used. However, if you set:"
msgstr ""

#: ../docs/source/howto/installation.rst:293
msgid "the configuration directory ``~/project_a/.aiida`` will be used."
msgstr ""

#: ../docs/source/howto/installation.rst:297
msgid ""
"If there was no ``.aiida`` directory in ``~/project_a``, AiiDA would have "
"created it for you, so make sure to set the ``AIIDA_PATH`` correctly."
msgstr ""

#: ../docs/source/howto/installation.rst:303
msgid "Daemon as a service"
msgstr ""

#: ../docs/source/howto/installation.rst:305
msgid ""
"The daemon can be set up as a system service, such that it automatically "
"starts at system startup. How to do this, is operating system specific. For "
"Ubuntu, here is `a template for the service file <https://github.com/marvel-"
"nccr/ansible-role-"
"aiida/blob/c709088dff74d1e1ae4d8379e740aba35fb2ef97/templates/aiida-"
"daemon%40.service>`_ and `ansible instructions to install the service "
"<https://github.com/marvel-nccr/ansible-role-"
"aiida/blob/c709088dff74d1e1ae4d8379e740aba35fb2ef97/tasks/aiida-"
"daemon.yml>`_."
msgstr ""

#: ../docs/source/howto/installation.rst:313
msgid "Tuning performance"
msgstr ""

#: ../docs/source/howto/installation.rst:315
msgid ""
"AiiDA supports running hundreds of thousands of calculations and graphs with"
" millions of nodes. However, optimal performance at that scale might require"
" some tweaks to the AiiDA configuration to balance the CPU and disk load. "
"Here are a few general tips that might improve the AiiDA performance:"
msgstr ""

#: ../docs/source/howto/installation.rst:321
msgid ""
"Many Linux distributions include the ``locate`` command to quickly find "
"files and folders, and run a daily cron job ``updatedb.mlocate`` to create "
"the corresponding index. A large file repository can take a long time to "
"index, up to the point where the hard drive is constantly indexing."
msgstr ""

#: ../docs/source/howto/installation.rst:324
msgid ""
"In order to exclude the repository folder from indexing, add its path to the"
" ``PRUNEPATH`` variable in the ``/etc/updatedb.conf`` configuration file "
"(use ``sudo``)."
msgstr ""

#: ../docs/source/howto/installation.rst:328
msgid ""
"The verdi deamon can manage an arbitrary number of parallel workers; by "
"default only one is activated. If ``verdi daemon status`` shows the daemon "
"worker(s) constantly at high CPU usage, use ``verdi daemon incr X`` to add "
"``X`` daemon workers. It is recommended that the number of workers does not "
"exceed the number of CPU cores. Ideally, if possible, one should use one or "
"two cores less than the machine has, to avoid to degrade the PostgreSQL "
"database performance."
msgstr ""

#: ../docs/source/howto/installation.rst:335
msgid ""
"Stop the AiiDA daemon and :ref:`back up your database <how-"
"to:installation:backup:postgresql>`."
msgstr ""

#: ../docs/source/howto/installation.rst:337
msgid ""
"Find the data directory of your postgres installation (something like "
"``/var/lib/postgresql/9.6/main``, ``/scratch/postgres/9.6/main``, ...)."
msgstr ""

#: ../docs/source/howto/installation.rst:339
msgid ""
"The best way is to become the postgres UNIX user and enter the postgres "
"shell::"
msgstr ""

#: ../docs/source/howto/installation.rst:345
msgid ""
"If you are unable to enter the postgres shell, try looking for the "
"``data_directory`` variable in a file "
"``/etc/postgresql/9.6/main/postgresql.conf`` or similar."
msgstr ""

#: ../docs/source/howto/installation.rst:347
msgid "Stop the postgres database service::"
msgstr ""

#: ../docs/source/howto/installation.rst:351
msgid ""
"Copy all files and folders from the postgres ``data_directory`` to the new "
"location::"
msgstr ""

#: ../docs/source/howto/installation.rst:373
msgid ""
"Point the ``data_directory`` variable in your postgres configuration file "
"(e.g. ``/etc/postgresql/9.6/main/postgresql.conf``) to the new directory."
msgstr ""

#: ../docs/source/howto/installation.rst:375
msgid "Restart the database daemon::"
msgstr ""

#: ../docs/source/howto/installation.rst:379
msgid "Finally, check that the data directory has indeed changed::"
msgstr ""

#: ../docs/source/howto/installation.rst:385
msgid ""
"and try a simple AiiDA query with the new database. If everything went fine,"
" you can delete the old database location."
msgstr ""

#: ../docs/source/howto/installation.rst:391
msgid "Updating your installation"
msgstr ""

#: ../docs/source/howto/installation.rst:393
msgid ""
"Whenever updating your AiiDA installation, make sure you follow these "
"instructions **very carefully**, even when merely upgrading the patch "
"version! Failing to do so, may leave your installation in a broken state, or"
" worse may even damage your data, potentially irreparably."
msgstr ""

#: ../docs/source/howto/installation.rst:396
msgid "Activate the Python environment where AiiDA is installed."
msgstr ""

#: ../docs/source/howto/installation.rst:397
msgid ""
"Finish all running processes. All finished processes will be automatically "
"migrated, but it is not possible to resume unfinished processes."
msgstr ""

#: ../docs/source/howto/installation.rst:399
msgid "Stop the daemon using ``verdi daemon stop``."
msgstr ""

#: ../docs/source/howto/installation.rst:400
msgid ""
":ref:`Create a backup of your database and repository<how-"
"to:installation:backup>`."
msgstr ""

#: ../docs/source/howto/installation.rst:404
msgid ""
"Once you have migrated your database, you can no longer go back to an older "
"version of ``aiida-core`` (unless you restore your database and repository "
"from a backup)."
msgstr ""

#: ../docs/source/howto/installation.rst:406
msgid "Update your ``aiida-core`` installation."
msgstr ""

#: ../docs/source/howto/installation.rst:408
msgid ""
"If you have installed AiiDA through ``conda`` simply run: ``conda update "
"aiida-core``."
msgstr ""

#: ../docs/source/howto/installation.rst:409
msgid ""
"If you have installed AiiDA through ``pip`` simply run: ``pip install "
"--upgrade aiida-core``."
msgstr ""

#: ../docs/source/howto/installation.rst:410
msgid ""
"If you have installed from the git repository using ``pip install -e .``, "
"first delete all the ``.pyc`` files (``find . -name \"*.pyc\" -delete``) "
"before updating your branch with ``git pull``."
msgstr ""

#: ../docs/source/howto/installation.rst:412
msgid "Run `reentry scan` to update the cache of registered entry points."
msgstr ""

#: ../docs/source/howto/installation.rst:414
msgid ""
"Migrate your database with ``verdi -p <profile_name> database migrate``. "
"Depending on the size of your database and the number of migrations to "
"perform, data migration can take time, so please be patient."
msgstr ""

#: ../docs/source/howto/installation.rst:417
msgid ""
"After the database migration finishes, you will be able to continue working "
"with your existing data."
msgstr ""

#: ../docs/source/howto/installation.rst:420
msgid ""
"If the update involved a change in the major version number of ``aiida-"
"core``, expect backwards incompatible changes and check whether you also "
"need to update installed plugin packages."
msgstr ""

#: ../docs/source/howto/installation.rst:423
msgid "Updating from 0.x.* to 1.*"
msgstr ""

#: ../docs/source/howto/installation.rst:424
msgid ""
"`Additional instructions on how to migrate from 0.12.x versions "
"<https://aiida.readthedocs.io/projects/aiida-"
"core/en/v1.2.1/install/updating_installation.html#updating-"
"from-0-12-to-1>`_."
msgstr ""

#: ../docs/source/howto/installation.rst:425
msgid ""
"`Additional instructions on how to migrate from versions 0.4 -- 0.11 "
"<https://aiida.readthedocs.io/projects/aiida-"
"core/en/v1.2.1/install/updating_installation.html#older-versions>`_."
msgstr ""

#: ../docs/source/howto/installation.rst:426
msgid ""
"For a list of breaking changes between the 0.x and the 1.x series of AiiDA, "
"`see here <https://aiida.readthedocs.io/projects/aiida-"
"core/en/v1.2.1/install/updating_installation.html#breaking-changes-"
"from-0-12-to-1>`_."
msgstr ""

#: ../docs/source/howto/installation.rst:434
msgid "Backing up your installation"
msgstr ""

#: ../docs/source/howto/installation.rst:436
msgid ""
"A full backup of an AiiDA instance and AiiDA managed data requires a backup "
"of:"
msgstr ""

#: ../docs/source/howto/installation.rst:438
msgid ""
"the profile configuration in the ``config.json`` file located in the "
"``.aiida`` folder. Typically located at ``~/.aiida`` (see also "
":ref:`intro:install:setup`)."
msgstr ""

#: ../docs/source/howto/installation.rst:441
msgid ""
"files associated with nodes in the repository folder (one per profile). "
"Typically located in the ``.aiida`` folder."
msgstr ""

#: ../docs/source/howto/installation.rst:443
msgid "queryable metadata in the PostgreSQL database (one per profile)."
msgstr ""

#: ../docs/source/howto/installation.rst:449
msgid "Repository backup (``.aiida`` folder)"
msgstr ""

#: ../docs/source/howto/installation.rst:451
msgid ""
"For **small repositories** (with less than ~100k files), simply back up the "
"``.aiida`` folder using standard backup software. For example, the ``rsync``"
" utility supports incremental backups, and a backup command might look like "
"``rsync -avHzPx`` (verbose) or ``rsync -aHzx``."
msgstr ""

#: ../docs/source/howto/installation.rst:454
msgid ""
"For **large repositories** with millions of files, even incremental backups "
"can take a significant amount of time. AiiDA provides a helper script that "
"takes advantage of the AiiDA database in order to figure out which files "
"have been added since your last backup. The instructions below explain how "
"to use it:"
msgstr ""

#: ../docs/source/howto/installation.rst:458
msgid ""
"Configure your backup using ``verdi -p PROFILENAME devel configure-backup`` "
"where ``PROFILENAME`` is the name of the AiiDA profile that should be backed"
" up. This will ask for information on:"
msgstr ""

#: ../docs/source/howto/installation.rst:461
msgid ""
"The \"backup folder\", where the backup *configuration file* will be placed."
" This defaults to a folder named ``backup_PROFILENAME`` in your ``.aiida`` "
"directory."
msgstr ""

#: ../docs/source/howto/installation.rst:464
msgid ""
"The \"destination folder\", where the files of the backup will be stored. "
"This defaults to a subfolder of the backup folder but we **strongly suggest "
"to back up to a different drive** (see note below)."
msgstr ""

#: ../docs/source/howto/installation.rst:467
msgid ""
"The configuration step creates two files in the \"backup folder\": a "
"``backup_info.json`` configuration file (can also be edited manually) and a "
"``start_backup.py`` script."
msgstr ""

#: ../docs/source/howto/installation.rst:471
msgid ""
"Using the same disk for your backup forgoes protection against the most "
"common cause of data loss: disk failure. One simple option is to use a "
"destination folder mounted over ssh."
msgstr ""

#: ../docs/source/howto/installation.rst:474
msgid ""
"On Ubuntu, install ``sshfs`` using ``sudo apt-get install sshfs``. Imagine "
"you run your calculations on `server_1` and would like to back up regularly "
"to `server_2`. Mount a `server_2` directory on `server_1` using the "
"following command on `server_1`:"
msgstr ""

#: ../docs/source/howto/installation.rst:482
msgid ""
"Use ``gnome-session-properties`` in the terminal to add this line to the "
"actions performed at start-up. Do **not** add it to your shell's startup "
"file (e.g. ``.bashrc``) or your computer will complain that the mount point "
"is not empty whenever you open a new terminal."
msgstr ""

#: ../docs/source/howto/installation.rst:485
msgid ""
"Run the ``start_backup.py`` script in the \"backup folder\" to start the "
"backup."
msgstr ""

#: ../docs/source/howto/installation.rst:487
msgid ""
"This will back up all data added after the ``oldest_object_backedup`` date. "
"It will only carry out a new backup every ``periodicity`` days, until a "
"certain end date if specified (using ``end_date_of_backup`` or "
"``days_to_backup``), see :ref:`this reference page <reference:backup-script-"
"config-options>` for a detailed description of all options."
msgstr ""

#: ../docs/source/howto/installation.rst:490
msgid ""
"Once you've checked that it works, make sure to run the script periodically "
"(e.g. using a daily cron job)."
msgstr ""

#: ../docs/source/howto/installation.rst:494
msgid ""
"This is a quick note on how to setup a cron job on Linux (you can find many "
"more resources online)."
msgstr ""

#: ../docs/source/howto/installation.rst:496
msgid "On Ubuntu, you can set up a cron job using:"
msgstr ""

#: ../docs/source/howto/installation.rst:502
msgid "It will open an editor, where you can add a line of the form::"
msgstr ""

#: ../docs/source/howto/installation.rst:506
msgid "or (if you need to backup a different profile than the default one)::"
msgstr ""

#: ../docs/source/howto/installation.rst:510
msgid ""
"This will launch the backup of the database every day at 3 AM (03:00), and "
"send the output (or any error message) to the email address specified at the"
" end (provided the ``mail`` command -- from ``mailutils`` -- is configured "
"appropriately)."
msgstr ""

#: ../docs/source/howto/installation.rst:514
msgid ""
"You might want to exclude the file repository from any separately set up "
"automatic backups of your home directory."
msgstr ""

#: ../docs/source/howto/installation.rst:519
msgid "Database backup"
msgstr ""

#: ../docs/source/howto/installation.rst:521
msgid ""
"PostgreSQL typically spreads database information over multiple files that, "
"if backed up directly, are not guaranteed to restore the database. We "
"therefore strongly recommend to periodically dump the database contents to a"
" file (which you can then back up using your method of choice)."
msgstr ""

#: ../docs/source/howto/installation.rst:524
msgid "A few useful pointers:"
msgstr ""

#: ../docs/source/howto/installation.rst:526
msgid ""
"In order to avoid having to enter your database password each time you use "
"the script, you can create a file ``.pgpass`` in your home directory "
"containing your database credentials, as described `in the PostgreSQL "
"documentation <https://www.postgresql.org/docs/12/libpq-pgpass.html>`_."
msgstr ""

#: ../docs/source/howto/installation.rst:528
msgid ""
"In order to dump your database, use the `pg_dump utility from PostgreSQL "
"<https://www.postgresql.org/docs/12/app-pgdump.html>`_. You can use as a "
"starting example a bash script similar to :download:`this file "
"<include/backup_postgresql.sh>`."
msgstr ""

#: ../docs/source/howto/installation.rst:530
msgid ""
"You can setup the backup script to run daily using cron (see notes in the "
":ref:`previous section <how-to:installation:backup:repository>`)."
msgstr ""

#: ../docs/source/howto/installation.rst:535
msgid "Restore backup"
msgstr ""

#: ../docs/source/howto/installation.rst:537
msgid "In order to restore a backup, you will need to:"
msgstr ""

#: ../docs/source/howto/installation.rst:539
msgid ""
"Restore the repository folder that you backed up earlier in the same "
"location as it used to be (you can check the location in the ``config.json``"
" file inside your ``.aiida`` folder, or simply using ``verdi profile "
"show``)."
msgstr ""

#: ../docs/source/howto/installation.rst:541
msgid ""
"Create an empty database following the instructions described in "
":ref:`database <intro:install:database>` skipping the ``verdi setup`` phase."
" The database should have the same name and database username as the "
"original one (i.e. if you are restoring on the original postgresql cluster, "
"you may have to either rename or delete the original database)."
msgstr ""

#: ../docs/source/howto/installation.rst:544
msgid ""
"Change directory to the folder containing the database dump created with "
"``pg_dump``, and load it using the ``psql`` command."
msgstr ""

#: ../docs/source/howto/installation.rst:548
msgid ""
"This is an example command, assuming that your dump is named ``aiidadb-"
"backup.psql``:"
msgstr ""

#: ../docs/source/howto/installation.rst:554
msgid ""
"After supplying your database password, the database should be restored. "
"Note that, if you installed the database on Ubuntu as a system service, you "
"need to type ``sudo su - postgres`` to become the ``postgres`` UNIX user."
msgstr ""

#: ../docs/source/howto/installation.rst:560
msgid "Managing multiple users"
msgstr ""

#: ../docs/source/howto/installation.rst:561
msgid ""
"Setups with multiple users for a single AiiDA instance are currently not "
"supported. Instead, each AiiDA user should install AiiDA in a Unix/Windows "
"account on their own computer. Under this account it is possible to "
"configure all the credentials necessary to connect to remote computers. "
"Using independent accounts will ensure that, for instance, the SSH "
"credentials to connect to supercomputers are not shared with others."
msgstr ""

#: ../docs/source/howto/installation.rst:566
msgid ""
"Data can be shared between instances using :ref:`AiiDA's export and import "
"functionality <how-to:share:archives>`. Sharing (subsets of) the AiiDA graph"
" can be done as often as needed."
msgstr ""

#: ../docs/source/howto/interact.rst:5
msgid "How to interact with AiiDA"
msgstr ""

#: ../docs/source/howto/interact.rst:7
msgid "There are a variety of manners to interact with AiiDA:"
msgstr ""

#: ../docs/source/howto/interact.rst:9
msgid ":ref:`Through the command line interface <how-to:interact-cli>`"
msgstr ""

#: ../docs/source/howto/interact.rst:10
msgid ":ref:`Through scripts <how-to:interact-scripts>`"
msgstr ""

#: ../docs/source/howto/interact.rst:11
msgid ":ref:`Through interactive shells <how-to:interact-shell>`"
msgstr ""

#: ../docs/source/howto/interact.rst:12
msgid ":ref:`Through interactive notebooks <how-to:interact-notebook>`"
msgstr ""

#: ../docs/source/howto/interact.rst:13
msgid ":ref:`Through the REST API <how-to:interact-restapi>`"
msgstr ""

#: ../docs/source/howto/interact.rst:19
msgid "Command line interface"
msgstr ""

#: ../docs/source/howto/interact.rst:21
msgid ""
"AiiDA comes with a command line interface called ``verdi``. The "
":ref:`reference:command-line` section gives an overview of all available "
"commands. For more detailed information, refer to the topic section "
":ref:`topics:cli`."
msgstr ""

#: ../docs/source/howto/interact.rst:29
msgid "Scripts"
msgstr ""

#: ../docs/source/howto/interact.rst:31
msgid ""
"AiiDA's Python API can be used in Python scripts mixed with any other Python"
" code. The only requirement is that before the API is used an AiiDA profile "
"is loaded. The recommended way of accomplishing this is to run the script "
"through the command line interface:"
msgstr ""

#: ../docs/source/howto/interact.rst:39
msgid ""
"The ``verdi`` CLI will automatically load the default profile, before "
"calling the actual script, passing any command line arguments that may have "
"been specified."
msgstr ""

#: ../docs/source/howto/interact.rst:43 ../docs/source/howto/interact.rst:81
msgid ""
"A :ref:`different profile can be selected <topics:cli:profile>` using the "
"``--profile`` option, just as for all other ``verdi`` commands."
msgstr ""

#: ../docs/source/howto/interact.rst:45
msgid ""
"Alternatively, one can also add AiiDA's specific `shebang "
"<https://en.wikipedia.org/wiki/Shebang_(Unix)>`_ to the top of the file."
msgstr ""

#: ../docs/source/howto/interact.rst:51
msgid ""
"When a script starts with this shebang, when it is executed, it is "
"automatically passed to ``verdi run`` just as if it would have been called "
"through ``verdi run`` directly. This has the advantage that one no longer "
"has to explicitly type ``verdi run`` when running the script, but can simply"
" make it executable and execute it directly. The downside is that it does "
"not allow to specify a particular profile, but it always loads the default "
"profile."
msgstr ""

#: ../docs/source/howto/interact.rst:55
msgid ""
"If, for whatever reason, ``verdi run`` nor the special shebang can be used, "
"a profile can also be loaded directly through the API within the Python "
"script itself:"
msgstr ""

#: ../docs/source/howto/interact.rst:62 ../docs/source/howto/interact.rst:95
msgid ""
"One can pass a particular profile name to "
":meth:`~aiida.manage.configuration.load_profile`, otherwise the default "
"profile is loaded."
msgstr ""

#: ../docs/source/howto/interact.rst:68
msgid "Interactive shells"
msgstr ""

#: ../docs/source/howto/interact.rst:70
msgid ""
"AiiDA provides a Python API that can be used from an interactive shell, such"
" as `IPython <https://ipython.org/>`_. The recommended way of starting an "
"interactive shell session to work with AiiDA, is through the command line "
"interface:"
msgstr ""

#: ../docs/source/howto/interact.rst:77
msgid ""
"This command will open a normal IPython shell but automatically loads the "
"default AiiDA profile, which is required to use the Python API."
msgstr ""

#: ../docs/source/howto/interact.rst:83
msgid ""
"In addition to automatically loading an AiiDA profile, certain modules from "
"AiiDA's API that are used very often are automatically imported. The modules"
" that are pre-loaded can be configured using the :ref:`reference:command-"
"line:verdi-config` command."
msgstr ""

#: ../docs/source/howto/interact.rst:86
msgid ""
"If, for whatever reason, you cannot use ``verdi shell``, a profile can also "
"be loaded directly through the API within the shell itself:"
msgstr ""

#: ../docs/source/howto/interact.rst:101
msgid "Interactive notebooks"
msgstr ""

#: ../docs/source/howto/interact.rst:103
msgid ""
"Similar to :ref:`interactive shells <how-to:interact-shell>`, AiiDA is also "
"directly compatbile with interactive Python notebooks, such as `Jupyter "
"<https://jupyter.org/>`_. To use AiiDA's Python API in a notebook, first a "
"profile has to be loaded:"
msgstr ""

#: ../docs/source/howto/interact.rst:113
msgid ""
"One can pass a particular profile name to "
":meth:`~aiida.manage.configuration.load_profile`, otherwise the default "
"profile is loaded. The same can be accomplished using the following magic "
"statement:"
msgstr ""

#: ../docs/source/howto/interact.rst:120
msgid ""
"This magic line will replicate the same environment as :ref:`the interactive"
" shell <how-to:interact-shell>` provided by ``verdi shell``. However, it "
"does require some one-time installation, as detailed in the section on how "
"to :ref:`intro:install:jupyter`."
msgstr ""

#: ../docs/source/howto/interact.rst:127
msgid "REST API"
msgstr ""

#: ../docs/source/howto/interact.rst:129
msgid ""
"AiiDA ships with a built in REST API, that allows you to query the data of a"
" particular profile. Refer to section :ref:`how-to:share:serve:launch` to "
"learn how to start the REST API. The section :ref:`how-to:share:serve:query`"
" provides information on how to interact with a running REST API."
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:5
msgid "How to write a plugin for an external code"
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:9
msgid ""
"Before starting to write a new plugin, check the `aiida plugin registry "
"<https://aiidateam.github.io/aiida-registry/>`_. If a plugin for your code "
"is already available, you can skip straight to :ref:`how-to:run-codes`."
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:14
msgid ""
"This how to walks you through all logical steps of how AiiDA interacts with "
"an external code. If you already know the basics and would like to get "
"started with a new plugin package quickly, check out :ref:`how-to:plugins-"
"develop`."
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:17
msgid ""
"To run an external code with AiiDA, you need a corresponding *calculation* "
"plugin, which tells AiiDA how to:"
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:19
msgid "Prepare the required input files."
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:20
msgid "Run the code with the correct command line parameters."
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:22
msgid ""
"Finally, you will probably want a *parser* plugin, which tells AiiDA how to:"
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:24
msgid "Parse the output of the code."
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:26
msgid ""
"This how-to takes you through the process of :ref:`creating a calculation "
"plugin<how-to:plugin-codes:interfacing>` for a simple executable that sums "
"two numbers, using it to :ref:`run the code<how-to:plugin-codes:run>`, and "
":ref:`writing a parser <how-to:plugin-codes:parsing>` for its outputs."
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:28
msgid ""
"In the following, as an example, our |Code| will be the `bash` executable, "
"and our \"input file\" will be a `bash` script ``aiida.in`` that sums two "
"numbers and prints the result:"
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:34
msgid "We will run this as:"
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:40
msgid ""
"thus writing the sum of the two numbers ``numx`` and ``numy`` (provided by "
"the user) to the output file ``aiida.out``."
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:43
#: ../docs/source/howto/plugin_codes.rst:263
#: ../docs/source/howto/plugin_codes.rst:433
#: ../docs/source/howto/plugins_develop.rst:10
msgid "Todo"
msgstr "步骤"

#: ../docs/source/howto/plugin_codes.rst:45
msgid ""
"Add to preceding sentence: :ref:`the communication with external machines"
"<how-to:plugin-codes:transport>` and the interaction with its "
":ref:`scheduling software<how-to:plugin-codes:scheduler>`."
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:51
msgid "Interfacing external codes"
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:53
msgid ""
"Start by creating a file ``calculations.py`` and subclass the |CalcJob| "
"class:"
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:67
msgid ""
"In the following, we will tell AiiDA how to run our code by implementing two"
" key methods:"
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:69
msgid ":py:meth:`~aiida.engine.processes.calcjobs.calcjob.CalcJob.define`"
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:70
msgid ""
":py:meth:`~aiida.engine.processes.calcjobs.calcjob.CalcJob.prepare_for_submission`"
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:73
msgid "Defining the spec"
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:75
msgid ""
"The |define| method tells AiiDA which inputs the |CalcJob| expects and which"
" outputs it produces (exit codes will be :ref:`discussed later<how-to"
":plugin-codes:parsing:errors>`). This is done through an instance of the "
":py:class:`~aiida.engine.processes.process_spec.CalcJobProcessSpec` class, "
"which is passed as the |spec| argument to the |define| method. For example:"
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:83
msgid ""
"The first line of the method calls the |define| method of the |CalcJob| "
"parent class. This necessary step defines the `inputs` and `outputs` that "
"are common to all |CalcJob|'s."
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:86
msgid ""
"Next, we use the :py:meth:`~plumpy.process_spec.ProcessSpec.input` method in"
" order to define our two input numbers ``x`` and ``y`` (we support integers "
"and floating point numbers), and we use "
":py:meth:`~plumpy.process_spec.ProcessSpec.output` to define the only output"
" of the calculation with the label ``sum``. AiiDA will attach the outputs "
"defined here to a (successfully) finished calculation using the link label "
"provided."
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:90
msgid ""
"This holds for *required* outputs (the default behaviour). Use "
"``required=False`` in order to mark an output as optional."
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:95
msgid ""
"For the input parameters and input files of more complex simulation codes, "
"consider using :py:class:`~aiida.orm.nodes.data.dict.Dict` (python "
"dictionary) and :py:class:`~aiida.orm.nodes.data.singlefile.SinglefileData` "
"(file wrapper) input nodes."
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:97
msgid ""
"Finally, we set a couple of default ``options``, such as the name of the "
"parser (which we will implement later), the name of input and output files, "
"and the computational resources to use for such a calculation. These "
"``options`` have already been defined on the |spec| by the "
"``super().define(spec)`` call, and they can be accessed through the "
":py:attr:`~plumpy.process_spec.ProcessSpec.inputs` attribute, which behaves "
"like a dictionary."
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:102
msgid ""
"One more important input required by any |CalcJob| is which external "
"executable to use. External executables are represented by |Code|  instances"
" that contain information about the computer they reside on, their path in "
"the file system and more."
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:105
msgid ""
"They are passed to a |CalcJob| via the ``code`` input, which is defined in "
"the |CalcJob| base class, so you don't have to:"
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:113
msgid ""
"There is no ``return`` statement in ``define``: the ``define`` method "
"directly modifies the |spec| object it receives. For more details on setting"
" up your `inputs` and `outputs` (covering validation, dynamic number of "
"inputs, etc.) see the :ref:`Defining Processes "
"<topics:processes:usage:defining>` topic."
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:117
msgid "Preparing for submission"
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:119
msgid ""
"The "
":py:meth:`~aiida.engine.processes.calcjobs.calcjob.CalcJob.prepare_for_submission`"
" method has two jobs: Creating the input files in the format the external "
"code expects and returning a "
":py:class:`~aiida.common.datastructures.CalcInfo` object that contains "
"instructions for the AiiDA engine on how the code should be run. For "
"example:"
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:127
msgid ""
"Unlike the |define| method, the ``prepare_for_submission`` method is "
"implemented from scratch and so there is no super call."
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:129
msgid ""
"The first step is writing the simple bash script mentioned in the beginning:"
" summing the numbers ``x`` and ``y``, using Python's string interpolation to"
" replace the ``x`` and ``y`` placeholders with the actual values "
"``self.inputs.x`` and ``self.inputs.y`` that were provided as inputs by the "
"caller."
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:131
msgid ""
"All inputs provided to the calculation are validated against the ``spec`` "
"*before* |prepare_for_submission| is called. Therefore, when accessing the "
":py:attr:`~plumpy.processes.Process.inputs` attribute, you can safely assume"
" that all required inputs have been set and that all inputs have a valid "
"type."
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:134
msgid ""
"The ``folder`` argument (a |Folder| instance) allows us to write the input "
"file to a sandbox folder, whose contents will be transferred to the compute "
"resource where the actual calculation takes place. In this example, we only "
"create a single input file, but you can create as many as you need, "
"including subfolders if required."
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:139
msgid ""
"By default, the contents of the sandbox ``folder`` are also stored "
"permanently in the file repository of the calculation node for additional "
"provenance guarantees. There are cases (e.g. license issues, file size) "
"where you may want to change this behavior and :ref:`exclude files from "
"being "
"stored<topics:calculations:usage:calcjobs:file_lists_provenance_exclude>`."
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:142
msgid ""
"After having written the necessary input files, we let AiiDA know how to run"
" the code via the |CodeInfo| object."
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:144
msgid ""
"First, we forward the ``uuid`` of the |Code|  instance passed by the user "
"via the generic ``code`` input mentioned previously (in this example, the "
"``code`` will represent a ``bash`` executable)."
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:146
msgid "Second, let's recall how we want our executable to be run:"
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:154
msgid ""
"We want to pass our input file to the executable via standard input, and "
"record standard output of the executable in the output file -- this is done "
"using the ``stdin_name`` and ``stdout_name`` attributes of the |CodeInfo|."
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:158
msgid ""
"Many executables don't read from standard input but instead require the path"
" to an input file to be passed via command line parameters (potentially "
"including further configuration options). In that case, use the |CodeInfo| "
"``cmdline_params`` attribute:"
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:167
msgid ""
"``self.options.input_filename`` is just a shorthand for "
"``self.inputs.metadata['options']['input_filename']``."
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:169
msgid ""
"Finally, we pass the |CodeInfo| to a |CalcInfo| object (one calculation job "
"can involve more than one executable, so ``codes_info`` is a list). We "
"define the ``retrieve_list`` of filenames that the engine should retrieve "
"from the directory where the job ran after it has finished. The engine will "
"store these files in a |FolderData| node that will be attached as an output "
"node to the calculation with the label ``retrieved``. There are :ref:`other "
"file lists available<topics:calculations:usage:calcjobs:file_lists>` that "
"allow you to easily customize how to move files to and from the remote "
"working directory in order to prevent the creation of unnecessary copies."
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:174
msgid ""
"This was an example of how to implement the |CalcJob| class to interface "
"AiiDA with an external code. For more details on the |CalcJob| class, refer "
"to the Topics section on :ref:`defining calculations "
"<topics:calculations:usage>`."
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:180
msgid "Parsing the outputs"
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:182
msgid ""
"Parsing the output files produced by a code into AiiDA nodes is optional, "
"but it can make your data queryable and therefore easier to access and "
"analyze."
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:184
msgid ""
"To create a parser plugin, subclass the |Parser| class (for example in a "
"file called ``parsers.py``) and implement its "
":py:meth:`~aiida.parsers.parser.Parser.parse` method. The following is an "
"example of a simple implementation:"
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:191
msgid ""
"Before the ``parse()`` method is called, two important attributes are set on"
" the |Parser|  instance:"
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:193
msgid ""
"``self.retrieved``: An instance of |FolderData|, which points to the folder "
"containing all output files that the |CalcJob| instructed to retrieve, and "
"provides the means to :py:meth:`~aiida.orm.nodes.node.Node.open` any file it"
" contains."
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:195
msgid ""
"``self.node``: The "
":py:class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode` "
"representing the finished calculation, which, among other things, provides "
"access to all of its inputs (``self.node.inputs``)."
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:197
msgid ""
"The "
":py:meth:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.get_option`"
" convenience method is used to get the filename of the output file. Its "
"content is cast to an integer, since the output file should contain the sum "
"produced by the ``aiida.in`` bash script."
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:200
msgid ""
"Finally, the :py:meth:`~aiida.parsers.parser.Parser.out` method is used to "
"link the parsed sum as an output of the calculation. The first argument is "
"the name of the output, which will be used as the label for the link that "
"connects the calculation and data node, and the second is the node that "
"should be recorded as an output. Note that the type of the output should "
"match the type that is specified by the process specification of the "
"corresponding |CalcJob|. If any of the registered outputs do not match the "
"specification, the calculation will be marked as failed."
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:205
msgid ""
"In order to request automatic parsing of a |CalcJob| (once it has finished),"
" users can set the ``metadata.options.parser_name`` input when launching the"
" job. If a particular parser should be used by default, the |CalcJob| "
"``define`` method can set a default value for the parser name as was done in"
" the :ref:`previous section <how-to:plugin-codes:interfacing>`:"
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:215
msgid ""
"Note, that the default is not set to the |Parser| class itself, but the "
"*entry point string* under which the parser class is registered. How to "
"register a parser class through an entry point is explained in the how-to "
"section on :ref:`registering plugins <how-to:plugins-develop>`."
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:222
msgid "Handling parsing errors"
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:224
msgid ""
"So far, we have not spent much attention on dealing with potential errors "
"that can arise when running external codes. However, there are lots of ways "
"in which codes can fail to execute nominally. A |Parser| can play an "
"important role in detecting and communicating such errors, where "
":ref:`workflows <how-to:run-workflows>` can then decide how to proceed, "
"e.g., by modifying input parameters and resubmitting the calculation."
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:228
msgid ""
"Parsers communicate errors through :ref:`exit "
"codes<topics:processes:concepts:exit_codes>`, which are defined in the "
"|spec| of the |CalcJob| they parse. The "
":py:class:`~aiida.calculations.arithmetic.add.ArithmeticAddCalculation` "
"example, defines the following exit codes:"
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:237
msgid "Each ``exit_code`` defines:"
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:239
msgid "an exit status (a positive integer),"
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:240
msgid ""
"a label that can be used to reference the code in the |parse| method "
"(through the ``self.exit_codes`` property, as shown below), and"
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:241
msgid "a message that provides a more detailed description of the problem."
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:243
msgid ""
"In order to inform AiiDA about a failed calculation, simply return from the "
"``parse`` method the exit code that corresponds to the detected issue. Here "
"is a more complete version of the example |Parser| presented in the previous"
" section:"
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:250
msgid "It checks:"
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:252
msgid "Whether a retrieved folder is present."
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:253
msgid ""
"Whether the output file can be read (whether ``open()`` or ``read()`` will "
"throw an ``OSError``)."
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:254
msgid "Whether the output file contains an integer."
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:255
msgid "Whether the sum is negative."
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:257
msgid ""
"AiiDA stores the exit code returned by the |parse| method on the calculation"
" node that is being parsed, from where it can then be inspected further down"
" the line. The Topics section on :ref:`defining processes "
"<topics:processes:usage:defining>` provides more details on exit codes. Note"
" that scheduler plugins can also implement parsing of the output generated "
"by the job scheduler and in the case of problems can set an exit code. The "
"Topics section on :ref:`scheduler exit codes "
"<topics:calculations:usage:calcjobs:scheduler-errors>` explains how they can"
" be inspected inside an output parser and how they can optionally be "
"overridden."
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:267
msgid "title: Configuring remote computers"
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:269
msgid "`#4123`_"
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:274
msgid "Registering entry points"
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:276
msgid ""
":ref:`Entry points <how-to:plugins-develop:entrypoints>` are the preferred "
"method of registering new calculation, parser and other plugins with AiiDA."
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:278
msgid ""
"With your ``calculations.py`` and ``parsers.py`` files at hand, let's "
"register entry points for the plugins they contain:"
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:280
msgid "Move your two scripts into a subfolder ``aiida_add``:"
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:287
msgid "You have just created an ``aiida_add`` Python *package*!"
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:289
msgid "Write a minimalistic ``setup.py`` script for your new package:"
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:305
msgid ""
"Strictly speaking, ``aiida-add`` is the name of the *distribution*, while "
"``aiida_add`` is the name of the *package*. The aiida-core documentation "
"uses the term *package* a bit more loosely."
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:309
msgid ""
"Install your new ``aiida-add`` plugin package. See the :ref:`how-to:plugins-"
"install` section for details."
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:312
msgid "After this, you should see your plugins listed:"
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:325
msgid "Running a calculation"
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:327
msgid ""
"With the entry points set up, you are ready to launch your first calculation"
" with the new plugin:"
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:330
msgid ""
"If you haven't already done so, :ref:`set up your computer<how-to:run-"
"codes:computer>`. In the following we assume it to be the localhost:"
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:338
msgid "Write a ``launch.py`` script:"
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:368
msgid ""
"``output_dict`` is a dictionary containing all the output nodes keyed after "
"their label. In this case: \"remote_folder\", \"retrieved\" and \"sum\"."
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:372
#: ../docs/source/howto/plugin_codes.rst:412
msgid "Launch the calculation:"
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:379
msgid ""
"If everything goes well, this should print the results of your calculation, "
"something like:"
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:388
msgid ""
"If you encountered a parsing error, it can be helpful to make a "
":ref:`topics:calculations:usage:calcjobs:dry_run`, which allows you to "
"inspect the input folder generated by AiiDA before any calculation is "
"launched."
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:391
msgid ""
"Finally instead of running your calculation in the current shell, you can "
"submit your calculation to the AiiDA daemon:"
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:393
msgid "(Re)start the daemon to update its Python environment:"
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:399
msgid "Update your launch script to use:"
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:409
msgid ""
"``node`` is the |CalcJobNode| representing the state of the underlying "
"calculation process (which may not be finished yet)."
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:418
msgid "This should print the UUID and the PK of the submitted calculation."
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:420
msgid ""
"You can use the verdi command line interface to "
":ref:`monitor<topics:processes:usage:monitoring>` this processes:"
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:427
msgid "This marks the end of this how-to."
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:429
msgid ""
"The |CalcJob| and |Parser| plugins are still rather basic and the ``aiida-"
"add`` plugin package is missing a number of useful features, such as package"
" metadata, documentation, tests, CI, etc. Continue with :ref:`how-to"
":plugins-develop` in order to learn how to quickly create a feature-rich new"
" plugin package from scratch."
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:437
msgid "title: Adding support for a custom scheduler"
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:439
msgid "`#3989`_"
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:444
msgid "title: Adding support for a custom transport"
msgstr ""

#: ../docs/source/howto/plugin_codes.rst:446
msgid "`#3990`_"
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:5
msgid "How to package plugins"
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:7
msgid ""
"This section focuses on how to *package* AiiDA extensions (plugins) so that "
"they can be tested, published and eventually reused by others. For guides on"
" writing specific extensions, see :ref:`how-to:plugin-codes:interfacing` and"
" :ref:`topics:data_types:plugin`."
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:12
msgid ""
"For guides on writing specific extensions, see :ref:`how-to:plugin-"
"codes:interfacing`, :ref:'how-to:plugin-codes:scheduler', :ref:'how-to"
":plugin-codes:transport' or :ref:`topics:data_types:plugin`."
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:18
msgid "Creating a plugin package"
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:21
msgid ""
"AiiDA plugins can be bundled and distributed in a `Python package "
"<packages>`_ that provides a set of extensions to AiiDA."
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:25
msgid ""
"The Python community uses the term 'package' rather loosely. Depending on "
"context, it may refer simply to a folder containing individual Python "
"modules or it may include the files necessary for building and installing a "
"package to be distributed via the `Python Package Index (PyPI) <pypi>`_."
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:32
msgid "Quickstart"
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:34
msgid ""
"The fastest way to jumpstart an AiiDA plugin package is to use the `AiiDA "
"plugin cutter <plugin-cutter>`_ in order to template the basic folder "
"structure, already customized according to the desired name of your plugin, "
"following AiiDA conventions."
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:36
msgid ""
"Simply go to the `AiiDA plugin cutter <plugin-cutter>`_ and follow the usage"
" instructions. See also the `aiida-diff`_ demo plugin package for an in-"
"depth explanation of the files & folders produced by the plugin cutter."
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:39
msgid ""
"In the following, we explain some of the conventions implemented by the "
"AiiDA plugin cutter."
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:43
msgid "Choosing a name"
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:45
msgid ""
"The naming convention for AiiDA plugin packages is ``aiida-mycode`` for the "
"plugin distribution on `PyPI`_ and ``aiida_mycode`` for the corresponding "
"python package, leading to the following folder structure::"
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:53
msgid "Python package names cannot contain dashes, thus the underscore."
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:55
msgid ""
"If you intend to eventually publish your plugin package, please go to the "
"`AiiDA plugin registry <registry>`_  and choose a name that is not already "
"taken. You are also encouraged to pre-register your package (instructions "
"provided on the registry), both to reserve your plugin name and to inform "
"others of your ongoing development."
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:62
#: ../docs/source/howto/plugins_develop.rst:156
msgid "Folder structure"
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:64
msgid ""
"The overall folder structure of your plugin is up to you, but it is useful "
"to follow a set of basic conventions. Here is an example of a folder "
"structure for an AiiDA plugin, illustrating different levels of nesting (see"
" also the `aiida-diff demo plugin`_)::"
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:91
msgid "A minimal plugin package instead might look like::"
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:102
msgid "Registering plugins through entry points"
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:104
msgid ""
"An AiiDA plugin is an extension of AiiDA that announces itself by means of a"
" new *entry point* (for details, see :ref:`topics:plugins:entrypoints`). "
"Adding a new entry point consists of the following steps:"
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:107
msgid ""
"Deciding a name. We *strongly* suggest to start the name of each entry point"
" with the name of the plugin package (omitting the 'aiida-' prefix). For a "
"package ``aiida-mycode``, this will usually mean ``\"mycode.<something>\"``"
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:111
msgid ""
"Finding the right entry point group. You can list the entry point groups "
"defined by AiiDA via ``verdi plugin list``. For a documentation of the "
"groups, see :ref:`topics:plugins:entrypointgroups`."
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:114
msgid ""
"Adding the entry point to the ``entry_points`` field in the ``setup.json`` "
"file::"
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:124
msgid ""
"Let setuptools and reentry know about your entry point by installing your "
"plugin again::"
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:129
msgid ""
"Your new entry point should now show up in ``verdi plugin list "
"aiida.calculations``."
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:133
msgid ""
"Taking a package with the name ``aiida-diff`` as example, what does ``pip "
"install aiida-diff`` do?"
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:135
msgid "It resolves and installs the dependencies on other python packages"
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:136
msgid ""
"It creates a folder ``aiida_diff.egg-info/`` with metadata about the package"
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:137
msgid ""
"If the ``-e`` option is given, a symbolic link from the python package "
"search path to the ``aiida-diff`` directory is created and the ``.egg-info``"
" folder is put there instead. Changes to the **source code** will be picked "
"up by python without reinstalling (when restarting the interpreter),  but "
"changes to the **metadata** will not."
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:140
msgid ""
"For further details, see the Python `packaging user guide "
"<https://packaging.python.org/distributing/#configuring-your-project>`_."
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:147
msgid "Testing a plugin package"
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:149
msgid ""
"Writing tests for your AiiDA plugins and running continuous integration "
"tests using free platforms like `GitHub Actions <ghactions>`_ is the best "
"way to ensure that your plugin works and keeps working as it is being "
"developed. We recommend using the `pytest`_ framework for testing AiiDA "
"plugins."
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:152
msgid ""
"For an example of how to write tests and how to set up continuous "
"integration, see the `aiida-diff`_ demo plugin package."
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:158
msgid ""
"We suggest the following folder structure for including tests in AiiDA "
"plugin packages::"
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:165
msgid ""
"Keeping the tests outside the plugin package keeps the distribution of your "
"plugin package light."
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:168
msgid "AiiDA's fixtures"
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:170
msgid ""
"Many tests require a full AiiDA environment to be set up before the test "
"starts, e.g. some AiiDA data nodes. The pytest library has the concept of "
"`fixtures`_ for encapsulating code you would like to run before a test "
"starts. AiiDA ships with a number of fixtures in "
":py:mod:`aiida.manage.tests.pytest_fixtures` that take care of setting up "
"the test environment for you (for more details, see "
":ref:`topics:plugins:testfixtures`)."
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:174
msgid ""
"In order to make these fixtures available to your tests, create a "
"``conftest.py`` (see also `pytest docs <conftest>`_) at the root level of "
"your plugin package as follows::"
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:192
msgid ""
"You can now start writing tests e.g. in a ``tests/test_calculations.py`` "
"file::"
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:212
msgid ""
"In order to run your tests, simply type ``pytest`` at the root level or your"
" package. pytest automatically discovers and executes files, classes and "
"function names starting with the word ``test``."
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:222
msgid "Documenting a plugin package"
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:224
msgid ""
"AiiDA plugin packages are python packages, and general `best practises for "
"writing python documentation <https://docs.python-"
"guide.org/writing/documentation/>`_ apply."
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:226
msgid ""
"In the following, we mention a few hints that apply specifically to AiiDA "
"plugins."
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:229
msgid "Repository-level documentation"
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:231
msgid ""
"Since the source code of most AiiDA plugins is hosted on GitHub, the first "
"contact of a new user with your plugin package is likely the landing page of"
" your GitHub repository."
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:233
msgid ""
"Make sure to have a useful ``README.md``, describing what your plugin does "
"and how to install it."
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:234
msgid "Leaving a contact email and adding a license is also a good idea."
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:235
msgid ""
"Make sure the information in the ``setup.json`` file is correct and up to "
"date (in particular the version number), since this information is used to "
"advertise your package on the AiiDA plugin registry."
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:238
msgid "Source-code-level documentation"
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:240
msgid ""
"Source-code level documentations matters both for users of your plugin's "
"python API and, particularly, for attracting contributions from others."
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:242
msgid ""
"When adding new types of calculations or workflows, make sure to use "
"`docstrings <https://www.python.org/dev/peps/pep-0257/#what-"
"is-a-docstring>`_, and use the ``help`` argument to document input ports and"
" output ports. Users of your plugin can then inspect which inputs the "
"calculations/workflows expect and which outputs they produce directly "
"through the ``verdi`` cli. For example, try::"
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:249
msgid "Documentation website"
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:251
msgid ""
"For simple plugins, a well-written ``README.md`` can be a good start. Once "
"the README grows out of proportion, you may want to consider creating a "
"dedicated documentation website."
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:254
msgid ""
"The `Sphinx <http://www.sphinx-doc.org/en/master/>`_ tool makes it very easy"
" to create documentation websites for python packages, and the `ReadTheDocs "
"<http://readthedocs.org/>`_ service will host your sphinx documentation "
"online for free. The `aiida-diff demo plugin <aiida-diff>`_ comes with a "
"full template for a sphinx-based documentation, including a mix of manually "
"written pages and an automatically generated documentation of your plugin's "
"python API. See the `developer guide of aiida-diff <https://aiida-"
"diff.readthedocs.io/en/latest/developer_guide/index.html>`_ for instructions"
" on how to build it."
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:258
msgid ""
"AiiDA provides a sphinx extension for inserting automatically generated "
"documentations of ``Process`` classes (calculations and workflows) into your"
" sphinx documentation (analogous to the information displayed by ``verdi "
"plugin list``). Enable the extension by adding ``aiida.sphinxext`` to the "
"list of ``extensions`` in your ``docs/conf.py`` file. You can now use the "
"``aiida-process``, ``aiida-calcjob`` or ``aiida-workchain`` directives in "
"your ReST files like so::"
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:266
msgid "Here,"
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:268
msgid "``MyWorkChain`` is the name of the workchain to be documented."
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:269
msgid ""
"``:module:`` is the python module from which the workchain can be imported."
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:270
msgid ""
"``:hide-unstored-inputs:`` hides workchain inputs that are not stored in the"
" database (shown by default)."
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:274
msgid ""
"The ``aiida-workchain`` directive is hooked into ``sphinx.ext.autodoc``, "
"i.e. it is used automatically by the generic ``automodule``, ``autoclass`` "
"directives when applied to workchain classes."
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:281
msgid "Publishing a plugin package"
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:283
msgid ""
"AiiDA plugin packages are published on the `AiiDA plugin registry "
"<registry>`_ and the `python package index (PyPI) <pypi>`_."
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:285
msgid "Before publishing your plugin, make sure your plugin comes with:"
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:287
msgid "a ``setup.json`` file with the plugin metadata"
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:288
msgid "a ``setup.py`` file for installing your plugin via ``pip``"
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:289
msgid "a license"
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:291
msgid ""
"For examples of these files, see the `aiida-diff demo plugin <aiida-diff>`_."
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:296
msgid "Publishing on the plugin registry"
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:298
msgid ""
"The `AiiDA plugin registry <registry>`_ aims to be the home for all publicly"
" available AiiDA plugins. It collects information on the type of plugins "
"provided by your package, which AiiDA versions it is compatible with, etc."
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:301
msgid ""
"In order to register your plugin package, simply go to the `plugin registry "
"<registry>`_ and follow the instructions in the README."
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:305
msgid ""
"The plugin registry reads the metadata of your plugin from the "
"``setup.json`` file in your plugin repository."
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:308
msgid ""
"We encourage you to **get your plugin package listed as soon as possible**, "
"both in order to reserve the plugin name and to inform others of the ongoing"
" development."
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:311
msgid "Publishing on PyPI"
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:313
msgid ""
"For distributing AiiDA plugin packages, we recommend to follow the "
"`guidelines for packaging python projects <packaging>`_, which include "
"making the plugin available on the `python package index <PyPI>`_. This "
"makes it possible for users to simply ``pip install aiida-myplugin``."
msgstr ""

#: ../docs/source/howto/plugins_develop.rst:317
msgid ""
"When updating the version of your plugin, don't forget to update the version"
" number both in the ``setup.json`` and in ``aiida_mycode/__init__.py``."
msgstr ""

#: ../docs/source/howto/plugins_install.rst:5
msgid "How to install plugins"
msgstr ""

#: ../docs/source/howto/plugins_install.rst:7
msgid ""
"The functionality of AiiDA can be extended through plugins. There are "
"various types of functionality that can be extended, such as new :ref:`data "
"types<topics:data_types:plugin>`, :ref:`calculation plugins<how-to:plugin-"
"codes>` and much more. Multiple plugins can be bundled together and "
"distributed in a :ref:`plugin package<how-to:plugins-develop>`. The `AiiDA "
"plugin registry <https://aiidateam.github.io/aiida-registry>`_ gives an "
"overview of public plugin packages."
msgstr ""

#: ../docs/source/howto/plugins_install.rst:12
msgid ""
"Installing an AiiDA plugin package is done with `pip "
"<https://pypi.org/project/pip/>`_. If the package is distributed via the "
"`Python Package Index (PyPI) <https://pypi.org/search/?q=aiida>`_ you can "
"install it as follows:"
msgstr ""

#: ../docs/source/howto/plugins_install.rst:19
msgid ""
"A package can also be installed from the source code. For example, if the "
"code is available through a Git repository:"
msgstr ""

#: ../docs/source/howto/plugins_install.rst:30
msgid ""
"Each time when you install a new plugin package you should make sure to run "
"the following command to let AiiDA know about the new plugins that come with"
" it:"
msgstr ""

#: ../docs/source/howto/plugins_install.rst:36
msgid ""
"If you forget to run this command, AiiDA will not be able to find the "
"plugins. The reentry cache can also be updated from python when access to "
"the commandline is not available (e.g. in Jupyter notebooks)."
msgstr ""

#: ../docs/source/howto/plugins_install.rst:46
msgid ""
"If your daemon was running when installing or updating a plugin package, "
"make sure to restart it with the ``--reset`` flag for changes to take "
"effect:"
msgstr ""

#: ../docs/source/howto/plugins_install.rst:52
msgid "This needs to be done *after* the command ``reentry scan`` is called."
msgstr ""

#: ../docs/source/howto/plugins_install.rst:54
msgid "To verify which plugins are currently installed, use the command:"
msgstr ""

#: ../docs/source/howto/plugins_install.rst:60
msgid ""
"It will list the various categories of functionality that can be extended "
"through plugins. To see which plugins are installed for any of these "
"categories, pass the category name as an argument, e.g.:"
msgstr ""

#: ../docs/source/howto/run_codes.rst:5
msgid "How to run external codes"
msgstr "如何运行外部计算代码"

#: ../docs/source/howto/run_codes.rst:7
msgid ""
"This how-to walks you through the steps of setting up a (possibly remote) "
"compute resource, setting up a code on that computer, and submitting a "
"calculation through AiiDA (similar to the :ref:`introductory tutorial "
"<tutorial:basic:calcjob>`, but in more detail)."
msgstr ""

#: ../docs/source/howto/run_codes.rst:9
msgid ""
"To run an external code with AiiDA, you need an appropriate "
":ref:`calculation plugin <topics:plugins>`. In the following, we assume that"
" a plugin for your code is already available from the `aiida plugin registry"
" <https://aiidateam.github.io/aiida-registry/>`_ and installed on your "
"machine. Refer to the :ref:`how-to:plugins-install` section for details on "
"how to install an existing plugin. If a plugin for your code is not yet "
"available, see :ref:`how-to:plugin-codes`."
msgstr ""

#: ../docs/source/howto/run_codes.rst:14
msgid ""
"Throughout the process, you will be prompted for information on the computer"
" and code. In these prompts:"
msgstr ""

#: ../docs/source/howto/run_codes.rst:17
msgid ""
"Type ``?`` followed by ``<enter>`` to get help on what is being asked at any"
" prompt."
msgstr ""

#: ../docs/source/howto/run_codes.rst:18
msgid ""
"Press ``<CTRL>+C`` at any moment to abort the setup process. Your AiiDA "
"database will remain unmodified."
msgstr ""

#: ../docs/source/howto/run_codes.rst:23
msgid ""
"The ``verdi`` commands use ``readline`` extensions to provide default "
"answers, which require an advanced terminal. Use a standard terminal -- "
"terminals embedded in some text editors (such as ``emacs``) have been known "
"to cause problems."
msgstr ""

#: ../docs/source/howto/run_codes.rst:29
msgid "How to set up a computer"
msgstr ""

#: ../docs/source/howto/run_codes.rst:31
msgid ""
"A |Computer| in AiiDA denotes a computational resource on which you will run"
" your calculations. It can either be:"
msgstr ""

#: ../docs/source/howto/run_codes.rst:34
msgid "the machine where AiiDA is installed or"
msgstr ""

#: ../docs/source/howto/run_codes.rst:35
msgid ""
"any machine that is accessible via `SSH "
"<https://en.wikipedia.org/wiki/Secure_Shell>`_ from the machine where AiiDA "
"is installed (possibly :ref:`via a proxy server<how-to:ssh:proxy>`)."
msgstr ""

#: ../docs/source/howto/run_codes.rst:37
msgid ""
"The second option allows managing multiple remote compute resources "
"(including HPC clusters and cloud services) from the same AiiDA installation"
" and moving computational jobs between them."
msgstr ""

#: ../docs/source/howto/run_codes.rst:41
msgid ""
"The second option requires access through an SSH keypair. If your compute "
"resource demands two-factor authentication, you may need to install AiiDA "
"directly on the compute resource instead."
msgstr ""

#: ../docs/source/howto/run_codes.rst:46
msgid "Computer requirements"
msgstr ""

#: ../docs/source/howto/run_codes.rst:48
msgid "Each computer must satisfy the following requirements:"
msgstr ""

#: ../docs/source/howto/run_codes.rst:50
msgid ""
"It runs a Unix-like operating system (Linux distros and MacOS should work "
"fine)"
msgstr ""

#: ../docs/source/howto/run_codes.rst:51
msgid "It has ``bash`` installed"
msgstr ""

#: ../docs/source/howto/run_codes.rst:52
msgid ""
"(optional) It has batch scheduler installed (see the :ref:`list of supported"
" schedulers <topics:schedulers>`)"
msgstr ""

#: ../docs/source/howto/run_codes.rst:54
msgid ""
"If you are configuring a remote computer, start by :ref:`configuring "
"password-less SSH access <how-to:ssh>` to it."
msgstr ""

#: ../docs/source/howto/run_codes.rst:58
msgid ""
"AiiDA will use ``bash`` on the remote computer, regardless of the default "
"shell. Please ensure that your remote ``bash`` configuration does not load a"
" different shell."
msgstr ""

#: ../docs/source/howto/run_codes.rst:65
msgid "Computer setup"
msgstr ""

#: ../docs/source/howto/run_codes.rst:67
msgid ""
"The configuration of computers happens in two steps: setting up the public "
"metadata associated with the |Computer| in AiiDA provenance graphs, and "
"configuring private connection details."
msgstr ""

#: ../docs/source/howto/run_codes.rst:69
msgid "Start by creating a new computer instance in the database:"
msgstr ""

#: ../docs/source/howto/run_codes.rst:75
msgid ""
"At the end, the command will open your default editor on a file containing a"
" summary of the configuration up to this point. You can add ``bash`` "
"commands that will be executed"
msgstr ""

#: ../docs/source/howto/run_codes.rst:78
msgid ""
"*before* the actual execution of the job (under 'Pre-execution script'), and"
msgstr ""

#: ../docs/source/howto/run_codes.rst:79
msgid "*after* the script submission (under 'Post execution script')."
msgstr ""

#: ../docs/source/howto/run_codes.rst:81
msgid ""
"Use these additional lines to perform any further set up of the environment "
"on the computer, for example loading modules or exporting environment "
"variables:"
msgstr ""

#: ../docs/source/howto/run_codes.rst:90
msgid ""
"Don't specify settings here that are specific to a code or calculation: you "
"can set further pre-execution commands at the ``Code`` and even ``CalcJob`` "
"level."
msgstr ""

#: ../docs/source/howto/run_codes.rst:92
msgid ""
"When you are done editing, save and quit. The computer has now been created "
"in the database but you still need to *configure* access to it using your "
"credentials."
msgstr ""

#: ../docs/source/howto/run_codes.rst:96
msgid ""
"In order to avoid having to retype the setup information the next time "
"around, you can provide some (or all) of the information via a configuration"
" file:"
msgstr ""

#: ../docs/source/howto/run_codes.rst:102
msgid ""
"where ``computer.yml`` is a configuration file in the `YAML format "
"<https://en.wikipedia.org/wiki/YAML#Syntax>`__. This file contains the "
"information in a series of key-value pairs:"
msgstr ""

#: ../docs/source/howto/run_codes.rst:119
msgid ""
"The list of the keys for the ``yaml`` file is given by the options of the "
"``computer setup`` command:"
msgstr ""

#: ../docs/source/howto/run_codes.rst:130
msgid "Computer connection configuration"
msgstr ""

#: ../docs/source/howto/run_codes.rst:132
msgid "The second step configures private connection details using:"
msgstr ""

#: ../docs/source/howto/run_codes.rst:138
msgid ""
"Replace ``COMPUTERLABEL`` with the computer label chosen during the setup "
"and replace ``TRANSPORTTYPE`` with the name of chosen transport type, i.e., "
"``local`` for the localhost computer and ``ssh`` for any remote computer."
msgstr ""

#: ../docs/source/howto/run_codes.rst:140
msgid ""
"After the setup and configuration have been completed, let's check that "
"everything is working properly:"
msgstr ""

#: ../docs/source/howto/run_codes.rst:146
msgid ""
"This command will perform various tests to make sure that AiiDA can connect "
"to the computer, create new files in the scratch directory, retrieve files "
"and query the job scheduler."
msgstr ""

#: ../docs/source/howto/run_codes.rst:151
msgid "Mitigating connection overloads"
msgstr ""

#: ../docs/source/howto/run_codes.rst:153
msgid ""
"Some compute resources, particularly large supercomputing centers, may not "
"tolerate submitting too many jobs at once, executing scheduler commands too "
"frequently, or opening too many SSH connections."
msgstr ""

#: ../docs/source/howto/run_codes.rst:155
msgid "Limit the number of jobs in the queue."
msgstr ""

#: ../docs/source/howto/run_codes.rst:157
msgid ""
"Set a limit for the maximum number of workflows to submit, and only submit "
"new ones once previous workflows start to complete. The supported number of "
"jobs depends on the supercomputer configuration which may be documented as "
"part of the center's user documentation. The supercomputer administrators "
"may also find the information found on `this page "
"<https://github.com/aiidateam/aiida-core/wiki/Optimising-the-SLURM-"
"scheduler-configuration-(for-cluster-administrators)>`_ useful."
msgstr ""

#: ../docs/source/howto/run_codes.rst:161
msgid "Increase the time interval between polling the job queue."
msgstr ""

#: ../docs/source/howto/run_codes.rst:163
msgid ""
"The time interval (in seconds) can be set through the Python API by loading "
"the corresponding |Computer| node, e.g. in the ``verdi shell``:"
msgstr ""

#: ../docs/source/howto/run_codes.rst:169
msgid "Increase the connection cooldown time."
msgstr ""

#: ../docs/source/howto/run_codes.rst:171
msgid ""
"This is the minimum time (in seconds) to wait between opening a new "
"connection. Modify it for an existing computer using:"
msgstr ""

#: ../docs/source/howto/run_codes.rst:180
msgid ""
"The two intervals apply *per daemon worker*, i.e. doubling the number of "
"workers may end up putting twice the load on the remote computer."
msgstr ""

#: ../docs/source/howto/run_codes.rst:183
msgid "Managing your computers"
msgstr ""

#: ../docs/source/howto/run_codes.rst:185
msgid "Fully configured computers can be listed with:"
msgstr ""

#: ../docs/source/howto/run_codes.rst:191
msgid ""
"To get detailed information on the specific computer named "
"``COMPUTERLABEL``:"
msgstr ""

#: ../docs/source/howto/run_codes.rst:197
msgid "To rename a computer or remove it from the database:"
msgstr ""

#: ../docs/source/howto/run_codes.rst:206
msgid ""
"Before deleting a |Computer|, you will need to delete *all* nodes linked to "
"it (e.g. any ``CalcJob`` and ``RemoteData`` nodes). Otherwise, AiiDA will "
"prevent you from doing so in order to preserve provenance."
msgstr ""

#: ../docs/source/howto/run_codes.rst:209
msgid ""
"If a remote machine is under maintenance (or no longer operational), you may"
" want to **disable** the corresponding |Computer|. Doing so will prevent "
"AiiDA from connecting to the given computer to check the state of "
"calculations or to submit new calculations."
msgstr ""

#: ../docs/source/howto/run_codes.rst:220
msgid "How to setup a code"
msgstr ""

#: ../docs/source/howto/run_codes.rst:222
msgid "Once your computer is configured, you can set up codes on it."
msgstr ""

#: ../docs/source/howto/run_codes.rst:224
msgid ""
"AiiDA stores a set of metadata for each code, which is attached "
"automatically to each calculation using it. Besides being important for "
"reproducibility, this also makes it easy to query for all calculations that "
"were run with a given code (for instance, if a specific version is found to "
"contain a bug)."
msgstr ""

#: ../docs/source/howto/run_codes.rst:230
msgid "Setting up a code"
msgstr ""

#: ../docs/source/howto/run_codes.rst:232
msgid ""
"The ``verdi code`` CLI is the access point for managing codes in AiiDA. To "
"setup a new code, execute:"
msgstr ""

#: ../docs/source/howto/run_codes.rst:239
msgid "and you will be guided through a process to setup your code."
msgstr ""

#: ../docs/source/howto/run_codes.rst:241
msgid "On remote and local codes"
msgstr ""

#: ../docs/source/howto/run_codes.rst:244
msgid ""
"In most cases, it is advisable to install the executables to be used by "
"AiiDA on the target machine *before* submitting calculations using them in "
"order to take advantage of the compilers and libraries present on the target"
" machine. This setup is referred to as *remote* codes (``Installed on target"
" computer?: True``)."
msgstr ""

#: ../docs/source/howto/run_codes.rst:247
msgid ""
"Occasionally, you may need to run small, reasonably machine-independent "
"scripts (e.g. Python or bash), and copying them manually to a number of "
"different target computers can be tedious. For this use case, AiiDA provides"
" *local* codes (``Installed on target computer?: False``). Local codes are "
"stored in the AiiDA file repository and copied to the target computer for "
"every execution."
msgstr ""

#: ../docs/source/howto/run_codes.rst:251
msgid ""
"Do *not* use local codes as a way of encapsulating the environment of "
"complex executables. Containers are a much better solution to this problem, "
"and we are working on adding native support for containers in AiiDA."
msgstr ""

#: ../docs/source/howto/run_codes.rst:255
msgid ""
"At the end of these steps, you will be prompted to edit a script, where you "
"can include ``bash`` commands that will be executed"
msgstr ""

#: ../docs/source/howto/run_codes.rst:257
msgid ""
"*before* running the submission script (after the 'Pre execution script' "
"lines), and"
msgstr ""

#: ../docs/source/howto/run_codes.rst:258
msgid ""
"*after* running the submission script (after the 'Post execution script' "
"separator)."
msgstr ""

#: ../docs/source/howto/run_codes.rst:260
msgid ""
"Use this, for instance, to load modules or set variables that are needed by "
"the code, such as:"
msgstr ""

#: ../docs/source/howto/run_codes.rst:266
msgid ""
"At the end, you receive a confirmation, with the *PK* and the *UUID* of your"
" new code."
msgstr ""

#: ../docs/source/howto/run_codes.rst:268
msgid "Using configuration files"
msgstr ""

#: ../docs/source/howto/run_codes.rst:271
msgid ""
"Analogous to a :ref:`computer setup <how-to:run-codes:computer>`, some (or "
"all) the information described above can be provided via a configuration "
"file:"
msgstr ""

#: ../docs/source/howto/run_codes.rst:277
msgid ""
"where ``code.yml`` is a configuration file in the `YAML format "
"<https://en.wikipedia.org/wiki/YAML#Syntax>`_."
msgstr ""

#: ../docs/source/howto/run_codes.rst:279
msgid "This file contains the information in a series of key:value pairs:"
msgstr ""

#: ../docs/source/howto/run_codes.rst:295
msgid ""
"The list of the keys for the ``yaml`` file is given by the available options"
" of the ``code setup`` command:"
msgstr ""

#: ../docs/source/howto/run_codes.rst:301
msgid ""
"Note: remove the ``--`` prefix and replace ``-`` within the keys with an "
"underscore ``_``."
msgstr ""

#: ../docs/source/howto/run_codes.rst:304
msgid "Managing codes"
msgstr ""

#: ../docs/source/howto/run_codes.rst:306
msgid "You can change the label of a code by using the following command:"
msgstr ""

#: ../docs/source/howto/run_codes.rst:312
msgid ""
"where <IDENTIFIER> can be the numeric *PK*, the *UUID* or the label of the "
"code (either ``label`` or ``label@computername``) if the label is unique."
msgstr ""

#: ../docs/source/howto/run_codes.rst:314
msgid "You can also list all available codes and their identifiers with:"
msgstr ""

#: ../docs/source/howto/run_codes.rst:320
msgid ""
"which also accepts flags to filter only codes on a given computer, or only "
"codes using a specific plugin, etc. (use the ``-h`` option)."
msgstr ""

#: ../docs/source/howto/run_codes.rst:322
msgid "You can get the information of a specific code with:"
msgstr ""

#: ../docs/source/howto/run_codes.rst:328
msgid "Finally, to delete a code use:"
msgstr ""

#: ../docs/source/howto/run_codes.rst:334
msgid ""
"(only if it wasn't used by any calculation, otherwise an exception is "
"raised)."
msgstr ""

#: ../docs/source/howto/run_codes.rst:338
msgid ""
"Codes are a subclass of :py:class:`Node <aiida.orm.nodes.Node>` and, as "
"such, you can attach ``extras`` to a code, for example:"
msgstr ""

#: ../docs/source/howto/run_codes.rst:345
msgid ""
"These can be useful for querying, for instance in order to find all runs "
"done with the CP2K code of version 6.1 or later."
msgstr ""

#: ../docs/source/howto/run_codes.rst:350
msgid "How to submit a calculation"
msgstr ""

#: ../docs/source/howto/run_codes.rst:352
msgid ""
"After :ref:`setting up your computer <how-to:run-codes:computer>` and "
":ref:`setting up your code <how-to:run-codes:code:setup>`, you are ready to "
"launch your calculations!"
msgstr ""

#: ../docs/source/howto/run_codes.rst:354
msgid "Make sure the daemon is running:"
msgstr ""

#: ../docs/source/howto/run_codes.rst:360
msgid "Figure out which inputs your |CalcJob|  plugin needs, e.g. using:"
msgstr ""

#: ../docs/source/howto/run_codes.rst:366
msgid "Write a ``submit.py`` script:"
msgstr ""

#: ../docs/source/howto/run_codes.rst:386
msgid ""
"Of course, the code label and builder inputs need to be adapted to your code"
" and calculation."
msgstr ""

#: ../docs/source/howto/run_codes.rst:388
msgid "Submit your calculation to the AiiDA daemon:"
msgstr ""

#: ../docs/source/howto/run_codes.rst:394
msgid ""
"After this, use ``verdi process list`` to monitor the status of the "
"calculations."
msgstr ""

#: ../docs/source/howto/run_codes.rst:396
msgid ""
"See :ref:`topics:processes:usage:launching` and "
":ref:`topics:processes:usage:monitoring` for more details."
msgstr ""

#: ../docs/source/howto/run_codes.rst:403
msgid "How to save compute time with caching"
msgstr ""

#: ../docs/source/howto/run_codes.rst:405
msgid ""
"Over the course of a project, you may end up re-running the same "
"calculations multiple times - be it because two workflows include the same "
"calculation or because one needs to restart a workflow that failed due to "
"some infrastructure problem."
msgstr ""

#: ../docs/source/howto/run_codes.rst:407
msgid ""
"Since AiiDA stores the full provenance of each calculation, it can detect "
"whether a calculation has been run before and, instead of running it again, "
"simply reuse its outputs, thereby saving valuable computational resources. "
"This is what we mean by **caching** in AiiDA."
msgstr ""

#: ../docs/source/howto/run_codes.rst:410
msgid ""
"With caching enabled, AiiDA searches the database for a calculation of the "
"same :ref:`hash<topics:provenance:caching:hashing>`. If found, AiiDA creates"
" a copy of the calculation node and its results, thus ensuring that the "
"resulting provenance graph is independent of whether caching is enabled or "
"not (see :numref:`fig_caching`)."
msgstr ""

#: ../docs/source/howto/run_codes.rst:418
msgid ""
"When reusing the results of a calculation **C** for a new calculation "
"**C'**, AiiDA simply makes a copy of the result nodes and links them up as "
"usual. This diagram depicts the same input node **D1** being used for both "
"calculations, but an input node **D1'** with the same *hash* as **D1** would"
" trigger the cache as well."
msgstr ""

#: ../docs/source/howto/run_codes.rst:421
msgid ""
"Caching happens on the *calculation* level (no caching at the workflow "
"level, see :ref:`topics:provenance:caching:limitations`). By default, both "
"successful and failed calculations enter the cache (more details in "
":ref:`topics:provenance:caching:control-caching`)."
msgstr ""

#: ../docs/source/howto/run_codes.rst:427
msgid "How to enable caching"
msgstr ""

#: ../docs/source/howto/run_codes.rst:429
msgid ""
"Caching is **not** enabled by default, see :ref:`the faq <how-to:faq"
":caching-not-enabled>`."
msgstr ""

#: ../docs/source/howto/run_codes.rst:431
msgid ""
"Caching is controlled on a per-profile level via the :ref:`verdi config cli "
"<how-to:installation:configure:options>`."
msgstr ""

#: ../docs/source/howto/run_codes.rst:433
msgid "View your current caching configuration:"
msgstr ""

#: ../docs/source/howto/run_codes.rst:444
msgid ""
"Enable caching for your current profile or globally (for all profiles):"
msgstr ""

#: ../docs/source/howto/run_codes.rst:463
msgid ""
"Configuring caching via the ``cache_config.yml`` is deprecated as of AiiDA "
"1.6.0. Existing ``cache_config.yml`` files will be migrated to the central "
"``config.json`` file automatically."
msgstr ""

#: ../docs/source/howto/run_codes.rst:467
msgid ""
"From this point onwards, when you launch a new calculation, AiiDA will "
"compare its hash (a fixed size string, unique for a calulation's type and "
"inputs, see :ref:`topics:provenance:caching:hashing`) against other "
"calculations already present in your database. If another calculation with "
"the same hash is found, AiiDA will reuse its results without repeating the "
"actual calculation."
msgstr ""

#: ../docs/source/howto/run_codes.rst:472
msgid ""
"In contrast to caching, hashing **is** enabled by default, i.e. hashes for "
"all your calculations will already have been computed."
msgstr ""

#: ../docs/source/howto/run_codes.rst:477
msgid "How to configure caching"
msgstr ""

#: ../docs/source/howto/run_codes.rst:479
msgid ""
"The caching mechanism can be configured on a process class level, meaning "
"the rules will automatically be applied to all instances of the given class,"
" or on a per-instance level, meaning it can be controlled for individual "
"process instances when they are launch."
msgstr ""

#: ../docs/source/howto/run_codes.rst:482
msgid "Class level"
msgstr ""

#: ../docs/source/howto/run_codes.rst:484
msgid ""
"Besides the on/off switch set by ``caching.default_enabled``, caching can be"
" controlled at the level of specific calculations using their corresponding "
"entry point strings (see the output of ``verdi plugin list "
"aiida.calculations``):"
msgstr ""

#: ../docs/source/howto/run_codes.rst:502
msgid ""
"In this example, caching is enabled by default, but explicitly disabled for "
"calculations of the ``TemplatereplacerCalculation`` class, identified by its"
" corresponding ``aiida.calculations:templatereplacer`` entry point string. "
"It also shows how to enable caching for particular calculations (which has "
"no effect here due to the profile-wide default)."
msgstr ""

#: ../docs/source/howto/run_codes.rst:505
msgid "To set multiple entry-points at once, use a ``,`` delimiter."
msgstr ""

#: ../docs/source/howto/run_codes.rst:507
msgid ""
"For the available entry-points in your environment, you can list which are "
"enabled/disabled using:"
msgstr ""

#: ../docs/source/howto/run_codes.rst:519
msgid ""
"For calculations which do not have an entry point, you need to specify the "
"fully qualified Python name instead. For example, the "
"``seekpath_structure_analysis`` calcfunction defined in "
"``aiida_quantumespresso.workflows.functions.seekpath_structure_analysis`` is"
" labelled as "
"``aiida_quantumespresso.workflows.functions.seekpath_structure_analysis.seekpath_structure_analysis``."
" From an existing "
":class:`~aiida.orm.nodes.process.calculation.CalculationNode`, you can get "
"the identifier string through the ``process_type`` attribute."
msgstr ""

#: ../docs/source/howto/run_codes.rst:523
msgid ""
"The caching configuration also accepts ``*`` wildcards. For example, the "
"following configuration disables caching for all calculation entry points."
msgstr ""

#: ../docs/source/howto/run_codes.rst:538
msgid ""
"Any entry with a wildcard is overridden by a more specific entry. The "
"following configuration disables caching for all ``aiida.calculation`` entry"
" points, except those of ``arithmetic``:"
msgstr ""

#: ../docs/source/howto/run_codes.rst:560
msgid "Instance level"
msgstr ""

#: ../docs/source/howto/run_codes.rst:562
msgid ""
"Caching can be enabled or disabled on a case-by-case basis by using the "
":class:`~aiida.manage.caching.enable_caching` or "
":class:`~aiida.manage.caching.disable_caching` context manager, "
"respectively, regardless of the profile settings:"
msgstr ""

#: ../docs/source/howto/run_codes.rst:573
msgid ""
"This affects only the current Python interpreter and won't change the "
"behavior of the daemon workers. This means that this technique is only "
"useful when using :py:class:`~aiida.engine.run`, and **not** with "
":py:class:`~aiida.engine.submit`."
msgstr ""

#: ../docs/source/howto/run_codes.rst:576
msgid ""
"If you suspect a node is being reused in error (e.g. during development), "
"you can also manually *prevent* a specific node from being reused:"
msgstr ""

#: ../docs/source/howto/run_codes.rst:578
msgid ""
"Load one of the nodes you suspect to be a clone. Check that "
":meth:`~aiida.orm.nodes.Node.get_cache_source` returns a UUID. If it returns"
" `None`, the node was not cloned."
msgstr ""

#: ../docs/source/howto/run_codes.rst:582
msgid ""
"Clear the hashes of all nodes that are considered identical to this node:"
msgstr ""

#: ../docs/source/howto/run_codes.rst:589
msgid ""
"Run your calculation again. The node in question should no longer be reused."
msgstr ""

#: ../docs/source/howto/run_workflows.rst:5
msgid "How to run multi-step workflows"
msgstr ""

#: ../docs/source/howto/run_workflows.rst:8
msgid "Launching a predefined workflow"
msgstr ""

#: ../docs/source/howto/run_workflows.rst:10
msgid ""
"The first step to launching a predefined workflow is loading the work "
"function or work chain class that defines the workflow you want to run. The "
"recommended method for loading a workflow is using the ``WorkflowFactory``, "
"for example:"
msgstr ""

#: ../docs/source/howto/run_workflows.rst:19
msgid ""
"This is essentially the same as importing the workflow from its respective "
"module, but using the ``WorkflowFactory`` has the advantage that the so "
"called *entry point* (e.g. ``'arithmetic.multiply_add'``) will not change "
"when the packages or plugins are reorganised. This means your code is less "
"likely to break when updating AiiDA or the plugin that supplies the "
"workflow."
msgstr ""

#: ../docs/source/howto/run_workflows.rst:22
msgid ""
"The list of installed plugins can be easily accessed via the verdi CLI:"
msgstr ""

#: ../docs/source/howto/run_workflows.rst:28
msgid "To see the list of workflow entry points, simply use:"
msgstr ""

#: ../docs/source/howto/run_workflows.rst:34
msgid ""
"By further specifying the entry point of the workflow, you can see its "
"description, inputs, outputs and exit codes:"
msgstr ""

#: ../docs/source/howto/run_workflows.rst:41
msgid "Work functions"
msgstr ""

#: ../docs/source/howto/run_workflows.rst:43
msgid ""
"Running a work function is as simple as calling a typical Python function: "
"simply call it with the required input arguments:"
msgstr ""

#: ../docs/source/howto/run_workflows.rst:53
msgid ""
"Here, the ``add_and_multiply`` work function returns the output ``Int`` node"
" and we assign it to the variable ``result``. Note that the input arguments "
"of a work function must be an instance of ``Data`` node, or any of its "
"subclasses. Just calling the ``add_and_multiply`` function with regular "
"integers will result in a ``ValueError``, as these cannot be stored in the "
"provenance graph."
msgstr ""

#: ../docs/source/howto/run_workflows.rst:59
msgid ""
"Although the example above shows the most straightforward way to run the "
"``add_and_multiply`` work function, there are several other ways of running "
"processes that can return more than just the result. For example, the "
"``run_get_node`` function from the AiiDA engine returns both the result of "
"the workflow and the work function node. See the :ref:`corresponding topics "
"section for more details <topics:processes:usage:launching>`."
msgstr ""

#: ../docs/source/howto/run_workflows.rst:64
msgid "Work chains"
msgstr ""

#: ../docs/source/howto/run_workflows.rst:66
msgid ""
"To launch a work chain, you can either use the ``run`` or ``submit`` "
"functions. For either function, you need to provide the class of the work "
"chain as the first argument, followed by the inputs as keyword arguments. "
"When \"running the work chain\" (using the ``run`` function), it will be "
"executed in the same system process as the interpreter in which it is "
"launched:"
msgstr ""

#: ../docs/source/howto/run_workflows.rst:81
msgid ""
"Alternatively, you can first construct a dictionary of the inputs, and pass "
"it to the ``run`` function by taking advantage of `Python's automatic "
"keyword expansion <https://docs.python.org/3/tutorial/controlflow.html"
"#unpacking-argument-lists>`_:"
msgstr ""

#: ../docs/source/howto/run_workflows.rst:88
msgid ""
"This is particularly useful in case you have a workflow with a lot of "
"inputs. In both cases, running the ``MultiplyAddWorkChain`` workflow returns"
" the **results** of the workflow, i.e. a dictionary of the nodes that are "
"produced as outputs, where the keys of the dictionary correspond to the "
"labels of each respective output."
msgstr ""

#: ../docs/source/howto/run_workflows.rst:93
msgid ""
"Similar to other processes, there are multiple functions for launching a "
"work chain. See the section on :ref:`launching processes for more "
"details<topics:processes:usage:launching>`."
msgstr ""

#: ../docs/source/howto/run_workflows.rst:96
msgid ""
"Since *running* a workflow will block the interpreter, you will have to wait"
" until the workflow is finished before you get back control. Moreover, you "
"won't be able to turn your computer or even your terminal off until the "
"workflow has fully terminated, and it is difficult to run multiple workflows"
" in parallel. So, it is advisable to *submit* more complex or longer work "
"chains to the daemon:"
msgstr ""

#: ../docs/source/howto/run_workflows.rst:112
msgid ""
"Note that when using ``submit`` the work chain is not run in the local "
"interpreter but is sent off to the daemon and you get back control "
"instantly. This allows you to submit multiple work chains at the same time "
"and the daemon will start working on them in parallel. Once the ``submit`` "
"call returns, you will not get the result as with ``run``, but you will get "
"the **node** that represents the work chain. Submitting a work chain instead"
" of directly running it not only makes it easier to execute multiple work "
"chains in parallel, but also ensures that the progress of a workchain is not"
" lost when you restart your computer."
msgstr ""

#: ../docs/source/howto/run_workflows.rst:119
msgid ""
"As of AiiDA v1.5.0, it is possible to submit both work *chains* and work "
"*functions* to the daemon. Older versions only allow the submission of work "
"*chains*, whereas work *functions* cannot be submitted to the daemon, and "
"hence can only be *run*."
msgstr ""

#: ../docs/source/howto/run_workflows.rst:121
msgid ""
"If you are unfamiliar with the inputs of a particular ``WorkChain``, a "
"convenient tool for setting up the work chain is the :ref:`process "
"builder<topics:processes:usage:builder>`. This can be obtained by using the "
"``get_builder()`` method, which is implemented for every ``CalcJob`` and "
"``WorkChain``:"
msgstr ""

#: ../docs/source/howto/run_workflows.rst:131
msgid ""
"To explore the inputs of the work chain, you can use tab autocompletion by "
"typing ``builder.`` and then hitting ``TAB``. If you want to get more "
"details on a specific input, you can simply add a ``?`` and press enter:"
msgstr ""

#: ../docs/source/howto/run_workflows.rst:141
msgid ""
"Here you can see that the ``x`` input is required, needs to be of the "
"``Int`` type and is stored in the database (``\"non_db\": \"False\"``)."
msgstr ""

#: ../docs/source/howto/run_workflows.rst:143
msgid ""
"Using the builder, the inputs of the ``WorkChain`` can be provided one by "
"one:"
msgstr ""

#: ../docs/source/howto/run_workflows.rst:152
msgid ""
"Once the *required* inputs of the workflow have been provided to the "
"builder, you can either run the work chain or submit it to the daemon:"
msgstr ""

#: ../docs/source/howto/run_workflows.rst:161
msgid ""
"For more detail on the process builder, see the :ref:`corresponding topics "
"section<topics:processes:usage:builder>`."
msgstr ""

#: ../docs/source/howto/run_workflows.rst:163
msgid ""
"Now that you know how to run a pre-defined workflow, you may want to start "
":ref:`writing your own<how-to:write-workflows>`."
msgstr ""

#: ../docs/source/howto/share_data.rst:5
msgid "How to share data"
msgstr ""

#: ../docs/source/howto/share_data.rst:7
msgid ""
"AiiDA offers two avenues for sharing data with others: archive files and the"
" REST API."
msgstr ""

#: ../docs/source/howto/share_data.rst:13
msgid "Sharing AiiDA archives"
msgstr ""

#: ../docs/source/howto/share_data.rst:15
msgid ""
"You have performed your calculations with AiiDA and you would like to share "
"your AiiDA provenance graph, for example to make your scientific study "
"reproducible."
msgstr ""

#: ../docs/source/howto/share_data.rst:17
msgid ""
"Since AiiDA keeps track of the provenance of every computed result, this "
"step is easy: Tell AiiDA the **final results** you would like to be "
"reproducible, and AiiDA will automatically include their entire provenance "
"using the :ref:`topics:provenance:consistency:traversal-rules`."
msgstr ""

#: ../docs/source/howto/share_data.rst:21
msgid "Exporting individual nodes"
msgstr ""

#: ../docs/source/howto/share_data.rst:22
msgid ""
"Let's say the key results of your study are contained in three AiiDA nodes "
"with PKs ``12``, ``123``, ``1234``. Exporting those results together with "
"their provenance is as easy as:"
msgstr ""

#: ../docs/source/howto/share_data.rst:29
msgid ""
"As usual, you can use any identifier (label, PK or UUID) to specify the "
"nodes to be exported."
msgstr ""

#: ../docs/source/howto/share_data.rst:31
msgid ""
"The resulting archive file ``my-calculations.aiida`` contains all "
"information pertaining to the exported nodes. The default traversal rules "
"make sure to include the complete provenance of any node specified and "
"should be sufficient for most cases. See ``verdi archive create --help`` for"
" ways to modify the traversal rules."
msgstr ""

#: ../docs/source/howto/share_data.rst:37
msgid ""
"If you want to make sure the archive includes everything you intended, you "
"can create a new profile and import it:"
msgstr ""

#: ../docs/source/howto/share_data.rst:44
msgid ""
"Now use, e.g. the :py:class:`~aiida.orm.querybuilder.QueryBuilder` to query "
"the database."
msgstr ""

#: ../docs/source/howto/share_data.rst:46
msgid ""
"Please remember to use **UUIDs** when pointing your colleagues to data "
"*inside* an AiiDA archive, since UUIDs are guaranteed to be universally "
"unique (while PKs aren't)."
msgstr ""

#: ../docs/source/howto/share_data.rst:49
msgid "Using groups for data exporting"
msgstr ""

#: ../docs/source/howto/share_data.rst:51
msgid ""
"If the number of results to be exported is large, for example in a high-"
"throughput study, use the ``QueryBuilder`` to add the corresponding nodes to"
" a group ``my-results`` (see :ref:`how-to:data:organize:group`). Then export"
" the group:"
msgstr ""

#: ../docs/source/howto/share_data.rst:59
msgid "Publishing AiiDA archive files"
msgstr ""

#: ../docs/source/howto/share_data.rst:61
msgid ""
"AiiDA archive files can be published on any research data repository, for "
"example the `Materials Cloud Archive`_, `Zenodo`_, or the `Open Science "
"Framework`_. When publishing AiiDA archives on the `Materials Cloud "
"Archive`_, you also get an interactive *EXPLORE* section, which allows peers"
" to browse the AiiDA provenance graph directly in the browser."
msgstr ""

#: ../docs/source/howto/share_data.rst:70
msgid "Importing an archive"
msgstr ""

#: ../docs/source/howto/share_data.rst:72
msgid ""
"Use ``verdi archive import`` to import AiiDA archives into your current "
"AiiDA profile. ``verdi archive import`` accepts URLs, e.g.:"
msgstr ""

#: ../docs/source/howto/share_data.rst:79
msgid ""
"During import, AiiDA will avoid identifier collisions and node duplication "
"based on UUIDs (and email comparisons for :py:class:`~aiida.orm.users.User` "
"entries). By default, existing entities will be updated with the most recent"
" changes. Node extras and comments have special modes for determining how to"
" import them - for more details, see ``verdi archive import --help``."
msgstr ""

#: ../docs/source/howto/share_data.rst:83
msgid ""
"The AiiDA archive format has evolved over time, but you can still import "
"archives created with previous AiiDA versions. If an outdated archive "
"version is detected during import, the archive file will be automatically "
"migrated to the newest version (within a temporary folder) and the import "
"retried."
msgstr ""

#: ../docs/source/howto/share_data.rst:86
msgid ""
"You can also use ``verdi archive migrate`` to create updated archive files "
"from existing archive files (or update them in place)."
msgstr ""

#: ../docs/source/howto/share_data.rst:88
msgid ""
"In order to get a quick overview of an archive file *without* importing it "
"into your AiiDA profile, use ``verdi archive inspect``:"
msgstr ""

#: ../docs/source/howto/share_data.rst:103
msgid ""
"Note: For archive versions 0.2 and below, the overview may be inaccurate."
msgstr ""

#: ../docs/source/howto/share_data.rst:109
msgid "Serving data through the REST API"
msgstr ""

#: ../docs/source/howto/share_data.rst:111
msgid ""
"The AiiDA REST API allows to query your AiiDA database over HTTP(S) and "
"returns results in :ref:`JSON format <reference:rest-api:endpoints-"
"responses>`."
msgstr ""

#: ../docs/source/howto/share_data.rst:115
msgid ""
"As of October 2020, the AiiDA REST API only supports ``GET`` methods "
"(reading); in particular, it does *not* yet support workflow management. "
"This feature is, however, part of the `AiiDA roadmap "
"<https://github.com/aiidateam/aiida-core/wiki/AiiDA-release-roadmap>`_."
msgstr ""

#: ../docs/source/howto/share_data.rst:121
msgid "Launching the REST API"
msgstr ""

#: ../docs/source/howto/share_data.rst:123
msgid "Start serving data from your default AiiDA profile via the REST API:"
msgstr ""

#: ../docs/source/howto/share_data.rst:136
msgid "The REST API is now running on port ``5000`` of your local computer."
msgstr ""

#: ../docs/source/howto/share_data.rst:138
msgid ""
"Like all ``verdi`` commands, you can select a different AiiDA profile via "
"the ``-p PROFILE`` option:"
msgstr ""

#: ../docs/source/howto/share_data.rst:146
msgid "REST API version history:"
msgstr ""

#: ../docs/source/howto/share_data.rst:150
msgid "Version history"
msgstr ""

#: ../docs/source/howto/share_data.rst:152
msgid ""
"``aiida-core`` >= 1.0.0b6: ``v4``. Simplified endpoints; only ``/nodes``, "
"``/processes``, ``/calcjobs``, ``/groups``, ``/computers`` and ``/servers`` "
"remain."
msgstr ""

#: ../docs/source/howto/share_data.rst:153
msgid ""
"``aiida-core`` >= 1.0.0b3, <1.0.0b6: ``v3``. Development version, never "
"shipped with a stable release."
msgstr ""

#: ../docs/source/howto/share_data.rst:154
msgid ""
"``aiida-core`` <1.0.0b3: ``v2``. First API version, with new endpoints added"
" step by step."
msgstr ""

#: ../docs/source/howto/share_data.rst:160
msgid "Querying the REST API"
msgstr ""

#: ../docs/source/howto/share_data.rst:162
msgid "A URL to query the REST API consists of:"
msgstr ""

#: ../docs/source/howto/share_data.rst:164
msgid "The *base URL*, by default:"
msgstr ""

#: ../docs/source/howto/share_data.rst:166
msgid "http://127.0.0.1:5000/api/v4"
msgstr ""

#: ../docs/source/howto/share_data.rst:168
msgid "Querying the base URL returns a list of all available endpoints."
msgstr ""

#: ../docs/source/howto/share_data.rst:170
msgid ""
"The *path* defining the requested *resource*, optionally followed by a more "
"specific *endpoint*. For example::"
msgstr ""

#: ../docs/source/howto/share_data.rst:179
msgid ""
"If no endpoint is appended, the API returns a list of objects of that "
"resource. In order to request a specific object of a resource, append its "
"*UUID*."
msgstr ""

#: ../docs/source/howto/share_data.rst:184
msgid "As usual, you can use partial UUIDs as long as they are unique."
msgstr ""

#: ../docs/source/howto/share_data.rst:186
msgid ""
"In order to query by *PK* you need to use the ``id`` filter (see below). "
"This also applies to :py:class:`~aiida.orm.users.User` s, which don't have "
"UUIDs (but instead uses email)."
msgstr ""

#: ../docs/source/howto/share_data.rst:189
msgid ""
"(Optional) The *query string* for filtering, ordering and pagination of "
"results. For example::"
msgstr ""

#: ../docs/source/howto/share_data.rst:196
msgid "Here are some examples to try::"
msgstr ""

#: ../docs/source/howto/share_data.rst:204
msgid ""
"The interactive `EXPLORE sections on Materials Cloud "
"<https://www.materialscloud.org/explore/menu>`_ are all powered by the AiiDA"
" REST API and you can query the underlying API, either using your web "
"browser or using a tool like ``curl``:"
msgstr ""

#: ../docs/source/howto/share_data.rst:210
msgid ""
"For an extensive user documentation of the endpoints, the query string as "
"well as the format of the responses, see the :ref:`AiiDA REST API reference "
"<reference:rest-api>`."
msgstr ""

#: ../docs/source/howto/share_data.rst:215
msgid "Deploying a REST API server"
msgstr ""

#: ../docs/source/howto/share_data.rst:217
msgid ""
"The ``verdi restapi`` command runs the REST API through the ``werkzeug`` "
"python-based HTTP server. In order to deploy production instances of the "
"REST API for serving your data to others, we recommend using a fully fledged"
" web server, such as `Apache <https://httpd.apache.org/>`_ or `NGINX "
"<https://www.nginx.com/>`_, which then runs the REST API python application "
"through the `web server gateway interface (WSGI) <wsgi.readthedocs.io/>`_."
msgstr ""

#: ../docs/source/howto/share_data.rst:221
msgid ""
"One Apache/NGINX server can host multiple instances of the REST APIs, e.g. "
"serving data from different AiiDA profiles."
msgstr ""

#: ../docs/source/howto/share_data.rst:223
msgid ""
"A ``myprofile-rest.wsgi`` script for an AiiDA profile ``myprofile`` would "
"look like this:"
msgstr ""

#: ../docs/source/howto/share_data.rst:227
msgid ""
"See the documentation of :py:func:`~aiida.restapi.run_api.configure_api` for"
" all available configuration options."
msgstr ""

#: ../docs/source/howto/share_data.rst:229
msgid ""
"In the following, we explain how to run this wsgi application using Apache "
"on Ubuntu."
msgstr ""

#: ../docs/source/howto/share_data.rst:231
msgid ""
"Install and enable the ``mod_wsgi`` `WSGI module <modwsgi.readthedocs.io/>`_"
" module:"
msgstr ""

#: ../docs/source/howto/share_data.rst:238
msgid ""
"Place the WSGI script in a folder on your server, for example "
"``/home/ubuntu/wsgi/myprofile-rest.wsgi``."
msgstr ""

#: ../docs/source/howto/share_data.rst:240
msgid ""
"Configure apache to run the WSGI application using a virtual host "
"configuration similar to:"
msgstr ""

#: ../docs/source/howto/share_data.rst:244
msgid "Place this ``aiida-rest.conf`` file in ``/etc/apache2/sites-enabled``"
msgstr ""

#: ../docs/source/howto/share_data.rst:246
msgid "Restart apache: ``sudo service apache2 restart``."
msgstr ""

#: ../docs/source/howto/share_data.rst:248
msgid ""
"You should now be able to reach your REST API at "
"``localhost/myprofile/api/v4`` (Port 80)."
msgstr ""

#: ../docs/source/howto/ssh.rst:5
msgid "How to setup SSH connections"
msgstr ""

#: ../docs/source/howto/ssh.rst:7
msgid ""
"AiiDA communicates with remote computers via the SSH protocol. There are two"
" ways of setting up an SSH connection for AiiDA:"
msgstr ""

#: ../docs/source/howto/ssh.rst:10
msgid "Using a passwordless SSH key (easier, less safe)"
msgstr ""

#: ../docs/source/howto/ssh.rst:11
msgid ""
"Using a password-protected SSH key through ``ssh-agent`` (one more step, "
"safer)"
msgstr ""

#: ../docs/source/howto/ssh.rst:16
msgid "Using a passwordless SSH key"
msgstr ""

#: ../docs/source/howto/ssh.rst:19
msgid ""
"There are numerous tutorials on the web, see e.g. `here "
"<https://www.redhat.com/sysadmin/passwordless-ssh>`_. Very briefly, first "
"create a new private/public keypair (``aiida``/``aiida.pub``), leaving "
"passphrase emtpy:"
msgstr ""

#: ../docs/source/howto/ssh.rst:26
msgid ""
"Copy the public key to the remote machine, normally this will add the public"
" key to the rmote machine's ``~/.ssh/authorized_keys``:"
msgstr ""

#: ../docs/source/howto/ssh.rst:32
msgid ""
"Add the following lines to your ``~/.ssh/config`` file (or create it, if it "
"does not exist):"
msgstr ""

#: ../docs/source/howto/ssh.rst:42
msgid ""
"If your cluster needs you to connect to another computer *PROXY* first, you "
"can use the ``proxy_command`` feature of ssh, see :ref:`how-to:ssh:proxy`."
msgstr ""

#: ../docs/source/howto/ssh.rst:44
msgid ""
"You should now be able to access the remote computer (without the need to "
"type a password) *via*:"
msgstr ""

#: ../docs/source/howto/ssh.rst:52
msgid "Connection closed failures"
msgstr ""

#: ../docs/source/howto/ssh.rst:56
msgid ""
"If the ``ssh`` command works, but the ``sftp`` command prints ``Connection "
"closed``, there may be a line in the ``~/.bashrc`` file **on the cluster** "
"that either produces text output or an error. Remove/comment lines from this"
" file until no output or error is produced: this should make ``sftp`` work "
"again."
msgstr ""

#: ../docs/source/howto/ssh.rst:59
msgid ""
"Finally, if you are planning to use a batch scheduler on the remote "
"computer, try also:"
msgstr ""

#: ../docs/source/howto/ssh.rst:65
msgid ""
"replacing ``QUEUE_VISUALIZATION_COMMAND`` by ``squeue`` (SLURM), ``qstat`` "
"(PBSpro) or the equivalent command of your scheduler and check that it "
"prints a list of the job queue without errors."
msgstr ""

#: ../docs/source/howto/ssh.rst:67
msgid "Scheduler errors?"
msgstr ""

#: ../docs/source/howto/ssh.rst:70
msgid ""
"If the previous command errors with ``command not found``, while the same "
"``QUEUE_VISUALIZATION_COMMAND`` works fine after you've logged in via SSH, "
"it may be that a guard in the ``.bashrc`` file on the cluster prevents "
"necessary modules from being loaded."
msgstr ""

#: ../docs/source/howto/ssh.rst:72
msgid "Look for lines like:"
msgstr ""

#: ../docs/source/howto/ssh.rst:78
msgid "or:"
msgstr ""

#: ../docs/source/howto/ssh.rst:87
msgid "which will prevent any instructions that follow from being executed."
msgstr ""

#: ../docs/source/howto/ssh.rst:89
msgid ""
"You can either move relevant instructions before these lines or delete the "
"guards entirely. If you are wondering whether the ``PATH`` environment "
"variable is set correctly, you can check its value using:"
msgstr ""

#: ../docs/source/howto/ssh.rst:99
msgid "Using passphrase-protected keys *via* an ssh-agent"
msgstr ""

#: ../docs/source/howto/ssh.rst:102
msgid ""
"Tools like ``ssh-agent`` (available on most Linux distros and MacOS) allow "
"you to enter the passphrase of a protected key *once* and provide access to "
"the decrypted key for as long as the agent is running. This allows you to "
"use a passphrase-protected key (required by some HPC centres), while making "
"the decrypted key available to AiiDA for automatic SSH operations."
msgstr ""

#: ../docs/source/howto/ssh.rst:106
msgid "Creating the key"
msgstr ""

#: ../docs/source/howto/ssh.rst:108
msgid ""
"Start by following the instructions above for :ref:`how-"
"to:ssh:passwordless`, the only difference being that you enter a passphrase "
"when creating the key (and when logging in to the remote computer)."
msgstr ""

#: ../docs/source/howto/ssh.rst:111
msgid "Adding the key to the agent"
msgstr ""

#: ../docs/source/howto/ssh.rst:113
msgid "Now provide the passphrase for your private key to the agent:"
msgstr ""

#: ../docs/source/howto/ssh.rst:119
msgid ""
"The private key and the relative passphrase are now recorded in an instance "
"of the agent."
msgstr ""

#: ../docs/source/howto/ssh.rst:123
msgid ""
"The passphase is stored in the agent only until the next reboot. If you shut"
" down or restart the AiiDA machine, before starting the AiiDA deamon "
"remember to run the ``ssh-add`` command again."
msgstr ""

#: ../docs/source/howto/ssh.rst:127
msgid "Starting the ssh-agent"
msgstr ""

#: ../docs/source/howto/ssh.rst:129
msgid ""
"On most modern Linux installations, the ``ssh-agent`` starts automatically "
"at login (e.g. Ubuntu 16.04 and later or MacOS 10.5 and later). If you "
"received an error ``Could not open a connection to your authentication "
"agent``, you will need to start the agent manually instead."
msgstr ""

#: ../docs/source/howto/ssh.rst:132
msgid ""
"Check whether you can start an ``ssh-agent`` **in your current shell**:"
msgstr ""

#: ../docs/source/howto/ssh.rst:138
msgid ""
"In order to reuse the same agent instance everywhere (including the AiiDA "
"daemon), the environment variables of ``ssh-agent`` need to be reused by "
"*all* shells. Download the script :download:`load-singlesshagent.sh <include"
"/load-singlesshagent.sh>` and place it e.g. in ``~/bin``. Then add the "
"following lines to your ``~/.bashrc`` file:"
msgstr ""

#: ../docs/source/howto/ssh.rst:148
msgid "To check that it works:"
msgstr ""

#: ../docs/source/howto/ssh.rst:150
msgid "Open a new shell (``~/.bashrc`` file is sourced)."
msgstr ""

#: ../docs/source/howto/ssh.rst:151
msgid "Run ``ssh-add``."
msgstr ""

#: ../docs/source/howto/ssh.rst:152
msgid "Close the shell."
msgstr ""

#: ../docs/source/howto/ssh.rst:153
msgid "Open a new shell and try logging in to the remote computer."
msgstr ""

#: ../docs/source/howto/ssh.rst:155
msgid ""
"Try logging in to the remote computer; it should no longer require a "
"passphrase."
msgstr ""

#: ../docs/source/howto/ssh.rst:157
msgid ""
"The key and its corresponding passphrase are now stored by the agent until "
"it is stopped. After a reboot, remember to run ``ssh-add ~/.ssh/aiida`` "
"again before starting the AiiDA daemon."
msgstr ""

#: ../docs/source/howto/ssh.rst:161
msgid "Integrating the ssh-agent with keychain on OSX"
msgstr ""

#: ../docs/source/howto/ssh.rst:163
msgid ""
"On OSX Sierra and later, the native ``ssh-add`` client allows passphrases to"
" be stored persistently in the `OSX keychain <https://support.apple.com/en-"
"gb/guide/keychain-access/kyca1083/mac>`__. Store the passphrase in the "
"keychain using the OSX-specific ``-k`` argument:"
msgstr ""

#: ../docs/source/howto/ssh.rst:170
msgid ""
"To instruct ssh to look in the OSX keychain for key passphrases, add the "
"following lines to ``~/.ssh/config``:"
msgstr ""

#: ../docs/source/howto/ssh.rst:178 ../docs/source/howto/ssh.rst:224
msgid "AiiDA configuration"
msgstr ""

#: ../docs/source/howto/ssh.rst:180
msgid ""
"When :ref:`configuring the computer in AiiDA <how-to:run-"
"codes:computer:configuration>`, simply make sure that ``Allow ssh agent`` is"
" set to ``true`` (default)."
msgstr ""

#: ../docs/source/howto/ssh.rst:185
msgid "Connecting to a remote computer *via* a proxy server"
msgstr ""

#: ../docs/source/howto/ssh.rst:187
msgid ""
"Some compute clusters require you to connect to an intermediate server "
"*PROXY*, from which you can then connect to the cluster *TARGET* on which "
"you run your calculations. This section explains how to use the "
"``proxy_command`` feature of ``ssh`` in order to make this jump "
"automatically."
msgstr ""

#: ../docs/source/howto/ssh.rst:192
msgid ""
"This method can also be used to automatically tunnel into virtual private "
"networks, if you have an account on a proxy/jumphost server with access to "
"the network."
msgstr ""

#: ../docs/source/howto/ssh.rst:197
msgid "SSH configuration"
msgstr ""

#: ../docs/source/howto/ssh.rst:199
msgid ""
"Edit the ``~/.ssh/config`` file on the computer on which you installed AiiDA"
" (or create it if missing) and add the following lines::"
msgstr ""

#: ../docs/source/howto/ssh.rst:207
msgid ""
"replacing the ``..._TARGET`` and ``..._PROXY`` variables with the host/user "
"names of the respective servers."
msgstr ""

#: ../docs/source/howto/ssh.rst:209
msgid "This should allow you to directly connect to the *TARGET* server using"
msgstr ""

#: ../docs/source/howto/ssh.rst:215
msgid ""
"For a *passwordless* connection, you need to follow the instructions :ref"
":`how-to:ssh:passwordless` *twice*: once for the connection from your "
"computer to the *PROXY* server, and once for the connection from the *PROXY*"
" server to the *TARGET* server."
msgstr ""

#: ../docs/source/howto/ssh.rst:219
msgid ""
"If you need to specify a separate SSH key for the proxy, provide it *after* "
"the ``-W`` directive, e.g.::"
msgstr ""

#: ../docs/source/howto/ssh.rst:226
msgid ""
"When :ref:`configuring the computer in AiiDA <how-to:run-"
"codes:computer:configuration>`, AiiDA will automatically parse the required "
"information from your ``~/.ssh/config`` file."
msgstr ""

#: ../docs/source/howto/ssh.rst:230
msgid ""
"When specifying or updating the ``proxy_command`` option via ``verdi "
"computer configure ssh``, please **do not use placeholders** ``%h`` and "
"``%p`` but provide the *actual* hostname and port. AiiDA replaces them only "
"when parsing from the ``~/.ssh/config`` file."
msgstr ""

#: ../docs/source/howto/ssh.rst:235
msgid "Using kerberos tokens"
msgstr ""

#: ../docs/source/howto/ssh.rst:237
msgid ""
"If the remote machine requires authentication through a Kerberos token (that"
" you need to obtain before using ssh), you typically need to"
msgstr ""

#: ../docs/source/howto/ssh.rst:239
msgid "install ``libffi`` (``sudo apt-get install libffi-dev`` under Ubuntu)"
msgstr ""

#: ../docs/source/howto/ssh.rst:240
msgid ""
"install the ``ssh_kerberos`` extra during the installation of aiida-core "
"(see :ref:`intro:install:setup`)."
msgstr ""

#: ../docs/source/howto/ssh.rst:242
msgid ""
"If you provide all necessary ``GSSAPI`` options in your ``~/.ssh/config`` "
"file, ``verdi computer configure`` should already pick up the appropriate "
"values for all the gss-related options."
msgstr ""

#: ../docs/source/howto/visualising_graphs/visualising_graphs.rst:8
msgid "How to visualize provenance"
msgstr ""

#: ../docs/source/howto/visualising_graphs/visualising_graphs.rst:10
msgid "graph,graphviz"
msgstr ""

#: ../docs/source/howto/visualising_graphs/visualising_graphs.rst:15
msgid ""
"This tutorial can be downloaded and run as a Jupyter Notebook: "
":download:`visualising_graphs.ipynb`"
msgstr ""

#: ../docs/source/howto/visualising_graphs/visualising_graphs.rst:18
msgid ""
"The provenance graph of a database can be visually inspected, *via* "
"`graphviz <https://www.graphviz.org/>`__, using both the python API and "
"command-line interface."
msgstr ""

#: ../docs/source/howto/visualising_graphs/visualising_graphs.rst:24
msgid "``verdi graph generate -h``"
msgstr ""

#: ../docs/source/howto/visualising_graphs/visualising_graphs.rst:26
msgid "We first load the database and required modules:"
msgstr ""

#: ../docs/source/howto/visualising_graphs/visualising_graphs.rst:38
msgid ""
"The example provenance graph, used in this tutorial, can be downloaded "
":download:`from this link <graph1.aiida>` :fa:`download`"
msgstr ""

#: ../docs/source/howto/visualising_graphs/visualising_graphs.rst:40
msgid "It can then be imported into the database:"
msgstr ""

#: ../docs/source/howto/visualising_graphs/visualising_graphs.rst:51
msgid ""
"The :py:class:`~aiida.tools.visualization.graph.Graph` class is used to "
"store visual representations of the nodes and edges, which can be added "
"separately or cumulatively by one of the graph traversal methods. The "
":py:attr:`~aiida.tools.visualization.graph.Graph.graphviz` attribute returns"
" a `graphviz.Digraph <https://graphviz.readthedocs.io/en/stable/>`__ "
"instance, which will auto-magically render the graph in the notebook, or can"
" be used to save the graph to file."
msgstr ""

#: ../docs/source/howto/visualising_graphs/visualising_graphs.rst:94
msgid ""
"The :py:class:`~aiida.tools.visualization.graph.Graph` can also be "
"initialized with global style attributes, as outlined in the `graphviz "
"attributes table <https://www.graphviz.org/doc/info/attrs.html>`__."
msgstr ""

#: ../docs/source/howto/visualising_graphs/visualising_graphs.rst:112
msgid ""
"Additionally functions can be parsed to the "
":py:class:`~aiida.tools.visualization.graph.Graph` initializer, to specify "
"exactly how each node will be represented. For example, the "
":py:func:`~aiida.tools.visualization.graph.pstate_node_styles` function "
"colors process nodes by their process state."
msgstr ""

#: ../docs/source/howto/visualising_graphs/visualising_graphs.rst:135
msgid ""
"Edges can be annotated by one or both of their edge label and link type."
msgstr ""

#: ../docs/source/howto/visualising_graphs/visualising_graphs.rst:152
msgid ""
"The :meth:`~aiida.tools.visualization.graph.Graph.recurse_descendants` and "
":meth:`~aiida.tools.visualization.graph.Graph.recurse_ancestors` methods can"
" be used to construct a full provenance graph."
msgstr ""

#: ../docs/source/howto/visualising_graphs/visualising_graphs.rst:171
msgid ""
"The link types can also be filtered, to view only the ‘data’ or ‘logical’ "
"provenance."
msgstr ""

#: ../docs/source/howto/visualising_graphs/visualising_graphs.rst:206
msgid ""
"If you wish to highlight specific node classes, then the "
"``highlight_classes`` option can be used to only color specified nodes:"
msgstr ""

#: ../docs/source/howto/workchains_restart.rst:5
msgid "How to write error-resistant workflows"
msgstr ""

#: ../docs/source/howto/workchains_restart.rst:7
msgid "Overview"
msgstr ""

#: ../docs/source/howto/workchains_restart.rst:9
msgid ""
"This how-to introduces the "
":py:class:`~aiida.engine.processes.workchains.restart.BaseRestartWorkChain`,"
" and how it can be sub-classed to handle known failure modes of processes "
"and calculations."
msgstr ""

#: ../docs/source/howto/workchains_restart.rst:11
msgid ""
"In the :ref:`how-to on writing workflows <how-to:write-workflows>` we "
"discussed how to write a simple multi-step workflow using work chains. "
"However, there is one thing that we did not consider there:"
msgstr ""

#: ../docs/source/howto/workchains_restart.rst:14
msgid "What if a calculation step fails?"
msgstr ""

#: ../docs/source/howto/workchains_restart.rst:16
msgid ""
"For example with the "
":py:class:`~aiida.workflows.arithmetic.multiply_add.MultiplyAddWorkChain`; "
"it launches a "
":py:class:`~aiida.calculations.arithmetic.add.ArithmeticAddCalculation`. If "
"that were to fail, the work chain would except because the line "
"``self.ctx.addition.outputs.sum`` will raise an ``AttributeError``. In this "
"case, where the work chain just runs a single calculation, that is not such "
"a big deal but for real-life work chains that run a number of calculations "
"in sequence, having the work chain except will cause all the work up to that"
" point to be lost. Take as an example a workflow that computes the phonons "
"of a crystal structure using Quantum ESPRESSO:"
msgstr ""

#: ../docs/source/howto/workchains_restart.rst:23
msgid ""
"Schematic diagram of a workflow that computes the phonons of a crystal "
"structure using Quantum ESPRESSO. The workflow consists of four consecutive "
"calculations using the ``pw.x``, ``ph.x``, ``q2r.x`` and ``matdyn.x`` code, "
"respectively."
msgstr ""

#: ../docs/source/howto/workchains_restart.rst:26
msgid ""
"If all calculations run without problems, the workflow itself will of course"
" also run fine and produce the desired final result. But, now imagine the "
"third calculation actually fails. If the workflow does not explicitly check "
"for this failure, but instead blindly assumes that the calculation have "
"produced the required results, it will fail itself, losing the progress it "
"made with the first two calculations."
msgstr ""

#: ../docs/source/howto/workchains_restart.rst:32
msgid ""
"Example execution of the Quantum ESPRESSO phonon workflow where the third "
"step, the ``q2r.x`` code, failed, and because the workflow blindly assumed "
"it would have finished without errors also fails."
msgstr ""

#: ../docs/source/howto/workchains_restart.rst:34
msgid ""
"The solution seems simple then. After each calculation, we simply add a "
"check to verify that it finished successfully and produced the required "
"outputs before continuing with the next calculation. What do we do, though, "
"when the calculation failed? Depending on the cause of the failure, we might"
" actually be able to fix the problem, and re-run the calculation, "
"potentially with corrected inputs. A common example is that the calculation "
"ran out of wall time (requested time from the job scheduler) and was "
"cancelled by the job scheduler. In this case, simply restarting the "
"calculation (if the code supports restarts), and optionally giving the job "
"more wall time or resources, may fix the problem."
msgstr ""

#: ../docs/source/howto/workchains_restart.rst:41
msgid ""
"You might be tempted to add this error handling directly into the workflow. "
"However, this requires implementing the same error-handling code many times "
"in other workflows that just happen to run the same codes. For example, we "
"could add the error handling for the ``pw.x`` code directly in our phonon "
"workflow, but a structure optimization workflow will also have to run "
"``pw.x`` and will have to implement the same error-handling logic. Is there "
"a way that we can implement this once and easily reuse it in various "
"workflows?"
msgstr ""

#: ../docs/source/howto/workchains_restart.rst:46
msgid ""
"Yes! Instead of directly running a calculation in a workflow, one should "
"rather run a work chain that is explicitly designed to run the calculation "
"to completion. This *base* work chain knows about the various failure modes "
"of the calculation and can try to fix the problem and restart the "
"calculation whenever it fails, until it finishes successfully. This logic of"
" such a base work chain is very generic and can be applied to any "
"calculation, and actually any process:"
msgstr ""

#: ../docs/source/howto/workchains_restart.rst:54
msgid ""
"Schematic flow diagram of the logic of a *base* work chain, whose job it is "
"to run a subprocess repeatedly, fixing any potential errors, until it "
"finishes successfully."
msgstr ""

#: ../docs/source/howto/workchains_restart.rst:56
msgid ""
"The work chain runs the subprocess. Once it has finished, it then inspects "
"the status. If the subprocess finished successfully, the work chain returns "
"the results and its job is done. If, instead, the subprocess failed, the "
"work chain should inspect the cause of failure, and attempt to fix the "
"problem and restart the subprocess. This cycle is repeated until the "
"subprocess finishes successfully. Of course this runs the risk of entering "
"into an infinite loop if the work chain never manages to fix the problem, so"
" we want to build in a limit to the maximum number of calculations that can "
"be re-run:"
msgstr ""

#: ../docs/source/howto/workchains_restart.rst:68
msgid ""
"An improved flow diagram for the base work chain that limits the maximum "
"number of iterations that the work chain can try and get the calculation to "
"finish successfully."
msgstr ""

#: ../docs/source/howto/workchains_restart.rst:70
msgid ""
"Since this is such a common logical flow for a base work chain that is to "
"wrap another :py:class:`~aiida.engine.processes.process.Process` and restart"
" it until it is finished successfully, we have implemented it as an abstract"
" base class in ``aiida-core``. The "
":py:class:`~aiida.engine.processes.workchains.restart.BaseRestartWorkChain` "
"implements the logic of the flow diagram shown above. Although the "
"``BaseRestartWorkChain`` is a subclass of "
":py:class:`~aiida.engine.processes.workchains.workchain.WorkChain` itself, "
"you cannot launch it. The reason is that it is completely general and so "
"does not know which :py:class:`~aiida.engine.processes.process.Process` "
"class it should run. Instead, to make use of the base restart work chain, "
"you should subclass it for the process class that you want to wrap."
msgstr ""

#: ../docs/source/howto/workchains_restart.rst:78
msgid "Writing a base restart work chain"
msgstr ""

#: ../docs/source/howto/workchains_restart.rst:80
msgid ""
"In this how-to, we will show how to implement the ``BaseRestartWorkChain`` "
"for the "
":py:class:`~aiida.calculations.arithmetic.add.ArithmeticAddCalculation`. We "
"start by importing the relevant base classes and create a subclass:"
msgstr ""

#: ../docs/source/howto/workchains_restart.rst:95
msgid ""
"As you can see, all we had to do is create a subclass of the "
"``BaseRestartWorkChain`` class, which we called "
"``ArithmeticAddBaseWorkChain``, and set the ``_process_class`` class "
"attribute to ``ArithmeticAddCalculation``. The latter instructs the work "
"chain what type of process it should launch. Next, as with all work chains, "
"we should *define* its process specification:"
msgstr ""

#: ../docs/source/howto/workchains_restart.rst:121
msgid ""
"The inputs and output that we define are essentially determined by the sub "
"process that the work chain will be running. Since the "
"``ArithmeticAddCalculation`` requires the inputs ``x`` and ``y``, and "
"produces the ``sum`` as output, we `mirror` those in the specification of "
"the work chain, otherwise we wouldn't be able to pass the necessary inputs. "
"Finally, we define the logical outline, which if you look closely, resembles"
" the logical flow chart presented in :numref:`workflow-error-handling-flow-"
"loop` a lot. We start by *setting up* the work chain and then enter a loop: "
"*while* the subprocess has not yet finished successfully *and* we haven't "
"exceeded the maximum number of iterations, we *run* another instance of the "
"process and then *inspect* the results. The while conditions are implemented"
" in the ``should_run_process`` outline step. When the process finishes "
"successfully or we have to abandon, we report the *results*. Now unlike with"
" normal work chain implementations, we *do not* have to implement these "
"outline steps ourselves. They have already been implemented by the "
"``BaseRestartWorkChain`` so that we don't have to. This is why the base "
"restart work chain is so useful, as it saves us from writing and repeating a"
" lot of `boilerplate code "
"<https://en.wikipedia.org/wiki/Boilerplate_code>`__."
msgstr ""

#: ../docs/source/howto/workchains_restart.rst:133
msgid ""
"This minimal outline definition is required for the work chain to work "
"properly. If you change the logic, the names of the steps or omit some "
"steps, the work chain will not run. Adding extra outline steps to add custom"
" functionality, however, is fine and actually encouraged if it makes sense."
msgstr ""

#: ../docs/source/howto/workchains_restart.rst:137
msgid ""
"The last part of the puzzle is to define in the setup what inputs the work "
"chain should pass to the subprocess. You might wonder why this is necessary,"
" because we already define the inputs in the specification, but those are "
"not the only inputs that will be passed. The ``BaseRestartWorkChain`` also "
"defines some inputs of its own, such as ``max_iterations`` as you can see in"
" its "
":py:meth:`~aiida.engine.processes.workchains.restart.BaseRestartWorkChain.define`"
" method. To make it absolutely clear what inputs are intended for the "
"subprocess, we define them as a dictionary in the context under the key "
"``inputs``. One way of doing this is to reuse the "
":py:meth:`~aiida.engine.processes.workchains.restart.BaseRestartWorkChain.setup`"
" method:"
msgstr ""

#: ../docs/source/howto/workchains_restart.rst:154
msgid ""
"Note that, as explained before, the ``setup`` step forms a crucial part of "
"the logical outline of any base restart work chain. Omitting it from the "
"outline will break the work chain, but so will overriding it completely, "
"except as long as we call the ``super``."
msgstr ""

#: ../docs/source/howto/workchains_restart.rst:157
msgid ""
"This is all the code we have to write to have a functional work chain. We "
"can now launch it like any other work chain and the ``BaseRestartWorkChain``"
" will work its magic:"
msgstr ""

#: ../docs/source/howto/workchains_restart.rst:164
msgid ""
"Once the work chain finished, we can inspect what has happened with, for "
"example, ``verdi process status``:"
msgstr ""

#: ../docs/source/howto/workchains_restart.rst:172
msgid ""
"As you can see the work chain launched a single instance of the "
"``ArithmeticAddCalculation`` which finished successfully, so the job of the "
"work chain was done as well."
msgstr ""

#: ../docs/source/howto/workchains_restart.rst:176
msgid ""
"If the work chain excepted, make sure the directory containing the WorkChain"
" definition is in the ``PYTHONPATH``."
msgstr ""

#: ../docs/source/howto/workchains_restart.rst:178
msgid ""
"You can add the folder in which you have your Python file defining the "
"WorkChain to the ``PYTHONPATH`` through:"
msgstr ""

#: ../docs/source/howto/workchains_restart.rst:184
msgid "After this, it is **very important** to restart the daemon:"
msgstr ""

#: ../docs/source/howto/workchains_restart.rst:190
msgid ""
"Indeed, when updating an existing work chain file or adding a new one, it is"
" **necessary** to restart the daemon **every time** after all changes have "
"taken place."
msgstr ""

#: ../docs/source/howto/workchains_restart.rst:193
#: ../docs/source/howto/write_workflows.rst:180
msgid "Exposing inputs and outputs"
msgstr ""

#: ../docs/source/howto/workchains_restart.rst:195
msgid ""
"Any base restart work chain *needs* to *expose* the inputs of the subprocess"
" it wraps, and most likely *wants* to do the same for the outputs it "
"produces, although the latter is not necessary. For the simple example "
"presented in the previous section, simply copy-pasting the input and output "
"port definitions of the subprocess ``ArithmeticAddCalculation`` was not too "
"troublesome. However, this quickly becomes tedious, and more importantly, "
"error-prone once you start to wrap processes with quite a few more inputs. "
"To prevent the copy-pasting of input and output specifications, the "
":class:`~aiida.engine.processes.process_spec.ProcessSpec` class provides the"
" :meth:`~plumpy.ProcessSpec.expose_inputs` and "
":meth:`~plumpy.ProcessSpec.expose_outputs` methods:"
msgstr ""

#: ../docs/source/howto/workchains_restart.rst:212
msgid ""
"For more detail on exposing inputs and outputs, see the basic "
":ref:`Workchain usage section "
"<topics:workflows:usage:workchains:expose_inputs_outputs>`."
msgstr ""

#: ../docs/source/howto/workchains_restart.rst:214
msgid ""
"That takes care of exposing the port specification of the wrapped process "
"class in a very efficient way. To efficiently retrieve the inputs that have "
"been passed to the process, one can use the "
":meth:`~aiida.engine.processes.process.Process.exposed_inputs` method. Note "
"the past tense of the method name. The method takes a process class and an "
"optional namespace as arguments, and will return the inputs that have been "
"passed into that namespace when it was launched. This utility now allows us "
"to simplify the ``setup`` outline step that we have shown before:"
msgstr ""

#: ../docs/source/howto/workchains_restart.rst:231
msgid ""
"This way we don't have to manually fish out all the individual inputs from "
"the ``self.inputs`` but have to just call this single method, saving a lot "
"of time and lines of code."
msgstr ""

#: ../docs/source/howto/workchains_restart.rst:233
msgid ""
"When submitting or running the work chain using namespaced inputs (``add`` "
"in the example above), it is important to use the namespace:"
msgstr ""

#: ../docs/source/howto/workchains_restart.rst:248
msgid ""
"Every time you make changes to the ``ArithmeticAddBaseWorkChain``, don't "
"forget to restart the daemon with:"
msgstr ""

#: ../docs/source/howto/workchains_restart.rst:255
msgid "Error handling"
msgstr ""

#: ../docs/source/howto/workchains_restart.rst:257
msgid ""
"So far you have seen how easy it is to get a work chain up and running that "
"will run a subprocess using the ``BaseRestartWorkChain``. However, the whole"
" point of this exercise, as described in the introduction, was for the work "
"chain to be able to deal with *failing* processes, yet in the previous "
"example it finished without any problems."
msgstr ""

#: ../docs/source/howto/workchains_restart.rst:260
msgid "What would have happened if the subprocess had failed?"
msgstr ""

#: ../docs/source/howto/workchains_restart.rst:262
msgid ""
"If the computed sum of the inputs ``x`` and ``y`` is negative, the "
"``ArithmeticAddCalculation`` fails with exit code ``410`` which corresponds "
"to ``ERROR_NEGATIVE_NUMBER``."
msgstr ""

#: ../docs/source/howto/workchains_restart.rst:266
msgid ""
"The :ref:`exit code usage section<topics:processes:usage:exit_codes>`, for a"
" more detailed explanation of exit codes."
msgstr ""

#: ../docs/source/howto/workchains_restart.rst:268
msgid ""
"Let's launch the work chain with inputs that will cause the calculation to "
"fail, e.g. by making one of the operands negative, and see what happens:"
msgstr ""

#: ../docs/source/howto/workchains_restart.rst:274
msgid ""
"This time we will see that the work chain takes quite a different path:"
msgstr ""

#: ../docs/source/howto/workchains_restart.rst:283
msgid ""
"As expected, the ``ArithmeticAddCalculation`` failed this time with a "
"``410``. The work chain noticed the failure when inspecting the result of "
"the subprocess in ``inspect_process``, and in keeping with its name and "
"design, restarted the calculation. However, since the inputs were not "
"changed, the calculation inevitably and wholly expectedly failed once more "
"with the exact same error code. Unlike after the first iteration, however, "
"the work chain did not restart again, but gave up and returned the exit code"
" ``402`` itself, which stands for "
"``ERROR_SECOND_CONSECUTIVE_UNHANDLED_FAILURE``. As the name suggests, the "
"work chain tried to run the subprocess but it failed twice in a row without "
"the problem being *handled*. The obvious question now of course is: \"How "
"exactly can we instruct the base work chain to handle certain problems?\""
msgstr ""

#: ../docs/source/howto/workchains_restart.rst:290
msgid ""
"Since the problems are necessarily dependent on the subprocess that the work"
" chain will run, it cannot be implemented by the ``BaseRestartWorkChain`` "
"class itself, but rather will have to be implemented by the subclass. If the"
" subprocess fails, the ``BaseRestartWorkChain`` calls a set of *process "
"handlers* in the ``inspect_process`` step. Each process handler gets passed "
"the node of the subprocess that was just run, such that it can inspect the "
"results and potentially fix any problems that it finds. To \"register\" a "
"process handler for a base restart work chain implementation, you simply "
"define a method that takes a node as its single argument and decorate it "
"with the :func:`~aiida.engine.processes.workchains.utils.process_handler` "
"decorator:"
msgstr ""

#: ../docs/source/howto/workchains_restart.rst:320
msgid ""
"The method name can be anything as long as it is a valid Python method name "
"and does not overlap with one of the base work chain's methods. For better "
"readability, it is, however, recommended to have the method name start with "
"``handle_``. In this example, we want to specifically check for a particular"
" failure mode of the ``ArithmeticAddCalculation``, so we compare the "
":meth:`~aiida.orm.nodes.process.process.ProcessNode.exit_status` of the node"
" with that of the spec of the process. If the exit code matches, we know "
"that the problem was due to the sum being negative. Fixing this fictitious "
"problem for this example is as simple as making sure that the inputs are all"
" positive, which we can do by taking the absolute value of them. We assign "
"the new values to the ``self.ctx.inputs`` just as where we defined the "
"original inputs in the ``setup`` step. Finally, to indicate that we have "
"handled the problem, we return an instance of "
":class:`~aiida.engine.processes.workchains.utils.ProcessHandlerReport`. This"
" will instruct the work chain to restart the subprocess, taking the updated "
"inputs from the context. With this simple addition, we can now launch the "
"work chain again:"
msgstr ""

#: ../docs/source/howto/workchains_restart.rst:337
msgid ""
"This time around, although the first subprocess fails again with a ``410``, "
"the new process handler is called. It \"fixes\" the inputs, and when the "
"work chain restarts the subprocess with the new inputs it finishes "
"successfully. With this simple process you can add as many process handlers "
"as you would like to deal with any potential problem that might occur for "
"the specific subprocess type of the work chain implementation. To make the "
"code even more readable, the "
":func:`~aiida.engine.processes.workchains.utils.process_handler` decorator "
"comes with various syntactic sugar. Instead of having a conditional at the "
"start of each handler to compare the exit status of the node to a particular"
" exit code of the subprocess, you can define it through the ``exit_codes`` "
"keyword argument of the decorator:"
msgstr ""

#: ../docs/source/howto/workchains_restart.rst:352
msgid ""
"If the ``exit_codes`` keyword is defined, which can be either a single "
"instance of :class:`~aiida.engine.processes.exit_code.ExitCode` or a list "
"thereof, the process handler will only be called if the exit status of the "
"node corresponds to one of those exit codes, otherwise it will simply be "
"skipped."
msgstr ""

#: ../docs/source/howto/workchains_restart.rst:355
msgid "Multiple process handlers"
msgstr ""

#: ../docs/source/howto/workchains_restart.rst:357
msgid ""
"Since typically a base restart work chain implementation will have more than"
" one process handler, one might want to control the order in which they are "
"called. This can be done through the ``priority`` keyword:"
msgstr ""

#: ../docs/source/howto/workchains_restart.rst:369
msgid ""
"The process handlers with a higher priority will be called first. In this "
"scenario, in addition to controlling the order with which the handlers are "
"called, you may also want to stop the process handling once you have "
"determined the problem. This can be achieved by setting the ``do_break`` "
"argument of the ``ProcessHandler`` to ``True``:"
msgstr ""

#: ../docs/source/howto/workchains_restart.rst:382
msgid ""
"Finally, sometimes one detects a problem that simply cannot or should not be"
" corrected by the work chain. In this case, the handler can signal that the "
"work chain should abort by setting an "
":class:`~aiida.engine.processes.exit_code.ExitCode` instance on the "
"``exit_code`` argument of the ``ProcessHandler``:"
msgstr ""

#: ../docs/source/howto/workchains_restart.rst:394
msgid ""
"The base restart work chain will detect this exit code and abort the work "
"chain, setting the corresponding status and message on the node as usual:"
msgstr ""

#: ../docs/source/howto/workchains_restart.rst:402
msgid ""
"With these basic tools, a broad range of use-cases can be addressed while "
"preventing a lot of boilerplate code."
msgstr ""

#: ../docs/source/howto/write_workflows.rst:5
msgid "How to write and extend workflows"
msgstr ""

#: ../docs/source/howto/write_workflows.rst:8
msgid "Writing workflows"
msgstr ""

#: ../docs/source/howto/write_workflows.rst:10
msgid ""
"A workflow in AiiDA is a :ref:`process <topics:processes:concepts>` that "
"calls other workflows and calculations and optionally *returns* data and as "
"such can encode the logic of a typical scientific workflow. Currently, there"
" are two ways of implementing a workflow process:"
msgstr ""

#: ../docs/source/howto/write_workflows.rst:13
msgid ":ref:`work functions<topics:workflows:concepts:workfunctions>`"
msgstr ""

#: ../docs/source/howto/write_workflows.rst:14
msgid ":ref:`work chains<topics:workflows:concepts:workchains>`"
msgstr ""

#: ../docs/source/howto/write_workflows.rst:16
msgid ""
"Here we present a brief introduction on how to write both workflow types."
msgstr ""

#: ../docs/source/howto/write_workflows.rst:20
msgid ""
"For more details on the concept of a workflow, and the difference between a "
"work function and a work chain, please see the corresponding :ref:`topics "
"section<topics:workflows:concepts>`."
msgstr ""

#: ../docs/source/howto/write_workflows.rst:24
msgid ""
"Developing workflows may involve running several lengthy calculations. "
"Consider :ref:`enabling caching <how-to:run-codes:caching>` to help avoid "
"repeating long workflow steps."
msgstr ""

#: ../docs/source/howto/write_workflows.rst:27
msgid "Work function"
msgstr ""

#: ../docs/source/howto/write_workflows.rst:29
msgid ""
"A *work function* is a process function that calls one or more calculation "
"functions and *returns* data that has been *created* by the calculation "
"functions it has called. Moreover, work functions can also call other work "
"functions, allowing you to write nested workflows. Writing a work function, "
"whose provenance is automatically stored, is as simple as writing a Python "
"function and decorating it with the "
":class:`~aiida.engine.processes.functions.workfunction` decorator:"
msgstr ""

#: ../docs/source/howto/write_workflows.rst:37
msgid ""
"It is important to reiterate here that the "
":class:`~aiida.engine.processes.functions.workfunction`-decorated "
"``add_multiply()`` function does not *create* any new data nodes. The "
"``add()`` and ``multiply()`` calculation functions create the ``Int`` data "
"nodes, all the work function does is *return* the results of the "
"``multiply()`` calculation function. Moreover, both calculation and workflow"
" functions can only accept and return data nodes, i.e. instances of classes "
"that subclass the :class:`~aiida.orm.nodes.data.data.Data` class."
msgstr ""

#: ../docs/source/howto/write_workflows.rst:42
msgid "Work chain"
msgstr ""

#: ../docs/source/howto/write_workflows.rst:44
msgid ""
"When the workflow you want to run is more complex and takes longer to "
"finish, it is better to write a *work chain*. Writing a work chain in AiiDA "
"requires creating a class that inherits from the "
":class:`~aiida.engine.processes.workchains.workchain.WorkChain` class. Below"
" is an example of a work chain that takes three integers as inputs, "
"multiplies the first two and then adds the third to obtain the final result:"
msgstr ""

#: ../docs/source/howto/write_workflows.rst:52
msgid ""
"You can give the work chain any valid Python class name, but the convention "
"is to have it end in "
":class:`~aiida.engine.processes.workchains.workchain.WorkChain` so that it "
"is always immediately clear what it references. Let's go over the methods of"
" the ``MultiplyAddWorkChain`` one by one:"
msgstr ""

#: ../docs/source/howto/write_workflows.rst:60
msgid ""
"The most important method to implement for every work chain is the "
"``define()`` method. This class method must always start by calling the "
"``define()`` method of its parent class. Next, the ``define()`` method "
"should be used to define the specifications of the work chain, which are "
"contained in the work chain ``spec``:"
msgstr ""

#: ../docs/source/howto/write_workflows.rst:64
msgid ""
"the **inputs**, specified using the ``spec.input()`` method. The first "
"argument of the ``input()`` method is a string that specifies the label of "
"the input, e.g. ``'x'``. The ``valid_type`` keyword argument allows you to "
"specify the required node type of the input. Other keyword arguments allow "
"the developer to set a default for the input, or indicate that an input "
"should not be stored in the database, see :ref:`the process topics section "
"<topics:processes:usage:spec>` for more details."
msgstr ""

#: ../docs/source/howto/write_workflows.rst:68
msgid ""
"the **outline** or logic of the workflow, specified using the "
"``spec.outline()`` method. The outline of the workflow is constructed from "
"the methods of the "
":class:`~aiida.engine.processes.workchains.workchain.WorkChain` class. For "
"the ``MultiplyAddWorkChain``, the outline is a simple linear sequence of "
"steps, but it's possible to include actual logic, directly in the outline, "
"in order to define more complex workflows as well. See the :ref:`work chain "
"outline section <topics:workflows:usage:workchains:define_outline>` for more"
" details."
msgstr ""

#: ../docs/source/howto/write_workflows.rst:72
msgid ""
"the **outputs**, specified using the ``spec.output()`` method. This method "
"is very similar in its usage to the ``input()`` method."
msgstr ""

#: ../docs/source/howto/write_workflows.rst:74
msgid ""
"the **exit codes** of the work chain, specified using the "
"``spec.exit_code()`` method. Exit codes are used to clearly communicate "
"known failure modes of the work chain to the user. The first and second "
"arguments define the ``exit_status`` of the work chain in case of failure "
"(``400``) and the string that the developer can use to reference the exit "
"code (``ERROR_NEGATIVE_NUMBER``). A descriptive exit message can be provided"
" using the ``message`` keyword argument. For the ``MultiplyAddWorkChain``, "
"we demand that the final result is not a negative number, which is checked "
"in the ``validate_result`` step of the outline."
msgstr ""

#: ../docs/source/howto/write_workflows.rst:82
msgid ""
"For more information on the ``define()`` method and the process spec, see "
"the :ref:`corresponding section in the topics "
"<topics:processes:usage:defining>`."
msgstr ""

#: ../docs/source/howto/write_workflows.rst:84
msgid ""
"The ``multiply`` method is the first step in the outline of the "
"``MultiplyAddWorkChain`` work chain."
msgstr ""

#: ../docs/source/howto/write_workflows.rst:92
msgid ""
"This step simply involves running the calculation function ``multiply()``, "
"on the ``x`` and ``y`` **inputs** of the work chain. To store the result of "
"this function and use it in the next step of the outline, it is added to the"
" *context* of the work chain using ``self.ctx``."
msgstr ""

#: ../docs/source/howto/write_workflows.rst:101
msgid ""
"The ``add()`` method is the second step in the outline of the work chain. As"
" this step uses the ``ArithmeticAddCalculation`` calculation job, we start "
"by setting up the inputs for this "
":class:`~aiida.engine.processes.calcjobs.calcjob.CalcJob` in a dictionary. "
"Next, when submitting this calculation job to the daemon, it is important to"
" use the submit method from the work chain instance via ``self.submit()``. "
"Since the result of the addition is only available once the calculation job "
"is finished, the ``submit()`` method returns the "
":class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode` of the "
"*future* ``ArithmeticAddCalculation`` process. To tell the work chain to "
"wait for this process to finish before continuing the workflow, we return "
"the ``ToContext`` class, where we have passed a dictionary to specify that "
"the future calculation job node should be assigned to the ``'addition'`` "
"context key."
msgstr ""

#: ../docs/source/howto/write_workflows.rst:109
msgid ""
"Never use the global ``submit()`` function to submit calculations to the "
"daemon within a "
":class:`~aiida.engine.processes.workchains.workchain.WorkChain`. Doing so "
"will raise an exception during runtime. See the :ref:`topics section on work"
" chains<topics:workflows:usage:workchains:submitting_sub_processes>` for "
"more details."
msgstr ""

#: ../docs/source/howto/write_workflows.rst:114
msgid ""
"Instead of passing a dictionary, you can also initialize a ``ToContext`` "
"instance by passing the future process as a keyword argument, e.g. "
"``ToContext(addition=calcjob_node)``. More information on the ``ToContext`` "
"class can be found in :ref:`the topics section on submitting sub "
"processes<topics:workflows:usage:workchains:submitting_sub_processes>`."
msgstr ""

#: ../docs/source/howto/write_workflows.rst:123
msgid ""
"Once the ``ArithmeticAddCalculation`` calculation job is finished, the next "
"step in the work chain is to validate the result, i.e. verify that the "
"result is not a negative number. After the ``addition`` node has been "
"extracted from the context, we take the ``sum`` node from the "
"``ArithmeticAddCalculation`` outputs and store it in the ``result`` "
"variable. In case the value of this ``Int`` node is negative, the "
"``ERROR_NEGATIVE_NUMBER`` exit code - defined in the ``define()`` method - "
"is returned. Note that once an exit code is returned during any step in the "
"outline, the work chain will be terminated and no further steps will be "
"executed."
msgstr ""

#: ../docs/source/howto/write_workflows.rst:134
msgid ""
"The final step in the outline is to pass the result to the outputs of the "
"work chain using the ``self.out()`` method. The first argument "
"(``'result'``) specifies the label of the output, which corresponds to the "
"label provided to the spec in the ``define()`` method. The second argument "
"is the result of the work chain, extracted from the ``Int`` node stored in "
"the context under the ``'addition'`` key."
msgstr ""

#: ../docs/source/howto/write_workflows.rst:138
msgid ""
"For a more complete discussion on workflows and their usage, please read "
":ref:`the corresponding topics section<topics:workflows:usage>`."
msgstr ""

#: ../docs/source/howto/write_workflows.rst:143
msgid "Extending workflows"
msgstr ""

#: ../docs/source/howto/write_workflows.rst:145
msgid ""
"When designing workflows, there are many cases where you want to reuse an "
"existing process. This section explains how to extend workflows by wrapping "
"them around other processes or linking them together."
msgstr ""

#: ../docs/source/howto/write_workflows.rst:148
msgid ""
"As an example, let's say you want to extend the ``MultiplyAddWorkChain`` by "
"adding another step of analysis that checks whether the result is an even "
"number or not. This final step can be written as a simple ``calcfunction``:"
msgstr ""

#: ../docs/source/howto/write_workflows.rst:155
msgid ""
"We could simply write a new workflow based off ``MultiplyAddWorkChain`` that"
" includes an extra step in the outline which runs the ``is_even`` "
"calculation function. However, this would lead to a lot of code duplication,"
" and longer workflows consisting of multiple work chains would become very "
"cumbersome to deal with (see the dropdown panel below)."
msgstr ""

#: ../docs/source/howto/write_workflows.rst:166
msgid ""
"We've removed the ``result`` step from the outline, as well as the "
"``result`` output. For this work chain, we're assuming that for now we are "
"only interested in whether or not the result is even."
msgstr ""

#: ../docs/source/howto/write_workflows.rst:169
msgid ""
"We can avoid some code duplication by simply submitting the "
"``MultiplyAddWorkChain`` within one of the steps of a new work chain which "
"would then call ``is_even`` in a second step:"
msgstr ""

#: ../docs/source/howto/write_workflows.rst:175
msgid ""
"This already simplifies the extended work chain, and avoids duplicating the "
"steps of the ``MultiplyAddWorkChain`` in the outline. However, we still had "
"to copy all of the input definitions of the ``MultiplyAddWorkChain``, and "
"manually extract them from the inputs before passing them to the "
"``self.submit`` method. Fortunately, there is a better way of *exposing* the"
" inputs and outputs of subprocesses of the work chain."
msgstr ""

#: ../docs/source/howto/write_workflows.rst:182
msgid ""
"In many cases it is convenient for work chains to expose the inputs of the "
"subprocesses it wraps so users can specify these inputs directly, as well as"
" exposing some of the outputs produced as one of the results of the parent "
"work chain. For the simple example presented in the previous section, simply"
" copy-pasting the input and output port definitions of the subprocess "
"``MultiplyAddWorkChain`` was not too troublesome. However, this quickly "
"becomes tedious and error-prone once you start to wrap processes with quite "
"a few more inputs."
msgstr ""

#: ../docs/source/howto/write_workflows.rst:186
msgid ""
"To prevent the copy-pasting of input and output specifications, the "
":class:`~aiida.engine.processes.process_spec.ProcessSpec` class provides the"
" :meth:`~plumpy.ProcessSpec.expose_inputs` and "
":meth:`~plumpy.ProcessSpec.expose_outputs` methods. Calling "
":meth:`~plumpy.ProcessSpec.expose_inputs` for a particular ``Process`` "
"class, will automatically copy the inputs of the class into the inputs "
"namespace of the process specification:"
msgstr ""

#: ../docs/source/howto/write_workflows.rst:202
msgid ""
"Be aware that any inputs that already exist in the namespace will be "
"overridden. To prevent this, the method accepts the ``namespace`` argument, "
"which will cause the inputs to be copied into that namespace instead of the "
"top-level namespace. This is especially useful for exposing inputs since "
"*all* processes have the ``metadata`` input. If you expose the inputs "
"without a namespace, the ``metadata`` input port of the exposed class will "
"override the one of the host, which is often not desirable. Let's copy the "
"inputs of the ``MultiplyAddWorkChain`` into the ``multiply_add`` namespace:"
msgstr ""

#: ../docs/source/howto/write_workflows.rst:213
msgid ""
"That takes care of exposing the port specification of the wrapped process "
"class in a very efficient way. To easily retrieve the inputs that have been "
"passed to the process, one can use the "
":meth:`~aiida.engine.processes.process.Process.exposed_inputs` method. Note "
"the past tense of the method name. The method takes a process class and an "
"optional namespace as arguments, and will return the inputs that have been "
"passed into that namespace when it was launched. This utility now allows us "
"to simplify the ``multiply_add`` step in the outline:"
msgstr ""

#: ../docs/source/howto/write_workflows.rst:224
msgid ""
"This way we don't have to manually fish out all the individual inputs from "
"the ``self.inputs`` but have to just call this single method, saving time "
"and lines of code. The final ``MultiplyAddIsEvenWorkChain`` can be found in "
"the dropdown panel below."
msgstr ""

#: ../docs/source/howto/write_workflows.rst:233
msgid ""
"When submitting or running the work chain using namespaced inputs "
"(``multiply_add`` in the example above), it is important to use the "
"namespace when providing the inputs:"
msgstr ""

#: ../docs/source/howto/write_workflows.rst:244
msgid ""
"After running the ``MultiplyAddIsEvenWorkChain``, you can see a hierarchical"
" overview of the processes called by the work chain using the ``verdi "
"process status`` command:"
msgstr ""

#: ../docs/source/howto/write_workflows.rst:255
msgid ""
"Note that this command also recursively shows the processes called by the "
"subprocesses of the ``MultiplyAddIsEvenWorkChain`` work chain."
msgstr ""

#: ../docs/source/howto/write_workflows.rst:257
msgid ""
"As mentioned earlier, you can also expose the outputs of the "
"``MultiplyAddWorkChain`` using the "
":meth:`~plumpy.ProcessSpec.expose_outputs` method. Say we want to add the "
"``result`` of the ``MultiplyAddWorkChain`` as one of the outputs of the "
"extended work chain:"
msgstr ""

#: ../docs/source/howto/write_workflows.rst:274
msgid ""
"Since there is not one output port that is shared by all process classes, it"
" is less critical to use the ``namespace`` argument when exposing outputs. "
"However, take care not to override the outputs of the parent work chain in "
"case they do have outputs with the same port name. We still need to pass the"
" ``result`` of the ``MultiplyAddWorkChain`` to the outputs of the parent "
"work chain. For example, we could do this in the ``is_even`` step by using "
"the :meth:`~aiida.engine.processes.process.Process.out` method:"
msgstr ""

#: ../docs/source/howto/write_workflows.rst:289
msgid ""
"This works fine if we want to pass a single output to the parent work chain,"
" but once again becomes tedious and error-prone when passing multiple "
"outputs. Instead we can use the "
":meth:`~aiida.engine.processes.process.Process.exposed_outputs` method in "
"combination with the "
":meth:`~aiida.engine.processes.process.Process.out_many` method:"
msgstr ""

#: ../docs/source/howto/write_workflows.rst:301
msgid ""
"The :meth:`~aiida.engine.processes.process.Process.exposed_outputs` method "
"returns a dictionary of the exposed outputs of the ``MultiplyAddWorkChain``,"
" extracted from the workchain node stored in the ``multi_addition`` key of "
"the context. The :meth:`~aiida.engine.processes.process.Process.out_many` "
"method takes this dictionary and assigns its values to the output ports with"
" names equal to the corresponding keys."
msgstr ""

#: ../docs/source/howto/write_workflows.rst:306
msgid ""
"Besides avoiding code duplication and errors, using the methods for exposing"
" inputs and outputs also has the advantage that our parent work chain "
"doesn't have to be adjusted in case the inputs or outputs of the child work "
"chain change. This makes the code much easier to maintain."
msgstr ""
