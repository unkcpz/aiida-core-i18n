# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2020, ECOLE POLYTECHNIQUE FEDERALE DE LAUSANNE (Theory and Simulation of Materials (THEOS) and National Centre for Computational Design and Discovery of Novel Materials (NCCR MARVEL)), Switzerland and ROBERT BOSCH LLC, USA. All rights reserved
# This file is distributed under the same license as the AiiDA package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Jason.Eu <morty.yu@yahoo.com>, 2021
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: AiiDA 1.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-04-29 08:46+0000\n"
"PO-Revision-Date: 2020-07-01 16:11+0000\n"
"Last-Translator: Jason.Eu <morty.yu@yahoo.com>, 2021\n"
"Language-Team: Chinese (China) (https://www.transifex.com/aiidateam/teams/98967/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../docs/source/intro/about.rst:5
msgid "What is AiiDA"
msgstr ""

#: ../docs/source/intro/about.rst:7
msgid ""
"AiiDA is an open-source Python infrastructure to help researchers with "
"automating, managing, persisting, sharing and reproducing the complex "
"workflows associated with modern computational science and all associated "
"data."
msgstr ""
"AiiDA是一个使用Python编写的开源复杂工作流设计和管理框架，旨在帮助从事计算科学（计算材料学，计算生物学等）的相关研究者可以更好的管理，编写，使用和分享复杂的工作流以及计算产生的有用数据。它使得在研究中复杂的计算流程的可重复性得以保证。"

#: ../docs/source/intro/about.rst:9
msgid ""
"AiiDA is built to support and streamline the four core pillars of the ADES "
"model: Automation, Data, Environment, and Sharing (described `here "
"<https://arxiv.org/abs/1504.01163>`__). Some of the key features of AiiDA "
"include:"
msgstr ""
"AiiDA实现并支持了ADES 模式的四大基石： (A)utomation（自动）, (D)ata（数据）, (E)nvironment（社区环境）, "
"和 (S)haring （分享） (在 `该论文 <https://arxiv.org/abs/1504.01163>`__). "
"AiiDA支持的一些典型特性包括："

#: ../docs/source/intro/about.rst:11
msgid ""
"**Workflows:** AiiDA allows to build and execute complex, auto-documenting "
"workflows linked to multiple codes on local and remote computers."
msgstr "**工作流：** AiiDA 可以用来创建并执行复杂的，自动文档化的工作流，来连接本地和远端计算资源上的多个计算代码。"

#: ../docs/source/intro/about.rst:12
msgid ""
"**High-throughput:** AiiDA's event-based workflow engine supports tens of "
"thousands of processes per hour with full check-pointing."
msgstr "**高通量：** AiiDA的基于事件的工作流引擎支持成百上千（每小时）的带有检查点的计算例程。"

#: ../docs/source/intro/about.rst:13
msgid ""
"**Data provenance:** AiiDA automatically tracks and records inputs, outputs "
"and metadata of all calculations and workflows in extensive provenance "
"graphs that preserve the full lineage of all data."
msgstr ""
"**数据可验证性** AiiDA 自动追踪所有可验证性图中(provenance graph) 的输入、输出和元数据，以保证计算的完全的可重复性。"

#: ../docs/source/intro/about.rst:14
msgid ""
"**Advanced queries:** AiiDA's query language enables fast graph queries on "
"millions of nodes."
msgstr "**高级的查询检索特性：** AiiDA'的查询语言支持快速的千万个节点的图查询。"

#: ../docs/source/intro/about.rst:15
msgid ""
"**Plugin interface:** AiiDA can support via plugins any computational code "
"and data analytics tool, data type, scheduler, connection mode, etc. (see "
"`public plugin repository <https://aiidateam.github.io/aiida-registry/>`__)."
msgstr ""
"**插件接口：:** AiiDA 可以通过插件来支持各种计算代码，和各种数据分析工具，各种数据类型，任务调度工具以及远程连接方式等 (参见 `公共插件库"
" <https://aiidateam.github.io/aiida-registry/>`__)."

#: ../docs/source/intro/about.rst:16
msgid ""
"**HPC interface:** AiiDA can seamlessly deal with heterogeneous and remote "
"computing resources; it works with many schedulers out of the box (`SLURM "
"<https://slurm.schedmd.com>`__, `PBS Pro <https://www.pbspro.org/>`__, "
"`torque <http://www.adaptivecomputing.com/products/torque/>`__, `SGE "
"<http://gridscheduler.sourceforge.net/>`__ or `LSF "
"<https://www.ibm.com/support/knowledgecenter/SSETD4/product_welcome_platform_lsf.html>`__)."
msgstr ""
"**高性能集群接口：** AiiDA支持无缝的把你的计算从一个集群转换到另一个集群运行。AiiDA 兼容各种任务调度软件 `SLURM "
"<https://slurm.schedmd.com>`_, `PBS Pro <https://www.pbspro.org/>`_, `torque"
" <http://www.adaptivecomputing.com/products/torque/>`_, `SGE "
"<http://gridscheduler.sourceforge.net/>`_ 或者 `LSF "
"<https://www.ibm.com/support/knowledgecenter/SSETD4/product_welcome_platform_lsf.html>`_"
" ，对这些任务调度工具AiiDA都是源生支持的。"

#: ../docs/source/intro/about.rst:17
msgid ""
"**Open science:** AiiDA allows to export both full databases and selected "
"subsets, to be shared with collaborators or made available and browsable "
"online on the `Archive <https://archive.materialscloud.org/>`__ and `Explore"
" <https://www.materialscloud.org/explore>`__ sections of `Materials Cloud "
"<https://www.materialscloud.org>`__."
msgstr ""
"**开放科学：** AiiDA可以将全部或部分的数据库导出，以便于和同行分享，或上传至 `Materials Cloud "
"<https://www.materialscloud.org>`__ 以变 `归档 "
"<https://archive.materialscloud.org/>`__ 和 `检索 "
"<https://www.materialscloud.org/explore>`__ 。"

#: ../docs/source/intro/about.rst:18
msgid ""
"**Open source:** AiiDA is released under the `MIT open-source license "
"<LICENSE.txt>`__."
msgstr "**开源：** AiiDA 通过 `MIT 开源协议 <LICENSE.txt>`__ 发布"

#: ../docs/source/intro/about.rst:20
msgid ""
"See also the `list of AiiDA-powered scientific publications "
"<http://www.aiida.net/science/>`__ and `testimonials from AiiDA users "
"<http://www.aiida.net/testimonials/>`__."
msgstr ""
"同时参见 `已发表的得益于AiiDA的科学文献 <http://www.aiida.net/science/>`__ 和 `来自AiiDA 用户的推荐书"
" <http://www.aiida.net/testimonials/>`__."

#: ../docs/source/intro/get_started.rst:5
msgid "Getting started"
msgstr "从这里开始"

#: ../docs/source/intro/get_started.rst:7
msgid ""
"An AiiDA installation consists of three core components (plus any external "
"codes you wish to run):"
msgstr "AiiDA的安装有三个主要组建的安装组成（另外还包括你需要运行的外部代码的安装）："

#: ../docs/source/intro/get_started.rst:9
msgid ""
"aiida-core: The main Python package and the associated ``verdi`` command "
"line interface"
msgstr "aiida-core（核心组建）: 主体Python包以及命令还接口程序 ``verdi`` "

#: ../docs/source/intro/get_started.rst:10
msgid ""
"|PostgreSQL|: The service that manages the database that AiiDA uses to store"
" data."
msgstr "|PostgreSQL|: AiiDA用户用于存放和管理计算数据的数据库服务"

#: ../docs/source/intro/get_started.rst:11
msgid "|RabbitMQ|: The message broker used for communication within AiiDA."
msgstr "|RabbitMQ|: AiiDA中用于工作流程中控制消息储存和通信的消息中间件组建。"

#: ../docs/source/intro/get_started.rst:25
msgid "Setup"
msgstr "配置"

#: ../docs/source/intro/get_started.rst:27
msgid ""
"There are multiple routes to setting up a working AiiDA environment. Which "
"of those is optimal depends on your environment and use case. If you are "
"unsure, use the :ref:`system-wide installation <intro:get_started:system-"
"wide-install>` method."
msgstr ""
"有多种方法可以设置一个可工作的AiiDA环境。哪一个是最优的取决于您的环境和用例。如果不确定，请使用:ref:`全系统安装 "
"<intro:get_started:system-wide-install>` 方法。"

#: ../docs/source/intro/get_started.rst:35
msgid ":fa:`desktop,mr-1` **System-wide installation**"
msgstr ":fa:`desktop,mr-1` **全系统安装**"

#: ../docs/source/intro/get_started.rst:42
msgid ""
"Install the prerequisite services using standard package managers (apt, "
"homebrew, etc.) with administrative privileges."
msgstr "使用管理员权限,用标准包管理器(apt、homebrew等)安装必备服务。"

#: ../docs/source/intro/get_started.rst:46
msgid ":fa:`folder,mr-1` **Installation into Conda environment**"
msgstr ":fa:`folder,mr-1` **在Conda环境中安装**"

#: ../docs/source/intro/get_started.rst:53
msgid ""
"This method does not require administrative privileges, but involves manual "
"management of start-up and shut-down of services."
msgstr "此方法不需要管理特权，但需要对服务手动启动和关闭."

#: ../docs/source/intro/get_started.rst:57
msgid ":fa:`cube,mr-1` **Run via docker container**"
msgstr ":fa:`cube,mr-1` **在docker容器中运行**"

#: ../docs/source/intro/get_started.rst:64
msgid ""
"Does not require the separate installation of prerequisite services. "
"Especially well-suited to get directly started on the **tutorials**."
msgstr "不需要单独安装先决服务。特别适合直接开体验**入门教程**。"

#: ../docs/source/intro/get_started.rst:69
msgid ":fa:`cloud,mr-1` **Run via virtual machine**"
msgstr ":fa:`cloud,mr-1` **在虚拟机中运行**"

#: ../docs/source/intro/get_started.rst:75
msgid ""
"`Materials Cloud <https://www.materialscloud.org>`__ provides both "
"downloadable and web based VMs, also incorporating pre-installed Materials "
"Science codes."
msgstr ""
"`Materials Cloud `__ 提供了可供用户直接从网上下载的虚拟机文件，该虚拟机包含了预先安装的各种Materials Science "
"的计算代码。"

#: ../docs/source/intro/get_started.rst:81
msgid "What's next?"
msgstr "接下来呢？"

#: ../docs/source/intro/get_started.rst:83
msgid ""
"After successfully completing one of the above outlined setup routes, if you"
" are new to AiiDA, we recommed you go through the :ref:`Basic Tutorial "
"<tutorial:basic>`, or see our :ref:`Next steps guide <tutorial:next-steps>`."
msgstr ""
"在成功完成上面列出的其中一条设置路线后，如果你是AiiDA的新手，我们建议你浏览 :ref:`基础教程 "
"<tutorial:basic>`,，或者查看我们的:ref:`下一步指南<tutorial:next-steps>`。"

#: ../docs/source/intro/get_started.rst:86
msgid ""
"If however, you encountered some issues, proceed to the "
":ref:`troubleshooting section <intro:troubleshooting>`."
msgstr "但是，如果遇到一些问题，请转:ref:`请参见故障排除 <intro:troubleshooting>`."

#: ../docs/source/intro/get_started.rst:88
msgid "In-depth instructions"
msgstr "进阶说明"

#: ../docs/source/intro/get_started.rst:91
msgid ""
"For more detailed instructions on configuring AiiDA, :ref:`see the "
"configuration how-to <how-to:installation:configure>`."
msgstr "更多更详细的AiiDA配置方法请参考 :ref:`配置篇 <how-to:installation:configure>`."

#: ../docs/source/intro/index.rst:3
msgid "Introduction"
msgstr "概述"

#: ../docs/source/intro/install_conda.rst:5
msgid "Installation into Conda environment"
msgstr "安装到Conda环境"

#: ../docs/source/intro/install_conda.rst:7
msgid ""
"This installation route installs all necessary software -- including the "
"prerequisite services PostgreSQL and RabbitMQ -- into a Conda environment. "
"This is the recommended method for users on shared systems and systems where"
" the user has no administrative privileges."
msgstr ""
"这个安装路径将所有必要的软件(包括先决服务PostgreSQL和RabbitMQ)安装到Conda环境中。对于管理员权限的用户，这是推荐的方法。"

#: ../docs/source/intro/install_conda.rst:12
msgid ""
"This installation method installs **all** software into a conda environment,"
" including PostgreSQL and RabbitMQ. See the :ref:`system-wide installation "
"<intro:get_started:system-wide-install>` to use Conda only to install the "
"AiiDA (core) Python package."
msgstr ""
"这个安装方法将所有的软件安装到conda环境中，包括PostgreSQL和RabbitMQ。请参阅:ref:`全系统安装 "
"<intro:get_started:system-wide-install>` "
"仅使用Conda来安装AiiDA(核心)Python包(而不包含服务)。"

#: ../docs/source/intro/install_conda.rst:19
msgid "**Install prerequisite services + AiiDA (core)**"
msgstr "**安装必备服务+ AiiDA(核心)**"

#: ../docs/source/intro/install_conda.rst:29
msgid "**Start-up services and initialize data storage**"
msgstr "**启动服务，初始化数据存储**"

#: ../docs/source/intro/install_conda.rst:31
msgid ""
"Before working with AiiDA, you must first initialize a database storage area"
" on disk."
msgstr "在使用AiIDA之前，你必须先在硬盘上初始化一块储存。"

#: ../docs/source/intro/install_conda.rst:37
msgid ""
"This *database cluster* may contain a collection of databases (one per "
"profile) that is managed by a single running server process. We start this "
"process with:"
msgstr ""
"这一 *数据储存快* 可能将会包含多个数据库 （每个配置档案对应一个数据库） "
"。该初始化过程可以通过一个运行一个服务进程来实现。我们使用下面命令来开启进程："

#: ../docs/source/intro/install_conda.rst:44
msgid "Further Reading"
msgstr "拓展阅读"

#: ../docs/source/intro/install_conda.rst:47
#: ../docs/source/intro/installation.rst:25
msgid ""
"`Creating a Database Cluster <https://www.postgresql.org/docs/12/creating-"
"cluster.html>`__."
msgstr "`创建数据块 <https://www.postgresql.org/docs/12/creating-cluster.html>`__."

#: ../docs/source/intro/install_conda.rst:48
#: ../docs/source/intro/installation.rst:26
msgid ""
"`Starting the Database Server <https://www.postgresql.org/docs/12/server-"
"start.html>`__."
msgstr "`启动数据库服务 <https://www.postgresql.org/docs/12/server-start.html>`__."

#: ../docs/source/intro/install_conda.rst:50
msgid "Then, start the RabbitMQ server:"
msgstr "然后启动RabbitMQ服务器:"

#: ../docs/source/intro/install_conda.rst:56
msgid "Finally, start the AiiDA daemon(s):"
msgstr "最后，启动AiiDA守护进程:"

#: ../docs/source/intro/install_conda.rst:64
#: ../docs/source/intro/install_system.rst:251
msgid "The verdi daemon(s) must be restarted after a system reboot."
msgstr "verdi守护进程必须在系统重新启动后重新启动。"

#: ../docs/source/intro/install_conda.rst:68
#: ../docs/source/intro/install_system.rst:255
msgid ""
"Do not start more daemons then there are physical processors on your system."
msgstr "当系统上有物理处理器时，不要启动更多的守护进程。"

#: ../docs/source/intro/install_conda.rst:72
#: ../docs/source/intro/install_system.rst:219
msgid "**Setup profile**"
msgstr "**设置配置文件**"

#: ../docs/source/intro/install_conda.rst:74
#: ../docs/source/intro/install_system.rst:221
msgid ""
"Next, set up an AiiDA configuration profile and related data storage, with "
"the ``verdi quicksetup`` command."
msgstr "接下来，我们使用 ``verdi quicksetup`` 指令设置一个AiiDA配置档案，并关联数据储存块。"

#: ../docs/source/intro/install_conda.rst:87
#: ../docs/source/intro/install_system.rst:234
msgid "Is AiiDA unable to auto-detect the PostgreSQL setup?"
msgstr "AiiDA无法自动检测PostgreSQL设置?"

#: ../docs/source/intro/install_conda.rst:90
#: ../docs/source/intro/install_system.rst:237
msgid ""
"If you get an error saying that AiiDA has trouble autodetecting the "
"PostgreSQL setup, you will need to do the manual setup explained in the "
":ref:`troubleshooting section<intro:troubleshooting:installation:postgresql-"
"autodetect-issues>`."
msgstr ""
"如果你得到一个错误，说AiiDA有自动检测PostgreSQL设置的困难，你将需要手动设置 "
":ref:`故障排除章节<intro:troubleshooting:installation:postgresql-autodetect-"
"issues>`.。"

#: ../docs/source/intro/install_conda.rst:94
#: ../docs/source/intro/install_system.rst:259
#: ../docs/source/intro/run_docker.rst:41
msgid "**Check setup**"
msgstr "**检查设置**"

#: ../docs/source/intro/install_conda.rst:96
#: ../docs/source/intro/install_system.rst:261
msgid "To check that everything is set up correctly, execute:"
msgstr "要检查所有设置是否正确，请执行:"

#: ../docs/source/intro/install_conda.rst:108
msgid ""
"At this point you now have a working AiiDA environment, from which you can "
"add and retrieve data."
msgstr "现在，你就拥有了一个可使用的AiIDA环境了，你可以向其中增加或提取数据。"

#: ../docs/source/intro/install_conda.rst:110
#: ../docs/source/intro/install_system.rst:275
msgid "Missing a checkmark or ecountered some other issue?"
msgstr "缺少一个勾号还是有其他问题?"

#: ../docs/source/intro/install_conda.rst:113
#: ../docs/source/intro/install_system.rst:278
msgid ":ref:`See the troubleshooting section <intro:troubleshooting>`."
msgstr ":ref:`请参见故障排除章节 <intro:troubleshooting>`."

#: ../docs/source/intro/install_conda.rst:122
msgid "**Shut-down services**"
msgstr "**关闭服务**"

#: ../docs/source/intro/install_conda.rst:124
msgid ""
"After finishing with your aiida session, particularly if switching between "
"profiles, you may wish to power down the services:"
msgstr "在你完成了你的aiida任务后，尤其是当你想要切换到另一个配置档案，你可能希望关闭所有正在运行的服务。"

#: ../docs/source/intro/install_system.rst:5
msgid "System-wide installation"
msgstr "全系统安装"

#: ../docs/source/intro/install_system.rst:7
msgid ""
"The system-wide installation will install the prerequisite services "
"(PostgreSQL and RabbitMQ) via standard package managers such that their "
"startup and shut-down is largely managed by the operating system. The AiiDA "
"(core) Python package is then installed either with Conda or pip."
msgstr ""
"整个系统的安装将通过标准的包管理器安装必要的服务(PostgreSQL和RabbitMQ)，这样它们的启动和关闭主要由操作系统管理。AiiDA(核心)Python包然后由Conda或pip一起安装。"

#: ../docs/source/intro/install_system.rst:10
msgid ""
"This is the *recommended* installation method to setup AiiDA on a personal "
"laptop or workstation for the majority of users."
msgstr "对于大多数用户来说，这是*推荐的*在个人笔记本电脑或工作站上安装AiiDA的方法。"

#: ../docs/source/intro/install_system.rst:16
msgid "**Install prerequisite services**"
msgstr "**安装必备服务**"

#: ../docs/source/intro/install_system.rst:18
msgid ""
"AiiDA is designed to run on `Unix <https://en.wikipedia.org/wiki/Unix>`_ "
"operating systems and requires a `bash "
"<https://en.wikipedia.org/wiki/Bash_(Unix_shell)>`_ or `zsh "
"<https://en.wikipedia.org/wiki/Z_shell>`_ shell, and Python >= 3.7."
msgstr ""
"AiiDA被设计为在 `Unix `_ 操作系统上运行，需要 `bash`_ 或 `zsh`_ shell，以及Python >= 3.7。"

#: ../docs/source/intro/install_system.rst:0
msgid "Ubuntu"
msgstr "Ubuntu"

#: ../docs/source/intro/install_system.rst:22
msgid "*AiiDA is tested on Ubuntu versions 16.04, 18.04, and 20.04.*"
msgstr "*AiiDA已在Ubuntu 16.04、18.04和20.04版本上进行测试运行*"

#: ../docs/source/intro/install_system.rst:24
#: ../docs/source/intro/install_system.rst:38
#: ../docs/source/intro/install_system.rst:147
#: ../docs/source/intro/install_system.rst:194
#: ../docs/source/intro/install_system.rst:206
msgid "Open a terminal and execute:"
msgstr "打开一个终端并执行:"

#: ../docs/source/intro/install_system.rst:0
msgid "MacOS X (Homebrew)"
msgstr "MacOS X (Homebrew)"

#: ../docs/source/intro/install_system.rst:34
msgid ""
"The recommended installation method for Mac OS X is to use `Homebrew "
"<https://brew.sh>`__."
msgstr "Mac OS X推荐的安装方法是使用 `Homebrew `__。"

#: ../docs/source/intro/install_system.rst:36
msgid ""
"Follow `this guide <https://docs.brew.sh/Installation>`__ to install "
"Homebrew on your system if not installed yet."
msgstr "按照 `这个指南`__ 在您的系统上安装Homebrew，如果还没有安装。"

#: ../docs/source/intro/install_system.rst:0
msgid "Windows Subsystem for Linux"
msgstr "Windows上的Linux子系统"

#: ../docs/source/intro/install_system.rst:48
msgid ""
"*The following instructions are for setting up AiiDA on WSL 1/2 in "
"combination with Ubuntu.*"
msgstr "下面的说明是在WSL 1/2上结合Ubuntu设置AiiDA"

#: ../docs/source/intro/install_system.rst:50
msgid "Installing RabbitMQ:"
msgstr "RabbitMQ安装:"

#: ../docs/source/intro/install_system.rst:52
msgid ""
"(WSL 1) Install and start the `Windows native RabbitMQ "
"<https://www.rabbitmq.com/install-windows.html>`_."
msgstr "(WSL 1)安装并启动 `Windows 原生 RabbitMQ `_."

#: ../docs/source/intro/install_system.rst:54
msgid "(WSL 2) Install RabbitMQ inside the the WSL:"
msgstr "(WSL 2)在WSL内部安装RabbitMQ:"

#: ../docs/source/intro/install_system.rst:61
msgid "Install Python and PostgreSQL:"
msgstr "安装Python和PostgreSQL:"

#: ../docs/source/intro/install_system.rst:72
msgid ""
"Create a file ``start_aiida_services.sh`` containing the following lines:"
msgstr "创建 ``start_aiida_services.sh`` 文件，包含以下行:"

#: ../docs/source/intro/install_system.rst:79
msgid ""
"and store it in your preferred location, e.g., the home directory. Then make"
" the file executeable, and editable only by root users with:"
msgstr "并将其存储在您的首选位置，例如，主目录。然后设置文件为可执行，并仅root用户可编辑:"

#: ../docs/source/intro/install_system.rst:87
msgid "Next, run"
msgstr "接下来,运行"

#: ../docs/source/intro/install_system.rst:93
msgid "and add the line"
msgstr "并加入以下行："

#: ../docs/source/intro/install_system.rst:99
msgid ""
"replacing ``<username>`` with your Ubuntu username. This will allow you to "
"run *only* this specific ``.sh`` file with ``root`` access (without "
"password), without lowering security on the rest of your system."
msgstr ""
"将 ``<username>`` 替换为你的Ubuntu用户名。这使得仅有该 ``.sh`` 文件可以通过 ``root`` "
"权限（免密码）运行，且不会降低系统其余部分的安全性。"

#: ../docs/source/intro/install_system.rst:102
msgid ""
"Now you can use the Windows Task Scheduler to automatically execute this "
"file on startup:"
msgstr "现在你可以使用Windows任务调度程序在启动时自动执行这个文件:"

#: ../docs/source/intro/install_system.rst:104
msgid "Open Task Scheduler."
msgstr "打开任务管理器。"

#: ../docs/source/intro/install_system.rst:106
msgid "In the \"Actions\" menu, click \"Create Task\"."
msgstr "在“Actions”菜单中，点击“Create Task”。"

#: ../docs/source/intro/install_system.rst:108
msgid ""
"In \"General/Security options\", select \"Run whether user is logged on or "
"not\"."
msgstr "在“常规/安全选项”中，选择“无论用户是否登录都运行”。"

#: ../docs/source/intro/install_system.rst:110
msgid "In the \"Triggers\" tab, click \"New...\"."
msgstr "在“触发器”选项卡，点击“新建…”。"

#: ../docs/source/intro/install_system.rst:112
msgid "In the \"Begin the task:\" dropdown, select \"At startup\"."
msgstr "在“开始任务:”下拉框中，选择“在启动时”。"

#: ../docs/source/intro/install_system.rst:114
#: ../docs/source/intro/install_system.rst:124
msgid "Click \"OK\" to confirm."
msgstr "点击“OK”确认。"

#: ../docs/source/intro/install_system.rst:116
msgid "In the \"Actions\" tab, click \"New...\"."
msgstr "在“Actions”选项卡，点击“新建…”。"

#: ../docs/source/intro/install_system.rst:118
msgid "In the \"Action\" dropdown, select \"Start a program\"."
msgstr "在“动作”下拉菜单中，选择“启动程序”。"

#: ../docs/source/intro/install_system.rst:120
msgid "In the \"Program/script\" text field, add ``C:\\Windows\\System32\\bash.exe``."
msgstr "在 \"Program/script\" 编辑框, 键入 ``C:\\Windows\\System32\\bash.exe``."

#: ../docs/source/intro/install_system.rst:122
msgid ""
"In the \"Add arguments (optional)\" text field, add ``-c \"sudo "
"/path/to/start_aiida_services.sh\"``."
msgstr ""
"在 \"Add arguments (optional)\" 编辑框, 键入 ``-c \"sudo "
"/path/to/start_aiida_services.sh\"``."

#: ../docs/source/intro/install_system.rst:126
msgid "Click \"OK\" to confirm the task."
msgstr "点击“OK”确认任务。"

#: ../docs/source/intro/install_system.rst:128
msgid "You can tweak other details of this task to fit your needs."
msgstr "您可以调整此任务的其他细节以满足您的需要。"

#: ../docs/source/intro/install_system.rst:0
msgid "Other"
msgstr "其他"

#: ../docs/source/intro/install_system.rst:132
msgid ""
"Install RabbitMQ following the `instructions applicable to your system "
"<https://www.rabbitmq.com/download.html>`__."
msgstr "按照 `rabbitmq适用于您的系统的说明 `__ 来安装RabbitMQ。"

#: ../docs/source/intro/install_system.rst:133
msgid ""
"Install PostgreSQL following the `instructions applicable to your system "
"<https://www.postgresql.org/download/>`__."
msgstr "按照 `postgresql适用于您的系统的说明 `__ 安装PostgreSQL。"

#: ../docs/source/intro/install_system.rst:137
msgid ""
"Alternatively use the :ref:`pure conda installation method "
"<intro:get_started:conda-install>`."
msgstr "或者使用 :ref:`纯conda安装方法 <intro:get_started:conda-install>`."

#: ../docs/source/intro/install_system.rst:141
msgid "**Install AiiDA (core)**"
msgstr "**安装AiiDA(核心组件)**"

#: ../docs/source/intro/install_system.rst:0
msgid "pip + venv"
msgstr "pip + venv"

#: ../docs/source/intro/install_system.rst:145
msgid "*Install the aiida-core package from PyPI into a virtual environment.*"
msgstr "*从PyPI安装aida -core包到虚拟环境.*"

#: ../docs/source/intro/install_system.rst:158
msgid ""
"See the `venv documentation <https://docs.python.org/3/library/venv.html>`__"
" if the activation command fails. The exact command for activating a virtual"
" environment differs slightly based on the used shell."
msgstr "如果激活命令失败，请参阅 `venv 手册 `__ 。根据所使用的shell，激活虚拟环境的确切命令略有不同。"

#: ../docs/source/intro/install_system.rst:163
msgid ""
"There are additional optional packages that you may want to install, which "
"are grouped in the following categories:"
msgstr "你可能还会考虑安装额外的可选软件包，他们被归类在以下的类别中："

#: ../docs/source/intro/install_system.rst:165
msgid ""
"``atomic_tools``: packages that allow importing and manipulating crystal "
"structure from various formats"
msgstr "``atomic_tools`` ： 读取和修改不同格式晶体构型文件的软件包"

#: ../docs/source/intro/install_system.rst:166
msgid ""
"``ssh_kerberos``: adds support for ssh transport authentication through "
"Kerberos"
msgstr "``ssh_kerberos``: 增加了通过Kerberos对ssh传输进行认证的软件包"

#: ../docs/source/intro/install_system.rst:167
msgid "``REST``: allows a REST server to be ran locally to serve AiiDA data"
msgstr "``REST``: 支持在本地运行REST服务器以显示AiiDA数据"

#: ../docs/source/intro/install_system.rst:168
msgid "``docs``: tools to build the documentation"
msgstr "``docs``: 用来编译文档的工具"

#: ../docs/source/intro/install_system.rst:169
msgid "``notebook``: jupyter notebook - to allow it to import AiiDA modules"
msgstr "``notebook``: jupyter notebook 方便在jupyter中加载AiiDA模块"

#: ../docs/source/intro/install_system.rst:170
msgid "``tests``: python modules required to run the automatic unit tests"
msgstr "``tests``: 用以执行单元测试的软件包组"

#: ../docs/source/intro/install_system.rst:171
msgid ""
"``pre-commit``: pre-commit tools required for developers to enable automatic"
" code linting and formatting"
msgstr "``pre-commit``: pre-commit 向开发者提供了自动规范和检查代码格式的工具。"

#: ../docs/source/intro/install_system.rst:173
msgid ""
"In order to install any of these package groups, simply append them as a "
"comma separated list in the ``pip`` install command, for example:"
msgstr "为了安装这些包组，只需在 ``pip`` 安装命令中添加一个逗号分隔的列表，例如:"

#: ../docs/source/intro/install_system.rst:181
msgid ""
"If you are installing the optional ``ssh_kerberos`` and you are on Ubuntu "
"you might encounter an error related to the ``gss`` package. To fix this you"
" need to install the ``libffi-dev`` and ``libkrb5-dev`` packages:"
msgstr ""
"如果Ubuntu中已安装了 ``ssh_kerberos`` ，则有可能会有 ``gss`` 包相关的错误。可通过安装 ``libffi-dev`` 与"
" ``libkrb5-dev`` 来解决错误 ："

#: ../docs/source/intro/install_system.rst:0
msgid "Conda"
msgstr "Conda"

#: ../docs/source/intro/install_system.rst:190
msgid "*Install the aiida-core package in a Conda environment.*"
msgstr "*安装aida -core包到Conda虚拟环境.*"

#: ../docs/source/intro/install_system.rst:192
msgid ""
"Make sure that conda is installed, e.g., by following `the instructions on "
"installing Miniconda <https://docs.conda.io/en/latest/miniconda.html>`__."
msgstr "确保安装了conda，例如，按照  `安装Miniconda手册中的方法 `__ . "

#: ../docs/source/intro/install_system.rst:0
msgid "From source"
msgstr "从源代码"

#: ../docs/source/intro/install_system.rst:204
msgid "*Install the aiida-core package directly from the cloned repository.*"
msgstr "*直接从克隆的存储库安装aida -core包.*"

#: ../docs/source/intro/install_system.rst:241
msgid "**Start verdi daemons**"
msgstr "**启动verdi守护进程**"

#: ../docs/source/intro/install_system.rst:243
msgid "Start the verdi daemon(s) that are used to run AiiDA workflows."
msgstr "启动用于运行AiiDA工作流的verdi守护进程。"

#: ../docs/source/intro/install_system.rst:273
msgid ""
"At this point you should now have a working AiiDA environment, from which "
"you can add and retrieve data."
msgstr "现在，你就拥有了一个可使用的AiIDA环境了，你可以向其中增加或提取数据。"

#: ../docs/source/intro/installation.rst:6
msgid "Advanced configuration"
msgstr "高级配置"

#: ../docs/source/intro/installation.rst:8
msgid ""
"This chapter covers topics that go beyond the :ref:`standard setup of AiiDA "
"<intro:get_started:setup>`. If you are new to AiiDA, we recommend you first "
"go through the :ref:`Basic Tutorial <tutorial:basic>`, or see our :ref:`Next"
" steps guide <tutorial:next-steps>`."
msgstr ""
"本章涉及的主题超出了:ref:`AiiDA的标准设置<intro:get_started:setup>`。如果你是AiiDA的新手，我们建议你先看一下 "
":ref:`基础教程<tutorial:basic>`，或者看看我们的 :ref:`下一步指南 <tutorial:next-steps>`。"

#: ../docs/source/intro/installation.rst:15
msgid "Creating the database"
msgstr "创建数据库"

#: ../docs/source/intro/installation.rst:17
msgid ""
"AiiDA uses a database to store the nodes, node attributes and other "
"information, allowing the end user to perform fast queries of the results. "
"Currently, the highly performant `PostgreSQL`_ database is supported as a "
"database backend."
msgstr ""
"AiiDA 使用一个关系型数据库来保存数据节点，节点属性以及其他信息， 以方便使用者实现对结果数据的快速查询。当前仅支持 `PostgreSQL`_ "
"作为后端数据库系统。"

#: ../docs/source/intro/installation.rst:22
msgid "Find out more about the database"
msgstr "有关数据库的更多内容请看"

#: ../docs/source/intro/installation.rst:27
msgid ":ref:`The database topic <topics:database>`."
msgstr ":ref:`数据库 <topics:database>`."

#: ../docs/source/intro/installation.rst:29
msgid ""
"To manually create the database for AiiDA, you need to run the program "
"``psql`` to interact with postgres. On most operating systems, you need to "
"do so as the ``postgres`` user that was created upon installing the "
"software. To assume the role of ``postgres`` run as root:"
msgstr ""
"要手动为 AiiDA创建数据库， 你需要使用命令 ``psql`` 与postgres 进行交互。 在多数系统中， 你需要以 ``postgres`` "
"用户身份来完成交互。 通过root权限来进入 ``postgres`` 用户："

#: ../docs/source/intro/installation.rst:37
msgid ""
"(or, equivalently, type ``sudo su - postgres``, depending on your "
"distribution) and launch the postgres program:"
msgstr "（或者同样地，也可以输入 ``sudo su - postgres`` ，这取决于你使用的发行版）并启动postgres程序："

#: ../docs/source/intro/installation.rst:43
msgid "Create a new database user account for AiiDA by running:"
msgstr "运行以下命令为AiiDA创建一个新的postgreSQL用户："

#: ../docs/source/intro/installation.rst:49
msgid "replacing ``<password>`` with a password of your choice."
msgstr "将 ``<password>`` 替换为你设置的密码。"

#: ../docs/source/intro/installation.rst:51
msgid ""
"You will need to provide the password again when you configure AiiDA to use "
"this database through ``verdi setup``. If you want to change the password "
"you just created use the command:"
msgstr "千万别忘记密码，因为之后在运行配置命令 ``verdi setup`` 时你会用到该密码。 如果你要修改刚刚设置的密码，运行："

#: ../docs/source/intro/installation.rst:58
msgid ""
"Next, we create the database itself. We enforce the UTF-8 encoding and "
"specific locales:"
msgstr "接下来，我们创建一个数据库。我们限定使用UTF-8作为编码及其特定的语言环境："

#: ../docs/source/intro/installation.rst:64
msgid ""
"and grant all privileges on this DB to the previously-created ``aiida`` "
"user:"
msgstr "并且将该数据库的所有权限赋予刚刚创建的 ``aiida`` 用户："

#: ../docs/source/intro/installation.rst:70
msgid ""
"You have now created a database for AiiDA and you can close the postgres "
"shell by typing ``\\q``. To test if the database was created successfully, "
"you can run the following command as a regular user in a bash terminal:"
msgstr ""
"现在，你已经成功创建了AiiDA数据库，可以输入 ``\\q`` 退出postgres shell。 为测试数据库是否成功创建， "
"你可以在bash终端中以普通用户运行以下命令："

#: ../docs/source/intro/installation.rst:77
msgid ""
"and type the password you inserted before, when prompted. If everything "
"worked well, you should get no error and see the prompt of the ``psql`` "
"shell."
msgstr "当提示输入密码时，键入你设置的密码。如果所有数据库工作正常，你将不会看到错误输出并会看到 ``psql`` shell 命令行提示符。"

#: ../docs/source/intro/installation.rst:80
msgid ""
"If you use the same names as in the example commands above, then during the "
"``verdi setup`` phase the following parameters will apply to the newly "
"created database:"
msgstr "如果你使用了和示例中相同的用户名，,在使用 ``verdi setup`` 时你会用到下列参数来使用你创建的数据库："

#: ../docs/source/intro/installation.rst:91
msgid "Don't forget to backup your database!"
msgstr "说认真的，请不要忘了备份你的数据！"

#: ../docs/source/intro/installation.rst:94
msgid ""
"See the :ref:`Database backup how-to <how-"
"to:installation:backup:postgresql>`), and :ref:`how to move your database "
"<how-to:installation:performance>`."
msgstr ""
"参考 :ref:`如何备份数据库 <how-to:installation:backup:postgresql>` ）以及 "
":ref:`如何迁移你的数据库 <how-to:installation:performance>` 。"

#: ../docs/source/intro/installation.rst:97
msgid "Database setup using 'peer' authentication"
msgstr "使用用户对认证设置数据库"

#: ../docs/source/intro/installation.rst:99
msgid ""
"On Ubuntu Linux, the default PostgreSQL setup is configured to use ``peer`` "
"authentication, which allows password-less login via local Unix sockets. In "
"this mode, PostgreSQL compares the Unix user connecting to the socket with "
"its own database of users and allows a connection if a matching user exists."
msgstr ""
"在Ubuntu Linux系统中，默认的PostgreSQL设置使用了 ``peer`` "
"（用户对）认证，使得本地的Unix连接可以不需要密码。在这种情形下，PostgreSQL会对比数据库中的用户和当前的Unix用户，如果该用户在数据库中存在，则允许连接。"

#: ../docs/source/intro/installation.rst:104
msgid ""
"This is an alternative route to set up your database - the standard approach"
" will work on Ubuntu just as well."
msgstr "这是一个设置数据库的替代方式，标准的步骤在Ubuntu中同样也能正常使用。"

#: ../docs/source/intro/installation.rst:106
msgid ""
"Below we are going to take advantage of the command-line utilities shipped "
"on Ubuntu to simplify creating users and databases compared to issuing the "
"SQL commands directly."
msgstr "下面，我们使用Ubuntu提供的命令行工具来简单快速地创建用户和数据库，而不是直接用到SQL语句来完成用户和数据库的创建。"

#: ../docs/source/intro/installation.rst:108
msgid "Assume the role of ``postgres``:"
msgstr "进入 ``postgres`` 用户 ："

#: ../docs/source/intro/installation.rst:114
msgid ""
"Create a database user with the **same name** as the UNIX user who will be "
"running AiiDA (usually your login name):"
msgstr "创建一个与将要运行AiiDA的UNIX用户同名的数据库用户(通常是你的登录名):"

#: ../docs/source/intro/installation.rst:120
msgid "replacing ``<username>`` with your username."
msgstr "替换 ``<username>`` 为你的用户名。"

#: ../docs/source/intro/installation.rst:122
msgid "Next, create the database itself with your user as the owner:"
msgstr "然后创建数据库，并确保你的用户是该数据库的所有者 ::"

#: ../docs/source/intro/installation.rst:128
msgid ""
"Exit the shell to go back to your login user. To test if the database was "
"created successfully, try:"
msgstr "退出shell并回到你的登陆用户。并用下列命令尝试数据库是否成功创建："

#: ../docs/source/intro/installation.rst:135
msgid ""
"During the ``verdi setup`` phase, use ``!`` to leave host empty and specify "
"your Unix user name as the *AiiDA Database user*.:"
msgstr ""
"During the在使用 ``verdi setup``设置配置档案时，使用 ``!`` 将主机host名设置为空并将你的Unix用户作为 "
"*AiiDA 数据库用户*："

#: ../docs/source/intro/installation.rst:148
msgid "RabbitMQ configuration"
msgstr "RabbitMQ配置"

#: ../docs/source/intro/installation.rst:150
msgid ""
"In most normal setups, RabbitMQ will be installed and run as a service on "
"the same machine that hosts AiiDA itself. In that case, using the default "
"configuration proposed during a profile setup will work just fine. However, "
"when the installation of RabbitMQ is not standard, for example it runs on a "
"different port, or even runs on a completely different machine, all relevant"
" connection details can be configured with ``verdi setup``."
msgstr ""
"在大多数正常的设置中，RabbitMQ将作为服务安装和托管在运行AiiDA的同一台机器上。在这种情况下，在配置文件设置期间使用建议的默认配置就可以了。但是，如果RabbitMQ的安装不是标准的，比如它运行在不同的端口上，甚至是完全不同的机器上，所有相关的连接细节都需要通过"
" ``verdi setup`` 来配置。"

#: ../docs/source/intro/installation.rst:154
msgid "The following parameters can be configured:"
msgstr "可配置以下参数:"

#: ../docs/source/intro/installation.rst:157
msgid "Parameter"
msgstr "参数"

#: ../docs/source/intro/installation.rst:157
msgid "Option"
msgstr "选项"

#: ../docs/source/intro/installation.rst:157
msgid "Default"
msgstr "默认值"

#: ../docs/source/intro/installation.rst:157
msgid "Explanation"
msgstr "释义"

#: ../docs/source/intro/installation.rst:159
msgid "Protocol"
msgstr "协议"

#: ../docs/source/intro/installation.rst:159
msgid "``--broker-protocol``"
msgstr "``--broker-protocol``"

#: ../docs/source/intro/installation.rst:159
msgid "``amqp``"
msgstr "``amqp``"

#: ../docs/source/intro/installation.rst:159
msgid ""
"The protocol to use, can be either ``amqp`` or ``amqps`` for SSL enabled "
"connections."
msgstr ""

#: ../docs/source/intro/installation.rst:161
msgid "Username"
msgstr ""

#: ../docs/source/intro/installation.rst:161
msgid "``--broker-username``"
msgstr "``--broker-username``"

#: ../docs/source/intro/installation.rst:161
#: ../docs/source/intro/installation.rst:163
msgid "``guest``"
msgstr "``guest``"

#: ../docs/source/intro/installation.rst:161
msgid ""
"The username with which to connect. The ``guest`` account is available and "
"usable with a default RabbitMQ installation."
msgstr ""

#: ../docs/source/intro/installation.rst:163
msgid "Password"
msgstr ""

#: ../docs/source/intro/installation.rst:163
msgid "``--broker-password``"
msgstr "``--broker-password``"

#: ../docs/source/intro/installation.rst:163
msgid ""
"The password with which to connect. The ``guest`` account is available and "
"usable with a default RabbitMQ installation."
msgstr ""

#: ../docs/source/intro/installation.rst:165
msgid "Host"
msgstr ""

#: ../docs/source/intro/installation.rst:165
msgid "``--broker-host``"
msgstr "``--broker-host``"

#: ../docs/source/intro/installation.rst:165
msgid "``127.0.0.1``"
msgstr "``127.0.0.1``"

#: ../docs/source/intro/installation.rst:165
msgid "The hostname of the RabbitMQ server."
msgstr ""

#: ../docs/source/intro/installation.rst:167
msgid "Port"
msgstr ""

#: ../docs/source/intro/installation.rst:167
msgid "``--broker-port``"
msgstr "``--broker-port``"

#: ../docs/source/intro/installation.rst:167
msgid "``5672``"
msgstr "``5672``"

#: ../docs/source/intro/installation.rst:167
msgid "The port to which the server listens."
msgstr ""

#: ../docs/source/intro/installation.rst:169
msgid "Virtual host"
msgstr ""

#: ../docs/source/intro/installation.rst:169
msgid "``--broker-virtual-host``"
msgstr "``--broker-virtual-host``"

#: ../docs/source/intro/installation.rst:169
msgid "``''``"
msgstr "``''``"

#: ../docs/source/intro/installation.rst:169
msgid ""
"Optional virtual host. Should not contain the leading forward slash, this "
"will be added automatically by AiiDA."
msgstr "可选的虚拟主机。不应该包含前置斜杠，这将由AiiDA自动添加。"

#: ../docs/source/intro/installation.rst:171
msgid "Parameters"
msgstr ""

#: ../docs/source/intro/installation.rst:171
msgid "not available"
msgstr ""

#: ../docs/source/intro/installation.rst:171
msgid "n.a."
msgstr "n.a."

#: ../docs/source/intro/installation.rst:171
msgid ""
"These are additional broker parameters that are typically encoded as URL "
"parameters, for example, to specify SSL parameters such as the filepath to "
"the certificate that is to be used. The parameters are currently not "
"definable through the CLI but have to be added manually in the "
"``config.json``. A key ``broker_parameters`` should be added that is a "
"dictionary, which can contain fields: ``cafile``, ``capath``, ``cadata``, "
"``certfile``, ``keyfile`` and ``no_verify_ssl``."
msgstr ""
"这些是附加的代理参数，通常被编码为URL参数，例如，用于指定SSL参数，例如要使用的证书的文件路径。参数目前不能通过CLI定义，但必须手动添加在 "
"``config.json`` 。需要添加 ``broker_parameters`` 的对象，它是一个字典，可以包含字段 ``cafile``， "
"``capath``， ``cadata``， ``certfile``， ``keyfile``和 ``no_verify_ssl``。"

#: ../docs/source/intro/installation.rst:182
msgid "verdi setup"
msgstr "verdi setup"

#: ../docs/source/intro/installation.rst:184
msgid "After the database has been created, do:"
msgstr "在数据库成功创建后，"

#: ../docs/source/intro/installation.rst:190
msgid ""
"where `<profile_name>` is a profile name of your choosing. The ``verdi "
"setup`` command will guide you through the setup process through a series of"
" prompts."
msgstr ""
"其中 `<profile_name>` 是你选择配置文件的名称。 命令 ``verdi setup`` 会通过提示的方式指导你完成之后的配置步骤。"

#: ../docs/source/intro/installation.rst:193
msgid ""
"The first information asked is your email, which will be used to associate "
"the calculations to you. In AiiDA, the email is your username, and acts as a"
" unique identifier when importing/exporting data from AiiDA."
msgstr "首先需要提供你的邮箱，邮箱会被用于关联你的算例。在AiiDA中，邮箱是你的用户名，并且作为你从AiiDA导入和导出数据使得唯一性标识。"

#: ../docs/source/intro/installation.rst:198
msgid ""
"The password, in the current version of AiiDA, is not used (it will be used "
"only in the REST API and in the web interface). If you leave the field "
"empty, no password will be set and no access will be granted to the user via"
" the REST API and the web interface."
msgstr ""
"密码，在当前版本的AiiDA中不被使用（会在REST API和网页接口中使用）。如果你将该区域设置为空，则密码不被设置，那么用户将不会被赋予访问REST"
" API和网页接口的权限。"

#: ../docs/source/intro/installation.rst:201
msgid ""
"Then, the following prompts will help you configure the database. Typical "
"settings are:"
msgstr "之后的提示符会指引你配置数据库，典型的设置有 ："

#: ../docs/source/intro/installation.rst:222
msgid "Don't forget to backup your data!"
msgstr "说认真的，请不要忘了备份你的数据！"

#: ../docs/source/intro/installation.rst:225
msgid ""
"See the :ref:`installation backup how-to <how-to:installation:backup>`."
msgstr "参考 :ref:`如何安装并备份 <how-to:installation:backup>`."

#: ../docs/source/intro/installation.rst:230
msgid "Managing the daemon"
msgstr "管理守护进程"

#: ../docs/source/intro/installation.rst:232
msgid ""
"The AiiDA daemon process runs in the background and takes care of processing"
" your submitted calculations and workflows, checking their status, "
"retrieving their results once they are finished and storing them in the "
"AiiDA database."
msgstr "AiiDA的守护进程在后台运行，并守护你你所提交的计算算例和工作流，检查他们的状态，并当其结束后回收他们的结果储存入AiiDA数据库中。"

#: ../docs/source/intro/installation.rst:234
msgid "The AiiDA daemon is controlled using three simple commands:"
msgstr "AiiDA的守护进程使用下列三个命令控制 ："

#: ../docs/source/intro/installation.rst:236
msgid "``verdi daemon start``: start the daemon"
msgstr "``verdi daemon start``: 开启守护进程"

#: ../docs/source/intro/installation.rst:237
msgid "``verdi daemon status``: check the status of the daemon"
msgstr "``verdi daemon status``: 查看守护进程当前状态"

#: ../docs/source/intro/installation.rst:238
msgid "``verdi daemon stop``: stop the daemon"
msgstr "``verdi daemon stop``: 停止守护进程"

#: ../docs/source/intro/installation.rst:242
msgid ""
"While operational, the daemon logs its activity to a file in "
"``~/.aiida/daemon/log/`` (or, more generally, "
"``$AIIDA_PATH/.aiida/daemon/log``). Get the latest log messages via ``verdi "
"daemon logshow``."
msgstr ""
"当进程运行时，日志文件会被写入文件 ``~/.aiida/daemon/log/`` (更确切的说，是 "
"``$AIIDA_PATH/.aiida/daemon/log``)。使用命令 ``verdi daemon logshow`` 查看最新的日志。`"

#: ../docs/source/intro/installation.rst:248
msgid "Using AiiDA in Jupyter"
msgstr "在Jupyter中使用AiiDA"

#: ../docs/source/intro/installation.rst:250
msgid ""
"Install the AiiDA ``notebook`` extra **inside** the AiiDA python "
"environment, e.g. by running ``pip install aiida-core[notebook]``."
msgstr ""
"在AiiDA python环境中安装AiiDA ``notebook`` 附加依赖包 ，例如运行 ``pip Install aiida-"
"core[notebook]`` 。"

#: ../docs/source/intro/installation.rst:252
msgid ""
"(optional) Register the ``%aiida`` IPython magic for loading the same "
"environment as in the ``verdi shell``:"
msgstr "(可选)注册 ``%aiida`` IPython magic以加载与 ``verdi shell``相同的环境:"

#: ../docs/source/intro/installation.rst:254
msgid ""
"Copy the following code snippet into "
"``<home_folder>/.ipython/profile_default/startup/aiida_magic_register.py``"
msgstr ""
"复制以下代码片段到 "
"``<home_folder>/.ipython/profile_default/startup/aiida_magic_register.py``"

#: ../docs/source/intro/installation.rst:259
msgid ""
"Use ``ipython locate profile`` if you're unsure about the location of your "
"ipython profile folder."
msgstr "如果不确定ipython配置文件文件夹的位置，请使用 ``ipython locate profile`` 。"

#: ../docs/source/intro/installation.rst:262
msgid "With this setup, you're ready to use AiiDA in Jupyter notebeooks."
msgstr "有了这个设置，您就可以在Jupyter记事本中使用AiiDA了。"

#: ../docs/source/intro/installation.rst:264
msgid "Start a Jupyter notebook server:"
msgstr "启动jupiter笔记本服务器:"

#: ../docs/source/intro/installation.rst:270
msgid "This will open a tab in your browser. Click on ``New -> Python``."
msgstr "这会在你的浏览器中打开一个标签页。点击 ``新建（New） -> Python`` ."

#: ../docs/source/intro/installation.rst:272
msgid "If you registered the ``%aiida`` IPython magic, simply run:"
msgstr "如果你注册了``%aiida`` IPython magic，只需运行:"

#: ../docs/source/intro/installation.rst:278
msgid ""
"After executing the cell by ``Shift-Enter``, you should receive the message "
"\"Loaded AiiDA DB environment.\" Otherwise, you can load the profile "
"manually as you would in a Python script:"
msgstr ""
"通过 ``Shift-Enter`` 执行单元格后，您应该会看到“Loaded AiiDA DB "
"environment”的消息。否则，你可以像在Python脚本中那样手动加载配置文件:"

#: ../docs/source/intro/run_docker.rst:6
msgid "Run AiiDA via a Docker image"
msgstr "通过Docker映像运行AiiDA"

#: ../docs/source/intro/run_docker.rst:8
msgid ""
"The AiiDA team maintains a `Docker <https://www.docker.com/>`__ image on "
"`Docker Hub <https://hub.docker.com/r/aiidateam/aiida-core>`__. This image "
"contains a fully pre-configured AiiDA environment which makes it "
"particularly useful for learning and testing purposes."
msgstr ""
"AiiDA团队在 ``Docker "
"Hub``__上维护一个``Docker``__镜像。此镜像包含一个完全预配置的AiiDA环境，这对于学习和测试特别有用。"

#: ../docs/source/intro/run_docker.rst:13
msgid ""
"All data stored in a container will persist only over the lifetime of that "
"particular container unless you use volumes (see instructions below)."
msgstr "容器中存储的所有数据只会在特定容器的生命周期内保存，除非使用卷(参见下面的说明)。"

#: ../docs/source/intro/run_docker.rst:19
msgid "**Start container**"
msgstr "**开始容器**"

#: ../docs/source/intro/run_docker.rst:21
msgid "First, pull the image:"
msgstr "首先，下载镜像:"

#: ../docs/source/intro/run_docker.rst:27
msgid "Then start the container with:"
msgstr "然后用以下命令启动容器:"

#: ../docs/source/intro/run_docker.rst:33
msgid ""
"You can use the following command to block until all services have started "
"up:"
msgstr "您可以使用以下命令来阻止，直到所有服务都启动:"

#: ../docs/source/intro/run_docker.rst:43
msgid ""
"The default profile is created under the ``aiida`` user, so to execute "
"commands you must add the ``--user aiida`` option."
msgstr "默认配置文件是在 ``aiida`` 用户下创建的，所以要执行命令，你必须添加``--user aiida``选项。"

#: ../docs/source/intro/run_docker.rst:45
msgid "For example, to check the verdi status, execute:"
msgstr "例如，要检查verdi状态，执行:"

#: ../docs/source/intro/run_docker.rst:59
msgid "**Use container interactively**"
msgstr "**交互使用容器**"

#: ../docs/source/intro/run_docker.rst:61
msgid "To \"enter\" the container and run commands directly in the shell, use:"
msgstr "要“进入”容器并在shell中直接运行命令，请使用:"

#: ../docs/source/intro/run_docker.rst:67
msgid ""
"This will drop you into the shell within the container as the user "
"\"aiida\"."
msgstr "这将使您作为用户“aiida”进入容器内的shell。"

#: ../docs/source/intro/run_docker.rst:71
msgid "**Persist data across different containers**"
msgstr "**跨容器数据持久化**"

#: ../docs/source/intro/run_docker.rst:73
msgid ""
"If you stop the container and start it again, any data you created will "
"persist."
msgstr "即使你停止了容器的运行或重新启动了容器，之前创建的数据也不会丢失。"

#: ../docs/source/intro/run_docker.rst:80
msgid ""
"However, if you remove the container, **all data will be removed as well**."
msgstr "但如果你移除了容器，那么所有数据也会被移除。"

#: ../docs/source/intro/run_docker.rst:87
msgid ""
"The preferred way to persistently store data is to `create a volume "
"<https://docs.docker.com/storage/volumes/>`__. To create a simple volume, "
"run:"
msgstr "持久存储数据的首选方法是`创建卷`__。要创建一个简单的卷，运行命令:"

#: ../docs/source/intro/run_docker.rst:94
msgid "Then make sure to mount that volume when running the aiida container:"
msgstr "然后确保在运行aiida容器时挂载该卷:"

#: ../docs/source/intro/run_docker.rst:100
msgid ""
"Starting the container with the above command, ensures that any data stored "
"in the ``/tmp/my_data`` path within the container is stored in the ``my-"
"data`` volume and therefore persists even if the container is removed."
msgstr ""
"使用上面的命令启动容器，确保容器内``/tmp/my_data``路径中存储的任何数据都存储在``my-data`` "
"卷中，因此即使容器被删除，数据也会保存。"

#: ../docs/source/intro/troubleshooting.rst:5
msgid "Troubleshooting"
msgstr "故障排除"

#: ../docs/source/intro/troubleshooting.rst:7
msgid ""
"If you experience any problems, first check that all services are up and "
"running:"
msgstr "如果你遇到了任何问题，首先检查所有的服务都已经开启并运行 :"

#: ../docs/source/intro/troubleshooting.rst:19
msgid ""
"In the example output, all service have a green check mark and so should be "
"running as expected. If all services are up and running and you are still "
"experiencing problems or if you have trouble with the installation of aiida-"
"core and related services, consider the commonly encountered problems below."
msgstr ""
"在输出实例中，所有服务都是绿色的，因此能够入预期的运行。如果所有服务都开启并运行，但你还是遇到问题，或在安装aiida-"
"core和相关服务的过程中喷到问题，考虑是否是以下常见问题。"

#: ../docs/source/intro/troubleshooting.rst:25
msgid "Installation issues"
msgstr "安装时可能出现的问题"

#: ../docs/source/intro/troubleshooting.rst:28
msgid "numpy dependency"
msgstr "numpy依赖"

#: ../docs/source/intro/troubleshooting.rst:30
msgid ""
"On a clean Ubuntu 16.04 install the pip install command ``pip install -e "
"aiida-core`` may fail due to a problem with dependencies on the ``numpy`` "
"package. In this case you may be presented with a message like the "
"following:"
msgstr ""
"在纯净版的 Ubuntu 16.04 系统中，用pip运行 ``pip install -e aiida_core`` 可能会遇到对 ``numpy``"
" 的依赖问题，而使安装失败。遇到这种情况，会有如下报错信息 ："

#: ../docs/source/intro/troubleshooting.rst:38
msgid ""
"To fix this, simply install ``numpy`` individually through pip in your "
"virtual env, i.e.:"
msgstr "只需要单独在虚拟环境中使用pip安装 ``numpy`` 包即可 ："

#: ../docs/source/intro/troubleshooting.rst:44
msgid "followed by executing the original install command once more:"
msgstr "然后再次执行原来的安装指令 ："

#: ../docs/source/intro/troubleshooting.rst:50
msgid "This should fix the dependency error."
msgstr "这就可以修复该依赖错误。"

#: ../docs/source/intro/troubleshooting.rst:53
msgid "Database installation and location"
msgstr "数据库的安装及其位置"

#: ../docs/source/intro/troubleshooting.rst:55
msgid ""
"If the installation fails while installing the packages related to the "
"database, you may have not installed or set up the database libraries."
msgstr "如果安装过程出错的是由于数据库导致的，你可能没有安装或正确设置数据库。"

#: ../docs/source/intro/troubleshooting.rst:57
msgid ""
"In particular, on Mac OS X, if you installed the binary package of "
"PostgreSQL, it is possible that the PATH environment variable is not set "
"correctly, and you get a \"Error: pg_config executable not found.\" error. "
"In this case, discover where the binary is located, then add a line to your "
"``~/.bashrc`` file similar to the following:"
msgstr ""
"尤其在Mac OS X中，如果你安装了二进制的PostgreSQL包，那么及有可能环境变量PATH的设置不是预期的，你会得到这样一个错误 "
"\"Error: pg_config executable not found.\" 。遇见该情况，寻找正确的二进制文件的位置，然后将该路径加入 "
"``~/.bashrc`` 中，如下 ："

#: ../docs/source/intro/troubleshooting.rst:64
msgid ""
"and then open a new bash shell. Some possible paths can be found at this "
"`Stackoverflow link`_ and a non-exhaustive list of possible paths is the "
"following (version number may change):"
msgstr ""
"之后打开一个新的bash shell。 可能的路径可以在 `Stackoverflow link`_ 中找到，或如下列表中（版本号可能不同）:"

#: ../docs/source/intro/troubleshooting.rst:67
msgid "``/Applications/Postgres93.app/Contents/MacOS/bin``"
msgstr "``/Applications/Postgres93.app/Contents/MacOS/bin``"

#: ../docs/source/intro/troubleshooting.rst:68
msgid "``/Applications/Postgres.app/Contents/Versions/9.3/bin``"
msgstr "``/Applications/Postgres.app/Contents/Versions/9.3/bin``"

#: ../docs/source/intro/troubleshooting.rst:69
msgid "``/Library/PostgreSQL/9.3/bin/pg_config``"
msgstr "``/Library/PostgreSQL/9.3/bin/pg_config``"

#: ../docs/source/intro/troubleshooting.rst:71
msgid ""
"Similarly, if the package installs but then errors occur during the first of"
" AiiDA (with ``Symbol not found`` errors or similar), you may need to point "
"to the path where the dynamical libraries are. A way to do it is to add a "
"line similar to the following to the ``~/.bashrc`` and then open a new "
"shell:"
msgstr ""
"同样的，如果软件包已经安装，但是在AiiDA开始运行的过程中出现 (如 ``Symbol not found`` "
"或类似的错误)，你可能需要指定动态库安装的位置。其中一个方法是在 ``~/.bashrc`` 中增加如下一行并打开一个新的shell ："

#: ../docs/source/intro/troubleshooting.rst:78
msgid "(you should of course adapt the path to the PostgreSQL libraries)."
msgstr "（你必须将路径加入PostgreSQL库中）"

#: ../docs/source/intro/troubleshooting.rst:86
msgid "Autodetection of the PostgreSQL setup"
msgstr "自动检测PostgreSQL设置"

#: ../docs/source/intro/troubleshooting.rst:88
msgid ""
"Sometimes AiiDA fails to autodetect the local configuration of PostgreSQL "
"when running ``verdi quicksetup``. In that case try to:"
msgstr "有时AiiDA在运行``verdi quicksetup``时无法自动检测PostgreSQL的本地配置。在这种情况下，尝试:"

#: ../docs/source/intro/troubleshooting.rst:91
msgid ""
"Create the database manually in PostgreSQL (see "
":ref:`here<intro:install:database>`)."
msgstr "在PostgreSQL中手动创建数据库(见:ref:`这里<intro:install:database>`)。"

#: ../docs/source/intro/troubleshooting.rst:92
msgid ""
"Then run the full ``verdi setup`` command (see "
":ref:`here<intro:install:verdi_setup>`)."
msgstr "然后运行完整的 ``verdi setup`` 命令(参见:ref:`这里<intro:install:verdi_setup>`)。"

#: ../docs/source/intro/troubleshooting.rst:96
msgid "RabbitMQ Installation (Unix)"
msgstr "RabbitMQ 的安装(Unix)"

#: ../docs/source/intro/troubleshooting.rst:98
msgid ""
"If in ``verdi status`` RabbitMQ is not connected, first check that RabbitMQ "
"is actually running:"
msgstr "如果你看到 ``verdi status`` 的输出显示RabbitMQ 没有正确连接，首先检查确定 RabbitMQ 已经正确运行："

#: ../docs/source/intro/troubleshooting.rst:108
msgid ""
"By default, AiiDA profiles are configured to connect to RabbitMQ *via* "
"``amqp://guest:guest@127.0.0.1:5672``, hence this port should be open for "
"connections. In Linux / Mac OSX you can also check which ports a PID has "
"open using:"
msgstr ""
"默认的AiiDA配置档案将通过 ``amqp://guest:guest@127.0.0.1:5672`` "
"连接RabbitMQ，因此该网络端口需要开启。在Linux / Mac OSX 你可以用以下命令查看PID使用的端口："

#: ../docs/source/intro/troubleshooting.rst:120
msgid ""
"If a connection cannot be found, try starting ``rabbitmq-server`` in non-"
"detached mode. If you encounter an output similar to that below, it may be "
"that your versions of RabbitMQ and erlang (the programming language which "
"RabbitMQ is written in) are incompatible."
msgstr ""
"如果连接没有被找到，尝试不退出地启动 ``rabbitmq-server``。 "
"如果你遇见如下输出，那么可能时由于你的RabbitMQ版本和erlang（编写RabbitMQ的编程语言）不兼容导致的。"

#: ../docs/source/intro/troubleshooting.rst:151
msgid "You can check your version of erlang using:"
msgstr "你可以使用下列命令查看erlang版本："

#: ../docs/source/intro/troubleshooting.rst:158
msgid "and your version of rabbitmq-server with:"
msgstr "以及查看 rabbitmq-server的版本："

#: ../docs/source/intro/troubleshooting.rst:165
msgid ""
"Then see `RabbitMQ Erlang Version Requirements <https://www.rabbitmq.com"
"/which-erlang.html>`__, to check if these are compatible, and reinstall as "
"appropriate."
msgstr "然后对照 `RabbitMQ Erlang 版本需求 `__ 来检查版本是否兼容，并修改重启服务。"

#: ../docs/source/intro/troubleshooting.rst:167
msgid ""
"See also the `RabbitMQ Troubleshooting "
"<https://www.rabbitmq.com/troubleshooting.html>`__ for further information."
msgstr "更多资料请参看 `RabbitMQ Troubleshooting  `__ 。"

#: ../docs/source/intro/troubleshooting.rst:170
msgid "Ensuring a UTF-8 locale"
msgstr "确保使用 UTF-8 编码"

#: ../docs/source/intro/troubleshooting.rst:172
msgid ""
"For some reasons, on some machines (notably often on Mac OS X) there is no "
"default locale defined, and when you run ``verdi setup`` for the first time "
"it fails (see also `this issue`_ of django). Run in your terminal (or maybe "
"even better, add to your ``.bashrc``, but then remember to open a new shell "
"window!):"
msgstr ""
"出于一些原因，在一些机器上 (通常是 Mac OS X) 时没有默认的区域设置的，当你首次运行 ``verdi setup`` 时会出错 (同时参考 "
"`this issue`_ of django)。在终端中运行 (最好能够在文件 ``.bashrc`` "
"中加入，但要记得重新打开一个shell)下列代码 :"

#: ../docs/source/intro/troubleshooting.rst:180
msgid "and then run ``verdi setup`` again."
msgstr "然后重新运行 ``verdi setup`` 。"

#: ../docs/source/intro/troubleshooting.rst:185
msgid "Possible Ubuntu dependencies"
msgstr "Ubuntu的版本依赖"

#: ../docs/source/intro/troubleshooting.rst:187
msgid ""
"Several users reported the need to install also ``libpq-dev`` (header files "
"for libpq5 - PostgreSQL library):"
msgstr "有多位用户反映需要安装 ``libpq-dev`` ( libpq5 库所需的头文件 - PostgreSQL library)："

#: ../docs/source/intro/troubleshooting.rst:193
msgid "But under Ubuntu 12.04 this is not needed."
msgstr "这在 Ubuntu 12.04 上时不需要的。"

#: ../docs/source/intro/troubleshooting.rst:196
msgid "verdi not in PATH"
msgstr "verdi 不再可执行路径 PATH中"

#: ../docs/source/intro/troubleshooting.rst:198
msgid ""
"Installing the ``aiida-core`` python package *should* add the ``verdi`` CLI "
"to your ``PATH`` automatically."
msgstr ""
"安装 ``aiida-core`` python 包 *本应* 将 ``verdi`` 命令行可执行程序自动加入你的 ``PATH`` 环境变量中。"

#: ../docs/source/intro/troubleshooting.rst:200
msgid ""
"If the ``verdi`` executable is not available in your terminal, the folder "
"where ``pip`` places binaries may not be added to your ``PATH``"
msgstr ""
"如果 ``verdi`` 可执行程序在你的终端中不可用，那么 ``pip`` 安装的软件的路径可能没有被加入你的  ``PATH`` 环境变量中"

#: ../docs/source/intro/troubleshooting.rst:202
msgid ""
"For Linux systems, this folder is usually something like ``~/.local/bin``:"
msgstr "对于Linux系统，这个文件夹通常为 ``~/.local.bin`` ："

#: ../docs/source/intro/troubleshooting.rst:208
msgid ""
"For Mac OS X systems, the path to add is usually "
"``~/Library/Python/2.7/bin``:"
msgstr "在Mac OS X 系统中，路径通常是 ``~/Library/Python/2.7/bin``："

#: ../docs/source/intro/troubleshooting.rst:214
msgid ""
"After updating your ``PATH``, the ``verdi`` command should be available."
msgstr "在你更新了 ``PATH`` 环境变量后，``verdi`` 命令就可以被使用了。"

#: ../docs/source/intro/troubleshooting.rst:218
msgid ""
"A preprequisite for ``verdi`` to work is that the ``aiida`` python package "
"is importable. Test this by opening a ``python`` or ``ipython`` shell and "
"typing:"
msgstr ""
"``verdi`` 能够使用的前提是 ``aiida`` python包是可以载入的。要检验是否可以载入，打开 ``python`` 或 "
"``ipython`` shell并键入 ："

#: ../docs/source/intro/troubleshooting.rst:225
msgid ""
"If you get an ``ImportError`` (and you are in the environment where AiiDA "
"was installed), you can add it to the ``PYTHONPATH`` manually:"
msgstr ""
"如果你得到一个 ``ImportError`` （并且你已经在AiiDA安装的环境中），你可以手动将其加入 ``PYTHONPAHT`` 中 ："

#: ../docs/source/intro/troubleshooting.rst:233
msgid "Configuring remote SSH computers"
msgstr "配置远程可SSH计算机"

#: ../docs/source/intro/troubleshooting.rst:236
msgid "ssh_kerberos installation"
msgstr "安装 ssh_kerberos"

#: ../docs/source/intro/troubleshooting.rst:238
msgid ""
"When installing the ``ssh_kerberos`` *optional* requirement through Anaconda"
" you may encounter the following error on Ubuntu machines:"
msgstr "如果在Ubuntu机器上使用Anaconda，并安装 ``ssh_kerberos`` (*可选*) 依赖时，你可能会遇见下列错误 ："

#: ../docs/source/intro/troubleshooting.rst:244
msgid ""
"This is related to an open issue in anaconda `ContinuumIO/anaconda-"
"issues#686`_. A potential solution is to run the following command:"
msgstr ""
"这是由anaconda的一个已知问题 `ContinuumIO/anaconda-issues#686`_ 导致的。 可能的解决办法是运行下列命令 ："

#: ../docs/source/intro/troubleshooting.rst:254
msgid "Output from .bashrc and/or .bash_profile on remote computers"
msgstr "远端计算资源上由 .bashrc 或 .bash_profile 产生的输出"

#: ../docs/source/intro/troubleshooting.rst:258
msgid "This also applies to computers configured via ``local`` transport."
msgstr "这同样适用于通过 ``local`` 传输配置的计算资源。"

#: ../docs/source/intro/troubleshooting.rst:260
msgid ""
"When connecting to remote computers, AiiDA (like other codes as ``sftp``) "
"can get confused if you have code in your ``.bashrc`` or ``.bash_profile`` "
"that produces output or e.g. runs commands like ``clean`` that require a "
"terminal."
msgstr ""
"当连接远端计算机时， 如果你在 ``.bashrc`` 或 ``.bash_profile`` 文件中加入了会输出一些输出的代码 ，AiiDA (如指令"
" ``sftp``) 会出现问题。如，当运行了命令如 ``clean`` 。"

#: ../docs/source/intro/troubleshooting.rst:262
msgid ""
"For instance, if you add a ``echo \"a\"`` in your ``.bashrc`` and then try "
"to SFTP a file from it, you will get an error like ``Received message too "
"long 1091174400``."
msgstr ""
"比如，如果你在 ``.bashrc`` 中加入 ``echo \"a\"`` ，并试图SFTP一个文件。你将会得到如 ``Received "
"message too long 1091174400`` 这样的错误。"

#: ../docs/source/intro/troubleshooting.rst:264
msgid ""
"If you still want to have code that needs an interactive shell (``echo``, "
"``clean``, ...), but you want to disable it for non-interactive shells, put "
"at the top of your file a guard like this:"
msgstr ""
"如果你依然想要保留一个交互的shell的代码（如 ``echo`` ， ``clean`` "
"，……），但你又想在非交互的shell中关闭它，将以下代码加入你的配置文件中 ："

#: ../docs/source/intro/troubleshooting.rst:273
msgid "Everything below this will not be executed in a non-interactive shell."
msgstr "下面的这些将不会在非交互的shell中执行。"

#: ../docs/source/intro/troubleshooting.rst:277
msgid ""
"Still, you might want to have some code on top, like e.g. setting the PATH "
"or similar, if this needs to be run also in the case of non-interactive "
"shells."
msgstr "如果你想在非交互shell中执行一些指令，你还是要将这些代码在文件的开始位置，比如设置PATH环境变量或类似的操作。"

#: ../docs/source/intro/troubleshooting.rst:279
msgid ""
"To test if a the computer does not produce spurious output, run (after "
"configuring):"
msgstr "要检测一台你设置的机器是否会输出不必要的信息，你可以运行（在配置之后） ："

#: ../docs/source/intro/troubleshooting.rst:285
msgid ""
"which checks and, in case of problems, suggests how to solve the problem."
msgstr "这会执行一个检查，以避免出现错误，若出现错误，会告知解决办法。"

#: ../docs/source/intro/troubleshooting.rst:289
msgid ""
"If the methods explained above do not work, you can configure AiiDA to not "
"use a login shell when connecting to your computer, which may prevent the "
"spurious output from being printed: During ``verdi computer configure``, set"
" ``-no-use-login-shell`` or when asked to use a login shell, set it to "
"``False``. Note, however, that this may result in a slightly different "
"environment, since `certain startup files are only sourced for login shells "
"<https://unix.stackexchange.com/a/46856/155909>`_."
msgstr ""
"如果上面的方法没用,您可以配置AiiDA时不使用登录shell连接到你的电脑,可以防止远端的的提示性输出:在 ``verdi computer "
"configure`` , 设置 ``-no-use-login-shell`` 或要求使用登录shell时,将其设置为 ``False``. "
"但是，请注意，这可能会导致一个稍微不同的环境，因为 `某些启动文件只被登录shel 加载l`_。"

#: ../docs/source/intro/troubleshooting.rst:298
msgid "Improvements for dependencies"
msgstr "其他软件的依赖"

#: ../docs/source/intro/troubleshooting.rst:301
msgid "Activating the ASE visualizer"
msgstr "打开ASE视图器"

#: ../docs/source/intro/troubleshooting.rst:303
msgid ""
"Within a virtual environment, attempt to visualize a structure with ``ase`` "
"(either from the shell, or using the command ``verdi data structure show "
"--format=ase <PK>``), might end up with the following error message::"
msgstr ""
"在虚拟环境中，尝试用 ``ase`` 来可视化查看结构时（通过 shell 运行或是使用命令 ``verdi data structure show "
"--format=ase <PK>``），可能会有以下错误 ::"

#: ../docs/source/intro/troubleshooting.rst:307
msgid ""
"The issue is that ``pygtk`` is currently not pip-installable. One has to "
"install it separately and create the appropriate bindings manually in the "
"virtual environment. You can follow the following procedure to get around "
"this issue:"
msgstr ""
"这是因为 ``pygtk`` 目前还不能通过pip安装。需要单独安装它并在虚拟环境中手动添加一些合适的软链接。可以按照以下步骤来解决此问题："

#: ../docs/source/intro/troubleshooting.rst:310
msgid "Install the ``python-gtk2`` package. Under Ubuntu, do:"
msgstr "安装 ``python-gtk2`` 包。在Ubuntu中可按以下步骤 ："

#: ../docs/source/intro/troubleshooting.rst:316
msgid ""
"Create the ``lib/python2.7/dist-packages`` folder within your virtual "
"environment:"
msgstr "在虚拟环境中创建 ``lib/python2.7/dist-packages`` 文件夹"

#: ../docs/source/intro/troubleshooting.rst:323
msgid ""
"where ``<AIIDA_VENV_FOLDER>`` is the virtual environment folder you have "
"created during the installation process."
msgstr "``<AIIDA_VENV_FOLDER>`` 表示安装过程中创建的虚拟环境文件夹。"

#: ../docs/source/intro/troubleshooting.rst:326
msgid ""
"Create several symbolic links from this folder, pointing to a number of "
"files in ``/usr/lib/python2.7/dist-packages/``:"
msgstr "在此文件夹中新建几个软链接指向 ``/usr/lib/python2.7/dist-packages/`` 中的文件 ："

#: ../docs/source/intro/troubleshooting.rst:338
msgid ""
"After that, ``verdi data structure show --format=ase <PK>`` should work."
msgstr "之后就可成功运行 ``verdi data structure show --format=ase <PK>``"

#: ../docs/source/intro/troubleshooting.rst:341
msgid "Use in ipython/jupyter"
msgstr "在ipython/jupyter中使用"

#: ../docs/source/intro/troubleshooting.rst:343
msgid ""
"In order to use the AiiDA objects and functions in Jupyter, this latter has "
"to be instructed to use the iPython kernel installed in the AiiDA virtual "
"environment. This happens by default if you install AiiDA with ``pip`` "
"including the ``notebook`` option, and run Jupyter from the AiiDA virtual "
"environment."
msgstr ""
"为了在Jupyter中使用AiiDA的对象与函数，需要指定使用安装在AiiDA虚拟环境中的iPython内核。如果使用 ``pip`` 同时安装了 "
"AiiDA 与 ``notebook`` 的话，之后再在AiiDA虚拟环境中启动Jupyter，那么会默认使用AiiDA虚拟环境中的iPython内核。"

#: ../docs/source/intro/troubleshooting.rst:346
msgid ""
"If for any reason, you do not want to install Jupyter in the virtual "
"environment, you might consider to install it out of the virtual "
"environment, if not already done:"
msgstr "如果不想把Jupyter装在虚拟环境之中，那么要确保虚拟环境之外已安装了Jupyter，可以用如下命令安装 ："

#: ../docs/source/intro/troubleshooting.rst:352
msgid "Then, activate the AiiDA virtual environment:"
msgstr "之后，激活AiiDA虚拟环境 ："

#: ../docs/source/intro/troubleshooting.rst:358
msgid "and setup the AiiDA iPython kernel:"
msgstr "并设置内核为AiiDA iPython内核 ："

#: ../docs/source/intro/troubleshooting.rst:365
msgid "where you have chosen a meaningful name for the new kernel."
msgstr "给这个新建的内核取一个有意义的名字。"

#: ../docs/source/intro/troubleshooting.rst:367
msgid "Finally, start a Jupyter server:"
msgstr "最后，如下命令开启Jupyter服务 ："

#: ../docs/source/intro/troubleshooting.rst:373
msgid ""
"and from the newly opened browser tab select ``New -> <aiida.kernel.name>``"
msgstr "在新打开的浏览器标签中选择 ``新建(New) -> <aiida.kernel.name>`` "

#: ../docs/source/intro/troubleshooting.rst:378
msgid "Increasing the logging verbosity"
msgstr "增加日志输出详细程度"

#: ../docs/source/intro/troubleshooting.rst:380
msgid ""
"By default, the logging level of AiiDA is minimal to avoid too much noise in"
" the logfiles. Only warnings and errors are logged to the daemon log files, "
"while info and debug messages are discarded."
msgstr ""
"默认情况下，AiiDA的日志级别是最小的，以避免冗余信息塞满日志文件。只有警告(warnings)和错误(errors)被记录到守护进程日志文件中，而信息(info)和调试(debug)消息被丢弃。"

#: ../docs/source/intro/troubleshooting.rst:383
msgid ""
"If you are experiencing a problem, you can increase the default minimum "
"logging level of AiiDA messages, with:"
msgstr "如果遇到问题，可以更改AiiDA的默认最低日志记录级别 ："

#: ../docs/source/intro/troubleshooting.rst:389
msgid ""
"You might also be interested in reviewing the circus log messages (the "
"``circus`` library is the daemonizer that manages the daemon runners),"
msgstr "您可能还对 ``circus`` 日志消息感兴趣( ``circus`` 库是管理守护进程运行器的后台进程)，"

#: ../docs/source/intro/troubleshooting.rst:395
msgid ""
"however those messages are usually only relevant to debug AiiDA internals."
msgstr "但是这些消息通常只在对AiiDA内部代码进行调试时有用。"

#: ../docs/source/intro/troubleshooting.rst:397
msgid ""
"For each profile that runs a daemon, there are two unique logfiles, one for "
"AiiDA log messages (named ``aiida-<profile_name>.log``) and one for the "
"circus logs (named ``circus-<profile_name>.log``). Those files can be found "
"in the ``~/.aiida/daemon/log`` folder."
msgstr ""
"对于每个运行守护进程的概要文件，将有惟二的日志文件，一个用于AiiDA日志消息(名为' ``aiida-<profile_name>.log`` "
")，另一个用于 circus日志(名为 ``circus-<profile_name>.log`` )。这些文件可以在 "
"``~/.aiida/daemon/log`` 文件夹找到。"

#: ../docs/source/intro/troubleshooting.rst:400
msgid ""
"After restarting the daemon (``verdi daemon restart``), the number of "
"messages logged will increase significantly and may help in determining the "
"source of the problem."
msgstr "重启守护进程( ``verdi daemon restart`` )后，记录的消息数量将显著增加，这可能有助于定位代码问题。"

#: ../docs/source/intro/troubleshooting.rst:404
msgid ""
"Besides ``DEBUG``, you can also use the levels defined in the `standard "
"Python logging module <https://docs.python.org/3/library/logging.html"
"#logging-levels>`_. In addition to those, AiiDA defines the custom "
"``REPORT`` level, which, with a value of ``23``, is more verbose than the "
"``WARNING`` level, but less verbose than ``INFO``. The ``REPORT`` level is "
"AiiDA's default logging level."
msgstr ""
"您可以使用与 ``DEBUG`` 不同的级别。级别列表及其顺序与 `standard Python logging module "
"<https://docs.python.org/3/library/logging.html#logging-levels>`_ "
"相同。除了标准日志级别之外，我们还定义了自定义的 ``REPORT`` 级别，其值为 ``23`` ，位于标准 ``INFO`` 和 "
"``WARNING`` 级别之间。AiiDA 的默认级别设为``REPORT`` ，用于报告工作链消息使用的日志记录。"

#: ../docs/source/intro/troubleshooting.rst:408
msgid ""
"When the problem is solved, we suggest to reset the default logging level, "
"with:"
msgstr "当问题解决后，我们建议恢复默认日志级别："

#: ../docs/source/intro/troubleshooting.rst:415
msgid "to avoid too much noise in the logfiles."
msgstr "以免过多的冗余信息塞满日志文件。"

#: ../docs/source/intro/troubleshooting.rst:417
msgid "The config options set for the current profile can be viewed using"
msgstr "当前配置文件设置的配置选项，可以通过下面命令查看："

#: ../docs/source/intro/troubleshooting.rst:423
msgid "in the ``options`` row."
msgstr "在 ``option`` 行。"

#: ../docs/source/intro/tutorial.rst:12
msgid "Basic tutorial"
msgstr "基础教程"

#: ../docs/source/intro/tutorial.rst:14
msgid ""
"Welcome to the AiiDA tutorial! The goal of this tutorial is to give you a "
"basic idea of how AiiDA helps you in executing data-driven workflows. At the"
" end of this tutorial, you will know how to:"
msgstr "欢迎来到AiiDA教程！这篇教程的目的是告诉你AiiDA是如何帮助你执行数据驱动的工作流的。在该教程的接为，你将会知道："

#: ../docs/source/intro/tutorial.rst:18
msgid "Store data in the database and subsequently retrieve it."
msgstr "如何将数据储存进入数据库中，以及后续如何检索它们。"

#: ../docs/source/intro/tutorial.rst:19
msgid ""
"Decorate a Python function such that its inputs and outputs are "
"automatically tracked."
msgstr "对Python函数使用装饰器，这样其输入和输出会自动被记录。"

#: ../docs/source/intro/tutorial.rst:20
msgid "Run and monitor the status of processes."
msgstr "运行和监视计算例程的状态。"

#: ../docs/source/intro/tutorial.rst:21
msgid "Explore and visualize the provenance graph."
msgstr "查看可验证性图。"

#: ../docs/source/intro/tutorial.rst:25
msgid ""
"If you are working on your own machine, note that the tutorial assumes that "
"you have a working AiiDA installation and have set up your AiiDA profile in "
"the current Python environment. If this is not the case, consult the "
":ref:`getting started page<intro:get_started>`."
msgstr ""
"如果你在你自己的机器上使用AiiDA，接下来的教程将会假设你已经在当前的环境中成功安装配置好AiiDA，并能正确运行了。如果没有，请参考 "
":ref:`准备开始篇<intro:get_started>`。"

#: ../docs/source/intro/tutorial.rst:29
msgid "Provenance"
msgstr "可验证性（Provenance）"

#: ../docs/source/intro/tutorial.rst:31
msgid ""
"Before we dive in, we need to briefly introduce one of the most important "
"concepts for AiiDA: *provenance*. An AiiDA database does not only contain "
"the results of your calculations, but also their inputs and each step that "
"was executed to obtain them. All of this information is stored in the form "
"of a *directed acyclic graph* (DAG). As an example, "
":numref:`fig_intro_workchain_graph` shows the provenance of the calculations"
" of this tutorial."
msgstr ""
"在我们正式开始前，有必要简短地介绍AiiDA的一个最重要的概念: "
"*可验证性（provenance）*。AiiDA的数据库不仅仅包含了你计算的结果，还包含了计算输入和输出间每一步执行的步骤。所有的这些信息都被储存在 "
"*（无环图）directed acyclic graph* (DAG)中。 :numref:`fig_intro_workchain_graph` "
"展现了这样一个可验证性图。"

#: ../docs/source/intro/tutorial.rst:41
msgid "Provenance Graph of a basic AiiDA WorkChain."
msgstr "一个基本的AiiDA工作链的可验证性图"

#: ../docs/source/intro/tutorial.rst:43
msgid ""
"In the provenance graph, you can see different types of *nodes* represented "
"by different shapes. The green ellipses are ``Data`` nodes, the blue ellipse"
" is a ``Code`` node, and the rectangles represent *processes*, i.e. the "
"calculations performed in your *workflow*."
msgstr ""
"在可验证性图中，你可以看到各种不同类型的*节点*，它们有不同的形状。绿色椭圆形的是  ``数据（Data）`` 节点，蓝色椭圆形的是 "
"``计算代码（Code）`` 节点，长方形则表示 *计算例程（processes）*，比如你的 *工作流* 中的算例。"

#: ../docs/source/intro/tutorial.rst:46
msgid ""
"The provenance graph allows us to not only see what data we have, but also "
"how it was produced. During this tutorial, we will be using AiiDA to "
"generate the provenance graph in :numref:`fig_intro_workchain_graph` step by"
" step."
msgstr ""
"通过可验证性图，你不仅可以看到你所拥有的数据，还可以看到数据是如何产生的。在这一教程中，我们将使用AiiDA一步步产生可验证性图 "
":numref:`fig_intro_workchain_graph` 。"

#: ../docs/source/intro/tutorial.rst:50
msgid "Data nodes"
msgstr "数据节点"

#: ../docs/source/intro/tutorial.rst:52
msgid ""
"Before running any calculations, let's create and store a *data node*. AiiDA"
" ships with an interactive IPython shell that has many basic AiiDA classes "
"pre-loaded. To start the IPython shell, simply type in the terminal:"
msgstr ""
"在运行计算前，我们先创建并储存一个 *数据节点*。 AiiDA提供了一个可交互的 IPython "
"shell，它包含了许多预加载的基础AiiDA类型。通过下面指令开启IPython shell："

#: ../docs/source/intro/tutorial.rst:60
msgid ""
"AiiDA implements data node types for the most common types of data (int, "
"float, str, etc.), which you can extend with your own (composite) data node "
"types if needed. For this tutorial, we'll keep it very simple, and start by "
"initializing an ``Int`` node and assigning it to the `node` variable:"
msgstr ""
"AiiDA重实现了最常用的一些数据类型如（int, float, "
"str等），如果你有需要，你可以拓展的创建特殊的组合数据类型。在该教程中，简单起见，我们初始化一个 ``Int`` 节点，并赋值给 `node` 变量："

#: ../docs/source/intro/tutorial.rst:67
msgid "We can check the contents of the ``node`` variable like this:"
msgstr "我们可以这样查看 ``node`` 变量的内容："

#: ../docs/source/intro/tutorial.rst:74
msgid "Quite a bit of information on our freshly created node is returned:"
msgstr "将返回这一刚刚创建的节点的一些信息："

#: ../docs/source/intro/tutorial.rst:76
msgid "The data node is of the type ``Int``"
msgstr "数据节点的类型是 ``Int``"

#: ../docs/source/intro/tutorial.rst:77
msgid ""
"The node has the *universally unique identifier* (**UUID**) ``eac48d2b-ae20"
"-438b-aeab-2d02b69eb6a8``"
msgstr "该节点的 *通用唯一标识符* (**UUID**) ``eac48d2b-ae20-438b-aeab-2d02b69eb6a8``"

#: ../docs/source/intro/tutorial.rst:78
msgid "The node is currently not stored in the database ``(unstored)``"
msgstr "该节点当前还没有被存入数据库中 ``(unstored)``"

#: ../docs/source/intro/tutorial.rst:79
msgid "The integer value of the node is ``2``"
msgstr "节点的值为整数 ``2``"

#: ../docs/source/intro/tutorial.rst:81
msgid "Let's store the node in the database:"
msgstr "我们把节点存入数据库："

#: ../docs/source/intro/tutorial.rst:88
msgid ""
"As you can see, the data node has now been assigned a *primary key* "
"(**PK**), a number that identifies the node in your database ``(pk: 1)``. "
"The PK and UUID both reference the node with the only difference that the PK"
" is unique *for your local database only*, whereas the UUID is a globally "
"unique identifier and can therefore be used between *different* databases. "
"Use the PK only if you are working within a single database, i.e. in an "
"interactive session and the UUID in all other cases."
msgstr ""
"如您所见，数据节点现在已经被分配了一个*主键* (**PK**)，这个数字标识数据库中的节点' ' (PK: 1) ' "
"'。PK和UUID都引用节点，唯一的区别是PK是唯一的*仅适用于您的本地数据库*，而UUID是全局唯一标识符，因此可以在*不同的*数据库之间使用。仅当您在单个数据库中工作时才使用PK，即在交互式会话中，在所有其他情况下使用UUID。"

#: ../docs/source/intro/tutorial.rst:94
msgid ""
"The PK numbers shown throughout this tutorial assume that you start from a "
"completely empty database. It is possible that the nodes' PKs will be "
"different for your database!"
msgstr "本教程中的PK值是假设你从一个全空的数据库开始增加数据节点产生的。因此，教程中的数据节点的PK值可能会和你的数据库中的不同！"

#: ../docs/source/intro/tutorial.rst:97
msgid ""
"The UUIDs are generated randomly and are, therefore, **guaranteed** to be "
"different."
msgstr "UUID是随机产生的，因此确定它们是不同的。"

#: ../docs/source/intro/tutorial.rst:99
msgid ""
"Next, let's leave the IPython shell by typing ``exit()`` and then enter. "
"Back in the terminal, use the ``verdi`` command line interface (CLI) to "
"check the data node we have just created:"
msgstr ""
"接下来，我们键入 ``exit()`` 来退出IPyhon shell并回车。回到终端后，使用 ``verdi`` "
"命令行接口（CLI）来查看刚刚你创建的数据节点："

#: ../docs/source/intro/tutorial.rst:106
msgid "This prints something like the following:"
msgstr "这会打印如下信息："

#: ../docs/source/intro/tutorial.rst:120
msgid ""
"Once again, we can see that the node is of type ``Int``, has PK = 1, and "
"UUID = ``eac48d2b-ae20-438b-aeab-2d02b69eb6a8``. Besides this information, "
"the ``verdi node show`` command also shows the (empty) ``label`` and "
"``description``, as well as the time the node was created (``ctime``) and "
"last modified (``mtime``)."
msgstr ""
"同样，我们可以看到该节点的类型为' ' Int ' '，其PK = 1, UUID = ' ' eac48d2b-ae20-438b-aeab-"
"2d02b69eb6a8 ' '。除了这些信息外，' ' verdi node show ' '命令还显示了(empty)' label ' ' and"
" ' description ' '，以及节点被创建的时间(' ctime ' ')和最后修改的时间(' mtime ' ')。"

#: ../docs/source/intro/tutorial.rst:123
msgid ""
"AiiDA already provides many standard data types, but you can also "
":ref:`create your own<topics:data_types:plugin>`."
msgstr ""
"AiiDA已经提供了许多的标准数据类型，但你也可以 :ref:`创建你自己的数据类型<topics:data_types:plugin>` 。"

#: ../docs/source/intro/tutorial.rst:126
msgid "Calculation functions"
msgstr "算例函数(Calculation functions)"

#: ../docs/source/intro/tutorial.rst:128
msgid ""
"Once your data is stored in the database, it is ready to be used for some "
"computational task. For example, let's say you want to multiply two ``Int`` "
"data nodes. The following Python function:"
msgstr "这样你的数据就被储存在数据库中了，你可以用它来进行计算任务。比如，你想要将两个整型 ``Int`` 数据节点相乘。有如下Python函数："

#: ../docs/source/intro/tutorial.rst:137
msgid ""
"will give the desired result when applied to two ``Int`` nodes, but the "
"calculation will not be stored in the provenance graph. However, we can use "
"a `Python decorator <https://docs.python.org/3/glossary.html#term-"
"decorator>`_ provided by AiiDA to automatically make it part of the "
"provenance graph. Start up the AiiDA IPython shell again using ``verdi "
"shell`` and execute the following code snippet:"
msgstr ""
"当应用到两个“Int”节点时，将给出想要的结果，但计算不会存储在起源图中。但是，我们可以使用AiiDA提供的' Python装饰器' "
"_自动使它成为起源图的一部分。再次使用' ' verdi shell ' '启动AiiDA IPython shell，并执行以下代码片段:"

#: ../docs/source/intro/tutorial.rst:149
msgid ""
"This converts the ``multiply`` function into an AiIDA *calculation "
"function*, the most basic execution unit in AiiDA. Next, load the ``Int`` "
"node you have created in the previous section using the ``load_node`` "
"function and the PK of the data node:"
msgstr ""
"这将“乘”函数转换为AiIDA *计算函数*，AiIDA中最基本的执行单元。接下来，使用' ' load_node ' "
"'函数和数据节点的PK加载上一节中创建的' ' Int ' '节点:"

#: ../docs/source/intro/tutorial.rst:156
msgid ""
"Of course, we need another integer to multiply with the first one. Let's "
"create a new ``Int`` data node and assign it to the variable ``y``:"
msgstr "当然，我们需要另一个整数来和第一个相乘。让我们创建一个新的' ' Int ' '数据节点，并将其赋给变量' ' y ' ':"

#: ../docs/source/intro/tutorial.rst:163
msgid "Now it's time to multiply the two numbers!"
msgstr "现在，我们可以将两个数相乘了！"

#: ../docs/source/intro/tutorial.rst:170
msgid ""
"Success! The ``calcfunction``-decorated ``multiply`` function has multiplied"
" the two ``Int`` data nodes and returned a new ``Int`` data node whose value"
" is the product of the two input nodes. Note that by executing the "
"``multiply`` function, all input and output nodes are automatically stored "
"in the database:"
msgstr ""
"成功!' ' calcfunction ' ' -修饰' ' multiply ' '函数将两个' ' Int ' '数据节点相乘，并返回一个新的' '"
" Int ' '数据节点，其值为两个输入节点的乘积。注意，通过执行' ' multiply ' '函数，所有的输入和输出节点都会自动存储在数据库中:"

#: ../docs/source/intro/tutorial.rst:179
msgid ""
"We had not yet stored the data node assigned to the ``y`` variable, but by "
"providing it as an input argument to the ``multiply`` function, it was "
"automatically stored with PK = 2. Similarly, the returned ``Int`` node with "
"value 6 has been stored with PK = 4."
msgstr ""
"我们还没有存储分配给' ' y ' '变量的数据节点，但是通过将其作为' ' multiply ' '函数的输入参数，它将自动存储为PK = "
"2。类似地，返回值为6的' ' Int ' '节点存储在PK = 4中。"

#: ../docs/source/intro/tutorial.rst:182
msgid ""
"Let's once again leave the IPython shell with ``exit()`` and look for the "
"process we have just run using the ``verdi`` CLI:"
msgstr "我们再次键入 ``exit()`` 离开IPython shell，并使用 ``verdi`` CLI来查看我们刚刚运行的计算例程："

#: ../docs/source/intro/tutorial.rst:188
msgid ""
"The returned list will be empty, but don't worry! By default, ``verdi "
"process list`` only returns the *active* processes. If you want to see *all*"
" processes (i.e. also the processes that are *terminated*), simply add the "
"``-a`` option:"
msgstr ""
"返回的列表为空？别着急！默认情况下， ``verdi process list`` 只会返回正在运行的 *active* 的计算例程。如果你希望看到 "
"*所有的* 计算例程（比如已经 *结束的* 计算例程），你只需要简单的在命令中加上 ``-a`` 选项："

#: ../docs/source/intro/tutorial.rst:196
msgid "You should now see something like the following output:"
msgstr "你现在就可以看到如下的输出了："

#: ../docs/source/intro/tutorial.rst:208
msgid ""
"We can see that our ``multiply`` calcfunction was created 1 minute ago, "
"assigned the PK 3, and has ``Finished``."
msgstr "我们可以看到 ``multiply`` 算例在一分钟之前创建，并被赋值了主键PK 3,且完成执行 `Finished`` 。"

#: ../docs/source/intro/tutorial.rst:210
msgid ""
"As a final step, let's have a look at the provenance of this simple "
"calculation. The provenance graph can be automatically generated using the "
"verdi CLI. Let's generate the provenance graph for the ``multiply`` "
"calculation function we have just run with PK = 3:"
msgstr ""
"最后一步，让我们看看这个简单计算的起源。起源图可以使用verdi CLI自动生成。让我们为刚刚运行的PK = 3的' '乘' '计算函数生成出处图:"

#: ../docs/source/intro/tutorial.rst:218
msgid ""
"The command will write the provenance graph to a ``.pdf`` file. Use your "
"favorite PDF viewer to have a look. It should look something like the graph "
"shown in :numref:`fig_calcfun_graph`."
msgstr ""
"该命令将出处图写入一个' ' .pdf ' '文件。使用您最喜欢的PDF查看器来查看。它应该类似于:numref: ' "
"fig_calcfun_graph '中显示的图形。"

#: ../docs/source/intro/tutorial.rst:227
msgid "Provenance graph of the ``multiply`` calculation function."
msgstr "``multiply`` 算例函数的可验证性图。"

#: ../docs/source/intro/tutorial.rst:229
msgid ""
"Remember that the PK of the ``CalcJob`` can be different for your database."
msgstr "请注意， ``CalcJob`` 的主键值可以于你数据库中的不同。"

#: ../docs/source/intro/tutorial.rst:234
msgid "CalcJobs"
msgstr "CalcJobs （算例任务）"

#: ../docs/source/intro/tutorial.rst:236
msgid ""
"When running calculations that require an external code or run on a remote "
"machine, a simple calculation function is no longer sufficient. For this "
"purpose, AiiDA provides the ``CalcJob`` process class."
msgstr "当运行需要外部代码或在远程机器上运行的计算时，一个简单的计算函数不再足够。为此，AiiDA提供了“CalcJob”流程类。"

#: ../docs/source/intro/tutorial.rst:239
msgid ""
"To run a ``CalcJob``, you need to set up two things: a ``code`` that is "
"going to implement the desired calculation and a ``computer`` for the "
"calculation to run on."
msgstr ""
"要运行一个' ' CalcJob ' '，你需要设置两个东西:一个' ' code ' ' '，将实现所需的计算和一个' ' computer ' ' "
"'计算运行。"

#: ../docs/source/intro/tutorial.rst:241
msgid ""
"If you're running this tutorial in the Quantum Mobile VM or on Binder, these"
" have been pre-configured for you. If you're running on your own machine, "
"you can follow the instructions in the panel below."
msgstr ""
"如果您在Quantum Mobile "
"VM或Binder上运行本教程，那么这些都已为您预先配置好了。如果您在自己的机器上运行，您可以遵循下面面板中的说明。"

#: ../docs/source/intro/tutorial.rst:245
msgid "More details for how to :ref:`run external codes <how-to:run-codes>`."
msgstr "关于如何:ref: '运行外部代码'的更多细节。"

#: ../docs/source/intro/tutorial.rst:249
msgid ""
"Let's begin by setting up the computer using the ``verdi computer`` "
"subcommand:"
msgstr "我们从使用 ``verdi computer`` 子命令来设置远端机器作为开始："

#: ../docs/source/intro/tutorial.rst:256
msgid "The first commands sets up the computer with the following options:"
msgstr "第一个命令使用一下参数设置了一台机器："

#: ../docs/source/intro/tutorial.rst:258
msgid "*label* (``-L``): tutor"
msgstr "*label（标签）* (``-L``): tutor"

#: ../docs/source/intro/tutorial.rst:259
msgid "*hostname* (``-H``): localhost"
msgstr "*hostname（主机名）* (``-H``): localhost"

#: ../docs/source/intro/tutorial.rst:260
msgid "*transport* (``-T``): local"
msgstr "*transport（传输方式）* (``-T``): local"

#: ../docs/source/intro/tutorial.rst:261
msgid "*scheduler* (``-S``): direct"
msgstr "*scheduler（任务调度）* (``-S``): direct"

#: ../docs/source/intro/tutorial.rst:262
msgid ""
"*work-dir* (``-w``): The ``work`` subdirectory of the current directory"
msgstr "*work-dir（工作目录）* (``-w``): 当前目录的工作 ``work`` 子目录"

#: ../docs/source/intro/tutorial.rst:264
msgid ""
"The second command *configures* the computer with a minimum interval between"
" connections (``--safe-interval``) of 5 seconds. For both commands, the "
"*non-interactive* option (``-n``) is added to not prompt for extra input."
msgstr ""
"The second command第二个命令使用 (``--safe-interval``) *配置了（configures）* "
"两次连接之间的最短间隔时间为五秒。对于以上命令，均使用了非交互 *non-interactive* 参数 (``-n``) "
"以避免弹出对额外配置输入的提示。"

#: ../docs/source/intro/tutorial.rst:267
msgid "Next, let's set up the code we're going to use for the tutorial:"
msgstr "接下来，我们类配置我们需要在教程中使用的计算代码："

#: ../docs/source/intro/tutorial.rst:273
msgid ""
"This command sets up a code with *label* ``add`` on the *computer* "
"``tutor``, using the *plugin* ``arithmetic.add``."
msgstr ""
"该命令设置了计算代码，其 *标签* 为  ``add`` ，运行的 *机器* 为刚刚配置的 ``tutor``，并使用了 *插件*  "
"``arithmetic.add`` 。."

#: ../docs/source/intro/tutorial.rst:275
msgid ""
"A typical real-world example of a computer is a remote supercomputing "
"facility. Codes can be anything from a Python script to powerful *ab initio*"
" codes such as Quantum Espresso or machine learning tools like Tensorflow. "
"Let's have a look at the codes that are available to us:"
msgstr ""
"计算机的一个典型的现实例子是远程超级计算设施。代码可以是任何东西，从Python脚本到强大的*从头开始*代码(如Quantum "
"Espresso)或机器学习工具(如Tensorflow)。让我们来看看可用的代码:"

#: ../docs/source/intro/tutorial.rst:286
msgid ""
"You can see a single code ``add@tutor``, with PK = 5, in the printed list. "
"This code allows us to add two integers together. The ``add@tutor`` "
"identifier indicates that the code with label ``add`` is run on the computer"
" with label ``tutor``. To see more details about the computer, you can use "
"the following ``verdi`` command:"
msgstr ""
"您可以在打印的列表中看到单个代码' ' add@tutor ' '，其中PK = 5。这段代码允许我们将两个整数相加。' ' add@tutor ' "
"'标识符表明带有标签' ' add ' '的代码在带有标签' ' tutor ' ' '的计算机上运行。要查看计算机的详细信息，可以使用以下' ' "
"verdi ' '命令:"

#: ../docs/source/intro/tutorial.rst:309
msgid ""
"We can see that the *Work directory* has been set up as the ``work`` "
"subdirectory of the current directory. This is the directory in which the "
"calculations running on the ``tutor`` computer will be executed."
msgstr "我们可以看到，*Work目录*已经被设置为当前目录的' ' Work ' '子目录。这是在“导师”计算机上运行的计算将被执行的目录。"

#: ../docs/source/intro/tutorial.rst:314
msgid ""
"You may have noticed that the PK of the ``tutor`` computer is 1, same as the"
" ``Int`` node we created at the start of this tutorial. This is because "
"different entities, such as nodes, computers and groups, are stored in "
"different tables of the database. So, the PKs for each entity type are "
"unique for each database, but entities of different types can have the same "
"PK within one database."
msgstr ""
"您可能已经注意到，' ' tutor ' '计算机的PK是1，与我们在本教程开始时创建的' ' Int ' "
"'节点相同。这是因为不同的实体(如节点、计算机和组)存储在数据库的不同表中。因此，每种实体类型的PK对于每个数据库都是惟一的，但是不同类型的实体可以在一个数据库中拥有相同的PK。"

#: ../docs/source/intro/tutorial.rst:318
msgid ""
"Let's now start up the ``verdi shell`` again and load the ``add@tutor`` code"
" using its label:"
msgstr "现在让我们再次启动' ' verdi shell ' '，并使用它的标签加载' ' add@tutor ' '代码:"

#: ../docs/source/intro/tutorial.rst:324
msgid ""
"Every code has a convenient tool for setting up the required input, called "
"the *builder*. It can be obtained by using the ``get_builder`` method:"
msgstr "每个代码都有一个方便的工具来设置所需的输入，称为*builder*。它可以通过``get_builder``方法获得:"

#: ../docs/source/intro/tutorial.rst:331
msgid ""
"Using the builder, you can easily set up the calculation by directly "
"providing the input arguments. Let's use the ``Int`` node that was created "
"by our previous ``calcfunction`` as one of the inputs and a new node as the "
"second input:"
msgstr ""
"使用构建器，您可以通过直接提供输入参数来轻松地设置计算。让我们使用由前面的``calcfunction``创建的``Int``节点作为一个输入，并使用一个新节点作为第二个输入:"

#: ../docs/source/intro/tutorial.rst:339
msgid ""
"In case that your nodes' PKs are different and you don't remember the PK of "
"the output node from the previous calculation, check the provenance graph "
"you generated earlier and use the UUID of the output node instead:"
msgstr "如果您的节点的PK不同，并且您不记得上一次计算的输出节点的PK，请检查您之前生成的起源图，并使用输出节点的UUID:"

#: ../docs/source/intro/tutorial.rst:346
msgid ""
"Note that you don't have to provide the entire UUID to load the node. As "
"long as the first part of the UUID is unique within your database, AiiDA "
"will find the node you are looking for."
msgstr "注意，您不必提供整个UUID来加载节点。只要UUID的第一部分在您的数据库中是惟一的，AiiDA就会找到您要查找的节点。"

#: ../docs/source/intro/tutorial.rst:351
msgid ""
"One nifty feature of the builder is the ability to use tab completion for "
"the inputs. Try it out by typing ``builder.`` + ``<TAB>`` in the verdi "
"shell."
msgstr "该构建器的一个漂亮特性是能够对输入使用制表符补全。键入' ' builder试试。' ' + ````在verdi shell。"

#: ../docs/source/intro/tutorial.rst:354
msgid ""
"To execute the ``CalcJob``, we use the ``run`` function provided by the "
"AiiDA engine:"
msgstr "要执行' ' CalcJob ' '，我们使用AiiDA引擎提供的' ' run ' '函数:"

#: ../docs/source/intro/tutorial.rst:361
msgid ""
"Wait for the process to complete. Once it is done, it will return a "
"dictionary with the output nodes:"
msgstr "等待流程完成。一旦完成，它将返回一个带有输出节点的字典:"

#: ../docs/source/intro/tutorial.rst:371
msgid ""
"Besides the sum of the two ``Int`` nodes, the calculation function also "
"returns two other outputs: one of type ``RemoteData`` and one of type "
"``FolderData``. See the :ref:`topics section on calculation jobs "
"<topics:calculations:usage:calcfunctions>` for more details. Now, exit the "
"IPython shell and once more check for *all* processes:"
msgstr ""
"除了两个Int节点的和之外，计算函数还返回另外两个输出:一个类型为RemoteData，另一个类型为FolderData。更多细节请参见:ref:“计算作业的主题部分”。现在，退出IPython"
" shell，再次检查*all*进程:"

#: ../docs/source/intro/tutorial.rst:379
msgid ""
"You should now see two processes in the list. One is the ``multiply`` "
"calcfunction you ran earlier, the second is the ``ArithmeticAddCalculation``"
" CalcJob that you have just run. Grab the PK of the "
"``ArithmeticAddCalculation``, and generate the provenance graph. The result "
"should look like the graph shown in :numref:`fig_calcjob_graph`."
msgstr ""
"您现在应该看到列表中有两个进程。一个是你之前运行的' '乘' ' calcfunction，第二个是你刚刚运行的' '算术addcalculation "
"' ' CalcJob。获取“算术添加计算”的PK，并生成起源图。结果应该类似于:numref: ' fig_calcjob_graph '中所示的图。"

#: ../docs/source/intro/tutorial.rst:393
msgid ""
"Provenance graph of the ``ArithmeticAddCalculation`` CalcJob, with one input"
" provided by the output of the ``multiply`` calculation function."
msgstr "“算术添加计算”“CalcJob”的起源图，由“乘法”计算函数的输出提供一个输入。"

#: ../docs/source/intro/tutorial.rst:395
msgid ""
"You can see more details on any process, including its inputs and outputs, "
"using the verdi shell:"
msgstr "你可以使用verdi shell来查看更为详细的包含输入输出的计算例程的信息："

#: ../docs/source/intro/tutorial.rst:402
msgid "Submitting to the daemon"
msgstr "提交到后台"

#: ../docs/source/intro/tutorial.rst:404
msgid ""
"When we used the ``run`` command in the previous section, the IPython shell "
"was blocked while it was waiting for the ``CalcJob`` to finish. This is not "
"a problem when we're simply adding two number together, but if we want to "
"run multiple calculations that take hours or days, this is no longer "
"practical. Instead, we are going to *submit* the ``CalcJob`` to the AiiDA "
"*daemon*. The daemon is a program that runs in the background and manages "
"submitted calculations until they are *terminated*. Let's first check the "
"status of the daemon using the ``verdi`` CLI:"
msgstr ""
"当我们在前一节中使用' ' run ' '命令时，IPython shell在等待' ' CalcJob ' "
"'完成时被阻塞。当我们简单地把两个数相加时，这不是一个问题，但如果我们想要运行多个计算，需要数小时或数天，这就不再实用了。相反，我们将把' ' "
"CalcJob ' '提交给AiiDA *守护进程*。守护进程是一个在后台运行的程序，管理提交的计算，直到它们被*终止*为止。让我们首先使用' ' "
"verdi ' '命令行检查守护进程的状态:"

#: ../docs/source/intro/tutorial.rst:414
msgid ""
"If the daemon is running, the output will be something like the following:"
msgstr "如果后台守护进程正在运行，则会有如下输出："

#: ../docs/source/intro/tutorial.rst:426
msgid "In this case, let's stop it for now:"
msgstr "此时，我们将其停止："

#: ../docs/source/intro/tutorial.rst:432
msgid ""
"Next, let's *submit* the ``CalcJob`` we ran previously. Start the ``verdi "
"shell`` and execute the Python code snippet below. This follows all the "
"steps we did previously, but now uses the ``submit`` function instead of "
"``run``:"
msgstr ""
"接下来，让我们*提交*前面运行的' ' CalcJob ' '。启动' ' verdi shell ' ' "
"'并执行下面的Python代码片段。它遵循了我们之前所做的所有步骤，但是现在使用' ' submit ' '函数而不是' ' run ' ':"

#: ../docs/source/intro/tutorial.rst:447
msgid ""
"When using ``submit`` the calculation job is not run in the local "
"interpreter but is sent off to the daemon and you get back control "
"instantly. Instead of the *result* of the calculation, it returns the node "
"of the ``CalcJob`` that was just submitted:"
msgstr ""
"当使用“提交”时，计算作业不会在本地解释器中运行，而是被发送给守护进程，你可以立即获得控制权。它返回的不是计算的*result*，而是刚刚提交的' ' "
"CalcJob ' '的节点:"

#: ../docs/source/intro/tutorial.rst:454
msgid "Let's exit the IPython shell and have a look at the process list:"
msgstr "退出IPython shell并查看计算例程列表："

#: ../docs/source/intro/tutorial.rst:460
msgid ""
"You should see the ``CalcJob`` you have just submitted, with the state "
"``Created``:"
msgstr "你会看到你刚刚提交的算例任务 ``CalcJob`` ，其状态为 ``Created`` ："

#: ../docs/source/intro/tutorial.rst:472
msgid ""
"The ``CalcJob`` process is now waiting to be picked up by a daemon runner, "
"but the daemon is currently disabled. Let's start it up (again):"
msgstr "' ' CalcJob ' '进程现在正在等待被守护进程运行程序拾取，但是守护进程目前是禁用的。让我们(再)启动它:"

#: ../docs/source/intro/tutorial.rst:479
msgid ""
"Now you can either use ``verdi process list`` to follow the execution of the"
" ``CalcJob``, or ``watch`` its progress:"
msgstr ""
"现在你可以使用' verdi process list ' '来跟踪' ' CalcJob ' '的执行，或者' ' watch ' '它的进度:"

#: ../docs/source/intro/tutorial.rst:485
msgid ""
"Let's wait for the ``CalcJob`` to complete and then use ``verdi process list"
" -a`` to see all processes we have run so far:"
msgstr ""
"让我们等待' ' CalcJob ' '完成，然后使用' ' verdi process list -a ' '查看到目前为止我们已经运行的所有进程:"

#: ../docs/source/intro/tutorial.rst:500
msgid "Workflows"
msgstr "工作流"

#: ../docs/source/intro/tutorial.rst:502
msgid ""
"So far we have executed each process manually. AiiDA allows us to automate "
"these steps by linking them together in a *workflow*, whose provenance is "
"stored to ensure reproducibility. For this tutorial we have prepared a basic"
" ``WorkChain`` that is already implemented in ``aiida-core``. You can see "
"the code below:"
msgstr ""
"到目前为止，我们已经手动执行了每个流程。AiiDA允许我们通过将它们链接到一个*工作流*中来自动化这些步骤，其出处被存储以确保再现性。在本教程中，我们准备了一个基本的“工作链”，它已经在“aida"
" -core”中实现了。你可以看到下面的代码:"

#: ../docs/source/intro/tutorial.rst:513
msgid ""
"First, we recognize the ``multiply`` function we have used earlier, "
"decorated as a ``calcfunction``. The ``define`` class method specifies the "
"``input`` and ``output`` of the ``WorkChain``, as well as the ``outline``, "
"which are the steps of the workflow. These steps are provided as methods of "
"the ``MultiplyAddWorkChain`` class."
msgstr ""
"首先，我们认识前面使用过的' ' multiply ' '函数，修饰为' ' calcfunction ' "
"'。``define``类方法指定``WorkChain``的``输入``和``输出``，以及``outline``，这是工作流的步骤。这些步骤作为' "
"' MultiplyAddWorkChain ' '类的方法提供。"

#: ../docs/source/intro/tutorial.rst:519
msgid ""
"Besides WorkChain's, workflows can also be implemented as *work functions*. "
"These are ideal for workflows that are not very computationally intensive "
"and can be easily implemented in a Python function."
msgstr ""
"除了WorkChain的，工作流也可以作为*工作函数*来实现。对于计算量不是很大且可以很容易地在Python函数中实现的工作流来说，这是理想的。"

#: ../docs/source/intro/tutorial.rst:522
msgid ""
"Let's run the ``WorkChain`` above! Start up the ``verdi shell`` and load the"
" ``MultiplyAddWorkChain`` using the ``WorkflowFactory``:"
msgstr ""
"让我们运行上面的“工作链”!启动“verdi shell”并使用“WorkflowFactory”加载“MultiplyAddWorkChain”:"

#: ../docs/source/intro/tutorial.rst:529
msgid ""
"The ``WorkflowFactory`` is a useful and robust tool for loading workflows "
"based on their *entry point*, e.g. ``'arithmetic.multiply_add'`` in this "
"case. Similar to a ``CalcJob``, the ``WorkChain`` input can be set up using "
"a builder:"
msgstr ""
"“WorkflowFactory”是一个有用且健壮的工具，用于基于工作流的“入口点”加载工作流，例如:“算术。在本例中，Multiply_add ' "
"'。类似于' ' CalcJob ' '， ' ' WorkChain ' '输入可以使用构建器进行设置:"

#: ../docs/source/intro/tutorial.rst:540
msgid ""
"Once the ``WorkChain`` input has been set up, we submit it to the daemon "
"using the ``submit`` function from the AiiDA engine:"
msgstr "一旦' ' WorkChain ' '输入设置好了，我们就使用AiiDA引擎的' ' submit ' '函数将它提交给守护进程:"

#: ../docs/source/intro/tutorial.rst:547
msgid "Now quickly leave the IPython shell and check the process list:"
msgstr "退出IPython shell并查看计算例程列表："

#: ../docs/source/intro/tutorial.rst:553
msgid ""
"Depending on which step the workflow is running, you should get something "
"like the following:"
msgstr "你将会看到如下的输出，当然输出略有不同，取决于工作流运行到了哪里："

#: ../docs/source/intro/tutorial.rst:570
msgid ""
"We can see that the ``MultiplyAddWorkChain`` is currently waiting for its "
"*child process*, the ``ArithmeticAddCalculation``, to finish. Check the "
"process list again for *all* processes (You should know how by now!). After "
"about half a minute, all the processes should be in the ``Finished`` state. "
"The ``verdi process status`` command prints a *hierarchical* overview of the"
" processes called by the work chain:"
msgstr ""
"我们可以看到``MultiplyAddWorkChain``目前正在等待它的*子进程* ``算术addcalculation "
"``完成。再次检查*所有*过程列表(你现在应该知道怎么做了!)大约半分钟后，所有进程都应该处于“完成”状态。' ' verdi进程状态' "
"'命令打印工作链调用的进程的*层次*概述:"

#: ../docs/source/intro/tutorial.rst:582
msgid ""
"The bracket ``[3:result]`` indicates the current step in the outline of the "
":py:class:`~aiida.workflows.arithmetic.multiply_add.MultiplyAddWorkChain` "
"(step 3, with name ``result``). The ``process status`` is particularly "
"useful for debugging complex work chains, since it helps pinpoint where a "
"problem occurred."
msgstr ""
"支架“[3:结果]“显示当前步骤的概述:py:类:“~ "
"aiida.workflows.arithmetic.multiply_add。MultiplyAddWorkChain '(步骤3，名称' ' "
"result ' ')。“进程状态”对于调试复杂的工作链特别有用，因为它有助于查明问题发生的位置。"

#: ../docs/source/intro/tutorial.rst:585
msgid ""
"We can now generate the full provenance graph for the ``WorkChain`` with:"
msgstr "我们现在可以用以下方法为“工作链”生成完整的出处图:"

#: ../docs/source/intro/tutorial.rst:591
msgid ""
"Look familiar? The provenance graph should be similar to the one we showed "
"at the start of this tutorial (:numref:`fig_workchain_graph`)."
msgstr "看起来熟悉吗?出处图应该类似于我们在本教程开始时显示的(:numref: ' fig_workchain_graph ')。"

#: ../docs/source/intro/tutorial.rst:599
msgid "Final provenance Graph of the basic AiiDA tutorial."
msgstr "基础AiIDA教程后生成的可验证性图"

#: ../docs/source/intro/tutorial.rst:605
msgid "Next Steps"
msgstr "下一步"

#: ../docs/source/intro/tutorial.rst:607
msgid ""
"Congratulations! You have completed the first step to becoming an AiiDA "
"expert."
msgstr "恭喜！你成功完成了我们的初级试炼，成为AiiDA专家指日可待。"

#: ../docs/source/intro/tutorial.rst:609
msgid ""
"We have also compiled useful how-to guides that are especially relevant for "
"the following use cases:"
msgstr "我们还准备了非常实用的详细操作篇，对于下面的使用场景非常有用："

#: ../docs/source/intro/tutorial.rst:617
msgid "Designing a workflow"
msgstr "设计一个工作流"

#: ../docs/source/intro/tutorial.rst:617
msgid ""
"After reading the :ref:`Basic Tutorial <tutorial:basic>`, you may want to "
"learn about how to encode the logic of a typical scientific workflow in the "
":ref:`writing workflows how-to <how-to:write-workflows>`."
msgstr ""
"在完成阅读 :ref:`基础教程 <tutorial:basic>` 后，你可能想学习如何编写一个特定逻辑的科学工作流，那么请参考 "
":ref:`如何编写多步工作流<how-to:write-workflows>` 。"

#: ../docs/source/intro/tutorial.rst:620
msgid "Reusable data types"
msgstr "重用数据类型"

#: ../docs/source/intro/tutorial.rst:620
msgid ""
"If you have a certain input or output data type, which you use often, then "
"you may wish to turn it into its own :ref:`data plugin "
"<topics:data_types:plugin>`."
msgstr ""
"如果你有一个特定的输入或输出数据类型，且你会经常用到它，你可以将其封装成为一个 :ref:`数据插件 "
"<topics:data_types:plugin>`."

#: ../docs/source/intro/tutorial.rst:623 ../docs/source/intro/tutorial.rst:655
msgid "Exploring your data"
msgstr "探索你的数据"

#: ../docs/source/intro/tutorial.rst:623 ../docs/source/intro/tutorial.rst:655
msgid ""
"Once you have run multiple computations, the :ref:`find and query data how-"
"to <how-to:data:find>` can show you how to efficiently explore your data. "
"The data lineage can also be visualised as a :ref:`provenance graph <how-"
"to:data:visualise-provenance>`."
msgstr ""
"当你运行了许多的计算任务后 :ref:`查找并访问篇 <how-to:data:find>` 会告诉你如何高效的探索你的数据。可以通过 "
":ref:`可验证性图 <how-to:data:visualise-provenance>` 来直观地查看数据之间的流向关系。"

#: ../docs/source/intro/tutorial.rst:626 ../docs/source/intro/tutorial.rst:658
msgid "Sharing your data"
msgstr "分享你的数据"

#: ../docs/source/intro/tutorial.rst:626 ../docs/source/intro/tutorial.rst:658
msgid ""
"You can export all or part of your data to file with the :ref:`export/import"
" functionality<how-to:share:archives>` or you can even serve your data over "
"HTTP(S) using the :ref:`AiiDA REST API <how-to:share:serve>`."
msgstr ""
"你可以使用:ref: ' export/import功能'导出全部或部分数据到文件中，或者你甚至可以使用:ref: ' AiiDA REST API "
"'通过HTTP(S)提供数据。"

#: ../docs/source/intro/tutorial.rst:628
msgid "Sharing your workflows"
msgstr "分享你的工作流"

#: ../docs/source/intro/tutorial.rst:629
msgid ""
"Once you have a working computation workflow, you may also wish to "
":ref:`package it into a python module <how-to:plugins-develop>` for others "
"to use."
msgstr "一旦你有了一个工作的计算工作流，你可能还希望:ref: '将它打包到一个python模块'供其他人使用。"

#: ../docs/source/intro/tutorial.rst:636 ../docs/source/intro/tutorial.rst:652
msgid "Working with external codes"
msgstr "运行外部计算代码"

#: ../docs/source/intro/tutorial.rst:635 ../docs/source/intro/tutorial.rst:651
msgid ""
"Existing calculation plugins, for interfacing with external codes, are "
"available on the `aiida plugin registry <https://aiidateam.github.io/aiida-"
"registry/>`_. If none meet your needs, then the :ref:`external codes how-to "
"<how-to:plugin-codes>` can show you how to create your own calculation "
"plugin."
msgstr ""
"现有的计算插件，用于与外部代码接口，可在' aiida插件注册' _。如果没有满足你的需要，那么:ref: ' external codes how-"
"to '可以告诉你如何创建自己的计算插件。"

#: ../docs/source/intro/tutorial.rst:639
msgid "Tuning performance"
msgstr "性能提升"

#: ../docs/source/intro/tutorial.rst:639
msgid ""
"To optimise the performance of AiiDA for running many concurrent "
"computations see the :ref:`tuning performance how-to <how-"
"to:installation:performance>`."
msgstr "要优化AiiDA的性能以运行许多并发计算，请参阅:ref:“性能调优指南”。"

#: ../docs/source/intro/tutorial.rst:641
msgid "Saving computational resources"
msgstr "节省计算资源"

#: ../docs/source/intro/tutorial.rst:642
msgid ""
"AiiDA can cache and reuse the outputs of identical computations, as "
"described in the :ref:`caching how-to <how-to:run-codes:caching>`."
msgstr "AiiDA可以缓存和重用相同计算的输出，如:ref: ' caching how-to '所述"

#: ../docs/source/intro/tutorial.rst:648
msgid "Connecting to supercomputers"
msgstr "连接超算"

#: ../docs/source/intro/tutorial.rst:647
msgid ""
"To setup up a computer which can communicate with a high-performance "
"computer over SSH, see the :ref:`how-to for running external codes <how-to"
":run-codes>`, or add a :ref:`custom transport <how-to:plugin-"
"codes:transport>`. AiiDA has pre-written scheduler plugins to work with LSF,"
" PBSPro, SGE, Slurm and Torque."
msgstr ""
"要设置一台可以通过SSH与高性能计算机通信的计算机，请参阅:ref: ' how-to for running external codes "
"'，或添加:ref: ' custom transport '。AiiDA有预先编写的调度插件来工作与LSF, PBSPro, SGE, "
"Slurm和Torque。"

#: ../docs/source/intro/tutorial.rst:660
msgid "Sharing your calculation plugin"
msgstr "分享你的计算插件"

#: ../docs/source/intro/tutorial.rst:661
msgid ""
"Once you have a working plugin, you may also wish to :ref:`package it into a"
" python module <how-to:plugins-develop>` for others to use."
msgstr ""
"一旦你有了可用的插件，你可能想要 :ref:`将其打包为python模块 <how-to:plugins-develop>` 并与他人分享使用。"

#: ../docs/source/intro/tutorial.rst:665
msgid "Todo"
msgstr "Todo"

#: ../docs/source/intro/tutorial.rst:667
msgid ""
"Add to \"Connecting to supercomputers\": , or you can add a :ref:`custom "
"scheduler <how-to:plugin-codes:scheduler>`."
msgstr ""
"Add to \"Connecting to supercomputers\": , or you can add a :ref:`custom "
"scheduler <how-to:plugin-codes:scheduler>`."
