# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2020, ECOLE POLYTECHNIQUE FEDERALE DE LAUSANNE (Theory and Simulation of Materials (THEOS) and National Centre for Computational Design and Discovery of Novel Materials (NCCR MARVEL)), Switzerland and ROBERT BOSCH LLC, USA. All rights reserved
# This file is distributed under the same license as the AiiDA package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Jusong Yu <jusong.yeu@gmail.com>, 2023
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: AiiDA 2.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-12-23 19:17+0000\n"
"PO-Revision-Date: 2023-12-21 01:39+0000\n"
"Last-Translator: Jusong Yu <jusong.yeu@gmail.com>, 2023\n"
"Language-Team: Chinese (China) (https://app.transifex.com/aiidateam/teams/98967/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../source/internals/engine.rst:5
msgid "Engine"
msgstr "Engine"

#: ../../source/internals/engine.rst:12
msgid "Controlling caching"
msgstr "控制缓存"

#: ../../source/internals/engine.rst:16
msgid ""
"This section covers some details of the caching mechanism which are not "
"discussed in the :ref:`topics section <topics:provenance:caching>`. If you "
"are developing plugins and want to modify the caching behavior of your "
"classes, we recommend you read that section first."
msgstr ""
"本节涉及缓存机制的一些细节，这些细节在 :ref:`topics 章节 <topics:provenance:caching>` "
"中没有讨论。如果您正在开发插件并希望修改类的缓存行为，我们建议您先阅读该部分。"

#: ../../source/internals/engine.rst:19
msgid ""
"There are several methods which the internal classes of AiiDA use to control"
" the caching mechanism:"
msgstr "AiiDA 的内部类使用几种方法来控制缓存机制："

#: ../../source/internals/engine.rst:21
msgid "On the level of the generic :class:`orm.Node <aiida.orm.Node>` class:"
msgstr "在通用 :class:`orm.Node <aiida.orm.Node>` 类的层面上："

#: ../../source/internals/engine.rst:23
msgid ""
"The :meth:`~aiida.orm.nodes.caching.NodeCaching.is_valid_cache` property "
"determines whether a particular node can be used as a cache. This is used "
"for example to disable caching from failed calculations."
msgstr ""
" :meth:`~aiida.orm.nodes.caching.NodeCaching.is_valid_cache` "
"属性决定特定节点是否可用作缓存。例如，它可用于禁用计算失败后的缓存。"

#: ../../source/internals/engine.rst:25
msgid ""
"Node classes have a ``_cachable`` attribute, which can be set to ``False`` "
"to completely switch off caching for nodes of that class. This avoids "
"performing queries for the hash altogether."
msgstr ""
"节点类有一个 ``_cachable`` 属性，可将其设置为 ``False``，以完全关闭该类节点的缓存。这样就可以完全避免执行散列查询。"

#: ../../source/internals/engine.rst:28
msgid ""
"On the level of the :class:`Process "
"<aiida.engine.processes.process.Process>` and :class:`orm.ProcessNode "
"<aiida.orm.ProcessNode>` classes:"
msgstr ""
"在 :class:`Process <aiida.engine.processes.process.Process>` 和 "
":class:`orm.ProcessNode <aiida.orm.ProcessNode>` 类的级别上："

#: ../../source/internals/engine.rst:30
msgid ""
"The :meth:`ProcessNodeCaching.is_valid_cache "
"<aiida.orm.nodes.process.process.ProcessNodeCaching.is_valid_cache>` calls "
":meth:`Process.is_valid_cache "
"<aiida.engine.processes.process.Process.is_valid_cache>`, passing the node "
"itself. This can be used in :class:`~aiida.engine.processes.process.Process`"
" subclasses (e.g. in calculation plugins) to implement custom ways of "
"invalidating the cache."
msgstr ""
" :meth:`ProcessNodeCaching.is_valid_cache "
"<aiida.orm.nodes.process.process.ProcessNodeCaching.is_valid_cache>` 调用 "
":meth:`Process.is_valid_cache<aiida.engine.process.process.Process.is_valid_cache>`，传递节点本身。这可以在"
" :class:`~aiida.engine.processes.process.Process` "
"子类（例如计算插件）中使用，以实现自定义的缓存失效方式。"

#: ../../source/internals/engine.rst:32
msgid ""
"The :meth:`ProcessNodeCaching._hash_ignored_inputs "
"<aiida.orm.nodes.process.process.ProcessNodeCaching._hash_ignored_inputs>` "
"attribute lists the inputs that should be ignored when creating the hash. "
"This is checked by the :meth:`ProcessNodeCaching._get_objects_to_hash "
"<aiida.orm.nodes.process.process.ProcessNodeCaching._get_objects_to_hash>` "
"method."
msgstr ""
" :meth:`ProcessNodeCaching._hash_ignored_inputs "
"<aiida.orm.nodes.process.process.ProcessNodeCaching._hash_ignored_inputs>` "
"属性列出了创建哈希值时应忽略的输入。 :meth:`ProcessNodeCaching._get_objects_to_hash "
"<aiida.orm.nodes.process.process.ProcessNodeCaching._get_objects_to_hash>` "
"方法会对此进行检查。"

#: ../../source/internals/engine.rst:34
msgid ""
"The :meth:`Process.is_valid_cache "
"<aiida.engine.processes.process.Process.is_valid_cache>` is where the "
":meth:`exit_codes "
"<aiida.engine.processes.process_spec.ProcessSpec.exit_code>` that have been "
"marked by ``invalidates_cache`` are checked."
msgstr ""
" :meth:`Process.is_valid_cache "
"<aiida.engine.processes.process.Process.is_valid_cache>` 是检查  "
"``invalidates_cache`` 标记的  :meth:`exit_codes "
"<aiida.engine.processes.process_spec.ProcessSpec.exit_code>` 的位置。"

#: ../../source/internals/engine.rst:38
msgid "The ``WorkflowNode`` example"
msgstr "``WorkflowNode`` 示例"

#: ../../source/internals/engine.rst:40
msgid ""
"As discussed in the :ref:`topic section "
"<topics:provenance:caching:limitations>`, nodes which can have ``RETURN`` "
"links cannot be cached. This is enforced on two levels:"
msgstr ""
"正如  :ref:`topic section <topics:provenance:caching:limitations>` "
"中所讨论的，不能缓存可能有  ``RETURN`` 链接的节点。这在两个层面上强制执行："

#: ../../source/internals/engine.rst:43
msgid ""
"The ``_cachable`` property is set to ``False`` in the "
":class:`~aiida.orm.Node`, and only re-enabled in "
":class:`~aiida.orm.nodes.process.calculation.calculation.CalculationNode` "
"(which affects CalcJobs and calcfunctions). This means that a "
":class:`~aiida.orm.nodes.process.workflow.workflow.WorkflowNode` will not be"
" cached."
msgstr ""
"在  :class:`~aiida.orm.Node` 中， ``_cachable`` 属性被设置为  ``False``，只有在  "
":class:`~aiida.orm.nodes.process.calculation.calculation.CalculationNode` "
"中才重新启用（影响 CalcJobs 和 calcfunctions）。这意味着  "
":class:`~aiida.orm.nodes.process.workflow.workflow.WorkflowNode` 不会被缓存。"

#: ../../source/internals/engine.rst:45
msgid ""
"The ``_store_from_cache`` method, which is used to \"clone\" an existing "
"node, will raise an error if the existing node has any ``RETURN`` links. "
"This extra safe-guard prevents cases where a user might incorrectly override"
" the ``_cachable`` property on a ``WorkflowNode`` subclass."
msgstr ""
"``_store_from_cache`` 方法用于 ``克隆``现有节点，如果现有节点有任何  ``RETURN`` "
"链接，该方法将引发错误。这种额外的安全保护可以防止用户错误地覆盖  ``WorkflowNode`` 子类上的  ``_cachable`` 属性。"

#: ../../source/internals/index.rst:3
msgid "Internal architecture"
msgstr "内部结构"

#: ../../source/internals/index.rst:12
msgid "Todo"
msgstr "Todo"

#: ../../source/internals/index.rst:14
msgid "global_design"
msgstr "global_design"

#: ../../source/internals/plugin_system.rst:5
msgid "Plugin system"
msgstr "插件系统"

#: ../../source/internals/plugin_system.rst:7
msgid ""
"This page explains how to contribute to the plugin system in ``aiida-core``."
" For instrucions on how to develop plugins, see :ref:`how-to:plugins-"
"develop`."
msgstr ""
"本页解释了如何为  ``aiida-core`` 的插件系统做出贡献。有关如何开发插件的说明，请参阅  :ref:`how-to:plugins-"
"develop`。"

#: ../../source/internals/plugin_system.rst:11
msgid "Design Principles"
msgstr "设计原则"

#: ../../source/internals/plugin_system.rst:13
msgid "Only restrict plugin developers when really necessary;"
msgstr "只有在真正必要时才限制插件开发人员；"

#: ../../source/internals/plugin_system.rst:15
msgid "Avoid database schema changes whenever reasonably possible;"
msgstr "尽可能避免更改数据库模式；"

#: ../../source/internals/plugin_system.rst:17
msgid ""
"Finding and loading plugins must be as fast as the plugin allows, especially"
" for command line interface (CLI) commands. In other words, directly "
"importing a plugin class should not be noticeably faster than using the "
"plugin loader/factory;"
msgstr ""
"查找和加载插件的速度必须在插件允许的范围内，尤其是命令行界面（CLI）命令。换句话说，直接导入插件类的速度不应明显快于使用插件加载器/工厂；"

#: ../../source/internals/plugin_system.rst:20
msgid ""
"Implement as a drop-in replacement, provide backwards compatibility to "
"pre-0.9 plugin system;"
msgstr "以直接替换的方式实施，向后兼容 0.9 之前的插件系统；"

#: ../../source/internals/plugin_system.rst:22
msgid ""
"Plugin management should be as user friendly from the verdi shell as from "
"the CLI."
msgstr "插件管理应与 CLI 一样，通过 verdi shell 方便易用。"

#: ../../source/internals/plugin_system.rst:25
msgid "Mini-Spec"
msgstr "Mini-Spec"

#: ../../source/internals/plugin_system.rst:28
msgid "Nomenclature"
msgstr "术语"

#: ../../source/internals/plugin_system.rst:35
msgid "``plugin_name``"
msgstr "``plugin_name``"

#: ../../source/internals/plugin_system.rst:30
msgid "A unique name identifying the plugin. Suggested naming scheme is"
msgstr "标识插件的唯一名称。建议命名方案为"

#: ../../source/internals/plugin_system.rst:32
msgid "``aiida-<plugin-name>`` for pypi distribution / source code repository"
msgstr "``aiida-<plugin-name>`` 用于 pypi 发行版/源代码库"

#: ../../source/internals/plugin_system.rst:33
msgid ""
"``aiida_<plugin_name>`` for python package (``import aiida_<plugin_name>``; "
"dashes replaced by underscores)"
msgstr ""
"``aiida_<plugin_name>`` 用于 python 软件包 ( ``import "
"aiida_<plugin_name>``；破折号用下划线代替)"

#: ../../source/internals/plugin_system.rst:34
msgid "``<plugin_name>.ep_name`` for entry points"
msgstr "``<plugin_name>.ep_name`` for entry points"

#: ../../source/internals/plugin_system.rst:41
msgid "``category``"
msgstr "``category``"

#: ../../source/internals/plugin_system.rst:38
msgid ""
"A name given to each aspect of AiiDA that can be extended via plugins, such "
"as ``calculations``, ``schedulers``, ... (see output of ``verdi plugin "
"list`` for a complete list)."
msgstr ""
"为 AiiDA 的每个方面命名，可通过插件进行扩展，如  ``calculations``、 ``schedulers``......（完整列表请参见"
"  ``verdi plugin list`` 的输出）。"

#: ../../source/internals/plugin_system.rst:41
msgid "Each category maps to an *entry point group* ``aiida.<category>``."
msgstr "每个类别映射到一个 *entry point 组*  ``aiida.<category>``。"

#: ../../source/internals/plugin_system.rst:44
msgid "Interfaces"
msgstr "接口"

#: ../../source/internals/plugin_system.rst:47
msgid "Pluginloader"
msgstr "插件加载器"

#: ../../source/internals/plugin_system.rst:48
msgid ""
"The plugin loading functionality is defined in "
":py:mod:`aiida.plugins.entry_point`."
msgstr "插件加载功能在  :py:mod:`aiida.plugins.entry_point` 中定义。"

#: ../../source/internals/plugin_system.rst:51
msgid "Registry Tools"
msgstr "注册表工具"

#: ../../source/internals/plugin_system.rst:52
msgid "See the API documentation in :py:mod:`aiida.plugins`."
msgstr "请参阅 :py:mod:`aiida.plugins` 中的 API 文档。"

#: ../../source/internals/rest_api.rst:8
msgid "REST API"
msgstr "REST API"

#: ../../source/internals/rest_api.rst:10
msgid "The AiiDA REST API is made of two main classes:"
msgstr "AiiDA REST API 由两个主要类组成："

#: ../../source/internals/rest_api.rst:12
msgid ""
"``App``, inheriting from ``flask.Flask`` (generic class for Flask web "
"applications)."
msgstr "``App``，继承自  ``flask.Flask``。"

#: ../../source/internals/rest_api.rst:13
msgid ""
"``AiidaApi``, inheriting ``flask_restful.Api``. This class defines the "
"resources served by the REST API."
msgstr "``AiidaApi``，继承于  ``flask_restful.Api``。该类定义了 REST API 提供的资源。"

#: ../../source/internals/rest_api.rst:15
msgid ""
"The instances of both ``AiidaApi`` (let's call it ``api``) and ``App`` "
"(let's call it ``app``) need to be coupled by setting ``api.app = app``."
msgstr ""
"需要通过设置  ``api.app = app`` 将  ``AiidaApi``（我们称之为  ``api``）和  ``App``（我们称之为  "
"``app``）的实例耦合起来。"

#: ../../source/internals/rest_api.rst:19
msgid "Extending the REST API"
msgstr "扩展 REST API"

#: ../../source/internals/rest_api.rst:21
msgid ""
"In the following, we will go through a minimal example of creating an API "
"that extends the AiiDA REST API by adding an endpoint ``/new-endpoint``. The"
" endpoint implements a ``GET`` request that retrieves the latest created "
"``Dict`` node and returns its ``id``, ``ctime`` in ISO 8601 format, and "
"``attributes``."
msgstr ""
"下面，我们将通过一个最小的示例来创建一个 API，通过添加一个端点  ``/new-endpoint`` 来扩展 AiiDA REST API。端点实现"
"  ``GET`` 请求，检索最新创建的  ``Dict`` 节点，并返回其  ``id``、ISO 8601 格式的  ``ctime`` 和  "
"``attributes``。"

#: ../../source/internals/rest_api.rst:26
msgid ""
"The REST API is currently read-only and does not support end-points that "
"create new data or mutate existing data in the database. See `this AiiDA "
"enhancement proposal draft <https://github.com/aiidateam/AEP/pull/24>`_ for "
"efforts in this direction."
msgstr ""
"REST API 目前是只读的，不支持在数据库中创建新数据或更改现有数据的端点。请参阅  `this AiiDA enhancement "
"proposal draft <https://github.com/aiidateam/AEP/pull/24>`_ 了解这方面的努力。"

#: ../../source/internals/rest_api.rst:29
msgid "In order to achieve this, we will need to:"
msgstr "为了实现这一目标，我们需要"

#: ../../source/internals/rest_api.rst:31
msgid ""
"Create the ``flask_restful.Resource`` class that will be bound to the new "
"endpoint."
msgstr "创建将绑定到新端点的  ``flask_restful.Resource`` 类。"

#: ../../source/internals/rest_api.rst:32
msgid ""
"Extend the :py:class:`~aiida.restapi.api.AiidaApi` class in order to "
"register the new endpoint."
msgstr "扩展 :py:class:`~aiida.restapi.api.AiidaApi` 类，以注册新的端点。"

#: ../../source/internals/rest_api.rst:33
msgid ""
"(Optional) Extend the :py:class:`~aiida.restapi.api.App` class for "
"additional customization."
msgstr "(可选）扩展  :py:class:`~aiida.restapi.api.App` 类以进行更多定制。"

#: ../../source/internals/rest_api.rst:35
msgid "Let's start by putting the following code into a  file ``api.py``:"
msgstr "让我们先将以下代码放入文件  ``api.py``："

#: ../../source/internals/rest_api.rst:39
msgid "We will now go through the previous code step by step."
msgstr "现在，我们将一步一步地查看之前的代码。"

#: ../../source/internals/rest_api.rst:41
msgid "First things first: the imports."
msgstr "首先是 imports。"

#: ../../source/internals/rest_api.rst:49
msgid ""
"To start with, we import the base classes to be extended/employed: "
"``AiidaApi`` and ``App``. For simplicity, it is advisable to import the "
"method ``run_api``, as it provides an interface to configure the API, parse "
"command-line arguments, and couple the two classes representing the API and "
"the App. However, you can refer to the documentation of `flask_restful "
"<https://flask-restful.readthedocs.io/>`_ to configure and hook-up an API "
"through its built-in methods."
msgstr ""
"首先，我们需要 import 扩展/使用基类： ``AiidaApi`` 和  ``App``。为简单起见，建议使用 import 方法  "
"``run_api``，因为它提供了配置 API、解析 command-line 参数以及将代表 API "
"和应用程序的两个类结合起来的接口。不过，您可以参考  `flask_restful <https://flask-"
"restful.readthedocs.io/>`_ 的文档，通过其 built-in 方法配置和 hook-up API。"

#: ../../source/internals/rest_api.rst:53
msgid "Then we define a class representing the additional resource:"
msgstr "然后，我们定义一个代表附加资源的类："

#: ../../source/internals/rest_api.rst:75
msgid ""
"The class ``NewResource`` contains a single method ``get``. The name chosen "
"for this method is not arbitrary but fixed by ``Flask`` which is called to "
"respond to HTTP GET requests. In other words, when the API receives a GET "
"request to the URL ``new-endpoint``, the function ``NewResource.get()`` is "
"called. The HTTP response is constructed around the data returned by these "
"functions. The data, which are packed as dictionaries, are serialized by "
"Flask as a JSON stream of data. All the Python built-in types can be "
"serialized by Flask (e.g. ``int``, ``float``, ``str``, etc.), whereas for "
"serialization of custom types we let you refer to the `Flask documentation "
"<http://flask.pocoo.org/docs/>`_ . The documentation of Flask is the main "
"source of information also for topics such as customization of HTTP "
"responses, construction of custom URLs (e.g. accepting parameters), and more"
" advanced serialization issues."
msgstr ""
"类  ``NewResource`` 包含一个方法  ``get``。为该方法选择的名称不是任意的，而是由  ``Flask`` 固定的，它被调用来响应"
" HTTP GET 请求。换句话说，当 API 收到指向 URL  ``new-endpoint`` 的 GET 请求时，函数  "
"``NewResource.get()`` 就会被调用。HTTP 响应是围绕这些函数返回的数据构建的。这些数据被打包成字典，由 Flask 序列化为 "
"JSON 数据流。Flask 可以序列化所有 Python built-in 类型（如  ``int``、 ``float``、 ``str`` "
"等），而对于自定义类型的序列化，我们让您参考  `Flask documentation "
"<http://flask.pocoo.org/docs/>`_。Flask 文档也是自定义 HTTP 响应、构建自定义 "
"URL（如接受参数）和更高级序列化问题等主题的主要信息来源。"

#: ../../source/internals/rest_api.rst:83
msgid ""
"Whenever you face the need to handle errors, consider to use the AiiDA REST "
"API-specific exceptions already defined in  "
":py:class:`aiida.restapi.common.exceptions`. The reason will become clear "
"slightly later in this section."
msgstr ""
"当你需要处理错误时，可以考虑使用 :py:class:`aiida.restapi.common.exceptions` 中已经定义的 AiiDA "
"REST API-specific 异常。原因将在本节稍后部分阐明。"

#: ../../source/internals/rest_api.rst:86
msgid ""
"Once the new resource is defined, we have to register it to the API by "
"assigning it one (or more) endpoint(s). This is done in the ``__init__()`` "
"of ``NewApi`` by means of the method ``add_resource()``:"
msgstr ""
"一旦定义了新资源，我们就必须通过分配一个（或多个）端点将其注册到 API 中。这是通过 ``add_resource()`` 方法在 "
"``NewApi`` 的 ``__init__()`` 中完成的："

#: ../../source/internals/rest_api.rst:102
msgid ""
"In our original intentions, the main (if not the only) purpose of overriding"
" the ``__init__()`` method is to register new resources to the API. In fact,"
" the general form of ``__init__()`` is meant to be:"
msgstr ""
"按照我们的初衷，覆盖 ``__init__()`` 方法的主要目的（如果不是唯一目的的话）是向 API 注册新资源。事实上，``__init__()``"
" 的一般形式是："

#: ../../source/internals/rest_api.rst:119
msgid ""
"In the example, indeed, the only characteristic line is "
":python:`self.add_resource(NewResource, '/new-endpoint/', "
"strict_slashes=False)`. Anyway, the method ``add_resource()`` is defined and"
" documented in `Flask <http://flask.pocoo.org/docs/>`_."
msgstr ""
"在示例中，唯一的特征线是 :python:`self.add_resource(NewResource, '/new-endpoint/', "
"strict_slashes=False)`。总之，``add_resource()`` 方法已在 `Flask "
"<http://flask.pocoo.org/docs/>`_ 中定义和记录。"

#: ../../source/internals/rest_api.rst:122
msgid "Finally, the ``main`` code configures and runs the API:"
msgstr "最后，``main`` 代码会配置并运行应用程序接口："

#: ../../source/internals/rest_api.rst:161
msgid ""
"The `click package <https://click.palletsprojects.com/en/7.x/>`_ is used to "
"provide a a nice command line interface to process the options and handle "
"the default values to pass to the ``newendpoint`` function."
msgstr ""
"`click package <https://click.palletsprojects.com/en/7.x/>`_ "
"用于提供一个漂亮的命令行界面，以处理选项并处理传递给 ``newendpoint`` 函数的默认值。"

#: ../../source/internals/rest_api.rst:163
msgid ""
"The method ``run_api()`` accomplishes several functions: it couples the API "
"to an instance of ``flask.Flask``, namely, the Flask fundamental class "
"representing a web app. Consequently, the app is configured and, if "
"required, hooked up."
msgstr ""
"方法 ``run_api()`` 完成了几个功能：它将 API 与 ``flask.Flask`` （即代表网络应用的 Flask "
"基本类）的实例耦合。这样，应用程序就配置好了，如果需要，还可以连接起来。"

#: ../../source/internals/rest_api.rst:166
msgid "It takes as inputs:"
msgstr "它需要输入"

#: ../../source/internals/rest_api.rst:169
msgid "the classes representing the API and the application."
msgstr "代表应用程序接口和应用程序的类。"

#: ../../source/internals/rest_api.rst:169
msgid ""
"We strongly suggest to pass to ``run_api()`` the "
":py:class:`aiida.restapi.api.App` class, inheriting from ``flask.Flask``, as"
" it handles correctly AiiDA RESTApi-specific exceptions."
msgstr ""
"我们强烈建议将继承自 ``flask.Flask`` 的 :py:class:`aiida.restapi.api.App` 类传给 "
"``run_api()``，因为它能正确处理 AiiDA RESTApi-specific 异常。"

#: ../../source/internals/rest_api.rst:173
msgid ""
"positional arguments representing the command-line arguments/options, passed"
" by the click function."
msgstr "位置参数，代表点击函数传递的 command-line 参数/选项。"

#: ../../source/internals/rest_api.rst:172
msgid ""
"Types, defaults and help strings can be set in the ``@click.option`` "
"definitions, and will be handled by the command line call."
msgstr "类型、默认值和帮助字符串可在 ``@click.option`` 定义中设置，并由命令行调用处理。"

#: ../../source/internals/rest_api.rst:175
msgid "A few more things before using the script:"
msgstr "使用脚本前还有几件事要做："

#: ../../source/internals/rest_api.rst:177
msgid ""
"if you want to customize further the error handling, you can take "
"inspiration by looking at the definition of ``App`` and create your derived "
"class ``NewApp(App)``."
msgstr "如果您想进一步自定义错误处理，可以从 ``App`` 的定义中获得灵感，创建派生类 ``NewApp(App)``。"

#: ../../source/internals/rest_api.rst:182
msgid ""
"the supported command line options are identical to those of ``verdi "
"restapi``."
msgstr "支持的命令行选项与 ``verdi restapi`` 相同。"

#: ../../source/internals/rest_api.rst:181
msgid ""
"Use ``verdi restapi --help`` for their full documentation. If you want to "
"add more options or modify the existing ones, create you custom runner "
"taking inspiration from ``run_api``."
msgstr ""
"请使用 ``verdi restapi --help`` 查阅其完整文档。如果您想添加更多选项或修改现有选项，请从 ``run_api`` "
"中汲取灵感，创建自定义运行程序。"

#: ../../source/internals/rest_api.rst:184
msgid "It is time to run ``api.py``. Type in a terminal"
msgstr "现在是运行 ``api.py`` 的时候了。在终端中键入"

#: ../../source/internals/rest_api.rst:198
msgid ""
"Let's use ``curl`` with the GET method to ask for the latest created node:"
msgstr "让我们使用 ``curl`` 和 GET 方法来查询最新创建的 node："

#: ../../source/internals/rest_api.rst:204
msgid "The form of the output (and only the form) should resemble"
msgstr "输出的形式（也仅是形式）应类似于"

#: ../../source/internals/rest_api.rst:217
msgid ""
"whereas the actual values of the response dictionary as well as the internal"
" structure of the attributes field will be in general very different."
msgstr "而响应字典的实际值和属性字段的内部结构一般会有很大不同。"

#: ../../source/internals/rest_api.rst:219
msgid ""
"As a final remark, there might be circumstances in which you do not want to "
"use the internal werkzeug-based server. For example, you might want to run "
"the app through Apache using a wsgi script. In this case, simply use "
"``configure_api`` to return a custom object ``api``:"
msgstr ""
"最后要说的是，在某些情况下，您可能不想使用内部 werkzeug-based 服务器。例如，您可能希望使用 wsgi 脚本通过 Apache "
"运行应用程序。在这种情况下，只需使用 ``configure_api`` 返回自定义对象 ``api``："

#: ../../source/internals/rest_api.rst:228
msgid ""
"The ``app`` can be retrieved by ``api.app``. This snippet of code becomes "
"the fundamental block of a *wsgi* file used by Apache as documented in  "
":ref:`how-to:share:serve:deploy`. Moreover, we recommend to consult the "
"documentation of `mod_wsgi <https://modwsgi.readthedocs.io/>`_."
msgstr ""
"通过 ``api.app`` 可以检索到 ``app``。如 :ref:`how-to:share:serve:deploy` 所述，该代码片段成为 "
"Apache 使用的 *wsgi* 文件的基本模块。此外，我们建议查阅 `mod_wsgi "
"<https://modwsgi.readthedocs.io/>`_ 的文档。"

#: ../../source/internals/rest_api.rst:233
msgid ""
"Optionally, create a click option for the variable ``catch_internal_server``"
" to be ``False`` in order to let exceptions (including python tracebacks) "
"bubble up to the apache error log. This can be particularly useful when the "
"``app`` is still under heavy development."
msgstr ""
"可选择将 ``catch_internal_server`` 变量创建为 ``False``，以便让异常（包括 python 回溯）涌入 apache "
"错误日志。这在 ``app`` 仍处于开发阶段时尤其有用。"

#: ../../source/internals/rest_api.rst:240
msgid "Serving multiple profiles"
msgstr "为多个配置文件提供服务"

#: ../../source/internals/rest_api.rst:242
msgid ""
"A single REST API instance can serve data from all profiles of an AiiDA "
"instance. To maintain backwards compatibility, the new functionality needs "
"to be explicitly enabled through the configuration:"
msgstr "单个 REST API 实例可以为 AiiDA 实例的所有配置文件提供数据。为了保持向后兼容性，新功能需要通过配置明确启用："

#: ../../source/internals/rest_api.rst:249
msgid ""
"After the REST API is restarted, it will now accept the profile query "
"parameter, for example:"
msgstr "重新启动 REST API 后，它将接受配置文件查询参数，例如"

#: ../../source/internals/rest_api.rst:255
msgid ""
"If the specified profile is already loaded, the REST API functions exactly "
"as without profile switching enabled. If another profile is specified, the "
"REST API will first switch profiles before executing the request. If the "
"profile parameter is specified in a request and the REST API does not have "
"profile switching enabled, a 400 response is returned."
msgstr ""
"如果指定的配置文件已加载，REST API 的功能与未启用配置文件切换时完全相同。如果指定了另一个配置文件，REST API "
"会在执行请求前首先切换配置文件。如果在请求中指定了配置文件参数，而 REST API 未启用配置文件切换功能，则会返回 400 响应。"

#: ../../source/internals/storage/architecture.rst:4
msgid "General architecture"
msgstr "总体结构"

#: ../../source/internals/storage/architecture.rst:6
msgid ""
"The storage of data is an important aspect of the AiiDA system. The design "
"for this subsystem is illustrated below."
msgstr "数据存储是 AiiDA 系统的一个重要方面。该子系统的设计如下图所示。"

#: ../../source/internals/storage/architecture.rst:13
msgid "UML diagram of the storage architecture."
msgstr "存储架构的 UML 图。"

#: ../../source/internals/storage/architecture.rst:15
msgid ""
"Blue indicates frontend classes, red indicates backend classes, and green "
"indicates singletons."
msgstr "蓝色表示前台类，红色表示后台类，绿色表示单子。"

#: ../../source/internals/storage/architecture.rst:17
msgid ""
"Separate data is stored per ``Profile``, forming a single provenance graph. "
"A :py:class:`~aiida.manage.configuration.profile.Profile` instance "
"represents a dictionary that includes the configuration details for "
"accessing the storage for that profile, such as a database URI, etc. "
"Multiple ``Profile`` can be stored in a "
":py:class:`~aiida.manage.configuration.config.Config` instance, which is "
"stored in the configuration file (``config.json``)."
msgstr ""
"每个 ``Profile`` 存储不同的数据，形成一个 provenance "
"图形。:py:class:`~aiida.manage.configuration.profile.Profile` "
"实例代表一个字典，其中包括访问该配置文件存储的配置细节，如数据库 URI 等。多个 ``Profile`` 可存储在一个 "
":py:class:`~aiida.manage.configuration.config.Config` 实例中，该实例存储在配置文件 "
"(``config.json``) 中。"

#: ../../source/internals/storage/architecture.rst:21
msgid ""
"Within a single Python process, a single "
":py:class:`~aiida.manage.manager.Manager` instance can be loaded, to manage "
"access to a globally loaded ``Profile`` and its "
":py:class:`~aiida.orm.implementation.storage_backend.StorageBackend` "
"instance."
msgstr ""
"在单个 Python 进程中，可以加载单个 :py:class:`~aiida.manage.manager.Manager` 实例，以管理对全局加载的"
" ``Profile`` 及其 "
":py:class:`~aiida.orm.implementation.storage_backend.StorageBackend` 实例的访问。"

#: ../../source/internals/storage/architecture.rst:23
msgid ""
"The storage API subsystem is based on an Object Relational Mapper (ORM) and "
"is divided into two main parts: the frontend and the backend. The frontend "
"is responsible for the user interface, and is agnostic of any particular "
"storage technologies, and the backend is responsible for implementing "
"interfaces with specific technologies (such as SQL databases)."
msgstr ""
"存储 API 子系统基于对象关系映射器（ORM），分为两个主要部分：前台和后台。前端负责用户界面，与任何特定的存储技术无关；后端负责实现与特定技术（如 "
"SQL 数据库）的接口。"

#: ../../source/internals/storage/architecture.rst:30
msgid "Frontend ORM"
msgstr "前端 ORM"

#: ../../source/internals/storage/architecture.rst:32
msgid ""
"The frontend ORM comprises of a number of "
":py:class:`~aiida.orm.entities.Collection` and "
":py:class:`~aiida.orm.entities.Entity` subclasses, representing access to a "
"single ORM type."
msgstr ""
"前端 ORM 由多个 :py:class:`~aiida.orm.entities.Collection` 和 "
":py:class:`~aiida.orm.entities.Entity` 子类组成，代表对单一 ORM 类型的访问。"

#: ../../source/internals/storage/architecture.rst:34
msgid ":py:class:`~aiida.orm.User`"
msgstr ":py:class:`~aiida.orm.User`"

#: ../../source/internals/storage/architecture.rst:35
msgid "Represents the author of a particular entity."
msgstr "代表某个实体的作者。"

#: ../../source/internals/storage/architecture.rst:38
msgid ":py:class:`~aiida.orm.Node`"
msgstr ":py:class:`~aiida.orm.Node`"

#: ../../source/internals/storage/architecture.rst:37
msgid ""
"Represents a node in a provenance graph, containing data for a particular "
"process (:py:class:`~aiida.orm.ProcessNode`) or process input/output "
"(:py:class:`~aiida.orm.Data`). Nodes are connected by links, that form an "
"acyclic graph. Nodes also have a "
":py:class:`~aiida.repository.repository.Repository` instance, which is used "
"to store binary data of the node (see also :ref:`internal-"
"architecture:repository`)."
msgstr ""
"代表 provenance 图形中的 node，包含特定进程 (:py:class:`~aiida.orm.ProcessNode`) 或进程输入/输出"
" (:py:class:`~aiida.orm.Data`) 的数据。Node 由链接连接，形成非循环图。Node 也有一个 "
":py:class:`~aiida.repository.repository.Repository` 实例，用于存储 node 的二进制数据（另见 "
":ref:`internal-architecture:repository`）。"

#: ../../source/internals/storage/architecture.rst:40
msgid ":py:class:`~aiida.orm.Comment`"
msgstr ":py:class:`~aiida.orm.Comment`"

#: ../../source/internals/storage/architecture.rst:41
msgid "Represents a comment on a node, by a particular user."
msgstr "代表某个用户对 node 的评论。"

#: ../../source/internals/storage/architecture.rst:42
msgid ":py:class:`~aiida.orm.Log`"
msgstr ":py:class:`~aiida.orm.Log`"

#: ../../source/internals/storage/architecture.rst:43
msgid ""
"Represents a log message on a :py:class:`~aiida.orm.ProcessNode`, by a "
"particular user."
msgstr "代表特定用户在 :py:class:`~aiida.orm.ProcessNode` 上的日志信息。"

#: ../../source/internals/storage/architecture.rst:45
msgid ":py:class:`~aiida.orm.Group`"
msgstr ":py:class:`~aiida.orm.Group`"

#: ../../source/internals/storage/architecture.rst:45
msgid ""
"Represents a group of nodes. A single node can be part of multiple groups "
"(i.e. a one-to-many relationship)."
msgstr "代表一组 node。单个 node 可以是多个组的一部分（即 one-to-多关系）。"

#: ../../source/internals/storage/architecture.rst:48
msgid ":py:class:`~aiida.orm.Computer`"
msgstr ":py:class:`~aiida.orm.Computer`"

#: ../../source/internals/storage/architecture.rst:48
msgid ""
"Represents a compute resource on which a process is executed. A single "
"computer can be attached to multiple :py:class:`~aiida.orm.ProcessNode` "
"(i.e. a one-to-many relationship)."
msgstr ""
"代表执行进程的计算资源。一台计算机可连接多个 :py:class:`~aiida.orm.ProcessNode` （即 one-to-多关系）。"

#: ../../source/internals/storage/architecture.rst:51
msgid ":py:class:`~aiida.orm.AuthInfo`"
msgstr ":py:class:`~aiida.orm.AuthInfo`"

#: ../../source/internals/storage/architecture.rst:51
msgid ""
"Represents a authentication information for a particular computer and user."
msgstr "代表特定计算机和用户的身份验证信息。"

#: ../../source/internals/storage/architecture.rst:53
msgid ""
"The :py:class:`~aiida.orm.QueryBuilder` allows for querying of specific "
"entities and their associated data."
msgstr ":py:class:`~aiida.orm.QueryBuilder` 允许查询特定实体及其相关数据。"

#: ../../source/internals/storage/architecture.rst:56
msgid "Backend Implementations"
msgstr "后台实施"

#: ../../source/internals/storage/architecture.rst:58
msgid ""
"Backend implementations must implement the classes outlines in "
":py:mod:`aiida.orm.implementation`."
msgstr "后端实施必须实施 :py:mod:`aiida.orm.implementation` 中概述的类。"

#: ../../source/internals/storage/architecture.rst:60
msgid "There are currently two core backend implementations:"
msgstr "目前有两种核心后台实现方式："

#: ../../source/internals/storage/architecture.rst:62
msgid ""
"``psql_dos`` is implemented as the primary storage backend, see "
":ref:`internal_architecture:storage:psql_dos`."
msgstr ""
"``psql_dos`` 作为主存储后端实施，参见 :ref:`internal_architecture:storage:psql_dos`。"

#: ../../source/internals/storage/architecture.rst:63
msgid ""
"``sqlite_zip`` is implemented as a storage backend for the AiiDA archive, "
"see :ref:`internal_architecture:storage:sqlite_zip`."
msgstr ""
"``sqlite_zip`` 用作 AiiDA 存档的存储后端，参见 "
":ref:`internal_architecture:storage:sqlite_zip`。"

#: ../../source/internals/storage/architecture.rst:66
msgid "Storage maintenance and profile locking"
msgstr "存储维护和配置文件锁定"

#: ../../source/internals/storage/architecture.rst:68
msgid ""
"The "
":py:meth:`~aiida.orm.implementation.storage_backend.StorageBackend.maintain`"
" method is allows for maintenance operations on the storage (for example, to"
" optimise memory usage), and is called by `verdi storage maintain`."
msgstr ""
":py:meth:`~aiida.orm.implementation.storage_backend.StorageBackend.maintain`"
" 方法允许对存储进行维护操作（例如，优化内存使用），由 `verdi storage maintain` 调用。"

#: ../../source/internals/storage/architecture.rst:70
msgid ""
"During \"full\" maintenance, to guarantee the safety of its procedures, it "
"may be necessary that the storage is not accessed by other processes. The "
":py:class`~aiida.manage.profile_access.ProfileAccessManager` allows for "
"profile access requests, and locking of profiles during such procedures. "
":py:meth:`~aiida.manage.profile_access.ProfileAccessManager.request_access` "
"is called within "
":py:meth:`~aiida.manage.manager.Manager.get_profile_storage`."
msgstr ""
"在 \"full\" "
"维护期间，为保证其程序的安全，可能有必要禁止其他进程访问存储。:py:meth:`~aiida.manage.manager.Manager.get_profile_storage`"
" 内调用 :py:class`~aiida.manage.profile_access.ProfileAccessManager` allows for"
" profile access requests, and locking of profiles during such procedures. "
":py:meth:`~aiida.manage.profile_access.ProfileAccessManager.request_access`。"

#: ../../source/internals/storage/index.rst:2
msgid "Storage"
msgstr "存储"

#: ../../source/internals/storage/psql_dos.rst:4
msgid "``psql_dos`` format"
msgstr "``psql_dos`` 格式"

#: ../../source/internals/storage/psql_dos.rst:6
msgid ""
"The :py:class:`~aiida.storage.psql_dos.backend.PsqlDosBackend` is the "
"primary format for storing provenance data. It stores data in two places:"
msgstr ""
":py:class:`~aiida.storage.psql_dos.backend.PsqlDosBackend` 是存储 provenance "
"数据的主要格式。它将数据存储在两个位置："

#: ../../source/internals/storage/psql_dos.rst:9
msgid "A `PostgreSQL <https://www.postgresql.org/>`_ database."
msgstr "A `PostgreSQL <https://www.postgresql.org/>`_ 数据库。"

#: ../../source/internals/storage/psql_dos.rst:10
msgid ""
"A disk-objectstore repository (see :ref:`internal-"
"architecture:repository:dostore`)."
msgstr ""
"disk-objectstore 存储库（见 :ref:`internal-architecture:repository:dostore`）。"

#: ../../source/internals/storage/psql_dos.rst:12
msgid ""
"The database stores all \"JSONable\" entity data, organized into different "
"tables (closely related to AiiDA ORM entities) and columns/fields. Larger "
"binary data (such as input/output file content), required for nodes, are "
"stored in the disk-objectstore, and referenced by "
"`db_dbnode.repository_metadata` as a virtual file-system."
msgstr ""
"数据库存储了所有的实体数据，组织成不同的表格（与 AiiDA ORM 实体密切相关）和列/字段。node "
"所需的较大二进制数据（如输入/输出文件内容）存储在 disk-objectstore 中，并作为虚拟 file-system 被 "
"`db_dbnode.repository_metadata` 引用。"

#: ../../source/internals/storage/psql_dos.rst:15
msgid ""
"Interfacing with the database is achieved using the `sqlalchemy "
"<https://www.sqlalchemy.org/>`_ ORM API."
msgstr "使用 `sqlalchemy <https://www.sqlalchemy.org/>`_ ORM API 可实现与数据库的对接。"

#: ../../source/internals/storage/psql_dos.rst:19
msgid "The PostgreSQL database schema"
msgstr "PostgreSQL 数据库模式"

#: ../../source/internals/storage/psql_dos.rst:21
msgid ""
"The following section provides a complete schema for the PostgreSQL "
"database."
msgstr "下一节提供了 PostgreSQL 数据库的完整模式。"

#: ../../source/internals/storage/psql_dos.rst:24
#: ../../source/internals/storage/sqlite_zip.rst:88
msgid "Tables"
msgstr "表格"

#: ../../source/internals/storage/psql_dos.rst:26
msgid ""
"In all tables, the primary key that uniquely identifies each of their "
"members is a positive integer number in the ``id`` field. However, this "
"number is only unique within the table, and thus there can be a user with an"
" ``id`` of 2 and a node with an ``id`` of 2 in the same database (or, more "
"trivially, two different nodes both with an ``id`` of 2, each in a different"
" database)."
msgstr ""
"在所有表中，唯一标识每个成员的主键是 ``id`` 字段中的一个正整数。但是，这个数字在表内是唯一的，因此在同一个数据库中，可能存在一个 ``id`` "
"为 2 的用户和一个 ``id`` 为 2 的 node （或者，更简单地说，两个 ``id`` 为 2 的 node 在不同的数据库中）。"

#: ../../source/internals/storage/psql_dos.rst:29
msgid ""
"Most of the entities also have a ``uuid`` value. The ``uuid`` is meant to "
"serve as an identifier that is unique within all tables of all AiiDA "
"databases in the world. This is a 32-position hexadecimal sequence that is "
"stored as a string with some dash separated sections (for example: "
"``479a312d-e9b6-4bbb-93b4-f0a7174ccbf4``)."
msgstr ""
"大多数实体也有一个 ``uuid`` 值。``uuid`` 是全球所有 AiiDA 数据库表中唯一的标识符。这是一个 32-position "
"十六进制序列，以字符串形式存储，其中包含一些破折号分隔的部分（例如：``479a312d-e9b6-4bbb-93b4-f0a7174ccbf4``）。"

#: ../../source/internals/storage/psql_dos.rst:35
msgid "``*`` indicates columns with a unique constraint"
msgstr "``*`` 表示具有唯一约束的列"

#: ../../source/internals/storage/psql_dos.rst:36
msgid "``→`` indicate foreign keys"
msgstr "``→`` 指示外键"

#: ../../source/internals/storage/psql_dos.rst:37
msgid "``?`` indicate value types that are nullable."
msgstr "``?`` 表示可归零的值类型。"

#: ../../source/internals/storage/psql_dos.rst:40
msgid ""
"sqla-model:: ~aiida.storage.psql_dos.models.user.DbUser sqla-model:: "
"~aiida.storage.psql_dos.models.node.DbNode sqla-model:: "
"~aiida.storage.psql_dos.models.node.DbLink sqla-model:: "
"~aiida.storage.psql_dos.models.group.DbGroup sqla-model:: "
"~aiida.storage.psql_dos.models.group.DbGroupNode sqla-model:: "
"~aiida.storage.psql_dos.models.computer.DbComputer sqla-model:: "
"~aiida.storage.psql_dos.models.authinfo.DbAuthInfo sqla-model:: "
"~aiida.storage.psql_dos.models.comment.DbComment sqla-model:: "
"~aiida.storage.psql_dos.models.log.DbLog sqla-model:: "
"~aiida.storage.psql_dos.models.settings.DbSetting"
msgstr ""
"sqla-model:: ~aiida.storage.psql_dos.models.user.DbUser sqla-model:: "
"~aiida.storage.psql_dos.models.node.DbNode sqla-model:: "
"~aiida.storage.psql_dos.models.node.DbLink sqla-model:: "
"~aiida.storage.psql_dos.models.group.DbGroup sqla-model:: "
"~aiida.storage.psql_dos.models.group.DbGroupNode sqla-model:: "
"~aiida.storage.58sqla-model:: "
"~aiida.storage.psql_dos.models.computer.DbComputer sqla-model:: "
"~aiida.storage.psql_dos.models.authinfo.DbAuthInfo sqla-model:: "
"~aiida.storage.psql_dos.models.comment.DbComment sqla-model:: "
"~aiida.storage.psql_dos.models.log.DbLog sqla-model:: "
"~aiida.storage.psql_dos.models.settings.DbSetting"

#: ../../source/internals/storage/psql_dos.rst:52
msgid "The many-to-one relationship"
msgstr "many-to-one 的关系"

#: ../../source/internals/storage/psql_dos.rst:54
msgid ""
"You can see an example of a many-to-one relationship between users and "
"nodes: each node will have one and only one user that has created it, while "
"a single user may have created many nodes. Although in that case the "
"relationship is \"mandatory\", this doesn't need to be the case: for "
"example, not all nodes will have a computer associated with them, but the "
"ones that do will have only one and no more."
msgstr ""
"您可以看到用户和 node 之间关系为 many-to-one 的示例：每个 node 都有一个且仅有一个创建它的用户，而一个用户可能创建了许多 "
"node。虽然在这种情况下关系是 \"mandatory\"，但情况并不一定如此：例如，并不是所有的 node 都有计算机，但有计算机的 node "
"只有一台，没有更多。"

#: ../../source/internals/storage/psql_dos.rst:57
msgid "The following entities have a many-to-one relationship:"
msgstr "以下实体具有 many-to-one 关系："

#: ../../source/internals/storage/psql_dos.rst:59
msgid "Many `nodes` can be created by the same `user`."
msgstr "同一个 `user` 可以创建多个 `nodes`。"

#: ../../source/internals/storage/psql_dos.rst:60
msgid "Many `nodes` can point to the same `computer`."
msgstr "许多 `nodes` 可以指向同一个 `computer`。"

#: ../../source/internals/storage/psql_dos.rst:61
msgid "Many `groups` can be created by the same `user`."
msgstr "同一个 `user` 可以创建多个 `groups`。"

#: ../../source/internals/storage/psql_dos.rst:62
msgid "Many `authinfos` can be set for the same `user`."
msgstr "同一个 `user` 可以设置多个 `authinfos`。"

#: ../../source/internals/storage/psql_dos.rst:63
msgid "Many `authinfos` can be set for the same `computer`."
msgstr "同一个 `computer` 可以设置多个 `authinfos`。"

#: ../../source/internals/storage/psql_dos.rst:64
msgid "Many `comments` can be created by the same `user`."
msgstr "同一个 `user` 可以创建多个 `comments`。"

#: ../../source/internals/storage/psql_dos.rst:65
msgid "Many `comments` can be attached to the same `node`."
msgstr "同一 `node` 可连接多个 `comments`。"

#: ../../source/internals/storage/psql_dos.rst:66
msgid "Many `logs` can be attached to the same `node`."
msgstr "同一 `node` 可连接多个 `logs`。"

#: ../../source/internals/storage/psql_dos.rst:68
msgid ""
"The way to keep track of these relationships is by inserting a `foreign key`"
" column in the table of the \"many\" entity that points to the corresponding"
" id value of the \"one\" entity they are related to. For example, there is a"
" ``user_id`` foreign key column in the **db_dbnode** table that stores the "
"id of the user that created each node."
msgstr ""
"跟踪这些关系的方法是在 \"many\" 实体的表中插入一个 ``外键``列，指向与之相关的 \"one\" 实体的相应 id "
"值。例如，在**db_dbnode**表中有一个 ``user_id`` 外键列，其中存储了创建每个 node 的用户的 id。"

#: ../../source/internals/storage/psql_dos.rst:73
msgid "The many-to-many relationship"
msgstr "many-to-many 关系"

#: ../../source/internals/storage/psql_dos.rst:75
msgid ""
"This type of relationship is a bit more difficult to track, since now both "
"members can be related to more than one element. Recording this in the same "
"table as one of the entities would imply storing a list of values in a "
"column (which is often discouraged and not well supported). Therefore, it is"
" more convenient to use an extra table in which each of the connections has "
"its corresponding entry indicating which are the specific elements that are "
"related."
msgstr ""
"这种类型的关系比较难以跟踪，因为现在两个成员都可能与不止一个元素相关。如果将其记录在与其中一个实体相同的表中，就意味着要在列中存储一个值列表（通常不鼓励这样做，也不支持这样做）。因此，更方便的做法是使用一个额外的表，其中每个连接都有相应的条目，指明相关的具体元素。"

#: ../../source/internals/storage/psql_dos.rst:79
msgid "There are only two many-to-many relationships in AiiDA:"
msgstr "AiiDA 中只有两个 many-to 多关系："

#: ../../source/internals/storage/psql_dos.rst:83
msgid "Between groups and nodes"
msgstr "组与 nodes 之间"

#: ../../source/internals/storage/psql_dos.rst:82
msgid ""
"as specified before, many nodes can be inside the same group and a single "
"node can belong to many different groups. This relationship is tracked in "
"the **db_dbgroup_dbnodes** table."
msgstr ""
"如前所述，同一个组内可以有多个 node，一个 node 可以属于多个不同的组。这种关系在 **db_dbgroup_dbnodes** 表中进行跟踪。"

#: ../../source/internals/storage/psql_dos.rst:88
msgid "Between nodes themselves (Links)"
msgstr "nodes 本身之间（链接）"

#: ../../source/internals/storage/psql_dos.rst:86
msgid ""
"nodes have what is known as a \"self-referencing relationship\", meaning "
"that they can be connected among themselves. Indeed, this is one of the core"
" principles of how the provenance graph works. This relationship is tracked "
"in the **db_dblinks** table."
msgstr ""
"node 具有所谓的 \"self-referencing relationship\"，这意味着它们之间可以相互连接。事实上，这是 "
"provenance 图形工作的核心原则之一。这种关系在 **db_dblinks** 表中有记录。"

#: ../../source/internals/storage/psql_dos.rst:91
msgid "Storage schema migrations"
msgstr "存储 schema 迁移"

#: ../../source/internals/storage/psql_dos.rst:93
msgid ""
"Migrations of the storage schema, to bring it inline with updates to the "
"``aiida-core`` API, are implemented by "
":py:class:`~aiida.storage.psql_dos.migrator.PsqlDosMigrator` , using "
"`alembic <https://alembic.sqlalchemy.org>`_."
msgstr "存储 schema 的迁移由 :py:class:`~aiida.storage.psql_dos.migrator.PsqlDosMigrator` 使用 `alembic <https://alembic.sqlalchemy.org>`_ 实现，以便与 ``aiida-core`` API 的更新保持一致。"

#: ../../source/internals/storage/psql_dos.rst:96
msgid "Legacy schema"
msgstr "传统 schema"

#: ../../source/internals/storage/psql_dos.rst:98
msgid ""
"The `psql_dos` storage format originates from the merging of the `django` "
"and `sqlalchemy` backends, present in `aiida-core` version 1. Both backends "
"had very similar PostgreSQL database schema, and there are now two separate "
"migration branches to merge these into a single schema."
msgstr "`psql_dos` 存储格式源于 `aiida-core` 第 1 版中的 `django` 和 `sqlalchemy` 后端合并。这两个后端都有非常相似的 PostgreSQL 数据库 schema，现在有两个独立的迁移分支将它们合并为一个 schema。"

#: ../../source/internals/storage/repository.rst:5
msgid "Repository"
msgstr "存储库"

#: ../../source/internals/storage/repository.rst:7
msgid ""
"The file repository in AiiDA, often referred to simply as the repository, is"
" the data store where all binary data is persisted, that belong to the "
":py:class:`~aiida.orm.Node` in the provenance graph. In this chapter, the "
"design and implementation of the file repository is described, which largely"
" draws from :doc:`aep:007_improved_file_repository/readme` and "
":doc:`aep:006_efficient_object_store_for_repository/readme`."
msgstr ""
"AiiDA 中的文件存储库，通常简称为存储库，是持久化所有二进制数据的数据存储库，这些数据属于 provenance 图中的 "
":py:class:`~aiida.orm.Node`。本章将描述文件存储库的设计和实现，主要借鉴 "
":doc:`aep:007_improved_file_repository/readme` 和 "
":doc:`aep:006_efficient_object_store_for_repository/readme` 的内容。"

#: ../../source/internals/storage/repository.rst:11
msgid ""
"The current architecture is heavily influenced by lessons learned from the "
"original design of the file repository in the earliest version of AiiDA that"
" had difficulty scaling to large numbers of files. For that reason, at end "
"of the chapter there is a description of the original design and its "
"limitations. This can be instructive in understanding the design of the "
"current solution."
msgstr ""
"目前的架构在很大程度上受到 AiiDA "
"最早版本中文件库原始设计的经验教训的影响，原始设计很难扩展到大量文件。因此，在本章的末尾有一个关于原始设计及其局限性的描述。这对理解当前解决方案的设计很有启发。"

#: ../../source/internals/storage/repository.rst:18
msgid "Design"
msgstr "设计"

#: ../../source/internals/storage/repository.rst:20
msgid ""
"The following requirements were considered during the design of the file "
"repository implementation:"
msgstr "在设计文件存储库实施过程中，考虑了以下要求："

#: ../../source/internals/storage/repository.rst:22
msgid ""
"Scalability: the repository should be able to store millions of files, all "
"the while permitting efficient backups."
msgstr "可扩展性：存储库应能存储数百万个文件，同时允许高效备份。"

#: ../../source/internals/storage/repository.rst:23
msgid ""
"Heterogeneity: the repository should operate efficiently for data that is "
"heterogeneous in size, with object of size ranging from a few bytes to "
"multiple gigabytes."
msgstr "异构性：存储库应能有效地处理大小不一的数据，对象的大小从几个字节到多个千兆字节不等。"

#: ../../source/internals/storage/repository.rst:24
msgid ""
"Simplicity: the solution should not require an actively running server to "
"operate."
msgstr "简便性：解决方案的运行不需要运行中的服务器。"

#: ../../source/internals/storage/repository.rst:25
msgid ""
"Concurrency: the repository should support multiple concurrent reading and "
"writing processes."
msgstr "并发性：版本库应支持多个并发读写进程。"

#: ../../source/internals/storage/repository.rst:26
msgid ""
"Efficiency: the repository should automatically deduplicate file content in "
"an effort to reduce the total amount of required storage space."
msgstr "效率：存储库应自动重复文件内容，以减少所需存储空间总量。"

#: ../../source/internals/storage/repository.rst:28
msgid ""
"These are merely the requirements for the data store that persists the "
"content of the files, or the *backend* file repository. The frontend "
"interface that is employed by users to store files has another set of "
"requirements altogether. Users are used to think about file storage in terms"
" of a file hierarchy, as they would on a normal file system, where files are"
" stored in (nested) directories. Moreover, in the context of AiiDA, a node "
"is expected to have their own subset of files with their own hierarchy, an "
"example of which is shown in :numref:`fig:internal-"
"architecture:repository:design-node-repository`. The frontend interface "
"therefore needs to allow users to store and address files with such a "
"hierarchy on a per node basis, even if only virtually. With that guarantee, "
"the backend implementation is free to store the files in any way imaginable "
"in order to meet the requirements specified above."
msgstr ""
"这些仅仅是对持久保存文件内容的数据存储或*后端*文件存储库的要求。用户存储文件时使用的前端界面则完全不同。用户习惯从文件层次结构的角度来考虑文件存储，就像在普通文件系统中一样，文件存储在（嵌套）目录中。此外，在"
" AiiDA 的背景下，node 应该有自己的文件子集，有自己的层次结构，例如 :numref:`fig:internal-"
"architecture:repository:design-node-repository`。因此，前端界面需要允许用户按 node "
"层级存储和处理文件，即使只是虚拟的。有了这种保证，后端实现就可以自由地以任何可以想象的方式存储文件，以满足上述要求。"

#: ../../source/internals/storage/repository.rst:40
msgid ""
"Schematic representation of a possible virtual file hierarchy of a node in "
"the provenance graph. From a user's perspective, each node can contain an "
"arbitrary number of files and directories with a certain file hierarchy. The"
" hierarchy is completely virtual, however, in the sense that the hierarchy "
"is not necessarily maintained literally in the data store containing the "
"file content."
msgstr "Schematic 表示 provenance graph 中 node 可能的虚拟文件层次结构。从用户的角度来看，每个 node 可以包含任意数量的文件和目录，并具有一定的文件层次结构。不过，这种层次结构完全是虚拟的，因为在包含文件内容的数据存储区中，并不一定按字面意思来维护层次结构。"

#: ../../source/internals/storage/repository.rst:44
msgid ""
"To satisfy the requirements of the frontend interface and the actual data "
"store at the same time, the file repository solution in AiiDA is divided "
"into two components: a *frontend*, which is agnostic of any particular "
"storage technology, and a *backend*, which implements the interface to the "
"storage."
msgstr ""
"为了同时满足前端界面和实际数据存储的要求，AiiDA "
"的文件存储解决方案分为两个部分：*前端*和*后端*，前者不依赖于任何特定的存储技术，后者实现了与存储的接口。"

#: ../../source/internals/storage/repository.rst:50
msgid "The file repository frontend"
msgstr "文件存储库前端"

#: ../../source/internals/storage/repository.rst:52
msgid ""
"To understand how the file repository frontend integrates the ORM and the "
"file repository backend, consider the following class diagram:"
msgstr "要了解文件存储库前端如何集成 ORM 和文件存储库后台，请看下面的类图："

#: ../../source/internals/storage/repository.rst:59
msgid ""
"The file repository backend is interfaced through the "
":class:`~aiida.repository.repository.Repository` class. It maintains a "
"reference of an instance of one of the available file repository backend "
"implementations, be it the sandbox or disk object store variant, to store "
"file objects and to retrieve the content for stored objects. Internally, it "
"keeps a virtual file hierarchy, which allows clients to address files by "
"their path in the file hierarchy as opposed to have the unique key "
"identifiers created by the backend. Finally, the "
":class:`~aiida.orm.nodes.node.Node` class, which is the main point of "
"interaction of users with the entire API, mixes in the "
":class:`~aiida.orm.nodes.repository.NodeRepository` class. The latter keeps "
"an instance of the :class:`~aiida.repository.repository.Repository` class to"
" which all repository operations are forwarded, after the check of node "
"mutability is performed."
msgstr ""
"文件存储库后端通过 :class:`~aiida.repository.repository.Repository` "
"类进行连接。它维护可用文件存储库后端实现（无论是沙盒还是磁盘对象存储变体）之一实例的引用，以存储文件对象并检索所存储对象的内容。在内部，它保留了一个虚拟文件层次结构，允许客户端通过文件层次结构中的路径来寻址文件，而不是使用后端创建的唯一密钥标识符。最后，:class:`~aiida.orm.nodes.node.Node`"
" 类是用户与整个应用程序接口的主要交互点，它混合了 "
":class:`~aiida.orm.nodes.repository.NodeRepository` 类。后者保留了一个 "
":class:`~aiida.repository.repository.Repository` 类的实例，在对 node "
"的可变性进行检查后，所有存储库操作都将转发给该类。"

#: ../../source/internals/storage/repository.rst:65
msgid ""
"As opposed to the backend interface, the frontend "
":class:`~aiida.repository.repository.Repository` *does* understand the "
"concept of a file hierarchy and keeps it fully in memory. This allows "
"clients to interact with this interface as if the files were stored with the"
" indicated hierarchy and address them by their relative filepaths, as "
"opposed to the unique string identifiers that are generated by the backend. "
"It is important to note, however, that this virtual hierarchy is not "
"initialized based on the actual contents of the file repository backend. In "
"fact it *cannot* be, because the backend has no notion of a file hierarchy "
"and so cannot provide its hierarchy to the "
":class:`~aiida.repository.repository.Repository` when it is constructed. "
"This means that the :class:`~aiida.repository.repository.Repository` only "
"exposes a *subset* of the files that are contained within a file repository "
"backend."
msgstr ""
"与后端界面不同，前端 :class:`~aiida.repository.repository.Repository` *确实* "
"理解文件层次结构的概念，并将其完全保存在内存中。这样，客户端就可以与该界面进行交互，就好像文件是按照指定的层次结构存储的一样，并通过相对文件路径（而不是后端生成的唯一字符串标识符）进行寻址。但"
" import 要注意的是，这个虚拟层次结构并不是根据文件存储库后台的实际内容来初始化的。事实上，它 *不能* "
"这样做，因为后端没有文件层次结构的概念，因此无法在构建 :class:`~aiida.repository.repository.Repository`"
" 时向其提供层次结构。这意味着，:class:`~aiida.repository.repository.Repository` "
"只能公开文件存储库后端所含文件的 *子集* 。"

#: ../../source/internals/storage/repository.rst:71
msgid ""
"To persist the virtual hierarchy of the files stored for any particular "
"node, it is stored in the database. The node database model has a JSONB "
"column called ``repository_metadata`` that contains the virtual file "
"hierarchy in a serialized form. This serialized form is generated by the "
":meth:`~aiida.repository.repository.Repository.serialize` method, and the "
":meth:`~aiida.repository.repository.Repository.from_serialized` class method"
" can be used to reconstruct a repository instance with a pre-existing file "
"hierarchy. Note that upon constructing from a serialized file hierarchy, the"
" :class:`~aiida.repository.repository.Repository` will not actually validate"
" that the file objects contained within the hierarchy are *actually* "
"contained in the backend."
msgstr ""
"要持久保存为任何特定 node 存储的文件的虚拟层次结构，可将其存储在数据库中。node 数据库模型有一个名为 "
"``repository_metadata`` 的 JSONB 列，其中包含序列化形式的虚拟文件层次结构。该序列化形式由 "
":meth:`~aiida.repository.repository.Repository.serialize` "
"方法生成，:meth:`~aiida.repository.repository.Repository.from_serialized` "
"类方法可用于重构具有 pre-existing "
"文件层次结构的存储库实例。请注意，在从序列化文件层次结构构建时，:class:`~aiida.repository.repository.Repository`"
" 不会实际验证层次结构中包含的文件对象是否*实际*包含在后端中。"

#: ../../source/internals/storage/repository.rst:76
msgid ""
"The final integration of the "
":class:`~aiida.repository.repository.Repository` class with the ORM is "
"through the :class:`~aiida.orm.nodes.repository.NodeRepository` class, which"
" is mixed into the :class:`~aiida.orm.nodes.node.Node` class. This layer "
"serves a couple of functions:"
msgstr " :class:`~aiida.repository.repository.Repository` 类与 ORM 的最终整合是通过 :class:`~aiida.orm.nodes.repository.NodeRepository` 类进行的，该类与 :class:`~aiida.orm.nodes.node.Node` 类混合在一起。这一层有几个功能："

#: ../../source/internals/storage/repository.rst:79
msgid "It implements the mutability rules of nodes"
msgstr "它实现了 nodes 的可变性规则"

#: ../../source/internals/storage/repository.rst:80
msgid "It serves as a translation layer between string and byte streams."
msgstr "它是字符串流和字节流之间的转换层。"

#: ../../source/internals/storage/repository.rst:82
msgid ""
"The first is necessary because after a node has been stored, its content is "
"considered immutable, which includes the content of its file repository. The"
" :class:`~aiida.orm.utils.mixins.Sealable` mixin overrides the "
":class:`~aiida.repository.repository.Repository` methods that mutate "
"repository content, to ensure that process nodes *can* mutate their content,"
" as long as they are not sealed."
msgstr "第一个方法是必要的，因为 node 被存储后，其内容被认为是不可变的，这包括其文件存储库的内容。:class:`~aiida.orm.utils.mixins.Sealable` 混合脚本重写了更改存储库内容的 :class:`~aiida.repository.repository.Repository` 方法，以确保 node 进程只要不被密封，就可以更改其内容。"

#: ../../source/internals/storage/repository.rst:85
msgid ""
"The second *raison-d'être* of the "
":class:`~aiida.orm.nodes.repository.NodeRepository` is to allow clients to "
"work with string streams instead of byte streams. As explained in the "
"section on the :ref:`file repository backend <internal-"
"architecture:repository:design:repository-backend>`, it only works with byte"
" streams. However, users of the frontend API are often more used to working "
"with strings and files with a given encoding. The "
":class:`~aiida.orm.nodes.repository.NodeRepository` overrides the "
"*put*-methods and accepts string streams, and enables returning file handles"
" to existing file objects that automatically decode the byte content. The "
"only additional requirement for operating with strings instead of bytes is "
"that the client specifies the encoding. Since the file repository backend "
"does not store any sort of metadata, it is impossible to deduce the file "
"encoding and automatically decode it. Likewise, using the default file "
"encoding of the system may yield the wrong result since the file could have "
"been imported and actually have been originally written on another system "
"with a different encoding. Encoding and decoding of file objects is "
"therefore the responsibility of the frontend user."
msgstr ""

#: ../../source/internals/storage/repository.rst:97
msgid "The file repository backend"
msgstr ""

#: ../../source/internals/storage/repository.rst:99
msgid ""
"In a clear separation of responsibilities, the backend is solely tasked with"
" storing the content of files and returning them upon request as efficiently"
" as possible, both when retrieving files individual as well as in bulk. For "
"simplicity, the repository backend only deals with raw byte streams and does"
" not maintain any sort of file hierarchy. The interface that any backend "
"file repository should implement is defined by the "
":class:`~aiida.repository.backend.abstract.AbstractRepositoryBackend` "
"abstract class."
msgstr ""

#: ../../source/internals/storage/repository.rst:107
msgid ""
"The "
":meth:`~aiida.repository.backend.abstract.AbstractRepositoryBackend.put_object_from_filelike`"
" is the main method that, given a stream or filelike-object of bytes, will "
"write it as an object to the repository and return a key. The "
":meth:`~aiida.repository.backend.abstract.AbstractRepositoryBackend.put_object_from_file`"
" is a convenience method that allows to store a file object directly from a "
"file on the local file system, and simply calls through to "
":meth:`~aiida.repository.backend.abstract.AbstractRepositoryBackend.put_object_from_filelike`."
" The key returned by the *put*-methods, which could be any type of string, "
"should uniquely identify the stored object. Using the key, "
":meth:`~aiida.repository.backend.abstract.AbstractRepositoryBackend.open` "
"and "
":meth:`~aiida.repository.backend.abstract.AbstractRepositoryBackend.get_object_content`"
" can be used to obtain a handle to the object or its entire content read "
"into memory, respectively. Finally, the "
":meth:`~aiida.repository.backend.abstract.AbstractRepositoryBackend.has_object`"
" and "
":meth:`~aiida.repository.backend.abstract.AbstractRepositoryBackend.delete_object`"
" can be used to determine whether the repository contains an object with a "
"certain key, or delete it, respectively."
msgstr ""

#: ../../source/internals/storage/repository.rst:113
msgid ""
"The abstract repository backend interface is implemented for the `disk "
"object store`_ "
"(:class:`~aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend`)"
" as well as a scratch sandbox "
"(:class:`~aiida.repository.backend.sandbox.SandboxRepositoryBackend`). The "
"latter implementation simply implements the interface using a temporary "
"scratch folder on the local file system to store the file content. File "
"objects are stored in a flat manner where the filename, that functions as "
"the unique key, is based on a randomly generated UUID, as shown in "
":numref:`fig:internal-architecture:repository:design-sandbox`."
msgstr ""

#: ../../source/internals/storage/repository.rst:122
msgid ""
"The file structure created by the "
":class:`~aiida.repository.backend.sandbox.SandboxRepositoryBackend` "
"implementation of the file repository backend. Files are stored in a "
"completely flat structure with the name determined by a randomly generated "
"UUID. This is the most efficient method for writing and reading files on a "
"local file system. Since these sandbox repositories are intended to have "
"very short lifetimes and contain relatively few objects, the typical "
"drawbacks of a flat file store do not apply."
msgstr ""

#: ../../source/internals/storage/repository.rst:127
msgid ""
"The simple flat structure of this sandbox implementation should not be a "
"limitation since this backend should only be used for short-lived temporary "
"file repositories. The use case is to provide a file repository for unstored"
" nodes. New node instances that created in interactive shell sessions are "
"often discarded before being stored, so it is important that not only the "
"creation of new files, but also their deletion once the node is deleted, is "
"as efficient as possible. The disk object store is not optimized for "
"efficient ad-hoc object deletion, but rather, object deletion is implemented"
" as a soft-delete and the actual deletion should be performed during "
"maintenance operations, such as the packing of loose objects. That is why a "
"new node instance upon instantiation gets an instance of the "
"class:`~aiida.repository.backend.sandbox.SandboxRepositoryBackend` "
"repository. Only when the node gets stored, are the files copied to the "
"permanent backend file repository (such as the "
":class:`~aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend`)."
msgstr ""

#: ../../source/internals/storage/repository.rst:137
msgid "The disk object store"
msgstr ""

#: ../../source/internals/storage/repository.rst:139
msgid ""
"The disk object store was designed from scratch in order to satisfy the "
"technical requirements of the file repository described in the previous "
"section. The concept is simple: the file repository is represented by a "
"*container* which is a directory on the local file system and contains all "
"the file content. When a file is written to the container, it is first "
"written to the *scratch* directory. Once this operation has finished "
"successfully, the file is moved atomically to the *loose* directory. It is "
"called *loose* because each file in this directory is stored as an "
"individual or *loose* object. The name of the object is given by the hash "
"computed from its content, currently using the `sha256 algorithm "
"<https://en.wikipedia.org/wiki/SHA-2>`_. The *loose* directory applies one "
"level of sharding based on the first two characters of the object hashes, in"
" order to make the lookup of objects more performant as described in "
":ref:`internal-architecture:repository:original-design`. A schematic "
"overview of the folder structure of a disk object store *container* is shown"
" in :numref:`fig:internal-architecture:repository:design-dos`."
msgstr ""

#: ../../source/internals/storage/repository.rst:153
msgid ""
"Schematic representation of the file hierarchy in a *container* of the `disk"
" object store <https://pypi.org/project/disk-objectstore/>`_ package. When "
"writing files to the container, they are first written to a *scratch* "
"sandbox folder and then moved atomically to the *loose* directory. During "
"maintenance operations, *loose* files can be concatenated to pack files that"
" are stored in the *packed* directory."
msgstr ""

#: ../../source/internals/storage/repository.rst:157
msgid ""
"The approach of creating new files in the repository by first writing them "
"to the scratch sandbox folder before atomically moving them to the *loose* "
"object directory, directly addresses the requirement of *concurrency*. By "
"relying on the *atomic* file move operation of the operating system, all "
"*loose* objects are guaranteed to be protected from data corruptions, within"
" the limits of the atomicity guarantees of the local file system. The usage "
"of the file content's hash checksum as the filename automatically fulfils "
"the *efficiency* requirement. Assuming that the hashing algorithm used has "
"no collisions, two objects with the same hash are guaranteed to have the "
"same content and so therefore can be stored as a single object. Although the"
" computation of a file's hash before storing it incurs a non-negligible "
"overhead, the chosen hashing algorithm is fast enough that it justifies that"
" cost given that it gives a significant reduction in required storage space "
"due to the automatic and implicit data deduplication."
msgstr ""

#: ../../source/internals/storage/repository.rst:163
msgid ""
"While the approach of the *scratch* and *loose* directories address the "
"criteria of *concurrency* and *efficiency*, the solution is not *scalable*. "
"Just as the :ref:`original design <internal-"
"architecture:repository:original-design>`, this solution does not scale to "
"file repositories of multiple millions of nodes, since every object is "
"stored as an individual file on disk. As described there, this makes the "
"repository impractical to backup since merely constructing the list of files"
" present is an expensive operation. To tackle this problem, the disk object "
"store implements the concept of packing. In this maintenance operation, the "
"contents of all loose objects stored in the *loose* directory are "
"concatenated into single files that are stored in the *packed* folder. The "
"pack files have a configurable maximum size and once it is reached the next "
"pack file is created, whose filenames are named by consecutive integers."
msgstr ""

#: ../../source/internals/storage/repository.rst:170
msgid ""
"A `sqlite <https://sqlite.org/index.html>`_ database is used to track in "
"which pack file each object is stored, the byte offset at which it starts "
"and its total byte length. Such an index file is necessary once individual "
"objects are packed into a smaller number of files, and to respect the "
"*simplicity* requirement, a sqlite database was chosen, since it is "
"serverless and efficient. The loose objects are concatenated in a random "
"order, which is to say that the disk object store undertakes no effort to "
"order objects according to their content size in any way, such as to align "
"them with blocks on the file system, unlike some other key-value store "
"solutions. Files of any size are treated equally and as such there is no "
"optimization towards storing smaller files nor larger files. This is done "
"intentionally because the disk object store is expected to be able to store "
"files that are strongly heterogeneous in size and as such can not make "
"optimizations for a particular range of file sizes."
msgstr ""

#: ../../source/internals/storage/repository.rst:176
msgid ""
"Currently, the packing operation is seen as a maintenance operation, and "
"therefore, unlike the writing of new *loose* objects, cannot be operated "
"concurrently by multiple processes. Despite this current limitation, the "
"packing mechanism satisfies the final *scalability* requirement. By reducing"
" the total number of files and the packing strategy, the pack files can be "
"copied to a backup copy very efficiently. Since new objects are concatenated"
" to the end of existing pack files and existing pack files are in principle "
"never touched after they have reached their maximum size (unless the pack "
"files are forcefully repacked), backup up tools, such as `rsync "
"<https://en.wikipedia.org/wiki/Rsync>`_, can reduce the transfer of content "
"to the bare minimum."
msgstr ""

#: ../../source/internals/storage/repository.rst:182
msgid "The lifetime of a node"
msgstr ""

#: ../../source/internals/storage/repository.rst:184
msgid ""
"Now that all the components are described, here we describe how they are "
"employed throughout the lifetime of a node. When a new node instance is "
"constructed, it will not yet have an instance of the "
":class:`~aiida.repository.repository.Repository`. Instead, this is done "
"lazily as soon as an operation on the file repository is executed. This is "
"crucial for performance since node instances may often be initialized "
"without their repository contents ever needing to be accessed and "
"constructing the repository interface instances will have a non-negligible "
"overhead. If the node is unstored the "
":class:`~aiida.repository.repository.Repository` will be constructed with an"
" instance of the "
":class:`~aiida.repository.backend.sandbox.SandboxRepositoryBackend` "
"implementation. The advantage is that if the node object does go out of "
"scope before it has been stored, the contents that may have been created in "
"the repository will be automatically cleaned from the local file system."
msgstr ""

#: ../../source/internals/storage/repository.rst:191
msgid ""
"When a node gets stored, the "
":class:`~aiida.repository.repository.Repository` instance is replaced with a"
" new instance, this time with the backend set to the "
":class:`~aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend`"
" that is initialized to point to the *container* of the current profile. The"
" contents of the sandbox repository are copied over to the disk object store"
" through the :class:`~aiida.repository.repository.Repository` interface and "
"at the end its contents are serialized. The serialized file hierarchy is "
"then stored on the node itself in the ``repository_metadata`` column. This "
"allows to reconstruct the :class:`~aiida.repository.repository.Repository` "
"instance correctly once the node is reloaded from the database, by calling "
"the :meth:`~aiida.repository.repository.Repository.from_serialized` class "
"method while passing the stored ``repository_metadata``."
msgstr ""

#: ../../source/internals/storage/repository.rst:200
msgid "The original design"
msgstr ""

#: ../../source/internals/storage/repository.rst:202
msgid ""
"The original file repository in AiiDA was implemented as a simple directory "
"on the local file system. The files that belong to a node would be written "
"*as is* to a subdirectory within that repository directory, without any "
"compression or packing. The name of the directory was equal to the UUID of "
"the node, guaranteeing that each subdirectory was unique, and the files of "
"different nodes would not overwrite one another, even if they have identical"
" names."
msgstr ""

#: ../../source/internals/storage/repository.rst:206
msgid ""
"In anticipation of databases containing many nodes leading to many "
"subdirectories, which would slow down the operation of finding the directory"
" of a particular node, the repository was `sharded "
"<https://en.wikipedia.org/wiki/Shard_(database_architecture)>`_. In the "
"context of a file system, this means that instead of a flat structure of the"
" file repository, the node directories are stored in a (nested) "
"subdirectory. Which subdirectory is once again determined by the UUID: the "
"first and second subdirectories are given by the first and second two "
"characters, respectively. The remaining characters of the UUID form the name"
" of the final subdirectory. For example, given the UUID "
"``4802585e-18da-42e1-b063-7504585ea9af``, the relative path of the "
"subdirectory would be ``48/02/585e-18da-42e1-b063-7504585ea9af``. With this "
"structure, the file repository would contain at most 256 directories, ``00``"
" through ``ff``, with the same applying to each one of those. Starting from "
"the third level, however, the file hierarchy would once again be flat. A "
"schematic overview of the resulting file hierarchy is shown in "
":numref:`fig:internal-architecture:repository:design-original`."
msgstr ""

#: ../../source/internals/storage/repository.rst:220
msgid ""
"Schematic representation of the original structure of the file repository. "
"The files of each node are stored in a directory that is exclusive to that "
"node, whose path is determined by the UUID of the node. The directory is "
"sharded twice, using two consecutive characters of the start of the UUID to "
"create two levels of subdirectories. This is done to limit the number of "
"directories in any one level in order to make the looking up of a directory "
"for a given node more efficient."
msgstr ""

#: ../../source/internals/storage/repository.rst:227
msgid "Limitations"
msgstr ""

#: ../../source/internals/storage/repository.rst:229
msgid ""
"While a simple and robust design, the original architecture of the file "
"repository had various limitations, many of which would start to play a "
"significant role for larger project that contain many files. The main "
"limitation of the original design is that all files were stored as is, which"
" eventually leads to a large number of files stored in a large number of "
"subdirectories. On a file system, each file or directory requires an "
"*inode*, which is label that the file system to be able to map the filepath "
"to the actual location on disk. The number of available inodes on a file "
"system are limited, and certain AiiDA projects were hitting these limits, "
"making it impossible to write more files to disk, even though there might "
"have been plenty of raw storage space left."
msgstr ""

#: ../../source/internals/storage/repository.rst:234
msgid ""
"In addition, backing up a file repository with the original design was "
"practically impossible. Due to the sheer number of files, even just "
"determining the difference between the original and backup of a repository, "
"for example using `rsync <https://en.wikipedia.org/wiki/Rsync>`_ could take "
"days. And that is just computing the difference, let alone the time it would"
" take to perform the actual backup."
msgstr ""

#: ../../source/internals/storage/repository.rst:238
msgid ""
"However, it wasn't merely the number of files that was problematic, but even"
" the number of directories that typical repositories would contain, would "
"already significantly slow down backup operations. Since the database kept "
"no reference of which files and directories were stored in the file "
"repository for any given node, the original design would always create a "
"subdirectory in the file repository for any node, even if it contained no "
"files whatsoever. Otherwise, it would have been impossible to know whether a"
" node *really* did not contain any files, or if the directory in the file "
"repository was accidentally mistaken. This approach did, however, lead to a "
"large number of empty directories, as many nodes often contain no files at "
"all, for example, base type data nodes."
msgstr ""

#: ../../source/internals/storage/sqlite_zip.rst:4
msgid "``sqlite_zip`` (archive) format"
msgstr ""

#: ../../source/internals/storage/sqlite_zip.rst:6
msgid ""
"The :py:class:`~aiida.storage.sqlite_zip.backend.SqliteZipBackend` is the "
"storage format used for the AiiDA archive, whose design draws from "
"consideration outlined in :doc:`aep:005_exportformat/readme`."
msgstr ""

#: ../../source/internals/storage/sqlite_zip.rst:9
msgid ""
"An AiiDA archive is a single file format (with canonical extension "
"``.aiida``), for long term storage of an AiiDA provenance graph. It provides"
" a data storage backend, integrating a database and file repository."
msgstr ""

#: ../../source/internals/storage/sqlite_zip.rst:12
msgid "The standard format is a ZIP archive, containing the following files:"
msgstr ""

#: ../../source/internals/storage/sqlite_zip.rst:14
msgid ""
"``metadata.json`` file containing information on the version of the archive."
msgstr ""

#: ../../source/internals/storage/sqlite_zip.rst:15
msgid "``db.sqlite3`` file containing the AiiDA database."
msgstr ""

#: ../../source/internals/storage/sqlite_zip.rst:16
msgid "``repo/`` directory containing the AiiDA file repository."
msgstr ""

#: ../../source/internals/storage/sqlite_zip.rst:22
msgid "``sqlite_zip`` zip file format."
msgstr ""

#: ../../source/internals/storage/sqlite_zip.rst:24
msgid ""
"The central directory is written with the metadata and database records at "
"the top of the file. Zip files are read first from the bottom, which "
"contains the byte position of the start of the central directory, then "
"scanning down the central directory to extract records for each file. When "
"extracting the metadata/database only, one can simply scan for that record, "
"then break and directly decompress the byte array for that file. In this "
"way, we do not have to scan through all the records of the repository files"
msgstr ""

#: ../../source/internals/storage/sqlite_zip.rst:29
msgid ""
"As opposed to the :ref:`internal_architecture:storage:psql_dos`, this format"
" is \"read-only\", since zip files cannot be modified once created."
msgstr ""

#: ../../source/internals/storage/sqlite_zip.rst:34
msgid "metadata schema"
msgstr ""

#: ../../source/internals/storage/sqlite_zip.rst:36
msgid ""
"This file contains important information, and it is necessary for the "
"correct interpretation of ``db.sqlite3```. This is used to avoid any "
"incompatibilities among different versions of AiiDA."
msgstr ""

#: ../../source/internals/storage/sqlite_zip.rst:39
msgid "Here is an example ``metadata.json``:"
msgstr ""

#: ../../source/internals/storage/sqlite_zip.rst:44
msgid ""
"At the beginning of the file, we see the version of the archive file (under "
"``export_version``) and the version of the AiiDA code. New archive versions "
"are introduced for several different reasons; this may generally be when:"
msgstr ""

#: ../../source/internals/storage/sqlite_zip.rst:47
msgid "a change occurs in what can or cannot be exported for each entity,"
msgstr ""

#: ../../source/internals/storage/sqlite_zip.rst:48
msgid "the database and/or archive schemes are updated or changed,"
msgstr ""

#: ../../source/internals/storage/sqlite_zip.rst:49
msgid "or standardized exported property values are updated in AiiDA."
msgstr ""

#: ../../source/internals/storage/sqlite_zip.rst:52
msgid ""
"For archives of version 0.3 and older it is advisable that you manually try "
"to convince yourself that the migration was completely successful. While all"
" migrations are tested, trying to include reasonable edge-cases, the "
"migrations involved from version 0.3 to 0.4 are intricate and the "
"possibility of a missing edge-case test is quite real. It is worth noting "
"that if you ever have an issue, please report it on `GitHub "
"<https://www.github.com/aiidateam/aiida_core/issues/new>`."
msgstr ""

#: ../../source/internals/storage/sqlite_zip.rst:57
msgid ""
"If you have migrated an archive file to the newest version, there may be an "
"extra entry in ``metadata.json``. This simply states from which archive "
"version the file was migrated."
msgstr ""

#: ../../source/internals/storage/sqlite_zip.rst:62
msgid ""
"If you supply an old archive file that the current AiiDA code does not "
"support, ``verdi archive import`` will automatically try to migrate the "
"archive by calling ``verdi archive migrate``."
msgstr ""

#: ../../source/internals/storage/sqlite_zip.rst:67
msgid "repository format"
msgstr ""

#: ../../source/internals/storage/sqlite_zip.rst:69
msgid ""
"The repository is read by the "
":py:class:`~aiida.storage.sqlite_zip.backend.ZipfileBackendRepository`."
msgstr ""

#: ../../source/internals/storage/sqlite_zip.rst:71
msgid ""
"The zip file should contain repository files with the key format: "
"``repo/<sha256 hash>``, i.e. files named by the sha256 hash of the file "
"contents, inside a ``repo`` directory."
msgstr ""

#: ../../source/internals/storage/sqlite_zip.rst:75
msgid "database schema"
msgstr ""

#: ../../source/internals/storage/sqlite_zip.rst:77
msgid ""
"The database schema is intended to directly mirror that of the "
":ref:`internal_architecture:storage:psql_dos`. The only differences are in "
"the handling of certain data types by SQLite versus PostgreSQL:"
msgstr ""

#: ../../source/internals/storage/sqlite_zip.rst:80
msgid "``UUID`` -> ``CHAR(32)``"
msgstr ""

#: ../../source/internals/storage/sqlite_zip.rst:81
msgid "``DateTime`` -> ``TZDateTime``"
msgstr ""

#: ../../source/internals/storage/sqlite_zip.rst:82
msgid "``JSONB`` -> ``JSON``"
msgstr ""

#: ../../source/internals/storage/sqlite_zip.rst:84
msgid "Also, `varchar_pattern_ops` indexes are not possible in SQLite."
msgstr ""

#: ../../source/internals/storage/sqlite_zip.rst:89
msgid ""
"sqla-model:: ~aiida.storage.sqlite_zip.models.DbUser sqla-model:: "
"~aiida.storage.sqlite_zip.models.DbNode sqla-model:: "
"~aiida.storage.sqlite_zip.models.DbLink sqla-model:: "
"~aiida.storage.sqlite_zip.models.DbGroup sqla-model:: "
"~aiida.storage.sqlite_zip.models.DbGroupNodes sqla-model:: "
"~aiida.storage.sqlite_zip.models.DbComputer sqla-model:: "
"~aiida.storage.sqlite_zip.models.DbAuthInfo sqla-model:: "
"~aiida.storage.sqlite_zip.models.DbComment sqla-model:: "
"~aiida.storage.sqlite_zip.models.DbLog"
msgstr ""
