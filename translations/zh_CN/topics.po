# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2020, ECOLE POLYTECHNIQUE FEDERALE DE LAUSANNE (Theory and Simulation of Materials (THEOS) and National Centre for Computational Design and Discovery of Novel Materials (NCCR MARVEL)), Switzerland and ROBERT BOSCH LLC, USA. All rights reserved
# This file is distributed under the same license as the AiiDA package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Jianxing Huang <jx.huang.x@gmail.com>, 2023
# Jusong Yu <jusong.yeu@gmail.com>, 2023
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: AiiDA 2.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-12-21 00:18+0000\n"
"PO-Revision-Date: 2023-12-21 01:39+0000\n"
"Last-Translator: Jusong Yu <jusong.yeu@gmail.com>, 2023\n"
"Language-Team: Chinese (China) (https://app.transifex.com/aiidateam/teams/98967/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../source/topics/calculations/concepts.rst:5
#: ../../source/topics/processes/concepts.rst:5
#: ../../source/topics/provenance/concepts.rst:5
#: ../../source/topics/workflows/concepts.rst:5
msgid "Concepts"
msgstr "概念"

#: ../../source/topics/calculations/concepts.rst:7
#: ../../source/topics/calculations/usage.rst:9
msgid ""
"A calculation is a process (see the :ref:`process "
"section<topics:processes:concepts>` for details) that *creates* new data. "
"Currently, there are two ways of implementing a calculation process:"
msgstr ""
"算例是一个能够创建新数据的例程 (详情参见 :ref:`例程章节<topics:processes:concepts>` ) 。 "
"当前，有两种算例的实现，分别是："

#: ../../source/topics/calculations/concepts.rst:10
#: ../../source/topics/processes/functions.rst:10
msgid ""
":ref:`calculation function<topics:calculations:concepts:calcfunctions>`"
msgstr ":ref:`算例函数 <topics:calculations:concepts:calcfunctions>`"

#: ../../source/topics/calculations/concepts.rst:11
msgid ":ref:`calculation job<topics:calculations:concepts:calcjobs>`"
msgstr ":ref:`算例任务<topics:calculations:concepts:calcjobs>`"

#: ../../source/topics/calculations/concepts.rst:13
msgid ""
"The first one is the simplest of the two and is basically a python function "
"that is magically transformed into a process. This is ideal for calculations"
" that are not very computationally intensive and can be easily implemented "
"in a python function. For more taxing calculations, typically performed by "
"external codes that are optionally run on remote computing clusters, the "
"calculation job is the better alternative."
msgstr ""
"前者是简单的将一个python函数转变为一个例程(process)，这适用于计算量不大且易于实现的python函数。对于复杂的计算任务，通常需要外部的计算软件参与，这些代码通常运行在远端的集群上，因此使用算例任务更为合适。"

#: ../../source/topics/calculations/concepts.rst:17
msgid ""
"In the following sections, both concepts will be explained but without going"
" too much into detail on how to implement or run them. For a more detailed "
"exposé, please refer to the respective advanced sections on "
":ref:`calculation functions<topics:calculations:usage:calcfunctions>` and "
":ref:`calculation jobs<topics:calculations:usage:calcjobs>`."
msgstr ""
"下列章节将分别介绍两者，但是这里只是简单介绍概念而不深入详细的实现和使用细节。详细的内容请参考相应的进阶章节 "
":ref:`算例函数<topics:calculations:usage:calcfunctions>` 和 :ref:`算例任务 "
"<topics:calculations:usage:calcjobs>` 。"

#: ../../source/topics/calculations/concepts.rst:24
#: ../../source/topics/calculations/usage.rst:20
msgid "Calculation functions"
msgstr "算例函数(Calculation functions)"

#: ../../source/topics/calculations/concepts.rst:26
msgid "Consider the following computational task at hand:"
msgstr "以下列计算任务为例："

#: ../../source/topics/calculations/concepts.rst:29
msgid ""
"Given three integers, add the first two and then multiply the sum by the "
"third."
msgstr "给定三个整数，将前两者求和后与第三者相乘。"

#: ../../source/topics/calculations/concepts.rst:31
msgid ""
"In plain python code, the solution would look something like the following:"
msgstr "常规的python代码如下："

#: ../../source/topics/calculations/concepts.rst:36
msgid ""
"This simple code snippet will achieve the goal of getting the desired "
"result, however, the provenance is lost. There is no connection between the "
"output of the functions and their inputs. The remedy to this problem is the "
":py:func:`~aiida.engine.processes.functions.calcfunction`. The "
"``calcfunction`` in AiiDA is a `function decorator "
"<https://docs.python.org/3/glossary.html#term-decorator>`_ that transforms a"
" regular python function in a calculation process, which automatically "
"stores the provenance of its output in the :ref:`provenance "
"graph<topics:provenance>` when executed. Updating the previous snippet with "
"``calcfunction`` decorators yields:"
msgstr ""
"这些代码会直接得到想要的结果，但是，并没有关于运算过程的可验证性。结果与输入之间并没有保留运算关系。 为保留运算过程，我们使用 "
":py:meth:`~aiida.engine.processes.functions.calcfunction`。  AiiDA的 "
"``calcfunction`` 是一个 `装饰器 <https://docs.python.org/3/glossary.html#term-"
"decorator>`_ 它将一个函数装饰成为一个算例例程，这使得其可以自动将得到结果的计算过程储存为一个 :ref:`可验证性图 "
"<topics:provenance>` 。. 使用 ``calcfunction`` 装饰器更性上面代码片段后为:"

#: ../../source/topics/calculations/concepts.rst:45
msgid ""
"The only thing we had to do to decorate the two functions was to add the "
"line ``@calcfunction`` just before the function definition. Adding the "
"decorator tells AiiDA that the provenance for this function should be stored"
" in the provenance graph when it is executed. This means linking up the "
"inputs and the outputs for a calculation node, which represents the function"
" that was executed. The final change that has to be performed to make this "
"possible, is to make the inputs and the outputs storable. In the previous "
"snippet, the inputs are plain python integer types, which cannot be "
"automatically stored in the provenance graph as nodes. To solve this, one "
"only has to wrap them in the :py:class:`~aiida.orm.nodes.data.int.Int` node "
"sub class, which makes them storable in the database:"
msgstr ""
"我们只需要简单的在每一个函数前增加 ``@calcfunction`` 装饰器。 增加的装饰器使得 AiiDA "
"知晓被装饰的函数在执行后的可验证性需要被储存进可验证性图中 。 也就是执行函数后将输入和输出与一个算例节点连接。  "
"新的代码块还涉及将输入和输出储存进可验证性图。之前的代码中，输入和输出都是普通的python整型数据结构，是无法作为节点自动存入可验证性图中的。为实现该特性，用户只需要将输入输出封装成"
" :py:class:`~aiida.orm.nodes.data.int.Int`  类即可，这样他们就能够被储存进入数据库中了。"

#: ../../source/topics/calculations/concepts.rst:55
msgid ""
"The only difference with the previous snippet is that all inputs have been "
"wrapped in the :py:class:`~aiida.orm.nodes.data.int.Int` class. The result "
"that is returned by the function, is now also an "
":py:class:`~aiida.orm.nodes.data.int.Int` node that can be stored in the "
"provenance graph, and contains the result of the computation."
msgstr ""
"前后函数中的的代码差异就只是输入被封装成了 :py:class:`~aiida.orm.nodes.data.int.Int` 类。 "
"同样返回的结果也被封装成 :py:class:`~aiida.orm.nodes.data.int.Int` "
"包含计算结果的节点，可以储存进可验证性图中。"

#: ../../source/topics/calculations/concepts.rst:62
#: ../../source/topics/workflows/concepts.rst:45
msgid ""
"If a function argument is a Python base type (i.e. a value of type ``bool``,"
" ``dict``, ``Enum``, ``float``, ``int``, ``list`` or ``str``), it can be "
"passed straight away to the function, without first having to wrap it in the"
" corresponding AiiDA data type. That is to say, you can run the example "
"above also as:"
msgstr ""

#: ../../source/topics/calculations/concepts.rst:69
#: ../../source/topics/workflows/concepts.rst:52
msgid ""
"and AiiDA will recognize that the arguments are of type ``int`` and "
"automatically wrap them in an ``Int`` node."
msgstr ""

#: ../../source/topics/calculations/concepts.rst:73
msgid ""
"Since ``x`` and ``y`` inside the ``add`` and ``multiply`` functions are "
"already :py:class:`~aiida.orm.nodes.data.int.Int` instances the sum will "
"also be one. This is true because all arithmetic operators also work on the "
"base AiiDA classes (``Int``, ``Float``, etc.) as they would on the "
"equivalent python types. It is important to realize though that only "
":py:class:`~aiida.orm.nodes.node.Node` instances, or sub classes thereof can"
" be stored. For more information on how to return results from process "
"functions, refer to the :ref:`advanced "
"section<topics:calculations:usage:calcfunctions>`."
msgstr ""
"因为函数 ``add`` 和 ``multiply`` 中的 ``x`` 和 ``y`` 都已经是 "
":py:class:`~aiida.orm.nodes.data.int.Int` "
"类的实例，因为所有的运算都已经重载，无需类型转换便可以用于AiiDA类( ``Int``, ``Float``, "
"等)，他们等价于python本身的类型。需要清楚的记住只有 :py:class:`~aiida.orm.nodes.node.Node` "
"的实例，或是其子类的实例可以被储存进数据库。有关如何从例程函数中返回可储存的结果，请参考 :ref:`进阶章节 "
"<topics:calculations:usage:calcfunctions>`"

#: ../../source/topics/calculations/concepts.rst:78
msgid ""
"With these trivial changes, the full provenance of the result produced by "
"running the function is maintained and looks like the following:"
msgstr "在这样简单的修改后，函数运行并产生结果的整个可验证性就被保留下来，如下所示："

#: ../../source/topics/calculations/concepts.rst:83
msgid "The provenance generated by the calcfunction example"
msgstr "算例例子生成的可验证性图"

#: ../../source/topics/calculations/concepts.rst:85
msgid ""
"The example above already shows how a calcfunction can be run: simply by "
"calling it. The value that is returned is the result returned by the "
"definition of the function. However, sometimes one would also like to have a"
" reference to the calculation node that represents the execution of the "
"function in the provenance graph. The following example shows two additional"
" launch functions that will return a tuple, which in addition to the "
"results, also return the ``pk`` or the node associated with the process"
msgstr ""
"上面的例子展示了如何运行一个算例：简单的调用并运行。算例返回的结果就是对应函数的结果。然而用户可能还会想要得到有关算例节点的信息。下列代码块展示了如何用另外两个函数在运行的同时获得例程的"
" ``pk`` 和节点信息。"

#: ../../source/topics/calculations/concepts.rst:93
msgid ""
"This was a very short and limited description of calculation functions. For "
"a more detailed description of launching them, please refer to the section "
"on :ref:`launching processes<topics:processes:usage:launching>`. If you want"
" more details on implementing calculation functions and best practices, "
"refer to the section on :ref:`working with calculation "
"functions<topics:calculations:usage:calcfunctions>`."
msgstr ""
"这是一个关于算例函数的一个简单概述。请从以下链接 :ref:`启动例程 <topics:processes:usage:launching>`` "
"中获得有关如可启动例程的详细细节。如果你想要知晓有关如何实现一个算例函数并找到更为详细的示例，请参考章节 :ref:`算例函数的编写 "
"<topics:calculations:usage:calcfunctions>`。 "

#: ../../source/topics/calculations/concepts.rst:101
#: ../../source/topics/calculations/usage.rst:64
msgid "Calculation jobs"
msgstr "算例任务(Calculation jobs)"

#: ../../source/topics/calculations/concepts.rst:103
msgid ""
"In the previous section on :ref:`calculation "
"functions<topics:calculations:concepts:calcfunctions>`, we showed how a "
"simple python function can be transformed into a process, such that when it "
"is launched, its execution is recorded automatically in the provenance "
"graph. However, not all computations are well suited to be implemented as a "
"python function, but rather are implemented as a separate code, external to "
"AiiDA. To interface an external code with the engine of AiiDA, the "
":py:class:`~aiida.engine.processes.calcjobs.calcjob.CalcJob` process class "
"was introduced. A detailed explanation of how to implement it, the interface"
" and best practices, can be found in a :ref:`later "
"section<topics:calculations:usage:calcjobs>`. Here, instead, we will focus "
"on the big picture and explain in broad lines how a calculation job models "
"the execution of an external code and what tasks it performs when launched."
msgstr ""
"在前面章节 :ref:`算例函数 <topics:calculations:concepts:calcfunctions>` "
"，我们展示了如何将简单的python函数转换成一个例程，以使其在启动执行后，其结果能够自动记录在可验证性图中。然而并非所有计算过程都能够通过简单的python函数实现，而是通常涉及外部代码来实现。为了实现外部代码与内部引擎的接口"
" AiiDA 引入了 :py:class:`~aiida.engine.processes.calcjobs.calcjob.CalcJob` "
"process 类 。 可以在 :ref:`后续章节 <topics:calculations:usage:calcjobs>` "
"中找到关于如何实现与外部代码接口的细节和示例。这里，只关注算例任务的整体特征和使用场景，即如何通过算例任务来驱动外部代码的运行。"

#: ../../source/topics/calculations/concepts.rst:109
msgid ""
"To illustrate how a calculation job operates, we need an external code. "
"Let's imagine an external code that consists of a bash script that reads an "
"input file containing two integers, sums them and prints the result in the "
"standard output using ``echo``, for example:"
msgstr ""
"为了展示算例任务是如何工作的，我们首先需要一份外部代码样例。我们假设一个外部代码是一个bash脚本，它读入一个包含两个整数的文件，并将他们求和后返回结果，如："

#: ../../source/topics/calculations/concepts.rst:120
msgid ""
"When run, this script reads the contents of a file called ``aiida.in`` and "
"expects that it contains two integers. It will parse these into the "
"variables ``x`` and ``y`` and then print their sum. When you want to run "
"this 'code' through AiiDA, you need to tell *how* AiiDA should run it. The "
":py:class:`~aiida.calculations.arithmetic.add.ArithmeticAddCalculation` is a"
" calculation job implementation that forms an interface to accomplish "
"exactly that for the example bash script. A ``CalcJob`` implementation for a"
" specific code, often referred to as a calculation plugin, essentially "
"instructs the engine how it should be run. This includes how the necessary "
"input files should be created based on the inputs that it receives, how the "
"code executable should be called and what files should be retrieved when the"
" calculation is complete. Note the files should be 'retrieved' because "
"calculation jobs can be run not just on the localhost, but on any "
":ref:`computer that is configured in AiiDA<how-to:run-codes:computer>`, "
"including remote machines accessible over for example SSH."
msgstr ""

#: ../../source/topics/calculations/concepts.rst:128
msgid ""
"Since a ``CalcJob`` is a process just like the :ref:`calculation "
"functions<topics:calculations:concepts:calcfunctions>` described before, "
"they can be run in an identical way."
msgstr ""
"因为 ``CalcJob`` 和前面所述的 :ref:`算例函数 "
"<topics:calculations:concepts:calcfunctions>` 一样是一个例程，所以他们通过相同的方式运行。"

#: ../../source/topics/calculations/concepts.rst:133
msgid ""
"the provenance generated by running the calculation job will look something "
"like this:"
msgstr "通过运行算例任务产生的可验证性图如下所示："

#: ../../source/topics/calculations/concepts.rst:138
msgid "The provenance generated by the calculation job example"
msgstr "算例任务例子生成的可验证性图"

#: ../../source/topics/calculations/concepts.rst:140
msgid ""
"The execution of the calculation job is represented in the provenance graph "
"by a process node, i.e. the pink square labeled `C\\ :sub:`1`` in "
":numref:`fig_calculation_jobs_provenance_arithmetic_add`. The integer data "
"nodes ``x`` and ``y`` that were passed as inputs are linked to the "
"calculation job as such, as well as the third input ``code``. This input is "
"required for *all* calculation jobs as it represents the external code that "
"is actually executed. These code nodes are instances of the "
":py:class:`~aiida.orm.nodes.data.code.abstract.AbstractCode` class, which is"
" a sub-class of :py:class:`~aiida.orm.nodes.data.data.Data`. This means that"
" code instances are a sort of data node. Its function is to record the path "
"to the executable and some other code related attributes defined during the "
"code setup."
msgstr ""

#: ../../source/topics/calculations/concepts.rst:147
msgid ""
"The calculation job produced two outputs, an integer node, containing the "
"sum of ``x`` and ``y`` and a "
":py:class:`~aiida.orm.nodes.data.folder.FolderData` node, containing the "
"output files that were retrieved. Note that all outputs of calculation jobs "
"(except for the ``retrieved`` node) are technically not created by the "
"calculation job itself, but rather by an implementation of the "
":py:class:`~aiida.parsers.parser.Parser` class. In principle, this step is "
"optional, and so a calculation job is therefore not required to produce any "
"outputs, except for the ``retrieved`` folder data node, which will always be"
" there. How the parser fits into the concept of calculation jobs will be "
"addressed in :ref:`this "
"section<topics:calculations:concepts:calcjobs_parsers>`."
msgstr ""
"这个算例任务生成两个输出，一个是包含了 ``x`` 和 ``y`` 求和结果的整数数据节点，和一个数据类型为 "
":py:class:`~aiida.orm.nodes.data.folder.FolderData`  "
"的节点，该节点包含了存放计算结果的文件夹。需要注意到的是，（除了 ``retrieved`` "
"节点）所有的算例任务的计算结果都不是由其自身产生的，而是通过 :py:class:`~aiida.parsers.parser.Parser` "
"类解析产生的。原则上解析的步骤不是必须的因此算例任务可以没有输出，但一定会有 ``retrieved``` "
"数据节点。有关算例任务中结果解析器概念的详细内容请参考 :ref:`这里 "
"<topics:calculations:concepts:calcjobs_parsers>`。"

#: ../../source/topics/calculations/concepts.rst:155
msgid "Transport tasks"
msgstr "传输任务"

#: ../../source/topics/calculations/concepts.rst:157
msgid ""
"To arrive at the provenance graph shown above in "
":numref:`fig_calculation_jobs_provenance_arithmetic_add`, the engine "
"performed quite some tasks. When a calculation job is launched, the engine "
"will take it roughly through the following steps:"
msgstr ""
"AiiDA内部引擎执行了一系列工作，以实现可验证性图 "
":numref:`fig_calculation_jobs_provenance_arithmetic_add` 。 "
"当一个算例任务启动时，AiiDA内部引擎执行下列步骤："

#: ../../source/topics/calculations/concepts.rst:160
msgid ""
"**Upload**: the calculation job implementation is used to transform the "
"input nodes into the required input files, which are uploaded to a 'working'"
" directory on the target machine"
msgstr "**上传** : 算例任务会从输入节点得到输入文件，再将输入文件上传到目标计算机器的工作目录中"

#: ../../source/topics/calculations/concepts.rst:161
msgid ""
"**Submit**: to execute the calculation, a job is submitted to the scheduler "
"of the computer on which the input `code` is configured."
msgstr "**提交** : 提交一个作业到作业调度工具到配置文件中 `code` 所在的计算机。 "

#: ../../source/topics/calculations/concepts.rst:162
msgid ""
"**Update**: the engine will query the scheduler to check for the status of "
"the calculation job"
msgstr "**更新**: 内部引擎会不断查询作业系统以返回算例任务的状态。"

#: ../../source/topics/calculations/concepts.rst:163
msgid ""
"**Retrieve**: once the job has finished, the engine will retrieve the output"
" files, specified by the calculation plugin and store them in a node "
"attached as an output node to the calculation"
msgstr "**获取**: 一旦作业结束，引擎会取回输出文件，依据算例插件中定义的方式将输出结果储存在可验证性图的节点中。"

#: ../../source/topics/calculations/concepts.rst:165
msgid ""
"All of these tasks require the engine to interact with the computer, or "
"machine, that will actually run the external code. Since the "
":py:class:`~aiida.orm.nodes.data.code.abstract.AbstractCode` that is used as"
" an input for the calculation job, which is configured for a specific "
":py:class:`~aiida.orm.computers.Computer`, the engine knows exactly how to "
"execute all these tasks. The ``CalcJob`` implementation itself then is "
"completely independent of the machine the code will be run on. To run the "
"calculation job on a different machine, all you have to do is change the "
"``code`` input to one that is configured for that machine. If the machine is"
" *not* the localhost, the engine will need a way to connect to the remote "
"machine in order to perform each of the four tasks listed above. The "
"mechanism that allows the engine to connect to the remote machine is called "
"a *transport* and therefore the tasks it performs using this transport are "
"called *transport tasks*."
msgstr ""

#: ../../source/topics/calculations/concepts.rst:176
msgid "Exponential backoff mechanism"
msgstr "指数退让机制"

#: ../../source/topics/calculations/concepts.rst:178
msgid ""
"In the case of calculation jobs being executed on a remote machine, the "
"engine will have to connect to the machine for each of the transport tasks. "
"In connecting to the remote, a whole host of potential problems may occur "
"that would cause the calculation job to fail. For example, the remote "
"machine may be down and as a result unreachable, or the engine itself may "
"lose its internet connection. However, these problems are often temporary. "
"To prevent the calculation job from excepting and it being lost forever, an "
"*exponential backoff mechanism* has been implemented. Whenever the engine "
"performs a transport task but encounters an exception, instead of letting "
"the calculation job fail, it will reschedule the same task to be executed "
"again at a later time. The task will be automatically rescheduled until it "
"finishes successfully, where the interval between tries increases "
"exponentially. If after 5 consecutive tries, the task still fails, instead "
"of rescheduling it, the engine will simply pause the calculation job. The "
"output of ``verdi process list`` will give more information on why the task "
"failed:"
msgstr ""
"当在远端机器执行算例的过程中，AiiDA引擎需要为每一个传输任务建立一条链接。当连接远端服务器时，所有服务器端的潜在问题都可能发生，这会导致算例任务失败。比如，远端计算资源可能宕机而导致结果无法获得，或者引擎所在的本地端可能无法连接网络。然而，这些问题都是不确定的。为了防止算例任务异常或一直无法连接，AiiDA使用了"
" *指数退让策略* "
"。当引擎执行了一个传输任务时遇到异常，算例任务不会直接失败，而是提交一个相同的任务后续重新执行。任务会自动重新加入作业系统直到其顺利结束。在连续5次尝试后，若任务还是失败，引擎会单纯的暂停算例任务而不是重新提交。``verdi"
" process list`` 能够输出有关任务失败的更多信息："

#: ../../source/topics/calculations/concepts.rst:197
msgid ""
"When there are calculation jobs that have been paused because the transport "
"tasks have failed multiple times, the user has the time to investigate the "
"problem. If the problem is determined to be temporary and it has been "
"resolved, one can use ``verdi process play`` to resume the paused processes."
" The engine will then automatically reschedule the task that failed last and"
" the calculation job will continue where it left off."
msgstr ""
"当算例任务因为传输任务失败后且反复重试后依旧无法连接而暂停后，用户可以查看问题。如果发现问题是临时发生的，且问题被解决后，用户可以重新使用 "
"``verdi process play`` 来恢复暂停的任务。AiiDA引擎会自动重新提交之前失败的任务，且暂停的算例任务会继续在停止的地方恢复执行。"

#: ../../source/topics/calculations/concepts.rst:201
msgid ""
"This exponential backoff mechanism makes the engine very robust with respect"
" to calculation jobs, reducing the loss of computational resources due to "
"temporary problems to an absolute minimum."
msgstr "该指数退让机制是的AiiDA内部引擎对于算例任务的稳健性提高，将临时问题发生所导致的计算资源浪费减少到最小。"

#: ../../source/topics/calculations/concepts.rst:205
msgid ""
"The parameters, such as the delays between retries and the maximum number of"
" retries, are currently not configurable, but they might be in the future."
msgstr "当前有关该策略的设置参数如重试间隔延时和最大重试次数都不能够修改，但在未来可能会支持修改。"

#: ../../source/topics/calculations/concepts.rst:210
msgid "Parsers"
msgstr "解析器"

#: ../../source/topics/calculations/concepts.rst:211
msgid ""
"The previous section explained how the ``CalcJob`` class functions as an "
"interface between AiiDA's engine and an external piece of code. The "
"calculation job plugin will instruct the engine how the :ref:`transport "
"tasks<topics:calculations:concepts:calcjobs_transport_tasks>` should be "
"accomplished. However, as mentioned before, those tasks stop after the "
"output files have been retrieved, which the engine will attach as a "
":py:class:`~aiida.orm.nodes.data.folder.FolderData` node with the label "
"``'retrieved'`` to the calculation job node. As far as the calculation job "
"goes that is all that is absolutely required. However, often one wants to "
"parse those output files into some specific outputs that should be "
"represented as individual nodes in the provenance graph. This can be "
"accomplished by implementing the :py:class:`~aiida.parsers.parser.Parser` "
"class and specifying it in the inputs of the calculation job. In that case, "
"the engine will call the parser after the output files created by the job "
"have been successfully retrieved. In the parser implementation, the "
"retrieved files can then be parsed and converted into output nodes. For "
"technical details on how to implement a parser for a calculation job and how"
" to specify it in the inputs, please refer to the :ref:`detailed parser "
"section<topics:calculations:usage:calcjobs:parsers>`,"
msgstr ""
"前面章节阐述了 ``CalcJob`` 类函数接口连接AiiDA引擎和外部运行代码。算例任务插件还会告知引擎 :ref:`传输任务 "
"<topics:calculations:concepts:calcjobs_transport_tasks>` "
"该如何结束。如前所述，任务在输出文件获取后停止，这时引擎会在算例任务节点后增加标记为 ``retrieved`` 的 "
":py:class:`~aiida.orm.nodes.data.folder.FolderData`  "
"节点。这样算例任务就顺利完成了。然而用户通常还会想要将输出文件解析为特定的输出并表示为可验证性图中的节点。这可以通过 "
":py:class:`~aiida.parsers.parser.Parser` "
"类来实现并在算例任务的输入中指定。这样，引擎就会在任务成功结束并创建输出文件后调用解析器。解析器通过以下方式实现，在获取文件后解析并转换成输出节点。有关解析器的实现细节以及如何在算例任务输入中指定解析器，请参考"
" :ref:`解析器详情章节 <topics:calculations:usage:calcjobs:parsers>` 。"

#: ../../source/topics/calculations/index.rst:5
msgid "Calculations"
msgstr "算例"

#: ../../source/topics/calculations/index.rst:7
msgid ""
"This topic section provides detailed information on the concept of "
"calculations in AiiDA and an extensive guide on how to work with them. An "
"introductory guide to working with calculations can be found in :ref:`\"How "
"to run external codes\"<how-to:plugin-codes>`."
msgstr ""
"本主题部分提供了关于AiiDA中算例概念的详细信息，以及关于如何使用它们的详细指南。关于如何使用算例的介绍性指南可以在 :ref:``如何运行外部代码 "
"<how-to:plugin-codes>`` 中找到 。"

#: ../../source/topics/calculations/usage.rst:5
#: ../../source/topics/processes/usage.rst:5
#: ../../source/topics/workflows/usage.rst:5
msgid "Usage"
msgstr "用法"

#: ../../source/topics/calculations/usage.rst:7
msgid ""
"This chapter assumes knowledge of the :ref:`basic "
"concept<topics:calculations:concepts>` and difference between calculation "
"functions and calculation jobs is known and when one should use on or the "
"other."
msgstr ""
"本章假设用户已知 :ref:``AiiDA基本概念 <topics:calculations:concepts>`` "
"和算例函数和算例任务之间的区别，以及何时应该使用。"

#: ../../source/topics/calculations/usage.rst:12
msgid ":ref:`calculation function<topics:calculations:usage:calcfunctions>`"
msgstr ":ref:`算例函数 <topics:calculations:usage:calcfunctions>`"

#: ../../source/topics/calculations/usage.rst:13
msgid ":ref:`calculation job<topics:calculations:usage:calcjobs>`"
msgstr ":ref:`算例任务<topics:calculations:usage:calcjobs>`"

#: ../../source/topics/calculations/usage.rst:15
msgid ""
"This section will provide detailed information and best practices on how to "
"implement these two calculation types."
msgstr "该章节提供了关于如何实现这两种算例的详细信息和案例。"

#: ../../source/topics/calculations/usage.rst:22
msgid ""
"The section on the :ref:`concept of calculation "
"functions<topics:calculations:concepts:calcfunctions>` already addressed "
"their aim: automatic recording of their execution with their inputs and "
"outputs in the provenance graph. The :ref:`section on process "
"functions<topics:processes:functions>` subsequently detailed the rules that "
"apply when implementing them, all of which to calculation functions, which "
"are a sub type, just like work functions. However, there are some "
"differences given that calculation functions are 'calculation'-like "
"processes and work function behave like 'workflow'-like processes. What this"
" entails in terms of intended usage and limitations for calculation "
"functions is the scope of this section."
msgstr ""
"章节 :ref:`算例函数及其概念 <topics:calculations:concepts:calcfunctions>` 已经描述了其使用目的: "
"自动在可验证性图中记录算例的运行和运行所需的输入和产生的输出。之后的 The :ref:`例程函数章节 "
"<topics:processes:functions>` "
"详细描述了实现例程函数时候的规则和细节，如同工作函数，规则和实现同时适用于例程函数这一例程函数的子类。但是，算例函数这种 “算例型” "
"的例程和工作函数这种“工作型” 的例程之间还是有些区别的。 就算例函数的预期使用和限制，还在本节描述。"

#: ../../source/topics/calculations/usage.rst:28
msgid "Creating data"
msgstr "创建数据"

#: ../../source/topics/calculations/usage.rst:29
msgid ""
"It has been said many times before: calculation functions, like all "
"'calculation'-like processes, `create` data, but what does `create` mean "
"exactly? In this context, the term 'create' is not intended to refer to the "
"simple creation of a new data node in the graph, in an interactive shell or "
"a script for example. But rather it indicates the creation of a new piece of"
" data from some other data through a computation implemented by a process. "
"This is then exactly what the calculation function does. It takes one or "
"more data nodes as inputs and returns one or more data nodes as outputs, "
"whose content is based on those inputs. As explained in the :ref:`technical "
"section<topics:processes:functions>`, outputs are created simply by "
"returning the nodes from the function. The engine will inspect the return "
"value from the function and attach the output nodes to the calculation node "
"that represents the calculation function. To verify that the output nodes "
"are in fact 'created', the engine will check that the nodes are not stored. "
"Therefore, it is very important that you **do not store the nodes you create"
" yourself**, or the engine will raise an exception, as shown in the "
"following example:"
msgstr ""
"前面曾多次提到: 算例函数，如同所有的“算例型”例程一样，能够  “创建” 数据，但所谓的“创建”具体指什么？ "
"在此处的上下文中，术语“创建”并不简单的描述通过交互式shell或脚本在可验证性图中创建数据节点。 "
"而是指代了通过例程实现的计算中从一些数据产生新的数据的过程。这就是算例函数所实际产生的效果。它以一个或多个数据节点作为输入，并返回以这些输入作为操作对象的一个或多个数据节点作为输出。正如小节"
" :ref:`技术细节 <topics:processes:functions>` "
"所解释的，输出是通过从函数中返回数据节点的方式简单创建的。后端引擎会从函数中检查返回值并将返回节点连接在表示算例函数的算例节点上。为验证输出节点确实是“创建”的，AiiDA引擎会检查这个节点是没有被储存过的。因此，"
" **不要手动储存你所创建的节点** 是很重要的，否则引擎会产生一个如下异常 :"

#: ../../source/topics/calculations/usage.rst:42
msgid ""
"Because the returned node is already stored, the engine will raise the "
"following exception:"
msgstr "因为返回的节点已经储存，AiiDA引擎会产生一个如下异常 :"

#: ../../source/topics/calculations/usage.rst:50
msgid ""
"The reason for this strictness is that a node that was stored after being "
"created in the function body, is indistinguishable from a node that was "
"already stored and had simply been loaded in the function body and returned,"
" e.g.:"
msgstr "该严格限制的原因是，节点需要在被创建后才会被储存，这有别与在函数体中或函数的返回中载入一个已经储存的节点，如 :"

#: ../../source/topics/calculations/usage.rst:55
msgid ""
"The loaded node would also have gotten a `create` link from the calculation "
"function, even though it was not really created by it at all. It is exactly "
"to prevent this ambiguity that calculation functions require all returned "
"output nodes to be *unstored*."
msgstr ""
"载入的节点会从算例函数中产生一个 `create` 连接，即便该节点不是由该函数创建的。正是为了避免这种模糊性，要求算例函数返回的所有输出节点都是 "
"*未储存* 的。"

#: ../../source/topics/calculations/usage.rst:58
msgid ""
"Note that work functions have exactly the opposite required and all the "
"outputs that it returns **have to be stored**, because as a 'workflow'-like "
"process, it *cannot* create new data. For more details refer to the "
":ref:`work function section<topics:workflows:usage:workfunctions>`."
msgstr ""
"注意到工作流函数有完全相反的要求，即所有函数返回的输出必须 *已经被储存* ，因为如一个“工作流”型的例程，它是 *不能* 创建新的数据的。详情请参考 "
":ref:`工作流函数小节 <topics:workflows:usage:workfunctions>` 。"

#: ../../source/topics/calculations/usage.rst:66
msgid ""
"To explain how a calculation job can be implemented, we will continue with "
"the example presented in the section on the :ref:`concept of the calculation"
" job<topics:calculations:concepts:calcjobs>`. There we described a code that"
" adds two integers, implemented as a simple bash script, and how the "
":py:class:`~aiida.engine.processes.calcjobs.calcjob.CalcJob` class can be "
"used to run this code through AiiDA. Since it is a sub class of the "
":py:class:`~aiida.engine.processes.process.Process` class, it shares all its"
" properties. It will be very valuable to have read the section on working "
"with :ref:`generic processes<topics:processes:usage>` before continuing, "
"because all the concepts explained there will apply also to calculation "
"jobs."
msgstr ""
"为描述如何实现算例任务，我们继续章节 :ref:`算例任务的概念 <topics:calculations:concepts:calcjobs>` "
"中展示的例子。例子中我们描述了对两个整数求和并通过简单的bash脚本实现的代码，以及 "
":py:class:`~aiida.engine.processes.calcjobs.calcjob.CalcJob` "
"类如何被用于在AiiDA中运行这段代码。因为该类是 "
":py:class:`~aiida.engine.processes.process.Process` "
"类的子类，则拥有它的全部性质。因此在继续之前阅读章节 :ref:`泛型例程 <topics:processes:usage>` "
"也是很有用的。因为那里所描述的所有特性在此处算例任务中同样适用。"

#: ../../source/topics/calculations/usage.rst:75
#: ../../source/topics/workflows/usage.rst:150
msgid "Define"
msgstr "定义"

#: ../../source/topics/calculations/usage.rst:76
msgid ""
"To implement a calculation job, one simply sub classes the "
":py:class:`~aiida.engine.processes.calcjobs.calcjob.CalcJob` process class "
"and implements the "
":py:meth:`~aiida.engine.processes.calcjobs.calcjob.CalcJob.define` method. "
"You can pick any name that is a valid python class name. The most important "
"method of the ``CalcJob`` class, is the ``define`` class method. Here you "
"define, what inputs it takes and what outputs it will generate."
msgstr ""
"要实现一个算例任务，使用者只需要继承 "
":py:class:`~aiida.engine.processes.calcjobs.calcjob.CalcJob` 例程类并实现 "
":py:meth:`~aiida.engine.processes.calcjobs.calcjob.CalcJob.define` "
"方法。你可以使用认可python许可的类名。``CalcJob`` 中最重要的方法是 ``define`` "
"类方法。在这个方法中，你定义了输入和算例运行产生的输出。"

#: ../../source/topics/calculations/usage.rst:84
msgid ""
"As the snippet above demonstrates, the class method takes two arguments:"
msgstr "如上面代码片段所展示的，该类方法接受两个参数 :"

#: ../../source/topics/calculations/usage.rst:86
msgid ""
"``cls`` this is the reference of the class itself and is mandatory for any "
"class method"
msgstr "``cls`` 是指向该类自身的可以访问类的所有类方法的变量"

#: ../../source/topics/calculations/usage.rst:87
msgid "``spec`` which is the 'specification'"
msgstr "``spec`` 是 “计算规格参数和详情” (specification)"

#: ../../source/topics/calculations/usage.rst:90
msgid ""
"Do not forget to add the line ``super().define(spec)`` as the first line of "
"the ``define`` method, where you replace the class name with the name of "
"your calculation job. This will call the ``define`` method of the parent "
"class, which is necessary for the calculation job to work properly"
msgstr ""
"请不要忘记在 ``define`` 方法的首行加入 ``super().define(spec)``  ，这里你需要用你自己的类名。这会调用 "
"``define`` 方法的父类，使得算例任务可以正确工作。"

#: ../../source/topics/calculations/usage.rst:93
msgid ""
"As the name suggests, the ``spec`` can be used to specify the properties of "
"the calculation job. For example, it can be used to define inputs that the "
"calculation job takes. In our example, we need to be able to pass two "
"integers as input, so we define those in the spec by calling "
"``spec.input()``. The first argument is the name of the input. This name "
"should be used later to specify the inputs when launching the calculation "
"job and it will also be used as the label for link to connect the data node "
"and the calculation node in the provenance graph. Additionally, as we have "
"done here, you can specify which types are valid for that particular input. "
"Since we expect integers, we specify that the valid type is the database "
"storable :py:class:`~aiida.orm.nodes.data.int.Int` class."
msgstr ""
"正如其名所示， ``spec`` "
"可以用于指定算例任务的性质。比如，它可以用于定义算例任务所需的输入。在我们的例子中，我们需要接受两个整数作为输入，所以我们通过调用 "
"``spec.input()`` 定义这些 “规格参数”。 "
"第一个参数是输入的名称。该名称之后会被用于在启动算例任务时输入的指定，还会被作为在可验证性图中连接算例节点的数据节点的标签。另外，正如我们在这里所用到的，你还可以指定特定输入允许的参数类型。因为我们在此处希望得到整形的变量，我们指定允许的类型是数据库可储存的"
" :py:class:`~aiida.orm.nodes.data.int.Int` 类。"

#: ../../source/topics/calculations/usage.rst:103
msgid ""
"Since we sub class from ``CalcJob`` and call its ``define`` method, it will "
"inherit the ports that it declares as well. If you look at the "
"implementation, you will find that the base class ``CalcJob`` already "
"defines an input ``code`` that takes a ``Code`` instance. This will "
"reference the code that the user wants to run when he launches the "
"``CalcJob``. For this reason, you **do not** again have to declare this "
"input."
msgstr ""
"因为我们继承了 ``CalcJob`` 类并调用了它的 ``define`` 方法，这会同时继承其声明的端口(port)。 "
"如果你查看类的实现，你会发现在基类 ``CalcJob`` 中已经定义了输入 ``code`` 以接受一个 ``Code`` 示例。这会指向用户在运行 "
"``CalcJob`` 时所要使用的计算代码。因此， **请不要** 重复声明该输入。"

#: ../../source/topics/calculations/usage.rst:108
msgid ""
"Next we should define what outputs we expect the calculation to produce:"
msgstr "之后我们需要定义我们期望得到的算例输出 :"

#: ../../source/topics/calculations/usage.rst:113
msgid ""
"Just as for the inputs, one can specify what node type each output should "
"have. By default a defined output will be 'required', which means that if "
"the calculation job terminates and the output has not been attached, the "
"process will be marked as failed. To indicate that an output is optional, "
"one can use ``required=False`` in the ``spec.output`` call. Note that the "
"process spec, and its :py:meth:`~plumpy.ProcessSpec.input` and "
":py:meth:`~plumpy.ProcessSpec.output` methods provide a lot more "
"functionality. Fore more details, please refer to the section on "
":ref:`process specifications<topics:processes:usage:spec>`."
msgstr ""
"如同输入，用户需要指定每个输出因有的节点类型。默认的，一个定义了的输出将会是 '必给的' "
"(required)，意味着如果算例任务终止但没有得到输出，则例程(process)会被标记为失败。要指明一个输出不是必须的而是可选的，用户可以在 "
"``spec.output`` 调用中使用 ``required=False``  。可以注意到，例程的规格详情以及其 "
":py:meth:`~plumpy.ProcessSpec.input` 和 :py:meth:`~plumpy.ProcessSpec.output`"
" 方法提供了许多功能。详情可以参考章节 :ref:`例程规格 <topics:processes:usage:spec>` 。"

#: ../../source/topics/calculations/usage.rst:123
msgid "Prepare"
msgstr "准备"

#: ../../source/topics/calculations/usage.rst:124
msgid ""
"We have now defined through the process specification, what inputs the "
"calculation job expects and what outputs it will create. The final remaining"
" task is to instruct the engine how the calculation job should actually be "
"run. To understand what the engine would have to do to accomplish this, "
"let's consider what one typically does when manually preparing to run a "
"computing job through a scheduler:"
msgstr ""
"通过例程的规格定义，我们能够知晓算例任务所期望的输入和将会产生的输出。剩下的任务就是告知引擎算例任务事实上需要如何运行。为了理解AiiDA引擎为了完成算例任务将会执行的步骤，我们来看一下当用户手动通过任务调度工具执行一个计算任务时会采取的具体步骤"
" :"

#: ../../source/topics/calculations/usage.rst:128
msgid ""
"Prepare a working directory in some scratch space on the machine where the "
"job will run"
msgstr "在计算资源的可用空间上，准备一个任务运行的工作文件夹"

#: ../../source/topics/calculations/usage.rst:129
msgid "Create the raw input files required by the executable"
msgstr "创建可执行软件所需的的原始输入文件"

#: ../../source/topics/calculations/usage.rst:130
msgid ""
"Create a launch script containing scheduler directives, loading of "
"environment variables and finally calling the executable with certain "
"command line parameters."
msgstr "创建一个包含调度程序指令的启动脚本，加载环境变量，最后使用特定命令行参数调用可执行文件。"

#: ../../source/topics/calculations/usage.rst:132
msgid ""
"So all we need to do now is instruct the engine how to accomplish these "
"things for a specific calculation job. Since these instructions will be "
"calculation dependent, we will implement this with the "
":py:meth:`~aiida.engine.processes.calcjobs.calcjob.CalcJob.prepare_for_submission`"
" method. The implementation of the ``ArithmeticAddCalculation`` that we are "
"considering in the example looks like the following:"
msgstr ""
"所以我们要做的就是直到AiiDA引擎对指定算例任务完成这些步骤。由于这些步骤对每个计算是不同的，我们需要通过 "
":py:meth:`~aiida.engine.processes.calcjobs.calcjob.CalcJob.prepare_for_submission`"
" 方法来实现这些步骤。在样例中展示的 ``ArithmeticAddCalculation`` 实现如下 :"

#: ../../source/topics/calculations/usage.rst:139
msgid ""
"Before we go into the code line-by-line, let's describe the big picture of "
"what is happening here. The goal of this method is to help the engine "
"accomplish the three steps required for preparing the submission a "
"calculation job, as described above. The raw input files that are required "
"can be written to a sandbox folder that is passed in as the ``folder`` "
"argument."
msgstr ""
"在我们逐行研究代码之前，让我们先描述一下这里发生的事情的全貌。该类方法的目的是帮助AiiDA引擎完成如上所述的准备和提交计算任务所需的三个步骤。所需的原始输入文件可以写入沙箱文件夹，该文件夹之后会以"
" ``folder`` 参数传入。"

#: ../../source/topics/calculations/usage.rst:145
msgid ""
"The ``folder`` argument points to a temporary sandbox folder on the local "
"file system that can be used to write the input files to. After the "
"``prepare_for_submission`` method returns, the engine will take those "
"contents and copy them to the working directory where the calculation will "
"be run. On top of that, these files will also be written to the file "
"repository of the node that represents the calculation as an additional "
"measure of provenance. Even though the information written there should be a"
" derivation of the contents of the nodes that were passed as input nodes, "
"since it is a derived form we store this explicitly nonetheless. Sometimes, "
"this behavior is undesirable, for example for efficiency or data privacy "
"reasons, so it can be controlled with various lists such as "
":ref:`local_copy_list "
"<topics:calculations:usage:calcjobs:file_lists_local_copy>` and "
":ref:`provenance_exclude_list "
"<topics:calculations:usage:calcjobs:file_lists_provenance_exclude>`."
msgstr ""
"``folder`` 参数指向本地文件系统上的一个临时沙箱文件夹，可用于将输入文件写入。在 ``prepare_for_submission`` "
"方法返回后，引擎将获取这些文件并将它们复制到运行计算的工作目录中。在此基础上，这些文件还将被写入表示计算节点的文件存储库，用作保存详细的额外的可验证性。即使写在那里的信息应该是作为输入节点传递的节点内容的派生，我们仍然显式地存储它。有时，这并非预期的行为，例如出于效率或数据隐私的原因。因此可以使用各种列表来控制它，例如"
" :ref:`local_copy_list "
"<topics:calculations:usage:calcjobs:file_lists_local_copy>` 和 "
":ref:`provenance_exclude_list "
"<topics:calculations:usage:calcjobs:file_lists_provenance_exclude>` 。"

#: ../../source/topics/calculations/usage.rst:151
msgid ""
"All the other required information, such as the directives of which files to"
" copy and what command line options to use are defined through the "
":py:class:`~aiida.common.datastructures.CalcInfo` datastructure, which "
"should be returned from the method as the only value. In principle, this is "
"what one **should do** in the ``prepare_for_submission`` method:"
msgstr ""
"所需的其他所有信息，如拷贝文件的指令和指令参数均通过 :py:class:`~aiida.common.datastructures.CalcInfo`"
" 数据结构定义，这个值应该作为方法返回的唯一值。理论上，这是用户在方法 ``prepare_for_submission`` 中 **应该做的** :"

#: ../../source/topics/calculations/usage.rst:154
msgid ""
"Writing raw inputs files required for the calculation to run to the "
"``folder`` sandbox folder."
msgstr "编写运行计算所需的原始输入文件到 ``folder`` 沙箱文件夹。"

#: ../../source/topics/calculations/usage.rst:155
msgid ""
"Use a ``CalcInfo`` to instruct the engine which files to copy to the working"
" directory"
msgstr "使用 ``CalcInfo`` 告诉引擎将被复制到工作目录的文件"

#: ../../source/topics/calculations/usage.rst:156
msgid ""
"Use a ``CalcInfo`` to tell which codes should run, using which command line "
"parameters, such as standard input and output redirection."
msgstr "使用 ``CalcInfo`` 来决定应运行的计算代码，以及使用哪些命令行参数，例如标准输入和输出重定向。"

#: ../../source/topics/calculations/usage.rst:160
msgid ""
"The ``prepare_for_submission`` does not have to write the submission script "
"itself. The engine will know how to do this, because the codes that are to "
"be used have been configured on a specific computer, which defines what "
"scheduler is to be used. This gives the engine all the necessary information"
" on how to write the launch script such as what scheduler directives to "
"write."
msgstr ""
"函数 ``prepare_for_submission`` "
"中不需要自己编写任务提交脚本。引擎知道如何编写任务脚本，因为使用的计算代码在配置时已经关联到特定计算资源上，因此其上的任务调度工具也就被记录在计算代码中。这也就告知了AiiDA引擎有关如何编写任务提交脚本比如任务调度指令等的全部信息。"

#: ../../source/topics/calculations/usage.rst:164
msgid ""
"Now that we know what the ``prepare_for_submission`` is expected to do, "
"let's see how the implementation of the ``ArithmeticAddCalculation`` "
"accomplishes it line-by-line. The input file required for this example "
"calculation will consist of the two integers that are passed as inputs. The "
"``self.inputs`` attribute returns an attribute dictionary with the parsed "
"and validated inputs, according to the process specification defined in the "
"``define`` method. This means that you do not have to validate the inputs "
"yourself. That is to say, if an input is marked as required and of a certain"
" type, by the time we get to the ``prepare_for_submission`` it is guaranteed"
" that the dictionary returned by ``self.inputs`` will contain that input and"
" of the correct type."
msgstr ""
"现在我们知道 ``prepare_for_submission`` 的预期功能，让我们逐行看看 ``ArithmeticAddCalculation``"
" 的实现。此示例所需的输入文件包含作为输入传递的两个整数。 ``self.inputs`` 属性根据 ``define`` "
"方法中定义的过程规范返回解析和验证好的输入的属性字典。这意味着用户不必自己验证输入。也就是说，如果输入被标记为必须的，以及某种指定类型，那么当我们运行 "
"``prepare_for_submission`` 时，``self.inputs`` 返回的字典将确保包含正确类型的输入。"

#: ../../source/topics/calculations/usage.rst:170
msgid ""
"From the two inputs ``x`` and ``y`` that will have been passed when the "
"calculation job was launched, we should now generate the input file, that is"
" simply a text file with these two numbers on a single line, separated by a "
"space. We accomplish this by opening a filehandle to the input file in the "
"sandbox folder and write the values of the two ``Int`` nodes to the file."
msgstr ""
"计算作业启动，两个输入 ``x`` 和 ``y`` "
"会被传入，我们应确保输入文件只是包含一行两个数组的文本文件，这两个数字在一行上，被空间隔开。我们通过在沙箱文件夹中打开到输入文件的文件句柄并将两个 "
"``Int`` 节点的值写入文件来实现此目的。"

#: ../../source/topics/calculations/usage.rst:175
msgid ""
"The format of this input file just so happens to be the format that the "
":ref:`bash script<topics:calculations:concepts:calcjobs>` expects that we "
"are using in this example. The exact number of input files and their content"
" will of course depend on the code for which the calculation job is being "
"written."
msgstr ""
"这个输入文件的格式恰好是 :ref:`bash 脚本 <topics:calculations:concepts:calcjobs>` "
"期望我们在本例中使用的格式。输入文件的确切数量及其内容当然将取决于为其编写算例任务的代码。"

#: ../../source/topics/calculations/usage.rst:178
msgid ""
"With the input file written, we now have to create an instance of "
":py:class:`~aiida.common.datastructures.CalcInfo` that should be returned "
"from the method. This data structure will instruct the engine exactly what "
"needs to be done to execute the code, such as what files should be copied to"
" the remote computer where the code will be executed. In this simple "
"example, we define four simple attributes:"
msgstr ""
"写好输入文件后，我们现在必须创建一个 :py:class:`~aiida.common.datastructures.CalcInfo` "
"的实例，该实例应该从方法返回。这个数据结构将精确地指示引擎如何执行计算代码，比如应该将哪些文件复制到将要执行代码的远程计算机。在这个简单的例子中，我们定义了四个简单的属性:"

#: ../../source/topics/calculations/usage.rst:182
msgid ""
"``codes_info``: a list of :py:class:`~aiida.common.datastructures.CodeInfo` "
"datastructures, that tell which codes to run consecutively during the job"
msgstr ""
"``codes_info``: 一个由数据结构 :py:class:`~aiida.common.datastructures.CodeInfo` "
"构成的列表，用以告知任务运行期间要顺序执行的计算代码"

#: ../../source/topics/calculations/usage.rst:183
msgid ""
"``local_copy_list``: a list of tuples that instruct what files to copy to "
"the working directory from the local machine"
msgstr "``local_copy_list``: 元组列表，指示要从本地计算机复制哪些文件到工作目录"

#: ../../source/topics/calculations/usage.rst:184
msgid ""
"``remote_copy_list``: a list of tuples that instruct what files to copy to "
"the working directory from the machine on which the job will run"
msgstr "``remote_copy_list``: 一个元组列表，它指示要将哪些文件从运行任务的机器复制到工作目录"

#: ../../source/topics/calculations/usage.rst:185
msgid ""
"``retrieve_list``: a list of tuples instructing which files should be "
"retrieved from the working directory and stored in the local repository "
"after the job has finished"
msgstr "``retrieve_list``: 一个元组列表，指示应从工作目录检索哪些文件，并在作业完成后存储在本地存储库中"

#: ../../source/topics/calculations/usage.rst:187
msgid ""
"In this example we only need to run a single code, so the ``codes_info`` "
"list has a single ``CodeInfo`` datastructure. This datastructure needs to "
"define which code it needs to run, which is one of the inputs passed to the "
"``CalcJob``, and does so by means of its UUID. Through the ``stdout_name`` "
"attribute, we tell the engine where the output of the executable should be "
"redirected to. In this example this is set to the value of the  "
"``output_filename`` option. What options are available in calculation jobs, "
"what they do and how they can be set will be explained in the :ref:`section "
"on options<topics:calculations:usage:calcjobs:options>`. Finally, the "
"``cmdline_params`` attribute takes a list with command line parameters that "
"will be placed *after* the executable in the launch script. Here we use it "
"to explicitly instruct the executable to read its input from the filename "
"stored in the option ``input_filename``."
msgstr ""
"在本例中，我们只需要运行一个计算代码，因此 ``codes_info`` 列表有一个 ``CodeInfo`` "
"数据结构。这个数据结构需要定义它需要运行哪些代码，这是传递给 ``CalcJob`` 的输入之一，并通过它的UUID来实现。通过 "
"``stdout_name`` 属性，我们告诉引擎可执行文件的输出应该重定向到哪里。在本例中，它被设置为 ``output_filename`` "
"选项的值。计算作业中有哪些选项可用，它们做什么以及如何设置这些选项，将在 :ref:`选项章节 "
"<topics:calculations:usage:calcjobs:options>` 中进行说明。最后，``cmdline_params`` "
"属性接受一个带有命令行参数的列表，这些命令行参数将放在启动脚本中可执行文件的 *后面* 。在这里，我们使用它显式地指示可执行文件从存储在选项 "
"``input_filename`` 中的文件名中读取其输入。"

#: ../../source/topics/calculations/usage.rst:197
msgid ""
"Since we instruct the executable should read the input from "
"``self.options.input_filename``, this is also the filename we used when "
"writing that very input file in the sandbox folder."
msgstr ""
"因为我们指示可执行文件应该从 ``self.options.input_filename`` "
"读取输入，这也是我们在数据临时储存文件夹中编写输入文件时使用的文件名。"

#: ../../source/topics/calculations/usage.rst:199
msgid ""
"Finally, we have to define the various \"file lists\" that tell what files "
"to copy from where to where and what files to retrieve. Here we will briefly"
" describe their intended goals. The implementation details will be described"
" in full in the :ref:`file lists "
"section<topics:calculations:usage:calcjobs:file_lists>`."
msgstr ""
"最后，我们必须定义各种“文件列表”，这些“文件列表”告诉我们要将哪些文件从何处复制到何处，以及要检索哪些文件。在这里，我们将简要描述他们的预期目标。实现细节将在"
" :ref:`文件列表章节 <topics:calculations:usage:calcjobs:file_lists>` 中详细描述。"

#: ../../source/topics/calculations/usage.rst:203
msgid ""
"The local copy list is useful to instruct the engine to copy over files that"
" you might already have stored in your database, such as instances of "
":py:class:`~aiida.orm.nodes.data.singlefile.SinglefileData` nodes, that you "
"can define and pass as inputs of the ``CalcJob``. You could have of course "
"many copied their content to the ``folder`` sandbox folder, which will also "
"have caused them to be written to the working directory. The disadvantage of"
" that method, however, is that all the contents written to the sandbox "
"folder will also be stored in the repository of the ``CalcJobNode`` that "
"will represent the execution of the ``CalcJob`` in the provenance graph. "
"This will cause duplication of the data contained within these data nodes. "
"By not writing them explicitly to the sandbox folder, you avoid this "
"duplication, without losing provenance, because the data node itself will of"
" course be recorded in the provenance graph."
msgstr ""
"本地复制列表用于指示引擎复制可能已经存储在数据库中的文件，例如  "
":py:class:`~aiida.orm.nodes.data.singlefile.SinglefileData` 实例节点。您可以定义并传递为 "
"``CalcJob`` "
"的输入。你当然可以将它们的内容复制到沙箱文件夹中，这也会导致它们被写入工作目录。然而，这种方法的缺点是，写入到沙箱文件夹的所有内容也将被存储在 "
"``CalcJobNode`` 的存储库中，它将代表可验证性图中的 ``CalcJob`` "
"的执行节点。这将导致这些数据节点中包含的数据重复。通过不显式地将它们写入沙箱文件夹，您可以避免这种重复，而不会丢失可验证性，因为数据节点本身当然会被记录在可验证性图中。"

#: ../../source/topics/calculations/usage.rst:209
msgid ""
"The remote copy list is useful to avoid unnecessary file transfers between "
"the machine where the engine runs and where the calculation jobs are "
"executed. For example, imagine you have already completed a calculation job "
"on a remote cluster and now want to launch a second one, that requires some "
"of the output files of the first run as its inputs. The remote copy list "
"allows you to specify exactly what output files to copy to the remote "
"working directory, without them having to be retrieved to the engine's "
"machine in between."
msgstr ""
"远程复制列表有助于避免在运行引擎的计算机与执行计算作业的位置之间进行不必要的文件传输。例如，假设您已经在远程集群上完成了计算作业，现在想要启动第二个计算作业，这需要第一次运行的某些输出文件作为其输入。远程复制列表允许您准确指定要复制到远程工作目录的输出文件，而不必将它们检索到引擎的机器之间。"

#: ../../source/topics/calculations/usage.rst:213
msgid ""
"The retrieve list, finally, allows you to instruct the engine what files "
"should be retrieved from the working directory after the job has terminated."
" These files will be downloaded to the local machine, stored in a "
":py:class:`~aiida.orm.nodes.data.folder.FolderData` data node and attached "
"as an output to the ``CalcJobNode`` with the link label ``retrieved``."
msgstr ""
"最后，检索列表允许您指示引擎在作业终止后应从工作目录中检索哪些文件。这些文件将被下载到本地机器，存储在 "
":py:class:`~aiiida.orm.nodes.data.folder.FolderData`数据节点中，并作为输出附加到``CalcJobNode``"
" 的 ``retrieved`` 链接标签  。"

#: ../../source/topics/calculations/usage.rst:218
msgid ""
"We didn't explicitly define the ``retrieved`` folder data node as an output "
"in the example ``ArithmeticAddCalculation`` implementation shown above. This"
" is because this is already defined by the ``CalcJob`` base class. Just as "
"the ``code`` input, the ``retrieved`` output is common for all calculation "
"job implementations."
msgstr ""
"我们没有明确地将 ``retrieve`` 文件夹数据节点定义为上面显示的示例 ``ArithmeticAddCalculation`` "
"实现中的输出。这是因为它已经由 ``CalcJob`` 基类定义。正如 ``code`` 输入一样， ``retrieve`` "
"输出对于所有计算作业实现都是通用的。"

#: ../../source/topics/calculations/usage.rst:226
msgid "File lists"
msgstr "文件列表"

#: ../../source/topics/calculations/usage.rst:231
msgid "Local copy list"
msgstr "本地复制列表"

#: ../../source/topics/calculations/usage.rst:232
msgid ""
"The local copy list takes tuples of length three, each of which represents a"
" file or directory to be copied, defined through the following items:"
msgstr ""

#: ../../source/topics/calculations/usage.rst:234
msgid ""
"`node uuid`: the node whose repository contains the file, typically a "
"``SinglefileData`` or ``FolderData`` node"
msgstr "`node uuid`: 其存储库包含文件的节点，通常是 ``SinglefileData`` 或 ``FolderData`` 节点"

#: ../../source/topics/calculations/usage.rst:235
msgid ""
"`source relative path`: the relative path of the file or directory within "
"the node repository"
msgstr ""

#: ../../source/topics/calculations/usage.rst:236
msgid ""
"`target relative path`: the relative path within the working directory to "
"which to copy the file or directory contents"
msgstr ""

#: ../../source/topics/calculations/usage.rst:238
msgid ""
"As an example, consider a ``CalcJob`` implementation that receives a "
"``SinglefileData`` node as input with the name ``pseudopotential``, to copy "
"its contents one can specify:"
msgstr ""
"作为一个例子，考虑一个 ``CalcJob`` 实现，它接收一个名为 ``pseudopotential`` 的 ``SinglefileData`` "
"节点作为输入，以复制其可以指定的内容:"

#: ../../source/topics/calculations/usage.rst:244
msgid ""
"The ``SinglefileData`` node only contains a single file by definition, the "
"relative path of which is returned by the ``filename`` attribute. If "
"instead, you need to transfer a specific file from a ``FolderData``, you can"
" specify the explicit key of the file, like so:"
msgstr ""
"根据定义， ``SinglefileData`` 节点只包含一个文件，其相对路径由 ``filename`` 属性返回。相反，如果需要从 "
"``FolderData`` 传输特定文件，则可以指定文件的显式键，如下所示:"

#: ../../source/topics/calculations/usage.rst:251
msgid ""
"Note that the filenames in the relative source and target path need not be "
"the same. This depends fully on how the files are stored in the node's "
"repository and what files need to be written to the working directory."
msgstr "请注意，相对源和目标路径中的文件名不必相同。这完全取决于文件如何存储在节点的存储库中以及需要将哪些文件写入工作目录。"

#: ../../source/topics/calculations/usage.rst:254
msgid ""
"To copy the contents of a directory of the source node, simply define it as "
"the `source relative path`. For example, imagine we have a `FolderData` node"
" that is passed as the `folder` input, which has the following repository "
"virtual hierarchy:"
msgstr ""

#: ../../source/topics/calculations/usage.rst:263
msgid ""
"If the entire content needs to be copied over, specify the "
"``local_copy_list`` as follows:"
msgstr ""

#: ../../source/topics/calculations/usage.rst:269
msgid ""
"The ``'.'`` here indicates that the entire contents need to be copied over. "
"Alternatively, one can specify a sub directory, e.g.:"
msgstr ""

#: ../../source/topics/calculations/usage.rst:276
msgid ""
"Finally, the `target relative path` can be used to write the contents of the"
" source repository to a particular sub directory in the working directory. "
"For example, the following statement:"
msgstr ""

#: ../../source/topics/calculations/usage.rst:283
msgid ""
"will result in the following file hierarchy in the working directory of the "
"calculation:"
msgstr ""

#: ../../source/topics/calculations/usage.rst:291
msgid ""
"One might think what the purpose of the list is, when one could just as "
"easily use normal the normal API to write the file to the ``folder`` sandbox"
" folder. It is true, that in this way the file will be copied to the working"
" directory, however, then it will *also* be copied into the repository of "
"the calculation node. Since in this case it is merely a direct one-to-one "
"copy of the file that is already part of one of the input nodes (in an "
"unaltered form), this duplication is unnecessary and adds useless weight to "
"the file repository. Using the ``local_copy_list`` prevents this unnecessary"
" duplication of file content. It can also be used if the content of a "
"particular input node is privacy sensitive and cannot be duplicated in the "
"repository."
msgstr ""
"有人可能会想这个列表的目的是什么，因为可以很容易地使用普通的API把文件写到 ``folder`` "
"沙箱文件夹。的确，通过这种方式文件将被复制到工作目录中，但是，它 **也** "
"将复制到计算节点的存储库中。由于在本例中，它仅仅是一个已经是一个输入节点的一部分的文件的直接一对一的副本(以未更改的形式)，因此这种复制是不必要的，并给文件存储库增加了无用的权重。使用"
" ``local_copy_list`` 可以防止这种不必要的文件内容重复。如果特定输入节点的内容是隐私敏感的，并且不能在存储库中复制，也可以使用它。"

#: ../../source/topics/calculations/usage.rst:300
msgid "Provenance exclude list"
msgstr "可验证性排除列表"

#: ../../source/topics/calculations/usage.rst:301
msgid ""
"The :ref:`local_copy_list "
"<topics:calculations:usage:calcjobs:file_lists_local_copy>`  allows one to "
"instruct the engine to write files from the input files to the working "
"directory, without them *also* being copied to the file repository of the "
"calculation node. As discussed in the corresponding section, this is useful "
"in order to avoid duplication or in case where the data of the nodes is "
"proprietary or privacy sensitive and cannot be duplicated arbitrarily "
"everywhere in the file repository. However, the limitation of the "
"``local_copy_list`` is that the it can only target single files in its "
"entirety and cannot be used for arbitrary files that are written to the "
"``folder`` sandbox folder. To provide full control over what files from the "
"``folder`` are stored permanently in the calculation node file repository, "
"the ``provenance_exclude_list`` is introduced. This "
":py:class:`~aiida.common.datastructures.CalcInfo` attribute is a list of "
"filepaths, relative to the base path of the ``folder`` sandbox folder, which"
" *are not stored* in the file repository."
msgstr ""
":ref:`local_copy_list "
"<topics:calculations:usage:calcjobs:file_lists_local_copy>` "
"允许指示引擎将文件从输入文件写入工作目录，而不 *同时* "
"复制到计算节点的文件存储库。正如在相应的部分中所讨论的，为了避免重复，或者当节点的数据是专有的或隐私敏感的，且不能在文件存储库中的任意位置重复时，这是有用的。然而，"
" ``local_copy_list`` 的限制是，它只能针对单个文件的整体，不能用于写入 ``folder`` 沙箱文件夹的任意文件。为了完全控制 "
"``folder`` 中的文件永久存储在计算节点文件存储库中，我们引入了 ``provenance_exclude_list``。这个 "
":py:class:`~aiida.common.datastructures.CalcInfo` 属性是一个文件路径列表，相对于 ``folder``"
" 沙箱文件夹的基本路径，它 *不存储* 在文件存储库中。"

#: ../../source/topics/calculations/usage.rst:307
msgid ""
"Consider the following file structure as written by an implementation of "
"``prepare_for_submission`` to the ``folder`` sandbox:"
msgstr "下面是 ``prepare_for_submission`` 的实现的 ``folder`` 沙箱文件夹的文件结构："

#: ../../source/topics/calculations/usage.rst:317
msgid ""
"Clearly, we do not want the ``personal.dat`` and ``secret.key`` files to end"
" up permanently in the file repository. This can be achieved by defining:"
msgstr "显然，我们不想要 ``personal.dat`` 和 ``secret.key`` 文件最终永久地保存在文件存储库中。这可以通过定义："

#: ../../source/topics/calculations/usage.rst:324
msgid ""
"With this specification, the final contents of the repository of the "
"calculation node will contain:"
msgstr "有了这个规范，计算节点存储库的最终内容将包括:"

#: ../../source/topics/calculations/usage.rst:335
msgid "Remote copy list"
msgstr "远程复制列表"

#: ../../source/topics/calculations/usage.rst:336
msgid ""
"The remote copy list takes tuples of length three, each of which represents "
"a file to be copied on the remote machine where the calculation will run, "
"defined through the following items:"
msgstr "远程复制列表采用长度为3的元组，每个元组表示要在运行计算的远程计算机上复制的文件，通过以下各项定义:"

#: ../../source/topics/calculations/usage.rst:338
msgid ""
"`computer uuid`: this is the UUID of the ``Computer`` on which the source "
"file resides. For now the remote copy list can only copy files on the same "
"machine where the job will run."
msgstr ""
"`computer uuid`: 这是源文件所在的 ``Computer`` 的UUID。目前，远程复制列表只能复制运行在同一台计算机上的文件。"

#: ../../source/topics/calculations/usage.rst:339
msgid ""
"`source absolute path`: the absolute path of the source file on the remote "
"machine"
msgstr "`source absolute path`: 远程机器上源文件的绝对路径"

#: ../../source/topics/calculations/usage.rst:340
msgid ""
"`target relative path`: the relative path within the working directory to "
"which to copy the file"
msgstr "`target relative path`: 要复制文件的工作目录中的相对路径"

#: ../../source/topics/calculations/usage.rst:346
msgid ""
"Note that the source path can point to a directory, in which case its "
"contents will be recursively copied in its entirety."
msgstr "请注意，源路径可以指向目录，在这种情况下，其内容将以整体递归方式复制。"

#: ../../source/topics/calculations/usage.rst:351
msgid "Retrieve list"
msgstr "检索列表"

#: ../../source/topics/calculations/usage.rst:352
msgid ""
"The retrieve list is a list of instructions of what files and folders should"
" be retrieved by the engine once a calculation job has terminated. Each "
"instruction should have one of two formats:"
msgstr "检索列表是一个指令列表，指示一旦计算作业终止，引擎应该检索哪些文件和文件夹。每个指令应该为以下两种格式之一:"

#: ../../source/topics/calculations/usage.rst:355
msgid ""
"a string representing a relative filepath in the remote working directory"
msgstr "表示远程工作目录中相对文件路径的字符串"

#: ../../source/topics/calculations/usage.rst:356
msgid ""
"a tuple of length three that allows to control the name of the retrieved "
"file or folder in the retrieved folder"
msgstr "长度为3的元组，允许控制检索到的文件夹中的检索文件或文件夹的名称"

#: ../../source/topics/calculations/usage.rst:358
msgid ""
"The retrieve list can contain any number of instructions and can use both "
"formats at the same time. The first format is obviously the simplest, "
"however, this requires one knows the exact name of the file or folder to be "
"retrieved and in addition any subdirectories will be ignored when it is "
"retrieved. If the exact filename is not known and `glob patterns "
"<https://en.wikipedia.org/wiki/Glob_%28programming%29>`_ should be used, or "
"if the original folder structure should be (partially) kept, one should use "
"the tuple format, which has the following format:"
msgstr ""
"检索列表可以包含任意数量的指令，并且可以同时使用两种格式。第一种格式显然是最简单的，但是，它需要知道要检索的文件或文件夹的确切名称，并且在检索时将忽略任何子目录。如果不知道确切的文件名，并且应该使用"
" `glob patterns <https://en.wikipedia.org/wiki/Glob_%28programming%29>`_ "
"，或者如果应该(部分)保留原始的文件夹结构，应该使用元组格式，它有以下格式:"

#: ../../source/topics/calculations/usage.rst:362
msgid ""
"`source relative path`: the relative path, with respect to the working "
"directory on the remote, of the file or directory to retrieve."
msgstr "`source relative path`: 相对于要检索的文件或目录的远程工作目录的相对路径。"

#: ../../source/topics/calculations/usage.rst:363
msgid ""
"`target relative path`: the relative path of the directory in the retrieved "
"folder in to which the content of the source will be copied. The string "
"``'.'`` indicates the top level in the retrieved folder."
msgstr "*目标相对路径* ：检索到的文件夹中的目录的相对路径，源路径文件的内容将被复制到其中。字符串 ``'.'`` 表示检索到的文件夹的顶层。"

#: ../../source/topics/calculations/usage.rst:364
msgid ""
"`depth`: the number of levels of nesting in the source path to maintain when"
" copying, starting from the deepest file."
msgstr "*深度* ：复制时要在源路径中的嵌套层次数，从最深的文件开始。"

#: ../../source/topics/calculations/usage.rst:366
msgid ""
"To illustrate the various possibilities, consider the following example file"
" hierarchy in the remote working directory:"
msgstr "为了说明各种可能情况，考虑以下远端工作目录中的文件层次结构示例："

#: ../../source/topics/calculations/usage.rst:377
msgid ""
"Below, you will find examples for various use cases of files and folders to "
"be retrieved. Each example starts with the format of the ``retrieve_list``, "
"followed by a schematic depiction of the final file hierarchy that would be "
"created in the retrieved folder."
msgstr ""
"下面，您将看到要检索的文件和文件夹的各种用例的示例。每个示例都以 ``retrieve_list`` "
"的格式开始，然后是在检索到的文件夹中创建的最终文件层次结构的示意图。"

#: ../../source/topics/calculations/usage.rst:381
msgid "Explicit file or folder"
msgstr "显式文件或文件夹"

#: ../../source/topics/calculations/usage.rst:383
msgid ""
"Retrieving a single toplevel file or folder (with all its contents) where "
"the final folder structure is not important."
msgstr "检索单个顶层文件或文件夹(及其所有内容)，且其中最终的文件夹结构并不重要。"

#: ../../source/topics/calculations/usage.rst:402
msgid "Explicit nested file or folder"
msgstr "显式嵌套的文件或文件夹"

#: ../../source/topics/calculations/usage.rst:404
msgid ""
"Retrieving a single file or folder (with all its contents) that is located "
"in a subdirectory in the remote working directory, where the final folder "
"structure is not important."
msgstr "检索位于远程工作目录的子目录中的单个文件或文件夹(及其所有内容)，且其不需要最终的文件夹结构"

#: ../../source/topics/calculations/usage.rst:421
msgid "Explicit nested file or folder keeping (partial) hierarchy"
msgstr "显式嵌套的文件或文件夹，但保持(部分)层次结构"

#: ../../source/topics/calculations/usage.rst:423
msgid ""
"The following examples show how the file hierarchy of the retrieved files "
"can be controlled. By changing the ``depth`` parameter of the tuple, one can"
" control what part of the remote folder hierarchy is kept. In the given "
"example, the maximum depth of the remote folder hierarchy is ``3``. The "
"following example shows that by specifying ``3``, the exact folder structure"
" is kept:"
msgstr ""
"以下示例展示了如何控制检索到的文件的文件层次结构。通过改变元组的 ``depth`` "
"参数，可以控制远程文件夹层次结构的哪一部分被保留。在这个例子中，远程文件夹层次结构的最大深度是 ``3``。下面的例子表明，通过指定 "
"``3``，可以保持准确的文件夹结构:"

#: ../../source/topics/calculations/usage.rst:436
msgid ""
"For ``depth=2``, only two levels of nesting are kept (including the file "
"itself) and so the ``path`` folder is discarded."
msgstr "对于 ``depth=2``，只保留了两层嵌套(包括文件本身)，因此 ``path`` 文件夹将被丢弃。"

#: ../../source/topics/calculations/usage.rst:445
msgid ""
"The same applies for directories. By specifying a directory for the first "
"element, all its contents will be retrieved. With ``depth=1``, only the "
"first level ``sub`` is kept of the folder hierarchy."
msgstr ""
"这同样适用于目录。通过为第一个元素指定目录，将检索它的所有内容。使用 ``depth=1`` ，只有第一级 ``sub`` 被保存在文件夹层次结构中。"

#: ../../source/topics/calculations/usage.rst:459
msgid "Pattern matching"
msgstr "模式匹配"

#: ../../source/topics/calculations/usage.rst:461
msgid ""
"If the exact file or folder name is not known beforehand, glob patterns can "
"be used. In the following examples, all files that match ``*c.txt`` in the "
"directory ``path/sub`` will be retrieved."
msgstr ""

#: ../../source/topics/calculations/usage.rst:464
msgid "To maintain the folder structure set ``depth`` to ``None``:"
msgstr ""

#: ../../source/topics/calculations/usage.rst:474
msgid ""
"Alternatively, the ``depth`` can be used to specify the number of levels of "
"nesting that should be kept. For example, ``depth=0`` instructs to copy the "
"matched files without any subfolders:"
msgstr ""

#: ../../source/topics/calculations/usage.rst:483
msgid "and ``depth=2`` will keep two levels in the final filepath:"
msgstr ""

#: ../../source/topics/calculations/usage.rst:494
msgid "Specific target directory"
msgstr "特定的目标文件夹"

#: ../../source/topics/calculations/usage.rst:496
msgid ""
"The final folder hierarchy of the retrieved files in the retrieved folder is"
" not only determined by the hierarchy of the remote working directory, but "
"can also be controlled through the second and third elements of the "
"instructions tuples. The final ``depth`` element controls what level of "
"hierarchy of the source is maintained, where the second element specifies "
"the base path in the retrieved folder into which the remote files should be "
"retrieved. For example, to retrieve a nested file, maintaining the remote "
"hierarchy and storing it locally in the ``target`` directory, one can do the"
" following:"
msgstr ""
"所检索文件夹中所检索文件的最终文件夹层次结构不仅由远程工作目录的层次结构决定，而且还可以通过指令元组的第二和第三个元素进行控制。最后一个 "
"``depth`` "
"元素控制要维护的源的层次结构的级别，其中第二个元素指定要将远程文件检索到的已检索文件夹中的基本路径。例如，要检索一个嵌套的文件，维护远程层次结构并将其存储在本地的"
" ``target`` 目录中，可以执行以下操作:"

#: ../../source/topics/calculations/usage.rst:509
msgid "The same applies for folders that are to be retrieved:"
msgstr "这同样适用于要检索的文件夹:"

#: ../../source/topics/calculations/usage.rst:520
msgid ""
"Note that `target` here is not used to rename the retrieved file or folder, "
"but indicates the path of the directory into which the source is copied. The"
" target relative path is also compatible with glob patterns in the source "
"relative paths:"
msgstr ""
"注意，这里的 `target` 不是用来重命名检索到的文件或文件夹，而是表示要将源复制到的目录的路径。目标相对路径也与源相对路径中的glob模式兼容:"

#: ../../source/topics/calculations/usage.rst:532
msgid "Retrieve temporary list"
msgstr "临时文件检索列表"

#: ../../source/topics/calculations/usage.rst:534
msgid ""
"Recall that, as explained in the :ref:`'prepare' "
"section<topics:calculations:usage:calcjobs:prepare>`, all the files that are"
" retrieved by the engine following the 'retrieve list', are stored in the "
"``retrieved`` folder data node. This means that any file you retrieve for a "
"completed calculation job will be stored in your repository. If you are "
"retrieving big files, this can cause your repository to grow significantly. "
"Often, however, you might only need a part of the information contained in "
"these retrieved files. To solve this common issue, there is the concept of "
"the 'retrieve temporary list'. The specification of the retrieve temporary "
"list is identical to that of the normal :ref:`retrieve "
"list<topics:calculations:usage:calcjobs:file_lists_retrieve>`, but it is "
"added to the ``calc_info`` under the ``retrieve_temporary_list`` attribute:"
msgstr ""

#: ../../source/topics/calculations/usage.rst:546
msgid ""
"The only difference is that, unlike the files of the retrieve list which "
"will be permanently stored in the retrieved "
":py:class:`~aiida.orm.nodes.data.folder.FolderData` node, the files of the "
"retrieve temporary list will be stored in a temporary sandbox folder. This "
"folder is then passed under the ``retrieved_temporary_folder`` keyword "
"argument to the ``parse`` method of the "
":ref:`parser<topics:calculations:usage:calcjobs:parsers>`, if one was "
"specified for the calculation job:"
msgstr ""

#: ../../source/topics/calculations/usage.rst:556
msgid ""
"The parser implementation can then parse these files and store the relevant "
"information as output nodes."
msgstr ""

#: ../../source/topics/calculations/usage.rst:560
msgid ""
"The type of ``kwargs['retrieved_temporary_folder']`` is a simple ``str`` "
"that represents the `absolute` filepath to the temporary folder. You can "
"access its contents with the ``os`` standard library module or convert it "
"into a ``pathlib.Path``."
msgstr ""

#: ../../source/topics/calculations/usage.rst:563
msgid ""
"After the parser terminates, the engine will automatically clean up the "
"sandbox folder with the temporarily retrieved files. The concept of the "
"``retrieve_temporary_list`` is essentially that the files will be available "
"during parsing and will be destroyed immediately afterwards."
msgstr ""

#: ../../source/topics/calculations/usage.rst:569
msgid "Stashing on the remote"
msgstr ""

#: ../../source/topics/calculations/usage.rst:573
msgid ""
"The ``stash`` option namespace allows a user to specify certain files and/or"
" folders that are created by the calculation job to be stashed somewhere on "
"the remote where the job is run. This can be useful if these need to be "
"stored for a longer time on a machine where the scratch space is cleaned "
"regularly, but they need to be kept on the remote machine and not retrieved."
" Examples are files that are necessary to restart a calculation but are too "
"big to be retrieved and stored permanently in the local file repository."
msgstr ""

#: ../../source/topics/calculations/usage.rst:577
msgid ""
"The files/folder that need to be stashed are specified through their "
"relative filepaths within the working directory in the ``stash.source_list``"
" option. Using the ``COPY`` mode, the target path defines another location "
"(on the same filesystem as the calculation) to copy the files to, and is set"
" through the ``stash.target_base`` option, for example:"
msgstr ""

#: ../../source/topics/calculations/usage.rst:600
msgid ""
"In the future, other methods for stashing may be implemented, such as "
"placing all files in a (compressed) tarball or even stash files on tape."
msgstr "将来，可能会实现其他的存储方法，比如将所有文件放在(压缩的)tarball中，甚至将文件存储在磁带上。"

#: ../../source/topics/calculations/usage.rst:604
msgid ""
"If the ``stash`` option namespace is defined for a calculation job, the "
"daemon will perform the stashing operations before the files are retrieved. "
"This means that the stashing happens before the parsing of the output files "
"(which occurs after the retrieving step), such that that the files will be "
"stashed independent of the final exit status that the parser will assign to "
"the calculation job. This may cause files to be stashed for calculations "
"that will later be considered to have failed."
msgstr ""
"如果为计算作业定义了 ``stash`` "
"选项名称空间，守护进程将在检索文件之前执行存储操作。这意味着存储发生在解析输出文件之前(检索步骤之后)，这样文件的存储将独立于解析器将分配给计算作业的最终退出状态。这可能会导致文件被之后已经失败的计算存储起来。"

#: ../../source/topics/calculations/usage.rst:608
msgid ""
"The stashed files and folders are represented by an output node that is "
"attached to the calculation node through the label ``remote_stash``, as a "
"``RemoteStashFolderData`` node. Just like the ``remote_folder`` node, this "
"represents a location or files on a remote machine and so is equivalent to a"
" \"symbolic link\"."
msgstr ""

#: ../../source/topics/calculations/usage.rst:613
msgid ""
"AiiDA does not actually control the files in the remote stash, and so the "
"contents may disappear at some point."
msgstr ""

#: ../../source/topics/calculations/usage.rst:618
msgid "Options"
msgstr "选项"

#: ../../source/topics/calculations/usage.rst:619
msgid ""
"In addition to the common metadata inputs, such as ``label`` and "
"``description``, that all processes have, the "
":py:class:`~aiida.engine.processes.calcjobs.calcjob.CalcJob` has an "
"additonal input called ``options``. These options allow to subtly change the"
" behavior of the calculation job, for example which parser should be used "
"once it is finished and special scheduler directives. The full list of "
"available options are documented below as part of the ``CalcJob`` interface:"
msgstr ""
"除了所有进程都有的常见的元数据输入，例如 ``label`` 和 ``description`` ， "
":py:class:`~aiida.engine.processes.calcjobs.calcjob.CalcJob`  有一个额外的 "
"``options`` "
"输入。这些选项允许微妙地更改计算作业的行为，例如完成计算作业后应该使用哪个解析器，以及特殊的调度器指令。可用选项的完整列表在下面记录为 "
"``CalcJob`` 接口的一部分:"

#: ../../source/topics/calculations/usage.rst:628
msgid ""
"The ``rerunnable`` option enables the scheduler to re-launch the calculation"
" if it has failed, for example due to node failure or a failure to launch "
"the job. It corresponds to the ``--requeue`` option in SLURM, and the ``-r``"
" option in SGE, LSF, and PBS. The following two conditions must be met in "
"order for this to work well with AiiDA:"
msgstr ""

#: ../../source/topics/calculations/usage.rst:630
msgid "the scheduler assigns the same job-id to the restarted job"
msgstr ""

#: ../../source/topics/calculations/usage.rst:631
msgid ""
"the code produces the same results if it has already partially run before "
"(not every scheduler may produce this situation)"
msgstr ""

#: ../../source/topics/calculations/usage.rst:633
msgid ""
"Because this depends on the scheduler, its configuration, and the code used,"
" we cannot say conclusively when it will work -- do your own testing! It has"
" been tested on a cluster using SLURM, but that does not guarantee other "
"SLURM clusters behave in the same way."
msgstr ""

#: ../../source/topics/calculations/usage.rst:639
msgid "Controlling MPI"
msgstr ""

#: ../../source/topics/calculations/usage.rst:641
msgid ""
"The `Message Passing Interface "
"<https://en.wikipedia.org/wiki/Message_Passing_Interface>`_ (MPI) is a "
"standardized and portable message-passing standard designed to function on "
"parallel computing architectures. AiiDA implements support for running "
"calculation jobs with or without MPI enabled. There are a number of settings"
" that can be used to control when and how MPI is used."
msgstr ""

#: ../../source/topics/calculations/usage.rst:648
msgid "The ``Computer``"
msgstr ""

#: ../../source/topics/calculations/usage.rst:650
msgid ""
"Each calculation job is executed on a compute resource, which is modeled by "
"an instance of the :class:`~aiida.orm.computers.Computer` class. If the "
"computer supports running with MPI, the command to use is stored in the "
"``mpirun_command`` attribute, which is retrieved and set using the "
":meth:`~aiida.orm.computers.Computer.get_mpirun_command` and "
":meth:`~aiida.orm.computers.Computer.get_mpirun_command`, respectively. For "
"example, if the computer has `OpenMPI <https://docs.open-"
"mpi.org/en/v5.0.x/index.html>`_ installed, it can be set to ``mpirun``. If "
"the ``Computer`` does not specify an MPI command, then enabling MPI for a "
"calculation job is ineffective."
msgstr ""

#: ../../source/topics/calculations/usage.rst:658
msgid "The ``Code``"
msgstr ""

#: ../../source/topics/calculations/usage.rst:662
msgid ""
"When creating a code, you can tell AiiDA that it should be run as an MPI "
"program, by setting the ``with_mpi`` attribute to ``True`` or ``False``. "
"From AiiDA 2.3 onward, this is the **recommended** way of controlling MPI "
"behavior. The attribute can be set from the Python API as "
"``AbstractCode(with_mpi=with_mpi)`` or through the ``--with-mpi`` / ``--no-"
"with-mpi`` option of the ``verdi code create`` CLI command. If the code can "
"be run with or without MPI, setting the ``with_mpi`` attribute can be "
"skipped. It will default to ``None``, leaving the question of whether to run"
" with or without MPI up to the ``CalcJob`` plugin or user input."
msgstr ""

#: ../../source/topics/calculations/usage.rst:671
#: ../../source/topics/calculations/usage.rst:733
msgid "The ``CalcJob`` implementation"
msgstr ""

#: ../../source/topics/calculations/usage.rst:673
msgid ""
"The ``CalcJob`` implementation instructs AiiDA how the codes should be run "
"through the :class:`~aiida.common.datastructures.CalcInfo` object, which it "
"returns from the "
":meth:`~aiida.engine.processes.calcjobs.calcjob.CalcJob.prepare_for_submission`"
" method. For each code that the job should run (usually only a single one), "
"a :class:`~aiida.common.datastructures.CodeInfo` object should be added to "
"the list of the ``CalcInfo.codes_info`` attribute. If the plugin developer "
"knows that the executable being wrapped is *always* MPI program (no serial "
"version available) or *never* an MPI program, they can set the ``withmpi`` "
"attribute of the ``CodeInfo`` to ``True`` or ``False``, respectively. Note "
"that this setting is fully optional; if the code could be run either way, it"
" is best not to set it and leave it up to the ``Code`` or the "
"``metadata.options.withmpi`` input."
msgstr ""

#: ../../source/topics/calculations/usage.rst:680
msgid ""
"When implementing a ``CalcJob`` that runs a single code, consider using "
"specifying whether MPI should be enabled or disabled through the "
":ref:`metadata option<topics:calculations:usage:calcjobs:mpi:calcjob-"
"inputs>`. This can be accomplished by changing the default in the process "
"specification:"
msgstr ""

#: ../../source/topics/calculations/usage.rst:692
msgid ""
"The advantage over using the ``CodeInfo.withmpi`` attribute is that the "
"default of the metadata option can be introspected programmatically from the"
" process spec, and so is more visible to the user."
msgstr ""

#: ../../source/topics/calculations/usage.rst:694
msgid ""
"Naturally, this approach is not viable for calculation jobs that run "
"multiple codes that are different in whether they require MPI or not. In "
"this case, one should resort to using the ``CodeInfo.withmpi`` attribute."
msgstr ""

#: ../../source/topics/calculations/usage.rst:700
msgid "The ``CalcJob`` inputs"
msgstr ""

#: ../../source/topics/calculations/usage.rst:702
msgid ""
"Finally, the MPI setting can be controlled on a per-instance basis, using "
"the ``withmpi`` :ref:`metadata "
"option<topics:calculations:usage:calcjobs:options>`. If MPI should be "
"enabled or disabled, explicitly set this option to ``True`` or ``False``, "
"respectively. For example, the following instructs to run all codes in the "
"calculation job with MPI enabled:"
msgstr ""

#: ../../source/topics/calculations/usage.rst:718
msgid ""
"The default for this option is set to ``False`` on the base ``CalcJob`` "
"implementation, but it will be overruled if explicitly defined."
msgstr ""

#: ../../source/topics/calculations/usage.rst:722
msgid ""
"The value set for the ``withmpi`` option will be applied to all codes. If a "
"calculation job runs more than one code, and each requires a different MPI "
"setting, this option should not be used, and instead MPI should be "
"controlled :ref:`through the code input "
"<topics:calculations:usage:calcjobs:mpi:code>`."
msgstr ""

#: ../../source/topics/calculations/usage.rst:728
msgid "Conflict resolution"
msgstr ""

#: ../../source/topics/calculations/usage.rst:730
msgid ""
"As described above, MPI can be enabled or disabled for a calculation job on "
"a number of levels:"
msgstr ""

#: ../../source/topics/calculations/usage.rst:732
msgid "The ``Code`` input"
msgstr ""

#: ../../source/topics/calculations/usage.rst:734
msgid "The ``metadata.options.withmpi`` input"
msgstr ""

#: ../../source/topics/calculations/usage.rst:736
msgid ""
"MPI is enabled or disabled if any of these values is explicitly set to "
"``True`` or ``False``, respectively. If multiple values are specified and "
"they are not equivalent, a ``RuntimeError`` is raised. Depending on the "
"conflict, one has to change the ``Code`` or ``metadata.options.withmpi`` "
"input. If none of the values are explicitly defined, the value specified by "
"the default of ``metadata.options.withmpi`` is taken."
msgstr ""

#: ../../source/topics/calculations/usage.rst:745
msgid "Launch"
msgstr "启动"

#: ../../source/topics/calculations/usage.rst:747
msgid ""
"Launching a calculation job is no different from launching any other process"
" class, so please refer to the section on :ref:`launching "
"processes<topics:processes:usage:launch>`. The only caveat that we should "
"place is that calculation jobs typically tend to take quite a bit of time. "
"The trivial example we used above of course will run very fast, but a "
"typical calculation job that will be submitted to a scheduler will most "
"likely take longer than just a few seconds. For that reason it is highly "
"advisable to **submit** calculation jobs instead of running them. By "
"submitting them to the daemon, you free up your interpreter straight away "
"and the process will be checkpointed between the various :ref:`transport "
"tasks<topics:calculations:concepts:calcjobs_transport_tasks>` that will have"
" to be performed. The exception is of course when you want to run a "
"calculation job locally for testing or demonstration purposes."
msgstr ""
"启动一个算例任务和启动任何其他列程类没有什么不同，所以请参考 :ref:`启动列程 <topics:processes:usage:launch>` "
"一节。我们唯一应该注意的是，算例任务通常相当耗时。我们上面使用的简单示例当然会运行得很快，但是提交给调度器的典型的算例很可能需要花费更长的时间。因此，建议"
" **提交** 算例，而不是运行它们。通过将它们提交给守护进程，你就可以直接释放python解释器的占用，整个进程将在必须执行的各种 "
":ref:`传输任务 <topics:calculations:concepts:calcjobs_transport_tasks>` "
"之间进行检查。当然，当您希望本地运行算例以进行测试或演示时除外。"

#: ../../source/topics/calculations/usage.rst:758
msgid "Dry run"
msgstr "裸运行"

#: ../../source/topics/calculations/usage.rst:759
msgid ""
"The calculation job has one additional feature over all other processes when"
" it comes to launching them. Since an incorrectly configured calculation job"
" can potentially waste computational resources, one might want to inspect "
"the input files that will be written by the plugin, before actually "
"submitting the job. A so-called dry-run is possible by simply specifying it "
"in the metadata of the inputs. If you are using the process builder, it is "
"as simple as:"
msgstr ""
"当涉及到启动所有其他进程时，算例任务有一个额外的可选特性。未正确配置的算例任务可能会浪费计算资源，所以在实际提交作业之前，可能需要检查插件将写入的输入文件。通过简单地在输入的元数据中指定所谓的"
" “裸运行” 是可能的。如果你正在使用过程构建器，只需简单使用："

#: ../../source/topics/calculations/usage.rst:768
msgid ""
"When you now launch the process builder, the engine will perform the entire "
"process of a normal calculation job run, except that it will not actually "
"upload and submit the job to the remote computer. However, the "
"``prepare_for_submission`` method will be called. The inputs that it writes "
"to the input folder will be stored in temporary folder called "
"``submit_test`` that will be created in the current working directory. Each "
"time you perform a dry-run, a new sub folder will be created in the "
"``submit_test`` folder, which you allows you to perform multiple dry-runs "
"without overwriting the previous results."
msgstr ""
"当您现在启动列程构建器时，引擎将执行正常算例运行的整个过程，只是它不会实际地将作业上传并提交到远程计算机。但是， "
"``prepare_for_submission`` 方法将被调用。它写入输入文件夹的输入将存储在临时文件夹名为 ``submit_test`` "
"，该文件夹将在当前工作目录中创建。每次执行裸运行时，将在 ``submit_test`` "
"文件夹中创建一个新的子文件夹，您可以在不覆盖以前结果的情况下执行多次裸运行。"

#: ../../source/topics/calculations/usage.rst:773
msgid "Moreover, the following applies:"
msgstr "此外，下列规则也适用:"

#: ../../source/topics/calculations/usage.rst:775
msgid ""
"when calling :py:func:`~aiida.engine.launch.run` for a calculation with the "
"``dry_run`` flag set, you will get back its results, being always an empty "
"dictionary ``{}``;"
msgstr ""
"当调用 :py:func:`~aiida.engine.launch.run` 进行计算时，设置了 ``dry_run`` "
"标志，返回结果将始终是一个空字典 ``{}`` ；"

#: ../../source/topics/calculations/usage.rst:778
msgid ""
"if you call :py:func:`~aiida.engine.launch.run_get_node`, you will get back "
"as a node an unstored ``CalcJobNode``. In this case, the unstored "
"``CalcJobNode`` (let's call it ``node``) will have an additional property "
"``node.dry_run_info``. This is a dictionary that contains additional "
"information on the dry-run output. In particular, it will have the following"
" keys:"
msgstr ""
"如果你调用 :py:func:`~aiida.engine.launch.run_get_node` ，你会得到一个未存储的 "
"``CalcJobNode`` 作为一个节点。在这种情况下，未存储的 ``CalcJobNode`` (让我们称它为 ``node`` "
")将有一个额外的属性 ``node.dry_run_info`` 。这是一个字典，它包含关于裸运行输出的附加信息。特别地，它将有以下键："

#: ../../source/topics/calculations/usage.rst:784
msgid ""
"``folder``: the absolute path to the folder within the ``submit_test`` "
"folder where the files have been created, e.g.: "
"``/home/user/submit_test/20190726-00019``"
msgstr ""
"``folder``： 在 ``submit_test`` 文件夹内创建文件的绝对路径，例如：  "
"``/home/user/submit_test/20190726-00019``"

#: ../../source/topics/calculations/usage.rst:787
msgid ""
"``script_filename``: the filename of the submission script that AiiDA "
"generated in the folder, e.g.: ``_aiidasubmit.sh``"
msgstr "`script_filename`： AiiDA在文件夹中生成的提交脚本的文件名，例如： `` _aiidassubmit .sh``"

#: ../../source/topics/calculations/usage.rst:790
msgid ""
"if you send a dry-run to the :py:func:`~aiida.engine.launch.submit` "
"function, this will be just forwarded to run and you will get back the "
"unstored node (with the same properties as above)."
msgstr ""
"如果使用 :py:func:`~aiida.engine.launch.submit`  "
"来提交裸运行，将只是转发运行，您将获得未存储的节点(与上面相同的属性)。"

#: ../../source/topics/calculations/usage.rst:797
msgid ""
"By default the storing of provenance is enabled and this goes also for a dry"
" run. If you do not want any nodes to be created during a dry run, simply "
"set the metadata input ``store_provenance`` to ``False``."
msgstr ""
"默认情况下，可验证性的存储是开启的，这也适用于裸运行。如果您不希望在裸运行期间创建任何节点，只需将元数据输入 ``store_provenance`` "
"设置为 ``False`` 。"

#: ../../source/topics/calculations/usage.rst:804
msgid "Parsing"
msgstr "结果解析"

#: ../../source/topics/calculations/usage.rst:805
msgid ""
"The previous sections explained in detail how the execution of an external "
"executable is wrapped by the ``CalcJob`` class to make it runnable by "
"AiiDA's engine. From the first steps of preparing the input files on the "
"remote machine, to retrieving the relevant files and storing them in a "
":py:class:`~aiida.orm.nodes.data.folder.FolderData` node, that is attached "
"as the ``retrieved`` output. This is the last *required* step for a "
"``CalcJob`` to terminate, but often we would *like* to parse the raw output "
"and attach them as queryable output nodes to the calculation job node. To "
"automatically trigger the parsing of a calculation job after its output has "
"been retrieved, is to specify the :ref:`parser name "
"option<topics:calculations:usage:calcjobs:options>`. If the engine find this"
" option specified, it will load the corresponding parser class, which should"
" be a sub class of :py:class:`~aiida.parsers.parser.Parser` and calls its "
":py:meth:`~aiida.parsers.parser.Parser.parse` method."
msgstr ""
"前面的部分详细解释了外部可执行文件的执行是如何通过 ``CalcJob`` "
"类包装的，从而使其可由AiiDA的引擎运行。从在远程机器上准备输入文件的第一步，到检索相关文件并将它们存储在 "
":py:class:`~aiida.orm.nodes.data.folder.FolderData`  节点，它被附加为 ``retrieved`` "
"输出。这是 ``CalcJob`` 终止的 *必需的* 步骤，但通常我们 *希望* "
"解析原始输出并将它们作为可查询的输出节点附加到计算作业节点。要在检索到计算作业的输出后自动触发对它的解析，需要指定 :ref:`解析器名称选项 "
"<topics:calculations:usage:calcjobs:options>` "
"。如果引擎发现指定了这个选项，它将加载相应的解析器类，该解析器类应是 :py:class:`~aiida.parsers.parser.Parser` "
"的子类。并重载了它的 :py:meth:`~aiida.parsers.parser.Parser.parse`  方法。"

#: ../../source/topics/calculations/usage.rst:811
msgid ""
"To explain the interface of the ``Parser`` class and the ``parse`` method, "
"let's take the "
":py:class:`~aiida.parsers.plugins.arithmetic.add.ArithmeticAddParser` as an "
"example. This parser is designed to parse the output produced by the simple "
"bash script that is wrapped by the ``ArithmeticAddCalculation`` discussed in"
" the previous sections."
msgstr ""
"为了解释 ``Parser`` 类和 ``parse`` 方法的接口，让我们使用 "
":py:class:`~aiida.parsers.plugins.arithmetic.add.ArithmeticAddParser` "
"作为例子。这个解析器被设计来解析简单的bash脚本产生的输出，该脚本由前面讨论的 ``ArithmeticAddCalculation`` 包装。"

#: ../../source/topics/calculations/usage.rst:818
msgid ""
"To create a new parser implementation, simply create a new class that sub "
"classes the :py:class:`~aiida.parsers.parser.Parser` class. As usual, any "
"valid python class name will work, but the convention is to always use the "
"``Parser`` suffix and to use the same name as the calculation job for which "
"the parser is designed. For example, here we are implementing a parser for "
"the ``ArithmeticAddCalculation``, so therefore we name it "
"``ArithmeticAddParser``, just replacing the ``Calculation`` suffix for "
"``Parser``. The only method that needs to be implemented is the "
":py:meth:`~aiida.parsers.parser.Parser.parse` method. Its signature should "
"include ``**kwargs``, the reason for which will become clear later. The goal"
" of the ``parse`` method is very simple:"
msgstr ""
"要创建新的解析器实现，只需创建一个新类，该类继承自 :py:class:`~aiida.parsers.parser.Parser` "
"类。通常，任何有效的python类名都可以工作，但约定是始终使用 ``Parser`` 后缀，并使用与解析器设计的计算作业相同的名称。例如，这里我们为 "
"``ArithmeticAddCalculation`` 实现了一个解析器，因此我们将其命名为 ``ArithmeticAddParser``，只是将 "
"``Calculation`` 后缀替换为 ``Parser`` 。需要实现的唯一方法是 "
":py:meth:`~aiida.parser.parser.parser` 方法。它的签名应该包括 ``**kwargs`` ，其原因稍后将会清楚。 "
"``parse`` 方法的目标非常简单，即:"

#: ../../source/topics/calculations/usage.rst:825
msgid ""
"Open and load the content of the output files generated by the calculation "
"job and have been retrieved by the engine"
msgstr "打开并加载由算例任务生成并已被引擎检索的输出文件的内容"

#: ../../source/topics/calculations/usage.rst:826
msgid ""
"Create data nodes out of this raw data that are attached as output nodes"
msgstr "从作为输出节点附加在原始创建的数据节点上"

#: ../../source/topics/calculations/usage.rst:827
msgid "Log human-readable warning messages in the case of worrying output"
msgstr "在输出警告情况下，记录可读的警告消息"

#: ../../source/topics/calculations/usage.rst:828
msgid ""
"Optionally return an :ref:`exit code<topics:processes:concepts:exit_codes>` "
"to indicate that the results of the calculation was not successful"
msgstr "可选地返回 :ref:`退出状态码 <topics:processes:concepts:exit_codes>`来表示计算结果不成功"

#: ../../source/topics/calculations/usage.rst:830
msgid ""
"The advantage of adding the raw output data in different form as output "
"nodes, is that in that form the content becomes queryable. This allows one "
"to query for calculations that produced specific outputs with a certain "
"value, which becomes a very powerful approach for post-processing and "
"analyses of big databases."
msgstr ""
"以不同形式添加原始输出数据作为输出节点的好处是，在这种形式下，内容变成可查询的。这允许查询产生具有特定值的特定输出的计算，这成为对大型数据库进行后处理和分析的一种非常强大的方法。"

#: ../../source/topics/calculations/usage.rst:833
msgid ""
"The ``retrieved`` attribute of the parser will return the ``FolderData`` "
"node that should have been attached by the engine containing all the "
"retrieved files, as specified using the :ref:`retrieve "
"list<topics:calculations:usage:calcjobs:file_lists_retrieve>` in the "
":ref:`preparation step of the calculation "
"job<topics:calculations:usage:calcjobs:prepare>`. This retrieved folder can "
"be used to open and read the contents of the files it contains. In this "
"example, there should be a single output file that was written by "
"redirecting the standard output of the bash script that added the two "
"integers. The parser opens this file, reads its content and tries to parse "
"the sum from it:"
msgstr ""
"解析器的 ``retrieved`` 属性将返回 ``FolderData`` 节点，该节点应该由包含所有检索文件的引擎附加，如在 "
":ref:`算例任务的准备步骤 <topics:calculations:usage:calcjobs:prepare>` 中使用 :ref:`检索列表"
" <topics:calculations:usage:calcjobs:file_lists_retrieve>` "
"指定的那样。此检索到的文件夹可用于打开和读取其中包含的文件的内容。在本例中，应该有一个单独的输出文件，它是通过对两个整数求和结果标准输出重定向的bash脚本的编写的。解析器打开这个文件，读取它的内容，并试图解析其中的和："

#: ../../source/topics/calculations/usage.rst:844
msgid ""
"Note that this parsing action is wrapped in a try-except block to catch the "
"exceptions that would be thrown if the output file could not be read. If the"
" exception would not be caught, the engine will catch the exception instead "
"and set the process state of the corresponding calculation to ``Excepted``. "
"Note that this will happen for any uncaught exception that is thrown during "
"parsing. Instead, we catch these exceptions and return an exit code that is "
"retrieved by referencing it by its label, such as "
"``ERROR_READING_OUTPUT_FILE`` in this example, through the "
"``self.exit_codes`` property. This call will retrieve the corresponding exit"
" code defined on the ``CalcJob`` that we are currently parsing. Returning "
"this exit code from the parser will stop the parsing immediately and will "
"instruct the engine to set its exit status and exit message on the node of "
"this calculation job."
msgstr ""
"请注意，这个解析操作封装在try-except块中，以捕获在无法读取输出文件时抛出的异常。如果异常未被捕获，引擎将捕获异常，并将相应计算的进程状态设置为"
" ``Excepted`` 。请注意，在解析期间抛出的任何未捕获的异常都会发生这种情况。相反，我们捕获这些异常并返回一个退出代码，该退出代码通过通过 "
"``self.exit_codes`` 引用来检索，例如本例中的 ``ERROR_READING_OUTPUT_FILE`` "
"。该调用将检索在我们当前解析的 ``CalcJob`` "
"上定义的相应退出代码。从解析器返回此退出代码将立即停止解析，并指示引擎在此计算作业的节点上设置其退出状态和退出消息。"

#: ../../source/topics/calculations/usage.rst:851
msgid ""
"The ``parse_stdout`` method is just a small utility function to separate the"
" actual parsing of the data from the main parser code. In this case, the "
"parsing is so simple that we might have as well kept it in the main method, "
"but this is just to illustrate that you are completely free to organize the "
"code within the ``parse`` method for clarity. If we manage to parse the sum,"
" produced by the calculation, we wrap it in the appropriate "
":py:class:`~aiida.orm.nodes.data.int.Int` data node class, and register it "
"as an output through the ``out`` method:"
msgstr ""
"``parse_stdout`` "
"方法只是一个辅助函数，用于将数据的实际解析与主解析器代码分离开来。在这种情况下，解析变得简单，我们可以将其保存在主解析方法中，但这只是为了说明，以清晰起见，您可以完全自由地在"
" ``parse`` 方法中组织代码。如果设法解析计算产生的和，则将其封装在相应的 "
":py:class:`~aiida.orm.nodes.data.int.Int` 数据节点类中，并通过 ``out`` 方法将其注册为输出:"

#: ../../source/topics/calculations/usage.rst:861
msgid ""
"Note that if we encountered no problems, we do not have to return anything. "
"The engine will interpret this as the calculation having finished "
"successfully. You might now pose the question: \"what part of the raw data "
"should I parse and in what types of data nodes should I store it?\". This "
"not an easy question to answer in the general, because it will heavily "
"depend on the type of raw output that is produced by the calculation and "
"what parts you would like to be queryable. However, we can give you some "
"guidelines:"
msgstr ""
"注意，如果我们没有遇到任何问题，我们不需要返回任何东西。引擎会将此解释为计算成功完成。现在您可能会提出这样的问题：“应该解析原始数据的哪一部分，应该将其存储在哪种类型的数据节点中?”"
" 一般来说，这不是一个容易回答的问题，因为它在很大程度上取决于计算产生的原始输出的类型，以及您希望可查询的部分。但是，我们可以给你一些方针:"

#: ../../source/topics/calculations/usage.rst:867
msgid ""
"Store data that you might want to query for, in the lightweight data nodes, "
"such as :py:class:`~aiida.orm.nodes.data.dict.Dict`, "
":py:class:`~aiida.orm.nodes.data.list.List` and "
":py:class:`~aiida.orm.nodes.data.structure.StructureData`. The contents of "
"these nodes are stored as attributes in the database, which makes sure that "
"they can be queried for."
msgstr ""
"将您可能想要查询的数据存储在轻量级数据节点中，例如 :py:class:`~aiida.orm.nodes.data.dict.Dict`， "
":py:class:`~aiida.orm.nodes.data.list.List` 和 "
":py:class:`~aiida.orm.nodes.data.structure.StructureData` "
"。这些节点的内容作为属性存储在数据库中，这确保可以查询它们。"

#: ../../source/topics/calculations/usage.rst:869
msgid ""
"Bigger data sets, such as large (multi-dimnensional) arrays, are better "
"stored in an :py:class:`~aiida.orm.nodes.data.array.array.ArrayData` or one "
"of its sub classes. If you were to store all this data in the database, it "
"would become unnecessarily bloated, because the chances you would have to "
"query for this data are unlikely. Instead these array type data nodes store "
"the bulk of their content in the repository. This way you still keep the "
"data and therewith the provenance of your calculations, while keeping your "
"database lean and fast!"
msgstr ""
"更大的数据集，比如大型(多维)数组，最好存储在 "
":py:class:`~aiida.orm.nodes.data.array.array.ArrayData` "
"或它的一个子类。如果将所有这些数据存储在数据库中，它将变得不必要地臃肿，因为您不太可能查询这些数据。相反，这些数组类型的数据节点将其大部分内容存储在存储库中。通过这种方式，您仍然可以保留数据和计算的可验证性，同时保持您的数据库精简和快速!"

#: ../../source/topics/calculations/usage.rst:878
msgid "Scheduler errors"
msgstr "任务调度程序错误"

#: ../../source/topics/calculations/usage.rst:880
msgid ""
"Besides the output parsers, the scheduler plugins can also provide parsing "
"of the output generated by the job scheduler, by implementing the "
":meth:`~aiida.schedulers.scheduler.Scheduler.parse_output` method. If the "
"scheduler plugin has implemented this method, the output generated by the "
"scheduler, written to the stdout and stderr file descriptors as well as the "
"output of the detailed job info command, is parsed. If the parser detects a "
"known problem, such as an out-of-memory (OOM) or out-of-walltime (OOW) "
"error, the corresponding exit code will already be set on the calculation "
"job node. The output parser, if defined in the inputs, can inspect the exit "
"status on the node and decide to keep it or override it with a different, "
"potentially more useful, exit code."
msgstr ""

#: ../../source/topics/calculations/usage.rst:903
msgid ""
"Note that in the example given above, the parser returns immediately if it "
"detects that the scheduler detected a problem. Since it returns `None`, the "
"exit code of the scheduler will be kept and will be the final exit code of "
"the calculation job. However, the parser does not have to immediately "
"return. It can still try to parse some of the retrieved output, if there is "
"any. If it finds a more specific problem than the generic scheduler error, "
"it can always return an exit code of itself to override it. The parser can "
"even return ``ExitCode(0)`` to have the calculation marked as successfully "
"finished, despite the scheduler having determined that there was a problem. "
"The following table summarizes the possible scenarios of the scheduler "
"parser and output parser returning an exit code and what the final resulting"
" exit code will be that is set on the node:"
msgstr ""
"注意，在上面给出的示例中，如果检测到调度器检测到问题，解析器立即返回。由于它返回 `None` "
"，调度程序的退出码将被保留，并将是算例的最终退出码。但是，解析器不需要立即返回。它仍然可以尝试解析一些检索到的输出(如果有的话)。如果它发现了比通用调度程序错误更具体的问题，它总是可以返回自身的退出代码来覆盖它。解析器甚至可以返回"
" ``ExitCode(0)` "
"来将计算标记为成功完成，尽管已知调度器存在问题。下表总结了调度器解析器和输出解析器返回退出代码的可能场景，以及在节点上设置的最终结果退出代码是什么："

#: ../../source/topics/calculations/usage.rst:912
msgid "**Scenario**"
msgstr "**场景**"

#: ../../source/topics/calculations/usage.rst:912
msgid "**Scheduler result**"
msgstr "**调度程序结果**"

#: ../../source/topics/calculations/usage.rst:912
msgid "**Retrieved result**"
msgstr "**结果检索结果**"

#: ../../source/topics/calculations/usage.rst:912
msgid "**Final result**"
msgstr "**最终结果**"

#: ../../source/topics/calculations/usage.rst:914
msgid "Neither parser found any problem."
msgstr "所有解析器均没有找到问题"

#: ../../source/topics/calculations/usage.rst:914
#: ../../source/topics/calculations/usage.rst:916
#: ../../source/topics/calculations/usage.rst:919
msgid "``None``"
msgstr "``None``"

#: ../../source/topics/calculations/usage.rst:914
#: ../../source/topics/calculations/usage.rst:924
msgid "``ExitCode(0)``"
msgstr "``ExitCode(0)``"

#: ../../source/topics/calculations/usage.rst:916
msgid "Scheduler parser found an issue, but output parser does not override."
msgstr "调度器解析器发现一个问题，但输出解析器没有将其覆盖。"

#: ../../source/topics/calculations/usage.rst:916
#: ../../source/topics/calculations/usage.rst:921
#: ../../source/topics/calculations/usage.rst:924
msgid "``ExitCode(100)``"
msgstr "``ExitCode(100)``"

#: ../../source/topics/calculations/usage.rst:919
msgid "Only output parser found a problem."
msgstr "只有输出解析器发现了问题。"

#: ../../source/topics/calculations/usage.rst:919
#: ../../source/topics/calculations/usage.rst:921
msgid "``ExitCode(400)``"
msgstr "``ExitCode(400)``"

#: ../../source/topics/calculations/usage.rst:921
msgid ""
"Scheduler parser found an issue, but the output parser overrides with a more"
" specific error code."
msgstr "调度器解析器发现了一个问题，但输出解析器使用更具体的错误代码覆盖。"

#: ../../source/topics/calculations/usage.rst:924
msgid ""
"Scheduler found issue but output parser overrides saying that despite that "
"the calculation should be considered finished successfully."
msgstr "调度器发现问题，但输出解析器将其重写，而计算应该被认为已成功完成。"

#: ../../source/topics/cli.rst:5
msgid "Command line interface"
msgstr "命令行接口"

#: ../../source/topics/cli.rst:7
msgid ""
"The command line interface utility for AiiDA is called ``verdi``. This "
"section explains the basic concepts that apply to all ``verdi`` commands."
msgstr "AiiDA的命令行接口实用程序称为 ``verdi`` 。本节解释适用于所有 ``verdi`` 命令的基本概念。"

#: ../../source/topics/cli.rst:12
msgid ""
"The ``verdi`` command line interface can also be explored as a `text-based "
"user interface <https://en.wikipedia.org/wiki/Text-based_user_interface>`_ "
"(TUI). It requires ``aiida-core`` to be installed with the ``tui`` extra "
"(e.g. ``pip install aiida-core[tui]``). The TUI can then be launched with "
"``verdi tui``."
msgstr ""

#: ../../source/topics/cli.rst:20
msgid "Parameters"
msgstr "参数"

#: ../../source/topics/cli.rst:21
msgid "Parameters to ``verdi`` commands come in two flavors:"
msgstr "``verdi`` 命令的参数有两种方式："

#: ../../source/topics/cli.rst:23
msgid ""
"Arguments: positional parameters, e.g. ``123`` in ``verdi process kill 123``"
msgstr "参数：位置参数，例如 ``123`` in ``verdi process kill 123``"

#: ../../source/topics/cli.rst:24
msgid ""
"Options: announced by a flag (e.g. ``-f`` or ``--flag``), potentially "
"followed by a value. E.g. ``verdi process list --limit 10`` or ``verdi "
"process -h``."
msgstr ""
"选项： 由一个标志宣布(例如， ``-f`` 或 ``--flag`` )，后面可能跟着一个值，如， ``verdi process list "
"--limit 10`` 或 ``verdi process -h`` 。"

#: ../../source/topics/cli.rst:29
msgid "Multi-value options"
msgstr "多值选项"

#: ../../source/topics/cli.rst:31
msgid ""
"Some ``verdi`` commands provide *options* that can take multiple values. "
"This allows to avoid repetition and e.g. write::"
msgstr ""

#: ../../source/topics/cli.rst:36
msgid "instead of the more lengthy::"
msgstr ""

#: ../../source/topics/cli.rst:40
msgid ""
"Note the use of the so-called 'endopts' marker ``--`` that is necessary to "
"mark the end of the ``-N`` option and distinguish it from the "
"``archive.aiida`` argument."
msgstr ""

#: ../../source/topics/cli.rst:46
msgid "Help strings"
msgstr "帮助信息"

#: ../../source/topics/cli.rst:47
msgid ""
"Append the ``--help`` option to any verdi (sub-)command to get help on how "
"to use it. For example, ``verdi process kill --help`` shows::"
msgstr ""

#: ../../source/topics/cli.rst:61
msgid "All help strings consist of three parts:"
msgstr ""

#: ../../source/topics/cli.rst:63
msgid "A ``Usage:`` line describing how to invoke the command"
msgstr ""

#: ../../source/topics/cli.rst:64
msgid "A description of the command's functionality"
msgstr ""

#: ../../source/topics/cli.rst:65
msgid "A list of the available options"
msgstr "一个全部可用选项的列表"

#: ../../source/topics/cli.rst:67
msgid ""
"The ``Usage:`` line encodes information on the command's parameters, e.g.:"
msgstr ""

#: ../../source/topics/cli.rst:69
msgid "``[OPTIONS]``: this command takes one (or more) options"
msgstr ""

#: ../../source/topics/cli.rst:70
msgid ""
"``PROCESSES``: this command *requires* a process as a positional argument"
msgstr ""

#: ../../source/topics/cli.rst:71
msgid ""
"``[PROCESSES]``: this command takes a process as an *optional* positional "
"argument"
msgstr ""

#: ../../source/topics/cli.rst:72
msgid ""
"``[PROCESSES]...``: this command takes one or more processes as *optional* "
"positional arguments"
msgstr ""

#: ../../source/topics/cli.rst:74
msgid ""
"Multi-value options are followed by ``...`` in the help string and the "
"``Usage:`` line of the corresponding command will contain the 'endopts' "
"marker. For example::"
msgstr ""

#: ../../source/topics/cli.rst:97
msgid "Profile"
msgstr "配置"

#: ../../source/topics/cli.rst:98
msgid ""
"AiiDA supports multiple profiles per installation, one of which is marked as"
" the default and used unless another profile is requested. Show the current "
"default profile using::"
msgstr ""

#: ../../source/topics/cli.rst:103
msgid ""
"In order to use a different profile, pass the ``-p/--profile`` option to any"
" ``verdi`` command, for example::"
msgstr ""

#: ../../source/topics/cli.rst:107
msgid ""
"Note that the specified profile will be used for this and *only* this "
"command. Use ``verdi profile setdefault`` in order to permanently change the"
" default profile."
msgstr ""

#: ../../source/topics/cli.rst:114
msgid "Verbosity"
msgstr ""

#: ../../source/topics/cli.rst:115
msgid ""
"All ``verdi`` commands have the ``-v/--verbosity`` option, which allows to "
"control the verbosity of the output that is printed by the command. The "
"option takes a value that is known as the log level and all messages that "
"are emitted with an inferior log level will be suppressed. The valid values "
"in order of increasing log level are: `NOTSET`, `DEBUG`, `INFO`, `REPORT`, "
"`WARNING`, `ERROR` and `CRITICAL`. For example, if the log level is set to "
"``ERROR``, only messages with the ``ERROR`` and ``CRITICAL`` level will be "
"shown. The choice for these log level values comes directly from `Python's "
"built-in logging module <https://docs.python.org/3/library/logging.html>`_. "
"The ``REPORT`` level is a log level that is defined and added by AiiDA that "
"sits between the ``INFO`` and ``WARNING`` level, and is the default log "
"level."
msgstr ""

#: ../../source/topics/cli.rst:122
msgid ""
"The verbosity option is case-insensitive, i.e., ``--verbosity debug`` and "
"``--verbosity DEBUG`` are identical. The option can be passed at any "
"subcommand level, for example:"
msgstr ""

#: ../../source/topics/cli.rst:129
msgid "is identical to"
msgstr ""

#: ../../source/topics/cli.rst:135
msgid ""
"When the option is specified multiple times, only the last value will be "
"considered. If the `--verbosity` option is specified, it overrides the log "
"level of all the loggers configured by AiiDA, e.g. `logging.aiida_loglevel`."
msgstr ""

#: ../../source/topics/cli.rst:142
msgid "Identifiers"
msgstr "身份信息（Identifiers）"

#: ../../source/topics/cli.rst:144
msgid ""
"When working with AiiDA entities, you need a way to *refer* to them on the "
"command line. Any entity in AiiDA can be addressed via three identifiers:"
msgstr ""

#: ../../source/topics/cli.rst:147
msgid ""
"\"Primary Key\" (PK): An integer, e.g. ``723``, identifying your entity "
"within your database (automatically assigned)"
msgstr ""

#: ../../source/topics/cli.rst:148
msgid ""
"`Universally Unique Identifier "
"<https://en.wikipedia.org/wiki/Universally_unique_identifier#Version_4_(random)>`_"
" (UUID): A string, e.g. ``ce81c420-7751-48f6-af8e-eb7c6a30cec3`` identifying"
" your entity globally (automatically assigned)"
msgstr ""

#: ../../source/topics/cli.rst:149
msgid ""
"Label: A human-readable string, e.g. ``test_calculation`` (manually "
"assigned)"
msgstr ""

#: ../../source/topics/cli.rst:153
msgid ""
"PKs are easy to type and work as long as you stay within your database. "
"**When sharing data with others, however, always use UUIDs.**"
msgstr ""

#: ../../source/topics/cli.rst:156
msgid ""
"Any ``verdi`` command that expects an identifier as a paramter will accept "
"PKs, UUIDs and labels."
msgstr ""

#: ../../source/topics/cli.rst:158
msgid ""
"In almost all cases, this will work out of the box. Since command line "
"parameters are passed as strings, AiiDA needs to deduce the type of "
"identifier from its content, which can fail in edge cases (see "
":ref:`topics:cli:identifier_resolution` for details). You can take the "
"following precautions in order to avoid such edge cases:"
msgstr ""

#: ../../source/topics/cli.rst:162
msgid "PK: no precautions needed"
msgstr ""

#: ../../source/topics/cli.rst:163
msgid ""
"UUID: no precautions needed for full UUIDs. Partial UUIDs should include at "
"least one non-numeric character or dash"
msgstr ""

#: ../../source/topics/cli.rst:164
msgid ""
"Label: add an exclamation mark ``!`` at the end of the identifier in order "
"to force interpretation as a label"
msgstr ""

#: ../../source/topics/cli.rst:170
msgid "Implementation of identifier resolution"
msgstr ""

#: ../../source/topics/cli.rst:172
msgid "The logic for deducing the identifier type is as follows:"
msgstr ""

#: ../../source/topics/cli.rst:174
msgid "Try interpreting the identifier as a PK (integer)"
msgstr ""

#: ../../source/topics/cli.rst:175
msgid ""
"If this fails, try interpreting the identifier as a UUID (full or partial)"
msgstr ""

#: ../../source/topics/cli.rst:176
msgid "If this fails, interpret the identifier as a label"
msgstr ""

#: ../../source/topics/cli.rst:178
msgid ""
"The following example illustrates edge cases that can arise in this logic:"
msgstr ""

#: ../../source/topics/cli.rst:181
msgid "PK"
msgstr ""

#: ../../source/topics/cli.rst:181
msgid "UUID"
msgstr "UUID"

#: ../../source/topics/cli.rst:181
msgid "LABEL"
msgstr "LABEL"

#: ../../source/topics/cli.rst:183 ../../source/topics/cli.rst:184
msgid "10"
msgstr "10"

#: ../../source/topics/cli.rst:183
msgid "12dfb104-7b2b-4bca-adc0-1e4fd4ffcc88"
msgstr "12dfb104-7b2b-4bca-adc0-1e4fd4ffcc88"

#: ../../source/topics/cli.rst:183
msgid "group"
msgstr "group"

#: ../../source/topics/cli.rst:184
msgid "11"
msgstr "11"

#: ../../source/topics/cli.rst:184
msgid "deadbeef-62ba-444f-976d-31d925dac557"
msgstr "deadbeef-62ba-444f-976d-31d925dac557"

#: ../../source/topics/cli.rst:185
msgid "12"
msgstr "12"

#: ../../source/topics/cli.rst:185
msgid "3df34a1e-5215-4e1a-b626-7f75b9586ef5"
msgstr "3df34a1e-5215-4e1a-b626-7f75b9586ef5"

#: ../../source/topics/cli.rst:185
msgid "deadbeef"
msgstr "deadbeef"

#: ../../source/topics/cli.rst:188
msgid ""
"trying to identify the first entity by its partial UUID ``12`` would match "
"the third entity by its PK instead"
msgstr ""

#: ../../source/topics/cli.rst:189
msgid ""
"trying to identify the second entity by its label ``10`` would match the "
"first entity by its PK instead"
msgstr ""

#: ../../source/topics/cli.rst:190
msgid ""
"trying to identify the third entity by its label ``deadbeef`` would match "
"the second entity on its partial UUID ``deadbeef`` instead"
msgstr ""

#: ../../source/topics/cli.rst:192
msgid ""
"The ambiguity between a partial UUID and a PK can always be resolved by "
"including a longer substring of the UUID, eventually rendering the "
"identifier no longer a valid PK."
msgstr ""

#: ../../source/topics/cli.rst:194
msgid ""
"The case of a label being also a valid PK or (partial) UUID requires a "
"different solution. For this case, ``verdi`` reserves a special character, "
"the exclamation mark ``!``, that can be appended to the identifier. Before "
"any type guessing is done, AiiDA checks for the presence of this marker and,"
" if found, will interpret the identifier as a label. I.e. to solve ambiguity"
" examples mentioned above, one would pass ``10!`` and ``deadbeef!``."
msgstr ""

#: ../../source/topics/daemon.rst:5
msgid "Daemon"
msgstr "守护进程"

#: ../../source/topics/daemon.rst:7
msgid ""
"AiiDA provides a daemon process that runs in the background which handles "
"any new processes (i.e., calculations and workflows, see :ref:`process "
"concepts <topics:processes:concepts>`) that are submitted. Unlike when "
"running a process, which blocks the current Python interpreter (see the "
":ref:`launching <topics:processes:usage:launching>` section for details on "
"the difference between *run* and *submit*), the daemon can handle multiple "
"processes asynchronously."
msgstr ""

#: ../../source/topics/daemon.rst:10
msgid "The daemon concept in AiiDA consists of multiple *system processes*."
msgstr ""

#: ../../source/topics/daemon.rst:14
msgid ""
"System processes, here, refers to processes that are run by the operating "
"system, not to the AiiDA specific collective term for all calculations and "
"workflows."
msgstr ""

#: ../../source/topics/daemon.rst:16
msgid ""
"When the daemon is started, a single system process is launched in the "
"background that runs indefinitely until it is stopped. This daemonized "
"process is responsible for launching and then monitoring one or multiple "
"daemon *workers*. Each daemon worker is another system process that connects"
" to RabbitMQ to retrieve calculations and workflows that have been submitted"
" and run them to completion. If a daemon worker dies, the daemon will "
"automatically revive it. When the daemon is requested to stop, it will send "
"a signal to all workers to shut them down before shutting down itself."
msgstr ""

#: ../../source/topics/daemon.rst:22
msgid ""
"In summary: AiiDA's daemon consists of a single system process running in "
"the background (the daemon) that manages one or more system processes that "
"handle all submitted calculations and workflows (the daemon workers)."
msgstr ""

#: ../../source/topics/daemon.rst:29
msgid "Client"
msgstr ""

#: ../../source/topics/daemon.rst:31
msgid ""
"The Python API provides the "
":class:`~aiida.engine.daemon.client.DaemonClient` class to interact with the"
" daemon. It can either be constructed directly for a given profile, or the "
":func:`aiida.engine.get_daemon_client` utility function can be used to "
"construct it. In order to control the daemon for the current default "
"profile:"
msgstr ""

#: ../../source/topics/daemon.rst:40
msgid "It is also possible to explicitly specify a profile:"
msgstr ""

#: ../../source/topics/daemon.rst:46
msgid "The daemon can be started and stopped through the client:"
msgstr ""

#: ../../source/topics/daemon.rst:54
msgid "The main methods of interest for interacting with the daemon are:"
msgstr ""

#: ../../source/topics/daemon.rst:56
msgid ":meth:`~aiida.engine.daemon.client.DaemonClient.start_daemon`"
msgstr ""

#: ../../source/topics/daemon.rst:57
msgid ":meth:`~aiida.engine.daemon.client.DaemonClient.restart_daemon`"
msgstr ""

#: ../../source/topics/daemon.rst:58
msgid ":meth:`~aiida.engine.daemon.client.DaemonClient.stop_daemon`"
msgstr ""

#: ../../source/topics/daemon.rst:59
msgid ":meth:`~aiida.engine.daemon.client.DaemonClient.get_status`"
msgstr ""

#: ../../source/topics/daemon.rst:61
msgid ""
"These methods will raise a "
":class:`~aiida.engine.daemon.client.DaemonException` if the daemon fails to "
"start or calls to it fail. All methods accept a ``timeout`` argument, which "
"is the number of seconds the client should wait for the daemon process to "
"respond, before raising a "
":class:`~aiida.engine.daemon.client.DaemonTimeoutException`. The default for"
" the ``timeout`` is taken from the ``daemon.timeout`` configuration option "
"and is set when constructing the "
":class:`~aiida.engine.daemon.client.DaemonClient`."
msgstr ""

#: ../../source/topics/daemon.rst:67
msgid ""
"The ``DaemonClient`` only directly interacts with the main daemon process, "
"not with any of the daemon workers that it manages."
msgstr ""

#: ../../source/topics/data_types.rst:5
msgid "Data types"
msgstr "数据类型"

#: ../../source/topics/data_types.rst:7
msgid ""
"AiiDA already ships with a number of useful data types. This section details"
" the most common, and some handy features/functionalities to work with them."
msgstr ""

#: ../../source/topics/data_types.rst:10
msgid ""
"The different data types can be accessed through the "
":py:func:`~aiida.plugins.factories.DataFactory` function (also exposed from "
":py:mod:`aiida.plugins`) by passing the corresponding entry point as an "
"argument, for example when working in the ``verdi shell``:"
msgstr ""

#: ../../source/topics/data_types.rst:18
msgid ""
"Many of the examples in this section will assume you are working inside the "
"``verdi shell``. If this is not the case, you will have to first load e.g. "
"the :py:func:`~aiida.plugins.factories.DataFactory()` function:"
msgstr ""

#: ../../source/topics/data_types.rst:27
msgid ""
"A list of all the data entry points can be obtain running the command "
"``verdi plugin list aiida.data``."
msgstr ""

#: ../../source/topics/data_types.rst:29
msgid ""
"For all data types, you can follow the link to the corresponding data class "
"in the API reference to read more about the class and its methods. We also "
"detail what is stored in the database (mostly as attributes, so the "
"information can be easily queried e.g. with the :ref:`QueryBuilder <how-"
"to:query>`) and what is stored as a raw file in the AiiDA file repository "
"(providing access to the file contents, but not efficiently queryable: this "
"is useful for e.g. big data files that don't need to be queried for)."
msgstr ""

#: ../../source/topics/data_types.rst:31
msgid ""
"If you need to work with some specific type of data, first check the list of"
" data types/plugins below, and if you don't find what you need, give a look "
"to :ref:`Adding support for custom data types <topics:data_types:plugin>`."
msgstr ""

#: ../../source/topics/data_types.rst:36
msgid "Core data types"
msgstr ""

#: ../../source/topics/data_types.rst:38
msgid ""
"Below is a list of the core data types already provided with AiiDA, along "
"with their entry point and where the data is stored once the node is stored "
"in the AiiDA database."
msgstr ""

#: ../../source/topics/data_types.rst:44
#: ../../source/topics/data_types.rst:759
msgid "**Class**"
msgstr ""

#: ../../source/topics/data_types.rst:44
#: ../../source/topics/data_types.rst:759
msgid "**Entry point**"
msgstr ""

#: ../../source/topics/data_types.rst:44
#: ../../source/topics/data_types.rst:759
msgid "**Stored in database**"
msgstr ""

#: ../../source/topics/data_types.rst:44
#: ../../source/topics/data_types.rst:759
msgid "**Stored in repository**"
msgstr ""

#: ../../source/topics/data_types.rst:46
msgid ":ref:`Int <topics:data_types:core:base>`"
msgstr ""

#: ../../source/topics/data_types.rst:46
msgid "``core.int``"
msgstr ""

#: ../../source/topics/data_types.rst:46
msgid "The integer value"
msgstr ""

#: ../../source/topics/data_types.rst:46 ../../source/topics/data_types.rst:48
#: ../../source/topics/data_types.rst:50 ../../source/topics/data_types.rst:52
#: ../../source/topics/data_types.rst:54 ../../source/topics/data_types.rst:56
#: ../../source/topics/data_types.rst:58 ../../source/topics/data_types.rst:60
#: ../../source/topics/data_types.rst:68 ../../source/topics/data_types.rst:72
#: ../../source/topics/data_types.rst:76 ../../source/topics/data_types.rst:80
msgid "``-``"
msgstr ""

#: ../../source/topics/data_types.rst:48
msgid ":ref:`Float <topics:data_types:core:base>`"
msgstr ""

#: ../../source/topics/data_types.rst:48
msgid "``core.float``"
msgstr ""

#: ../../source/topics/data_types.rst:48
msgid "The float value"
msgstr ""

#: ../../source/topics/data_types.rst:50
msgid ":ref:`Str <topics:data_types:core:base>`"
msgstr ""

#: ../../source/topics/data_types.rst:50
msgid "``core.str``"
msgstr ""

#: ../../source/topics/data_types.rst:50
msgid "The string"
msgstr ""

#: ../../source/topics/data_types.rst:52
msgid ":ref:`Bool <topics:data_types:core:base>`"
msgstr ""

#: ../../source/topics/data_types.rst:52
msgid "``core.bool``"
msgstr ""

#: ../../source/topics/data_types.rst:52
msgid "The boolean value"
msgstr ""

#: ../../source/topics/data_types.rst:54
msgid ":ref:`List <topics:data_types:core:base:iterable>`"
msgstr ""

#: ../../source/topics/data_types.rst:54
msgid "``core.list``"
msgstr ""

#: ../../source/topics/data_types.rst:54
msgid "The complete list"
msgstr ""

#: ../../source/topics/data_types.rst:56
msgid ":ref:`Dict <topics:data_types:core:base:iterable>`"
msgstr ""

#: ../../source/topics/data_types.rst:56
msgid "``core.dict``"
msgstr ""

#: ../../source/topics/data_types.rst:56
msgid "The complete dictionary"
msgstr ""

#: ../../source/topics/data_types.rst:58
msgid ":ref:`EnumData <topics:data_types:core:base:enum>`"
msgstr ""

#: ../../source/topics/data_types.rst:58
msgid "``core.enum``"
msgstr ""

#: ../../source/topics/data_types.rst:58
msgid "The value, name and the class identifier"
msgstr ""

#: ../../source/topics/data_types.rst:60
msgid ":ref:`JsonableData <topics:data_types:core:jsonable>`"
msgstr ""

#: ../../source/topics/data_types.rst:60
msgid "``core.jsonable``"
msgstr ""

#: ../../source/topics/data_types.rst:60
msgid "The JSON data and the class identifier"
msgstr ""

#: ../../source/topics/data_types.rst:62
msgid ":ref:`ArrayData <topics:data_types:core:array>`"
msgstr ""

#: ../../source/topics/data_types.rst:62
msgid "``core.array``"
msgstr ""

#: ../../source/topics/data_types.rst:62 ../../source/topics/data_types.rst:64
msgid "The array names and corresponding shapes"
msgstr ""

#: ../../source/topics/data_types.rst:62 ../../source/topics/data_types.rst:64
msgid "The array data in ``.npy`` format"
msgstr ""

#: ../../source/topics/data_types.rst:64
msgid ":ref:`XyData <topics:data_types:core:array:xy>`"
msgstr ""

#: ../../source/topics/data_types.rst:64
msgid "``core.array.xy``"
msgstr ""

#: ../../source/topics/data_types.rst:66
msgid ":ref:`SinglefileData <topics:data_types:core:singlefile>`"
msgstr ""

#: ../../source/topics/data_types.rst:66
msgid "``core.singlefile``"
msgstr ""

#: ../../source/topics/data_types.rst:66
msgid "The filename"
msgstr ""

#: ../../source/topics/data_types.rst:66
msgid "The file"
msgstr ""

#: ../../source/topics/data_types.rst:68
msgid ":ref:`FolderData <topics:data_types:core:folder>`"
msgstr ""

#: ../../source/topics/data_types.rst:68
msgid "``core.folder``"
msgstr ""

#: ../../source/topics/data_types.rst:68 ../../source/topics/data_types.rst:70
#: ../../source/topics/data_types.rst:74
msgid "All files and folders"
msgstr ""

#: ../../source/topics/data_types.rst:70
msgid ":ref:`RemoteData <topics:data_types:core:remote>`"
msgstr ""

#: ../../source/topics/data_types.rst:70
msgid "``core.remote``"
msgstr ""

#: ../../source/topics/data_types.rst:70
msgid "The computer and the absolute path to the folder"
msgstr ""

#: ../../source/topics/data_types.rst:72
msgid ":ref:`AbstractCode <topics:data_types:core:code>`"
msgstr ""

#: ../../source/topics/data_types.rst:72
msgid "Default plugin, append/prepend text"
msgstr ""

#: ../../source/topics/data_types.rst:74
msgid ":ref:`Code <topics:data_types:core:code:legacy>`"
msgstr ""

#: ../../source/topics/data_types.rst:74
msgid "``core.code``"
msgstr ""

#: ../../source/topics/data_types.rst:74 ../../source/topics/data_types.rst:76
msgid "The computer and the executable path"
msgstr ""

#: ../../source/topics/data_types.rst:76
msgid ":ref:`InstalledCode <topics:data_types:core:code:installed>`"
msgstr ""

#: ../../source/topics/data_types.rst:76
msgid "``core.code.installed``"
msgstr ""

#: ../../source/topics/data_types.rst:78
msgid ":ref:`PortableCode <topics:data_types:core:code:portable>`"
msgstr ""

#: ../../source/topics/data_types.rst:78
msgid "``core.code.portable``"
msgstr ""

#: ../../source/topics/data_types.rst:78
msgid "The relative path of the executable"
msgstr ""

#: ../../source/topics/data_types.rst:78
msgid "All files and folders of the code"
msgstr ""

#: ../../source/topics/data_types.rst:80
msgid ":ref:`ContainerizedCode <topics:data_types:core:code:containerized>`"
msgstr ""

#: ../../source/topics/data_types.rst:80
msgid "``core.code.containerized``"
msgstr ""

#: ../../source/topics/data_types.rst:80
msgid "The computer, the image and the executable path"
msgstr ""

#: ../../source/topics/data_types.rst:87
msgid "Base types"
msgstr "基础类型"

#: ../../source/topics/data_types.rst:89
msgid ""
"There are a number of useful classes that wrap base Python data types "
"(:py:class:`~aiida.orm.nodes.data.int.Int`, "
":py:class:`~aiida.orm.nodes.data.float.Float`, "
":py:class:`~aiida.orm.nodes.data.str.Str`, "
":py:class:`~aiida.orm.nodes.data.bool.Bool`) so they can be stored in the "
"provenance. These are automatically loaded with the ``verdi shell``, and "
"also directly exposed from :py:mod:`aiida.orm`. They are particularly useful"
" when you need to provide a single parameter to e.g. a "
":py:class:`~aiida.engine.processes.functions.workfunction`."
msgstr ""

#: ../../source/topics/data_types.rst:93
msgid ""
"Each of these classes can most often be used in a similar way as their "
"corresponding base type:"
msgstr ""

#: ../../source/topics/data_types.rst:99
msgid ""
"If you need to access the bare value and not the whole AiiDA class, use the "
"``.value`` property:"
msgstr ""

#: ../../source/topics/data_types.rst:108
msgid ""
"While this is convenient if you need to do simple manipulations like "
"multiplying two numbers, be very careful not to pass such nodes instead of "
"the corresponding Python values to libraries that perform heavy computations"
" with them. In fact, any operation on the value would be replaced with an "
"operation creating new AiiDA nodes, that however can be orders of magnitude "
"slower (see `this discussion <https://github.com/aiidateam/aiida-"
"core/issues/3320>`_ on GitHub). In this case, remember to pass the "
"node.value to the mathematical function instead."
msgstr ""

#: ../../source/topics/data_types.rst:114
msgid ""
"AiiDA has also implemented data classes for two basic Python iterables: "
":py:class:`~aiida.orm.nodes.data.list.List` and "
":py:class:`~aiida.orm.nodes.data.dict.Dict`. They can store any list or "
"dictionary where elements can be a base python type (strings, floats, "
"integers, booleans, None type):"
msgstr ""

#: ../../source/topics/data_types.rst:120
msgid ""
"Note the use of the keyword argument ``list``, this is required for the "
"constructor of the :py:class:`~aiida.orm.nodes.data.list.List` class. You "
"can also store lists or dictionaries within the iterable, at any depth "
"level. For example, you can create a dictionary where a value is a list of "
"dictionaries:"
msgstr ""

#: ../../source/topics/data_types.rst:128
msgid ""
"To obtain the Python ``list`` or ``dictionary`` from a "
":py:class:`~aiida.orm.nodes.data.list.List` or "
":py:class:`~aiida.orm.nodes.data.dict.Dict` instance, you have to use the "
":py:meth:`~aiida.orm.nodes.data.list.List.get_list()` or "
":py:meth:`~aiida.orm.nodes.data.dict.Dict.get_dict()` methods:"
msgstr ""

#: ../../source/topics/data_types.rst:138
msgid ""
"However, you can also use the list index or dictionary key to extract "
"specific values:"
msgstr ""

#: ../../source/topics/data_types.rst:148
msgid ""
"You can also use many methods of the corresponding Python base type, for "
"example:"
msgstr ""

#: ../../source/topics/data_types.rst:157
msgid ""
"For all of the base data types, their value is stored in the database in the"
" attributes column once you store the node using the "
":py:meth:`~aiida.orm.nodes.node.Node.store()` method."
msgstr ""

#: ../../source/topics/data_types.rst:161
msgid ""
"The :py:class:`~aiida.orm.List` and :py:class:`~aiida.orm.Dict` only store "
"the Python base types, not the corresponding AiiDA data type. These will be "
"converted to their corresponding Python base type when storing the "
":py:class:`~aiida.orm.List` or :py:class:`~aiida.orm.Dict` node in the "
"database."
msgstr ""

#: ../../source/topics/data_types.rst:167
msgid "EnumData"
msgstr ""

#: ../../source/topics/data_types.rst:171
msgid ""
"An `Enum` member is represented by three attributes in the "
":py:class:`~aiida.orm.EnumData` class:"
msgstr ""

#: ../../source/topics/data_types.rst:173
msgid "``name``: the member's name"
msgstr ""

#: ../../source/topics/data_types.rst:174
msgid "``value``: the member's value"
msgstr ""

#: ../../source/topics/data_types.rst:175
msgid "``identifier``: the string representation of the enum's identifier"
msgstr ""

#: ../../source/topics/data_types.rst:199
msgid "JsonableData"
msgstr ""

#: ../../source/topics/data_types.rst:203
msgid ""
":py:class:`~aiida.orm.JsonableData` is a data plugin that allows one to "
"easily wrap existing objects that are JSON-able."
msgstr ""

#: ../../source/topics/data_types.rst:205
msgid ""
"Any class that implements an ``as_dict`` method, returning a dictionary that"
" is a JSON serializable representation of the object, can be wrapped and "
"stored by this data plugin. To deserialize it should also implement a "
"``from_dict`` method, which takes the dictionary as input and returns the "
"object."
msgstr ""

#: ../../source/topics/data_types.rst:232
msgid "ArrayData"
msgstr "数组结构（ArrayData）"

#: ../../source/topics/data_types.rst:234
msgid ""
"The :py:class:`~aiida.orm.ArrayData` class can be used to represent `numpy "
"<https://numpy.org/>`_ arrays in the provenance. Each array is assigned to a"
" name specified by the user using the "
":py:meth:`~aiida.orm.ArrayData.set_array()` method:"
msgstr ""

#: ../../source/topics/data_types.rst:245
msgid ""
"Note that one :py:class:`~aiida.orm.ArrayData` instance can store multiple "
"arrays under different names:"
msgstr ""

#: ../../source/topics/data_types.rst:251
msgid ""
"To see the list of array names stored in the "
":py:class:`~aiida.orm.ArrayData` instance, you can use the "
":py:meth:`~aiida.orm.ArrayData.get_arraynames()` method:"
msgstr ""

#: ../../source/topics/data_types.rst:258
msgid ""
"If you want the array corresponding to a certain name, simply supply the "
"name to the :py:meth:`~aiida.orm.ArrayData.get_array()` method:"
msgstr ""

#: ../../source/topics/data_types.rst:267
msgid ""
"As with all nodes, you can store the :py:class:`~aiida.orm.ArrayData` node "
"using the :py:meth:`~aiida.orm.nodes.node.Node.store()` method. However, "
"only the names and shapes of the arrays are stored to the database, the "
"content of the arrays is stored to the repository in the `numpy format "
"<https://numpy.org/doc/stable/reference/generated/numpy.lib.format.html#npy-"
"format>`_ (``.npy``)."
msgstr ""

#: ../../source/topics/data_types.rst:272
msgid "XyData"
msgstr "XyData"

#: ../../source/topics/data_types.rst:274
msgid ""
"In case you are working with arrays that have a relationship with each "
"other, i.e. ``y`` as a function of ``x``, you can use the "
":py:class:`~aiida.orm.XyData` class:"
msgstr ""

#: ../../source/topics/data_types.rst:282
msgid ""
"This class is equipped with setter and getter methods for the ``x`` and "
"``y`` values specifically, and takes care of some validation (e.g. check "
"that they have the same shape). The user also has to specify the units for "
"both ``x`` and ``y``:"
msgstr ""

#: ../../source/topics/data_types.rst:291
msgid ""
"Note that you can set multiple ``y`` values that correspond to the ``x`` "
"grid. Same as for the :py:class:`~aiida.orm.ArrayData`, the names and shapes"
" of the arrays are stored to the database, the content of the arrays is "
"stored to the repository in the `numpy format "
"<https://numpy.org/doc/stable/reference/generated/numpy.lib.format.html#npy-"
"format>`_ (``.npy``)."
msgstr ""

#: ../../source/topics/data_types.rst:297
msgid "SinglefileData"
msgstr "单一文件信息（SinglefileData）"

#: ../../source/topics/data_types.rst:299
msgid ""
"In order to include a single file in the provenance, you can use the "
":py:class:`~aiida.orm.nodes.data.singlefile.SinglefileData` class. This "
"class can be initialized via the **absolute** path to the file you want to "
"store:"
msgstr ""

#: ../../source/topics/data_types.rst:308
msgid ""
"When storing the node, the filename is stored in the database and the file "
"itself is copied to the repository. The contents of the file in string "
"format can be obtained using the "
":py:meth:`~aiida.orm.nodes.data.singlefile.SinglefileData.get_content()` "
"method:"
msgstr ""

#: ../../source/topics/data_types.rst:316
#: ../../source/topics/data_types.rst:415
msgid ""
"For large files, reading the entire content into memory using "
":py:meth:`~aiida.orm.nodes.repository.NodeRepository.get_object_content()` "
"may not be desirable. Instead, a file-like handle can be opened to a file in"
" the repository which can be used to read the content as a stream. This can "
"be useful, for example, to copy a large file from the repository to a file "
"on disk, without loading it entirely into memory:"
msgstr ""

#: ../../source/topics/data_types.rst:327
#: ../../source/topics/data_types.rst:426
msgid ""
"To guarantee the file is copied over identically (and there are no encoding "
"issues), the files are opened in \"binary\" mode by including the ``b`` "
"character in the ``mode`` argument."
msgstr ""

#: ../../source/topics/data_types.rst:329
msgid ""
"For efficiency reasons, the repository interface only provides access to "
"object content through file-like objects or strings. However, for certain "
"use-cases, the object content _needs_ to be made available as a file on the "
"local file system. For example, the ``numpy.loadtxt`` method only accepts a "
"filepath, and no file-like objects. In this case, the content of the file "
"can be made available on the local file system using the "
":py:meth:`~aiida.orm.nodes.repository.NodeRepository.as_path()` context "
"manager:"
msgstr ""

#: ../../source/topics/data_types.rst:339
msgid ""
"The yielded value ``filepath`` is an instance of ``pathlib.Path`` that "
"points to a location on the local file system containing the content of the "
"file. The temporary copy on the local file system is automatically cleaned "
"up once the context manager is exited."
msgstr ""

#: ../../source/topics/data_types.rst:344
#: ../../source/topics/data_types.rst:444
msgid ""
"The temporary directory to which the content is copied is created using the "
":meth:`tempfile.TemporaryDirectory` function of the standard library. Its "
"location is chosen from a platform-dependent list or can be controlled "
"through the ``TMPDIR`` environment variable (see `the official documentation"
" <https://docs.python.org/3/library/tempfile.html#tempfile.mkstemp>`_ for "
"details)."
msgstr ""

#: ../../source/topics/data_types.rst:349
msgid ""
"The :py:meth:`~aiida.orm.nodes.repository.NodeRepository.as_path()` context "
"manager will copy the file content to a temporary folder on the local file "
"system. For large files this can be an expensive operation and it is "
"inefficient since it requires an additional read and write operation. "
"Therefore, if it is possible to use file-like objects or read the content "
"into memory, the "
":py:meth:`~aiida.orm.nodes.repository.NodeRepository.get_object_content()` "
"and :py:meth:`~aiida.orm.nodes.repository.NodeRepository.open()` methods "
"should be preferred."
msgstr ""

#: ../../source/topics/data_types.rst:357
msgid "FolderData"
msgstr "文件夹数据（FolderData）"

#: ../../source/topics/data_types.rst:359
msgid ""
"The :py:class:`~aiida.orm.nodes.data.folder.FolderData` class stores sets of"
" files and folders (including its subfolders). To store a complete "
"directory, simply use the ``tree`` keyword:"
msgstr ""

#: ../../source/topics/data_types.rst:368
msgid ""
"Alternatively, you can construct the node first and then use the various "
"repository methods to add objects from directory and file paths:"
msgstr ""

#: ../../source/topics/data_types.rst:378
msgid ""
"or from `file-like objects <https://docs.python.org/3/glossary.html#term-"
"file-like-object>`_:"
msgstr ""

#: ../../source/topics/data_types.rst:384
msgid ""
"Inversely, the content of the files stored in the "
":py:class:`~aiida.orm.nodes.data.folder.FolderData` node can be accessed "
"using the "
":py:meth:`~aiida.orm.nodes.repository.NodeRepository.get_object_content()` "
"method:"
msgstr ""

#: ../../source/topics/data_types.rst:391
msgid ""
"To see the files that are stored in the "
":py:class:`~aiida.orm.nodes.data.folder.FolderData`, you can use the "
":py:meth:`~aiida.orm.nodes.repository.NodeRepository.list_object_names()` "
"method:"
msgstr ""

#: ../../source/topics/data_types.rst:398
msgid ""
"In this example, ``subdir`` was a sub directory of "
"``/absolute/path/to/directory``, whose contents where added above. to list "
"the contents of the ``subdir`` directory, you can pass its path to the "
":py:meth:`~aiida.orm.nodes.repository.NodeRepository.list_object_names()` "
"method:"
msgstr ""

#: ../../source/topics/data_types.rst:406
msgid ""
"The content can once again be shown using the "
":py:meth:`~aiida.orm.nodes.repository.NodeRepository.get_object_content()` "
"method by passing the correct path:"
msgstr ""

#: ../../source/topics/data_types.rst:413
msgid ""
"Since the :py:class:`~aiida.orm.nodes.data.folder.FolderData` node is simply"
" a collection of files, it simply stores these files in the repository."
msgstr ""

#: ../../source/topics/data_types.rst:428
msgid ""
"For efficiency reasons, the repository interface only provides access to "
"object content through file-like objects or strings. However, for certain "
"use-cases, the object content _needs_ to be made available as a file on the "
"local file system. For example, the ``numpy.loadtxt`` method only accepts a "
"filepath, and no file-like objects. In this case, the content of the node's "
"repository can be made available on the local file system using the "
":py:meth:`~aiida.orm.nodes.repository.NodeRepository.as_path()` context "
"manager:"
msgstr ""

#: ../../source/topics/data_types.rst:439
msgid ""
"The yielded value ``dirpath`` is an instance of ``pathlib.Path`` that points"
" to a location on the local file system containing the complete content of "
"the repository. The temporary copy on the local file system is automatically"
" cleaned up once the context manager is exited."
msgstr ""

#: ../../source/topics/data_types.rst:447
msgid "Optionally, an explicit object can be specified:"
msgstr ""

#: ../../source/topics/data_types.rst:454
msgid ""
"If the object at ``path`` is a directory, the returned value points to a "
"directory that contains its contents. If it is a file, the returned value "
"points to a file with the content of the object."
msgstr ""

#: ../../source/topics/data_types.rst:459
msgid ""
"The :py:meth:`~aiida.orm.nodes.repository.NodeRepository.as_path()` context "
"manager will copy the content to a temporary folder on the local file "
"system. For large repositories this can be an expensive operation and it is "
"inefficient since it requires an additional read and write operation. "
"Therefore, if it is possible to use file-like objects or read the content "
"into memory, the "
":py:meth:`~aiida.orm.nodes.repository.NodeRepository.get_object_content()` "
"and :py:meth:`~aiida.orm.nodes.repository.NodeRepository.open()` methods "
"should be preferred."
msgstr ""

#: ../../source/topics/data_types.rst:467
msgid "RemoteData"
msgstr "远程数据（RemoteData）"

#: ../../source/topics/data_types.rst:469
msgid ""
"The :py:class:`~aiida.orm.RemoteData` node represents a \"symbolic link\" to"
" a specific folder on a remote computer. Its main use is to allow users to "
"persist the provenance when e.g. a calculation produces data in a "
"raw/scratch folder, and the whole folder needs to be provided to "
"restart/continue. To create a :py:class:`~aiida.orm.RemoteData` instance, "
"simply pass the remote path to the folder and the computer on which it is "
"stored:"
msgstr ""

#: ../../source/topics/data_types.rst:481
msgid ""
"You can see the contents of the remote folder by using the "
":py:meth:`~aiida.orm.RemoteData.listdir()` method:"
msgstr ""

#: ../../source/topics/data_types.rst:488
msgid ""
"To see the contents of a subdirectory, pass the relative path to the "
":py:meth:`~aiida.orm.RemoteData.listdir()` method:"
msgstr ""

#: ../../source/topics/data_types.rst:497
msgid ""
"Using the :py:meth:`~aiida.orm.RemoteData.listdir()` method, or any method "
"that retrieves information from the remote computer, opens a connection to "
"the remote computer using its transport type. Their use is strongly "
"discouraged when writing scripts and/or workflows."
msgstr ""

#: ../../source/topics/data_types.rst:504
msgid "AbstractCode"
msgstr ""

#: ../../source/topics/data_types.rst:508
msgid ""
"The :class:`aiida.orm.nodes.data.code.abstract.AbstractCode` class provides "
"the abstract class for objects that represent a \"code\" that can be "
"executed through a :class:`aiida.engine.processes.calcjobs.calcjob.CalcJob` "
"plugin. There are currently four implementations of this abstract class:"
msgstr ""

#: ../../source/topics/data_types.rst:511
msgid ""
":class:`~aiida.orm.nodes.data.code.legacy.Code` (see :ref:`Code "
"<topics:data_types:core:code:legacy>`)"
msgstr ""

#: ../../source/topics/data_types.rst:512
msgid ""
":class:`~aiida.orm.nodes.data.code.installed.InstalledCode` (see "
":ref:`InstalledCode <topics:data_types:core:code:installed>`)"
msgstr ""

#: ../../source/topics/data_types.rst:513
msgid ""
":class:`~aiida.orm.nodes.data.code.portable.PortableCode` (see "
":ref:`PortableCode <topics:data_types:core:code:portable>`)"
msgstr ""

#: ../../source/topics/data_types.rst:514
msgid ""
":class:`~aiida.orm.nodes.data.code.containerized.ContainerizedCode` (see "
":ref:`ContainerizedCode <topics:data_types:core:code:containerized>`)"
msgstr ""

#: ../../source/topics/data_types.rst:520
msgid "Code"
msgstr ""

#: ../../source/topics/data_types.rst:524
msgid ""
"Historically, there was only one code implementation, the "
":class:`~aiida.orm.nodes.data.code.legacy.Code`, which implemented two "
"different types of code:"
msgstr ""

#: ../../source/topics/data_types.rst:526
msgid ""
"An executable pre-installed on a computer, represented by a "
":class:`~aiida.orm.computers.Computer`."
msgstr ""

#: ../../source/topics/data_types.rst:527
msgid ""
"A directory containing all code files including an executable which would be"
" uploaded to"
msgstr ""

#: ../../source/topics/data_types.rst:529
msgid ""
"These two types were referred to as \"remote\" and \"local\" codes. However,"
" this nomenclature would lead to confusion as a \"remote\" code could also "
"refer to an executable on the localhost, i.e., the machine where AiiDA "
"itself runs. In addition, having two different concepts implemented by a "
"single class led to a unintuitive interface. Therefore, the ``Code`` class "
"was deprecated in ``aiida-core==2.1`` and replaced by the :ref:`InstallCode "
"<topics:data_types:core:code:installed>` and :ref:`InstallCode "
"<topics:data_types:core:code:installed>`, respectively. The ``Code`` class "
"is now deprecated and will be removed in ``aiida-core==3.0``."
msgstr ""

#: ../../source/topics/data_types.rst:539
msgid "InstalledCode"
msgstr ""

#: ../../source/topics/data_types.rst:543
msgid ""
"The :class:`~aiida.orm.nodes.data.code.installed.InstalledCode` class is an "
"implementation of the "
":class:`~aiida.orm.nodes.data.code.abstract.AbstractCode` class that "
"represents an executable code on a remote computer. This plugin should be "
"used if an executable is pre-installed on a computer. The ``InstalledCode`` "
"represents the code by storing the filepath of the relevant executable and "
"the computer on which it is installed. The computer is represented by an "
"instance of :class:`~aiida.orm.computers.Computer`. Each time a "
":class:`~aiida.engine.CalcJob` is run using an ``InstalledCode``, it will "
"run its executable on the associated computer. Example of creating an "
"``InstalledCode``:"
msgstr ""

#: ../../source/topics/data_types.rst:559
msgid ""
"The ``filepath_executable`` is no longer required to be an absolute path but"
" can be just the executable name."
msgstr ""

#: ../../source/topics/data_types.rst:566
msgid "PortableCode"
msgstr ""

#: ../../source/topics/data_types.rst:570
msgid ""
"The :class:`~aiida.orm.nodes.data.code.portable.PortableCode` class is an "
"implementation of the "
":class:`~aiida.orm.nodes.data.code.abstract.AbstractCode` class that "
"represents an executable code stored in AiiDA's storage. This plugin should "
"be used for executables that are not already installed on the target "
"computer, but instead are available on the machine where AiiDA is running. "
"The plugin assumes that the code is self-contained by a single directory "
"containing all the necessary files, including a main executable. When "
"constructing a ``PortableCode``, passing the absolute filepath as "
"``filepath_files`` will make sure that all the files contained within are "
"uploaded to AiiDA's storage. The ``filepath_executable`` should indicate the"
" filename of the executable within that directory. Each time a "
":class:`~aiida.engine.CalcJob` is run using a ``PortableCode``, the uploaded"
" files will be automatically copied to the working directory on the selected"
" computer and the executable will be run there. Example of creating an "
"``PortableCode``:"
msgstr ""

#: ../../source/topics/data_types.rst:591
msgid "ContainerizedCode"
msgstr ""

#: ../../source/topics/data_types.rst:595
msgid ""
"The :class:`~aiida.orm.nodes.data.code.containerized.ContainerizedCode` "
"class allows running an executable within a container image on a target "
"computer. The data plugin stores the following information in the database:"
msgstr ""

#: ../../source/topics/data_types.rst:598
msgid ""
"``image_name``: The name of the container image (e.g., a URI like "
"``docker://alpine:3`` or an absolute file path like ``/path/to/image.sif``)."
msgstr ""

#: ../../source/topics/data_types.rst:599
msgid ""
"``filepath_executable``: The filepath of the executable within the container"
" (e.g. ``/usr/bin/bash``)."
msgstr ""

#: ../../source/topics/data_types.rst:600
msgid ""
"``engine_command``: The bash command to invoke the container image (e.g. "
"``singularity exec --bind $PWD:$PWD {image_name}``). The exact form of this "
"command will depend on the containerization technology that is used."
msgstr ""

#: ../../source/topics/data_types.rst:602
msgid ""
"``computer``: The :class:`~aiida.orm.computers.Computer` on which to run the"
" container."
msgstr ""

#: ../../source/topics/data_types.rst:606
msgid ""
"If the container image is not yet present on the target computer, most "
"container engines will pull the image from the registry at first use. This "
"can take a while if the image is large."
msgstr ""

#: ../../source/topics/data_types.rst:611
msgid ""
"If the ``engine_command`` contains variables (such as in the ``singularity "
"exec --bind $PWD:$PWD {image_name}`` example), it is crucial that the "
"``Computer`` needs to have the ``use_double_quotes`` setting set to "
"``True``. By default, a ``Computer`` will use single quotes to escape "
"command line arguments and so the ``$PWD`` would not be expanded. If this "
"wasn't defined as such when the ``Computer`` was created, it can be changed "
"through the API:"
msgstr ""

#: ../../source/topics/data_types.rst:624
msgid "Setup"
msgstr "配置"

#: ../../source/topics/data_types.rst:626
msgid ""
"A ``ContainerizedCode`` can be created through the CLI as well as the API. "
"The following examples show how to setup running ``bash`` in a base Docker "
"container through Singularity to be run on the ``Computer`` named ``some-"
"computer``:"
msgstr ""

#: ../../source/topics/data_types.rst:0
msgid "CLI"
msgstr ""

#: ../../source/topics/data_types.rst:0
msgid "API"
msgstr ""

#: ../../source/topics/data_types.rst:657
msgid ""
"Please refer to the section on :ref:`supported container technologies "
"<topics:data_types:core:code:installed:containerized:support>` for an "
"overview and specific setup instructions for each containerization solution."
msgstr ""

#: ../../source/topics/data_types.rst:662
msgid "Run"
msgstr ""

#: ../../source/topics/data_types.rst:664
msgid ""
"A ``ContainerizedCode`` is used to launch a calculation just like any other "
"code. If a default calculation job plugin is defined, a process builder can "
"be obtained with ``get_builder``:"
msgstr ""

#: ../../source/topics/data_types.rst:679
msgid ""
"If a containerized code is used for a calculation that enables MPI (see "
":ref:`Controlling MPI <topics:calculations:usage:calcjobs:mpi>`), the MPI "
"command line arguments are placed in front of the container runtime. For "
"example, when running Singularity with MPI enabled, the runline in the "
"submission script will be written as:"
msgstr ""

#: ../../source/topics/data_types.rst:686
msgid ""
"This means that the containerization program is launched as a normal MPI "
"program, and so it needs to support forwarding the execution context to the "
"container application. It is currently not possible to have MPI invoked "
"inside the container runtime."
msgstr ""

#: ../../source/topics/data_types.rst:693
msgid "Supported container technologies"
msgstr ""

#: ../../source/topics/data_types.rst:695
msgid ""
"The ``ContainerizedCode`` is compatible with a variety of containerization "
"technologies:"
msgstr ""

#: ../../source/topics/data_types.rst:0
msgid "Docker"
msgstr ""

#: ../../source/topics/data_types.rst:701
msgid ""
"To use `Docker <https://www.docker.com/>`_ ``aiida-core==2.3.0`` or higher "
"is required in order to be able to set ``wrap_cmdline_params = True``. When "
"setting up a code for a Docker container, use the following "
"``engine_command`` when setting up the code:"
msgstr ""

#: ../../source/topics/data_types.rst:708
msgid ""
"Currently running with MPI is not yet supported, as it needs to be called "
"inside of the container which is currently not possible. The associated "
"computer should also be configured to have the setting ``use_double_quotes ="
" False``. This can be set from the Python API using "
"``load_computer('idenfitier').set_use_double_quotes(False)``."
msgstr ""

#: ../../source/topics/data_types.rst:712
msgid ""
"The following configuration provides an example to setup Quantum ESPRESSO's "
"``pw.x`` to be run by Docker on the local host"
msgstr ""

#: ../../source/topics/data_types.rst:725
msgid ""
"Save the configuration to ``code.yml`` and create the code using the "
"``verdi`` CLI:"
msgstr ""

#: ../../source/topics/data_types.rst:0
msgid "Singularity"
msgstr ""

#: ../../source/topics/data_types.rst:733
msgid ""
"To use `Singularity <https://singularity-docs.readthedocs.io/en/latest/>`_ "
"use the following ``engine_command`` when setting up the code:"
msgstr ""

#: ../../source/topics/data_types.rst:0
msgid "Sarus"
msgstr ""

#: ../../source/topics/data_types.rst:741
msgid ""
"To use `Sarus <https://sarus.readthedocs.io/en/stable/>`_ use the following "
"``engine_command`` when setting up the code:"
msgstr ""

#: ../../source/topics/data_types.rst:750
msgid "Materials science data types"
msgstr ""

#: ../../source/topics/data_types.rst:752
msgid ""
"Since AiiDA was first developed within the computational materials science "
"community, `aiida-core` still contains several data types specific to this "
"field. This sections lists these data types and provides some important "
"examples of their usage."
msgstr ""

#: ../../source/topics/data_types.rst:761
msgid ":ref:`StructureData <topics:data_types:materials:structure>`"
msgstr ""

#: ../../source/topics/data_types.rst:761
msgid "``structure``"
msgstr ""

#: ../../source/topics/data_types.rst:761
msgid ""
"The cell, periodic boundary conditions, atomic positions, species and kinds."
msgstr ""

#: ../../source/topics/data_types.rst:761
#: ../../source/topics/data_types.rst:767
msgid "\\\\-"
msgstr ""

#: ../../source/topics/data_types.rst:763
msgid ":ref:`TrajectoryData <topics:data_types:materials:trajectory>`"
msgstr ""

#: ../../source/topics/data_types.rst:763
msgid "``array.trajectory``"
msgstr ""

#: ../../source/topics/data_types.rst:763
msgid ""
"The structure species and the shape of the cell, step and position arrays."
msgstr ""

#: ../../source/topics/data_types.rst:763
#: ../../source/topics/data_types.rst:769
#: ../../source/topics/data_types.rst:771
msgid "The array data in numpy format."
msgstr ""

#: ../../source/topics/data_types.rst:765
msgid ":ref:`UpfData <topics:data_types:materials:upf>`"
msgstr ""

#: ../../source/topics/data_types.rst:765
msgid "``upf``"
msgstr ""

#: ../../source/topics/data_types.rst:765
msgid "The MD5 of the UPF and the element of the pseudopotential."
msgstr ""

#: ../../source/topics/data_types.rst:765
msgid "The pseudopotential file."
msgstr ""

#: ../../source/topics/data_types.rst:767
msgid ":ref:`KpointsData <topics:data_types:materials:kpoints>`"
msgstr ""

#: ../../source/topics/data_types.rst:767
msgid "``array.kpoints``"
msgstr ""

#: ../../source/topics/data_types.rst:767
msgid "(as mesh) The mesh and offset."
msgstr ""

#: ../../source/topics/data_types.rst:769
msgid "(as list) The \"kpoints\" array shape, labels and their indices."
msgstr ""

#: ../../source/topics/data_types.rst:771
msgid ":ref:`BandsData <topics:data_types:materials:bands>`"
msgstr ""

#: ../../source/topics/data_types.rst:771
msgid "``array.bands``"
msgstr ""

#: ../../source/topics/data_types.rst:771
msgid ""
"The units, labels and their numbers, and shape of the bands and kpoints "
"arrays."
msgstr ""

#: ../../source/topics/data_types.rst:777
msgid "StructureData"
msgstr "结构数据（StructureData）"

#: ../../source/topics/data_types.rst:779
msgid ""
"The :py:class:`~aiida.orm.nodes.data.structure.StructureData` data type "
"represents a structure, i.e. a collection of sites defined in a cell. The "
"boundary conditions are periodic by default, but can be set to non-periodic "
"in any direction."
msgstr ""

#: ../../source/topics/data_types.rst:782
msgid ""
"As an example, say you want to create a "
":py:class:`~aiida.orm.nodes.data.structure.StructureData` instance for bcc "
"Li. Let's begin with creating the instance by defining its unit cell:"
msgstr ""

#: ../../source/topics/data_types.rst:795
msgid ""
"Default units for crystal structure cell and atomic coordinates in AiiDA are"
" Å (Ångström)."
msgstr ""

#: ../../source/topics/data_types.rst:797
msgid ""
"Next, you can add the Li atoms to the structure using the "
":py:class:`~aiida.orm.nodes.data.structure.StructureData.append_atom()` "
"method:"
msgstr ""

#: ../../source/topics/data_types.rst:805
msgid ""
"You can check if the cell and sites have been set up properly by checking "
"the ``cell`` and ``sites`` properties:"
msgstr ""

#: ../../source/topics/data_types.rst:815
msgid ""
"From the :py:class:`~aiida.orm.nodes.data.structure.StructureData` node you "
"can also obtain the formats of well-known materials science Python libraries"
" such as `the Atomic Simulation Environment "
"<https://wiki.fysik.dtu.dk/ase/index.html>`_ (ASE) and `pymatgen "
"<https://pymatgen.org/index.html>`_:"
msgstr ""

#: ../../source/topics/data_types.rst:835
msgid ""
":ref:`topics:data_types:core:jsonable`, which can store any other Pymatgen "
"class."
msgstr ""

#: ../../source/topics/data_types.rst:0 ../../source/topics/data_types.rst:838
#: ../../source/topics/data_types.rst:873
msgid "Exporting"
msgstr ""

#: ../../source/topics/data_types.rst:840
msgid ""
"The following export formats are available for "
":py:class:`~aiida.orm.nodes.data.structure.StructureData`:"
msgstr ""

#: ../../source/topics/data_types.rst:842
#: ../../source/topics/data_types.rst:879
msgid ""
"``xsf`` (format supported by e.g. XCrySDen and other visualization software;"
" supports periodic cells)"
msgstr "``xsf`` （被诸如XCrySDen等可视化软件支持的文件格式，支持周期性晶胞）"

#: ../../source/topics/data_types.rst:843
msgid ""
"``xyz`` (classical xyz format, does not typically support periodic cells "
"(even if the cell is indicated in the comment line)"
msgstr "``xyz`` （经典的xyz格式，通常不支持周期性晶胞（即使在命令行中已指定了周期性））"

#: ../../source/topics/data_types.rst:844
msgid ""
"``cif`` (export to CIF format, without symmetry reduction, i.e. always "
"storing the structure as P1 symmetry)"
msgstr "``cif`` （导出为CIF文件格式，不会损失对称性，即通常把结构以P1空间群来保存）"

#: ../../source/topics/data_types.rst:846
msgid "The node can be exported using the verdi CLI, for example:"
msgstr ""

#: ../../source/topics/data_types.rst:852
msgid ""
"Where ``<IDENTIFIER>`` is one of the possible identifiers of the node, e.g. "
"its PK or UUID. This outputs the structure in ``xsf`` format and writes it "
"to a file."
msgstr ""

#: ../../source/topics/data_types.rst:858
msgid "TrajectoryData"
msgstr "构象数据（TrajectoryData）"

#: ../../source/topics/data_types.rst:860
msgid ""
"The :py:class:`~aiida.orm.nodes.data.array.trajectory.TrajectoryData` data "
"type represents a sequences of StructureData objects, where the number of "
"atomic kinds and sites does not change over time. Beside the coordinates, it"
" can also optionally store velocities. If you have a list of "
":py:class:`~aiida.orm.nodes.data.structure.StructureData` instances called "
"``structure_list`` that represent the trajectory of your system, you can "
"create a :py:class:`~aiida.orm.nodes.data.array.trajectory.TrajectoryData` "
"instance from this list:"
msgstr ""

#: ../../source/topics/data_types.rst:870
msgid ""
"Note that contrary with the "
":py:class:`~aiida.orm.nodes.data.structure.StructureData` data type, the "
"cell and atomic positions are stored a ``numpy`` array in the repository and"
" not in the database."
msgstr ""

#: ../../source/topics/data_types.rst:875
msgid ""
"You can export the "
"py:class:`~aiida.orm.nodes.data.array.trajectory.TrajectoryData` node with "
"``verdi data core.trajectory export``, which accepts a number of formats "
"including ``xsf`` and  ``cif``, and additional parameters like ``--step "
"NUM`` (to choose to export only a given trajectory step)."
msgstr ""

#: ../../source/topics/data_types.rst:877
#: ../../source/topics/data_types.rst:1135
msgid "The following export formats are available:"
msgstr "有以下可用导出文件类型:"

#: ../../source/topics/data_types.rst:881
msgid ""
"``cif`` (export to CIF format, without symmetry reduction, i.e. always "
"storing the structures as P1 symmetry)"
msgstr "``cif`` （导出为CIF文件格式，不会推倒还原对称性，即通常把结构以P1空间群来保存）"

#: ../../source/topics/data_types.rst:884
#: ../../source/topics/data_types.rst:1177 ../../source/topics/database.rst:7
msgid "Todo"
msgstr "Todo"

#: ../../source/topics/data_types.rst:886
msgid "Think of more example use cases, see `#4529`_."
msgstr ""

#: ../../source/topics/data_types.rst:893
msgid "UpfData"
msgstr "UpfData"

#: ../../source/topics/data_types.rst:895
msgid ""
"The :py:class:`~aiida.orm.nodes.data.upf.UpfData` data type represents a "
"pseudopotential in the .UPF format (e.g. used by `Quantum ESPRESSO`_ - see "
"also the `AiiDA Quantum ESPRESSO plugin`_). Usually these will be installed "
"as part of a pseudopotential family, for example via the `aiida-pseudo "
"<https://github.com/aiidateam/aiida-pseudo>`_ package."
msgstr ""

#: ../../source/topics/data_types.rst:898
msgid ""
"To see the pseudopotential families that have been installed in your AiiDA "
"profile, you can use the verdi CLI:"
msgstr ""

#: ../../source/topics/data_types.rst:912
msgid "KpointsData"
msgstr "KpointsData"

#: ../../source/topics/data_types.rst:914
msgid ""
"The :py:class:`~aiida.orm.nodes.data.array.kpoints.KpointsData` data type "
"represents either a grid of k-points (in reciprocal space, for crystal "
"structures), or explicit list of k-points (optionally with a weight "
"associated to each one)."
msgstr ""

#: ../../source/topics/data_types.rst:916
msgid ""
"To create a :py:class:`~aiida.orm.nodes.data.array.kpoints.KpointsData` "
"instance that describes a regular (2 x 2 x 2) mesh of k-points, execute the "
"following set of commands in the ``verdi shell``:"
msgstr ""

#: ../../source/topics/data_types.rst:924
msgid ""
"This will create a (2 x 2 x 2) mesh centered at the Gamma point (i.e. "
"without offset)."
msgstr ""

#: ../../source/topics/data_types.rst:926
msgid ""
"Alternatively, you can also define a "
":py:class:`~aiida.orm.nodes.data.array.kpoints.KpointsData` node from a list"
" of k-points using the "
":py:meth:`~aiida.orm.nodes.data.array.kpoints.KpointsData.set_kpoints()` "
"method:"
msgstr ""

#: ../../source/topics/data_types.rst:933
msgid ""
"In this case, you can also associate labels to (some of the) points, which "
"is very useful for generating plots of the band structure (and storing them "
"in a :py:class:`~aiida.orm.nodes.data.array.bands.BandsData` instance):"
msgstr ""

#: ../../source/topics/data_types.rst:945
msgid "Automatic computation of k-point paths"
msgstr "K-point路径的自动计算"

#: ../../source/topics/data_types.rst:947
msgid ""
"AiiDA provides a number of tools and wrappers to automatically compute "
"k-point paths given a cell or a crystal structure."
msgstr "AiiDA提供一系列工具和包装以自动完成对给定晶格或者晶体结构的k-point路径的计算。"

#: ../../source/topics/data_types.rst:949
msgid ""
"The main interface is provided by the two methods "
":py:func:`aiida.tools.data.array.kpoints.main.get_kpoints_path` and "
":py:func:`aiida.tools.data.array.kpoints.main.get_explicit_kpoints_path`."
msgstr ""

#: ../../source/topics/data_types.rst:951
msgid ""
"These methods are also conveniently exported directly as, e.g., "
"``aiida.tools.get_kpoints_path``."
msgstr "这些方法对我们来说也都可以很方便地访问，例如 ``aiida.tools.get_kpoints_path`` 。"

#: ../../source/topics/data_types.rst:953
msgid "The difference between the two methods is the following:"
msgstr "两种方法的不同之处在于:"

#: ../../source/topics/data_types.rst:955
msgid ""
":py:func:`~aiida.tools.data.array.kpoints.main.get_kpoints_path` returns a "
"dictionary of k-point coordinates (e.g. ``{'GAMMA': [0. ,0. ,0. ], 'X': "
"[0.5, 0., 0.], 'L': [0.5, 0.5, 0.5]}``, and then a list of tuples of "
"endpoints of each segment, e.g. ``[('GAMMA', 'X'), ('X', 'L'), ('L', "
"'GAMMA')]`` for the :math:`\\Gamma-X-L-\\Gamma` path."
msgstr ""

#: ../../source/topics/data_types.rst:956
msgid ""
":py:func:`~aiida.tools.data.array.kpoints.main.get_explicit_kpoints_path`, "
"instead, returns a list of kpoints that follow that path, with some "
"predefined (but user-customizable) distance between points, e.g. something "
"like ``[[0., 0., 0.], [0.05, 0., 0.], [0.1, 0., 0.], ...]``."
msgstr ""

#: ../../source/topics/data_types.rst:958
msgid ""
"Depending on how the underlying code works, one method might be preferred on"
" the other."
msgstr "方法各自的优势取决于以下的代码如何工作。"

#: ../../source/topics/data_types.rst:960
msgid ""
"The docstrings of the methods describe the expected parameters. The general "
"interface requires always a ``StructureData`` as the first parameter "
"``structure``, as well as a string for the method to use (by default this is"
" `seekpath <https://github.com/giovannipizzi/seekpath/>`_, but also the "
"``legacy`` method implemented in earlier versions of AiiDA is available; see"
" description below)."
msgstr ""

#: ../../source/topics/data_types.rst:963
msgid ""
"Additional parameters are passed as ``kwargs`` to the underlying "
"implementation, that often accepts a different number of parameters."
msgstr "附加参数在下文中以 ``kwargs`` 形式传入，通常接受不同数目的参数。"

#: ../../source/topics/data_types.rst:968
msgid "Seekpath implementation"
msgstr "Seekpath实现"

#: ../../source/topics/data_types.rst:970
msgid ""
"When specifying ``method='seekpath'``, the `seekpath "
"<https://github.com/giovannipizzi/seekpath/>`_ library is used to generate "
"the path. Note that this requires  ``seekpath`` to be installed (this is not"
" available by default, in order to reduce the dependencies of AiiDA core, "
"but can be easily installed using ``pip install seekpath``)."
msgstr ""
"当指定 ``method='seekpath'`` ，  `seekpath "
"<https://github.com/giovannipizzi/seekpath/>`_ 库被用于生成路径。注意到这需要预先安装 "
"``seekpath`` （为了减少 AiiDA core 的依赖默认是不提供的，但可以通过 ``pip install seekpath`` "
"命令来快速安装）。"

#: ../../source/topics/data_types.rst:973
msgid ""
"For a full description of the accepted parameters, we refer to the docstring"
" of the underlying methods "
":py:func:`aiida.tools.data.array.kpoints.seekpath.get_explicit_kpoints_path`"
" and :py:func:`aiida.tools.data.array.kpoints.seekpath.get_kpoints_path`, "
"and for more general information to the `seekpath documentation "
"<https://seekpath.readthedocs.io/>`_."
msgstr ""
"对各个接受参数的详细解释，请参阅以下方法的文档字符串：:py:func:`aiida.tools.data.array.kpoints.seekpath.get_explicit_kpoints_path`"
" 和 :py:func:`aiida.tools.data.array.kpoints.seekpath.get_kpoints_path`, and "
"for more general information to the `seekpath documentation "
"<https://seekpath.readthedocs.io/>`_ 。"

#: ../../source/topics/data_types.rst:975
msgid ""
"If you use this implementation, please cite the `Hinuma paper "
"<https://doi.org/10.1016/j.commatsci.2016.10.015>`_::"
msgstr ""
"若你使用了这一实现，请引用  `Hinuma paper "
"<https://doi.org/10.1016/j.commatsci.2016.10.015>`_::"

#: ../../source/topics/data_types.rst:0
msgid "Legacy implementation"
msgstr "Legacy实现"

#: ../../source/topics/data_types.rst:984
msgid ""
"This refers to the implementation that has been available since the early "
"versions of AiiDA."
msgstr "这一实现从早期版本的AiiDA开始便被支持。"

#: ../../source/topics/data_types.rst:986
msgid ""
"In the 3D case (all three directions have periodic boundary conditions), "
"this implementation expects that the structure is already standardized "
"according to the Setyawan paper (see journal reference below). If this is "
"not the case, the kpoints and band structure returned will be incorrect. The"
" only case that is dealt correctly by the library is the case when axes are "
"swapped, where the library correctly takes this swapping/rotation into "
"account to assign kpoint labels and coordinates."
msgstr ""

#: ../../source/topics/data_types.rst:990
msgid ""
"We therefore suggest that you use the seekpath implementation, that is able "
"to automatically correctly identify the standardized crystal structure "
"(primitive and conventional) as described in the `Hinuma paper "
"<https://doi.org/10.1016/j.commatsci.2016.10.015>`_."
msgstr ""
"我们因此建议用户使用seekpath实现，因为此实现可以自动正确识别标准化的晶体结构（元胞或常规），正如 `Hinuma paper "
"<https://doi.org/10.1016/j.commatsci.2016.10.015>`_ 所描述的那样。"

#: ../../source/topics/data_types.rst:992
msgid ""
"For a full description of the accepted parameters, we refer to the docstring"
" of the underlying methods "
":py:func:`aiida.tools.data.array.kpoints.legacy.get_explicit_kpoints_path` "
"and :py:func:`aiida.tools.data.array.kpoints.legacy.get_kpoints_path`, and "
"for more general information to the `seekpath documentation "
"<https://seekpath.readthedocs.io/>`_."
msgstr ""
"对于接受参数的完整描述，请参阅以下方法的文档字符串： "
":py:func:`aiida.tools.data.array.kpoints.legacy.get_explicit_kpoints_path` 和"
" :py:func:`aiida.tools.data.array.kpoints.legacy.get_kpoints_path`, and for "
"more general information to the `seekpath documentation "
"<https://seekpath.readthedocs.io/>`_ 。"

#: ../../source/topics/data_types.rst:994
msgid ""
"If you use this implementation, please cite the correct reference from the "
"following ones:"
msgstr "若你使用此实现，请正确引用以下的参考文献: "

#: ../../source/topics/data_types.rst:996
msgid ""
"The 3D implementation is based on the `Setyawan paper "
"<https://doi.org/10.1016/j.commatsci.2010.05.010>`_::"
msgstr ""
"The 3D implementation is based on the `Setyawan paper "
"<https://doi.org/10.1016/j.commatsci.2010.05.010>`_::"

#: ../../source/topics/data_types.rst:1003
msgid ""
"The 2D implementation is based on the `Ramirez paper "
"<https://doi.org/10.1002/qua.560300306>`_::"
msgstr ""
"The 2D implementation is based on the `Ramirez paper "
"<https://doi.org/10.1002/qua.560300306>`_::"

#: ../../source/topics/data_types.rst:1013
msgid "BandsData"
msgstr "BandsData"

#: ../../source/topics/data_types.rst:1015
msgid ""
"The :py:class:`~aiida.orm.nodes.data.array.bands.BandsData` data type is "
"dedicated to store band structures of different types (electronic bands, "
"phonons, or any other band-structure-like quantity that is a function of the"
" k-points in the Brillouin zone). In this section we describe the usage of "
"the ``BandsData`` to store the  electronic band structure of silicon and "
"some logic behind its methods. The dropdown panels below explain some "
"expanded use cases on how to create a "
":py:class:`~aiida.orm.nodes.data.array.bands.BandsData` node and plot the "
"band structure."
msgstr ""

#: ../../source/topics/data_types.rst:0
msgid "Creating a ``BandsData`` instance manually"
msgstr ""

#: ../../source/topics/data_types.rst:1021
msgid ""
"To start working with the "
":py:class:`~aiida.orm.nodes.data.array.bands.BandsData` data type we should "
"import it using the ``DataFactory`` and create an object of type "
"``BandsData``:"
msgstr ""

#: ../../source/topics/data_types.rst:1029
msgid ""
"To import the bands we need to make sure to have two arrays: one containing "
"kpoints and another containing bands. The shape of the kpoints object should"
" be ``nkpoints * 3``, while the shape of the bands should be ``nkpoints * "
"nstates``. Let's assume the number of kpoints is 12, and the number of "
"states is 5. So the kpoints and the bands array will look as follows:"
msgstr ""

#: ../../source/topics/data_types.rst:1065
msgid ""
"To insert kpoints and bands in the ``bands_data`` object we should employ "
"``set_kpoints()`` and ``set_bands()`` methods:"
msgstr ""

#: ../../source/topics/data_types.rst:0
msgid "Plotting the band structure"
msgstr "绘制能带结构图"

#: ../../source/topics/data_types.rst:1074
msgid ""
"Next we want to visualize the band structure. Before doing so, one thing "
"that we may want to add is the array of kpoint labels:"
msgstr ""

#: ../../source/topics/data_types.rst:1087
msgid "The resulting band structure will look as follows"
msgstr "得到的能带结构如下所示"

#: ../../source/topics/data_types.rst:1093
msgid ""
"As with any AiiDA node, once the ``bands_data`` object is stored "
"(``bands_data.store()``) it won't accept any modifications."
msgstr ""

#: ../../source/topics/data_types.rst:1095
msgid ""
"You may notice that depending on how you assign the kpoints labels the "
"output of the ``show_mpl()`` method looks different. Please compare:"
msgstr ""

#: ../../source/topics/data_types.rst:1112
msgid ""
"In the first case two neighboring kpoints with ``X`` and ``Y`` labels will "
"look like ``X|Y``, while in the second case they will be separated by a "
"certain distance. The logic behind such a difference is the following. In "
"the first case the plotting method discovers the two neighboring kpoints and"
" assumes them to be a discontinuity point in the band structure (e.g. "
"Gamma-X|Y-U). In the second case the kpoints labelled ``X`` and ``Y`` are "
"not neighbors anymore, so they are plotted with a certain distance between "
"them. The intervals between the kpoints on the X axis are proportional to "
"the cartesian distance between them."
msgstr ""
"第一种情形下，两个相邻的被分别标记为 ``X`` 和 ``Y`` 的k点看起来如同 ``X|Y`` "
"；而第二种情形下，两者被分开到一定距离。这种距离的产生的原因如下。第一种情形下，绘图的方法发现了两个相邻的k点，并假设它们是能带结构中两个不连续的点（例如Gamma-X|Y-U）；第二种情形下，被标记为"
" ``X`` 和 ``Y`` 的k点不再相邻，因而可以一确定距离被绘制出来。X轴上k点的间隔与它们笛卡尔坐标间的距离是等比例的。"

#: ../../source/topics/data_types.rst:0
msgid "Dealing with spins"
msgstr "自旋的处理"

#: ../../source/topics/data_types.rst:1120
msgid ""
"The ``BandsData`` object can also deal with the results of spin-polarized "
"calculations. Two provide different bands for two different spins you should"
" just merge them in one array and import them again using the "
"``set_bands()`` method:"
msgstr ""

#: ../../source/topics/data_types.rst:1129
msgid ""
"Now the shape of the bands array becomes ``nspins * nkpoints * nstates``"
msgstr "现在能带数组的大小变为 ``nspins * nkpoints * nstates`` "

#: ../../source/topics/data_types.rst:1133
msgid ""
"The :py:class:`~aiida.orm.nodes.data.array.bands.BandsData` data type can be"
" exported with ``verdi data core.bands export``, which accepts a number of "
"formats including (see also below) and additional parameters like "
"``--prettify-format FORMATNAME``, see valid formats below, or ``--y-min-"
"lim``, ``--y-max-lim`` to specify the ``y``-axis limits."
msgstr ""

#: ../../source/topics/data_types.rst:1137
msgid "``agr``: export a Xmgrace .agr file with the band plot"
msgstr "``agr`` : 导出一个包含能带图的Xmgrace .agr文件"

#: ../../source/topics/data_types.rst:1138
msgid ""
"``agr_batch``: export a Xmgrace batch file together with an independent .dat"
" file"
msgstr "``agr_batch``: 导出一个Xmgrace批处理文件以及一个独立的 .dat 文件"

#: ../../source/topics/data_types.rst:1139
msgid ""
"``dat_blocks``: export a .dat file, where each line has a data point (xy) "
"and bands are separated in blocks with empty lines."
msgstr ""

#: ../../source/topics/data_types.rst:1140
msgid ""
"``dat_multicolumn``: export a .dat file, where each line has all the values "
"for a given x coordinate: ``x y1 y2 y3 y4 ...`` (``x`` being a linear "
"coordinate along the band path and ``yN`` being the band energies)."
msgstr ""

#: ../../source/topics/data_types.rst:1141
msgid "``gnuplot``: export a gnuplot file, together with a .dat file."
msgstr ""

#: ../../source/topics/data_types.rst:1142
msgid "``json``: export a json file with the bands divided into segments."
msgstr ""

#: ../../source/topics/data_types.rst:1143
msgid ""
"``mpl_singlefile``: export a python file that when executed shows a plot "
"using the ``matplotlib`` module. All data is included in the same python "
"file as a multiline string containing the data in json format."
msgstr ""
"``mpl_singlefile``: 导出一个python文件，执行后可由 ``matplotlib`` "
"模块显示图线。全部的数据都存储为json格式并以一个多行字符串的形式被包含在同一个python文件中。"

#: ../../source/topics/data_types.rst:1145
msgid ""
"``mpl_withjson``: As above, but the json data is stored separately in a "
"different file."
msgstr ""

#: ../../source/topics/data_types.rst:1146
msgid ""
"``mpl_pdf``: As above, but after creating the .py file it runs it to export "
"the band structure in a PDF file (vectorial). **NOTE**: it requires that you"
" have the python ``matplotlib`` module installed. If ``use_latex`` is true, "
"it requires that you have LaTeX installed on your system to typeset the "
"labels, as well as the ``dvipng`` binary."
msgstr ""
"``mpl_pdf``: 同上，但创建 .py 文件后将自动运行并将能带结构（以矢量图的形式）导出到一个 PDF 文件。**注意**：这需要你预先安装好"
" ``matplotlib`` 模块。若 ``use_latex`` 为真，则需要预先将 LaTeX 和 ``dvipng`` "
"二进制文件安装在系统中以排版其中的标签。"

#: ../../source/topics/data_types.rst:1149
msgid ""
"``mpl_png``: As above, but after creating the .py file it runs it to export "
"the band structure in a PDF file (vectorial). **NOTE**: this format has the "
"same dependencies as the ``mpl_pdf`` format above."
msgstr ""
"``mpl_png``: 同上，但在创建 .py 文件后将自动运行并将能带结构（以矢量图的形式）导出到一个 PDF 文件。**注意**：此格式与上述的 "
"``mpl_pdf`` 格式具有相同的依赖要求。"

#: ../../source/topics/data_types.rst:1152
msgid ""
"AiiDA provides a number of functions to \"prettify\" the labels of band "
"structures (if labels are present in the data node), i.e., replace ``GAMMA``"
" with :math:`\\Gamma` or ``K_1`` with :math:`K_{1}` for instance. This makes"
" sense for some output formats (e.g. Xmgrace, Gnuplot, matplotlib)."
msgstr ""
"AiiDA提供一系列函数用于“美化”标签和能带结构（如果标签在数据节点中出现），举例的话也就是说，可以将 ``GAMMA`` 替换为 "
":math:`\\Gamma` ，将 ``K_1`` 替换为 :math:`K_{1}` 。这对于一些文件输出格式生效（例如Xmgrace, "
"Gnuplot, matplotlib等）。"

#: ../../source/topics/data_types.rst:1155
msgid ""
"The prettifier functions are defined as methods of the "
":py:class:`~aiida.common.utils.Prettifier` class and can be obtained calling"
" "
":py:meth:`Prettifier.get_prettifiers()<aiida.common.utils.Prettifier.get_prettifiers>`."
msgstr ""

#: ../../source/topics/data_types.rst:1157
msgid "The prettifiers should be chosen depending on two aspects:"
msgstr "美化应依据两个方面选取："

#: ../../source/topics/data_types.rst:1159
msgid ""
"How the raw labels are stored in the database. Two types exist currently: "
"``seekpath``, as used in the ``seekpath`` module, where Greek letters are "
"written explicitly (e.g. ``GAMMA``) and underscores are used to indicate a "
"subscript (``K_1``); and the \"old\" ``simple`` format, where "
":math:`\\Gamma` is indicated with ``G`` and there is no underscore symbol)."
msgstr ""

#: ../../source/topics/data_types.rst:1162
msgid ""
"Depending on the output format: xmgrace has a specific syntax for Greek "
"letters and subscripts, matplotlib uses LaTeX syntax, etc."
msgstr ""

#: ../../source/topics/data_types.rst:1164
msgid ""
"Most export formats already decide which prettifier is best to use, but if "
"you need to change it, you can do it passing the ``prettify_format`` "
"parameter to the :py:meth:`~aiida.orm.nodes.data.data.Data.export()` method."
" Valid prettifiers include:"
msgstr ""
"大多数导出文件格式已预先确定最佳的美化方法，但若你需要将其修改，你可以向 "
":py:meth:`~aiida.orm.nodes.data.data.Data.export()` 方法传入 ``prettify_format``"
" 参数。有效的美化方法包括:"

#: ../../source/topics/data_types.rst:1169
msgid ""
"``agr_seekpath``: format for Xmgrace, using ``seekpath`` raw label syntax."
msgstr ""

#: ../../source/topics/data_types.rst:1170
msgid "``agr_simple``: format for Xmgrace, using ``simple`` raw label syntax."
msgstr ""

#: ../../source/topics/data_types.rst:1171
msgid ""
"``latex_simple``: format for LaTeX (including dollar signs), using "
"``seekpath`` raw label syntax."
msgstr ""

#: ../../source/topics/data_types.rst:1172
msgid ""
"``latex_seekpath``: format for LaTeX (including dollar signs), using "
"``simple`` raw label syntax."
msgstr ""

#: ../../source/topics/data_types.rst:1173
msgid ""
"``gnuplot_simple``: format for GNUPlot (Unicode for Greek letters, LaTeX "
"syntax `without` dollar signs for underscores), using ``seekpath`` raw label"
" syntax."
msgstr ""

#: ../../source/topics/data_types.rst:1174
msgid ""
"``gnuplot_seekpath``: format for GNUPlot (Unicode for Greek letters, LaTeX "
"syntax `without` dollar signs for underscores), using ``simple`` raw label "
"syntax."
msgstr ""

#: ../../source/topics/data_types.rst:1175
msgid ""
"``pass``: no-op prettifier: leaves all strings unchanged to their raw value."
msgstr ""

#: ../../source/topics/data_types.rst:1181
msgid "title: CifData"
msgstr ""

#: ../../source/topics/data_types.rst:1185
msgid "title: OrbitalData"
msgstr ""

#: ../../source/topics/data_types.rst:1189
msgid "title: ProjectionData"
msgstr ""

#: ../../source/topics/data_types.rst:1194
msgid "Exporting data nodes"
msgstr ""

#: ../../source/topics/data_types.rst:1196
msgid ""
"Next to the CLI commands described above, each data node has a "
":py:meth:`~aiida.orm.nodes.data.data.Data.export()` method that allows to "
"export the given data node to file in a variety of available formats, e.g. "
"to pass it to a visualization software."
msgstr ""

#: ../../source/topics/data_types.rst:1198
msgid ""
"The :py:meth:`~aiida.orm.nodes.data.data.Data.export()` method asks for a "
"filename, and it will write to file the result. It is possible that more "
"than one file is written (for example, if you produce a gnuplot script, the "
"data will typically be in a different .dat file). The return value of the "
"function is a list of files that have been created."
msgstr ""
":py:meth:`~aiida.orm.nodes.data.data.Data.export()` "
"方法需要一个文件名，并将结果写入该文件中。写入多于一个文件是可行的（例如若你需要生成gnuplot脚本，数据通常会导出为另一个不同的 .dat "
"文件）。函数的返回值是创建文件的列表。"

#: ../../source/topics/data_types.rst:1202
msgid ""
"The list of export formats depends on the specific Data plugin. The export "
"format is typically inferred from the file extension, but if this is not "
"possible (or you want to specify a given format), you can pass an additional"
" ``fileformat`` parameter to "
":py:meth:`~aiida.orm.nodes.data.data.Data.export()`. The list of all valid "
"export formats can be obtained calling ``Data.get_export_formats()`` method,"
" that returns a list of strings with all valid formats."
msgstr ""
"导出文件的列表取决于具体的数据插件。导出格式通常由文件扩展名推测，但若不可用（或你希望选定特定的文件格式），则你可向 "
":py:meth:`~aiida.orm.nodes.data.data.Data.export()` 传入一个附加的 ``fileformat`` "
"参数。全部有效的格式可通过调用 ``Data.get_export_formats()`` 获得，这将返回一个包含全部有效格式的字符串列表。"

#: ../../source/topics/data_types.rst:1206
msgid ""
"If you don't want to export directly to a file, but want to get simply the "
"content of the file as a string, then you can call the "
":py:meth:`~aiida.orm.nodes.data.data.Data._exportcontent()` method, passing "
"also a ``fileformat`` parameter. The return value is a tuple of length 2: "
"the first element is a string with the content of the \"main\" file, while "
"the second is a dictionary (possibly empty) with a list of additional files "
"that should be created/needed: the keys are filenames, and the values are "
"the files content."
msgstr ""
"若你不希望直接导出到文件，而是以字符串的形式得到文件内容，你可以调用 "
":py:meth:`~aiida.orm.nodes.data.data.Data._exportcontent()` 方法，同样需要传入 "
"``fileformat`` "
"参数。返回值会是一个长度为2的元组：第一个元素是一个包含“主要”文件内容的字符串，第二个元素则是一个包含应被创建的附加文件列表的字典（可能为空），其键是文件名，值是文件内容。"

#: ../../source/topics/data_types.rst:1212
msgid "Adding support for custom data types"
msgstr ""

#: ../../source/topics/data_types.rst:1214
msgid ""
"The nodes in the :ref:`provenance graph<topics:provenance>` that are the "
"inputs and outputs of processes are referred to as `data` and are "
"represented by :class:`~aiida.orm.nodes.data.data.Data` nodes. Since data "
"can come in all shapes and forms, the "
":class:`~aiida.orm.nodes.data.data.Data` class can be sub classed. AiiDA "
"ships with some basic data types such as the "
":class:`~aiida.orm.nodes.data.int.Int` which represents a simple integer and"
" the :class:`~aiida.orm.nodes.data.dict.Dict`, representing a dictionary of "
"key-value pairs. There are also more complex data types such as the "
":class:`~aiida.orm.nodes.data.array.array.ArrayData` which can store "
"multidimensional arrays of numbers. These basic data types serve most needs "
"for the majority of applications, but more specific solutions may be useful "
"or even necessary. In the next sections, we will explain :ref:`how a new "
"data type can be created<topics:data_types:plugin:create>` and what "
":ref:`guidelines<topics:data_types:plugin:design-guidelines>` should ideally"
" be observed during the design process."
msgstr ""

#: ../../source/topics/data_types.rst:1224
msgid "Creating a data plugin"
msgstr ""

#: ../../source/topics/data_types.rst:1226
msgid ""
"Creating a new data type is as simple as creating a new sub class of the "
"base :class:`~aiida.orm.nodes.data.data.Data` class."
msgstr ""

#: ../../source/topics/data_types.rst:1237
msgid ""
"To be able to use the new ``Data`` plugin, it must be registered using an "
"entry point. See :ref:`What is an entry point?<topics:plugins:entrypoints>` "
"for details."
msgstr ""

#: ../../source/topics/data_types.rst:1240
msgid ""
"At this point, our new data type does nothing special. Typically, one "
"creates a new data type to represent a specific type of data. For the "
"purposes of this example, let's assume that the goal of our ``NewData`` type"
" is to store a single numerical value. To allow one to construct a new "
"``NewData`` data node with the desired ``value``, for example:"
msgstr ""

#: ../../source/topics/data_types.rst:1249
msgid ""
"we need to allow passing that value to the constructor of the node class. "
"Therefore, we have to override the constructor "
":meth:`~aiida.orm.nodes.node.Node.__init__`:"
msgstr ""

#: ../../source/topics/data_types.rst:1266
msgid ""
"For the class to function properly, the signature of the constructor "
"**cannot be changed** and the constructor of the parent class **has to be "
"called**. Note also that the constructor is **NOT** called when the node is "
"loaded from the database afterwards. Hence, one should not rely on "
"initializing instance attributes inside the ``__init__`` itself (here "
"\"attributes\" does not refer to the data stored in the database, but the "
"normal Python understanding of attributes that class instances have)."
msgstr ""

#: ../../source/topics/data_types.rst:1270
msgid ""
"Before calling the constructor of the base class, we have to remove the "
"``value`` keyword from the keyword arguments ``kwargs``, because the base "
"class will not expect it and will raise an exception if left in the keyword "
"arguments. The final step is to actually *store* the value that is passed by"
" the caller of the constructor. A new node has two locations to permanently "
"store any of its properties:"
msgstr ""

#: ../../source/topics/data_types.rst:1274
msgid "the database"
msgstr ""

#: ../../source/topics/data_types.rst:1275
msgid "the file repository"
msgstr ""

#: ../../source/topics/data_types.rst:1277
msgid ""
"The section on :ref:`design guidelines<topics:data_types:plugin:design-"
"guidelines>` will go into more detail what the advantages and disadvantages "
"of each option are and when to use which. For now, since we are storing only"
" a single value, the easiest and best option is to use the database. Each "
"node has *attributes* that can store any key-value pair, as long as the "
"value is JSON serializable. By adding the value to the node's attributes, "
"they will be queryable in the database once an instance of the ``NewData`` "
"node is stored."
msgstr ""

#: ../../source/topics/data_types.rst:1288
msgid ""
"After storing the node instance in the database, its attributes are frozen, "
"and ``node.base.attributes.set('value', 7)`` will fail. By storing the "
"``value`` in the attributes of the node instance, we ensure that that "
"``value`` can be retrieved even when the node is reloaded at a later point "
"in time."
msgstr ""

#: ../../source/topics/data_types.rst:1291
msgid ""
"Besides making sure that the content of a data node is stored in the "
"database or file repository, the data type class can also provide useful "
"methods for users to retrieve that data. For example, with the current state"
" of the ``NewData`` class, in order to retrieve the ``value`` of a stored "
"``NewData`` node, one needs to do:"
msgstr ""

#: ../../source/topics/data_types.rst:1299
msgid ""
"In other words, the user of the ``NewData`` class needs to know that the "
"``value`` is stored as an attribute with the name 'value'. This is not easy "
"to remember and therefore not very user-friendly. Since the ``NewData`` type"
" is a class, we can give it useful methods. Let's introduce one that will "
"return the value that was stored for it:"
msgstr ""

#: ../../source/topics/data_types.rst:1318
msgid ""
"The addition of the instance property ``value`` makes retrieving the value "
"of a ``NewData`` node a lot easier:"
msgstr ""

#: ../../source/topics/data_types.rst:1325
msgid ""
"As said before, in addition to their attributes, data types can also store "
"their properties in the file repository. Here is an example for a custom "
"data type that needs to wrap a single text file:"
msgstr ""

#: ../../source/topics/data_types.rst:1356
msgid "To create a new instance of this data type and get its content:"
msgstr ""

#: ../../source/topics/data_types.rst:1363
msgid ""
"This example is a simplified version of the "
":class:`~aiida.orm.nodes.data.singlefile.SinglefileData` data class that "
"ships with ``aiida-core``. If this happens to be your use case (or very "
"close to it), it is of course better to use that class, or you can sub class"
" it and adapt it where needed."
msgstr ""

#: ../../source/topics/data_types.rst:1366
msgid ""
"The just presented examples for new data types are of course trivial, but "
"the concept is always the same and can easily be extended to more complex "
"custom data types. The following section will provide useful guidelines on "
"how to optimally design new data types."
msgstr ""

#: ../../source/topics/data_types.rst:1372
msgid "Database or repository?"
msgstr ""

#: ../../source/topics/data_types.rst:1374
msgid ""
"When deciding where to store a property of a data type, one has the option "
"to choose between the database and the file repository. All node properties "
"that are stored in the database (such as the attributes), are directly "
"searchable as part of a database query, whereas data stored in the file "
"repository cannot be queried for. What this means is that, for example, it "
"is possible to search for all nodes where a particular database-stored "
"integer attribute falls into a certain value range, but the same value "
"stored in a file within the file repository would not be directly searchable"
" in this way. However, storing large amounts of data within the database "
"comes at the cost of slowing down database queries. Therefore, big data "
"(think large files), whose content does not necessarily need to be queried "
"for, is better stored in the file repository. A data type may safely use "
"both the database and file repository in parallel for individual properties."
" Properties stored in the database are stored as *attributes* of the node. "
"The node class has various methods to set these attributes, such as "
":py:meth:`~aiida.orm.nodes.attributes.NodeAttributes.set` and "
":py:meth:`~aiida.orm.nodes.attributes.NodeAttributes.set_many`."
msgstr ""

#: ../../source/topics/database.rst:5
msgid "Database"
msgstr ""

#: ../../source/topics/database.rst:15
msgid "Advanced querying"
msgstr ""

#: ../../source/topics/database.rst:17
msgid ""
"The basics on using the :class:`~aiida.orm.querybuilder.QueryBuilder` to "
"find the data you are interested in is explained in the :ref:`finding and "
"querying how-to<how-to:query>`. This section explains some more advanced "
"methods for querying your database and the :ref:`QueryBuilder "
"dictionary<topics:database:advancedquery>`."
msgstr ""

#: ../../source/topics/database.rst:23
msgid "Working with edges"
msgstr "利用边"

#: ../../source/topics/database.rst:25
msgid ""
"Filters and projections can be applied to both the vertices of the query "
"path and the edges that connect them. Applying a filter or projection to an "
"edge works the same way as for vertices, but the relevant keyword is now "
"preceded by ``edge_``. Using the ``ArithmeticAddCalculation`` calculation "
"job as an example, let's say we want to query for the first input of the "
"addition, i.e. the ``Int`` nodes which have been provided as the input with "
"label ``x``:"
msgstr ""

#: ../../source/topics/database.rst:36
msgid ""
"By using the ``edge_filters`` keyword argument, we can query for only the "
"inputs that have the label ``x``. Note that any operator that can be used to"
" filter vertices can also be applied to edges. Say we want to find all input"
" ``Int`` nodes that are **not** connected to the ``CalcJobNode``'s via an "
"edge with label ``x``:"
msgstr ""

#: ../../source/topics/database.rst:46
msgid ""
"Here, the equality operator ``==`` is negated by prepending an exclamation "
"mark ``!``. See the :ref:`reference table "
"below<topics:database:advancedquery:tables:operators>` for a table with all "
"operators. Similar to filters, we can *project* information of the edge "
"using the ``edge_project`` keyword argument:"
msgstr ""

#: ../../source/topics/database.rst:56
msgid ""
"In the example above, we are querying for the edge labels of the incoming "
"``Int`` nodes of all ``CalcJobNode``'s."
msgstr ""

#: ../../source/topics/database.rst:61
msgid "Ordering and limiting results"
msgstr ""

#: ../../source/topics/database.rst:63
msgid ""
"You can order the results of your query by the properties of the entity. Say"
" you want to return the list of ``Int`` outputs from all ``CalcJobNode``'s, "
"sorted by the time they were created in *descending* order, i.e. the most "
"recent first:"
msgstr ""

#: ../../source/topics/database.rst:73
msgid ""
"This can also be used to order your results based on values in a (nested) "
"dictionary, such as the ``attributes`` column. However, as the "
":class:`~aiida.orm.querybuilder.QueryBuilder` cannot infer the type of the "
"value in this case, you have to *cast* the type:"
msgstr ""

#: ../../source/topics/database.rst:83
msgid ""
"The query above will return all ``Int`` nodes that are output of all "
"``CalcJobNode``'s, in *ascending* order of their value, i.e. from small to "
"big. Note that in this case you have to specify the order operation with a "
"dictionary, where the ``order`` key details how you want to order the query "
"results and the ``cast`` key informs the ``QueryBuilder`` of the attribute "
"type. A list of the available cast types and their aliases can be found in "
"the table below:"
msgstr ""

#: ../../source/topics/database.rst:90
msgid "**Python type**"
msgstr ""

#: ../../source/topics/database.rst:90
msgid "**Alias**"
msgstr ""

#: ../../source/topics/database.rst:90
msgid "**SQLAlchemy type**"
msgstr ""

#: ../../source/topics/database.rst:92
msgid "int"
msgstr ""

#: ../../source/topics/database.rst:92
msgid "i"
msgstr ""

#: ../../source/topics/database.rst:92
msgid "Integer"
msgstr ""

#: ../../source/topics/database.rst:94
msgid "float"
msgstr ""

#: ../../source/topics/database.rst:94
msgid "f"
msgstr ""

#: ../../source/topics/database.rst:94
msgid "Float"
msgstr ""

#: ../../source/topics/database.rst:96
msgid "bool"
msgstr "布尔值"

#: ../../source/topics/database.rst:96
msgid "b"
msgstr ""

#: ../../source/topics/database.rst:96
msgid "Boolean"
msgstr ""

#: ../../source/topics/database.rst:98
msgid "str"
msgstr ""

#: ../../source/topics/database.rst:98
msgid "t"
msgstr ""

#: ../../source/topics/database.rst:98
msgid "String"
msgstr ""

#: ../../source/topics/database.rst:100 ../../source/topics/database.rst:168
msgid "dict"
msgstr ""

#: ../../source/topics/database.rst:100
msgid "j"
msgstr ""

#: ../../source/topics/database.rst:100
msgid "JSONB"
msgstr ""

#: ../../source/topics/database.rst:102
msgid "datetime.datetime"
msgstr ""

#: ../../source/topics/database.rst:102
msgid "d"
msgstr ""

#: ../../source/topics/database.rst:102
msgid "DateTime"
msgstr ""

#: ../../source/topics/database.rst:105
msgid ""
"You can also order using multiple properties by providing a list of "
"dictionaries that each specify one sorting operation:"
msgstr ""

#: ../../source/topics/database.rst:114
msgid ""
"Here the ``Int`` nodes will first be sorted by their value in ascending "
"order. Nodes for which the value is equal are subsequently sorted by their "
"modification time in descending order."
msgstr ""

#: ../../source/topics/database.rst:117
msgid ""
"Finally, you can also limit the number of query results returned with the "
"``limit()`` method. Suppose you only want the first three results from our "
"query:"
msgstr ""

#: ../../source/topics/database.rst:126
msgid ""
"This can be easily combined with the ``order_by`` method in order to get the"
" last three ``CalcJobNode``'s that were created in the database:"
msgstr ""

#: ../../source/topics/database.rst:138
msgid "Reference tables"
msgstr ""

#: ../../source/topics/database.rst:142
msgid "List of all operators:"
msgstr ""

#: ../../source/topics/database.rst:145
msgid "**Operator**"
msgstr "**操作符**"

#: ../../source/topics/database.rst:145
msgid "**Datatype**"
msgstr "**适用数据类型**"

#: ../../source/topics/database.rst:145
msgid "**Example**"
msgstr "**用法举例**"

#: ../../source/topics/database.rst:145
msgid "Explanation"
msgstr "释义"

#: ../../source/topics/database.rst:147
msgid "``==``"
msgstr ""

#: ../../source/topics/database.rst:147 ../../source/topics/database.rst:149
msgid "all"
msgstr ""

#: ../../source/topics/database.rst:147
msgid "``'id': {'==': 123}``"
msgstr ""

#: ../../source/topics/database.rst:147
msgid "Filter for equality"
msgstr ""

#: ../../source/topics/database.rst:149
msgid "``in``"
msgstr ""

#: ../../source/topics/database.rst:149
msgid "``'name': {'in': ['foo', 'bar']}``"
msgstr ""

#: ../../source/topics/database.rst:149
msgid "Filter for values that are in the given list."
msgstr ""

#: ../../source/topics/database.rst:151
msgid "``>,<,<=,>=``"
msgstr ""

#: ../../source/topics/database.rst:151
msgid "float, integer, date"
msgstr ""

#: ../../source/topics/database.rst:151
msgid "``'ctime': {'<': datetime(2016, 03, 03)}``"
msgstr ""

#: ../../source/topics/database.rst:151
msgid "Filter for values that are greater or smaller than a certain value"
msgstr ""

#: ../../source/topics/database.rst:155
msgid "``like``"
msgstr ""

#: ../../source/topics/database.rst:155 ../../source/topics/database.rst:160
msgid "string"
msgstr "string"

#: ../../source/topics/database.rst:155
msgid "``'name': {'like': 'label%'}``"
msgstr ""

#: ../../source/topics/database.rst:155
msgid ""
"Filter for matching substrings where ``%`` and ``_`` are wildcards. To match"
" a literal ``%`` or ``_`` escape it by prefixing it with ``\\\\``."
msgstr ""

#: ../../source/topics/database.rst:160
msgid "``ilike``"
msgstr ""

#: ../../source/topics/database.rst:160
msgid "``'name': {'ilike': 'lAbEl%'}``"
msgstr ""

#: ../../source/topics/database.rst:160
msgid "Case insensitive version of ``like``."
msgstr ""

#: ../../source/topics/database.rst:162
msgid "``or``"
msgstr ""

#: ../../source/topics/database.rst:162 ../../source/topics/database.rst:165
msgid "list of expressions"
msgstr "条件列表"

#: ../../source/topics/database.rst:162
msgid "``'id': {'or': [{'<': 12}, {'==': 199}]}``"
msgstr ""

#: ../../source/topics/database.rst:162
msgid "A list of expressions where at least one should be matched."
msgstr ""

#: ../../source/topics/database.rst:165
msgid "``and``"
msgstr ""

#: ../../source/topics/database.rst:165
msgid "``'id': {'and': [{'<': 12}, {'>': 1}]}``"
msgstr ""

#: ../../source/topics/database.rst:165
msgid "A list of expressions where all should be matched."
msgstr ""

#: ../../source/topics/database.rst:168
msgid "``has_key``"
msgstr ""

#: ../../source/topics/database.rst:168
msgid "``'attributes': {'has_key': 'some_key'}``"
msgstr ""

#: ../../source/topics/database.rst:168
msgid "Filter for dictionaries that contain a certain key."
msgstr ""

#: ../../source/topics/database.rst:170
msgid "``of_type``"
msgstr ""

#: ../../source/topics/database.rst:170
msgid "any"
msgstr "任意"

#: ../../source/topics/database.rst:170
msgid "``'attributes.some_key': {'of_type': 'bool'}``"
msgstr ""

#: ../../source/topics/database.rst:170
msgid "Filter for values of a certain type."
msgstr ""

#: ../../source/topics/database.rst:172
msgid "``of_length``"
msgstr ""

#: ../../source/topics/database.rst:172 ../../source/topics/database.rst:174
#: ../../source/topics/database.rst:176 ../../source/topics/database.rst:178
msgid "lists"
msgstr "列表"

#: ../../source/topics/database.rst:172
msgid "``'attributes.some_list': {'of_length': 4}``"
msgstr ""

#: ../../source/topics/database.rst:172
msgid "Filter for lists of a certain length."
msgstr ""

#: ../../source/topics/database.rst:174
msgid "``shorter``"
msgstr ""

#: ../../source/topics/database.rst:174
msgid "``'attributes.some_list': {'shorter': 4}``"
msgstr ""

#: ../../source/topics/database.rst:174
msgid "Filter for lists that are shorter than a certain length."
msgstr ""

#: ../../source/topics/database.rst:176
msgid "``longer``"
msgstr ""

#: ../../source/topics/database.rst:176
msgid "``'attributes.some_list': {'longer': 4}``"
msgstr ""

#: ../../source/topics/database.rst:176
msgid "Filter for lists that are longer than a certain length."
msgstr ""

#: ../../source/topics/database.rst:178
msgid "``contains``"
msgstr ""

#: ../../source/topics/database.rst:178
msgid "``'attributes.some_key': {'contains': ['a', 'b']}``"
msgstr ""

#: ../../source/topics/database.rst:178
msgid "Filter for lists that should contain certain values."
msgstr ""

#: ../../source/topics/database.rst:181
msgid ""
"As mentioned in the :ref:`section about operatior negations<how-"
"to:query:filters:operator-negations>` all operators can be turned into their"
" associated negation (``NOT`` operator) by adding a ``!`` in front of the "
"operator."
msgstr ""

#: ../../source/topics/database.rst:184
msgid ""
"The form of (negation) operators in the rendered SQL may differ from the "
"ones specified in the ``QueryBuilder`` instance. For example, the ``!==`` "
"operator of the ``QueryBuilder`` will be rendered to ``!=`` in SQL."
msgstr ""

#: ../../source/topics/database.rst:190
msgid "List of all relationships:"
msgstr ""

#: ../../source/topics/database.rst:193
msgid "**Entity from**"
msgstr "**实体来源**"

#: ../../source/topics/database.rst:193
msgid "**Entity to**"
msgstr "**实体去向**"

#: ../../source/topics/database.rst:193
msgid "**Relationship**"
msgstr "**关系**"

#: ../../source/topics/database.rst:193
msgid "**Explanation**"
msgstr "**释义**"

#: ../../source/topics/database.rst:195 ../../source/topics/database.rst:197
#: ../../source/topics/database.rst:199 ../../source/topics/database.rst:201
#: ../../source/topics/database.rst:203 ../../source/topics/database.rst:205
#: ../../source/topics/database.rst:207 ../../source/topics/database.rst:209
#: ../../source/topics/database.rst:211 ../../source/topics/database.rst:213
#: ../../source/topics/database.rst:219 ../../source/topics/database.rst:224
msgid "Node"
msgstr "Node"

#: ../../source/topics/database.rst:195
msgid "*with_outgoing*"
msgstr "*with_outgoing*"

#: ../../source/topics/database.rst:195
msgid "One node as input of another node"
msgstr "一个节点作为另一个节点的输入"

#: ../../source/topics/database.rst:197
msgid "*with_incoming*"
msgstr "*with_incoming*"

#: ../../source/topics/database.rst:197
msgid "One node as output of another node"
msgstr "一个节点作为另一个节点的输出"

#: ../../source/topics/database.rst:199
msgid "*with_descendants*"
msgstr "*with_descendants*"

#: ../../source/topics/database.rst:199
msgid "One node as the ancestor of another node (Path)"
msgstr "一个节点作为另一个节点的始祖（Path）"

#: ../../source/topics/database.rst:201
msgid "*with_ancestors*"
msgstr "*with_ancestors*"

#: ../../source/topics/database.rst:201
msgid "One node as descendant of another node (Path)"
msgstr "一个节点作为另一个节点的后代（Path）"

#: ../../source/topics/database.rst:203 ../../source/topics/database.rst:205
#: ../../source/topics/database.rst:215 ../../source/topics/database.rst:217
msgid "Group"
msgstr "Group"

#: ../../source/topics/database.rst:203 ../../source/topics/database.rst:207
#: ../../source/topics/database.rst:211 ../../source/topics/database.rst:219
msgid "*with_node*"
msgstr "*with_node*"

#: ../../source/topics/database.rst:203
msgid "The group of a node"
msgstr "节点所在的组"

#: ../../source/topics/database.rst:205 ../../source/topics/database.rst:217
msgid "*with_group*"
msgstr "*with_group*"

#: ../../source/topics/database.rst:205
msgid "The node is a member of a group"
msgstr "组的成员节点"

#: ../../source/topics/database.rst:207 ../../source/topics/database.rst:209
msgid "Computer"
msgstr "Computer"

#: ../../source/topics/database.rst:207
msgid "The computer of a node"
msgstr "节点对应的计算机器"

#: ../../source/topics/database.rst:209
msgid "*with_computer*"
msgstr "*with_computer*"

#: ../../source/topics/database.rst:209
msgid "The node of a computer"
msgstr "计算机器包含的节点"

#: ../../source/topics/database.rst:211 ../../source/topics/database.rst:213
#: ../../source/topics/database.rst:215 ../../source/topics/database.rst:217
#: ../../source/topics/database.rst:226 ../../source/topics/database.rst:228
msgid "User"
msgstr "User"

#: ../../source/topics/database.rst:211
msgid "The creator of a node is a user"
msgstr "节点的创建用户"

#: ../../source/topics/database.rst:213 ../../source/topics/database.rst:215
#: ../../source/topics/database.rst:226
msgid "*with_user*"
msgstr "*with_user*"

#: ../../source/topics/database.rst:213 ../../source/topics/database.rst:215
#: ../../source/topics/database.rst:217
msgid "The node was created by a user"
msgstr "由用户创建的节点"

#: ../../source/topics/database.rst:219
msgid "Log"
msgstr "Log"

#: ../../source/topics/database.rst:219
msgid "The log of a node"
msgstr "节点的日志"

#: ../../source/topics/database.rst:221
msgid "Log Node"
msgstr "Log Node"

#: ../../source/topics/database.rst:221
msgid "Node Comment"
msgstr "Node Comment"

#: ../../source/topics/database.rst:221
msgid "*with_log* *with_node*"
msgstr "*with_log* *with_node*"

#: ../../source/topics/database.rst:221
msgid "The node has a log The comment of a node"
msgstr "包含日志的节点 节点的注释"

#: ../../source/topics/database.rst:224 ../../source/topics/database.rst:226
#: ../../source/topics/database.rst:228
msgid "Comment"
msgstr "Comment"

#: ../../source/topics/database.rst:224 ../../source/topics/database.rst:228
msgid "*with_comment*"
msgstr "*with_comment*"

#: ../../source/topics/database.rst:224
msgid "The node has a comment"
msgstr "包含注释的节点"

#: ../../source/topics/database.rst:226
msgid "The comment was created by a user"
msgstr "用户创建的注释"

#: ../../source/topics/database.rst:228
msgid "The creator of a comment is a user"
msgstr "创建注释的用户"

#: ../../source/topics/database.rst:235
msgid "Converting the QueryBuilder to/from a dictionary"
msgstr ""

#: ../../source/topics/database.rst:239
msgid ""
"In aiida-core version 1, this dictionary was accessed with "
"``QueryBuilder.queryhelp``, which is now deprecated."
msgstr ""

#: ../../source/topics/database.rst:241
msgid ""
"The :class:`~aiida.orm.querybuilder.QueryBuilder` class can be converted to "
"a dictionary and also loaded from a dictionary, for easy serialisation and "
"storage. Once you have built your query using the appender method explained "
"in the :ref:`finding and querying for data how-to<how-to:query>` and the "
"advanced sections above, you can easily store your query by saving the "
"``QueryBuilder.as_dict()`` dictionary as a JSON file for later use:"
msgstr ""

#: ../../source/topics/database.rst:255
msgid ""
"To use this dictionary to instantiate the "
":class:`~aiida.orm.querybuilder.QueryBuilder`, you can use the ``from_dict``"
" class method:"
msgstr ""

#: ../../source/topics/database.rst:264
msgid ""
"Alternatively, you can also use a dictionary to set up your query by "
"specifying the path, filters and projections and constructing the dictionary"
" by hand. To do this, you have to specify:"
msgstr ""

#: ../../source/topics/database.rst:267
msgid ""
"the ``path``: Here, the user specifies the path along which to join tables "
"as a list of dictionaries, where each list item identifies a vertex in your "
"path. You define the vertex class with the ``cls`` key::"
msgstr ""

#: ../../source/topics/database.rst:277
msgid ""
"Each entity in the query has to have a unique tag. If the tag is not "
"provided, it is set to the name of the class. However, this will not work if"
" you choose the same class twice in the query. In this case you have to "
"provide the tag using the ``tag`` key::"
msgstr ""

#: ../../source/topics/database.rst:295
msgid ""
"You also have to detail some information on the vertex edges, in order to "
"connect them correctly. There are several redundant ways this can be done:"
msgstr ""

#: ../../source/topics/database.rst:298
msgid ""
"You can specify that this node is an input or output of another node "
"preceding the current one in the list. That other node can be specified by "
"an integer or the class or type. The following examples are all valid "
"joining instructions, assuming there is a structure defined at index 2 of "
"the path with tag \"struc1\"::"
msgstr ""
"你可以在列表中的当前节点前指定该节点作为另一个节点的输入或输出，被指定的节点可由一个整数或其类、类型来确定。以下的例子均为成功的连接操作，假设存在一个结构被定义为标记为“struc1”的结构的索引2"
" ::"

#: ../../source/topics/database.rst:310
msgid "``query_dict['path'][<i>]['direction'] = integer``"
msgstr ""

#: ../../source/topics/database.rst:312
msgid ""
"If any of the above specs (\"with_outgoing\", \"with_incoming\") were not "
"specified, the key \"direction\" is looked for. Directions are defined as "
"distances in the tree. 1 is defined as one step down the tree along a link. "
"This means that 1 joins the node specified in this dictionary to the node "
"specified on list-item before **as an output**. Direction defaults to 1, "
"which is why, if nothing is specified, this node is joined to the previous "
"one as an output by default. A negative number reverse the direction of the "
"link. The absolute value of the direction defines the table to join to with "
"respect to your own position in the list. An absolute value of 1 joins one "
"table above, a value of 2 to the table defined 2 indices above. The two "
"following dictionaries yield the same query::"
msgstr ""

#: ../../source/topics/database.rst:367
msgid "what to ``project``: Determining which columns the query will return::"
msgstr ""

#: ../../source/topics/database.rst:376
msgid ""
"If you are using JSONB columns, you can also project a value stored inside "
"the json::"
msgstr "若你在使用JSONB列表，你也可以将存储在json中的数据映射::"

#: ../../source/topics/database.rst:388
msgid ""
"Returns the state and the id of all instances of ``PwCalculation`` where a "
"structures is linked as output of a relax-calculation. The strings that you "
"pass have to be name of the columns. If you pass an asterisk ('*'), the "
"query will return the instance of the AiidaClass."
msgstr ""

#: ../../source/topics/database.rst:392
msgid ""
"the ``filters``: Filters enable you to further specify the query. This is an"
" example for a query for structures that were added after a certain time "
"(say last 4 days) and have an id larger than 50::"
msgstr ""

#: ../../source/topics/database.rst:412
msgid ""
"If you want to include filters and projections on links between nodes, you "
"will have to add these to filters and projections in the query dictionary. "
"Let's take an example from before and add a few filters on the link::"
msgstr ""

#: ../../source/topics/database.rst:435
msgid ""
"Notice that the tag for the link, by default, is the tag of the two "
"connecting nodes delimited by two dashes '--' and the order DOES matter."
msgstr ""

#: ../../source/topics/database.rst:437
msgid ""
"Alternatively, you can choose the tag for the edge in the path when defining"
" the entity to join using ``edge_tag``::"
msgstr ""

#: ../../source/topics/database.rst:463
msgid "Limits and offset can be set directly like this::"
msgstr ""

#: ../../source/topics/database.rst:471
msgid ""
"That ``query_dict`` would tell the QueryBuilder to return 10 rows after the "
"first 20 have been skipped."
msgstr ""

#: ../../source/topics/index.rst:3
msgid "Topics"
msgstr "相关主题"

#: ../../source/topics/performance.rst:5
msgid "Performance"
msgstr ""

#: ../../source/topics/performance.rst:7
msgid "The performance of AiiDA depends on many factors:"
msgstr ""

#: ../../source/topics/performance.rst:9
msgid "the hardware that AiiDA is running on"
msgstr ""

#: ../../source/topics/performance.rst:10
msgid ""
"how the services for AiiDA are configured (the database, message broker, "
"filesystem, etc.)"
msgstr ""

#: ../../source/topics/performance.rst:11
msgid "the codes and their plugins that are being run."
msgstr ""

#: ../../source/topics/performance.rst:13
msgid ""
"This section gives an overview of how each of these factors influence the "
"overall performance of AiiDA and how it can be optimized."
msgstr ""

#: ../../source/topics/performance.rst:19
msgid "Hardware"
msgstr ""

#: ../../source/topics/performance.rst:21
msgid ""
"The bulk of AiiDA's workload is typically carried by the daemon and its "
"workers. The performance is typically limited by the computing power of the "
"machine on which AiiDA is running."
msgstr ""

#: ../../source/topics/performance.rst:24
msgid ""
"Each worker is a separate Python process that takes care of executing the "
"AiiDA processes that are submitted. AiiDA was designed to allow to increase "
"the throughput by adding more daemon workers that can work independently in "
"parallel. A rule of thumb is to not have more workers than the number of "
"cores of the machine's CPU on which AiiDA is running. If more workers are "
"added, they will have to start sharing and swapping resources and the "
"performance scaling will degrade."
msgstr ""

#: ../../source/topics/performance.rst:33
msgid "Services"
msgstr ""

#: ../../source/topics/performance.rst:35
msgid ""
"For the default setup, AiiDA essentially has three services that influence "
"its performance:"
msgstr ""

#: ../../source/topics/performance.rst:37
msgid "PostgreSQL (the database in which the provenance graph is stored)"
msgstr ""

#: ../../source/topics/performance.rst:38
msgid ""
"RabbitMQ (the message broker that the daemon workers use to communicate)"
msgstr ""

#: ../../source/topics/performance.rst:39
msgid ""
"Filesystem (files are stored by AiiDA in the file repository on a filesytem)"
msgstr ""

#: ../../source/topics/performance.rst:41
msgid ""
"For the simplest installations, the PostgreSQL and RabbitMQ services are "
"typically running on the same machine as AiiDA itself. Although this means "
"that a part of the machine's resources is not available for AiiDA itself and"
" its daemon, the latency for AiiDA to communicate with the services is "
"minimal."
msgstr ""

#: ../../source/topics/performance.rst:44
msgid ""
"It is possible to configure an AiiDA profile to use services that are "
"running on a different machine and can be reached over a network. However, "
"this will typically affect the performance negatively as now each time a "
"connection needs to be made to a service, the latency of the network is "
"incurred."
msgstr ""

#: ../../source/topics/performance.rst:51
msgid "Benchmarks"
msgstr ""

#: ../../source/topics/performance.rst:53
msgid ""
"The :download:`benchmark script "
"<../howto/include/scripts/performance_benchmark_base.py>` :fa:`download` "
"provides a basic way of assessing performance of the workflow engine that "
"involves all components (CPU, file system, postgresql, rabbitmq)."
msgstr ""

#: ../../source/topics/performance.rst:55
msgid ""
"It launches ``ArithmeticAddCalculation``s on the localhost and measures the "
"time until completion. Since the workload of the "
"``ArithmeticAddCalculation`` (summing two numbers) completes instantly, the "
"time per process is a reasonable measure of the overhead incurred from the "
"workflow engine."
msgstr ""

#: ../../source/topics/performance.rst:58
msgid ""
"The numbers reported in the :ref:`howto section<how-"
"to:installation:performance>` were obtained by running the processes in the "
"current shell, which is the default. The ``--daemon`` option can be used to "
"run the calculations through the AiiDA daemon instead, and to look at "
"parallelizing over multiple daemon workers:"
msgstr ""

#: ../../source/topics/performance.rst:65
msgid "# Workers"
msgstr ""

#: ../../source/topics/performance.rst:65
msgid "Total elapsed time (s)"
msgstr ""

#: ../../source/topics/performance.rst:65
msgid "Performance (s/process)"
msgstr ""

#: ../../source/topics/performance.rst:67
msgid "1"
msgstr ""

#: ../../source/topics/performance.rst:67
msgid "46.55"
msgstr ""

#: ../../source/topics/performance.rst:67
msgid "0.47"
msgstr ""

#: ../../source/topics/performance.rst:68
msgid "2"
msgstr ""

#: ../../source/topics/performance.rst:68
msgid "27.83"
msgstr ""

#: ../../source/topics/performance.rst:68
msgid "0.28"
msgstr ""

#: ../../source/topics/performance.rst:69
msgid "4"
msgstr ""

#: ../../source/topics/performance.rst:69
msgid "16.43"
msgstr ""

#: ../../source/topics/performance.rst:69
msgid "0.16"
msgstr ""

#: ../../source/topics/performance.rst:74
msgid ""
"While the process rate increases with the number of daemon workers, the "
"scaling is not quite linear. This is because, for simplicity, the benchmark "
"script measures both the time required to submit the processes to the daemon"
" (not parallelized) as well as the time needed to run the processes "
"(parallelized over daemon workers). In long-running processes, the time "
"required to submit the process (roughly 0.1 seconds per process) is not "
"relevant and linear scaling is achieved."
msgstr ""

#: ../../source/topics/performance.rst:82 ../../source/topics/plugins.rst:5
msgid "Plugins"
msgstr ""

#: ../../source/topics/performance.rst:84
msgid ""
"One of AiiDA's strengths is its plugin system, which allows it capabilities "
"to be customized in a variety of ways. However, this flexibility also means "
"that the performance of AiiDA can be affected significantly by the "
"implementation of the plugins. For example, a `CalcJob` plugin determines "
"which files are transferred from and to the computing resources. If the "
"plugin needs to transfer and store large amounts of data, this will affect "
"the process throughput of the daemon workers. Likewise, if a `Parser` plugin"
" performs heavy numerical computations to parse the retrieved data, this "
"will slow down the workers' throughput. In order to optimize the process "
"throughput, plugins should try to minize heavy computations and the transfer"
" of lots of unnecessary data."
msgstr ""

#: ../../source/topics/plugins.rst:10
msgid "What a plugin can do"
msgstr ""

#: ../../source/topics/plugins.rst:12
msgid ""
"Add a new class to AiiDA's :ref:`entry point groups "
"<topics:plugins:entrypointgroups>`, including:: calculations, parsers, "
"workflows, data types, verdi commands, schedulers, transports and "
"importers/exporters from external databases. This typically involves "
"subclassing the respective base class AiiDA provides for that purpose."
msgstr ""

#: ../../source/topics/plugins.rst:14
msgid "Install new commandline and/or GUI executables"
msgstr ""

#: ../../source/topics/plugins.rst:15
msgid ""
"Depend on, and build on top of any number of other plugins (as long as their"
" requirements do not clash)"
msgstr ""

#: ../../source/topics/plugins.rst:21
msgid "What a plugin should not do"
msgstr ""

#: ../../source/topics/plugins.rst:23
msgid "An AiiDA plugin should not:"
msgstr ""

#: ../../source/topics/plugins.rst:25
msgid "Change the database schema AiiDA uses"
msgstr ""

#: ../../source/topics/plugins.rst:26
msgid ""
"Use protected functions, methods or classes of AiiDA (those starting with an"
" underscore ``_``)"
msgstr ""

#: ../../source/topics/plugins.rst:27
msgid ""
"Monkey patch anything within the ``aiida`` namespace (or the namespace "
"itself)"
msgstr ""

#: ../../source/topics/plugins.rst:29
msgid ""
"Failure to comply will likely prevent your plugin from being listed on the "
"official `AiiDA plugin registry <registry_>`_."
msgstr ""

#: ../../source/topics/plugins.rst:31
msgid ""
"If you find yourself in a situation where you feel like you need to do any "
"of the above, please open an issue on the `AiiDA repository <core_>`_ and we"
" can try to advise on how to proceed."
msgstr ""

#: ../../source/topics/plugins.rst:40
msgid "Guidelines for plugin design"
msgstr ""

#: ../../source/topics/plugins.rst:43
msgid "CalcJob & Parser plugins"
msgstr ""

#: ../../source/topics/plugins.rst:45
msgid ""
"The following guidelines are useful to keep in mind when wrapping external "
"codes:"
msgstr ""

#: ../../source/topics/plugins.rst:47
msgid ""
"**Start simple.** Make use of existing classes like "
":py:class:`~aiida.orm.nodes.data.dict.Dict`, "
":py:class:`~aiida.orm.nodes.data.singlefile.SinglefileData`, ... Write only "
"what is necessary to pass information from and to AiiDA."
msgstr ""

#: ../../source/topics/plugins.rst:50
msgid ""
"**Don't break data provenance.** Store *at least* what is needed for full "
"reproducibility."
msgstr ""

#: ../../source/topics/plugins.rst:52
msgid ""
"**Expose the full functionality.** Standardization is good but don't "
"artificially limit the power of a code you are wrapping - or your users will"
" get frustrated. If the code can do it, there should be *some* way to do it "
"with your plugin."
msgstr ""

#: ../../source/topics/plugins.rst:55
msgid ""
"**Don't rely on AiiDA internals.** Functionality at deeper nesting levels is"
" not considered part of the public API and may change between minor AiiDA "
"releases, breaking your plugin."
msgstr ""

#: ../../source/topics/plugins.rst:57
msgid ""
"**Parse what you want to query for.** Make a list of which information to:"
msgstr ""

#: ../../source/topics/plugins.rst:60
msgid ""
"parse into the database for querying "
"(:py:class:`~aiida.orm.nodes.data.dict.Dict`, ...)"
msgstr ""

#: ../../source/topics/plugins.rst:61
msgid ""
"store in the file repository for safe-keeping "
"(:py:class:`~aiida.orm.nodes.data.singlefile.SinglefileData`, ...)"
msgstr ""

#: ../../source/topics/plugins.rst:62
msgid ""
"leave on the computer where the calculation ran "
"(:py:class:`~aiida.orm.RemoteData`, ...)"
msgstr ""

#: ../../source/topics/plugins.rst:68
msgid "What is an entry point?"
msgstr ""

#: ../../source/topics/plugins.rst:71
msgid ""
"The ``setuptools`` package (used by ``pip``) has a feature called `entry "
"points`_, which allows to associate a string (the entry point *identifier*) "
"with any python object defined inside a python package. Entry points are "
"defined in the ``pyproject.toml`` file, for example::"
msgstr ""

#: ../../source/topics/plugins.rst:80
msgid ""
"Here, we add a new entry point ``mycode.mydata`` to the entry point *group* "
"``aiida.data``. The entry point identifier points to the ``MyData`` class "
"inside the file ``mydata.py``, which is part of the ``aiida_mycode`` "
"package."
msgstr ""

#: ../../source/topics/plugins.rst:83
msgid ""
"When installing a python package that defines entry points, the entry point "
"specifications are written to a file inside the distribution's ``.egg-info``"
" folder. ``setuptools`` provides a package ``pkg_resources`` for querying "
"these entry point specifications by distribution, by entry point group "
"and/or by name of the entry point and load the data structure to which it "
"points."
msgstr ""

#: ../../source/topics/plugins.rst:87
msgid "Why entry points?"
msgstr ""

#: ../../source/topics/plugins.rst:89
msgid ""
"AiiDA defines a set of entry point groups (see "
":ref:`topics:plugins:entrypointgroups` below). By inspecting the entry "
"points added to these groups by AiiDA plugins, AiiDA can offer uniform "
"interfaces to interact with them. For example:"
msgstr ""

#: ../../source/topics/plugins.rst:93
msgid ""
"``verdi plugin list aiida.workflows`` provides an overview of all workflows "
"installed by AiiDA plugins. Users can inspect the inputs/outputs of each "
"workflow using the same command without having to study the documentation of"
" the plugin."
msgstr ""

#: ../../source/topics/plugins.rst:95
msgid ""
"The ``DataFactory``, ``CalculationFactory`` and ``WorkflowFactory`` methods "
"allow instantiating new classes through a simple short string (e.g. "
"``quantumespresso.pw``). Users don't need to remember exactly where in the "
"plugin package the class resides, and plugins can be refactored without "
"users having to re-learn the plugin's API."
msgstr ""

#: ../../source/topics/plugins.rst:102
msgid "AiiDA entry point groups"
msgstr ""

#: ../../source/topics/plugins.rst:104
msgid ""
"Below, we list the entry point groups defined and searched by AiiDA. You can"
" get the same list as the output of ``verdi plugin list``."
msgstr ""

#: ../../source/topics/plugins.rst:108
msgid "``aiida.calculations``"
msgstr ""

#: ../../source/topics/plugins.rst:110
msgid ""
"Entry points in this group are expected to be subclasses of "
":py:class:`aiida.orm.JobCalculation "
"<aiida.orm.nodes.process.calculation.calcjob.CalcJobNode>`. This replaces "
"the previous method of placing a python module with the class in question "
"inside the ``aiida/orm/calculation/job`` subpackage."
msgstr ""

#: ../../source/topics/plugins.rst:112
msgid "Example entry point specification::"
msgstr ""

#: ../../source/topics/plugins.rst:117
msgid "``aiida_mycode/calcs/mycode.py``::"
msgstr ""

#: ../../source/topics/plugins.rst:123
msgid "Will lead to usage::"
msgstr ""

#: ../../source/topics/plugins.rst:129
msgid "``aiida.parsers``"
msgstr "``aiida.parsers``"

#: ../../source/topics/plugins.rst:131
msgid ""
"AiiDA expects a subclass of ``Parser``. Replaces the previous approach "
"consisting in placing a parser module under ``aiida/parsers/plugins``."
msgstr ""

#: ../../source/topics/plugins.rst:133
msgid "Example spec::"
msgstr ""

#: ../../source/topics/plugins.rst:138
msgid "``aida_mycode/parsers/myparser.py``::"
msgstr ""

#: ../../source/topics/plugins.rst:144 ../../source/topics/plugins.rst:165
#: ../../source/topics/plugins.rst:186 ../../source/topics/plugins.rst:325
msgid "Usage::"
msgstr ""

#: ../../source/topics/plugins.rst:150
msgid "``aiida.data``"
msgstr ""

#: ../../source/topics/plugins.rst:152
msgid ""
"Group for :py:class:`~aiida.orm.nodes.data.data.Data` subclasses. Previously"
" located in a subpackage of ``aiida/orm/data``."
msgstr ""

#: ../../source/topics/plugins.rst:154 ../../source/topics/plugins.rst:175
#: ../../source/topics/plugins.rst:295 ../../source/topics/plugins.rst:314
msgid "Spec::"
msgstr ""

#: ../../source/topics/plugins.rst:159
msgid "``aiida_mycode/data/mydat.py``::"
msgstr ""

#: ../../source/topics/plugins.rst:171
msgid "``aiida.workflows``"
msgstr ""

#: ../../source/topics/plugins.rst:173
msgid "Package AiiDA workflows as follows:"
msgstr ""

#: ../../source/topics/plugins.rst:180
msgid "``aiida_mycode/workflows/mywf.py``::"
msgstr ""

#: ../../source/topics/plugins.rst:191
msgid ""
"For old-style workflows the entry point mechanism of the plugin system is "
"not supported. Therefore one cannot load these workflows with the "
"``WorkflowFactory``. The only way to run these, is to store their source "
"code in the ``aiida/workflows/user`` directory and use normal python imports"
" to load the classes."
msgstr ""

#: ../../source/topics/plugins.rst:197
msgid "``aiida.cmdline``"
msgstr "``aiida.cmdline``"

#: ../../source/topics/plugins.rst:199
msgid ""
"``verdi`` uses the `click_` framework, which makes it possible to add new "
"subcommands to existing verdi commands, such as ``verdi data mydata``. AiiDA"
" expects each entry point to be either a ``click.Command`` or "
"``click.Group``. At present extra commands can be injected at the following "
"levels:"
msgstr ""

#: ../../source/topics/plugins.rst:202
msgid "As a :ref:`direct subcommand of verdi data<spec-verdi-data>`"
msgstr ""

#: ../../source/topics/plugins.rst:203
msgid ""
"As a :ref:`subcommand of verdi data core.structure import<spec-verdi-data-"
"structure-import>`"
msgstr ""

#: ../../source/topics/plugins.rst:208
msgid "Spec for ``verdi data``::"
msgstr ""

#: ../../source/topics/plugins.rst:213
msgid "``aiida_mycode/commands/mydata.py``::"
msgstr ""

#: ../../source/topics/plugins.rst:227 ../../source/topics/plugins.rst:254
msgid "Usage:"
msgstr ""

#: ../../source/topics/plugins.rst:235
msgid "Spec for ``verdi data core.structure import``::"
msgstr ""

#: ../../source/topics/plugins.rst:245
msgid "``aiida_mycode/commands/myformat.py``::"
msgstr ""

#: ../../source/topics/plugins.rst:262
msgid "``aiida.tools.dbexporters``"
msgstr ""

#: ../../source/topics/plugins.rst:264
msgid ""
"If your plugin package adds support for exporting to an external database, "
"use this entry point to have aiida find the module where you define the "
"necessary functions."
msgstr ""

#: ../../source/topics/plugins.rst:276
msgid "``aiida.tools.dbimporters``"
msgstr ""

#: ../../source/topics/plugins.rst:278
msgid ""
"If your plugin package adds support for importing from an external database,"
" use this entry point to have aiida find the module where you define the "
"necessary functions."
msgstr ""

#: ../../source/topics/plugins.rst:291
msgid "``aiida.schedulers``"
msgstr ""

#: ../../source/topics/plugins.rst:293
msgid ""
"We recommend naming the plugin package after the scheduler (e.g. ``aiida-"
"myscheduler``), so that the entry point name can simply equal the name of "
"the scheduler:"
msgstr ""

#: ../../source/topics/plugins.rst:300
msgid "``aiida_myscheduler/myscheduler.py``::"
msgstr ""

#: ../../source/topics/plugins.rst:306
msgid ""
"Usage: The scheduler is used in the familiar way by entering 'myscheduler' "
"as the scheduler option when setting up a computer."
msgstr ""

#: ../../source/topics/plugins.rst:309
msgid "``aiida.transports``"
msgstr ""

#: ../../source/topics/plugins.rst:311
msgid ""
"``aiida-core`` ships with two modes of transporting files and folders to "
"remote computers: ``core.ssh`` and ``core.local`` (stub for when the remote "
"computer is actually the same). We recommend naming the plugin package after"
" the mode of transport (e.g. ``aiida-mytransport``), so that the entry point"
" name can simply equal the name of the transport:"
msgstr ""

#: ../../source/topics/plugins.rst:319
msgid "``aiida_mytransport/mytransport.py``::"
msgstr ""

#: ../../source/topics/plugins.rst:330
msgid ""
"When setting up a new computer, specify ``mytransport`` as the transport "
"mode."
msgstr ""

#: ../../source/topics/plugins.rst:337
msgid "Plugin test fixtures"
msgstr ""

#: ../../source/topics/plugins.rst:339
msgid ""
"When developing AiiDA plugin packages, it is recommended to use `pytest "
"<https://docs.pytest.org/>`__ as the unit test library, which is the de-"
"facto standard in the Python ecosystem. It provides a number of `fixtures "
"<https://docs.pytest.org/en/7.1.x/how-to/fixtures.html>`__ that make it easy"
" to setup and write tests. ``aiida-core`` also provides a number fixtures "
"that are specific to AiiDA and make it easy to test various sorts of "
"plugins."
msgstr ""

#: ../../source/topics/plugins.rst:343
msgid ""
"To make use of these fixtures, create a ``conftest.py`` file in your "
"``tests`` folder and add the following code:"
msgstr ""

#: ../../source/topics/plugins.rst:349
msgid ""
"Just by adding this line, the fixtures that are provided by the "
":mod:`~aiida.manage.tests.pytest_fixtures` module are automatically "
"imported. The module provides the following fixtures:"
msgstr ""

#: ../../source/topics/plugins.rst:352
msgid ""
":ref:`aiida_manager <topics:plugins:testfixtures:aiida-manager>`: Return the"
" global instance of the :class:`~aiida.manage.manager.Manager`"
msgstr ""

#: ../../source/topics/plugins.rst:353
msgid ""
":ref:`aiida_profile <topics:plugins:testfixtures:aiida-profile>`: Provide a "
"loaded AiiDA test profile with loaded storage backend"
msgstr ""

#: ../../source/topics/plugins.rst:354
msgid ""
":ref:`aiida_profile_clean <topics:plugins:testfixtures:aiida-profile-"
"clean>`: Same as ``aiida_profile`` but the storage backend is cleaned"
msgstr ""

#: ../../source/topics/plugins.rst:355
msgid ""
":ref:`aiida_profile_clean_class <topics:plugins:testfixtures:aiida-profile-"
"clean-class>`: Same as ``aiida_profile_clean`` but should be used at the "
"class scope"
msgstr ""

#: ../../source/topics/plugins.rst:356
msgid ""
":ref:`aiida_profile_factory <topics:plugins:testfixtures:aiida-profile-"
"factory>`: Create a temporary profile ready to be used for testing"
msgstr ""

#: ../../source/topics/plugins.rst:357
msgid ""
":ref:`aiida_instance <topics:plugins:testfixtures:aiida-instance>`: Return "
"the :class:`~aiida.manage.configuration.config.Config` instance that is used"
" for the test session"
msgstr ""

#: ../../source/topics/plugins.rst:358
msgid ""
":ref:`config_psql_dos <topics:plugins:testfixtures:config-psql-dos>`: Return"
" a profile configuration for the "
":class:`~aiida.storage.psql_dos.backend.PsqlDosBackend`"
msgstr ""

#: ../../source/topics/plugins.rst:359
msgid ""
":ref:`postgres_cluster <topics:plugins:testfixtures:postgres-cluster>`: "
"Create a temporary and isolated PostgreSQL cluster using ``pgtest`` and "
"cleanup after the yield"
msgstr ""

#: ../../source/topics/plugins.rst:360
msgid ""
":ref:`aiida_local_code_factory <topics:plugins:testfixtures:aiida-local-"
"code-factory>`: Setup a "
":class:`~aiida.orm.nodes.data.code.installed.InstalledCode` instance on the "
"``localhost`` computer"
msgstr ""

#: ../../source/topics/plugins.rst:361
msgid ""
":ref:`aiida_computer <topics:plugins:testfixtures:aiida-computer>`: Setup a "
":class:`~aiida.orm.computers.Computer` instance"
msgstr ""

#: ../../source/topics/plugins.rst:362
msgid ""
":ref:`aiida_computer_local <topics:plugins:testfixtures:aiida-computer-"
"local>`: Setup the localhost as a :class:`~aiida.orm.computers.Computer` "
"using local transport"
msgstr ""

#: ../../source/topics/plugins.rst:363
msgid ""
":ref:`aiida_computer_ssh <topics:plugins:testfixtures:aiida-computer-ssh>`: "
"Setup the localhost as a :class:`~aiida.orm.computers.Computer` using SSH "
"transport"
msgstr ""

#: ../../source/topics/plugins.rst:364
msgid ""
":ref:`aiida_localhost <topics:plugins:testfixtures:aiida-localhost>`: "
"Shortcut for <topics:plugins:testfixtures:aiida-computer-local> that "
"immediately returns a :class:`~aiida.orm.computers.Computer` instance for "
"the ``localhost`` computer instead of a factory"
msgstr ""

#: ../../source/topics/plugins.rst:365
msgid ""
":ref:`submit_and_await <topics:plugins:testfixtures:submit-and-await>`: "
"Submit a process or process builder to the daemon and wait for it to reach a"
" certain process state"
msgstr ""

#: ../../source/topics/plugins.rst:366
msgid ""
":ref:`started_daemon_client <topics:plugins:testfixtures:started-daemon-"
"client>`: Same as ``daemon_client`` but the daemon is guaranteed to be "
"running"
msgstr ""

#: ../../source/topics/plugins.rst:367
msgid ""
":ref:`stopped_daemon_client <topics:plugins:testfixtures:stopped-daemon-"
"client>`: Same as ``daemon_client`` but the daemon is guaranteed to *not* be"
" running"
msgstr ""

#: ../../source/topics/plugins.rst:368
msgid ""
":ref:`daemon_client <topics:plugins:testfixtures:daemon-client>`: Return a "
":class:`~aiida.engine.daemon.client.DaemonClient` instance to control the "
"daemon"
msgstr ""

#: ../../source/topics/plugins.rst:369
msgid ""
":ref:`entry_points <topics:plugins:testfixtures:entry-points>`: Return a "
":class:`~aiida.manage.tests.pytest_fixtures.EntryPointManager` instance to "
"add and remove entry points"
msgstr ""

#: ../../source/topics/plugins.rst:375
msgid "``aiida_manager``"
msgstr ""

#: ../../source/topics/plugins.rst:377
msgid ""
"Return the global instance of the :class:`~aiida.manage.manager.Manager`. "
"Can be used, for example, to retrieve the current "
":class:`~aiida.manage.configuration.config.Config` instance:"
msgstr ""

#: ../../source/topics/plugins.rst:389
msgid "``aiida_profile``"
msgstr ""

#: ../../source/topics/plugins.rst:391
msgid ""
"This fixture ensures that an AiiDA profile is loaded with an initialized "
"storage backend, such that data can be stored. The fixture is session-scoped"
" and it has set ``autouse=True``, so it is automatically enabled for the "
"test session."
msgstr ""

#: ../../source/topics/plugins.rst:394
msgid ""
"By default, the fixture will generate a completely temporary independent "
"AiiDA instance and test profile. This includes:"
msgstr ""

#: ../../source/topics/plugins.rst:397
msgid "A temporary ``.aiida`` configuration folder with configuration files"
msgstr ""

#: ../../source/topics/plugins.rst:398
msgid "A temporary PostgreSQL cluster"
msgstr ""

#: ../../source/topics/plugins.rst:399
msgid ""
"A temporary test profile complete with storage backend (creates a database "
"in the temporary PostgreSQL cluster)"
msgstr ""

#: ../../source/topics/plugins.rst:401
msgid ""
"The temporary test instance and profile are automatically destroyed at the "
"end of the test session. The fixture guarantees that no changes are made to "
"the actual instance of AiiDA with its configuration and profiles."
msgstr ""

#: ../../source/topics/plugins.rst:404
msgid ""
"The creation of the temporary instance and profile takes a few seconds at "
"the beginning of the test suite to setup. It is possible to avoid this by "
"creating a dedicated test profile once and telling the fixture to use that "
"instead of generating one each time:"
msgstr ""

#: ../../source/topics/plugins.rst:407
msgid ""
"Create a profile, by using `verdi setup` or `verdi quicksetup` and specify "
"the ``--test-profile`` flag"
msgstr ""

#: ../../source/topics/plugins.rst:408
msgid ""
"Set the ``AIIDA_TEST_PROFILE`` environment variable to the name of the test "
"profile: ``export AIIDA_TEST_PROFILE=<test-profile-name>``"
msgstr ""

#: ../../source/topics/plugins.rst:410
msgid ""
"Although the fixture is automatically used, and so there is no need to "
"explicitly pass it into a test function, it may still be useful, as it can "
"be used to clean the storage backend from all data:"
msgstr ""

#: ../../source/topics/plugins.rst:430
msgid "``aiida_profile_clean``"
msgstr ""

#: ../../source/topics/plugins.rst:432
msgid ""
"Provides a loaded test profile through ``aiida_profile`` but empties the "
"storage before calling the test function. Note that a default user will be "
"inserted into the database after cleaning it."
msgstr ""

#: ../../source/topics/plugins.rst:440
msgid ""
"This functionality can be useful if it is easier to setup and write the test"
" if there is no pre-existing data. However, cleaning the storage may take a "
"non-negligible amount of time, so only use it when really needed in order to"
" keep tests running as fast as possible."
msgstr ""

#: ../../source/topics/plugins.rst:447
msgid "``aiida_profile_clean_class``"
msgstr ""

#: ../../source/topics/plugins.rst:449
msgid ""
"Provides the same as ``aiida_profile_clean`` but with ``scope=class``. "
"Should be used for a test class:"
msgstr ""

#: ../../source/topics/plugins.rst:460
msgid "The storage is cleaned once when the class is initialized."
msgstr ""

#: ../../source/topics/plugins.rst:466
msgid "``aiida_profile_factory``"
msgstr ""

#: ../../source/topics/plugins.rst:468
msgid ""
"Create a temporary profile, add it to the config of the loaded AiiDA "
"instance and load the profile. Can be useful to create a test profile for a "
"custom storage backend:"
msgstr ""

#: ../../source/topics/plugins.rst:488
msgid ""
"Note that the configuration above is not actually functional and the actual "
"configuration depends on the storage implementation that is used."
msgstr ""

#: ../../source/topics/plugins.rst:494
msgid "``aiida_instance``"
msgstr ""

#: ../../source/topics/plugins.rst:496
msgid ""
"Return the :class:`~aiida.manage.configuration.config.Config` instance that "
"is used for the test session."
msgstr ""

#: ../../source/topics/plugins.rst:507
msgid "``config_psql_dos``"
msgstr ""

#: ../../source/topics/plugins.rst:509
msgid ""
"Return a profile configuration for the "
":class:`~aiida.storage.psql_dos.backend.PsqlDosBackend`. This can be used in"
" combination with the ``aiida_profile_factory`` fixture to create a test "
"profile with customised database parameters:"
msgstr ""

#: ../../source/topics/plugins.rst:522
msgid ""
"Note that this is only useful if the storage configuration needs to be "
"customized. If any configuration works, simply use the ``aiida_profile`` "
"fixture straight away, which uses the ``PsqlDosStorage`` storage backend by "
"default."
msgstr ""

#: ../../source/topics/plugins.rst:529
msgid "``postgres_cluster``"
msgstr ""

#: ../../source/topics/plugins.rst:531
msgid ""
"Create a temporary and isolated PostgreSQL cluster using ``pgtest`` and "
"cleanup after the yield."
msgstr ""

#: ../../source/topics/plugins.rst:547
msgid "``aiida_localhost``"
msgstr ""

#: ../../source/topics/plugins.rst:549
msgid ""
"This test is useful if a test requires a "
":class:`~aiida.orm.computers.Computer` instance. This fixture returns a "
":class:`~aiida.orm.computers.Computer` that represents the ``localhost``."
msgstr ""

#: ../../source/topics/plugins.rst:561
msgid "``aiida_local_code_factory``"
msgstr ""

#: ../../source/topics/plugins.rst:563
msgid ""
"This test is useful if a test requires an "
":class:`~aiida.orm.nodes.data.code.installed.InstalledCode` instance. For "
"example:"
msgstr ""

#: ../../source/topics/plugins.rst:574
msgid ""
"By default, it will use the ``localhost`` computer returned by the "
"``aiida_localhost`` fixture."
msgstr ""

#: ../../source/topics/plugins.rst:580
msgid "``aiida_computer``"
msgstr ""

#: ../../source/topics/plugins.rst:582
msgid ""
"This fixture should be used to create and configure a "
":class:`~aiida.orm.computers.Computer` instance. The fixture provides a "
"factory that can be called without any arguments:"
msgstr ""

#: ../../source/topics/plugins.rst:592
msgid ""
"By default, the localhost is used for the hostname and a random label is "
"generated."
msgstr ""

#: ../../source/topics/plugins.rst:601
msgid ""
"First the database is queried to see if a computer with the given label "
"already exist. If found, the existing computer is returned, otherwise a new "
"instance is created."
msgstr ""

#: ../../source/topics/plugins.rst:604
msgid ""
"The returned computer is also configured for the current default user. The "
"configuration can be customized through the ``configuration_kwargs`` "
"dictionary:"
msgstr ""

#: ../../source/topics/plugins.rst:618
msgid "``aiida_computer_local``"
msgstr ""

#: ../../source/topics/plugins.rst:620
msgid ""
"This fixture is a shortcut for ``aiida_computer`` to setup the localhost "
"with local transport:"
msgstr ""

#: ../../source/topics/plugins.rst:629
msgid ""
"To leave a newly created computer unconfigured, pass ``configure=False``:"
msgstr ""

#: ../../source/topics/plugins.rst:637 ../../source/topics/plugins.rst:671
msgid ""
"Note that if the computer already exists and was configured before, it won't"
" be unconfigured. If you need a guarantee that the computer is not "
"configured, make sure to clean the database before the test or use a unique "
"label:"
msgstr ""

#: ../../source/topics/plugins.rst:651
msgid "``aiida_computer_ssh``"
msgstr ""

#: ../../source/topics/plugins.rst:653
msgid ""
"This fixture is a shortcut for ``aiida_computer`` to setup the localhost "
"with SSH transport:"
msgstr ""

#: ../../source/topics/plugins.rst:662
msgid ""
"This can be useful if the functionality that needs to be tested involves "
"testing the SSH transport, but these use-cases should be rare outside of "
"`aiida-core`. To leave a newly created computer unconfigured, pass "
"``configure=False``:"
msgstr ""

#: ../../source/topics/plugins.rst:685
msgid "``submit_and_await``"
msgstr ""

#: ../../source/topics/plugins.rst:687
msgid ""
"This fixture is useful when testing submitting a process to the daemon. It "
"submits the process to the daemon and will wait until it has reached a "
"certain state. By default it will wait for the process to reach "
"``ProcessState.FINISHED``:"
msgstr ""

#: ../../source/topics/plugins.rst:701
msgid ""
"Note that the fixture automatically depends on the ``started_daemon_client``"
" fixture to guarantee the daemon is running."
msgstr ""

#: ../../source/topics/plugins.rst:707
msgid "``started_daemon_client``"
msgstr ""

#: ../../source/topics/plugins.rst:709
msgid ""
"This fixture ensures that the daemon for the test profile is running and "
"returns an instance of the :class:`~aiida.engine.daemon.client.DaemonClient`"
" which can be used to control the daemon."
msgstr ""

#: ../../source/topics/plugins.rst:720
msgid "``stopped_daemon_client``"
msgstr ""

#: ../../source/topics/plugins.rst:722
msgid ""
"This fixture ensures that the daemon for the test profile is stopped and "
"returns an instance of the :class:`~aiida.engine.daemon.client.DaemonClient`"
" which can be used to control the daemon."
msgstr ""

#: ../../source/topics/plugins.rst:733
msgid "``daemon_client``"
msgstr ""

#: ../../source/topics/plugins.rst:735
msgid ""
"Return a :class:`~aiida.engine.daemon.client.DaemonClient` instance that can"
" be used to control the daemon:"
msgstr ""

#: ../../source/topics/plugins.rst:744
msgid ""
"The fixture is session scoped. At the end of the test session, this fixture "
"automatically shuts down the daemon if it is still running."
msgstr ""

#: ../../source/topics/plugins.rst:751
msgid "``entry_points``"
msgstr ""

#: ../../source/topics/plugins.rst:753
msgid ""
"Return a :class:`~aiida.manage.tests.pytest_fixtures.EntryPointManager` "
"instance to add and remove entry points."
msgstr ""

#: ../../source/topics/plugins.rst:769
msgid ""
"Any entry points additions and removals are automatically undone at the end "
"of the test."
msgstr ""

#: ../../source/topics/processes/concepts.rst:7
msgid ""
"Anything that runs in AiiDA is an instance of the "
":py:class:`~aiida.engine.processes.process.Process` class. The ``Process`` "
"class contains all the information and logic to tell, whoever is handling "
"it, how to run it to completion. Typically the one responsible for running "
"the processes is an instance of a :py:class:`~aiida.engine.runners.Runner`. "
"This can be a local runner or one of the daemon runners in case of the "
"daemon running the process."
msgstr ""
"所有可以通过AiiDA运行的事件都是:py:class:`~aiida.engine.processes.process.Process` 类的实例。 "
"``Process`` 类包含了有关运行用户，运行方法，运行逻辑的所有信息。特别的，运行该例程的用户属于类 "
":py:class:`~aiida.engine.runners.Runner` 的实例。该运行者可以是本地用户，也可是守护进程的的持有者。"

#: ../../source/topics/processes/concepts.rst:12
msgid ""
"In addition to those run instructions, any ``Process`` that has been "
"executed needs some sort of record in the database to store what happened "
"during its execution. For example it needs to record what its exact inputs "
"were, the log messages that were reported and what the final outputs were. "
"For this purpose, every process will utilize an instance of a sub class of "
"the :py:class:`~aiida.orm.ProcessNode` class. This ``ProcessNode`` class is "
"a sub class of :py:class:`~aiida.orm.Node` and serves as the record of the "
"process' execution in the database and by extension the provenance graph."
msgstr ""

#: ../../source/topics/processes/concepts.rst:17
msgid ""
"It is very important to understand this division of labor. A ``Process`` "
"describes how something should be run, and the ``ProcessNode`` serves as a "
"mere record in the database of what actually happened during execution. A "
"good thing to remember is that while it is running, we are dealing with the "
"``Process`` and when it is finished we interact with the ``ProcessNode``."
msgstr ""
"其父类的分工是非常明确的。``Process`` 类描述了任务该如何运行，``ProcessNode`` "
"类则用于在数据库中记录当时间运行时真实发生的过程。也就是说当事件运行时用户面对``Process``类，而事件运行结束后使用``ProcessNode``"
" 进行交互。"

#: ../../source/topics/processes/concepts.rst:24
msgid "Process types"
msgstr "例程类别"

#: ../../source/topics/processes/concepts.rst:26
msgid "Processes in AiiDA come in two flavors:"
msgstr "AiiDA中的例程主要有以下两类："

#: ../../source/topics/processes/concepts.rst:28
msgid "Calculation-like"
msgstr "算例类型"

#: ../../source/topics/processes/concepts.rst:29
msgid "Workflow-like"
msgstr "工作流类型"

#: ../../source/topics/processes/concepts.rst:31
msgid ""
"The calculation-like processes have the capability to *create* data, whereas"
" the workflow-like processes orchestrate other processes and have the "
"ability to *return* data produced by calculations. Again, this is a "
"distinction that plays a big role in AiiDA and is crucial to understand. For"
" this reason, these different types of processes also get a different sub "
"class of the ``ProcessNode`` class. The hierarchy of these node classes and "
"the link types that are allowed between them and ``Data`` nodes, is "
"explained in detail in the :ref:`provenance "
"implementation<topics:provenance:implementation>` documentation."
msgstr ""

#: ../../source/topics/processes/concepts.rst:36
msgid ""
"Currently, there are four types of processes in ``aiida-core`` and the "
"following table shows with which node class it is represented in the "
"provenance graph and what the process is used for."
msgstr "当前， ``aiida-core`` 中有如下表中四类例程，表中还展示了不同的例程表示在可验证性图中的具体节点类型和例程的具体使用场景。"

#: ../../source/topics/processes/concepts.rst:39
msgid "Process class"
msgstr "Process 类"

#: ../../source/topics/processes/concepts.rst:39
msgid "Node class"
msgstr "Node 类"

#: ../../source/topics/processes/concepts.rst:39
msgid "Used for"
msgstr "使用场景"

#: ../../source/topics/processes/concepts.rst:41
msgid ":py:class:`~aiida.engine.processes.calcjobs.calcjob.CalcJob`"
msgstr ":py:class:`~aiida.engine.processes.calcjobs.calcjob.CalcJob`"

#: ../../source/topics/processes/concepts.rst:41
msgid ":py:class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode`"
msgstr ":py:class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode`"

#: ../../source/topics/processes/concepts.rst:41
msgid "Calculations performed by external codes"
msgstr "外部软件代码执行的算例"

#: ../../source/topics/processes/concepts.rst:42
msgid ":py:class:`~aiida.engine.processes.workchains.workchain.WorkChain`"
msgstr ":py:class:`~aiida.engine.processes.workchains.workchain.WorkChain`"

#: ../../source/topics/processes/concepts.rst:42
msgid ":py:class:`~aiida.orm.nodes.process.workflow.workchain.WorkChainNode`"
msgstr ":py:class:`~aiida.orm.nodes.process.workflow.workchain.WorkChainNode`"

#: ../../source/topics/processes/concepts.rst:42
msgid "Workflows that run multiple calculations"
msgstr "多个算例组成的工作流"

#: ../../source/topics/processes/concepts.rst:43
#: ../../source/topics/processes/concepts.rst:44
msgid ":py:class:`~aiida.engine.processes.functions.FunctionProcess`"
msgstr ":py:class:`~aiida.engine.processes.functions.FunctionProcess`"

#: ../../source/topics/processes/concepts.rst:43
msgid ""
":py:class:`~aiida.orm.nodes.process.calculation.calcfunction.CalcFunctionNode`"
msgstr ""
":py:class:`~aiida.orm.nodes.process.calculation.calcfunction.CalcFunctionNode`"

#: ../../source/topics/processes/concepts.rst:43
msgid "Python functions decorated with the ``@calcfunction`` decorator"
msgstr "``@calculation`` 装饰器装饰的python 函数"

#: ../../source/topics/processes/concepts.rst:44
msgid ""
":py:class:`~aiida.orm.nodes.process.workflow.workfunction.WorkFunctionNode`"
msgstr ""
":py:class:`~aiida.orm.nodes.process.workflow.workfunction.WorkFunctionNode`"

#: ../../source/topics/processes/concepts.rst:44
msgid "Python functions decorated with the ``@workfunction`` decorator"
msgstr "``@workfunction`` 装饰器装饰的python 函数"

#: ../../source/topics/processes/concepts.rst:47
msgid ""
"For basic information on the concept of a ``CalcJob`` or ``calcfunction``, "
"refer to the :ref:`calculations concept<topics:calculations:concepts>` The "
"``WorkChain`` and ``workfunction`` are described in the :ref:`workflows "
"concept<topics:workflows:concepts>`. After having read and understood the "
"basic concept of calculation and workflow processes, detailed information on"
" how to implement and use them can be found in the dedicated developing "
"sections for :ref:`calculations<topics:calculations:usage>` and "
":ref:`workflows<topics:workflows:usage>`, respectively."
msgstr ""

#: ../../source/topics/processes/concepts.rst:51
msgid ""
"A ``FunctionProcess`` is never explicitly implemented but will be generated "
"dynamically by the engine when a python function decorated with a "
":py:func:`~aiida.engine.processes.functions.calcfunction` or "
":py:func:`~aiida.engine.processes.functions.workfunction` is run."
msgstr ""
"``FunctionProcess`` 不需要直接实现，而是通过在python函数前添加装饰器来动态的通过AiiDA引擎创建。比如创建 "
":py:func:`~aiida.engine.processes.functions.calcfunction`  "
":py:func:`~aiida.engine.processes.functions.workfunction` 。"

#: ../../source/topics/processes/concepts.rst:57
msgid "Process state"
msgstr "例程的状态"

#: ../../source/topics/processes/concepts.rst:58
msgid ""
"Each instance of a ``Process`` class that is being executed has a process "
"state. This property tells you about the current status of the process. It "
"is stored in the instance of the ``Process`` itself and the workflow engine,"
" the ``plumpy`` library, operates only on that value. However, the "
"``Process`` instance 'dies' as soon as it is terminated, therefore the "
"process state is also written to the calculation node that the process uses "
"as its database record, under the ``process_state`` attribute. The process "
"can be in one of six states:"
msgstr ""
"每个被执行的 ``Process`` 实例都有其不同时刻的状态。该性质告诉用户当前例程所处于的运行时状态。这个信息被储存在 ``Process`` "
"实例中或工作流引擎中，这些状态通过 ``plumpy`` 库来变换。然而当 ``Process`` "
"实例运行结束时他就‘死亡’了，因此我们这时还会将算例节点的状态信息按照 ``process_state`` 属性记录进数据库中。算例的状态有以下六种 :"

#: ../../source/topics/processes/concepts.rst:65
msgid "*Active*"
msgstr "*Active*"

#: ../../source/topics/processes/concepts.rst:65
msgid "*Terminated*"
msgstr "*Terminated*"

#: ../../source/topics/processes/concepts.rst:67
msgid "Created"
msgstr "Created"

#: ../../source/topics/processes/concepts.rst:67
msgid "Killed"
msgstr "Killed"

#: ../../source/topics/processes/concepts.rst:68
msgid "Running"
msgstr "Running"

#: ../../source/topics/processes/concepts.rst:68
msgid "Excepted"
msgstr "Excepted"

#: ../../source/topics/processes/concepts.rst:69
msgid "Waiting"
msgstr "Waiting"

#: ../../source/topics/processes/concepts.rst:69
msgid "Finished"
msgstr "Finished"

#: ../../source/topics/processes/concepts.rst:72
msgid ""
"The three states in the left column are 'active' states, whereas the right "
"column displays the three 'terminal' states. Once a process reaches a "
"terminal state, it will never leave it; its execution is permanently "
"terminated. When a process is first created, it is put in the ``Created`` "
"state. As soon as it is picked up by a runner and it is active, it will be "
"in the ``Running`` state. If the process is waiting for another process, "
"that it called, to be finished, it will be in the ``Waiting`` state. If a "
"process is in the ``Killed`` state, it means the user issued a command to "
"kill it, or its parent process was killed. The ``Excepted`` state indicates "
"that during execution an exception occurred that was not caught and the "
"process was unexpectedly terminated. The final option is the ``Finished`` "
"state, which means that the process was successfully executed, and the "
"execution was nominal. Note that this does not automatically mean that the "
"result of the process can also be considered to be successful, it was just "
"executed without any problems."
msgstr ""
"左边列是三个‘激活’状态，右边列时三个‘结束’状态。一旦一个例程到达结束状态之一，其状态就会始终停留在那里。当例程被创建时，自动将其状态设置为 "
"``Created`` 状态。一旦其被运行器选中并处于激活的状态，它就被转向 ``Running`` "
"状态。如果一个例程等待其他的例程完成，也就是说，它等待完成时，它处于 ``Waiting`` 状态。 如果例程处于 ``Killed`` "
"状态，说明用户通过指令终止了它的运行，也可能时父例程终止了它的运行。 ``Excepted`` "
"状态则表示运行过程中抛出了没有捕获的异常，或例程没有如预期正常结束。 最后是 ``Finished`` "
"状态，该状态表示例程成功运行。注意，这个状态并不代表例程的运行结果是正确可靠的，它只是代表了运行顺利结束，没有出错。"

#: ../../source/topics/processes/concepts.rst:82
msgid ""
"To distinguish between a successful and a failed execution, there is the "
":ref:`exit status<topics:processes:concepts:exit_codes>`. This is another "
"attribute that is stored in the node of the process and is an integer that "
"can be set by the process. A ``0`` (zero) means that the result of the "
"process was successful, and a non-zero value indicates a failure. All the "
"process nodes used by the various processes are sub-classes of "
":py:class:`~aiida.orm.ProcessNode`, which defines handy properties to query "
"the process state and exit status."
msgstr ""

#: ../../source/topics/processes/concepts.rst:88
msgid "Property"
msgstr "属性"

#: ../../source/topics/processes/concepts.rst:88
msgid "Meaning"
msgstr "含义"

#: ../../source/topics/processes/concepts.rst:90
msgid "``process_state``"
msgstr "``process_state``"

#: ../../source/topics/processes/concepts.rst:90
msgid "Returns the current process state"
msgstr "返回当前例程状态"

#: ../../source/topics/processes/concepts.rst:91
msgid "``exit_status``"
msgstr "``exit_status``"

#: ../../source/topics/processes/concepts.rst:91
msgid "Returns the exit status, or None if not set"
msgstr "返回例程结束时的具体退出状态，如果没有设置则是 ``None``"

#: ../../source/topics/processes/concepts.rst:92
msgid "``exit_message``"
msgstr "``exit_message``"

#: ../../source/topics/processes/concepts.rst:92
msgid "Returns the exit message, or None if not set"
msgstr "返回退出信息，如果没有设置则为 ``None``"

#: ../../source/topics/processes/concepts.rst:93
msgid "``is_terminated``"
msgstr "``is_terminated``"

#: ../../source/topics/processes/concepts.rst:93
msgid ""
"Returns ``True`` if the process was either ``Killed``, ``Excepted``, or "
"``Finished``"
msgstr "如果例程是 ``Killed`` ， ``Excepted`` 或 ``Finished`` 状态之一，则返回 ``True``"

#: ../../source/topics/processes/concepts.rst:94
msgid "``is_killed``"
msgstr "``is_killed``"

#: ../../source/topics/processes/concepts.rst:94
msgid "Returns ``True`` if the process is ``Killed``"
msgstr "返回 ``True`` 如果例程的状态是 ``Killed``"

#: ../../source/topics/processes/concepts.rst:95
msgid "``is_excepted``"
msgstr "``is_excepted``"

#: ../../source/topics/processes/concepts.rst:95
msgid "Returns ``True`` if the process is ``Excepted``"
msgstr "返回 ``True`` 如果例程的状态是 ``Excepted``"

#: ../../source/topics/processes/concepts.rst:96
msgid "``is_finished``"
msgstr "``is_finished``"

#: ../../source/topics/processes/concepts.rst:96
msgid "Returns ``True`` if the process is ``Finished``"
msgstr "返回 ``True`` 如果例程的状态是 ``Finished``"

#: ../../source/topics/processes/concepts.rst:97
msgid "``is_finished_ok``"
msgstr "``is_finished_ok``"

#: ../../source/topics/processes/concepts.rst:97
msgid ""
"Returns ``True`` if the process is ``Finished`` and the ``exit_status`` is "
"equal to zero"
msgstr "返回 ``True`` 如果例程的状态是 ``Finished`` 且 ``exit_status`` 的值为 ``0`` (零)"

#: ../../source/topics/processes/concepts.rst:98
msgid "``is_failed``"
msgstr "``is_failed``"

#: ../../source/topics/processes/concepts.rst:98
msgid ""
"Returns ``True`` if the process is ``Finished`` and the ``exit_status`` is "
"non-zero"
msgstr "返回 ``True`` 如果例程的状态是 ``Finished`` 且 ``exit_status`` 的值非零"

#: ../../source/topics/processes/concepts.rst:101
msgid ""
"When you load a calculation node from the database, you can use these "
"property methods to inquire about its state and exit status."
msgstr "当用户从数据库中加载这些算例节点，可以使用这些属性方法来查询算例的当前状态和退出状态。"

#: ../../source/topics/processes/concepts.rst:107
msgid "Process exit codes"
msgstr "例程结束代码"

#: ../../source/topics/processes/concepts.rst:109
msgid ""
"The previous section about the process state showed that a process that is "
"``Finished`` does not say anything about whether the result is 'successful' "
"or 'failed'. The ``Finished`` state means nothing more than that the engine "
"succeeded in running the process to the end of execution, without it "
"encountering exceptions or being killed. To distinguish between a "
"'successful' and 'failed' process, an 'exit status' can be defined. The "
"`exit status is a common concept in programming "
"<https://en.wikipedia.org/wiki/Exit_status>`_ and is a small integer, where "
"zero means that the result of the process was successful, and a non-zero "
"value indicates a failure. By default a process that terminates nominally "
"will get a ``0`` (zero) exit status. To mark a process as failed, one can "
"return an instance of the "
":py:class:`~aiida.engine.processes.exit_code.ExitCode` named tuple, which "
"allows to set an integer ``exit_status`` and a string message as "
"``exit_message``. When the engine receives such an ``ExitCode`` as the "
"return value from a process, it will set the exit status and message on the "
"corresponding attributes of the process node representing the process in the"
" provenance graph."
msgstr ""

#: ../../source/topics/processes/concepts.rst:119
msgid ""
"For how exit codes can be defined and returned see the :ref:`exit code usage"
" section <topics:processes:usage:exit_codes>`."
msgstr ""

#: ../../source/topics/processes/concepts.rst:124
msgid "Process lifetime"
msgstr "例程运行的生命周期"

#: ../../source/topics/processes/concepts.rst:126
msgid ""
"The lifetime of a process is defined as the time from the moment it is "
"launched until it reaches a :ref:`terminal "
"state<topics:processes:concepts:state>`."
msgstr ""

#: ../../source/topics/processes/concepts.rst:131
msgid "Process and node distinction"
msgstr "例程和其节点的区别"

#: ../../source/topics/processes/concepts.rst:132
msgid ""
"As explained in the :ref:`introduction of this "
"section<topics:processes:concepts>`, there is a clear and important "
"distinction between the 'process' and the 'node' that represents its "
"execution in the provenance graph. When a process is launched, an instance "
"of the ``Process`` class is created in memory which will be propagated to "
"completion by the responsible runner. This 'process' instance only exists in"
" the memory of the python interpreter that it is running in, for example "
"that of a daemon runner, and so we cannot directly inspect its state. That "
"is why the process will write any of its state changes to the corresponding "
"node representing it in the provenance graph. In this way, the node acts as "
"a 'proxy' or a mirror image that reflects the state of the process in "
"memory. This means that the output of many of the ``verdi`` commands, such "
"as ``verdi process list``, do not actually show the state of the process "
"instances, but rather the state of the node to which they have last written "
"their state."
msgstr ""

#: ../../source/topics/processes/concepts.rst:140
msgid "Process tasks"
msgstr "例程任务"

#: ../../source/topics/processes/concepts.rst:141
msgid ""
"The previous section explained how launching a process means creating an "
"instance of the ``Process`` class in memory. When the process is being 'run'"
" (see the section on :ref:`launching "
"processes<topics:processes:usage:launch>` for more details) that is to say "
"in a local interpreter, the particular process instance will die as soon as "
"the interpreter dies. This is what often makes 'submitting' the preferred "
"method of launching a process. When a process is 'submitted', an instance of"
" the ``Process`` is created, along with the node that represents it in the "
"database, and its state is then persisted (stored) in the database. This is "
"called a 'process checkpoint', more information on which :ref:`will follow "
"later<topics:processes:concepts:checkpoints>`. Subsequently, the process "
"instance is shut down and a 'continuation task' is sent to the process queue"
" of RabbitMQ. This task is simply a small message that just contains an "
"identifier for the process. In order to reconstruct the process from a "
"`checkpoint`, the process needs to be importable in the daemon environment "
"by a) giving it an :ref:`associated entry point<how-to:plugin-codes:entry-"
"points>` or b) :ref:`including its module path<how-to:faq:process-not-"
"importable-daemon>` in the ``PYTHONPATH`` that the daemon workers will have."
msgstr ""

#: ../../source/topics/processes/concepts.rst:150
msgid ""
"All the daemon runners, when they are launched, subscribe to the process "
"queue and RabbitMQ will distribute the continuation tasks to them as they "
"come in, making sure that each task is only sent to one runner at a time. "
"The receiving daemon runner can restore the process instance in memory from "
"the checkpoint that was stored in the database and continue the execution. "
"As soon as the process reaches a terminal state, the daemon runner will "
"acknowledge to RabbitMQ that the task has been completed. Until the runner "
"has confirmed that a task is completed, RabbitMQ will consider the task as "
"incomplete. If a daemon runner is shut down or dies before it got the chance"
" to finish running a process, the task will automatically be requeued by "
"RabbitMQ and sent to another daemon runner. Together with the fact that all "
"the tasks in the process queue are persisted to disk by RabbitMQ, guarantees"
" that once a continuation task has been sent to RabbitMQ, it will at some "
"point be finished, while allowing the machine to be shut down."
msgstr ""

#: ../../source/topics/processes/concepts.rst:157
msgid ""
"Each daemon runner has a maximum number of tasks that it can run "
"concurrently, which means that if there are more active tasks than available"
" slots, some of the tasks will remain queued. Processes, whose task is in "
"the queue and not with any runner, though technically 'active' as they are "
"not terminated, are not actually being run at the moment. While a process is"
" not actually being run, i.e. it is not in memory with a runner, one cannot "
"interact with it. Similarly, as soon as the task disappears, either because "
"the process was intentionally terminated (or unintentionally), the process "
"will never continue running again."
msgstr ""
"每一个运行器守护进程有一个可并发任务数上限，该上限约束了同时可运行的任务数量，当一些任务运行时，其他任务处于队列中等待被执行。当一个例程的实际任务处于等待被执行的队列中时，尽管它的状态时"
" activate "
"且没有终止，它也没有被实际运行。这时，因为例程并没有被实际运行，也就是在内存中并没有一个运行器运行它，用户这时不能与其交互。同样的，当例程中的任务退出（有意或无意的），这个例程将不会继续运行。"

#: ../../source/topics/processes/concepts.rst:164
msgid "A systems modelling representation of submitting a process."
msgstr ""

#: ../../source/topics/processes/concepts.rst:170
msgid "Process checkpoints"
msgstr "例程检查点"

#: ../../source/topics/processes/concepts.rst:171
msgid ""
"A process checkpoint is a complete representation of a ``Process`` instance "
"in memory that can be stored in the database. Since it is a complete "
"representation, the ``Process`` instance can also be fully reconstructed "
"from such a checkpoint. At any state transition of a process, a checkpoint "
"will be created, by serializing the process instance and storing it as an "
"attribute on the corresponding process node. This mechanism is the final cog"
" in the machine, together with the persisted process queue of RabbitMQ as "
"explained in the previous section, that allows processes to continue after "
"the machine they were running on, has been shut down and restarted."
msgstr ""

#: ../../source/topics/processes/concepts.rst:180
msgid "Process sealing"
msgstr ""

#: ../../source/topics/processes/concepts.rst:181
msgid ""
"One of the cardinal rules of AiiDA is that once a node is *stored*, it is "
"immutable, which means that its attributes can no longer be changed. This "
"rule is a problem for processes, however, since in order to be able to start"
" running it, its corresponding process node first has to be stored. However,"
" at that point its attributes, such as the process state or other mutable "
"attributes, can no longer be changed by the engine throughout the lifetime "
"of the corresponding process. To overcome this limitation, the concept of "
"*updatable* attributes is introduced. These are special attributes that are "
"allowed to be changed *even* when the process node is already stored *and* "
"the corresponding process is still active. To mark the point where a process"
" is terminated and even the updatable attributes on the process node are to "
"be considered immutable, the node is *sealed*. A sealed process node behaves"
" exactly like a normal stored node, as in *all* of its attributes are "
"immutable. In addition, once a process node is sealed, no more incoming or "
"outgoing links can be attached to it. Unsealed process nodes can also not be"
" exported, because they belong to processes that are still active. Note that"
" the sealing concept does not apply to data nodes and they are exportable as"
" soon as they are stored. To determine whether a process node is sealed, one"
" can use the property :py:attr:`~aiida.orm.utils.mixins.Sealable.is_sealed`."
msgstr ""

#: ../../source/topics/processes/functions.rst:5
msgid "Process functions"
msgstr "例程函数"

#: ../../source/topics/processes/functions.rst:7
msgid ""
"A process function is a process (see the "
":ref:`concepts<topics:processes:concepts>` for a definition and explanation)"
" that is implemented as a decorated python function. Currently, there are "
"two types of process functions:"
msgstr ""

#: ../../source/topics/processes/functions.rst:11
msgid ":ref:`work function<topics:workflows:concepts:workfunctions>`"
msgstr ""

#: ../../source/topics/processes/functions.rst:13
msgid ""
"The former can *create* new data, whereas the latter can orchestrate other "
"processes and *return* their results. This section will provide detailed "
"information and best practices on how to implement these two process types. "
"Since the calculation function and work function are both process functions "
"and have the same implementation, all the rules explained below apply to "
"both process types."
msgstr ""

#: ../../source/topics/processes/functions.rst:17
msgid ""
"The simple example in the :ref:`introductory section on calculation "
"functions<topics:calculations:concepts:calcfunctions>` showed how a simple "
"python function can be turned into a calculation function simply by adorning"
" it with the :py:func:`~aiida.engine.processes.functions.calcfunction` "
"decorator. When the function is run, AiiDA will dynamically generate a "
":py:class:`~aiida.engine.processes.functions.FunctionProcess` and build its "
":ref:`process specification<topics:processes:usage:spec>` based on the "
"function signature. Here we will explain how this is accomplished and what "
"features of the python function signature standard are supported."
msgstr ""

#: ../../source/topics/processes/functions.rst:22
msgid "Function signatures"
msgstr ""

#: ../../source/topics/processes/functions.rst:23
msgid ""
"To explain what features of python function definitions and calls are "
"supported we first need to be clear about some terminology. When dealing "
"with functions, there are two distinct parts:"
msgstr ""

#: ../../source/topics/processes/functions.rst:26
msgid ""
"`function definitions "
"<https://docs.python.org/3/reference/compound_stmts.html#function-"
"definitions>`_"
msgstr ""

#: ../../source/topics/processes/functions.rst:27
msgid ""
"`function calls "
"<https://docs.python.org/3/reference/expressions.html#calls>`_"
msgstr ""

#: ../../source/topics/processes/functions.rst:29
msgid ""
"Consider the following code snippet that defines a simple python function:"
msgstr ""

#: ../../source/topics/processes/functions.rst:34
msgid ""
"The function takes three 'parameters', named ``x``, ``y`` and ``z``. In "
"addition, the function ``plain_function`` is said to have default values, "
"because one or more parameters (``z`` in this case) have the form `parameter"
" = expression`. When *calling* a function, the terminology changes slightly "
"and values for parameters can be passed as either 'positional' or 'keyword'."
" In the example below, the function is called with 'positional' arguments:"
msgstr ""

#: ../../source/topics/processes/functions.rst:42
msgid ""
"They are called positional, because the arguments are not explicitly named "
"and so will be matched to the corresponding parameter solely based on their "
"position in the function call. In this example, ``x``, ``y`` and ``z`` will "
"have the values ``1``, ``2`` and ``3``, respectively. Since we specified "
"three values, the default for the third parameter ``z`` was not actually "
"used. However, we are allowed to only specify two arguments, in which case "
"the default *will* be used as can be seen below:"
msgstr ""

#: ../../source/topics/processes/functions.rst:50
msgid ""
"By not specifying the third argument, the default will be used, so in this "
"case ``z`` will equal ``1``. Additionally, one can employ 'named' arguments "
"to specifically target a parameter based on its name, instead of having to "
"rely on its position:"
msgstr ""

#: ../../source/topics/processes/functions.rst:56
msgid ""
"Notice how the order in which we pass the arguments is irrelevant because we"
" specify the name of each argument explicitly when assigning the value. Now "
"that we know the difference between positional and named arguments, it is "
"important to realize a python requirement that **positional arguments have "
"to come before named arguments**. What this means is that *both* the "
"function definition and function call below are illegal, because there are "
"named arguments before positional ones:"
msgstr ""

#: ../../source/topics/processes/functions.rst:63
msgid ""
"Finally, python knows the concept of ``*args`` and ``**kwargs``, which allow"
" one to define a function that accepts a variable number of positional and "
"keyword arguments (also known as a _variadic_ function)."
msgstr ""

#: ../../source/topics/processes/functions.rst:68
msgid ""
"The placeholder for positional arguments ``*args`` receives the positionally"
" passed arguments as a tuple, while ``**kwargs`` receives the named "
"arguments as a dictionary. With the formal definitions out of the way, let's"
" now see which of these concepts are supported by process functions."
msgstr ""

#: ../../source/topics/processes/functions.rst:72
msgid "Default arguments"
msgstr ""

#: ../../source/topics/processes/functions.rst:73
msgid ""
"Default arguments are supported by calculation functions just as normal "
"python functions as long as it is a :py:class:`~aiida.orm.nodes.node.Node` "
"instance, just like the inputs or ``None``. However, just as with python "
"functions, one should only use immutable objects as function defaults "
"because mutable objects can give unexpected results as they will be kept "
"between function calls. Therefore, in order to use a default value for "
"process functions, simply use ``None`` as the default value and check for "
"its presence in the function body settings the default value if it is "
"``None``. This pattern looks like the following:"
msgstr ""

#: ../../source/topics/processes/functions.rst:81
msgid ""
"Both function calls in the example above will have the exact same result."
msgstr ""

#: ../../source/topics/processes/functions.rst:84
msgid "Variadic arguments"
msgstr ""

#: ../../source/topics/processes/functions.rst:86
msgid ""
"Keyword arguments can be used effectively if a process function should take "
"a number of arguments that is unknown beforehand:"
msgstr ""

#: ../../source/topics/processes/functions.rst:91
msgid "The provenance generated by this example looks like the following:"
msgstr ""

#: ../../source/topics/processes/functions.rst:96
msgid ""
"The link labels of the inputs are determined based on the naming of the "
"parameters when the function is called."
msgstr ""

#: ../../source/topics/processes/functions.rst:98
msgid ""
"Note that the inputs **have to be passed as keyword arguments** because they"
" are used for the link labels."
msgstr ""

#: ../../source/topics/processes/functions.rst:102
msgid "Variadic positional arguments are now supported."
msgstr ""

#: ../../source/topics/processes/functions.rst:104
msgid ""
"Variadic positional arguments can be used in case the function should accept"
" a list of inputs of unknown length. Consider the example of a calculation "
"function that computes the average of a number of ``Int`` nodes:"
msgstr ""

#: ../../source/topics/processes/functions.rst:110
msgid ""
"The result will be a ``Float`` node with value ``2``. Since in this example "
"the arguments are not explicitly declared in the function signature, nor are"
" their values passed with a keyword in the function invocation, AiiDA needs "
"to come up with a different way to determine the labels to link the input "
"nodes to the calculation. For variadic arguments, link labels are created "
"from the variable argument declaration (``*args`` in the example), followed "
"by an index. The link labels for the example above will therefore be "
"``args_0``, ``args_1`` and ``args_2``. If any of these labels were to "
"overlap with the label of a positional or keyword argument, a "
"``RuntimeError`` will be raised. In this case, the conflicting argument name"
" needs to be changed to something that does not overlap with the "
"automatically generated labels for the variadic arguments."
msgstr ""

#: ../../source/topics/processes/functions.rst:120
msgid "Type validation"
msgstr ""

#: ../../source/topics/processes/functions.rst:124
msgid ""
"Type hints (introduced with `PEP 484 <https://peps.python.org/pep-0484/>`_ "
"in Python 3.5) can be used to add automatic type validation of process "
"function arguments. For example, the following will raise a ``ValueError`` "
"exception:"
msgstr ""

#: ../../source/topics/processes/functions.rst:130
msgid ""
"When the process function is declared, the process specification "
"(``ProcessSpec``) is built dynamically. For each function argument, if a "
"correct type hint is provided, it is set as the ``valid_type`` attribute of "
"the corresponding input port. In the example above, the ``x`` and ``y`` "
"inputs have ``Int`` as type hint, which is why the call that passes a "
"``Float`` raises a ``ValueError``."
msgstr ""

#: ../../source/topics/processes/functions.rst:136
msgid "Type hints for return values are currently not parsed."
msgstr ""

#: ../../source/topics/processes/functions.rst:138
msgid ""
"If an argument accepts multiple types, the ``typing.Union`` class can be "
"used as normal:"
msgstr ""

#: ../../source/topics/processes/functions.rst:143
msgid ""
"The call with an ``Int`` and a ``Float`` will now finish correctly. "
"Similarly, optional arguments, with ``None`` as a default, can be declared "
"using ``typing.Optional``:"
msgstr ""

#: ../../source/topics/processes/functions.rst:149
msgid ""
"The `postponed evaluation of annotations introduced by PEP 563 "
"<https://peps.python.org/pep-0563/>`_ is also supported. This means it is "
"possible to use Python base types for the type hint instead of AiiDA's "
"``Data`` node equivalent:"
msgstr ""

#: ../../source/topics/processes/functions.rst:155
msgid ""
"The type hints are automatically serialized just as the actual inputs are "
"when the function is called, :ref:`as introduced in "
"v2.1<topics:calculations:concepts:calcfunctions:automatic-serialization>`."
msgstr ""

#: ../../source/topics/processes/functions.rst:157
msgid ""
"The alternative syntax for union types ``X | Y`` `as introduced by PEP 604 "
"<https://peps.python.org/pep-0604/>`_ is also supported:"
msgstr ""

#: ../../source/topics/processes/functions.rst:164
msgid ""
"The usage of notation as defined by PEP 563 and PEP 604 are not supported "
"for Python versions older than 3.10, even if the ``from __future__ import "
"annotations`` statement is added. The reason is that the type inference uses"
" the `inspect.get_annotations "
"<https://docs.python.org/3/library/inspect.html#inspect.get_annotations>`_ "
"method, which was introduced in Python 3.10. For older Python versions, the "
"`get-annotations <https://pypi.org/project/get-annotations>`_ backport is "
"used, but that does not work with PEP 563 and PEP 604, so the constructs "
"from the ``typing`` module have to be used instead."
msgstr ""

#: ../../source/topics/processes/functions.rst:168
msgid ""
"If a process function has invalid type hints, they will simply be ignored "
"and a warning message is logged: ``function 'function_name' has invalid type"
" hints``. This ensures backwards compatibility in the case existing process "
"functions had invalid type hints."
msgstr ""

#: ../../source/topics/processes/functions.rst:174
msgid "Docstring parsing"
msgstr ""

#: ../../source/topics/processes/functions.rst:178
msgid ""
"If a process function provides a docstring, AiiDA will attempt to parse it. "
"If successful, the function argument descriptions will be set as the "
"``help`` attributes of the input ports of the dynamically generated process "
"specification. This means the descriptions of the function arguments can be "
"retrieved programmatically from the process specification (as returned by "
"the ``spec`` classmethod):"
msgstr ""

#: ../../source/topics/processes/functions.rst:185
msgid ""
"This particularly useful when exposing a process function in a wrapping "
"workchain:"
msgstr ""

#: ../../source/topics/processes/functions.rst:190
msgid ""
"The user can now access the input description directly through the spec of "
"the work chain, without having to go to the process function itself. For "
"example, in an interactive shell:"
msgstr ""

#: ../../source/topics/processes/functions.rst:197
msgid "Return values"
msgstr ""

#: ../../source/topics/processes/functions.rst:198
msgid ""
"In :numref:`fig_calculation_functions_kwargs` you can see that the engine "
"used the label ``result`` for the link connecting the calculation function "
"node with its output node. This is the default link label if only a single "
"result is returned from the calculation function. If you want to specify a "
"label yourself, you can return the result in the form of a dictionary, where"
" the key will be used as the link label. By using a dictionary you can also "
"record multiple nodes as output. Consider the following snippet:"
msgstr ""

#: ../../source/topics/processes/functions.rst:207
msgid ""
"The provenance generated by running this calculation function will look "
"like:"
msgstr ""

#: ../../source/topics/processes/functions.rst:212
msgid ""
"If a dictionary is returned, the keys will be used as the labels for the "
"links that connect the output nodes with the calculation node."
msgstr ""

#: ../../source/topics/processes/functions.rst:214
msgid ""
"As always, all the values returned by a calculation function have to be "
"storable, which means they have to be instances of the "
":py:class:`~aiida.orm.nodes.node.Node` class."
msgstr ""

#: ../../source/topics/processes/functions.rst:217
msgid ""
"It is very important that you **do not call** "
":py:meth:`~aiida.orm.nodes.node.Node.store` **yourself** on the nodes before"
" returning them from a ``calcfunction``. Because of the calculation/workflow"
" duality in AiiDA, a ``calcfunction``, which is a calculation-like process, "
"can only *create* and not *return* data nodes. This means that if a node is "
"returned from a ``calcfunction`` that *is already stored*, the engine will "
"throw an exception."
msgstr ""

#: ../../source/topics/processes/functions.rst:223
msgid "Outputs can be attached with nested namespaces in the output labels:"
msgstr ""

#: ../../source/topics/processes/functions.rst:231
#: ../../source/topics/processes/usage.rst:228
#: ../../source/topics/workflows/usage.rst:108
#: ../../source/topics/workflows/usage.rst:273
msgid "Exit codes"
msgstr ""

#: ../../source/topics/processes/functions.rst:232
msgid ""
"So far we have only seen examples of calculation functions where everything "
"works out just fine. However, the real world is different, and often we will"
" encounter situations where problems arise. A calculation function may "
"receive incorrect or incoherent inputs, or the code it executes may throw an"
" exception. Of course we could throw an input validation exception or not "
"even catch the exceptions that the code we call throws, but that will lead "
"the function process to be put in the ``Excepted`` terminal state. As "
"explained in the :ref:`process state<topics:processes:concepts:state>` "
"section, this state is indeed reserved for processes that incurred an "
"exception during execution. Consider the following calculation function "
"definition and call:"
msgstr ""

#: ../../source/topics/processes/functions.rst:242
msgid ""
"Because the value for ``y`` that is being passed is zero, the engine will "
"encounter a ``ZeroDivisionError`` exception when the calculation function is"
" run. The output of ``verdi process list`` will confirm that the process has"
" excepted:"
msgstr ""

#: ../../source/topics/processes/functions.rst:253
msgid ""
"Exceptions that occur during the execution of a process are recorded as a "
"log message on the corresponding process node. To show these log messages, "
"one can use ``verdi process report``. In the case of the example above, it "
"would look something like the following:"
msgstr ""

#: ../../source/topics/processes/functions.rst:272
msgid ""
"However, in this particular example the exception is not so much an "
"unexpected error, but one we could have considered and have seen coming, so "
"it might be more applicable to simply mark the process as failed. To "
"accomplish this, there is the concept of an :ref:`exit "
"status<topics:processes:concepts:exit_codes>` that can be set on the "
"process, which is an integer that, when non-zero, marks a process in the "
"``Finished`` state as 'failed'. Since the exit status is set as an attribute"
" on the process node, it also makes it very easy to query for failed "
"processes. To set a non-zero exit status on a calculation function to "
"indicate it as failed, simply return an instance of the "
":py:class:`~aiida.engine.processes.exit_code.ExitCode` class. Time for a "
"demonstration:"
msgstr ""

#: ../../source/topics/processes/functions.rst:281
msgid ""
"When we run the calculation function now, with the same inputs, instead of "
"excepting, the process will successfully terminate and its exit status will "
"be set to the value stored in the ``ExitCode``. The exit status is also "
"displayed by ``verdi process list``:"
msgstr ""

#: ../../source/topics/processes/functions.rst:293
msgid ""
"Both approaches are valid and which one to use depends on your use case. The"
" question you should ask yourself is whether a potential problem merits "
"throwing the process on the pile of 'excepted' processes. Or maybe, as in "
"the example above, the problem is easily foreseeable and classifiable with a"
" well defined exit status, in which case it might make more sense to return "
"the exit code. At the end one should think which solution makes it easier "
"for a workflow calling the function to respond based on the result and what "
"makes it easier to query for these specific failure modes."
msgstr ""

#: ../../source/topics/processes/functions.rst:299
msgid "As class member methods"
msgstr ""

#: ../../source/topics/processes/functions.rst:303
msgid ""
"Process functions can also be declared as class member methods, for example "
"as part of a "
":class:`~aiida.engine.processes.workchains.workchain.WorkChain`:"
msgstr ""

#: ../../source/topics/processes/functions.rst:327
msgid ""
"In this example, the work chain declares a class method called "
"``compute_sum`` which is decorated with the ``calcfunction`` decorator to "
"turn it into a calculation function. It is important that the method is also"
" decorated with the ``staticmethod`` (see the `Python documentation "
"<https://docs.python.org/3/library/functions.html#staticmethod>`_) such that"
" the work chain instance is not passed when the method is invoked. The "
"calcfunction can be called from a work chain step like any other class "
"method, as is shown in the last line."
msgstr ""

#: ../../source/topics/processes/functions.rst:333
#: ../../source/topics/provenance/index.rst:5
msgid "Provenance"
msgstr "可验证性（Provenance）"

#: ../../source/topics/processes/functions.rst:334
msgid ""
"In addition to the basic attributes that are stored for all processes such "
"as the process state and label, the process functions automatically store "
"additional information that relates to the source code of the function they "
"represent:"
msgstr ""

#: ../../source/topics/processes/functions.rst:336
msgid "Function name"
msgstr "函数名"

#: ../../source/topics/processes/functions.rst:337
msgid "Function namespace"
msgstr "函数命名空间"

#: ../../source/topics/processes/functions.rst:338
msgid "Function starting line number"
msgstr "函数起始行号"

#: ../../source/topics/processes/functions.rst:339
msgid "Function source file"
msgstr "函数源文件"

#: ../../source/topics/processes/functions.rst:341
msgid ""
"The first three are retrieved by inspecting the python source code as soon "
"as the process function is executed and are stored as attributes on the "
"process node. They can be accessed through the corresponding properties on "
"the process node as follows:"
msgstr ""

#: ../../source/topics/processes/functions.rst:347
msgid ""
"The source code of the file in which the function is defined is also stored,"
" but since it can be quite big, it is stored as a raw file in the repository"
" of the process node. It can be retrieved through the "
":py:meth:`~aiida.orm.utils.mixins.FunctionCalculationMixin.get_function_source_code`"
" method."
msgstr ""

#: ../../source/topics/processes/functions.rst:350
msgid ""
"The attributes give some querability to the process functions stored in the "
"provenance graph and by storing the source code of the function that was "
"executed, there will be some reference in the future to track how the "
"function created its output nodes. Note, however, that just storing the "
"source file of the function does not guarantee that one can reproduce the "
"exact result. For example, one can 'leak' data into the function by reading "
"a file or loading an existing node from the database that was not explicitly"
" passed as an input. Alternatively, external code can be imported and "
"called, the source code of which will not be recorded."
msgstr ""

#: ../../source/topics/processes/functions.rst:356
msgid "Reproducibility guidelines"
msgstr "如何保证重现性指南"

#: ../../source/topics/processes/functions.rst:357
msgid ""
"Due to the nature of the way process functions are implemented, it is "
"impossible to guarantee 100% reproducibility, but by following the following"
" guidelines, one can come as close as possible."
msgstr ""

#: ../../source/topics/processes/functions.rst:359
msgid "Do not leak data into functions"
msgstr "不要将数据泄漏到函数中"

#: ../../source/topics/processes/functions.rst:360
msgid "Limit importing of external code"
msgstr "限制导入外部计算代码"

#: ../../source/topics/processes/functions.rst:361
msgid "Keep functions self-consistent and in separate files"
msgstr "保持函数自洽并在单独的文件中"

#: ../../source/topics/processes/functions.rst:363
msgid ""
"Leaking data into functions is accomplished for example by reading a file on"
" the local file system in the function body and using its contents for the "
"creation of the outputs. Even if you store the source code, if you don't "
"possess the file that was read, it is impossible to reproduce the results. "
"Likewise, you should not load any existing data from the database through "
"the API, but rather they should be direct inputs of the process function."
msgstr ""

#: ../../source/topics/processes/functions.rst:367
msgid ""
"A similar problem occurs when importing other python code. Practically, it "
"is almost impossible to never import code into process functions, as this "
"would force massive code duplication. However, there is still a difference "
"between importing code from the ``aiida-core`` library or the repository in "
"which the process function is hosted, and the importing of a local python "
"file. Even though for both cases there can no be guarantee of "
"reproducibility, the former stands a better chance by far, as the version "
"number of the plugin package should be recorded. The rule of thumb then is "
"to keep the importing of code to a minimum, but if you have to, make sure to"
" make it part of a plugin package with a well-defined version number."
msgstr ""

#: ../../source/topics/processes/functions.rst:373
msgid ""
"Finally, as mentioned in the introduction, the source file of a process "
"function is stored as a file in the repository for *each execution*. "
"Currently there is no automatic deduplication for identical files by the "
"engine, so these files may occupy quite a bit of space. For this reason it "
"is advisable to keep each process function in its own separate file. This "
"not only improves readability, but it also minimizes the impact on the size "
"of the file repository."
msgstr ""

#: ../../source/topics/processes/index.rst:5
msgid "Processes"
msgstr "例程"

#: ../../source/topics/processes/index.rst:7
msgid ""
"This topic section provides extensive and detailed information on the "
"concept of processes in AiiDA and how to work with them. Since the concepts "
"explained here apply to processes in general, they also apply to its "
"subtypes: calculations and workflows. Information specific to each subtype "
"can be found in the topic sections on :ref:`calculations "
"<topics:calculations>` and :ref:`workflows <topics:workflows>`, "
"respectively."
msgstr ""

#: ../../source/topics/processes/usage.rst:7
msgid ""
"This chapter assumes knowledge of the previous section on the :ref:`basic "
"concept of processes<topics:workflows:concepts>`."
msgstr ""

#: ../../source/topics/processes/usage.rst:9
msgid ""
"This section will explain the aspects of working with processes that apply "
"to all processes. Details that only pertain to a specific sub type of "
"process, will be documented in their respective sections:"
msgstr ""

#: ../../source/topics/processes/usage.rst:12
msgid ":ref:`calculation functions<topics:calculations:usage:calcfunctions>`"
msgstr ""

#: ../../source/topics/processes/usage.rst:13
msgid ":ref:`calculation jobs<topics:calculations:usage:calcjobs>`"
msgstr ""

#: ../../source/topics/processes/usage.rst:14
msgid ":ref:`work functions<topics:workflows:usage:workfunctions>`"
msgstr ""

#: ../../source/topics/processes/usage.rst:15
msgid ":ref:`work chains<topics:workflows:usage:workchains>`"
msgstr ""

#: ../../source/topics/processes/usage.rst:21
msgid "Defining processes"
msgstr "定义例程"

#: ../../source/topics/processes/usage.rst:26
msgid "Process specification"
msgstr "例程规格"

#: ../../source/topics/processes/usage.rst:27
msgid ""
"How a process defines the inputs that it requires or can optionally take, "
"depends on the process type. The inputs of "
":py:class:`~aiida.engine.processes.calcjobs.calcjob.CalcJob` and "
":py:class:`~aiida.engine.processes.workchains.workchain.WorkChain` are given"
" by the :py:class:`~aiida.engine.processes.process_spec.ProcessSpec` class, "
"which is defined though  the "
":py:meth:`~aiida.engine.processes.process.Process.define` method. For "
"process functions, the "
":py:class:`~aiida.engine.processes.process_spec.ProcessSpec` is dynamically "
"generated by the engine from the signature of the decorated function. "
"Therefore, to determine what inputs a process takes, one simply has to look "
"at the process specification in the ``define`` method or the function "
"signature. For the "
":py:class:`~aiida.engine.processes.calcjobs.calcjob.CalcJob` and "
":py:class:`~aiida.engine.processes.workchains.workchain.WorkChain` there is "
"also the concept of the :ref:`process "
"builder<topics:processes:usage:builder>`, which will allow one to inspect "
"the inputs with tab-completion and help strings in the shell."
msgstr ""

#: ../../source/topics/processes/usage.rst:33
msgid ""
"The three most important attributes of the "
":py:class:`~aiida.engine.processes.process_spec.ProcessSpec` are:"
msgstr ""

#: ../../source/topics/processes/usage.rst:35
msgid "``inputs``"
msgstr "``inputs``"

#: ../../source/topics/processes/usage.rst:36
msgid "``outputs``"
msgstr "``outputs``"

#: ../../source/topics/processes/usage.rst:37
msgid "``exit_codes``"
msgstr "``exit_codes``"

#: ../../source/topics/processes/usage.rst:39
msgid ""
"Through these attributes, one can define what inputs a process takes, what "
"outputs it will produce and what potential exit codes it can return in case "
"of errors. Just by looking at a process specification then, one will know "
"exactly *what* will happen, just not *how* it will happen. The ``inputs`` "
"and ``outputs`` attributes are *namespaces* that contain so called *ports*, "
"each one of which represents a specific input or output. The namespaces can "
"be arbitrarily nested with ports and so are called *port namespaces*. The "
"port and port namespace are implemented by the :py:class:`~plumpy.Port` and "
":py:class:`~aiida.engine.processes.ports.PortNamespace` class, respectively."
msgstr ""

#: ../../source/topics/processes/usage.rst:49
msgid "Ports and Port namespaces"
msgstr "端口和端口命名空间"

#: ../../source/topics/processes/usage.rst:50
msgid ""
"To define an input for a process specification, we only need to add a port "
"to the ``inputs`` port namespace, as follows:"
msgstr ""

#: ../../source/topics/processes/usage.rst:57
msgid ""
"The ``input`` method, will create an instance of "
":py:class:`~aiida.engine.processes.ports.InputPort`, a sub class of the base"
" :py:class:`~plumpy.Port`, and will add it to the ``inputs`` port namespace "
"of the spec. Creating an output is just as easy, but one should use the "
":py:meth:`~plumpy.ProcessSpec.output` method instead:"
msgstr ""

#: ../../source/topics/processes/usage.rst:65
msgid ""
"This will cause an instance of "
":py:class:`~aiida.engine.processes.ports.CalcJobOutputPort`, also a sub "
"class of the base :py:class:`~plumpy.Port`, to be created and to be added to"
" the ``outputs`` specifcation attribute. Recall, that the ``inputs`` and "
"``output`` are instances of a "
":py:class:`~aiida.engine.processes.ports.PortNamespace`, which means that "
"they can contain any port. But the "
":py:class:`~aiida.engine.processes.ports.PortNamespace` itself is also a "
"port itself, so it can be added to another port namespace, allowing one to "
"create nested port namespaces. Creating a new namespace in for example the "
"inputs namespace is as simple as:"
msgstr ""

#: ../../source/topics/processes/usage.rst:75
msgid ""
"This will create a new ``PortNamespace`` named ``namespace`` in the "
"``inputs`` namespace of the spec. You can create arbitrarily nested "
"namespaces in one statement, by separating them with a ``.`` as shown here:"
msgstr ""

#: ../../source/topics/processes/usage.rst:83
msgid ""
"This command will result in the ``PortNamespace`` name ``namespace`` to be "
"nested inside another ``PortNamespace`` called ``nested``."
msgstr ""

#: ../../source/topics/processes/usage.rst:87
msgid ""
"Because the period is reserved to denote different nested namespaces, it "
"cannot be used in the name of terminal input and output ports as that could "
"be misinterpreted later as a port nested in a namespace."
msgstr ""

#: ../../source/topics/processes/usage.rst:89
msgid ""
"Graphically, this can be visualized as a nested dictionary and will look "
"like the following:"
msgstr ""

#: ../../source/topics/processes/usage.rst:99
msgid ""
"The ``outputs`` attribute of the ``ProcessSpec`` is also a ``PortNamespace``"
" just as the ``inputs``, with the only different that it will create "
"``OutputPort`` instead of ``InputPort`` instances. Therefore the same "
"concept of nesting through ``PortNamespaces`` applies to the outputs of a "
"``ProcessSpec``."
msgstr ""

#: ../../source/topics/processes/usage.rst:106
msgid "Validation and defaults"
msgstr "自动校验和默认值"

#: ../../source/topics/processes/usage.rst:107
msgid ""
"In the previous section, we saw that the ``ProcessSpec`` uses the "
"``PortNamespace``, ``InputPort`` and ``OutputPort`` to define the inputs and"
" outputs structure of the ``Process``. The underlying concept that allows "
"this nesting of ports is that the ``PortNamespace``, ``InputPort`` and "
"``OutputPort``, are all a subclass of :py:class:`~plumpy.ports.Port`. And as"
" different subclasses of the same class, they have more properties and "
"attributes in common, for example related to the concept of validation and "
"default values. All three have the following attributes (with the exception "
"of the ``OutputPort`` not having a ``default`` attribute):"
msgstr ""

#: ../../source/topics/processes/usage.rst:112
msgid "``default``"
msgstr "``default``"

#: ../../source/topics/processes/usage.rst:113
msgid "``required``"
msgstr "``required``"

#: ../../source/topics/processes/usage.rst:114
msgid "``valid_type``"
msgstr "``valid_type``"

#: ../../source/topics/processes/usage.rst:115
msgid "``validator``"
msgstr "``validator``"

#: ../../source/topics/processes/usage.rst:117
msgid ""
"These attributes can all be set upon construction of the port or after the "
"fact, as long as the spec has not been sealed, which means that they can be "
"altered without limit as long as it is within the ``define`` method of the "
"corresponding ``Process``. An example input port that explicitly sets all "
"these attributes is the following:"
msgstr ""

#: ../../source/topics/processes/usage.rst:124
msgid ""
"Here we define an input named ``positive_number`` that should be of type "
"``Int`` or ``Float`` and should pass the test of the ``is_number_positive`` "
"validator. If no value is passed, the default will be used."
msgstr ""

#: ../../source/topics/processes/usage.rst:129
msgid ""
"In python, it is good practice to avoid mutable defaults for function "
"arguments, `since they are instantiated at function definition and reused "
"for each invocation "
"<https://docs.python.org/3/reference/compound_stmts.html#function-"
"definitions>`_. This can lead to unexpected results when the default value "
"is changed between function calls. In the context of AiiDA, nodes (both "
"stored and unstored) are considered *mutable* and should therefore *not* be "
"used as default values for process ports. However, it is possible to use a "
"lambda that returns a node instance as done in the example above. This will "
"return a new instance of the node with the given value, each time the "
"process is instantiated."
msgstr ""

#: ../../source/topics/processes/usage.rst:135
msgid ""
"Note that the validator is nothing more than a free function which takes a "
"single argument, being the value that is to be validated. If nothing is "
"returned, the value is considered to be valid. To signal that the value is "
"invalid and to have a validation error raised, simply return a string with "
"the validation error message, for example:"
msgstr ""

#: ../../source/topics/processes/usage.rst:145
msgid ""
"The ``valid_type`` can define a single type, or a tuple of valid types."
msgstr ""

#: ../../source/topics/processes/usage.rst:149
msgid ""
"If a port is marked as optional through ``required=False`` and defines "
"``valid_type``, the port will also accept ``None`` as values, whereas before"
" this would raise validation error. This is accomplished by automatically "
"adding the ``NoneType`` to the ``valid_type`` tuple. Ports that do not "
"define a ``valid_type`` are not affected."
msgstr ""

#: ../../source/topics/processes/usage.rst:155
msgid ""
"Note that by default all ports are required, but specifying a default value "
"implies that the input is not required and as such specifying "
"``required=False`` is not necessary in that case. It was added to the "
"example above simply for clarity."
msgstr ""

#: ../../source/topics/processes/usage.rst:158
msgid ""
"The validation of input or output values with respect to the specification "
"of the corresponding port, happens at the instantiation of the process and "
"when it is finalized, respectively. If the inputs are invalid, a "
"corresponding exception will be thrown and the process instantiation will "
"fail. When the outputs fail to be validated, likewise an exception will be "
"thrown and the process state will be set to ``Excepted``."
msgstr ""

#: ../../source/topics/processes/usage.rst:166
msgid "Dynamic namespaces"
msgstr "动态命名空间"

#: ../../source/topics/processes/usage.rst:167
msgid ""
"In the previous section we described the various attributes related to "
"validation and claimed that all the port variants share those attributes, "
"yet we only discussed the ``InputPort`` and ``OutputPort`` explicitly. The "
"statement, however, is still correct and the ``PortNamespace`` has the same "
"attributes. You might then wonder what the meaning is of a ``valid_type`` or"
" ``default`` for a ``PortNamespace`` if all it does is contain "
"``InputPorts``, ``OutputPorts`` or other ``PortNamespaces``. The answer to "
"this question lies in the ``PortNamespace`` attribute ``dynamic``."
msgstr ""

#: ../../source/topics/processes/usage.rst:172
msgid ""
"Often when designing the specification of a ``Process``, we cannot know "
"exactly which inputs we want to be able to pass to the process. However, "
"with the concept of the ``InputPort`` and ``OutputPort`` one *does* need to "
"know exactly, how many values one expects at least, as they do have to be "
"defined. This is where the ``dynamic`` attribute of the ``PortNamespace`` "
"comes in. By default this is set to ``False``, but by setting it to "
"``True``, one indicates that that namespace can take a number of values that"
" is unknown at the time of definition of the specification. This now "
"explains the meaning of the ``valid_type``, ``validator`` and ``default`` "
"attributes in the context of the ``PortNamespace``. If you do mark a "
"namespace as dynamic, you may still want to limit the set of values that are"
" acceptable, which you can do by specifying the valid type and or validator."
" The values that will eventually be passed to the port namespace will then "
"be validated according to these rules exactly as a value for a regular input"
" port would be."
msgstr ""

#: ../../source/topics/processes/usage.rst:184
msgid "Non storable inputs"
msgstr "不存取的输入"

#: ../../source/topics/processes/usage.rst:185
msgid ""
"In principle, the only valid types for inputs and outputs should be "
"instances of a :py:class:`~aiida.orm.nodes.data.data.Data` node, or one of "
"its sub classes, as that is the only data type that can be recorded in the "
"provenance graph as an input or output of a process. However, there are "
"cases where you might want to pass an input to a process, whose provenance "
"you do not care about and therefore would want to pass a non-database "
"storable type anyway."
msgstr ""

#: ../../source/topics/processes/usage.rst:190
msgid ""
"AiiDA allows you to break the provenance as to be not too restrictive, but "
"always tries to urge you and guide you in a direction to keep the "
"provenance. There are legitimate reasons to break it regardless, but make "
"sure you think about the implications and whether you are really willing to "
"lose the information."
msgstr ""

#: ../../source/topics/processes/usage.rst:193
msgid ""
"For this situation, the ``InputPort`` has the attribute ``non_db``. By "
"default this is set to ``False``, but by setting it to ``True`` we can "
"indicate that the values that are passed to the port should not be stored as"
" a node in the provenance graph and linked to the process node. This allows "
"one to pass any normal value that one would also be able to pass to a normal"
" function."
msgstr ""

#: ../../source/topics/processes/usage.rst:201
msgid "Automatic input serialization"
msgstr ""

#: ../../source/topics/processes/usage.rst:203
msgid ""
"Quite often, inputs which are given as Python data types need to be cast to "
"the corresponding AiiDA type before passing them to a process. Doing this "
"manually can be cumbersome, so you can define a function when defining the "
"process specification, which does the conversion automatically. This "
"function, passed as ``serializer`` parameter to ``spec.input``, is invoked "
"if the given input is not ``None`` *and* not already an AiiDA type."
msgstr ""

#: ../../source/topics/processes/usage.rst:207
msgid ""
"For inputs which are stored in the database (``non_db=False``), the "
"serialization function should return an AiiDA data type. For ``non_db`` "
"inputs, the function must be idempotent because it might be applied more "
"than once."
msgstr ""

#: ../../source/topics/processes/usage.rst:210
msgid ""
"The following example work chain takes three inputs ``a``, ``b``, ``c``, and"
" simply returns the given inputs. The "
":func:`~aiida.orm.nodes.data.base.to_aiida_type` function is used as "
"serialization function."
msgstr ""

#: ../../source/topics/processes/usage.rst:216
msgid ""
"This work chain can now be called with native Python types, which will "
"automatically be converted to AiiDA types by the "
":func:`~aiida.orm.nodes.data.base.to_aiida_type` function. Note that the "
"module which defines the corresponding AiiDA type must be loaded for it to "
"be recognized by :func:`~aiida.orm.nodes.data.base.to_aiida_type`."
msgstr ""

#: ../../source/topics/processes/usage.rst:222
msgid ""
"Of course, you can also use the serialization feature to perform a more "
"complex serialization of the inputs."
msgstr ""

#: ../../source/topics/processes/usage.rst:229
msgid ""
"Any ``Process`` most likely will have one or multiple expected failure "
"modes. To clearly communicate to the caller what went wrong, the ``Process``"
" supports setting its ``exit_status``. This ``exit_status``, a positive "
"integer, is an attribute of the process node and by convention, when it is "
"zero means the process was successful, whereas any other value indicates "
"failure. This concept of an exit code, with a positive integer as the exit "
"status, `is a common concept in programming "
"<https://en.wikipedia.org/wiki/Exit_status>`_ and a standard way for "
"programs to communicate the result of their execution."
msgstr ""

#: ../../source/topics/processes/usage.rst:234
msgid ""
"Potential exit codes for the ``Process`` can be defined through the "
"``ProcessSpec``, just like inputs and outputs. Any exit code consists of a "
"positive non-zero integer, a string label to reference it and a more "
"detailed description of the problem that triggers the exit code. Consider "
"the following example:"
msgstr ""

#: ../../source/topics/processes/usage.rst:243
msgid ""
"This defines an exit code for the ``Process`` with exit status ``418`` and "
"exit message ``the work chain had an identity crisis``. The string "
"``ERROR_I_AM_A_TEAPOT`` is a label that the developer can use to reference "
"this particular exit code somewhere in the ``Process`` code itself."
msgstr ""

#: ../../source/topics/processes/usage.rst:246
msgid ""
"Whenever a ``Process`` exits through a particular error code, the caller "
"will be able to introspect it through the ``exit_status`` and "
"``exit_message`` attributes of the node. Assume for example that we ran a "
"``Process`` that threw the exit code described above, the caller would be "
"able to do the following:"
msgstr ""

#: ../../source/topics/processes/usage.rst:257
msgid ""
"This is useful, because the caller can now programmatically, based on the "
"``exit_status``, decide how to proceed. This is an infinitely more robust "
"way of communicating specific errors to a non-human than parsing text-based "
"logs or reports. Additionally, the exit codes make it very easy to query for"
" failed processes with specific error codes."
msgstr ""

#: ../../source/topics/processes/usage.rst:263
msgid ""
"Additional documentation, specific to certain process types, can be found in"
" the following sections:"
msgstr ""

#: ../../source/topics/processes/usage.rst:265
msgid ":ref:`Process functions<topics:processes:functions:exit_codes>`"
msgstr ""

#: ../../source/topics/processes/usage.rst:266
msgid ":ref:`Work functions<topics:workflows:usage:workfunctions:exit_codes>`"
msgstr ""

#: ../../source/topics/processes/usage.rst:267
msgid ":ref:`CalcJob parsers<topics:calculations:usage:calcjobs:parsers>`"
msgstr ""

#: ../../source/topics/processes/usage.rst:268
msgid ""
":ref:`Workchain exit code "
"specification<topics:workflows:usage:workchains:define_exit_codes>`"
msgstr ""

#: ../../source/topics/processes/usage.rst:269
msgid ":ref:`External code plugins<how-to:plugin-codes:parsing:errors>`"
msgstr ""

#: ../../source/topics/processes/usage.rst:270
msgid ":ref:`Restart workchains<how-to:restart-workchain>`"
msgstr ""

#: ../../source/topics/processes/usage.rst:275
msgid "Exit code conventions"
msgstr ""

#: ../../source/topics/processes/usage.rst:276
msgid ""
"In principle, the only restriction on the exit status of an exit code is "
"that it should be a positive integer or zero. However, to make effective use"
" of exit codes, there are some guidelines and conventions as to decide what "
"integers to use. Note that since the following rules are *guidelines* you "
"can choose to ignore them and currently the engine will not complain, but "
"this might change in the future. Regardless, we advise you to follow the "
"guidelines since it will improve the interoperability of your code with "
"other existing plugins. The following integer ranges are reserved or "
"suggested:"
msgstr ""

#: ../../source/topics/processes/usage.rst:282
msgid "0 -  99: Reserved for internal use by `aiida-core`"
msgstr ""

#: ../../source/topics/processes/usage.rst:283
msgid ""
"100 - 199: Reserved for errors parsed from scheduler output of calculation "
"jobs (note: this is not yet implemented)"
msgstr ""

#: ../../source/topics/processes/usage.rst:284
msgid "200 - 299: Suggested to be used for process input validation errors"
msgstr ""

#: ../../source/topics/processes/usage.rst:285
msgid "300 - 399: Suggested for critical process errors"
msgstr ""

#: ../../source/topics/processes/usage.rst:287
msgid "For any other exit codes, one can use the integers from 400 and up."
msgstr ""

#: ../../source/topics/processes/usage.rst:293
msgid "Process metadata"
msgstr "例程元数据"

#: ../../source/topics/processes/usage.rst:295
msgid ""
"Each process, in addition to the normal inputs defined through its process "
"specification, can take optional 'metadata'. These metadata differ from "
"inputs in the sense that they are not nodes that will show up as inputs in "
"the provenance graph of the executed process. Rather, these are inputs that "
"slightly modify the behavior of the process or allow to set attributes on "
"the process node that represents its execution. The following metadata "
"inputs are available for *all* process classes:"
msgstr ""

#: ../../source/topics/processes/usage.rst:300
msgid "``label``: will set the label on the ``ProcessNode``"
msgstr ""

#: ../../source/topics/processes/usage.rst:301
msgid "``description``: will set the description on the ``ProcessNode``"
msgstr ""

#: ../../source/topics/processes/usage.rst:302
msgid ""
"``store_provenance``: boolean flag, by default ``True``, that when set to "
"``False``, will ensure that the execution of the process **is not** stored "
"in the provenance graph"
msgstr ""

#: ../../source/topics/processes/usage.rst:304
msgid ""
"Sub classes of the :py:class:`~aiida.engine.processes.process.Process` class"
" can specify further metadata inputs, refer to their specific documentation "
"for details. To pass any of these metadata options to a process, simply pass"
" them in a dictionary under the key ``metadata`` in the inputs when "
"launching the process. How a process can be launched is explained the "
"following section."
msgstr ""

#: ../../source/topics/processes/usage.rst:312
msgid "Launching processes"
msgstr "启动例程"

#: ../../source/topics/processes/usage.rst:313
msgid ""
"Any process can be launched by 'running' or 'submitting' it. Running means "
"to run the process in the current python interpreter in a blocking way, "
"whereas submitting means to send it to a daemon worker over RabbitMQ. For "
"long running processes, such as calculation jobs or complex workflows, it is"
" best advised to submit to the daemon. This has the added benefit that it "
"will directly return control to your interpreter and allow the daemon to "
"save intermediate progress during checkpoints and reload the process from "
"those if it has to restart. Running processes can be useful for trivial "
"computational tasks, such as simple calcfunctions or workfunctions, or for "
"debugging and testing purposes."
msgstr ""

#: ../../source/topics/processes/usage.rst:323
msgid "Process launch"
msgstr "例程启动"

#: ../../source/topics/processes/usage.rst:325
msgid ""
"To launch a process, one can use the free functions that can be imported "
"from the :py:mod:`aiida.engine` module. There are four different functions:"
msgstr ""

#: ../../source/topics/processes/usage.rst:328
msgid ":py:func:`~aiida.engine.launch.run`"
msgstr ":py:func:`~aiida.engine.launch.run`"

#: ../../source/topics/processes/usage.rst:329
msgid ":py:func:`~aiida.engine.launch.run_get_node`"
msgstr ":py:func:`~aiida.engine.launch.run_get_node`"

#: ../../source/topics/processes/usage.rst:330
msgid ":py:func:`~aiida.engine.launch.run_get_pk`"
msgstr ":py:func:`~aiida.engine.launch.run_get_pk`"

#: ../../source/topics/processes/usage.rst:331
msgid ":py:func:`~aiida.engine.launch.submit`"
msgstr ":py:func:`~aiida.engine.launch.submit`"

#: ../../source/topics/processes/usage.rst:333
msgid ""
"As the name suggest, the first three will 'run' the process and the latter "
"will 'submit' it to the daemon. Running means that the process will be "
"executed in the same interpreter in which it is launched, blocking the "
"interpreter, until the process is terminated. Submitting to the daemon, in "
"contrast, means that the process will be sent to the daemon for execution, "
"and the interpreter is released straight away."
msgstr ""

#: ../../source/topics/processes/usage.rst:337
msgid ""
"All functions have the exact same interface ``launch(process, inputs)`` "
"where:"
msgstr ""

#: ../../source/topics/processes/usage.rst:339
msgid "``process`` is the process class or process function to launch"
msgstr ""

#: ../../source/topics/processes/usage.rst:340
msgid "``inputs`` the inputs dictionary to pass to the process."
msgstr ""

#: ../../source/topics/processes/usage.rst:344
msgid ""
"Before AiiDA v2.5, the inputs could only be passed as keyword arguments. "
"This behavior is still supported, e.g., one can launch a process as "
"``launch(process, **inputs)`` or ``launch(process, input_a=value_a, "
"input_b=value_b)``. However, the recommended approach is now to use an input"
" dictionary passed as the second positional argument. The reason is that "
"certain launchers define arguments themselves which can overlap with inputs "
"of the process. For example, the ``submit`` method defines the ``wait`` "
"keyword. If the process being launched *also* defines an input named "
"``wait``, the launcher method cannot tell them apart."
msgstr ""

#: ../../source/topics/processes/usage.rst:351
msgid ""
"What inputs can be passed depends on the exact process class that is to be "
"launched. For example, when we want to run an instance of the "
":py:class:`~aiida.calculations.arithmetic.add.ArithmeticAddCalculation` "
"process, which takes two :py:class:`~aiida.orm.nodes.data.int.Int` nodes as "
"inputs under the name ``x`` and ``y`` [#f1]_, we would do the following:"
msgstr ""

#: ../../source/topics/processes/usage.rst:357
msgid ""
"The function will submit the calculation to the daemon and immediately "
"return control to the interpreter, returning the node that is used to "
"represent the process in the provenance graph."
msgstr ""

#: ../../source/topics/processes/usage.rst:360
msgid ""
"For a process to be submittable, the class or function needs to be "
"importable in the daemon environment by a) giving it an :ref:`associated "
"entry point<how-to:plugin-codes:entry-points>` or b) :ref:`including its "
"module path<how-to:faq:process-not-importable-daemon>` in the ``PYTHONPATH``"
" that the daemon workers will have."
msgstr ""

#: ../../source/topics/processes/usage.rst:364
msgid ""
"Use ``wait=True`` when calling ``submit`` to wait for the process to "
"complete before returning the node. This can be useful for tutorials and "
"demos in interactive notebooks where the user should not continue before the"
" process is done. One could of course also use ``run`` (see below), but then"
" the process would be lost if the interpreter gets accidentally shut down. "
"By using ``submit``, the process is run by the daemon which takes care of "
"saving checkpoints so it can always be restarted in case of problems. If you"
" need to launch multiple processes in parallel and want to wait for all of "
"them to be finished, simply use ``submit`` with the default ``wait=False`` "
"and collect the returned nodes in a list. You can then pass them to "
":func:`aiida.engine.launch.await_processes` which will return once all "
"processes have terminated:"
msgstr ""

#: ../../source/topics/processes/usage.rst:383
msgid ""
"The ``await_processes`` function will loop every ``wait_interval`` seconds "
"and check whether all processes (represented by the ``ProcessNode`` in the "
"``nodes`` list) have terminated."
msgstr ""

#: ../../source/topics/processes/usage.rst:386
msgid "The ``run`` function is called identically:"
msgstr ""

#: ../../source/topics/processes/usage.rst:391
msgid ""
"except that it does not submit the process to the daemon, but executes it in"
" the current interpreter, blocking it until the process is terminated. The "
"return value of the ``run`` function is also **not** the node that "
"represents the executed process, but the results returned by the process, "
"which is a dictionary of the nodes that were produced as outputs. If you "
"would still like to have the process node or the pk of the process node you "
"can use one of the following variants:"
msgstr ""

#: ../../source/topics/processes/usage.rst:398
msgid ""
"Finally, the :py:func:`~aiida.engine.launch.run` launcher has two attributes"
" ``get_node`` and ``get_pk`` that are simple proxies to the "
":py:func:`~aiida.engine.launch.run_get_node` and "
":py:func:`~aiida.engine.launch.run_get_pk` methods. This is a handy "
"shortcut, as now you can choose to use any of the three variants with just a"
" single import:"
msgstr ""

#: ../../source/topics/processes/usage.rst:404
msgid ""
"If you want to launch a process class that takes a lot more inputs, often it"
" is useful to define them in a dictionary and use the python syntax ``**`` "
"that automatically expands it into keyword argument and value pairs. The "
"examples used above would look like the following:"
msgstr ""

#: ../../source/topics/processes/usage.rst:410
msgid ""
"Process functions, i.e. :ref:`calculation "
"functions<topics:calculations:concepts:calcfunctions>` and :ref:`work "
"functions<topics:workflows:concepts:workfunctions>`, can be launched like "
"any other process as explained above. Process functions have two additional "
"methods of being launched:"
msgstr ""

#: ../../source/topics/processes/usage.rst:413
msgid "Simply *calling* the function"
msgstr "只需*调用*函数"

#: ../../source/topics/processes/usage.rst:414
msgid "Using the internal run method attributes"
msgstr "使用内部运行方法的属性"

#: ../../source/topics/processes/usage.rst:416
msgid ""
"Using a calculation function to add two numbers as an example, these two "
"methods look like the following:"
msgstr ""

#: ../../source/topics/processes/usage.rst:425
msgid "Process builder"
msgstr "例程构建器"

#: ../../source/topics/processes/usage.rst:426
msgid ""
"As explained in a :ref:`previous section<topics:processes:usage:spec>`, the "
"inputs for a :py:class:`~aiida.engine.processes.calcjobs.calcjob.CalcJob` "
"and :py:class:`~aiida.engine.processes.workchains.workchain.WorkChain` are "
"defined in the :py:meth:`~aiida.engine.processes.process.Process.define` "
"method. To know what inputs they take, one would have to read the "
"implementation, which can be annoying if you are not a developer. To "
"simplify this process, these two process classes provide a utility called "
"the 'process builder'. The process builder is essentially a tool that helps "
"you build the inputs for the specific process class that you want to run. To"
" get a *builder* for a particular ``CalcJob`` or a ``WorkChain`` "
"implementation, all you need is the class itself, which can be loaded "
"through the :py:class:`~aiida.plugins.factories.CalculationFactory` and "
":py:class:`~aiida.plugins.factories.WorkflowFactory`, respectively. Let's "
"take the "
":py:class:`~aiida.calculations.arithmetic.add.ArithmeticAddCalculation` as "
"an example::"
msgstr ""

#: ../../source/topics/processes/usage.rst:436
msgid ""
"The string ``core.arithmetic.add`` is the entry point of the "
"``ArithmeticAddCalculation`` and passing it to the ``CalculationFactory`` "
"will return the corresponding class. Calling the ``get_builder`` method on "
"that class will return an instance of the "
":py:class:`~aiida.engine.processes.builder.ProcessBuilder` class that is "
"tailored for the ``ArithmeticAddCalculation``. The builder will help you in "
"defining the inputs that the ``ArithmeticAddCalculation`` requires and has a"
" few handy tools to simplify this process."
msgstr ""

#: ../../source/topics/processes/usage.rst:440
msgid ""
"To find out which inputs the builder exposes, you can simply use tab "
"completion. In an interactive python shell, by simply typing ``builder.`` "
"and hitting the tab key, a complete list of all the available inputs will be"
" shown. Each input of the builder can also show additional information about"
" what sort of input it expects. In an interactive shell, you can get this "
"information to display as follows::"
msgstr ""

#: ../../source/topics/processes/usage.rst:455
msgid ""
"In the ``Docstring`` you will see a ``help`` string that contains more "
"detailed information about the input port. Additionally, it will display a "
"``valid_type``, which when defined shows which data types are expected. If a"
" default value has been defined, that will also be displayed. The ``non_db``"
" attribute defines whether that particular input will be stored as a proper "
"input node in the database, if the process is submitted."
msgstr ""

#: ../../source/topics/processes/usage.rst:460
msgid ""
"Defining an input through the builder is as simple as assigning a value to "
"the attribute. The following example shows how to set the ``parameters`` "
"input, as well as the ``description`` and ``label`` metadata inputs::"
msgstr ""

#: ../../source/topics/processes/usage.rst:468
msgid ""
"If you evaluate the ``builder`` instance, simply by typing the variable name"
" and hitting enter, the current values of the builder's inputs will be "
"displayed::"
msgstr ""

#: ../../source/topics/processes/usage.rst:481
msgid ""
"In this example, you can see the value that we just set for the "
"``description`` and the ``label``. In addition, it will also show any "
"namespaces, as the inputs of processes support nested namespaces, such as "
"the ``metadata.options`` namespace in this example. Note that nested "
"namespaces are also all autocompleted, and you can traverse them recursively"
" with tab-completion."
msgstr ""

#: ../../source/topics/processes/usage.rst:485
msgid ""
"All that remains is to fill in all the required inputs and we are ready to "
"launch the process builder. When all the inputs have been defined for the "
"builder, it can be used to actually launch the ``Process``. The process can "
"be launched by passing the builder to any of the free functions "
":py:mod:`~aiida.engine.launch` module, just as you would do a normal process"
" as :ref:`described above<topics:processes:usage:launching>`, i.e.:"
msgstr ""

#: ../../source/topics/processes/usage.rst:492
msgid ""
"Note that the process builder is in principle designed to be used in an "
"interactive shell, as there is where the tab-completion and automatic input "
"documentation really shines. However, it is perfectly possible to use the "
"same builder in scripts where you simply use it as an input container, "
"instead of a plain python dictionary."
msgstr ""

#: ../../source/topics/processes/usage.rst:499
msgid "Monitoring processes"
msgstr "监控例程"

#: ../../source/topics/processes/usage.rst:500
msgid ""
"When you have launched a process, you may want to investigate its status, "
"progression and the results. The :ref:`verdi<reference:command-line>` "
"command line tool provides various commands to do just this."
msgstr ""

#: ../../source/topics/processes/usage.rst:507
msgid "verdi process list"
msgstr "verdi process list"

#: ../../source/topics/processes/usage.rst:508
msgid ""
"Your first point of entry will be the ``verdi`` command ``verdi process "
"list``. This command will print a list of all active processes through the "
"``ProcessNode`` stored in the database that it uses to represent its "
"execution. A typical example may look something like the following:"
msgstr ""

#: ../../source/topics/processes/usage.rst:522
msgid ""
"The 'State' column is a concatenation of the ``process_state`` and the "
"``exit_status`` of the ``ProcessNode``. By default, the command will only "
"show active items, i.e. ``ProcessNodes`` that have not yet reached a "
"terminal state. If you want to also show the nodes in a terminal states, you"
" can use the ``-a`` flag and call ``verdi process list -a``:"
msgstr ""

#: ../../source/topics/processes/usage.rst:538
msgid ""
"For more information on the meaning of the 'state' column, please refer to "
"the documentation of the :ref:`process state "
"<topics:processes:concepts:state>`. The ``-S`` flag let's you query for "
"specific process states, i.e. issuing ``verdi process list -S created`` will"
" return:"
msgstr ""

#: ../../source/topics/processes/usage.rst:550
msgid ""
"To query for a specific exit status, one can use ``verdi process list -E "
"0``:"
msgstr ""

#: ../../source/topics/processes/usage.rst:562
msgid ""
"This simple tool should give you a good idea of the current status of "
"running processes and the status of terminated ones. For a complete list of "
"all the available options, please refer to the documentation of :ref:`verdi "
"process<reference:command-line:verdi-process>`."
msgstr ""

#: ../../source/topics/processes/usage.rst:565
msgid ""
"If you are looking for information about a specific process node, the "
"following three commands are at your disposal:"
msgstr ""

#: ../../source/topics/processes/usage.rst:567
msgid ""
"``verdi process report`` gives a list of the log messages attached to the "
"process"
msgstr ""

#: ../../source/topics/processes/usage.rst:568
msgid ""
"``verdi process status`` print the call hierarchy of the process and status "
"of all its nodes"
msgstr ""

#: ../../source/topics/processes/usage.rst:569
msgid ""
"``verdi process show`` print details about the status, inputs, outputs, "
"callers and callees of the process"
msgstr ""

#: ../../source/topics/processes/usage.rst:571
msgid ""
"In the following sections, we will explain briefly how the commands work. "
"For the purpose of example, we will show the output of the commands for a "
"completed ``PwBaseWorkChain`` from the ``aiida-quantumespresso`` plugin, "
"which simply calls a ``PwCalculation``."
msgstr ""

#: ../../source/topics/processes/usage.rst:578
msgid "verdi process report"
msgstr "verdi process report"

#: ../../source/topics/processes/usage.rst:579
msgid ""
"The developer of a process can attach log messages to the node of a process "
"through the :py:meth:`~aiida.engine.processes.process.Process.report` "
"method. The ``verdi process report`` command will display all the log "
"messages in chronological order:"
msgstr ""

#: ../../source/topics/processes/usage.rst:589
msgid ""
"The log message will include a timestamp followed by the level of the log, "
"which is always ``REPORT``. The second block has the format ``pk|class "
"name|function name`` detailing information about, in this case, the work "
"chain itself and the step in which the message was fired. Finally, the "
"message itself is displayed. Of course how many messages are logged and how "
"useful they are is up to the process developer. In general they can be very "
"useful for a user to understand what has happened during the execution of "
"the process, however, one has to realize that each entry is stored in the "
"database, so overuse can unnecessarily bloat the database."
msgstr ""

#: ../../source/topics/processes/usage.rst:599
msgid "verdi process status"
msgstr "verdi process status"

#: ../../source/topics/processes/usage.rst:600
msgid ""
"This command is most useful for ``WorkChain`` instances, but also works for "
"``CalcJobs``. One of the more powerful aspects of work chains, is that they "
"can call ``CalcJobs`` and other ``WorkChains`` to create a nested call "
"hierarchy. If you want to inspect the status of a work chain and all the "
"children that it called, ``verdi process status`` is the go-to tool. An "
"example output is the following:"
msgstr ""

#: ../../source/topics/processes/usage.rst:610
msgid ""
"The command prints a tree representation of the hierarchical call structure,"
" that recurses all the way down. In this example, there is just a single "
"``PwBaseWorkChain`` which called a ``PwCalculation``, which is indicated by "
"it being indented one level. In addition to the call tree, each node also "
"shows its current process state and for work chains at which step in the "
"outline it is. This tool can be very useful to inspect while a work chain is"
" running at which step in the outline it currently is, as well as the status"
" of all the children calculations it called."
msgstr ""

#: ../../source/topics/processes/usage.rst:619
msgid "verdi process show"
msgstr "verdi process show"

#: ../../source/topics/processes/usage.rst:620
msgid ""
"Finally, there is a command that displays detailed information about the "
"``ProcessNode``, such as its inputs, outputs and the optional other "
"processes it called and or was called by. An example output for a "
"``PwBaseWorkChain`` would look like the following:"
msgstr ""

#: ../../source/topics/processes/usage.rst:664
msgid ""
"This overview should give you all the information if you want to inspect a "
"process' inputs and outputs in closer detail as it provides you their pk's."
msgstr ""

#: ../../source/topics/processes/usage.rst:670
msgid "Manipulating processes"
msgstr "操控例程"

#: ../../source/topics/processes/usage.rst:671
msgid ""
"To understand how one can manipulate running processes, one has to "
"understand the principles of the :ref:`process/node "
"distinction<topics:processes:concepts:node_distinction>` and a "
":ref:`process' lifetime<topics:processes:concepts:lifetime>` first, so be "
"sure to have read those sections first."
msgstr ""

#: ../../source/topics/processes/usage.rst:677
msgid "verdi process pause/play/kill"
msgstr "verdi process pause/play/kill"

#: ../../source/topics/processes/usage.rst:678
msgid ""
"The ``verdi`` command line interface provides three commands to interact "
"with 'live' processes."
msgstr ""

#: ../../source/topics/processes/usage.rst:680
msgid "``verdi process pause``"
msgstr "``verdi process pause``"

#: ../../source/topics/processes/usage.rst:681
msgid "``verdi process play``"
msgstr "``verdi process play``"

#: ../../source/topics/processes/usage.rst:682
msgid "``verdi process kill``"
msgstr "``verdi process kill``"

#: ../../source/topics/processes/usage.rst:684
msgid ""
"The first pauses a process temporarily, the second resumes any paused "
"processes and the third one permanently kills them. The sub command names "
"might seem to tell you this already and it might look like that is all there"
" is to know, but the functionality underneath is quite complicated and "
"deserves additional explanation nonetheless."
msgstr ""

#: ../../source/topics/processes/usage.rst:687
msgid ""
"As the section on :ref:`the distinction between the process and the "
"node<topics:processes:concepts:node_distinction>` explained, manipulating a "
"process means interacting with the live process instance that lives in the "
"memory of the runner that is running it. By definition, these runners will "
"always run in a different system process than the one from which you want to"
" interact, because otherwise, you would *be* the runner, given that there "
"can only be a single runner in an interpreter and if it is running, the "
"interpreter would be blocked from performing any other operations. This "
"means that in order to interact with the live process, one has to interact "
"with another interpreter running in a different system process. This is once"
" again facilitated by the RabbitMQ message broker. When a runner starts to "
"run a process, it will also add listeners for incoming messages that are "
"being sent for that specific process over RabbitMQ."
msgstr ""

#: ../../source/topics/processes/usage.rst:695
msgid ""
"This does not just apply to daemon runners, but also normal runners. That is"
" to say that if you were to launch a process in a local runner, that "
"interpreter will be blocked, but it will still setup the listeners for that "
"process on RabbitMQ. This means that you can manipulate the process from "
"another terminal, just as if you would do with a process that is being run "
"by a daemon runner."
msgstr ""

#: ../../source/topics/processes/usage.rst:699
msgid ""
"In the case of 'pause', 'play' and 'kill', one is sending what is called a "
"Remote Procedure Call (RPC) over RabbitMQ. The RPC will include the process "
"identifier for which the action is intended and RabbitMQ will send it to "
"whoever registered itself to be listening for that specific process, in this"
" case the runner that is running the process. This immediately reveals a "
"potential problem: the RPC will fall on deaf ears if there is no one "
"listening, which can have multiple causes. For example, as explained in the "
"section on a :ref:`process' lifetime<topics:processes:concepts:lifetime>`, "
"this can be the case for a submitted process, where the corresponding task "
"is still queued, as all available process slots are occupied. But even if "
"the task *were* to be with a runner, it might be too busy to respond to the "
"RPC and the process appears to be unreachable. Whenever a process is "
"unreachable for an RPC, the command will return an error:"
msgstr ""

#: ../../source/topics/processes/usage.rst:710
msgid ""
"Depending on the cause of the process being unreachable, the problem may "
"resolve itself automatically over time and one can try again at a later "
"time, as for example in the case of the runner being too busy to respond. "
"However, to prevent this from happening, the runner has been designed to "
"have the communication happen over a separate thread and to schedule "
"callbacks for any necessary actions on the main thread, which performs all "
"the heavy lifting. This should make occurrences of the runner being too busy"
" to respond very rare. However, there is unfortunately no way of telling "
"what the actual problem is for the process not being reachable. The problem "
"will manifest itself identically if the runner just could not respond in "
"time or if the task has accidentally been lost forever due to a bug, even "
"though these are two completely separate situations."
msgstr ""

#: ../../source/topics/processes/usage.rst:716
msgid ""
"This brings us to another potential unintuitive aspect of interacting with "
"processes. The previous paragraph already mentioned it in passing, but when "
"a remote procedure call is sent, it first needs to be answered by the "
"responsible runner, if applicable, but it will not *directly execute* the "
"call. This is because the call will be incoming on the communcation thread "
"who is not allowed to have direct access to the process instance, but "
"instead it will schedule a callback on the main thread who can perform the "
"action. The callback will however not necessarily be executed directly, as "
"there may be other actions waiting to be performed. So when you pause, play "
"or kill a process, you are not doing so directly, but rather you are "
"*scheduling* a request to do so. If the runner has successfully received the"
" request and scheduled the callback, the command will therefore show "
"something like the following:"
msgstr ""

#: ../../source/topics/processes/usage.rst:727
msgid ""
"The 'scheduled' indicates that the actual killing might not necessarily have"
" happened just yet. This means that even after having called ``verdi process"
" kill`` and getting the success message, the corresponding process may still"
" be listed as active in the output of ``verdi process list``."
msgstr ""

#: ../../source/topics/processes/usage.rst:730
msgid ""
"By default, the ``pause``, ``play`` and ``kill`` commands will only ask for "
"the confirmation of the runner that the request has been scheduled and not "
"actually wait for the command to have been executed. This is because, as "
"explained, the actual action being performed might not be instantaneous as "
"the runner may be busy working with other processes, which would mean that "
"the command would block for a long time. If you want to send multiple "
"requests to a lot of processes in one go, this would be ineffective, as each"
" one would have to wait for the previous one to be completed. To change the "
"default and actually wait for the action to be completed and await its "
"response, you can use the ``--wait`` flag. If you know that your daemon "
"runners may be experiencing a heavy load, you can also increase the time "
"that the command waits before timing out, with the ``-t/--timeout`` flag."
msgstr ""

#: ../../source/topics/processes/usage.rst:738
#: ../../source/topics/workflows/usage.rst:608
msgid "Footnotes"
msgstr "脚注"

#: ../../source/topics/processes/usage.rst:739
msgid ""
"Note that the "
":py:class:`~aiida.calculations.arithmetic.add.ArithmeticAddCalculation` "
"process class also takes a ``code`` as input, but that has been omitted for "
"the purposes of the example."
msgstr ""

#: ../../source/topics/processes/usage.rst:745
msgid "The processes API"
msgstr ""

#: ../../source/topics/processes/usage.rst:747
msgid ""
"The functionality of ``verdi process`` to ``play``, ``pause`` and ``kill`` "
"is now made available through the :meth:`aiida.engine.processes.control` "
"module. Processes can be played, paused or killed through the "
":meth:`~aiida.engine.processes.control.play_processes`, "
":meth:`~aiida.engine.processes.control.pause_processes`, and "
":meth:`~aiida.engine.processes.control.kill_processes`, respectively:"
msgstr ""

#: ../../source/topics/processes/usage.rst:760
msgid ""
"Instead of specifying an explicit list of processes, the functions also take"
" the ``all_entries`` keyword argument:"
msgstr ""

#: ../../source/topics/provenance/caching.rst:5
msgid "Caching and hashing"
msgstr ""

#: ../../source/topics/provenance/caching.rst:7
msgid ""
"This section covers the more general considerations of the hashing/caching "
"mechanism. For a more practical guide on how to enable and disable this "
"feature, please visit the corresponding :ref:`how-to section <how-to:run-"
"codes:caching>`. If you want to know more about how the internal design of "
"the mechanism is implemented, you can check the :ref:`internals section "
"<internal_architecture:engine:caching>` instead."
msgstr ""

#: ../../source/topics/provenance/caching.rst:15
msgid "How are nodes hashed"
msgstr ""

#: ../../source/topics/provenance/caching.rst:17
msgid ""
"*Hashing* is turned on by default, i.e., all nodes in AiiDA are hashed. This"
" means that even when you enable caching once you have already completed a "
"number of calculations, those calculations can still be used retro-actively "
"by the caching mechanism since their hashes have been computed."
msgstr ""

#: ../../source/topics/provenance/caching.rst:20
msgid "The hash of a ``Data`` node is computed from:"
msgstr ""

#: ../../source/topics/provenance/caching.rst:22
msgid ""
"all attributes of the node, except the ``_updatable_attributes`` and "
"``_hash_ignored_attributes``"
msgstr ""

#: ../../source/topics/provenance/caching.rst:23
msgid "the ``__version__`` of the package which defined the node class"
msgstr ""

#: ../../source/topics/provenance/caching.rst:24
msgid "the content of the repository folder of the node"
msgstr "节点的repository文件夹的内容"

#: ../../source/topics/provenance/caching.rst:25
msgid "the UUID of the computer, if the node is associated with one"
msgstr ""

#: ../../source/topics/provenance/caching.rst:27
msgid ""
"The hash of a :class:`~aiida.orm.ProcessNode` includes, on top of this, the "
"hashes of all of its input ``Data`` nodes."
msgstr ""

#: ../../source/topics/provenance/caching.rst:29
msgid ""
"Once a node is stored in the database, its hash is stored in the "
"``_aiida_hash`` extra, and this extra is used to find matching nodes. If a "
"node of the same class with the same hash already exists in the database, "
"this is considered a cache match. You can use the "
":meth:`~aiida.orm.nodes.caching.NodeCaching.get_hash` method to check the "
"hash of any node. In order to figure out why a calculation is *not* being "
"reused, the "
":meth:`~aiida.orm.nodes.caching.NodeCaching._get_objects_to_hash` method may"
" be useful:"
msgstr ""

#: ../../source/topics/provenance/caching.rst:64
msgid "Controlling hashing"
msgstr ""

#: ../../source/topics/provenance/caching.rst:67
msgid "Data nodes"
msgstr "数据节点"

#: ../../source/topics/provenance/caching.rst:69
msgid ""
"The hashing of *Data nodes* can be customized both when implementing a new "
"data node class and during runtime."
msgstr ""

#: ../../source/topics/provenance/caching.rst:71
msgid "In the :py:class:`~aiida.orm.Node` subclass:"
msgstr ""

#: ../../source/topics/provenance/caching.rst:73
msgid ""
"Use the ``_hash_ignored_attributes`` to exclude a list of node attributes "
"``['attr1', 'attr2']`` from computing the hash."
msgstr ""

#: ../../source/topics/provenance/caching.rst:74
msgid ""
"Include extra information in computing the hash by overriding the "
":meth:`~aiida.orm.nodes.caching.NodeCaching._get_objects_to_hash` method. "
"Use the ``super()`` method, and then append to the list of objects to hash."
msgstr ""

#: ../../source/topics/provenance/caching.rst:77
msgid ""
"You can also modify hashing behavior during runtime by passing a keyword "
"argument to :meth:`~aiida.orm.nodes.caching.NodeCaching.get_hash`, which are"
" forwarded to :meth:`~aiida.common.hashing.make_hash`."
msgstr ""

#: ../../source/topics/provenance/caching.rst:80
msgid "Process nodes"
msgstr ""

#: ../../source/topics/provenance/caching.rst:82
msgid ""
"The hashing of *Process nodes* is fixed and can only be influenced "
"indirectly via the hashes of their inputs. For implementation details of the"
" hashing mechanism for process nodes, see :ref:`here "
"<internal_architecture:engine:caching>`."
msgstr ""

#: ../../source/topics/provenance/caching.rst:88
msgid "Controlling Caching"
msgstr ""

#: ../../source/topics/provenance/caching.rst:90
msgid ""
"In the caching mechanism, there are two different types of roles played by "
"the nodes: the node that is currently being stored is called the `target`, "
"and the nodes already stored in the database that are considered to be "
"equivalent are referred to as a `source`."
msgstr ""

#: ../../source/topics/provenance/caching.rst:93
msgid "Targets"
msgstr ""

#: ../../source/topics/provenance/caching.rst:95
msgid ""
"Controlling what nodes will look in the database for existing equivalents "
"when being stored is done on the class level. Section :ref:`how-to:run-"
"codes:caching:configure` explains how this can be controlled globally "
"through the profile configuration, or locally through context managers."
msgstr ""

#: ../../source/topics/provenance/caching.rst:99
msgid "Sources"
msgstr ""

#: ../../source/topics/provenance/caching.rst:101
msgid ""
"When a node is being stored (the `target`) and caching is enabled for its "
"node class (see section above), a valid cache `source` is obtained through "
"the method :meth:`~aiida.orm.nodes.caching.NodeCaching._get_same_node`. This"
" method calls the iterator "
":meth:`~aiida.orm.nodes.caching.NodeCaching._iter_all_same_nodes` and takes "
"the first one it returns if there are any. To find the list of `source` "
"nodes that are equivalent to the `target` that is being stored, "
":meth:`~aiida.orm.nodes.caching.NodeCaching._iter_all_same_nodes` performs "
"the following steps:"
msgstr ""

#: ../../source/topics/provenance/caching.rst:105
msgid ""
"It queries the database for all nodes that have the same hash as the "
"`target` node."
msgstr ""

#: ../../source/topics/provenance/caching.rst:106
msgid ""
"From the result, only those nodes are returned where the property "
":meth:`~aiida.orm.nodes.caching.NodeCaching.is_valid_cache` returns "
"``True``."
msgstr ""

#: ../../source/topics/provenance/caching.rst:108
msgid ""
"The property :meth:`~aiida.orm.nodes.caching.NodeCaching.is_valid_cache` "
"therefore allows to control whether a stored node can be used as a `source` "
"in the caching mechanism. By default, for all nodes, the property returns "
"``True``. However, this can be changed on a per-node basis, by setting it to"
" ``False``"
msgstr ""

#: ../../source/topics/provenance/caching.rst:117
msgid ""
"Setting the property to ``False``, will cause an extra to be stored on the "
"node in the database, such that even when it is loaded at a later point in "
"time, ``is_valid_cache`` returns ``False``."
msgstr ""

#: ../../source/topics/provenance/caching.rst:124
msgid ""
"Through this method, it is possible to guarantee that individual nodes are "
"never used as a `source` for caching."
msgstr ""

#: ../../source/topics/provenance/caching.rst:126
msgid ""
"The :class:`~aiida.engine.processes.process.Process` class overrides the "
":meth:`~aiida.orm.nodes.caching.NodeCaching.is_valid_cache` property to give"
" more fine-grained control on process nodes as caching sources. If either "
":meth:`~aiida.orm.nodes.caching.NodeCaching.is_valid_cache` of the base "
"class or :meth:`~aiida.orm.nodes.process.process.ProcessNode.is_finished` "
"returns ``False``, the process node is not a valid source. Likewise, if the "
"process class cannot be loaded from the node, through the "
":meth:`~aiida.orm.nodes.process.process.ProcessNode.process_class`, the node"
" is not a valid caching source. Finally, if the associated process class "
"implements the "
":meth:`~aiida.engine.processes.process.Process.is_valid_cache` method, it is"
" called, passing the node as an argument. If that returns ``True``, the node"
" is considered to be a valid caching source."
msgstr ""

#: ../../source/topics/provenance/caching.rst:132
msgid ""
"The :meth:`~aiida.engine.processes.process.Process.is_valid_cache` is "
"implemented on the :class:`~aiida.engine.processes.process.Process` class. "
"It will check whether the exit code that is set on the node, if any, has the"
" keyword argument ``invalidates_cache`` set to ``True``, in which case the "
"property will return ``False`` indicating the node is not a valid caching "
"source. Whether an exit code invalidates the cache, is controlled with the "
"``invalidates_cache`` argument when it is defined on the process spec "
"through the :meth:`spec.exit_code "
"<aiida.engine.processes.process_spec.ProcessSpec.exit_code>` method."
msgstr ""

#: ../../source/topics/provenance/caching.rst:138
msgid ""
"Process plugins can override the "
":meth:`~aiida.engine.processes.process.Process.is_valid_cache` method, to "
"further control how nodes are considered valid caching sources. When doing "
"so, make sure to call :meth:`super().base.caching.is_valid_cache(node) "
"<aiida.engine.processes.process.Process.is_valid_cache>` and respect its "
"output: if it is `False`, your implementation should also return `False`. If"
" you do not comply with this, the ``invalidates_cache`` keyword on exit "
"codes will no longer work."
msgstr ""

#: ../../source/topics/provenance/caching.rst:146
msgid "Limitations and Guidelines"
msgstr ""

#: ../../source/topics/provenance/caching.rst:148
msgid ""
"Workflow nodes are not cached. In the current design this follows from the "
"requirement that the provenance graph be independent of whether caching is "
"enabled or not:"
msgstr ""

#: ../../source/topics/provenance/caching.rst:151
msgid ""
"**Calculation nodes:** Calculation nodes can have data inputs and create new"
" data nodes as outputs. In order to make it look as if a cloned calculation "
"produced its own outputs, the output nodes are copied and linked as well."
msgstr ""

#: ../../source/topics/provenance/caching.rst:153
msgid ""
"**Workflow nodes:** Workflows differ from calculations in that they can "
"*return* an input node or an output node created by a calculation. Since "
"caching does not care about the *identity* of input nodes but only their "
"*content*, it is not straightforward to figure out which node to return in a"
" cached workflow."
msgstr ""

#: ../../source/topics/provenance/caching.rst:156
msgid ""
"This limitation has typically no significant impact since the runtime of "
"AiiDA work chains is commonly dominated by expensive calculations."
msgstr ""

#: ../../source/topics/provenance/caching.rst:158
msgid ""
"The caching mechanism for calculations *should* trigger only when the inputs"
" and the calculation to be performed are exactly the same. While AiiDA's "
"hashes include the version of the Python package containing the "
"calculation/data classes, it cannot detect cases where the underlying Python"
" code was changed without increasing the version number. Another scenario "
"that can lead to an erroneous cache hit is if the parser and calculation are"
" not implemented as part of the same Python package, because the calculation"
" nodes store only the name, but not the version of the used parser."
msgstr ""

#: ../../source/topics/provenance/caching.rst:162
msgid ""
"While caching saves unnecessary computations, it does not necessarily save "
"space as the cached calculation and its output nodes are duplicated in the "
"provenance graph. However, AiiDA's default disk-objectstore storage backend "
"comes with automatic de-duplication at the object level. Disk usage "
"therefore remains unaffected with this backend, except for node metadata "
"stored at the database level."
msgstr ""

#: ../../source/topics/provenance/caching.rst:166
msgid ""
"Finally, When modifying the hashing/caching behaviour of your classes, keep "
"in mind that cache matches can go wrong in two ways:"
msgstr ""

#: ../../source/topics/provenance/caching.rst:168
msgid ""
"False negatives, where two nodes *should* have the same hash but do not"
msgstr ""

#: ../../source/topics/provenance/caching.rst:169
msgid ""
"False positives, where two different nodes get the same hash by mistake"
msgstr ""

#: ../../source/topics/provenance/caching.rst:171
msgid ""
"False negatives are **highly preferrable** because they only increase the "
"runtime of your calculations, while false positives can lead to wrong "
"results."
msgstr ""

#: ../../source/topics/provenance/concepts.rst:8
msgid "Nodes and links"
msgstr "节点和连接"

#: ../../source/topics/provenance/concepts.rst:10
msgid ""
"Two of the most important concepts in AiiDA are **data** and **processes**. "
"The former are pieces of data, such as a simple integer or float, all the "
"way to more complex data concepts such as a dictionary of parameters, a "
"folder of files or a crystal structure. Processes operate on this data in "
"order to produce new data."
msgstr ""

#: ../../source/topics/provenance/concepts.rst:14
msgid "Processes come in two different forms:"
msgstr "例程（process）有两种形式："

#: ../../source/topics/provenance/concepts.rst:16
msgid ""
"**Calculations** are processes that are able to **create** new data. This is"
" the case, for instance, for externals simulation codes, that generate new "
"data"
msgstr "**算例（Calculations）** 是能够 **产生** 新的数据的的例程，比如，使用外部代码，该类型例程能够产生新的结果数据"

#: ../../source/topics/provenance/concepts.rst:17
msgid ""
"**Workflows** are processes that **orchestrate** other workflows and "
"calculations, i.e. they manage the logical flow, being able to **call** "
"other processes. Workflows have data inputs, but cannot generate new data. "
"They can only return data that is already in the database (one typical case "
"is to return data created by a calculation they called)."
msgstr ""
"**工作流（Workflows）** "
"是**组合**了其他工作流或者其他算例的i例程，它是能够以逻辑流方式组合并调用其他例程的例程。工作流有数据输入，但不能够产生新的数据输出，它只能够返回已经储存在数据库中的数据（典型的情况是调用算例型例程并返回由其创建的数据）。"
" "

#: ../../source/topics/provenance/concepts.rst:19
msgid ""
"Data and processes are represented in the AiiDA provenance graph as the "
"**nodes** of that graph. The graph edges are referred to as **links** and "
"come in different forms:"
msgstr "数据和例程在AiiDA的可验证性图中以 **节点** 的形式表示。图中的边被称作 **连接** ，有以下几种形式 :"

#: ../../source/topics/provenance/concepts.rst:22
msgid ""
"**input** links: connect data nodes to the process nodes that used them as "
"input, both calculations and workflows"
msgstr "**输入(input)** 连接 : 从数据节点连接到例程节点，数据节点作为例程节点的输入，算例和工作流均支持该连接"

#: ../../source/topics/provenance/concepts.rst:23
msgid ""
"**create** links: connect calculation nodes to the data nodes that they "
"created"
msgstr "**创建(create)** 连接: 从算例节点连接到数据节点，来表示其创建的数据来源"

#: ../../source/topics/provenance/concepts.rst:24
msgid ""
"**return** links: connect workflow nodes to the data nodes that they "
"returned"
msgstr "**返回(return)** 连接: 从工作流节点连接到数据节点，表示工作流返回的数据"

#: ../../source/topics/provenance/concepts.rst:25
msgid ""
"**call** links: connecting workflow nodes to the process nodes that they "
"directly called, be it calculations or workflows"
msgstr ""
"**调用(call)** 连接: "
"从工作流节点连接到例程节点用以表示工作流调用的例程，调用的例程可以是算例(calculations)也可是工作流(workflows)"

#: ../../source/topics/provenance/concepts.rst:27
msgid ""
"Note that the **create** and **return** links are often collectively "
"referred to as **output** links."
msgstr "**创建(create)** 和 **返回(return)** 连接通常统称为 **输出(output)** 连接。"

#: ../../source/topics/provenance/concepts.rst:31
msgid "Data provenance and logical provenance"
msgstr "数据可验证性和逻辑可验证性"

#: ../../source/topics/provenance/concepts.rst:33
msgid ""
"AiiDA automatically stores entities in its database and links them forming a"
" **directed graph**. This directed graph automatically tracks the "
"**provenance** of all data produced by calculations or returned by "
"workflows. By tracking the provenance in this way, one can always fully "
"retrace how a particular piece of data came into existence, thus ensuring "
"its reproducibility."
msgstr ""
"AiiDA自动将流程实体储存在数据库中，并将实体连接成为有向图。有向图自动跟踪了数据如何从算例产生或从工作流中返回。通过跟踪数据的流向，用户总是可以清楚的回溯特定的数据是如何产生的，这保证了该数据的可重复性。"

#: ../../source/topics/provenance/concepts.rst:37
msgid "In particular, we define two types of provenance:"
msgstr "特别的，我们定义了两种类型的可验证性："

#: ../../source/topics/provenance/concepts.rst:39
msgid ""
"The **data provenance**, consisting of the part of the graph that *only* "
"consists of data and calculations (i.e. without considering workflows), and "
"only the **input** and **create** links that connect them. The data "
"provenance records the full history of how data has been generated. Due to "
"the causality principle, the data provenance part of the graph is a "
"**directed acyclic graph** (DAG), i.e. its nodes are connected by directed "
"edges and it does not contain any cycles."
msgstr ""
"其一为 **数据可验证性(data provenance)** ，考察图中只包含数据和算例的部分（不包含工作流），以及考察只有 "
"**输入(input)** 和 **创建(create)** "
"连接的部分。数据可验证性记录了关于该数据如何产生的整个完整流程。根据因果关系，数据的可验证性部分在图中是一个有向无环图 **directed "
"acyclic graph** (DAG)，也就是说节点和节点之间直接通过有向边连接，且图中没有环。"

#: ../../source/topics/provenance/concepts.rst:40
msgid ""
"The **logical provenance** which consists of workflow and data nodes, "
"together with the **input**, **return** and **call** links that connect "
"them. The logical provenance is *not* acyclic, e.g. a workflow that acts as "
"a filter can return one of its own inputs, directly introducing a cycle."
msgstr ""
"**逻辑可验证性(logical provenance)** 是图中只包含工作流和数据节点的部分，包含了 **输入** , **返回** , 和 "
"**调用** 连接。逻辑可验证性部分是有环图，比如一个表示过滤器的工作流会返回它自身，这自动导致在图中引入了环。"

#: ../../source/topics/provenance/concepts.rst:42
msgid ""
"The data provenance is essentially a log of which calculation generated what"
" data using certain inputs. The data provenance alone already guarantees "
"reproducibility (one could run again one by one the calculations with the "
"provided input and would obtain the same outputs). The logical provenance "
"gives additional information on why a specific calculation was run. Imagine "
"the case in which you start from 100 structures, you have a filter operation"
" that picks one, and then you run a simulation on it. The data provenance "
"only shows the simulation you run on the structure that was picked, while "
"the logical provenance can also show that the specific structure was not "
"picked at random but via a specific workflow logic."
msgstr ""
"数据可验证性就是有关算例如何用特定输入产生数据的日志信息。单纯的数据可验证性就已经保证了流程的可重复性（用户可以使用算例的输入来产生完全相同的输出结果）。而逻辑可验证性提供了关于如何运行一个特定的算例的附加信息。想象这样一个情景，开始时你有100个晶体结构，你需要以一定条件筛选出一个，然后将其加入模拟。数据可验证性仅仅表示了你如何对选出的结构进行计算模拟，而逻辑可验证性添加了关于如何筛选该晶体构型的信息，因为该构型不是随机挑选，而是通过一定的工作逻辑和条件筛选得到。"

#: ../../source/topics/provenance/concepts.rst:49
msgid "Other entities"
msgstr "其他实体"

#: ../../source/topics/provenance/concepts.rst:51
msgid ""
"Beside nodes (data and processes), AiiDA defines a few more entities, like a"
" :py:class:`~aiida.orm.computers.Computer` (representing a computer, "
"supercomputer or computer cluster where calculations are run or data is "
"stored), a :py:class:`~aiida.orm.groups.Group` (that group nodes together "
"for organizational purposes) and the :py:class:`~aiida.orm.users.User` (to "
"keep track of the user who first generated a given node, computer or group)."
msgstr ""
"除了上述节点（数据和例程），AiiDA还定义了一些其他相关实体比如  :py:class:`~aiida.orm.computers.Computer`"
" （表示执行运算或储存数据的计算机，超算或者集群）， :py:class:`~aiida.orm.groups.Group` "
"（用于组织数据的节点类型），和  :py:class:`~aiida.orm.users.User` "
"（跟踪数据等节点的创建者，或组和用户节点的拥有者）。"

#: ../../source/topics/provenance/concepts.rst:53
msgid ""
"In the following section we describe in more detail how the general "
"provenance concepts above are actually implemented in AiiDA, with specific "
"reference to the python classes that implement them and the class-"
"inheritance relationships."
msgstr "下列章节我们更加详细讲解上述提到的可验证性的概念在AiiDA中如何通过引用和继承特定的python类型来实现的。"

#: ../../source/topics/provenance/consistency.rst:5
msgid "Consistency"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:7
msgid ""
"Because of the very nature of scientific research, it becomes indispensable "
"to be able to both delete parts of a database (e.g., if errors are made, "
"inputs are misspelled, or useless calculations are performed) or export it "
"(for collaboration or publication purposes). Both these features, which are "
"provided by AiiDA, have one aspect in common: they can easily lead to a "
"provenance graph with incomplete information. To better understand why, "
"let's take a look at the following basic provenance graph:"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:14
msgid ""
"Even in this simple case, if we were to export only the calculation node and"
" the output data node (or, equivalently, delete just the input data node), "
"then we would have lost part of the critical information needed to run the "
"calculation (the |D_1| node), thus losing the reproducibility of the "
"calculation |C_1|. In this simple case, therefore, in order to have a "
"consistent provenance, whenever you export a calculation node you must also "
"import *all* of its input nodes (or, symmetrically, whenever you delete a "
"data node you must also delete all calculations that used it as an input)."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:17
msgid ""
"This is just one of the many rules that must be considered when trying to "
"manually edit a provenance database. The key message to remember is that "
"AiiDA will not only delete or export the nodes explicitly targeted by the "
"user, but will also include any other nodes that are needed for keeping a "
"consistent provenance in the resulting database."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:20
msgid ""
"It is also worth noting that if you do successive exports of partial "
"information, AiiDA will be able to reconstruct links that might have been "
"broken when dividing the data for export. So if you first where to export "
"the previous graph, and then you exported the next section of your full "
"database:"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:26
msgid ""
"Then AiiDA will be able to automatically identify the shared node |D_2| and "
"connect both sections back together during the import process. For this kind"
" of recognition it doesn't matter which sub-graph was exported first."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:29
msgid ""
"In the following section we will explain in more detail the criteria for "
"including other nodes and the corresponding traversal rules."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:34
msgid "Traversal Rules"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:36
msgid ""
"When you run ``verdi node delete [NODE_IDS]`` or ``verdi archive create -N "
"[NODE_IDS]``, AiiDA will look at the links incoming or outgoing from the "
"nodes that you specified and decide if there are other nodes that are "
"critical to keep."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:38
msgid ""
"For this decision, it is not only important to consider the type of link, "
"but also if we are following it along its direction (we will call this "
"``forward`` direction) or in the reversed direction (``backward`` "
"direction). To clarify this, in the example above, when deleting data node "
"|D_1|, AiiDA will follow the ``input_calc`` link in the ``forward`` "
"direction (in this case, it will decide that the linked node (|C_1|) must "
"then also be deleted). If the initial target node was, instead, |C_1| the "
"``input_calc`` link would be followed in the ``backward`` direction (and in "
"this case the node |D_1| will not be deleted, as we will explain below)."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:42
msgid ""
"This process will be repeated recursively for every node that has just been "
"included for deletion or export, until no more nodes need to be added. The "
"rules defining whether a linked node should be added or not to the "
"delete/export list (based on the kind and direction of the link) are called "
"*traversal rules*. In the following section we will describe these rules "
"both for the export and delete procedures."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:46
msgid ""
"The tables below are grouped according to the type of nodes and links "
"involved. We also provide illustrations of the cases considered, where the "
"encircled node is the one being targeted, and the other node (to which the "
"red arrow is pointing) is the one that is being considered for addition into"
" the delete/export list."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:50
msgid "Data and Calculation Nodes"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:52
msgid ""
"The first example above already discusses the case of deleting an input "
"node: in this case, it is necessary to also delete any calculation that uses"
" it as an input."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:54
msgid ""
"In AiiDA, we apply the same criterion also when deleting an output: in this "
"case, we follow the ``create`` link in the ``backward`` direction and we "
"mark for deletion also the calculation that created it. The reason for this "
"is that a calculation with missing outputs could be misleading. For "
"instance, some calculations produce optional outputs depending on the "
"combination of input flags that are used. A missing output might be "
"interpreted as if that piece of information was not computed by the "
"calculation. In the case of export, the rules are typically the reverse of "
"those used for deletion. Therefore, in this case, the following rule "
"applies: when exporting a calculation node, all its input data nodes and "
"created output nodes must be exported as well."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:60
msgid ""
"On the other hand, when exporting a data node, users typically do not need "
"to also export all the calculations that used it as an input. These may "
"represent further work that, by default, does not need to be exported as "
"well (unless explicitly specified by the user in the list of nodes). "
"Equivalently, when deleting a calculation, one typically wants to keep its "
"inputs, as they might be used by other unrelated calculations."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:64
msgid ""
"What should happen instead for the outputs of a calculation to be deleted? "
"Often, one might want to delete (recursively) all the outputs generated by "
"it. However, we leave the option to users to just delete the calculation, "
"keeping its outputs in the database. While we emphasize that this operation "
"removes all provenance information for the output nodes, there are cases in "
"which this is useful or even needed (removal of inputs that are protected by"
" copyright, or creating a smaller archive file to transfer to collaborators "
"who want to work with the output data)."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:70
#: ../../source/topics/provenance/consistency.rst:101
#: ../../source/topics/provenance/consistency.rst:137
msgid "Illustrative diagram (explicitly targeted node is encircled)"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:70
#: ../../source/topics/provenance/consistency.rst:101
#: ../../source/topics/provenance/consistency.rst:137
msgid "Name of Rule"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:70
#: ../../source/topics/provenance/consistency.rst:101
#: ../../source/topics/provenance/consistency.rst:137
msgid "Behavior when exporting target node"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:70
#: ../../source/topics/provenance/consistency.rst:101
#: ../../source/topics/provenance/consistency.rst:137
msgid "Behavior when deleting target node"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:73
msgid "``input_calc_forward``"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:73
#: ../../source/topics/provenance/consistency.rst:104
msgid "Default Value: ``False``"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:74
#: ../../source/topics/provenance/consistency.rst:105
#: ../../source/topics/provenance/consistency.rst:114
msgid "Linked node **won't** be exported **by default**."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:73
#: ../../source/topics/provenance/consistency.rst:76
#: ../../source/topics/provenance/consistency.rst:79
#: ../../source/topics/provenance/consistency.rst:82
#: ../../source/topics/provenance/consistency.rst:104
#: ../../source/topics/provenance/consistency.rst:107
#: ../../source/topics/provenance/consistency.rst:110
#: ../../source/topics/provenance/consistency.rst:113
#: ../../source/topics/provenance/consistency.rst:140
#: ../../source/topics/provenance/consistency.rst:143
#: ../../source/topics/provenance/consistency.rst:146
#: ../../source/topics/provenance/consistency.rst:149
msgid "Fixed Value: ``True``"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:74
#: ../../source/topics/provenance/consistency.rst:83
#: ../../source/topics/provenance/consistency.rst:105
#: ../../source/topics/provenance/consistency.rst:114
#: ../../source/topics/provenance/consistency.rst:144
#: ../../source/topics/provenance/consistency.rst:150
msgid "Linked node **will always** be deleted."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:76
msgid "``input_calc_backward``"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:77
#: ../../source/topics/provenance/consistency.rst:80
#: ../../source/topics/provenance/consistency.rst:108
#: ../../source/topics/provenance/consistency.rst:111
#: ../../source/topics/provenance/consistency.rst:141
#: ../../source/topics/provenance/consistency.rst:147
msgid "Linked node **will always** be exported."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:76
msgid "Fixed Value: ``False`` [#f01]_"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:77
#: ../../source/topics/provenance/consistency.rst:108
#: ../../source/topics/provenance/consistency.rst:111
msgid "Linked node **will never** be deleted."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:79
msgid "``create_forward``"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:79
#: ../../source/topics/provenance/consistency.rst:140
#: ../../source/topics/provenance/consistency.rst:143
#: ../../source/topics/provenance/consistency.rst:146
msgid "Default Value: ``True``"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:80
#: ../../source/topics/provenance/consistency.rst:141
#: ../../source/topics/provenance/consistency.rst:147
msgid "Linked node **will** be deleted **by default**."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:82
msgid "``create_backward``"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:82
#: ../../source/topics/provenance/consistency.rst:149
msgid "Default Value: ``True``."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:83
#: ../../source/topics/provenance/consistency.rst:144
#: ../../source/topics/provenance/consistency.rst:150
msgid "Linked node **will** be exported **by default**."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:87
msgid ""
"Although we provide the option to automatically export all calculations that"
" use as input any targeted data node (by specifying "
"``input_calc_forward=True``) we *currently* do not provide the reciprocal "
"option to delete all the data node inputs when targeting calculation nodes. "
"This is mainly for the potential danger that would imply automatically "
"enabling upwards traversal of the data provenance when deleting, which would"
" make it extremely hard to predict or control the nodes that will be "
"ultimately affected."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:92
msgid "Data and Workflow Nodes"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:94
msgid ""
"The behavior when considering ``input_work`` links is exactly the same as "
"when considering ``input_calc`` links for the same reasons. The case for "
"``return`` links is partially similar to the one for ``create`` one. Indeed,"
" it isn't desirable to have a resulting database with missing outputs, so "
"when exporting a workflow the returned data nodes will also be included (and"
" when deleting a data node, the returning workflow will also be removed). "
"However, when exporting a returned node, the default behavior is *not* to "
"traverse backwards through the ``return`` links, since a data node might be "
"returned by several unrelated workflows (representing selection procedures "
"for other studies, for example) that are unrelated to its creation. The "
"workflow responsible for coordinating its creation will be included in the "
"export, not directly, but through the chain effect of including the creating"
" calculation (through ``create_backward``) and then including its calling "
"workflows (through ``call_calc_backward`` and ``call_work_backward``, see "
"next sections)."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:104
msgid "``input_work_forward``"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:107
msgid "``input_work_backward``"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:107
msgid "Fixed Value: ``False``"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:110
msgid "``return_forward``"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:110
msgid "Fixed Value: ``False`` [#f02]_"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:113
msgid "``return_backward``"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:113
msgid "Default Value: ``False``."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:118
msgid ""
"The reason to prevent the deletion of returned data nodes is that, since the"
" logical provenance can be cyclical, this might end up deleting inputs and "
"thus propagating the deletion process to other unrelated parts of the "
"database. In most cases where you will want to delete a returned data node, "
"you will be able to do so by setting ``call_calc_forward=True`` (see below) "
"and ``create_forward=True`` (which is the default value)."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:124
msgid "Workflows and Calculation Nodes"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:126
msgid ""
"Finally, we will consider the possible (call) links between processes. The "
"results of a parent workflow depend critically on the sub-workflows or "
"calculations launched by it. When exporting a workflow node, we therefore "
"always traverse its ``call`` links (both ``call_calc`` and ``call_work``) in"
" the ``forward`` direction to include all children processes (i.e. processes"
" directly called by it). Since the traversal rules are applied recursively, "
"this means that also the children processes of any workflow that was a child"
" of the targeted one will be exported as well, and so on. Analogously, when "
"deleting a process the same applies but in the opposite direction "
"(``backward``), including the parent workflow of the targeted node (if there"
" is one), and the parent of that parent, etc."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:132
msgid ""
"Since ``call`` links are followed backward by default, targeting one process"
" for either export or deletion results in selecting not only all of its "
"child processes but also all children of any of its parent processes. As a "
"result of all ``call`` links being traversed in both directions, targeting "
"any of the process nodes in a workflow will mean the inclusion of the other "
"processes of that workflow as well. Users can disable the traversal of "
"``call`` links in one of the directions (``forward`` for deletion, "
"``backward`` for export) for fine-grained control (see examples below)."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:140
msgid "``call_calc_forward``"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:143
msgid "``call_calc_backward``"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:146
msgid "``call_work_forward``"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:149
msgid "``call_work_backward``"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:155
msgid "Cascading rules: an example"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:157
msgid ""
"In the previous sections we have described the basic rules used by AiiDA to "
"decide which nodes should also be included from an initial list of nodes to "
"delete or export. These rules are applied recursively: as new nodes are "
"included in the deletion (or export)list, the rules are applied to them as "
"well until no new nodes are included. Therefore, the consequence of using "
"these features on a given set of nodes may not always be straightforward, "
"and the final set might include more nodes than naively expected."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:161
msgid ""
"Let us first focus on the data provenance only (i.e., only ``input_calc`` "
"and ``create`` links). The following two rules apply when going in the "
"``forward`` direction:"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:163
msgid ""
"If you delete a data node, any calculation that uses it as input will "
"*always* be deleted as well (``input_calc_forward=True``)."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:164
msgid ""
"If you delete a calculation node, any output data node will be deleted *by "
"default* (``create_forward=True``)."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:166
msgid ""
"The consequence of these two together is a \"chain reaction\" in which every"
" node that can be traced back through the data provenance to any of the "
"initial targeted nodes will end up being deleted as well. The reciprocal is "
"true for the export: the default behavior is that every ancestor will also "
"be exported by default (because ``create_backward`` is ``True`` by default "
"and ``input_calc_backward`` is always ``True``)."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:169
msgid ""
"In regards to the connection between data provenance and logical provenance,"
" the most important thing to understand is how the default behavior of the "
"program treats the highest-level workflows as the units to be handled. The "
"logic behind this is the assumption that the typical user of the program "
"will be dealing with it mostly in an interactive way, running pre-defined "
"workflows through the verdi command line without needing a detailed "
"knowledge of their internal procedures. The default behavior then was "
"designed to reproduce the most intuitive outcomes for this type of usage."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:173
msgid ""
"This behavior is basically the result of the settings of "
"``call_calc_forward=True`` and ``call_work_forward=True``, which makes that "
"the inclusion of a process node will also imply the inclusion of any child "
"or parent process node as well. Following these rules in a recursive way "
"leads to the command affecting all the processes within any given workflow: "
"in this way, nodes that are sub-processes of a given highest-level workflow "
"will end up grouped together, in the sense that (by default) they will all "
"be affected in the same way when deleting or exporting."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:176
msgid ""
"More freedom to further customize the selection of sections to export or "
"delete is available through the specific switchable flags for each "
"functionality (although the final sections must always comply with the non-"
"switchable rules, see above). However, this usually requires a deeper "
"understanding of the traversal rules and may imply a more thorough analysis "
"of the particular graph. To better illustrate this, we will now consider the"
" application of the deletion procedure to the following graph:"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:184
msgid ""
"As you can see, |W_1| and |W_2| describe two similar but independent "
"procedures that were launched by a single parent workflow |W_0|. A typical "
"user would have obtained this by directly running this workflow |W_0| to "
"obtain the results |D_3| and |D_4| from the inputs |D_1| and |D_2|, and may "
"even be unaware of the internal division of |W_0| into two sub-Workflows "
"|W_1| and |W_2|. Hence, if the user considers the workflow (meaning, the "
"whole set of nodes produced by it) no longer necessary, the intuitive thing "
"to do in order to remove it from its database would be by targeting the "
"workflow node |W_0| for deletion. Indeed, this would produce the desired "
"result:"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:193
msgid ""
"The nodes |W_1| and |W_2| would be included because |W_0| is being targeted "
"(``call_work_forward=True``), then the nodes |C_1| and |C_2| would also be "
"included (``call_calc_forward=True``), and finally the nodes |D_3| and |D_4|"
" would end up being included as well (``create_forward=True``). In the end, "
"only the inputs |D_1| and |D_2| remain (since ``input_work_backward=False`` "
"always and ``input_calc_backward=False`` by default)."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:196
msgid ""
"The same result would occur if the user were to target the output nodes "
"instead (intending to delete everything associated with the obtention of "
"those results). It is important to notice that even if the user deletes only"
" one of the outputs, the whole set of nodes generated by the workflow would "
"be deleted, and not just the ones associated to the targeted data node. As "
"the results |D_3| and |D_4| where obtained from the same high-level process "
"|W_0|, then the default behavior has the underlying assumption that they are"
" interconnected and not independent from one another (as if they were two "
"different outputs of a single calculation)."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:204
msgid ""
"In this case, the node |C_1| would first be included because the data node "
"|D_3| is being targeted (``create_reverse=True``), and this in turn would "
"include the node |W_1| (``call_calc_reverse=True``) and then its parent "
"workflow |W_0| (``call_work_reverse=True``). Then nodes |W_2|, |C_2| and "
"|D_4| will be included because |W_0| was included, for the same reasons that"
" were explained in the paragraphs above."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:209
msgid "Customizing the graph traversal (for deletion or export)"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:211
msgid ""
"This dependency between nodes becomes particularly relevant when, for "
"example, a user with more knowledge of the internal procedures of the parent"
" workflow |W_0| wants to only delete the calculations and results associated"
" to workflow |W_1|. The intuitive action of targeting |W_1| does not produce"
" the desired outcome:"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:218
msgid ""
"Indeed |C_1| and |D_4| will be deleted (through ``call_calc_forward`` from "
"|W_1| to |C_1| and ``create_forward`` from |C_1| to |D_3|), but so will "
"|W_0| (through ``call_work_reverse`` from |W_1|), |W_2| "
"(``call_work_forward`` from |W_0|), |C_2| (``call_calc_forward`` from |W_2|)"
" and |D_4| (``create_forward`` from |C_2|). The way to achieve the desired "
"outcome is not trivial, although in some situations like this, one could "
"propose case-specific solutions such as targeting |W_1| with the switchable "
"flag ``call_work_forward=False`` (preventing the traversal from |W_0| to "
"|W_2|):"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:225
msgid ""
"However, this approach is not generally applicable, and wouldn't work if "
"|W_1| had sub-workflows that needed to be deleted as well. A more general "
"approach is to first sever the connection to |W_2| by deleting node |W_0| "
"with all switchable traversal rules turned off. Then, once the independence "
"of |W_1| and |W_2| is explicitly reflected in the graph, node |W_1| can be "
"deleted with the default settings."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:233
msgid ""
"It is worth noting that if the workflow |W_0| was itself part of a higher-"
"level workflow, all that higher-level logic would be deleted due to the non-"
"switchable rule ``call_work_reverse=True``. This is an inevitable outcome of"
" deleting part of a workflow, since due to the loss of that information it "
"has become incomplete and it makes no sense to keep it."
msgstr ""

#: ../../source/topics/provenance/implementation.rst:5
#: ../../source/topics/workflows/concepts.rst:130
msgid "Implementation"
msgstr "实现"

#: ../../source/topics/provenance/implementation.rst:8
msgid "Graph nodes"
msgstr "图的节点"

#: ../../source/topics/provenance/implementation.rst:10
msgid ""
"The **nodes** of the AiiDA provenance graph can be grouped into two main "
"**types**: **process nodes** (``ProcessNode``), that represent the execution"
" of calculations or workflows, and **data nodes** (``Data``), that represent"
" pieces of data."
msgstr ""
"AiiDA可验证图中的 **节点** 可以分类两大类：第一类是表示例程执行的 **例程节点** ( ``ProcessNode`` )， 和表示数据的 "
"**数据节点**( ``Data`` )。"

#: ../../source/topics/provenance/implementation.rst:12
msgid "In particular, **process nodes** are divided into two sub categories:"
msgstr "**例程节点** 被细分为两个小类："

#: ../../source/topics/provenance/implementation.rst:14
msgid ""
"**calculation nodes** (``CalculationNode``): Represent code execution that "
"creates new data. These are further subdivided in two subclasses:"
msgstr "**算例节点** ( ``CalculationNode`` )： 用以表示创建数据的和储存用来运行的代码的信息。又被分为两个小类："

#: ../../source/topics/provenance/implementation.rst:16
msgid ""
":py:class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode`: "
"Represents the execution of a calculation external to AiiDA, typically via a"
" job batch scheduler (see the concept of :ref:`calculation "
"jobs<topics:calculations:concepts:calcjobs>`)."
msgstr ""

#: ../../source/topics/provenance/implementation.rst:17
msgid ""
":py:class:`~aiida.orm.nodes.process.calculation.calcfunction.CalcFunctionNode`:"
" Represents the execution of a python function (see the concept of "
":ref:`calculation functions<topics:calculations:concepts:calcfunctions>`)."
msgstr ""

#: ../../source/topics/provenance/implementation.rst:19
msgid ""
"**workflow nodes** (``WorkflowNode``): Represent python code that "
"orchestrates the execution of other workflows and calculations, that "
"optionally return the data created by the processes they called. These are "
"further subdivided in two subclasses:"
msgstr ""
"**工作流节点** (``WorkflowNode``) "
":表示了则和其他工作流或其他算例的一段python代码所代表的节点，该节点可以返回由其中调用的例程创建的数据。其又被细分为两个小类 :"

#: ../../source/topics/provenance/implementation.rst:21
msgid ""
":py:class:`~aiida.orm.nodes.process.workflow.workchain.WorkChainNode`: "
"Represents the execution of a python class instance with built-in "
"checkpoints, such that the process may be paused/stopped/resumed (see the "
"concept of :ref:`work chains<topics:workflows:concepts:workchains>`)."
msgstr ""

#: ../../source/topics/provenance/implementation.rst:22
msgid ""
":py:class:`~aiida.orm.nodes.process.workflow.workfunction.WorkFunctionNode`:"
" Represents the execution of a python function calling other processes (see "
"the concept of :ref:`work "
"functions<topics:workflows:concepts:workfunctions>`)."
msgstr ""

#: ../../source/topics/provenance/implementation.rst:24
msgid "The class hierarchy of the process nodes is shown in the figure below."
msgstr "上述例程节点类的继承关系如下图所示。"

#: ../../source/topics/provenance/implementation.rst:29
msgid ""
"The hierarchy of the ORM classes for the process nodes. Only instances of "
"the lowest level of classes will actually enter into the provenance graph. "
"The two upper levels have a mostly taxonomical purpose as they allow us to "
"refer to multiple classes at once when reasoning about the graph as well as "
"a place to define common functionality (see section on :ref:`processes "
"<topics:processes:concepts>`)."
msgstr ""

#: ../../source/topics/provenance/implementation.rst:32
msgid ""
"For what concerns data nodes, the base class (``Data``) is subclassed to "
"provide functionalities specific to the data type and python methods to "
"operate on it. Often, the name of the subclass contains the word “Data” "
"appended to it, but this is not a requirement. A few examples:"
msgstr ""
"对于数据节点，基础的数据类 ``Data`` "
"被继承为能够提供数据操作和数据储存方式的子类。通常，这些子类的命名需要包含”Data“作为后缀，但这并非必须的，比如："

#: ../../source/topics/provenance/implementation.rst:35
msgid ""
":py:class:`~aiida.orm.nodes.data.float.Float`, "
":py:class:`~aiida.orm.nodes.data.int.Int`, "
":py:class:`~aiida.orm.nodes.data.bool.Bool`, "
":py:class:`~aiida.orm.nodes.data.str.Str`, "
":py:class:`~aiida.orm.nodes.data.list.List`, ..."
msgstr ""
":py:class:`~aiida.orm.nodes.data.float.Float`, "
":py:class:`~aiida.orm.nodes.data.int.Int`, "
":py:class:`~aiida.orm.nodes.data.bool.Bool`, "
":py:class:`~aiida.orm.nodes.data.str.Str`, "
":py:class:`~aiida.orm.nodes.data.list.List`, ..."

#: ../../source/topics/provenance/implementation.rst:36
msgid ""
":py:class:`~aiida.orm.nodes.data.dict.Dict`: represents a dictionary of key-"
"value pairs - these are parameters of a general nature that do not need to "
"belong to more specific data sub-classes"
msgstr ""
":py:class:`~aiida.orm.nodes.data.dict.Dict`: "
"表示字典型的键值对，这些都是基础类型，并不需要被继承为其他的子类来使用"

#: ../../source/topics/provenance/implementation.rst:37
msgid ""
":py:class:`~aiida.orm.nodes.data.structure.StructureData`: represents "
"crystal structure data (containing chemical symbols, atomic positions of the"
" atoms, periodic cell for periodic structures, …)"
msgstr ""
":py:class:`~aiida.orm.nodes.data.structure.StructureData`:  "
"用以表示i晶体的结构数据（包含有元素符号，原子位置，对于周期性体系还有晶胞信息等）"

#: ../../source/topics/provenance/implementation.rst:38
msgid ""
":py:class:`~aiida.orm.nodes.data.array.array.ArrayData`: represents generic "
"numerical arrays of data (python numpy arrays)"
msgstr ""
":py:class:`~aiida.orm.nodes.data.array.array.ArrayData`: "
"用以表示常规的数值数组（也就是python中的numpy数组）"

#: ../../source/topics/provenance/implementation.rst:39
msgid ""
":py:class:`~aiida.orm.nodes.data.array.kpoints.KpointsData`: represents a "
"numerical array of k-points data, is a sub-class of ``ArrayData``"
msgstr ""
":py:class:`~aiida.orm.nodes.data.array.kpoints.KpointsData`: 用以表示k点数据的数组，是 "
"``ArrayData`` 的子类"

#: ../../source/topics/provenance/implementation.rst:41
msgid "For more detailed information see :ref:`AiiDA data types <DataTypes>`."
msgstr "更多相关信息请参考 :ref:`AiiDA 数据类型 <DataTypes>` 。"

#: ../../source/topics/provenance/implementation.rst:43
msgid ""
"In the next section we introduce the links between nodes, creating the AiiDA"
" graph, and then we show some examples to clarify what we introduced up to "
"now."
msgstr "接下来的章节，我们将介绍连接节点的连接，这样就创建了完整的AiiDA可验证性图，在往后，我们给出一些上述内容的例子。"

#: ../../source/topics/provenance/implementation.rst:46
msgid "Graph links"
msgstr "图的连接"

#: ../../source/topics/provenance/implementation.rst:48
msgid ""
"Process nodes are connected to their input and output data nodes through "
"directed links. Calculation processes can *create* data, while workflow "
"processes can *call* calculations and *return* their outputs. Consider the "
"following graph example, where we represent **data nodes** with circles, "
"**calculation nodes** with squares and **workflow nodes** with diamond "
"shapes."
msgstr ""
"例程节点与输入输出数据节点之间通过有向边连接。算例例程（calculation process）可以 *创建* 数据，而工作流例程（workflow "
"process）只能调用例程并返回其创建的输出。请看以下图作为例子，我们将 **数据节点** 用圈来表示，**算例节点** 用正方形来表示 "
"**工作流节点** 使用菱形表示。"

#: ../../source/topics/provenance/implementation.rst:55
msgid ""
"Simple provenance graph for a workflow (W\\ :sub:`1`) *calling* a "
"calculation (C\\ :sub:`1`). The workflow takes a single **data node** (D\\ "
":sub:`1`\\) as input, and passes it to the calculation when *calling* it. "
"The calculation *creates* a new **data node** (D\\ :sub:`2`\\) that is also "
"*returned* by the **workflow node**."
msgstr ""
"一个工作流的简单可验证性图 (W\\ :sub:`1`) *调用* 算例 (C\\ :sub:`1`。 该工作流将一个 **数据节点** (D\\ "
":sub:`1`\\) 作为输入，当算例调用时将其传入算例。该算例 **创建** 了一个新的 **数据节点**  (D\\ :sub:`2`\\) "
"该节点被 **工作流节点** *返回* 。"

#: ../../source/topics/provenance/implementation.rst:57
msgid ""
"Notice that the different style and names for the two links coming into D\\ "
":sub:`2` is intentional, because it was the calculation that *created* the "
"new data, whereas the workflow merely *returned* it. This subtle distinction"
" has big consequences. By allowing workflow processes to *return* data, it "
"can also *return* data that was among its inputs."
msgstr ""
"注意这里用不同类型的线段和命名区别两种到达 D\\ :sub:`2` 上的有向连接是有意的。因为算例 *创建* "
"了新的数据，而工作流仅仅只是返回了数据。这个潜在的区别有重要的意义。因为工作流流程能够 *返回* 数据，它同样能够 *返回* 它的输入。"

#: ../../source/topics/provenance/implementation.rst:64
msgid ""
"Provenance graph example of a **workflow node** that receives three **data "
"nodes** as input and *returns* one of those inputs. The input link from D\\ "
":sub:`3` to W\\ :sub:`1` and the return link from W\\ :sub:`1` to D\\ "
":sub:`3` introduce a cycle in the graph."
msgstr ""
"**工作流节点** 的可验证性图例中有三个 **数据节点** 作为输入，并*返回* 了其中一个输入。从输入 D\\ :sub:`3` 到 W\\ "
":sub:`1` 的输入连接和从 W\\ :sub:`1` 到 D\\ :sub:`3` 的返回连接使得图形成了环。"

#: ../../source/topics/provenance/implementation.rst:66
msgid ""
"A scenario like this, represented in :numref:`fig_provenance_cycle`, would "
"create a cycle in the provenance graph, breaking the “acyclicity” of the "
"DAG. To restore the directed acyclic graph, we separate the entire "
"provenance graph into two planes as described above: the **data provenance**"
" and the **logical provenance**. With this division, the acyclicity of the "
"graph is restored in the data provenance plane."
msgstr ""
"图中所示的情景 :numref:`fig_provenance_cycle` "
"在可验证性图中引入了环，打破了DAG有向无环的特征。为了还能够储存有向无环图 （DAG）我们将整个图分割成两个部分: **数据可验证性** 和 "
"**逻辑可验证性** 。 按照这种约定，无环图被保存在数据可验证性部分。"

#: ../../source/topics/provenance/implementation.rst:70
msgid ""
"An additional benefit of thinking of the provenance graph in these two "
"planes, is that it allows you to inspect it with different layers of "
"granularity. Imagine a high level workflow that calls a large number of "
"calculations and sub-workflows, that each may also call more sub-processes, "
"to finally produce and return one or more data nodes as its result."
msgstr ""
"另外一个将可验证图分成这样两个部分的好处是，对于一个复杂的工作流，用户可以以不同的粒度来查看不同的部分。比有一个高度聚合的工作流，它调用了非常多的算例和子工作流，子工作流有可能调用许多的子流程，这些子流程返回一个或多个数据节点作为其结果，"

#: ../../source/topics/provenance/implementation.rst:75
msgid "Graph examples"
msgstr "可验证图的例子"

#: ../../source/topics/provenance/implementation.rst:77
msgid ""
"With these basic definitions of AiiDA’s provenance graph in place, let’s "
"take a look at some examples. Consider the sequence of computations that "
"adds two numbers `x` and `y`, and then multiplies the result with a third "
"number `z`. This sequence as represented in the provenance graph would look "
"something like what is shown in :numref:`fig_provenance_add_multiply_data`."
msgstr ""
"通过以上对AiiDA可验证性图的基础定义，我们来看以下例子。考虑这样一系列运算，首先将 两个数 `x` 和 `y` 相加，在将结果成上第三个数 `z` "
"。这个运算过程表示成可验证性图如下图所示 :numref:`fig_provenance_add_multiply_data` 。"

#: ../../source/topics/provenance/implementation.rst:84
msgid ""
"The DAG for computing `(x+y)*z`. We have two simple calculations: C\\ "
":sub:`1` represents the addition and C\\ :sub:`2` the multiplication. The "
"two data nodes D\\ :sub:`1` and D\\ :sub:`2` are the inputs of C\\ :sub:`1`,"
" which *creates* the data node D\\ :sub:`4`\\. Together with D\\ :sub:`3`, "
"D\\ :sub:`4` then forms the input of C\\ :sub:`2`, which multiplies their "
"values that *creates* the product, represented by D\\ :sub:`5`."
msgstr ""
"DAG 计算 `(x+y)*z`. 我们有两个简单的算例： C\\ :sub:`1` 表示求和而 C\\ :sub:`2` 表示乘法运算。两个数据节点 "
"D\\ :sub:`1` 和 D\\ :sub:`2` 是 C\\ :sub:`1` 的输入，它会 *创建* 数据节点 D\\ :sub:`4`\\ 。"
" 与数据节点 D\\ :sub:`3` 进行运算， D\\ :sub:`4` 成为算例 C\\ :sub:`2` 的输入，两者相乘并 *创建* "
"乘积，表示为 D\\ :sub:`5` 数据节点。"

#: ../../source/topics/provenance/implementation.rst:88
msgid ""
"In this simple example, there was no external process that controlled the "
"exact sequence of these operations. This may be imagined however, by adding "
"a workflow that calls the two calculations in succession, as shown in "
":numref:`fig_provenance_add_multiply_full`."
msgstr ""
"在这个简单的例子中，没有外部流程来控制这些运算的顺序。而当引入工作流后，这两个算例按照顺序调用，我们得到如图所示的可验证性图 "
":numref:`fig_provenance_add_multiply_full`."

#: ../../source/topics/provenance/implementation.rst:94
msgid ""
"The same calculation `(x+y)*z` is performed using a workflow. Here the data "
"nodes D\\ :sub:`1`, D\\ :sub:`2`, and D\\ :sub:`3` are the inputs of the "
"workflow W\\ :sub:`1`, which *calls* calculation C\\ :sub:`1` with inputs "
"D\\ :sub:`1` and D\\ :sub:`2`. It then *calls* calculation C\\ :sub:`2`, "
"using as inputs D\\ :sub:`3` and D\\ :sub:`4` (which was *created* by C\\ "
":sub:`2`\\). Calculation C\\ :sub:`2` *creates* data node D\\ :sub:`5`, "
"which is finally *returned* by workflow W\\ :sub:`1`\\."
msgstr ""
"工作流执行了同样的运算 `(x+y)*z` 。此处，输入节点 D\\ :sub:`1`, D\\ :sub:`2` 和 D\\ :sub:`3` "
"是工作流 W\\ :sub:`1` 的输入，该工作流节点使用 D\\ :sub:`1` and D\\ :sub:`2` *调用* 算例 C\\ "
":sub:`1` 然后 *调用* 算例 C\\ :sub:`2` 使用 D\\ :sub:`3` 和 D\\ :sub:`4` (被 C\\ "
":sub:`2`\\ *创建*)。 算例 C\\ :sub:`2` *创建* 数据节点 D\\ :sub:`5` ，最终作为返回值被工作流 W\\ "
":sub:`1`\\ *返回* ."

#: ../../source/topics/provenance/implementation.rst:98
msgid ""
"Notice that if we were to omit the workflow nodes and all its links from the"
" provenance graph in :numref:`fig_provenance_add_multiply_full`, one would "
"end up with the exact same graph as shown in "
":numref:`fig_provenance_add_multiply_data` (the **data provenance** graph)."
msgstr ""
"注意到，如果我们忽略图 :numref:`fig_provenance_add_multiply_full` "
"中，工作流节点和与其相连的所有连接，将会得到与 :numref:`fig_provenance_add_multiply_data` "
"完全相同的可验证性图（ **数据可验证** 图）。"

#: ../../source/topics/provenance/index.rst:7
msgid ""
"In this topic section, the concept of the provenance graph and its "
"implementation will be explained. The "
":ref:`consistency<topics:provenance:consistency>` section details the rules "
"that are imposed on the consistency of the provenance graph when nodes are "
"exported or deleted."
msgstr ""

#: ../../source/topics/repository.rst:5
msgid "Repository"
msgstr ""

#: ../../source/topics/repository.rst:7
msgid ""
"In addition to the :ref:`database <topics:database>`, AiiDA also stores "
"information in the *repository* in the form of files. The repository is "
"optimized to store large amounts of files, which allows AiiDA to scale to "
"high-throughput loads. As a result, the files cannot be accessed directly "
"using file system tools, despite the fact that they are stored somewhere on "
"the local file system. Instead, you should interact with the repository "
"through the API."
msgstr ""

#: ../../source/topics/repository.rst:12
msgid ""
"Since each node can have its own *virtual* file hierarchy, the repository "
"contents of a node are accessed through the "
":class:`~aiida.orm.nodes.node.Node` class. The hierarchy is virtual because "
"the files may not actually be written to disk with the same hierarchy. For "
"more technical information on the implementation, please refer to the "
":ref:`repository internals section <internal-architecture:repository>`."
msgstr ""

#: ../../source/topics/repository.rst:20
msgid "Writing to the repository"
msgstr ""

#: ../../source/topics/repository.rst:22
msgid ""
"To write files to a node, you can use one of the following three methods:"
msgstr ""

#: ../../source/topics/repository.rst:24
msgid ""
":meth:`~aiida.orm.nodes.repository.NodeRepository.put_object_from_file`"
msgstr ""

#: ../../source/topics/repository.rst:25
msgid ""
":meth:`~aiida.orm.nodes.repository.NodeRepository.put_object_from_filelike`"
msgstr ""

#: ../../source/topics/repository.rst:26
msgid ""
":meth:`~aiida.orm.nodes.repository.NodeRepository.put_object_from_tree`"
msgstr ""

#: ../../source/topics/repository.rst:28
msgid ""
"Let's assume that you have a file on your local file system called "
"`/some/path/file.txt` that you want to copy to a node. The most "
"straightforward solution is the following:"
msgstr ""

#: ../../source/topics/repository.rst:36
msgid ""
"Note that the first argument should be an absolute filepath. The second "
"argument is the filename with which the file will be written to the "
"repository of the node. It can be any valid filename as long as it is "
"relative. The target filename can contain nested subdirectories, for example"
" `some/relative/path/file.txt`. The nested directories do not have to exist."
msgstr ""

#: ../../source/topics/repository.rst:42
msgid ""
"Alternatively, it is also possible to write a file to a node from a stream "
"or filelike-object. This is useful when the content of the file is already "
"in memory and prevents having to write it to the local filesystem first. For"
" example, one can do the following:"
msgstr ""

#: ../../source/topics/repository.rst:52
msgid ""
"which is the same as the previous example, except the file is opened first "
"in a context manager and then the filelike-object is passed in. The "
":meth:`~aiida.orm.nodes.repository.NodeRepository.put_object_from_filelike` "
"method should work with any filelike-object, for example also byte- and "
"textstreams:"
msgstr ""

#: ../../source/topics/repository.rst:61
msgid ""
"Finally, instead of writing one file at a time, you can write the contents "
"of an entire directory to the node's repository:"
msgstr ""

#: ../../source/topics/repository.rst:68
msgid ""
"The contents of the entire directory will be recursively written to the "
"node's repository. Optionally, you can write the content to a subdirectory "
"in the repository:"
msgstr ""

#: ../../source/topics/repository.rst:76
msgid ""
"As with "
":meth:`~aiida.orm.nodes.repository.NodeRepository.put_object_from_file`, the"
" sub directories do not have to be explicitly created first."
msgstr ""

#: ../../source/topics/repository.rst:82
msgid "Listing repository content"
msgstr ""

#: ../../source/topics/repository.rst:84
msgid ""
"To determine the contents of a node's repository, you can use the following "
"methods:"
msgstr ""

#: ../../source/topics/repository.rst:86
msgid ":meth:`~aiida.orm.nodes.repository.NodeRepository.list_object_names`"
msgstr ""

#: ../../source/topics/repository.rst:87
msgid ":meth:`~aiida.orm.nodes.repository.NodeRepository.list_objects`"
msgstr ""

#: ../../source/topics/repository.rst:88
msgid ":meth:`~aiida.orm.nodes.repository.NodeRepository.walk`"
msgstr ""

#: ../../source/topics/repository.rst:90
msgid ""
"The first method will return a list of file objects contained within the "
"node's repository, where an object can be either a directory or a file:"
msgstr ""

#: ../../source/topics/repository.rst:97
msgid ""
"To determine the contents of a subdirectory, simply pass the path as an "
"argument:"
msgstr ""

#: ../../source/topics/repository.rst:104
msgid ""
"Note that the elements in the returned list are simple strings and so one "
"cannot tell if they correspond to a directory or a file. If this information"
" is needed, use "
":meth:`~aiida.orm.nodes.repository.NodeRepository.list_objects` instead. "
"This method returns a list of :class:`~aiida.repository.common.File` "
"objects. These objects have a "
":meth:`~aiida.repository.common.File.file_type` and "
":meth:`~aiida.repository.common.File.name` property which returns the type "
"and name of the file object, respectively. An example usage would be the "
"following:"
msgstr ""

#: ../../source/topics/repository.rst:120
msgid ""
"To retrieve a specific file object with a particular relative path, use "
":meth:`~aiida.orm.nodes.repository.NodeRepository.get_object`:"
msgstr ""

#: ../../source/topics/repository.rst:127
msgid ""
"Finally, if you want to recursively iterate over the contents of a node's "
"repository, you can use the "
":meth:`~aiida.orm.nodes.repository.NodeRepository.walk` method. It operates "
"exactly as the |os.walk|_:"
msgstr ""

#: ../../source/topics/repository.rst:142
msgid "Reading from the repository"
msgstr ""

#: ../../source/topics/repository.rst:144
msgid ""
"To retrieve the content of files stored in a node's repository, you can use "
"the following methods:"
msgstr ""

#: ../../source/topics/repository.rst:146
msgid ":meth:`~aiida.orm.nodes.repository.NodeRepository.open`"
msgstr ""

#: ../../source/topics/repository.rst:147
msgid ":meth:`~aiida.orm.nodes.repository.NodeRepository.get_object_content`"
msgstr ""

#: ../../source/topics/repository.rst:149
msgid ""
"The first method functions exactly as Python's ``open`` built-in function:"
msgstr ""

#: ../../source/topics/repository.rst:156
msgid ""
"The :meth:`~aiida.orm.nodes.repository.NodeRepository.get_object_content` "
"method provides a short-cut for this operation in case you want to directly "
"read the content into memory:"
msgstr ""

#: ../../source/topics/repository.rst:162
msgid ""
"Both methods accept a second argument to determine whether the file should "
"be opened in text- or binary-mode. The valid values are ``'r'`` and "
"``'rb'``, respectively. Note that these methods can only be used to read "
"content from the repository and so any other read modes, such as ``'wb'``, "
"will result in an exception. To write files to the repository, use the "
"methods that are described in the section on :ref:`writing to the repository"
" <topics:repository:writing>`."
msgstr ""

#: ../../source/topics/repository.rst:171
msgid "Copying from the repository"
msgstr ""

#: ../../source/topics/repository.rst:173
msgid ""
"If you want to copy specific files from a node's repository, the section on "
":ref:`reading from the repository<topics:repository:reading>` shows how to "
"read their content which can then be written elsewhere. However, sometimes "
"you want to copy the entire contents of the node's repository, or a "
"subdirectory of it. The "
":meth:`~aiida.orm.nodes.repository.NodeRepository.copy_tree` method makes "
"this easy and can be used as follows:"
msgstr ""

#: ../../source/topics/repository.rst:181
msgid ""
"which will write the entire repository content of ``node`` to the directory "
"``/some/target/directory`` on the local file system. If you only want to "
"copy a particular subdirectory of the repository, you can pass this as the "
"second ``path`` argument:"
msgstr ""

#: ../../source/topics/repository.rst:188
msgid ""
"This method, combined with "
":meth:`~aiida.orm.nodes.repository.NodeRepository.put_object_from_tree`, "
"makes it easy to copy the entire repository content (or a subdirectory) from"
" one node to another:"
msgstr ""

#: ../../source/topics/repository.rst:200
msgid ""
"Note that this method is not the most efficient as the files are first "
"written from ``node_a`` to a temporary directory on disk, before they are "
"read in memory again and written to the repository of ``node_b``. There is a"
" more efficient method which requires a bit more code and that directly uses"
" the :meth:`~aiida.orm.nodes.repository.NodeRepository.walk` method "
"explained in the section on :ref:`listing repository content "
"<topics:repository:listing>`."
msgstr ""

#: ../../source/topics/repository.rst:214
msgid ""
"In the example above, only the files are explicitly copied over. Any "
"intermediate nested directories will be automatically created in the virtual"
" hierarchy. However, currently it is not possible to create a directory "
"explicitly. Empty directories are not yet supported."
msgstr ""

#: ../../source/topics/schedulers.rst:5
msgid "Batch Job Schedulers"
msgstr ""

#: ../../source/topics/schedulers.rst:7
msgid ""
"Batch job schedulers manage the job queues and execution on a compute "
"resource. AiiDA ships with plugins for a range of schedulers, and this "
"section describes the interface of these plugins."
msgstr ""

#: ../../source/topics/schedulers.rst:10
msgid ""
"Follow :ref:`these instructions <topics:schedulers:develop_plugin>` to add "
"support for a custom scheduler."
msgstr ""

#: ../../source/topics/schedulers.rst:13
msgid "PBSPro"
msgstr "PBSPro"

#: ../../source/topics/schedulers.rst:15
msgid "The `PBSPro`_ scheduler is supported (tested: version 12.1)."
msgstr ""

#: ../../source/topics/schedulers.rst:17 ../../source/topics/schedulers.rst:28
#: ../../source/topics/schedulers.rst:39 ../../source/topics/schedulers.rst:57
#: ../../source/topics/schedulers.rst:86
msgid "All the main features are supported with this scheduler."
msgstr "该任务调度工具的主要特性均测试可用。"

#: ../../source/topics/schedulers.rst:19 ../../source/topics/schedulers.rst:30
#: ../../source/topics/schedulers.rst:59 ../../source/topics/schedulers.rst:88
msgid ""
"Use the :ref:`topics:schedulers:job_resources:node` when setting job "
"resources."
msgstr ""

#: ../../source/topics/schedulers.rst:24
msgid "SLURM"
msgstr "SLURM"

#: ../../source/topics/schedulers.rst:26
msgid "The `SLURM`_ scheduler is supported (tested: version 2.5.4)."
msgstr ""

#: ../../source/topics/schedulers.rst:35
msgid "SGE"
msgstr "SGE"

#: ../../source/topics/schedulers.rst:37
msgid ""
"The `SGE`_ scheduler (Sun Grid Engine, now called Oracle Grid Engine) and "
"some of its main variants/forks are supported (tested: version GE 6.2u3)."
msgstr ""

#: ../../source/topics/schedulers.rst:41
msgid ""
"Use the :ref:`topics:schedulers:job_resources:par` when setting job "
"resources."
msgstr ""

#: ../../source/topics/schedulers.rst:46
msgid "LSF"
msgstr "LSF"

#: ../../source/topics/schedulers.rst:48
msgid ""
"The IBM `LSF`_ scheduler is supported (tested: version 9.1.3 on the CERN "
"`lxplus` cluster)."
msgstr ""

#: ../../source/topics/schedulers.rst:53
msgid "Torque"
msgstr "Torque"

#: ../../source/topics/schedulers.rst:55
msgid ""
"`Torque`_ (based on OpenPBS) is supported (tested: version 2.4.16 from "
"Ubuntu)."
msgstr ""

#: ../../source/topics/schedulers.rst:66
msgid "Direct execution (bypassing schedulers)"
msgstr "直接运行 (不通过任务管理系统)"

#: ../../source/topics/schedulers.rst:68
msgid ""
"The ``direct`` scheduler plugin simply executes the command in a new bash "
"shell, puts it in the background and checks for its process ID (PID) to "
"determine when the execution is completed."
msgstr ""

#: ../../source/topics/schedulers.rst:70
msgid ""
"Its main purpose is debugging on the local machine. Use a proper batch "
"scheduler for any production calculations."
msgstr ""

#: ../../source/topics/schedulers.rst:75
msgid ""
"Compared to a proper batch scheduler, direct execution mode is fragile. In "
"particular:"
msgstr ""

#: ../../source/topics/schedulers.rst:78
msgid "There is no queueing, i.e. all calculations run in parallel."
msgstr ""

#: ../../source/topics/schedulers.rst:79
msgid "PID numeration is reset during reboots."
msgstr ""

#: ../../source/topics/schedulers.rst:83
msgid ""
"Do *not* use the direct scheduler for running on a supercomputer. The job "
"will end up running on the login node (which is typically forbidden), and if"
" your centre has multiple login nodes, AiiDA may get confused if subsequent "
"SSH connections end up at a different login node (causing AiiDA to infer "
"that the job has completed)."
msgstr ""

#: ../../source/topics/schedulers.rst:94
msgid "Job resources"
msgstr "任务资源"

#: ../../source/topics/schedulers.rst:96
msgid ""
"Unsurprisingly, different schedulers have different ways of specifying the "
"resources for a job (such as the number of required nodes or the numbers of "
"MPI processes per node)."
msgstr ""

#: ../../source/topics/schedulers.rst:98
msgid ""
"In AiiDA, these differences are accounted for by subclasses of the "
"|JobResource|  class. The previous section lists which subclass to use with "
"a given scheduler."
msgstr ""

#: ../../source/topics/schedulers.rst:101
msgid ""
"All subclasses define at least the "
":py:meth:`~aiida.schedulers.datastructures.JobResource.get_tot_num_mpiprocs`"
" method that returns the total number of MPI processes requested but "
"otherwise have slightly different interfaces described in the following."
msgstr ""

#: ../../source/topics/schedulers.rst:105
msgid ""
"You can manually load a `specific` |JobResource| subclass by directly "
"importing it, e.g."
msgstr ""

#: ../../source/topics/schedulers.rst:111
msgid ""
"In practice, however, the appropriate class will be inferred from scheduler "
"configured for the relevant AiiDA computer, and you can simply set the "
"relevant fields in the ``metadata.options`` input dictionary of the "
"|CalcJob|."
msgstr ""

#: ../../source/topics/schedulers.rst:113
msgid ""
"For a scheduler with job resources of type |NodeNumberJobResource|, this "
"could be:"
msgstr ""

#: ../../source/topics/schedulers.rst:132
msgid "NodeNumberJobResource (PBS-like)"
msgstr "NodeNumberJobResource (PBS-like)"

#: ../../source/topics/schedulers.rst:134
msgid ""
"The |NodeNumberJobResource| class is used for specifying job resources in "
"PBS and SLURM."
msgstr ""

#: ../../source/topics/schedulers.rst:136
#: ../../source/topics/schedulers.rst:190
msgid "The class has the following attributes:"
msgstr ""

#: ../../source/topics/schedulers.rst:138
msgid ""
"``res.num_machines``: the number of machines (also called nodes) on which "
"the code should run"
msgstr ""

#: ../../source/topics/schedulers.rst:139
msgid ""
"``res.num_mpiprocs_per_machine``: number of MPI processes to use on each "
"machine"
msgstr "``res.num_mpiprocs_per_machine``: 每台机器（节点）上运行的MPI进程的数量"

#: ../../source/topics/schedulers.rst:140
#: ../../source/topics/schedulers.rst:193
msgid ""
"``res.tot_num_mpiprocs``: the total number of MPI processes that this job "
"requests"
msgstr ""

#: ../../source/topics/schedulers.rst:141
msgid ""
"``res.num_cores_per_machine``: the number of cores to use on each machine"
msgstr ""

#: ../../source/topics/schedulers.rst:142
msgid ""
"``res.num_cores_per_mpiproc``: the number of cores to run each MPI process "
"on"
msgstr ""

#: ../../source/topics/schedulers.rst:144
msgid ""
"You need to specify only two among the first three fields above, but they "
"have to be defined upon construction. We suggest using the first two, for "
"instance:"
msgstr ""

#: ../../source/topics/schedulers.rst:151
msgid ""
"asks the scheduler to allocate 4 machines, with 16 MPI processes on each "
"machine. This will automatically ask for a total of ``4*16=64`` total number"
" of MPI processes."
msgstr "向任务调度工具申请4台机器，每台机器16个MPI进程。这会自动请求总共 ``4*16=64`` 个的MPI进程。"

#: ../../source/topics/schedulers.rst:156
msgid ""
"When creating a new computer, you will be asked for a "
"``default_mpiprocs_per_machine``. If specified, it will automatically be "
"used as the default value for ``num_mpiprocs_per_machine`` whenever creating"
" the resources for that computer."
msgstr ""

#: ../../source/topics/schedulers.rst:161
msgid ""
"If you prefer using ``res.tot_num_mpiprocs`` instead, make sure it is a "
"multiple of ``res.num_machines`` and/or ``res.num_mpiprocs_per_machine``."
msgstr ""

#: ../../source/topics/schedulers.rst:163
msgid "The first three fields are related by the equation:"
msgstr ""

#: ../../source/topics/schedulers.rst:170
msgid ""
"The ``num_cores_per_machine`` and ``num_cores_per_mpiproc`` fields are "
"optional and must satisfy the equation:"
msgstr ""

#: ../../source/topics/schedulers.rst:179
msgid ""
"In PBSPro, the ``num_mpiprocs_per_machine`` and ``num_cores_per_machine`` "
"fields are used for mpiprocs and ppn respectively."
msgstr ""

#: ../../source/topics/schedulers.rst:181
msgid ""
"In Torque, the ``num_mpiprocs_per_machine`` field is used for ppn unless the"
" ``num_mpiprocs_per_machine`` is specified."
msgstr ""

#: ../../source/topics/schedulers.rst:186
msgid "ParEnvJobResource (SGE-like)"
msgstr "ParEnvJobResource (SGE-like)"

#: ../../source/topics/schedulers.rst:188
msgid ""
"The :py:class:`~aiida.schedulers.datastructures.ParEnvJobResource` class is "
"used for specifying the resources of SGE and similar schedulers, which "
"require specifying a *parallel environment* and the *total number of CPUs* "
"requested."
msgstr ""

#: ../../source/topics/schedulers.rst:192
msgid ""
"``res.parallel_env``: the parallel environment in which you want to run your"
" job (a string)"
msgstr ""

#: ../../source/topics/schedulers.rst:195
msgid ""
"Both attributes are required. No checks are done on the consistency between "
"the specified parallel environment and the total number of MPI processes "
"requested (for instance, some parallel environments may have been configured"
" by your cluster administrator to run on a single machine). It is your "
"responsibility to make sure that the information is valid, otherwise the "
"submission will fail."
msgstr ""

#: ../../source/topics/schedulers.rst:199
msgid "Setting the fields directly in the class constructor:"
msgstr ""

#: ../../source/topics/schedulers.rst:205
msgid ""
"And setting the fields using the ``metadata.options`` input dictionary of "
"the |CalcJob|:"
msgstr ""

#: ../../source/topics/schedulers.rst:220 ../../source/topics/transport.rst:17
msgid "Developing a plugin"
msgstr ""

#: ../../source/topics/schedulers.rst:222
msgid ""
"A scheduler plugin allows AiiDA to communicate with a specific type of "
"scheduler. The plugin should subclass the "
":class:`~aiida.schedulers.scheduler.Scheduler` class and implement a number "
"of methods, that will instruct how certain key commands are to be executed, "
"such as submitting a new job or requesting the current active jobs. To get "
"you started, you can download :download:`this template "
"<include/scheduler_template.py>` and implement the following methods:"
msgstr ""

#: ../../source/topics/schedulers.rst:226
msgid ""
"``_get_joblist_command``: returns the command to report a full information "
"on existing jobs."
msgstr ""

#: ../../source/topics/schedulers.rst:227
msgid ""
"``_get_detailed_job_info_command``: returns the command to get the detailed "
"information on  a job, even after the job has finished."
msgstr ""

#: ../../source/topics/schedulers.rst:228
msgid "``_get_submit_script_header``: return the submit script header."
msgstr ""

#: ../../source/topics/schedulers.rst:229
msgid "``_get_submit_command``: return the string to submit a given script."
msgstr ""

#: ../../source/topics/schedulers.rst:230
msgid ""
"``_parse_joblist_output``: parse the queue output string, as returned by "
"executing the command returned by `_get_joblist_command`."
msgstr ""

#: ../../source/topics/schedulers.rst:231
msgid ""
"``_parse_submit_output``: parse the output of the submit command, as "
"returned by executing the command returned by `_get_submit_command`."
msgstr ""

#: ../../source/topics/schedulers.rst:232
msgid ""
"``_get_kill_command``: return the command to kill the job with specified "
"jobid."
msgstr ""

#: ../../source/topics/schedulers.rst:233
msgid "``_parse_kill_output``: parse the output of the kill command."
msgstr ""

#: ../../source/topics/schedulers.rst:234
msgid "``parse_output``: parse the output of the scheduler."
msgstr ""

#: ../../source/topics/schedulers.rst:236
msgid ""
"All these methods *have* to be implemented, except for "
"``_get_detailed_job_info_command`` and ``parse_output``, which are optional."
" In addition to these methods, the ``_job_resource_class`` class attribute "
"needs to be set to a subclass "
":class:`~aiida.schedulers.datastructures.JobResource`. For schedulers that "
"work like SLURM, Torque and PBS, one can most likely simply reuse the "
":class:`~aiida.schedulers.datastructures.NodeNumberJobResource` class, that "
"ships with ``aiida-core``. Schedulers that work like LSF and SGE, may be "
"able to reuse :class:`~aiida.schedulers.datastructures.ParEnvJobResource` "
"instead. If neither of these work, one can implement a custom subclass, a "
"template for which, the class called ``TemplateJobResource``, is already "
"included in the template file."
msgstr ""

#: ../../source/topics/schedulers.rst:245
msgid ""
"To inform AiiDA about your new scheduler plugin you must register an entry "
"point in the ``aiida.schedulers`` entry point group. Refer to :ref:`the "
"section on how to register plugins <how-to:plugins-develop:entrypoints>` for"
" instructions."
msgstr ""

#: ../../source/topics/storage.rst:5
msgid "Storage"
msgstr ""

#: ../../source/topics/storage.rst:7
msgid ""
"Each AiiDA profile defines a *storage* which is where all data in the "
"provenance graph is stored. Typically, a storage consists of a "
":ref:`database <topics:database>` and a :ref:`repository "
"<topics:repository>`. The provenance graph data itself is mostly persisted "
"to the database, whereas files attached to nodes (or other binary content) "
"are stored in the repository."
msgstr ""

#: ../../source/topics/storage.rst:11
msgid ""
"By default, the storage consists of a PostgreSQL database and a `disk-"
"objectstore container <https://disk-objectstore.readthedocs.io/en/latest/>`_"
" for the file repository. As of AiiDA 2.0, however, this storage can be "
"customized through plugins, meaning other databases and file stores can be "
"used if desired. AiiDA ships itself with a number of storage plugins that "
"each have their own strengths and weaknesses. This section gives an overview"
" of these storage plugins with suggestions of when to use them."
msgstr ""

#: ../../source/topics/storage.rst:19
msgid "core.psql_dos"
msgstr ""

#: ../../source/topics/storage.rst:23
msgid "*Default storage for production projects that require performance.*"
msgstr ""

#: ../../source/topics/storage.rst:25
msgid ":fa:`database;mr-1` PostgreSQL database"
msgstr ""

#: ../../source/topics/storage.rst:27 ../../source/topics/storage.rst:47
#: ../../source/topics/storage.rst:67
msgid ":fa:`file;mr-1` ``disk-objectstore`` container"
msgstr ""

#: ../../source/topics/storage.rst:29 ../../source/topics/storage.rst:49
#: ../../source/topics/storage.rst:69 ../../source/topics/storage.rst:89
msgid ":fa:`plus;mr-1` **Strengths**:"
msgstr ""

#: ../../source/topics/storage.rst:31
msgid "Supports all of AiiDA's functionality"
msgstr ""

#: ../../source/topics/storage.rst:32
msgid "Good performance"
msgstr ""

#: ../../source/topics/storage.rst:33
msgid "Automatic database migrations"
msgstr ""

#: ../../source/topics/storage.rst:35 ../../source/topics/storage.rst:54
#: ../../source/topics/storage.rst:74 ../../source/topics/storage.rst:94
msgid ":fa:`minus;mr-1` **Weaknesses**:"
msgstr ""

#: ../../source/topics/storage.rst:37
msgid "Requires a service running (PostgreSQL)"
msgstr ""

#: ../../source/topics/storage.rst:39
msgid "core.sqlite_dos"
msgstr ""

#: ../../source/topics/storage.rst:43
msgid "*Easy to set up storage for tests, demos and experimenting.*"
msgstr ""

#: ../../source/topics/storage.rst:45 ../../source/topics/storage.rst:65
#: ../../source/topics/storage.rst:85
msgid ":fa:`database;mr-1` SQLite database"
msgstr ""

#: ../../source/topics/storage.rst:51
msgid "Easy to set up and backup"
msgstr ""

#: ../../source/topics/storage.rst:52 ../../source/topics/storage.rst:72
#: ../../source/topics/storage.rst:91
msgid "Requires no running services"
msgstr ""

#: ../../source/topics/storage.rst:56
msgid "Performance of SQLite is inferior to PostgreSQL"
msgstr ""

#: ../../source/topics/storage.rst:57 ../../source/topics/storage.rst:77
#: ../../source/topics/storage.rst:97
msgid "Some ``QueryBuilder`` functionality is not supported :fa:`asterisk`"
msgstr ""

#: ../../source/topics/storage.rst:59
msgid "core.sqlite_zip"
msgstr ""

#: ../../source/topics/storage.rst:63
msgid "*Storage contained in single ZIP file used for export archives.*"
msgstr ""

#: ../../source/topics/storage.rst:71
msgid "Easy to set up"
msgstr ""

#: ../../source/topics/storage.rst:76
msgid "Read-only"
msgstr ""

#: ../../source/topics/storage.rst:79
msgid "core.sqlite_temp"
msgstr ""

#: ../../source/topics/storage.rst:83
msgid "*Temporary storage mostly used for unit testing or demonstrations.*"
msgstr ""

#: ../../source/topics/storage.rst:87
msgid ":fa:`file;mr-1` Sandbox directory"
msgstr ""

#: ../../source/topics/storage.rst:92
msgid "Automatic cleanup"
msgstr ""

#: ../../source/topics/storage.rst:96
msgid "Storage is deleted once session is closed"
msgstr ""

#: ../../source/topics/storage.rst:101
msgid ""
":fa:`asterisk;mr-1` The following features of the ``QueryBuilder`` are known"
" to not be supported for SQLite-based storages:"
msgstr ""

#: ../../source/topics/storage.rst:103
msgid "Use of ``contains`` in ``filters``"
msgstr ""

#: ../../source/topics/storage.rst:104
msgid "The ``get_creation_statistics`` method"
msgstr ""

#: ../../source/topics/storage.rst:111
msgid "``core.psql_dos``"
msgstr ""

#: ../../source/topics/storage.rst:113
msgid ""
"The ``core.psql_dos`` storage plugin is the default and is recommended for "
"all production work. It uses PostgreSQL for the database and the disk-"
"objectstore for the file repository. To create a profile using this storage "
"plugin, run:"
msgstr ""

#: ../../source/topics/storage.rst:121
msgid ""
"The command requires the PostgreSQL database to already exist and to be able"
" to connect to it."
msgstr ""

#: ../../source/topics/storage.rst:125
msgid ""
"Try the ``verdi quicksetup`` command to have the PostgreSQL database "
"automatically created. Certain systems require root access to do so, causing"
" the command to fail if it cannot obtain root access. In this case, the "
"database should be created manually (see :ref:`intro:install:database` for "
"details). Once created, a profile can be created using the database with the"
" command ``verdi profile setup core.psql_dos``."
msgstr ""

#: ../../source/topics/storage.rst:134
msgid "``core.sqlite_dos``"
msgstr ""

#: ../../source/topics/storage.rst:136
msgid ""
"The ``core.sqlite_dos`` storage plugin is an alternative to the "
"``core.psql_dos`` storage for use cases where performance is not critical. "
"Instead of a PostgreSQL database, it uses SQLite. This makes it easier to "
"set up as it does not require a running service, as the SQLite database is "
"just a file on disk."
msgstr ""

#: ../../source/topics/storage.rst:140
msgid ""
"A fully operational profile using this storage plugin can be created with a "
"single command:"
msgstr ""

#: ../../source/topics/storage.rst:146
msgid ""
"replacing ``<PROFILE_NAME>`` with the desired name for the profile and "
"``<EMAIL>`` with the email for the default user."
msgstr ""

#: ../../source/topics/storage.rst:148
msgid ""
"The SQLite database and disk-objectstore container are both stored in the "
"directory specified by the ``--filepath`` option of the ``verdi profile "
"setup core.sqlite_dos`` command. By default, this is a folder inside the "
"directory defined by the ``$AIIDA_PATH/repository`` of the form "
"``sqlite_dos_{UUID}``, where the suffix is randomly generated hexadecimal "
"UUID. An example of an automated generated directory is "
"``.aiida/repository/sqlite_dos_962e87af09b746c985335cb77acaa553``."
msgstr ""

#: ../../source/topics/storage.rst:154
msgid ""
"The ``$AIIDA_PATH`` environment variable :ref:`determines the location of "
"the configuration directory <how-to:installation:configure:instance-"
"isolation>`, and defaults to ``.aiida`` in the user's home folder"
msgstr ""

#: ../../source/topics/storage.rst:160
msgid "``core.sqlite_zip``"
msgstr ""

#: ../../source/topics/storage.rst:162
msgid ""
"The ``core.sqlite_zip`` is a storage plugin that is used to create export "
"archives. It functions more or less identical to the ``core.sqlite_dos`` "
"plugin, as it uses an SQLite database and a disk-objectstore container, "
"except everything is bundled up in a `zip archive "
"<https://en.wikipedia.org/wiki/ZIP_(file_format)>`_."
msgstr ""

#: ../../source/topics/storage.rst:165
msgid ""
"The storage plugin is not suited for normal use, because once the archive is"
" created, it becomes read-only. However, since otherwise it functions like "
"normal storage plugins, a profile can be created with it that make it easy "
"to explore its contents:"
msgstr ""

#: ../../source/topics/storage.rst:172
msgid ""
"replacing ``<PROFILE_NAME>`` with the desired name for the profile and "
"``<ARCHIVE>`` the path to the archive file. The created profile can now be "
"loaded like any other profile, and the contents of the provenance graph can "
"be explored as usual."
msgstr ""

#: ../../source/topics/storage.rst:179
msgid "``core.sqlite_temp``"
msgstr ""

#: ../../source/topics/storage.rst:181
msgid ""
"The ``core.sqlite_temp`` storage plugin utilises an in-memory SQLite "
"database and sandbox folder to store data. The data is automatically "
"destroyed as soon as the profile is garbage collected, which is either when "
"it is unloaded, or the Python interpreter is shut down. This makes this "
"storage plugin primarily useful for demonstration and testing purposes, "
"whereby no persistent storage is required."
msgstr ""

#: ../../source/topics/storage.rst:185
msgid "A new temporary profile can be created and loaded as follows:"
msgstr ""

#: ../../source/topics/transport.rst:5
msgid "Transport plugins"
msgstr ""

#: ../../source/topics/transport.rst:7
msgid ""
"The term `transport` in AiiDA refers to a class that the engine uses to "
"perform operations on local or remote machines where its "
":py:class:`~aiida.engine.processes.calcjobs.calcjob.CalcJob` are submitted. "
"The base class :py:class:`~aiida.transports.transport.Transport` defines an "
"interface for these operations, such as copying files and executing "
"commands. A `transport plugin` is a class that implements this base class "
"for a specific connection method. The ``aiida-core`` package ships with two "
"transport plugins: the "
":py:class:`~aiida.transports.plugins.local.LocalTransport` and "
":py:class:`~aiida.transports.plugins.ssh.SshTransport` classes. The "
"``local`` transport can be used to connect with the `localhost` and makes "
"use only of some standard python modules like ``os`` and ``shutil``. The "
"``ssh`` transport, which can be used for machines that can be connected to "
"over ssh, is simply a wrapper around the library `paramiko "
"<https://www.paramiko.org/>`_ that is installed as a required dependency of "
"``aiida-core``."
msgstr ""

#: ../../source/topics/transport.rst:19
msgid ""
"The transport class is actually almost never used directly by the user. It "
"is mostly utilized by the engine that uses the transport plugin to connect "
"to the machine where the calculation job, that it is managing, is running. "
"The engine has to be able to use always the same methods regardless of which"
" kind of transport is required to connect to the computer in question."
msgstr ""

#: ../../source/topics/transport.rst:23
msgid ""
"The generic transport class contains a set of minimal methods that an "
"implementation must support in order to be fully compatible with the other "
"plugins. If not, a ``NotImplementedError`` will be raised, interrupting the "
"managing of the calculation or whatever is using the transport plugin."
msgstr ""

#: ../../source/topics/transport.rst:26
msgid ""
"As for the general functioning of the plugin, the "
":py:meth:`~aiida.transports.transport.Transport.__init__` method is used "
"only to initialize the class instance, without actually opening the "
"transport channel. The connection must be opened only by the "
":py:meth:`~aiida.transports.transport.Transport.__enter__` method, (and "
"closed by :py:meth:`~aiida.transports.transport.Transport.__exit__`). The "
":py:meth:`~aiida.transports.transport.Transport.__enter__` method lets you "
"use the transport class using the ``with`` statement (see `python docs "
"<https://docs.python.org/3/reference/compound_stmts.html#with>`_), in a way "
"similar to the following:"
msgstr ""

#: ../../source/topics/transport.rst:35
msgid ""
"To ensure this, for example, the local plugin uses a hidden boolean variable"
" ``_is_open`` that is set when the "
":py:meth:`~aiida.transports.transport.Transport.__enter__` and "
":py:meth:`~aiida.transports.transport.Transport.__exit__` methods are "
"called. The ``ssh`` logic is instead given by the property sftp."
msgstr ""

#: ../../source/topics/transport.rst:38
msgid ""
"The other functions that require some care are the copying functions, called"
" using the following terminology:"
msgstr ""

#: ../../source/topics/transport.rst:40
msgid "``put``: from local source to remote destination"
msgstr ""

#: ../../source/topics/transport.rst:41
msgid "``get``: from remote source to local destination"
msgstr ""

#: ../../source/topics/transport.rst:42
msgid "``copy``: copying files from remote source to remote destination"
msgstr ""

#: ../../source/topics/transport.rst:44
msgid ""
"Note that these functions must accept both files and folders and internally "
"they will fallback to functions like ``putfile`` or ``puttree``."
msgstr ""

#: ../../source/topics/transport.rst:46
msgid ""
"The last function requiring care is "
":py:meth:`~aiida.transports.transport.Transport.exec_command_wait`, which is"
" an analogue to the `subprocess "
"<http://docs.python.org/3/library/subprocess.html>`_ python module. The "
"function gives the freedom to execute a string as a remote command, thus it "
"could produce nasty effects if not written with care."
msgstr ""

#: ../../source/topics/transport.rst:51
msgid "Be sure to escape any strings for bash!"
msgstr ""

#: ../../source/topics/transport.rst:53
msgid ""
"Download :download:`this template <transport_template.py>` as a starting "
"point to implementing a new transport plugin. It contains the interface with"
" all the methods that need to be implemented, including docstrings that will"
" work with Sphinx documentation."
msgstr ""

#: ../../source/topics/transport.rst:58
msgid ""
"To inform AiiDA about your new transport plugin you must register an entry "
"point in the ``aiida.transports`` entry point group. Please visit the `AiiDA"
" registry <https://aiidateam.github.io/aiida-registry/>`_ to see an example "
"of how this can be done."
msgstr ""

#: ../../source/topics/transport.rst:65
msgid "Login shells"
msgstr ""

#: ../../source/topics/transport.rst:67
msgid ""
"The base transport class :class:`aiida.transports.transport.Transport` "
"defines the ``use_login_shell`` option. When set to ``True``, all commands "
"executed over the transport will use the ``-l/--login`` option of ``bash``. "
"This instructs bash to load a login shell, which, according to the ``bash`` "
"manpage, means:"
msgstr ""

#: ../../source/topics/transport.rst:71
msgid ""
"When bash is invoked as an interactive login shell, or as a non-interactive "
"shell with the ``--login`` option, it first reads and executes commands from"
" the file ``/etc/profile``, if that file exists. After reading that file, it"
" looks for ``~/.bash_profile``, ``~/.bash_login``, and ``~/.profile``, in "
"that order, and reads and executes commands from the first one that exists "
"and is readable."
msgstr ""

#: ../../source/topics/transport.rst:74
msgid ""
"By default ``use_login_shell`` is set to ``True`` as it ensures that the "
"commands executed over the transport by AiiDA see the same shell environment"
" as the user, if they were to login manually and execute the command. "
"However, in certain cases, the login scripts might not be necessary for "
"AiiDA to properly run codes on the target computer. At the same time, it is "
"possible that the login scripts have a non-negligible run time, and so can "
"significantly slow down all the commands AiiDA has to execute. In this case,"
" it may be useful to set the ``use_login_shell`` to ``False``."
msgstr ""

#: ../../source/topics/workflows/concepts.rst:7
#: ../../source/topics/workflows/usage.rst:9
msgid ""
"A workflow in AiiDA is a process (see the :ref:`process "
"section<topics:processes:concepts>` for details) that calls other workflows "
"and calculations and optionally *returns* data and as such can encode the "
"logic of a typical scientific workflow. Currently, there are two ways of "
"implementing a workflow process:"
msgstr ""

#: ../../source/topics/workflows/concepts.rst:10
msgid ":ref:`work functions<topics:workflows:concepts:workfunctions>`"
msgstr ":ref:`工作函数（work functions）<topics:workflows:concepts:workfunctions>`"

#: ../../source/topics/workflows/concepts.rst:11
msgid ":ref:`work chains<topics:workflows:concepts:workchains>`"
msgstr ":ref:`工作链（work chains）<topics:workflows:concepts:workchains>`"

#: ../../source/topics/workflows/concepts.rst:13
msgid ""
"The first one is the simplest of the two and is basically a python function "
"that is magically transformed into a process. This is ideal for workflows "
"that are not very computationally intensive and can be easily implemented in"
" a python function. For more complex workflows, the work chain is a better "
"alternative. By chaining work chains and work functions together, that each "
"can run other sub processes, we can define a workflow. For simplicity, from "
"here on out, we will use the terms, workflows, work chains, and work "
"functions interchangeably, as a *pars pro toto* and *totum pro parte*."
msgstr ""
"前一种较为简单，仅仅是对python函数的封装变换。这对那些并不是非常耗费计算量的工作流非常合适并且它能够容易的通过python函数实现。对于更为复杂的工作流，工作链（work"
" chain）是更好的选择。通过将工作函数和工作链将流程连接，我们就定义出了作为的工作流。为了简单起见，我们这里在使用特定术语时对三者不作明显区分，好比"
" *石头剪刀布* 和 *剪刀石头布* 。"

#: ../../source/topics/workflows/concepts.rst:19
msgid ""
"In the following sections, both concepts will be explained but without going"
" too much into detail on how to implement or run them. For a more detailed "
"exposé, please refer to the respective advanced sections on :ref:`work "
"functions<topics:workflows:usage:workfunctions>` and :ref:`work "
"chains<topics:workflows:usage:workchains>`."
msgstr ""

#: ../../source/topics/workflows/concepts.rst:26
#: ../../source/topics/workflows/usage.rst:21
msgid "Work functions"
msgstr "工作函数"

#: ../../source/topics/workflows/concepts.rst:28
msgid ""
"A work function is implemented just as a :ref:`calculation "
"function<topics:calculations:concepts:calcfunctions>`, however, they have "
"very distinct use cases. Since the work function is a 'workflow-like' "
"process, it can only *return* existing data, whereas the calculation "
"function creates a 'calculation-like' process which can only *create* new "
"data. This difference is addressed in greater detail in the "
":ref:`process<topics:processes:concepts:types>` section and it is very "
"important that one understands this distinction."
msgstr ""

#: ../../source/topics/workflows/concepts.rst:32
msgid ""
"To explain the use of the ``@workfunction``, we will continue with the "
"example of the :ref:`calculation "
"functions<topics:calculations:concepts:calcfunctions>`, so before "
"continuing, read that section first. The example showed how the "
"``@calcfunction`` decorator can be used to create two functions that, for "
"three given integers, computes the sum of the first two, which is then "
"multiplied with the third, all the while keeping the provenance. Even though"
" the calculation functions ensured that the provenance of the data was kept,"
" the logic of *who* called these functions was not explicitly kept. From the"
" provenance graph generated by the calculation functions, it is impossible "
"to deduce whether the functions were called straight after another in a "
"single script, or whether first the ``add`` function was called and a long "
"time later, the output was used as an input for the ``multiply`` function. "
"Capturing this logical provenance of the *sequence of calls* of processes is"
" exactly what workflow-like processes, such as the ``workfunction`` are "
"designed for."
msgstr ""

#: ../../source/topics/workflows/concepts.rst:38
msgid ""
"Consider the following example, where we implement a function called "
"``add_and_multiply`` that we decorate with the ``@workfunction`` decorator."
msgstr ""
"考虑下列例子，我们实现了一个叫做 ``add_and_multiply`` 的函数并使用 ``@workfunction`` 装饰器装饰它。"

#: ../../source/topics/workflows/concepts.rst:54
msgid ""
"Instead of calling the calculation functions directly in the script, we call"
" the work function, which then consecutively calls the calculation "
"functions, passing the intermediate result from the first to the second. If "
"we look at the provenance graph generated by this example, we would see "
"something like the following:"
msgstr ""
"不同于直接使用脚本来调用算例函数，此处我们通过工作流算例来调用算例函数，这会将第一个算例的结果作为中间结果传递给第二个算例。可以从这个例子的可验证性图中发现以下特点："

#: ../../source/topics/workflows/concepts.rst:60
msgid "The full provenance generated by the work function example"
msgstr "所有的可验证性都被工作函数的例子中创建"

#: ../../source/topics/workflows/concepts.rst:62
msgid ""
"It is clear that this provenance graph contains a lot more information than "
"the one for the calculation function example. Whether this information is "
"actually necessary or useful depends on the situation and is entirely up to "
"the user, but there is a big advantage. The strict separation between "
"calculation-like and workflow-like processes and the different allowed links"
" between them, as codified in the :ref:`provenance graph "
"implementation<topics:provenance:implementation>`, may seem a bit excessive "
"at a first glance and to new users. However, the addition of this parallel "
"yet distinct workflow layer that represents the logical provenance, allows "
"one to ignore all the details of the computation. This is demonstrated by "
"the provenance graph below, which is the exact same as the one before, "
"except only data and workflow nodes are shown:"
msgstr ""

#: ../../source/topics/workflows/concepts.rst:71
msgid ""
"The 'logical' provenance generated by the work function example, where only "
"the workflow and data nodes, with their links, are shown"
msgstr "工作函数例子中创建的“逻辑” 可验证性，只包含工作流节点和数据节点及其节点间的连接"

#: ../../source/topics/workflows/concepts.rst:73
msgid ""
"With this reduced representation, the big picture of how the original inputs"
" led to the final result becomes immediately clear. Conversely, none of the "
"actual data provenance is lost. In the figure below, all the workflow nodes "
"are omitted and what we end up with is the exact same provenance graph as in"
" :numref:`fig_calculation_functions_provenance_add_multiply` of the "
":ref:`original example<topics:calculations:concepts:calcfunctions>` that "
"only used calculation functions."
msgstr ""

#: ../../source/topics/workflows/concepts.rst:80
msgid ""
"The 'data' provenance generated by the work function example, where only the"
" calculation and data nodes, with their links, are shown"
msgstr "工作函数例子中的 ‘数据’ 可验证性图，图中只有算例节点和数据节点及其连线。"

#: ../../source/topics/workflows/concepts.rst:82
msgid ""
"In this simple example, the power of being able to select what part of the "
"provenance graph one is interested in is obviously limited. But workflows "
"can quickly become complex and deeply nested, at which point the ability to "
"group parts of the provenance graph together under a single node and "
"effectively 'hide' its internal parts in a transparent way, becomes "
"invaluable."
msgstr ""
"在这个简单的例子中，选择可验证性图中所关注部分的强大功能用途并不明显。但是工作流可能变得及其复杂，并有许多嵌套，这时，将可验证性图中的某些部分组合成组，并有效的"
" ‘隐藏’ 可验证性图中的部分就变得非常有用。"

#: ../../source/topics/workflows/concepts.rst:85
msgid ""
"In addition to the orchestration role that the work function can fullfill, "
"it can also be used as a filter or selection function. Imagine that you want"
" to write a process function that takes a set of input integer nodes and "
"returns the one with the highest value. We cannot employ the "
"``calcfunction`` for this, because it would have to return one of its input "
"nodes, which is explicitly forbidden. However, for the ``workfunction``, "
"returning existing nodes, even one of its inputs, is perfectly fine. An "
"example implementation might look like the following:"
msgstr ""
"工作函数除了拥有组合流程的功能，它还能用作过滤和选择函数。假设你想要执行从三个整数中选出并返回最大值的流程。我们不能使用算例 "
"``calculation`` 来完成这个流程。因为这个流程返回了其中的输入节点，而没有创建新的数据，这在算例型中是禁止的。这时可以使用工作函数 "
"``workfunction`` 返回已经存在的节点，即使这个节点是输入节点也无妨。例子如下："

#: ../../source/topics/workflows/concepts.rst:94
msgid ""
"The work function above will return the input node ``x`` as one of its "
"outputs as it has the highest value. The provenance of the execution of this"
" select work function will look like the following:"
msgstr "上述的工作函数返回输入节点中最大值 ``x`` 作为它的返回值。可验证性图则如下所示："

#: ../../source/topics/workflows/concepts.rst:100
msgid ""
"The provenance generated by the work function that selects one of its input "
"nodes"
msgstr "选择并返回其输入节点的工作函数产生的可验证性图"

#: ../../source/topics/workflows/concepts.rst:103
msgid ""
"It is important to realize once again that in the work function examples "
"given above, all the nodes returned by the work functions are *already "
"stored*. That is to say, they were either created by a calculation function "
"called by the work function or were passed in as one of the inputs. This is "
"no accident, as the work function **can** only return stored nodes. Trying "
"to return a node that was created by the work function itself, will raise an"
" exception. You can find a more detailed explanation for the reasoning "
"behind this design choice in the documentation on the various :ref:`process "
"types<topics:processes:concepts:types>` present in AiiDA and the "
":ref:`implementation of the provenance "
"graph<topics:provenance:implementation>`."
msgstr ""

#: ../../source/topics/workflows/concepts.rst:113
#: ../../source/topics/workflows/usage.rst:129
msgid "Work chains"
msgstr "工作链"

#: ../../source/topics/workflows/concepts.rst:116
msgid "Why?"
msgstr "为什么？"

#: ../../source/topics/workflows/concepts.rst:118
msgid ""
"Now that we have demonstrated how easily ``workfunctions`` can be used to "
"write your workflow that automatically keeps the provenance, it is time to "
"confess that work functions are not perfect and have their shortcomings. In "
"the simple example of adding and multiplying numbers, the time to execute "
"the functions is very short, but imagine that you are performing a more "
"costly calculation, e.g. you want to run an actual ``CalcJob`` that will be "
"submitted to the scheduler and may run for a long time. If anywhere during "
"the chain, the workflow is interrupted, for whatever reason, all progress is"
" lost. There are no 'checkpoints', so to speak, by simply chaining work "
"functions together."
msgstr ""
"现在，我们展示了如何简单使用 ``workfunctions`` "
"来编写能够自动保留可验证性的工作流。不得不承认工作函数并不完美，且有其缺点。在求和后乘积这个简单的例子中，函数的运行时间非常短，但若有一个非常耗费资源和时间的计算，比如当你要运行一个真实的"
" ``CalcJob`` "
"，它会向作业调度工具提交任务并运行很长时间。在整个过程中的任何阶段因为任何原因工作流中断，则所有的流程都会丢失。单纯的将工作函数连接在一起，则整个过程中没有"
" ‘检查点’。"

#: ../../source/topics/workflows/concepts.rst:123
msgid ""
"But fret not! To tackle this problem, AiiDA defines the concept of the work "
"chain. As the name suggests, this construct is a way to chain multiple "
"logical steps of a workflow together in a way that allows to save the "
"progress between those steps as soon as they are successfully completed. The"
" work chain is therefore the preferred solution for parts of the workflow "
"that involve more expensive and complex calculations. To define a work "
"chain, AiiDA provides the "
":py:class:`~aiida.engine.processes.workchains.workchain.WorkChain` class."
msgstr ""
"但不要担心！为了解决这一问题，AiiDA定义了工作链的概念。正如其名所述，该结构能够将工作流中的多个逻辑步骤以某种方式连接起来以保证在每个步骤成功完成后保存流程。因此，工作链是构建时间复杂计算任务的最好选择。为定义工作链，AiiDA提供了"
" :py:class:`~aiida.engine.processes.workchains.workchain.WorkChain`  类。"

#: ../../source/topics/workflows/concepts.rst:132
msgid ""
"If we were to reimplement our work function solution of the simple example "
"problem of the previous section, but this time using a work chain, it would "
"look something like the following:"
msgstr "若我们用工作链来重新实现前面章节中通过工作函数构建的简单例子，我们将会由以下代码："

#: ../../source/topics/workflows/concepts.rst:137
msgid ""
"Don't be intimidated by all the code in this snippet. The point of this "
"example is not to explain the exact syntax, which will be done in greater "
"detail in the :ref:`advanced workflows<topics:workflows:usage:workchains>` "
"section, but to merely introduce the concept of the work chain. The core "
"attributes of a work chain are defined by its :ref:`process "
"specification<topics:processes:usage:spec>` which is setup in the "
":py:meth:`~aiida.engine.processes.process.Process.define` method. The only "
"thing you need to notice here, is that it defines the *inputs* that the work"
" chain takes, its logical *outline* and the *outputs* that it will produce. "
"The steps of the outline are implemented as class methods of the work chain."
" The ``add`` step will add the first two integers by calling the ``add`` "
"calculation function, and store the sum temporarily in the "
":ref:`context<topics:workflows:usage:workchains:context>`. The next step in "
"the outline, ``multiply``, will take the sum stored in the context that was "
"computed in the first outline step and call the ``multiply`` calculation "
"function with the third input integer. Finally, the ``result`` step will "
"take the product produced by the previous step and record it as an output of"
" the work chain. The resulting provenance when we run this work chain looks "
"like the following:"
msgstr ""

#: ../../source/topics/workflows/concepts.rst:150
msgid ""
"The provenance generated by the work chain example calling calculation "
"functions to perform the addition and multiplication."
msgstr "调用算例函数执行加法和乘法的工作链产生的可验证性图。"

#: ../../source/topics/workflows/concepts.rst:152
msgid ""
"As you can see, the produced provenance graph is identical to that of "
":numref:`fig_work_functions_provenance_add_multiply_full` that was produced "
"by the work function solution, except that the workflow node is a work chain"
" instead of a work function node. Full data provenance is kept as the "
"calculation of the sum and the product through the work chain are "
"represented explicitly by the calculation nodes of the ``add`` and "
"``multiply`` calculation functions that are called."
msgstr ""
"正如你看到的，这里产生的可验证性图和用工作函数产生的图 "
":numref:`fig_work_functions_provenance_add_multiply_full` "
"是完全相同的，除了工作流节点上是工作链而不是工作函数。所有的数据可验证性都被工作链以加法算例和乘法算例的算例节点保留，算例节点是调用的 ``add`` "
"和 ``multiply`` 算例函数。"

#: ../../source/topics/workflows/concepts.rst:157
msgid ""
"The usage of calculation functions for the computation of the sum and the "
"product is not an accident, but a concious design choice. Since work chains "
"are workflow-like processes and as such cannot *create* data, performing the"
" calculations directly in the work chain outline steps itself, would result "
"in a loss in the data provenance."
msgstr ""
"使用算例函数来计算加法和乘法并非意外而是有意为之。因为工作链是一个 “工作流型” 例程，它不能够 “创建” "
"数据，如果只是在工作链的步骤中单纯调用python函数则会造成数据可验证性的丢失。"

#: ../../source/topics/workflows/concepts.rst:160
msgid ""
"To illustrate what it means for worklow processes not being able to *create*"
" new data and how doing so causes a loss of data provenance, let's change "
"the previous implementation to perform the sum and product in the work chain"
" outline steps itself, instead of calling the calculation functions."
msgstr ""
"为展示有关工作流流程不能够 *创建* "
"数据和为何这样做会造成数据可验证性的丢失，我们将上述工作链中的步骤改为不调用和执行加法和乘法算例，而是直接在工作链中实现这两个步骤。"

#: ../../source/topics/workflows/concepts.rst:165
msgid "The resulting provenance would look like the following:"
msgstr "可验证性的结果将如下所示："

#: ../../source/topics/workflows/concepts.rst:170
msgid ""
"The provenance generated by the work chain example that computes the sum and"
" product directly in its outline steps, instead of delegating it to "
"calculation functions"
msgstr "工作链生成的可验证性图，该工作链直接在内部实现并执行了流程提纲(outline) 中的加法和乘法步骤，而不是将他们作为算例函数来调用。"

#: ../../source/topics/workflows/concepts.rst:172
msgid ""
"Note how, in contrast with the provenance of the previous correct solution "
"from :numref:`fig_work_chains_provenance_add_multiply_workchain_full`, there"
" are no explicit calculation nodes representing the computation of the sum "
"and the product. Instead, all that computation is abstracted and represented"
" by the single workflow node that represents the execution of the work "
"chain. The logic inside of those outline steps is then 'hidden' or "
"'encapsulated' in the provenance graph by a single workflow node. "
"Additionally, the output node representing the final product, only has a "
"``return`` link, even though it was *created* by the work chain. This is "
"because :ref:`workflow processes do not have the capacity to create new "
"nodes<topics:workflows:usage:workfunctions:returning_data>`, and therefore "
"in this example, the data provenance is lost."
msgstr ""

#: ../../source/topics/workflows/concepts.rst:178
msgid ""
"An important thing to remember is that *any computation* that happens in the"
" body of outline steps of a work chain, will not be explicitly represented, "
"but will be encapsulated by a single node in the graph that represents that "
"work chain execution. Whether that loss of data provenance is relevant "
"depends on the use case and is left to the developer of the workflow to "
"determine. These two examples demonstrate that AiiDA does not force any "
"particular method, but allows the user to choose exactly what level of "
"granularity they would like to maintain in the provenance. However, the rule"
" of thumb is that if you want to reduce the loss, or 'hiding' of provenance "
"to a minimum, one should keep real computation within the body of work "
"functions and work chains to a minimum and delegate that to calculations. "
"For any real computational work that is relevant to the data provenance, it "
"is better to implement it in explicit calculation processes, usually a "
"separate calculation function."
msgstr ""
"需要记住，工作链中存在于流程提纲outline中的*任何算例* "
"，都不会在可验证性图中展示，而是缩略成一个单一节点。丢失的数据可验证性是否相关则取决于使用场景和工作流的开发者。这两个例子阐释了AiiDA并不强制限制保留这些信息，而是允许用户选择在可验证性图中保留特定的可验证性。但是，宗旨是，若你希望尽量减少信息损失，并最少的隐藏可验证细节，则需要将运算步骤作为算例来指点再放置在工作函数或工作链中。对于真实的与数据可验证性相关的计算工作，通过算例例程来实现运算通常更为合理。"

#: ../../source/topics/workflows/concepts.rst:185
msgid "Advantages"
msgstr "进阶"

#: ../../source/topics/workflows/concepts.rst:186
msgid ""
"The work chain solution to the add-multiply problem requires significantly "
"more code, compared to the work function solution presented in the beginning"
" of this section. Why should one then bother using the work chain? The "
"advantages for this trivial example may be difficult to see, but imagine the"
" logic of the workflow becomes more complicated and the calculations become "
"more intensive. The process specification of the work chain provides a "
"central way of defining the inputs and outputs, making it easy to see at a "
"glance how the work chain operates. In addition, the ``outline`` can give a "
"succinct summary of the logical steps that the work chain will perform, all "
"of which a work function does not have. The outline in this example was "
"trivially simple, but the :ref:`advanced work chain development "
"section<topics:workflows:usage:workchains>` will show how complex logic can "
"be implemented directly in the process specification. The process "
"specification also makes it easy to 'wrap' existing work chains into more "
"complex work chains through the :ref:`expose "
"functionality<topics:workflows:usage:workchains:expose_inputs_outputs>`."
msgstr ""

#: ../../source/topics/workflows/concepts.rst:194
msgid ""
"Finally, as mentioned before, the work chain provides the possibility of "
"checkpoints, i.e. to save progress at certain points from which the "
"computation can be continued after it had been interrupted. The state of the"
" work chain is saved after each outline step. If expensive calculation jobs "
"are performed in an individual outline step, they will be saved as soon as "
"they finish. This is impossible for work functions, and if it were to be "
"interrupted before *all* the computations had been completed, all "
"intermediate progress would be lost. The rule of thumb therefore is, as soon"
" as the worfklow becomes only slightly complex or computationally intensive,"
" preference should be given to :ref:`work "
"chains<topics:workflows:concepts:workchains>` and :ref:`calculation "
"jobs<topics:calculations:concepts:calcjobs>`."
msgstr ""

#: ../../source/topics/workflows/concepts.rst:200
msgid ""
"This was a very quick overview of the intended use of work chains and how "
"they work, but of course they have a lot more features. To learn how to "
"write work chains for real life problems, continue reading at the :ref:`work"
" chain development<topics:workflows:usage:workchains>` section, but before "
"you do, read the following part on when to use a work function and when it "
"is better to use a work chain."
msgstr ""

#: ../../source/topics/workflows/concepts.rst:205
msgid "When to use which"
msgstr "When to use which"

#: ../../source/topics/workflows/concepts.rst:206
msgid ""
"Now that we know how the two workflow components, work functions and work "
"chains, work in AiiDA, you might wonder: when should I use which one? For "
"simple operations that do not take long, the simplicity of the work function"
" may be all you need, so by all means use it. However, a good rule of thumb "
"is that as soon as the code is expected to take longer, for example when you"
" want to launch a :ref:`calculation "
"job<topics:calculations:concepts:calcjobs>` or another complex workflow, it "
"is always best to go for the work chain. The automatic checkpointing, which "
"guarantees that work between steps is saved, becomes very important. But the"
" work chain offers a lot more features than just checkpointing that may make"
" it more preferable over the work function, which you can read about in the "
"advanced :ref:`work chain development <topics:workflows:usage:workchains>` "
"section."
msgstr ""

#: ../../source/topics/workflows/index.rst:5
msgid "Workflows"
msgstr "工作流"

#: ../../source/topics/workflows/index.rst:7
msgid ""
"This topic section provides detailed information on the concept of workflows"
" in AiiDA and an extensive guide on how to work with them. An introductory "
"guide to working with workflows can be found in :ref:`\"How to run multi-"
"step workflows\"<how-to:run-workflows>`."
msgstr ""

#: ../../source/topics/workflows/usage.rst:7
msgid ""
"This chapter assumes knowledge of the :ref:`basic "
"concept<topics:workflows:concepts>` and difference between work functions "
"and work chains is known and when one should use on or the other."
msgstr ""

#: ../../source/topics/workflows/usage.rst:12
msgid ":ref:`work function<topics:workflows:usage:workfunctions>`"
msgstr ""

#: ../../source/topics/workflows/usage.rst:13
msgid ":ref:`work chain<topics:workflows:usage:workchains>`"
msgstr ""

#: ../../source/topics/workflows/usage.rst:15
msgid ""
"This section will provide detailed information and best practices on how to "
"implement these two workflow types."
msgstr ""

#: ../../source/topics/workflows/usage.rst:23
msgid ""
"The concept of work functions and the basic rules of implementation are "
"documented in detail elsewhere:"
msgstr ""

#: ../../source/topics/workflows/usage.rst:25
msgid ""
":ref:`concept of work functions<topics:workflows:concepts:workfunctions>`"
msgstr ""

#: ../../source/topics/workflows/usage.rst:26
msgid ":ref:`implementation of process functions<topics:processes:functions>`"
msgstr ""

#: ../../source/topics/workflows/usage.rst:28
msgid ""
"Since work functions are a sub type of process functions, just like "
"calculation functions, their implementation rules are as good as identical. "
"However, their intended aim and heuristics are very different. Where "
":ref:`calculation functions<topics:calculations:usage:calcfunctions>` are "
"'calculation'-like processes that *create* new data, work functions behave "
"like 'workflow'-like processes and can only *return* data. What this entails"
" in terms of intended usage and limitations for work functions is the scope "
"of this section."
msgstr ""

#: ../../source/topics/workflows/usage.rst:36
msgid "Returning data"
msgstr "返回数据"

#: ../../source/topics/workflows/usage.rst:37
msgid ""
"It has been said many times before: work functions, like all 'workflow'-like"
" processes, `return` data, but what does `return` mean exactly? In this "
"context, the term 'return' is not intended to refer to a piece of python "
"code returning a value. Instead it refers to a workflow process recording a "
"data node as one of its outputs, that *it itself did not create*, but which "
"rather was created by some other process, that was called by the workflow. "
"The calculation process was responsable for *creating* the data node and the"
" workflow is merely *returning* it as one of its outputs."
msgstr ""

#: ../../source/topics/workflows/usage.rst:42
msgid ""
"This is then exactly what the workfunction function does. It takes one or "
"more data nodes as inputs, calls other processes to which it passes those "
"inputs and optionally returns some or all of the outputs created by the "
"calculation processes it called. As explained in the :ref:`technical "
"section<topics:processes:functions>`, outputs are recorded as 'returned' "
"nodes simply by returning the nodes from the function. The engine will "
"inspect the return value from the function and attach the output nodes to "
"the node that represents the work function. To verify that the output nodes "
"are in fact not 'created', the engine will check that the nodes are stored. "
"Therefore, it is very important that you **do not store the nodes you create"
" yourself**, or the engine will raise an exception, as shown in the "
"following example:"
msgstr ""

#: ../../source/topics/workflows/usage.rst:52
msgid ""
"Because the returned node is a newly created node and not stored, the engine"
" will raise the following exception:"
msgstr ""

#: ../../source/topics/workflows/usage.rst:60
msgid ""
"Note that you could of course circumvent this check by calling ``store`` "
"yourself on the node, but that misses the point. The problem with using a "
"``workfunction`` to 'create' new data, is that the provenance is lost. To "
"illustrate this problem, let's go back to the simple problem of implementing"
" a workflow to add two integer and multiply the result with a third. The "
":ref:`correct implementation<topics:workflows:concepts:workfunctions>` has a"
" resulting provenance graph that clearly captures the addition and the "
"multiplication as separate calculation nodes, as shown in "
":numref:`fig_work_functions_provenance_add_multiply_full`. To illustrate "
"what would happen if one does does not call calculation functions to perform"
" the computations, but instead directly perform them in the work function "
"itself and return the result, consider the following example:"
msgstr ""

#: ../../source/topics/workflows/usage.rst:69
#: ../../source/topics/workflows/usage.rst:88
msgid ""
"For the documentation skimmers: this is an explicit example on **how not to "
"use** work functions. The :ref:`correct "
"implementation<topics:workflows:concepts:workfunctions>` calls calculation "
"functions to perform the computation"
msgstr ""

#: ../../source/topics/workflows/usage.rst:71
msgid ""
"Note that in this example implementation we explicitly had to call ``store``"
" on the result before returning it to avoid the exception thrown by the "
"engine. The resulting provenance would look like the following:"
msgstr ""

#: ../../source/topics/workflows/usage.rst:77
msgid ""
"The provenance generated by the incorrect work function implementation. Note"
" how the addition and multiplication are not explicitly represented, but are"
" implicitly hidden inside the workflow node. Moreover, the result node does "
"not have a 'create' link, because a work function cannot create new data."
msgstr ""

#: ../../source/topics/workflows/usage.rst:79
msgid ""
"However, looking at the generated provenance shows exactly why we shouldn't."
" This faulty implementation loses provenance as it has no explicit "
"representations of the addition and the multiplication and the `result` node"
" does not have a `create` link, which means that if only the data provenance"
" is followed, it is as if it appears out of thin air! Compare this to the "
"provenance graph of "
":numref:`fig_work_functions_provenance_add_multiply_full`, which was "
"generated by a solution that correctly uses calculation functions to perform"
" the computations. In this trivial example, one may think that this loss of "
"information is not so important, because it is implicitly captured by the "
"workflow node. But a halfway solution may make the problem more apparent, as"
" demonstrated by the following snippet where the addition is properly done "
"by calling a calculation function, but the final product is still performed "
"by the work function itself:"
msgstr ""

#: ../../source/topics/workflows/usage.rst:90
msgid ""
"This time around the addition is correctly performed by a calculation "
"function as it should, however, its result is multiplied by the work "
"function itself and returned. Note that once again ``store`` had to be "
"called explicitly on ``product`` to avoid the engine throwing a "
"``ValueError``, which is only for the purpose of this example **and should "
"not be done in practice**. The resulting provenance would look like the "
"following:"
msgstr ""

#: ../../source/topics/workflows/usage.rst:97
msgid ""
"The provenance generated by the incorrect work function implementation that "
"uses only a calculation function for the addition but performs the "
"multiplication itself. The red cross is there to indicate that there is no "
"actual connection between the intermediate sum `D4` and the final result "
"`D5`, even though the latter in reality derives from the former."
msgstr ""

#: ../../source/topics/workflows/usage.rst:100
msgid ""
"The generated provenance shows, that although the addition is explicitly "
"represented because the work function called the calculation function, there"
" is no connection between the sum and the final result. That is to say, "
"there is no direct link between the sum `D4` and the final result `D5`, as "
"indicated by the red cross, even though we know that the final answer was "
"based on the intermediate sum. This is a direct cause of the work function "
"'creating' new data and illustrates how, in doing so, the provenance of data"
" creation is lost."
msgstr ""

#: ../../source/topics/workflows/usage.rst:110
msgid ""
"To terminate the execution of a work function and mark it as failed, one "
"simply has to return an :ref:`exit code<topics:processes:usage:exit_codes>`."
" The :py:class:`~aiida.engine.processes.exit_code.ExitCode` class is "
"constructed with an integer, to denote the desired exit status and an "
"optional message When such as exit code is returned, the engine will mark "
"the node of the work function as ``Finished`` and set the exit status and "
"message to the value of the exit code. Consider the following example:"
msgstr ""

#: ../../source/topics/workflows/usage.rst:122
msgid ""
"The execution of the work function will be immediately terminated as soon as"
" the exit code is returned, and the exit status and message will be set to "
"``418`` and ``I am a teapot``, respectively. Since no output nodes are "
"returned, the ``WorkFunctionNode`` node will have no outputs and the value "
"returned from the function call will be an empty dictionary."
msgstr ""

#: ../../source/topics/workflows/usage.rst:131
msgid ""
"The :ref:`basic concept of the work "
"chain<topics:workflows:concepts:workchains>` has been explained elsewhere. "
"This section will provide details on how a work chain can and should be "
"implemented. A work chain is implemented by the "
":py:class:`~aiida.engine.processes.workchains.workchain.WorkChain` class. "
"Since it is a sub class of the "
":py:class:`~aiida.engine.processes.process.Process` class, it shares all its"
" properties. It will be very valuable to have read the section on working "
"with :ref:`generic processes<topics:processes:usage>` before continuing, "
"because all the concepts explained there will apply also to work chains."
msgstr ""

#: ../../source/topics/workflows/usage.rst:137
msgid ""
"Let's continue with the example presented in the section on the "
":ref:`concept of workchains<topics:workflows:concepts:workchains>`, where we"
" sum two integers and multiply the result with a third. We provided a very "
"simple implementation in a code snippet, whose generated provenance graph, "
"when executed, is shown in "
":numref:`fig_work_chains_provenance_add_multiply_workchain_full`. For "
"convenience we copy the snippet here once more:"
msgstr ""

#: ../../source/topics/workflows/usage.rst:144
msgid ""
"We will now got through the implementation step-by-step and go into more "
"detail on the interface and best practices."
msgstr "我们现在将逐步完成实现，并详细介绍结构和最佳实践。"

#: ../../source/topics/workflows/usage.rst:151
msgid ""
"To implement a new work chain, simply create a new class that sub classes "
":py:class:`~aiida.engine.processes.workchains.workchain.WorkChain`. You can "
"give the new class any valid python class name, but the convention is to "
"have it end in ``WorkChain`` so that it is always immediately clear what it "
"references. After having created a new work chain class, the first and most "
"important method to implement is the "
":py:meth:`~aiida.engine.processes.process.Process.define` method. This is a "
"class method that allows the developer to define the characteristics of the "
"work chain, such as what inputs it takes, what outputs it can generate, what"
" potential exit codes it can return and the logical outline through which it"
" will accomplish all this."
msgstr ""
"要实现一个新的工作链，只需创建一个 "
":py:class:`~aiida.engine.processes.workchains.workchain.WorkChain` "
"的子类。您可以为新类提供任何有效的python类名，但约定是将它以 ``WorkChain`` "
"结尾，以便始终立即清楚它引用的内容。在创建了一个新的工作链类之后，第一个也是最重要的实现方法是 "
":py:meth:`~aiida.engine.processes.process.Process.define` "
"方法。这是一个类方法，允许开发人员定义工作链的特征，例如它需要什么输入，它可以生成什么输出，它可以返回什么样的退出码以及它将完成所有这些的逻辑大纲。"

#: ../../source/topics/workflows/usage.rst:156
msgid ""
"To implement the ``define`` method, you have to start with the following "
"three lines:"
msgstr "要实现 ``define`` 方法，您必须从以下三行开始："

#: ../../source/topics/workflows/usage.rst:164
msgid ""
"where you replace ``AddAndMultiplyWorkChain`` with the actual name of your "
"work chain. The ``@classmethod`` decorator indicates that this method is a "
"class method  [#f1]_ and not an instance method. The second line is the "
"method signature and specified that it will receive the class itself ``cls``"
" and ``spec`` which will be an instance of the "
":py:class:`~aiida.engine.processes.process_spec.ProcessSpec`. This is the "
"object that we will use to define our inputs, outputs and other relevant "
"properties of the work chain. The third and final line is extremely "
"important, as it will call the ``define`` method of the parent class, in "
"this case the "
":py:class:`~aiida.engine.processes.workchains.workchain.WorkChain` class."
msgstr ""
"这里，用工作链的实际名称替换 ``AddAndMultiplyWorkChain`` 。  ``classmethod`` 装饰器表示此方法是类方法 "
"[＃f1]_ 而不是实例方法。第二行是方法签名，并指定它将接收类本身 ``cls`` 和 ``spec`` ，它们将是 "
":py:class:`~aiida.engine.processes.process_spec.ProcessSpec` "
"的一个实例。这是我们将用于定义工作链的输入，输出和其他相关属性的对象。第三行和最后一行非常重要，因为它将调用父类的 ``define`` "
"方法，在本例中父类为 "
":py:class:`~aiiida.engine.processes.workchains.workchain.WorkChain` 类。"

#: ../../source/topics/workflows/usage.rst:172
msgid ""
"If you forget to call ``super`` in the ``define`` method, your work chain "
"will fail miserably!"
msgstr "如果你忘记在 ``define`` 方法中调用 ``super`` ，你的工作链就会失败！"

#: ../../source/topics/workflows/usage.rst:178
msgid "Inputs and outputs"
msgstr "输入和输出"

#: ../../source/topics/workflows/usage.rst:179
msgid ""
"With those formalities out of the way, you can start defining the "
"interesting properties of the work chain through the ``spec``. In the "
"example you can see how the method :py:meth:`~plumpy.ProcessSpec.input` is "
"used to define multiple input ports, which document exactly which inputs the"
" work chain expects. Similarly, :py:meth:`~plumpy.ProcessSpec.output` is "
"called to instruct that the work chain will produce an output with the label"
" ``result``. These two port creation methods support a lot more "
"functionality, such as adding help string, validation and more, all of which"
" is documented in detail in the section on :ref:`ports and port "
"namespace<topics:processes:usage:ports_portnamespaces>`."
msgstr ""

#: ../../source/topics/workflows/usage.rst:188
msgid "Outline"
msgstr "工作链大纲"

#: ../../source/topics/workflows/usage.rst:189
msgid ""
"The outline is what sets the work chain apart from other processes. It is a "
"way of defining the higher-level logic that encodes the workflow that the "
"work chain takes. The outline is defined in the ``define`` method through "
"the :py:meth:`~plumpy.WorkChainSpec.outline`. It takes a sequence of "
"instructions that the work chain will execute, each of which is implemented "
"as a method of the work chain class. In the simple example above, the "
"outline consists of three simple instructions: ``add``, ``multiply``, "
"``results``. Since these are implemented as instance methods, they are "
"prefixed with ``cls.`` to indicate that they are in fact methods of the work"
" chain class. For that same reason, their implementation should take "
"``self`` as its one and only argument, as demonstrated in the example "
"snippet."
msgstr ""

#: ../../source/topics/workflows/usage.rst:197
msgid ""
"The outline in this simple example is not particular interesting as it "
"consists of three simple instructions that will be executed sequentially. "
"However, the outline also supports various logical constructs, such as "
"while-loops, conditionals and return statements. As usual, the best way to "
"illustrate these constructs is by example. The currently available logical "
"constructs for the work chain outline are:"
msgstr ""
"这个简单示例中的大纲并不特别有趣，因为它包含三个将按顺序执行的简单指令。但是，该大纲还支持各种逻辑结构，例如while循环，条件和返回语句。像往常一样，说明这些结构的最佳方法是举例。工作链大纲的当前可用逻辑结构是:"

#: ../../source/topics/workflows/usage.rst:202
msgid "``if``, ``elif``, ``else``"
msgstr "``if``, ``elif``, ``else``"

#: ../../source/topics/workflows/usage.rst:203
msgid "``while``"
msgstr "``while``"

#: ../../source/topics/workflows/usage.rst:204
msgid "``return``"
msgstr "``return``"

#: ../../source/topics/workflows/usage.rst:206
msgid ""
"To distinguish these constructs from the python builtins, they are suffixed "
"with an underscore, like so ``while_``. To use these in your work chain "
"design, you will have to import them:"
msgstr "为了将这些结构区分python内置函数，它们的后缀为下划线，就像 ``while_`` 。要在工作链设计中使用它们，您必须导入它们:"

#: ../../source/topics/workflows/usage.rst:213
msgid ""
"The following example shows how to use these logical constructs to define "
"the outline of a work chain:"
msgstr "以下示例显示如何使用这些逻辑结构来定义工作链的大纲:"

#: ../../source/topics/workflows/usage.rst:233
msgid ""
"This is an implementation (and an extremely contrived one at that) of the "
"well known FizzBuzz [#f2]_ problem. The idea is that the program is supposed"
" to print in sequence the numbers from zero to some limit, except when the "
"number is a multiple of three ``Fizz`` is printed, for a multiple of five "
"``Buzz`` and when it is a multiple of both, the program should print "
"``FizzBuzz``. Note how the syntax looks very much like that of normal python"
" syntax. The methods that are used in the conditionals (between the "
"parentheses of the ``while_`` and ``if_`` constructs) for example should "
"return a boolean; ``True`` when the condition holds and ``False`` otherwise."
" The actual implementation of the outline steps themselves is now trivial:"
msgstr ""
"这是众所周知的FizzBuzz[＃f2]_ 问题的实现（以及极其拙劣的实现）。这个想法是程序应该按顺序打印从零到某个限制的数字，除非数字是三个 "
"``Fizz`` 的倍数打印，五个 ``Buzz`` 的倍数和当它是两者的倍数时，程序应该打印 ``FizzBuzz`` "
"。注意语法看起来非常像普通的python语法。条件中使用的方法（例如 ``while_`` 和 ``if_`` 构造的括号之间）应该返回一个布尔值; "
"条件成立时为 ``True`` ，否则为 ``False`` 。大纲步骤本身的实际实施现在是无足轻重的:"

#: ../../source/topics/workflows/usage.rst:259
msgid ""
"The intention of this example is to show that with a well designed outline, "
"a user only has to look at the outline to have a good idea *what* the work "
"chain does and *how* it does it. One should not have to look at the "
"implementation of the outline steps as all the important information is "
"captured by the outline itself. Since the goal of a work chain should be to "
"execute a very well defined task, it is the goal of the outline to capture "
"the required logic to achieve that goal, in a clear and short yet not overly"
" succint manner. The outline supports various logical flow constructs, such "
"as conditionals and while loops, so where possible this logic should be "
"expressed in the outline and not in the body of the outline functions. "
"However, one can also go overboard and put too finely grained logical blocks"
" into the outline, causing it to become bulky and difficult to understand."
msgstr ""
"这个例子的目的是为了表明，通过精心设计大纲，用户只需要查看大纲就可以了解 *工作链的作用以及* "
"它是如何实现的。人们不应该看大纲步骤的具体实现，因为大纲本身捕获了所有重要信息。由于工作链的目标应该是执行一项定义明确的任务，因此大纲的目标是以一种清晰而短暂但不过度苛刻的方式捕获实现该目标所需的逻辑。大纲支持各种逻辑流构造，例如条件和while循环，因此在可能的情况下，此逻辑应在大纲中表示，而不是在大纲函数的主体中表示。然而，人们也可能过度使用，并将太细粒度的逻辑块放入大纲中，导致它变得笨重且难以理解。"

#: ../../source/topics/workflows/usage.rst:265
msgid ""
"A good rule of thumb in designing the outline is the following: before you "
"start designing a work chain, define very clearly the task that it should "
"carry out. Once the goal is clear, draw a schematic block diagram of the "
"necessary steps and logical decisions that connect them, in order to "
"accomplish that goal. Converting the resulting flow diagram in a one-to-one "
"fashion into an outline, often results in very reasonable outline designs."
msgstr ""
"设计大纲的一个好的经验法则如下: "
"在开始设计工作链之前，要非常清楚地定义它应该执行的任务。一旦目标明确，绘制连接它们的必要步骤和逻辑决策的示意性框图，以实现该目标。将得到的流程图以一对一的方式转换为轮廓，通常会产生非常合理的大纲设计。"

#: ../../source/topics/workflows/usage.rst:274
msgid ""
"There is one more property of a work chain that is specified through its "
"process specification, in addition to its inputs, outputs and outline. Any "
"work chain may have one to multiple failure modes, which are modelled by "
":ref:`exit codes<topics:processes:usage:exit_codes>`. A work chain can be "
"stopped at any time, simply by returning an exit code from an outline "
"method. To retrieve an exit code that is defined on the spec, one can use "
"the :py:meth:`~aiida.engine.processes.process.Process.exit_codes` property. "
"This returns an attribute dictionary where the exit code labels map to their"
" corresponding exit code. For example, with the following process spec:"
msgstr ""

#: ../../source/topics/workflows/usage.rst:286
msgid ""
"To see how exit codes can be used to terminate the execution of work chains "
"gracefully, refer to the section "
":ref:`topics:workflows:usage:workchains:aborting_and_exit_codes`."
msgstr ""

#: ../../source/topics/workflows/usage.rst:292
msgid "Launching work chains"
msgstr "启动工作链"

#: ../../source/topics/workflows/usage.rst:294
msgid ""
"The rules for launching work chains are the same as those for any other "
"process, which are detailed in :ref:`this "
"section<topics:processes:usage:launching>`. On top of those basic rules, "
"there is one peculiarity in the case of work chains when submitting to the "
"daemon. When you submit a ``WorkChain`` over the daemon, or any other "
"process for that matter, you need to make sure that the daemon can find the "
"class when it needs to load it. Registering your class through the plugin "
"system with a designated entry point is one way to make sure that the daemon"
" will be able to find it. If, however, you simply have a test class and do "
"not want to go through the effort of creating an entry point for it, you "
"should make sure that the module where you define the class is in the python"
" path. Additionally, make sure that the definition of the work chain **is "
"not in the same file from which you submit it**, or the engine won't be able"
" to load it."
msgstr ""

#: ../../source/topics/workflows/usage.rst:305
msgid "Context"
msgstr "上下文（Context）"

#: ../../source/topics/workflows/usage.rst:306
msgid ""
"In the simplest work chain example presented in the introductory section, we"
" already saw how the context can be used to persist information during the "
"execution of a work chain and pass it between outline steps. The context is "
"essentially a data container, very similar to a dictionary that can hold all"
" sorts of data. The engine will ensure that its contents are saved and "
"persisted in between steps and when the daemon shuts down or restarts. A "
"trivial example of this would be the following:"
msgstr ""

#: ../../source/topics/workflows/usage.rst:319
msgid ""
"In the ``step_one`` outline step we store the string ``'store me in the "
"context'`` in the context, which can be addressed as ``self.ctx``, under the"
" key ``some_variable``. Note that for the key you can use anything that "
"would be a valid key for a normal python dictionary. In the second outline "
"step ``step_two``, we can verify that the string was successfully persisted,"
" by checking the value stored in the context ``self.ctx.some_variable``."
msgstr ""

#: ../../source/topics/workflows/usage.rst:325
msgid "Any data that is stored in the context **has** to be serializable."
msgstr ""

#: ../../source/topics/workflows/usage.rst:327
msgid ""
"This was just a simple example to introduce the concept of the context, "
"however, it really is one of the more important parts of the work chain. The"
" context really becomes crucial when you want to submit a calculation or "
"another work chain from within the work chain. How this is accomplished, we "
"will show in the next section."
msgstr ""

#: ../../source/topics/workflows/usage.rst:334
msgid "Submitting sub processes"
msgstr "提交子例程"

#: ../../source/topics/workflows/usage.rst:335
msgid ""
"One of the main tasks of a ``WorkChain`` will be to launch other processes, "
"such as a ``CalcJob`` or another ``WorkChain``. How to submit processes was "
"explained in :ref:`another section<topics:processes:usage:launch>` and is "
"accomplished by using the :py:func:`~aiida.engine.launch.submit` launch "
"function. However, when submitting a sub process from within a work chain, "
"**this should not be used**. Instead, the "
":py:class:`~aiida.engine.processes.process.Process` class provides its own "
":py:meth:`~aiida.engine.processes.process.Process.submit` method. If you do,"
" you will be greeted with the exception:"
msgstr ""

#: ../../source/topics/workflows/usage.rst:345
msgid ""
"The only change you have to make is to replace the top-level ``submit`` "
"method with the built-in method of the process class:"
msgstr ""

#: ../../source/topics/workflows/usage.rst:353
msgid ""
"The ``self.submit`` method has the exact same interface as the global "
"``aiida.engine.launch.submit`` launcher. When the ``submit`` method is "
"called, the process is created and submitted to the daemon, but at that "
"point it is not yet done. So the value that is returned by the ``submit`` "
"call is not the result of the submitted process, but rather it is the "
"process node that represents the execution of the process in the provenance "
"graph and acts as a *future*. We somehow need to tell the work chain that it"
" should wait for the sub process to be finished, and the future to resolve, "
"before it continues. To do so, however, control has to be returned to the "
"engine, which can then, when the process is completed, call the next step in"
" the outline, where we can analyse the results. The snippet above already "
"revealed that this is accomplished by returning an instance of the "
"``ToContext`` class."
msgstr ""

#: ../../source/topics/workflows/usage.rst:361
msgid "To context"
msgstr "To context （转换为上下文）"

#: ../../source/topics/workflows/usage.rst:362
msgid ""
"In order to store the future of the submitted process, we can store it in "
"the context with a special construct that will tell the engine that it "
"should wait for that process to finish before continuing the work chain. To "
"illustrate how this works, consider the following minimal example:"
msgstr ""
"为了存储提交过程的未来(Future)效果，我们可以将其存储在具有特殊构造的上下文(context)中，该构造将告诉引擎它应该在继续工作链之前等待该例程完成。为了说明其工作原理，请考虑以下小示例："

#: ../../source/topics/workflows/usage.rst:368
msgid ""
"As explained in the previous section, calling ``self.submit`` for a given "
"process that you want to submit, will return a future. To add this future to"
" the context, we can not access the context directly as explained in the "
":ref:`context section<topics:workflows:usage:workchains:context>`, but "
"rather we need to use the class "
":py:class:`~aiida.engine.processes.workchains.context.ToContext`. This class"
" has to be imported from the ``aiida.engine`` module. To add the future to "
"the context, simply construct an instance of ``ToContext``, passing the "
"future as a keyword argument, and returning it from the outline step. The "
"keyword used, ``workchain`` in this example, will be the key used under "
"which to store the node in the context once its execution has terminated. "
"Returning an instance of ``ToContext`` signals to the engine that it has to "
"wait for the futures contained within it to finish execution, store their "
"nodes in the context under the specified keys and then continue to the next "
"step in the outline. In this example, that is the ``inspect_workchain`` "
"method. At this point we are sure that the process, a work chain in this "
"case, has terminated its execution, although not necessarily successful, and"
" we can continue the logic of the work chain."
msgstr ""

#: ../../source/topics/workflows/usage.rst:379
msgid ""
"Using the ``ToContext`` construct alone is not enough to tell the engine "
"that it should wait for the sub process to finish. There **needs** to be at "
"least another step in the outline to follow the step that added the "
"awaitables. If there is no more step to follow, according to the outline, "
"the engine interprets this as the work chain being done and so it will not "
"wait for the sub process to finish. Think about it like this: if there is "
"not even a single step to follow, there is also nothing the work chain could"
" do with the results of the sub process, so there is no point in waiting."
msgstr ""
"仅使用 ``ToContext`` 构造并不足以告诉引擎它应该等待子进程完成。在大纲中，**需要** "
"至少有另一个步骤，以添加可等待的步骤。如果没有更多的步骤，根据大纲，引擎将其解释为正在完成的工作链，因此它不会等待子例程完成。这样想: "
"如果没有一个单独的步骤要遵循，那么工作链对子例程的结果也无能为力，所以等待是没有意义的。"

#: ../../source/topics/workflows/usage.rst:384
msgid ""
"Sometimes one wants to launch not just one, but multiple processes at the "
"same time that can run in parallel. With the mechanism described above, this"
" will not be possible since after submitting a single process and returning "
"the ``ToContext`` instance, the work chain has to wait for the process to be"
" finished before it can continue. To solve this problem, there is another "
"way to add futures to the context:"
msgstr ""
"有时候人们不仅想要启动一个，而是同时启动多个并行运行的进程。使用上述机制，这是不可能的，因为在提交单个进程并返回 ``ToContext`` "
"实例之后，工作链必须等待例程完成才能继续。要解决这个问题，还有另一种方法可以将未来结果添加到上下文中："

#: ../../source/topics/workflows/usage.rst:391
msgid ""
"Here we submit three work chains in a for loop in a single outline step, but"
" instead of returning an instance of ``ToContext``, we call the "
":meth:`~aiida.engine.processes.workchains.workchain.WorkChain.to_context` "
"method. This method has exactly the same syntax as the ``ToContext`` class, "
"except it is not necessary to return its value, so we can call it multiple "
"times in one outline step. Under the hood the functionality is also the same"
" as the ``ToContext`` class. At the end of the ``submit_workchains`` outline"
" step, the engine will find the futures that were added by calling "
"``to_context`` and will wait for all of them to be finished. The good thing "
"here is that these three sub work chains can be run in parallel and once all"
" of them are done, the parent work chain will go to the next step, which is "
"``inspect_workchains``. There we can find the nodes of the work chains in "
"the context under the key that was used as the keyword argument in the "
"``to_context`` call in the previous step."
msgstr ""
"在这里，我们在一个大纲步骤中在for循环中提交三个工作链，但是我们不是返回 ``ToContext`` 的实例，而是调用 "
":meth:`~aiiida.engine.processes.workchains.workchain.WorkChain.to_context ` "
"方法。这个方法与 ``ToContext`` "
"类的语法完全相同，只是没有必要返回它的值，所以我们可以在一个大纲步骤中多次调用它。在AiiDA引擎下，其功能也与 ``ToContext`` 类相同。在"
" ``submit_workchains`` 大纲步骤结束时，引擎将通过调用 ``to_context`` "
"找到所添加的未来期望结果，并等待所有这些未来结果完成。这里的好处是这三个子工作链可以并行运行，一旦完成所有这些工作链，父工作链将进入下一步，即 "
"``inspect_workchains`` 。在那里，我们可以在上下文的上下文中找到工作链的节点，该键在上一步的 ``to_context`` "
"调用中用作关键字参数。"

#: ../../source/topics/workflows/usage.rst:398
msgid ""
"Since we do not want the subsequent calls of ``to_context`` to override the "
"previous future, we had to create unique keys to store them under. In this "
"example, we chose to use the index of the for-loop. The name carries no "
"meaning and is just required to guarantee unique key names. This pattern "
"will occur often where you will want to launch multiple work chains or "
"calculations in parallel and will have to come up with unique names. In "
"essence, however, you are really just creating a list and it would be better"
" to be able to create a list in the context and simply append the future to "
"that list as you submit them. How this can be achieved is explained in the "
"next section."
msgstr ""
"由于我们不希望随后调用 ``to_context`` "
"来覆盖以前的未来，我们必须创建唯一的键来存储它们。在这个例子中，我们选择使用for循环的索引。该名称没有任何意义，只需要保证唯一的密钥名称。这种模式通常会出现在您希望并行启动多个工作链或算例的位置，并且必须提供唯一的名称。但实质上，您实际上只是创建一个列表，最好能够在上下文中创建列表，并在提交时将未来结果添加到该列表中。如何实现这一点将在下一节中解释。"

#: ../../source/topics/workflows/usage.rst:406
msgid "Appending"
msgstr "追加"

#: ../../source/topics/workflows/usage.rst:407
msgid ""
"When you want to add a future of a submitted sub process to the context, but"
" append it to a list rather than assign it to a key, you can use the "
":func:`~aiida.engine.processes.workchains.context.append_` function. "
"Consider the example from the previous section, but now we will use the "
"``append_`` function instead:"
msgstr ""
"如果要将已提交的子例程的未来结果添加到上下文中，但将其附加到列表而不是将其分配给键，则可以使用 "
":func:`~aiida.engine.processes.workchains.context.append_ ` "
"函数。继续考虑上一节中的示例，现在我们将使用 ``append_`` 函数："

#: ../../source/topics/workflows/usage.rst:413
msgid ""
"Notice that in the ``submit_workchains`` step we no longer have to generate "
"a unique key based on the index but we simply wrap the future in the "
"``append_`` function and assign it to the generic key ``workchains``. The "
"engine will see the ``append_`` function and instead of assigning the node "
"corresponding to the future to the key ``workchains``, it will append it to "
"the list stored under that key. If the list did not yet exist, it will "
"automatically be created. The ``self.ctx.workchains`` now contains a list "
"with the nodes of the completed work chains, with the same order as they had"
" been inserted, and so in the ``inspect_workchains`` step we can simply "
"iterate over it to access all of them. Note that the use of ``append_`` is "
"not just limited to the ``to_context`` method. You can also use it in "
"exactly the same way with ``ToContext`` to append a process to a list in the"
" context in multiple outline steps."
msgstr ""

#: ../../source/topics/workflows/usage.rst:421
msgid "Nested context keys"
msgstr ""

#: ../../source/topics/workflows/usage.rst:423
msgid ""
"To simplify the organization of the context, the keys may contain dots "
"``.``, transparently creating namespaces in the process. As an example "
"compare the following to the parallel submission example above:"
msgstr ""

#: ../../source/topics/workflows/usage.rst:429
msgid ""
"This allows to create intuitively grouped and easily accessible structures "
"of child calculations or workchains."
msgstr ""

#: ../../source/topics/workflows/usage.rst:434
msgid "Reporting"
msgstr "报告"

#: ../../source/topics/workflows/usage.rst:435
msgid ""
"During the execution of a ``WorkChain``, we may want to keep the user "
"abreast of its progress and what is happening. For this purpose, the "
"``WorkChain`` implements the "
":py:meth:`~aiida.engine.processes.process.Process.report` method, which "
"functions as a logger of sorts. It takes a single argument, a string, that "
"is the message that needs to be reported:"
msgstr ""
"在执行 ``WorkChain`` 时，我们可能希望让用户及时了解其进度和发生的情况。为此，``WorkChain`` 实现了 "
":py:meth:`~aiiida.engine.processes.process.Process.report` "
"方法，该方法用作各种日志。它需要一个参数，一个字符串，即需要报告的消息:"

#: ../../source/topics/workflows/usage.rst:444
msgid ""
"This will send that message to the internal logger of python, which will "
"cause it to be picked up by the default AiiDA logger, but it will also "
"trigger the database log handler, which will store the message in the "
"database and link it to the node of the work chain. This allows the ``verdi "
"process report`` command to retrieve all those messages that were fired "
"using the ``report`` method for a specific process. Note that the report "
"method, in addition to the pk of the work chain, will also automatically "
"record the name of the work chain and the name of the outline step in which "
"the report message was fired. This information will show up in the output of"
" ``verdi process report``, so you never have to explicitly reference the "
"work chain name, outline step name or date and time in the message itself."
msgstr ""
"这会将该消息发送到python的内部日志，这将导致它被默认的AiiDA日志拾取，但它也将触发数据库日志处理程序，该处理程序将消息存储在数据库中并将其链接到节点工作链。这允许"
" ``verdi process report`` 命令检索所有那些使用 ``report`` "
"方法为特定例程触发的消息。请注意，除了工作链的pk之外，report 方法还将自动记录工作链的名称以及触发报告消息的大纲步骤的名称。此信息将显示在 "
"``verdi process report`` 的输出中，因此您无需在消息本身中明确引用工作链名称，大纲步骤名称或日期和时间。"

#: ../../source/topics/workflows/usage.rst:449
msgid ""
"It is important to note that the report system is a form of logging and as "
"such has been designed to be read by humans only. That is to say, the report"
" system is not designed to pass information programmatically by parsing the "
"log messages."
msgstr "值得注意的是，报告系统是一种日志，因此只能被设计为容易阅读的。也就是说，报告系统不是为了通过解析日志消息以编程方式传递信息而设计的。"

#: ../../source/topics/workflows/usage.rst:455
msgid "Aborting and exit codes"
msgstr "终止和退出码"

#: ../../source/topics/workflows/usage.rst:456
msgid ""
"At the end of every outline step, the return value will be inspected by the "
"engine. If a non-zero integer value is detected, the engine will interpret "
"this as an exit code and will stop the execution of the work chain, while "
"setting its process state to ``Finished``. In addition, the integer return "
"value will be set as the ``exit_status`` of the work chain, which combined "
"with the ``Finished`` process state will denote that the worchain is "
"considered to be ``Failed``, as explained in the section on the "
":ref:`process state <topics:processes:concepts:state>`. This is useful "
"because it allows a workflow designer to easily exit from a work chain and "
"use the return value to communicate programmatically the reason for the work"
" chain stopping."
msgstr ""

#: ../../source/topics/workflows/usage.rst:461
msgid ""
"We assume that you have read the :ref:`section on how to define exit codes "
"<topics:workflows:usage:workchains:define_exit_codes>` through the process "
"specification of the work chain. Consider the following example work chain "
"that defines such an exit code:"
msgstr ""

#: ../../source/topics/workflows/usage.rst:468
msgid ""
"Now imagine that in the outline, we launch a calculation and in the next "
"step check whether it finished successfully. In the event that the "
"calculation did not finish successfully, the following snippet shows how you"
" can retrieve the corresponding exit code and abort the ``WorkChain`` by "
"returning it:"
msgstr ""
"现在想象一下，在大纲中，我们启动算例并在下一步检查它是否成功完成。如果计算没有成功完成，下面的代码片段显示了如何检索相应的退出码并通过返回它来中止 "
"``WorkChain`` :"

#: ../../source/topics/workflows/usage.rst:485
msgid ""
"In the ``inspect_calculation`` outline, we retrieve the calculation that was"
" submitted and added to the context in the previous step and check if it "
"finished successfully through the property ``is_finished_ok``. If this "
"returns ``False``, in this example we simply fire a report message and "
"return the exit code corresponding to the label "
"``ERROR_CALCULATION_FAILED``. Note that the specific exit code can be "
"retrieved through the ``WorkChain`` property ``exit_codes``. This will "
"return a collection of exit codes that have been defined for that "
"``WorkChain`` and any specific exit code can then be retrieved by accessing "
"it as an attribute. Returning this exit code, which will be an instance of "
"the :py:class:`~aiida.engine.processes.exit_code.ExitCode` class, will cause"
" the work chain to be aborted and the ``exit_status`` and ``exit_message`` "
"to be set on the node, which were defined in the spec."
msgstr ""

#: ../../source/topics/workflows/usage.rst:493
msgid ""
"The notation ``self.exit_codes.ERROR_CALCULATION_FAILED`` is just syntactic "
"sugar to retrieve the ``ExitCode`` instance that was defined in the spec "
"with that error label. Constructing your own ``ExitCode`` directly and "
"returning that from the outline step will have exactly the same effect in "
"terms of aborting the work chain execution and setting the exit status and "
"message. However, it is strongly advised to define the exit code through the"
" spec and retrieve it through the ``self.exit_codes`` collection, as that "
"makes it easily retrievable through the spec by the caller of the work "
"chain."
msgstr ""

#: ../../source/topics/workflows/usage.rst:497
msgid ""
"The ``message`` attribute of an ``ExitCode`` can also be a string that "
"contains placeholders. This is useful when the exit code's message is "
"generic enough to a host of situations, but one would just like to "
"parameterize the exit message. To concretize the template message of an exit"
" code, simply call the "
":meth:`~aiida.engine.processes.exit_code.ExitCode.format` method and pass "
"the parameters as keyword arguments:"
msgstr ""

#: ../../source/topics/workflows/usage.rst:506
msgid ""
"This concept can also be applied within the scope of a process. In the "
"process spec, we can declare a generic exit code whose exact message should "
"depend on one or multiple parameters:"
msgstr ""

#: ../../source/topics/workflows/usage.rst:513
msgid ""
"Through the ``self.exit_codes`` collection of a ``WorkChain``, this generic "
"can be easily customized as follows:"
msgstr ""

#: ../../source/topics/workflows/usage.rst:520
msgid ""
"This is no different than the example before, because "
"``self.exit_codes.ERROR_INVALID_PARAMETER`` simply returns an instance of "
"``ExitCode``, which we then call ``format`` on with the substitution "
"parameters."
msgstr ""

#: ../../source/topics/workflows/usage.rst:522
msgid ""
"In conclusion, the best part about using exit codes to abort a work chain's "
"execution, is that the exit status can now be used programmatically, by for "
"example a parent work chain. Imagine that a parent work chain submitted this"
" work chain. After it has terminated its execution, the parent work chain "
"will want to know what happened to the child work chain. As already noted in"
" the :ref:`report<topics:workflows:usage:workchains:reporting>` section, the"
" report messages of the work chain should not be used. The exit status, "
"however, is a perfect way. The parent work chain can easily request the exit"
" status of the child work chain through the ``exit_status`` property, and "
"based on its value determine how to proceed."
msgstr ""

#: ../../source/topics/workflows/usage.rst:531
msgid "Modular workflow design"
msgstr "模块化工作流设计"

#: ../../source/topics/workflows/usage.rst:532
msgid ""
"When creating complex workflows, it is a good idea to split them up into "
"smaller, modular parts. At the lowest level, each workflow should perform "
"exactly one task. These workflows can then be wrapped together by a "
"\"parent\" workflow to create a larger logical unit."
msgstr ""
"在创建复杂工作流时，最好将它们分割成更小的模块部分。在最低级别，每个工作流应该只执行一个任务。然后，这些工作流可以由“父”工作流包装在一起，以创建更大的逻辑单元。"

#: ../../source/topics/workflows/usage.rst:536
msgid ""
"In order to make this approach manageable, it needs to be as simple as "
"possible to glue together multiple workflows in a larger parent workflow. "
"One of the tools that AiiDA provides to simplify this is the ability to "
"*expose* the ports of another process class. This can be another "
"``WorkChain`` implementation, a ``CalcJob`` or even a process function (a "
"``calcfunction`` or ``workfunction``)."
msgstr ""

#: ../../source/topics/workflows/usage.rst:543
msgid "Exposing inputs and outputs"
msgstr "暴露输入和输出"

#: ../../source/topics/workflows/usage.rst:544
msgid ""
"Consider the following example work chain, which simply takes a few inputs "
"and returns them again as outputs:"
msgstr "考虑以下示例工作链，它只需要几个输入并将它们作为输出再次返回:"

#: ../../source/topics/workflows/usage.rst:549
msgid ""
"As a first example, we will implement a thin wrapper workflow, which simply "
"forwards its inputs to ``ChildWorkChain``, and forwards the outputs of the "
"child to its outputs:"
msgstr ""
"作为第一个例子，我们将实现一个小型的封装的工作流，它只是将其输入转发到 ``ChildWorkChain`` ，并将后代的输出转发到它的输出："

#: ../../source/topics/workflows/usage.rst:554
msgid ""
"In the ``define`` method of this simple parent work chain, we use the "
":meth:`~plumpy.process_spec.ProcessSpec.expose_inputs` and "
":meth:`~plumpy.process_spec.ProcessSpec.expose_outputs`. This creates the "
"corresponding input and output ports in the parent work chain. Additionally,"
" AiiDA remembers which inputs and outputs were exposed from that particular "
"work chain class. This is used when calling the child in the ``run_child`` "
"method. The :meth:`~aiida.engine.processes.process.Process.exposed_inputs` "
"method returns a dictionary of inputs that the parent received which were "
"exposed from the child, and so it can be used to pass these on to the child."
" Finally, in the ``finalize`` method, we use "
":meth:`~aiida.engine.processes.process.Process.exposed_outputs` to retrieve "
"the outputs of the child which were exposed to the parent. Using "
":meth:`~aiida.engine.processes.process.Process.out_many`, these outputs are "
"added to the outputs of the parent work chain. This work chain can now be "
"run in exactly the same way as the child itself:"
msgstr ""
"在这个简单的父工作链的 ``define`` 方法中，我们使用 "
":meth:`~plumpy.process_spec.ProcessSpec.expose_inputs` 和 "
":meth:`~pumpmpy.process_spec.ProcessSpec.expose_outputs` "
"。这将在父工作链中创建相应的输入和输出端口。此外，AiiDA还记得从该特定工作链类中暴露了哪些输入和输出。在 ``run_child`` "
"方法中调用子进程时使用此方法。 "
":meth:`~aiiida.engine.processes.process.Process.exposed_inputs`方法返回父工作链接收到的从子例程中暴露的输入的字典，因此可以用它将这些输入传递给子例程。最后，在"
" ``finalize`` 方法中，我们使用 "
":meth:`~aiiida.engine.processes.process.Process.exposed_outputs`来检索暴露给父例程的子例程的输出。使用"
" :meth:`~aiiida.engine.processes.process.Process.out_many` "
"，这些输出被添加到父工作链的输出中。现在，此工作链可以与子项本身完全相同的方式运行:"

#: ../../source/topics/workflows/usage.rst:566
msgid ""
"Next, we will see how a more complex parent work chain can be created by "
"using the additional features of the expose functionality. The following "
"work chain launches two children. These children share the input ``a``, but "
"have different ``b`` and ``c``. The output ``e`` will be taken only from the"
" first child, whereas ``d`` and ``f`` are taken from both children. In order"
" to avoid name conflicts, we need to create a *namespace* for each of the "
"two children, where the inputs and outputs which are not shared are stored. "
"Our goal is that the workflow can be called as follows:"
msgstr ""
"接下来，我们将看到如何通过使用暴露功能的其他功能来创建更复杂的父工作链。以下工作链启动了两个子项。这些子项共享输入 ``a`` ，但有不同的 ``b``"
" 和 ``c`` 。输出 ``e`` 将仅从第一个子项中获取，而 ``d`` 和 ``f`` "
"同时从两个子项中获取。为了避免名称冲突，我们需要为两个子节点中的每一个创建一个 *命名空间* "
"，其中存储未共享的输入和输出。我们的目标是可以按如下方式调用工作流程:"

#: ../../source/topics/workflows/usage.rst:576
msgid ""
"This is achieved by the following workflow. In the next section, we will "
"explain each of the steps."
msgstr "这是通过以下工作流程实现的。在下一节中，我们将解释每个步骤。"

#: ../../source/topics/workflows/usage.rst:582
msgid ""
"First of all, we want to expose the ``a`` input and the ``e`` output at the "
"top-level. For this, we again use "
":meth:`~plumpy.process_spec.ProcessSpec.expose_inputs` and "
":meth:`~plumpy.process_spec.ProcessSpec.expose_outputs`, but with the "
"optional keyword ``include``. This specifies a list of keys, and only inputs"
" or outputs which are in that list will be exposed. So by passing "
"``include=['a']`` to :meth:`~plumpy.process_spec.ProcessSpec.expose_inputs`,"
" only the input ``a`` is exposed."
msgstr ""
"首先，我们希望在顶层公开 ``a`` 输入和 ``e`` 输出。为此，我们再次使用 "
":meth:`~plumpy.process_spec.ProcessSpec.expose_inputs` 和 "
":meth:`~plumpy.process_spec.ProcessSpec.expose_outputs` ，但使用可选关键字 "
"``include`` 。这指定了一个键列表，只显示该列表中的输入或输出。因此，通过将 ``include = ['a']`` 传递给 "
":meth:`~plumpy.process_spec.ProcessSpec.expose_inputs` ，只显示输入 ``a`` 。"

#: ../../source/topics/workflows/usage.rst:587
msgid ""
"Additionally, we want to expose the inputs ``b`` and ``c`` (outputs ``d`` "
"and ``f``), but in a namespace specific for each of the two children. For "
"this purpose, we pass the ``namespace`` parameter to the expose functions. "
"However, since we now shouldn't expose ``a`` (``e``) again, we use the "
"``exclude`` keyword, which specifies a list of keys that will not be "
"exposed."
msgstr ""
"另外，我们希望暴露输入 ``b`` 和 ``c`` （输出 ``d`` 和 ``f`` ），但是在特定于两个子项中的每一个的命名空间中。为此，我们将 "
"``namespace`` 参数传递给 expose 函数。但是，由于我们现在不应该再次暴露 ``a`` （ ``e`` ），我们使用 "
"``exclude`` 关键字，它指定了一个不会暴露的键列表。"

#: ../../source/topics/workflows/usage.rst:591
msgid ""
"When calling the children, we again use the "
":meth:`~aiida.engine.processes.process.Process.exposed_inputs` method to "
"forward the exposed inputs. Since the inputs ``b`` and ``c`` are now in a "
"specific namespace, we need to pass this namespace as an additional "
"parameter. By default, "
":meth:`~aiida.engine.processes.process.Process.exposed_inputs` will search "
"through all the parent namespaces of the given namespace to search for "
"input, as shown in the call for ``child_1``. If the same input key exists in"
" multiple namespaces, the input in the lowest namespace takes precedence. "
"It's also possible to disable this behavior, and instead search only in the "
"explicit namespace that was passed. This is done by setting "
"``agglomerate=False``, as shown in the call to ``child_2``. Of course, we "
"then need to explicitly pass the input ``a``."
msgstr ""
"在调用子项时，我们再次使用 :meth:`~aiida.engine.processes.process.Process.exposed_inputs`"
" 方法来转发暴露的输入。由于输入 ``b`` 和 ``c`` 现在位于特定的命名空间中，我们需要将此命名空间作为附加参数传递。默认情况下， "
":meth:`~aiida.engine.processes.process.Process.exposed_inputs` "
"将搜索给定命名空间的所有父命名空间以搜索输入，如调用 ``child_1`` "
"所示。如果多个名称空间中存在相同的输入键，则最低名称空间中的输入优先。也可以禁用此行为，而只搜索传递的显式命名空间。这是通过设置 "
"``agglomerate=False`` 来完成的，如调用 ``child_2`` 所示。当然，我们需要显式传递输入 ``a`` 。"

#: ../../source/topics/workflows/usage.rst:599
msgid ""
"Finally, we use "
":meth:`~aiida.engine.processes.process.Process.exposed_outputs` and "
":meth:`~aiida.engine.processes.process.Process.out_many` to forward the "
"outputs of the children to the outputs of the parent. Again, the "
"``namespace`` and ``agglomerate`` options can be used to select which "
"outputs are returned by the "
":meth:`~aiida.engine.processes.process.Process.exposed_outputs` method."
msgstr ""
"最后，我们使用 :meth:`~aiida.engine.processes.process.Process.exposed_outputs` 和 "
":meth:`~aiida .engine.processes.process.Process.out_many` 将子项们的输出转发给父项输出。同样，"
" ``namespace`` 和 ``agglomerate`` 选项可用于决定 "
":meth:`~aiida.engine.processes.process.Process.exposed_outputs` 方法返回哪些输出。"

#: ../../source/topics/workflows/usage.rst:604
msgid ""
"For further practical examples of creating workflows, see the :ref:`how to "
"write workflows<how-to:write-workflows>` and :ref:`how to write error "
"resistant workflows <how-to:restart-workchain>` sections."
msgstr ""

#: ../../source/topics/workflows/usage.rst:609
msgid "https://docs.python.org/3.5/library/functions.html#classmethod"
msgstr "https://docs.python.org/3.5/library/functions.html#classmethod"

#: ../../source/topics/workflows/usage.rst:610
msgid "https://en.wikipedia.org/wiki/Fizz_buzz"
msgstr "https://en.wikipedia.org/wiki/Fizz_buzz"
