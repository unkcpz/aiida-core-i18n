# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2020, ECOLE POLYTECHNIQUE FEDERALE DE LAUSANNE (Theory and Simulation of Materials (THEOS) and National Centre for Computational Design and Discovery of Novel Materials (NCCR MARVEL)), Switzerland and ROBERT BOSCH LLC, USA. All rights reserved
# This file is distributed under the same license as the AiiDA package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Jusong Yu <jusong.yeu@gmail.com>, 2023
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: AiiDA 2.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-12-23 19:17+0000\n"
"PO-Revision-Date: 2023-12-21 01:39+0000\n"
"Last-Translator: Jusong Yu <jusong.yeu@gmail.com>, 2023\n"
"Language-Team: Chinese (China) (https://app.transifex.com/aiidateam/teams/98967/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../source/topics/calculations/concepts.rst:5
#: ../../source/topics/processes/concepts.rst:5
#: ../../source/topics/provenance/concepts.rst:5
#: ../../source/topics/workflows/concepts.rst:5
msgid "Concepts"
msgstr "概念"

#: ../../source/topics/calculations/concepts.rst:7
#: ../../source/topics/calculations/usage.rst:9
msgid ""
"A calculation is a process (see the :ref:`process "
"section<topics:processes:concepts>` for details) that *creates* new data. "
"Currently, there are two ways of implementing a calculation process:"
msgstr ""
"计算是 *创建* 新数据的过程（详见 :ref:`process "
"section<topics:processes:concepts>`）。目前，有两种实现计算过程的方法："

#: ../../source/topics/calculations/concepts.rst:10
#: ../../source/topics/processes/functions.rst:10
msgid ""
":ref:`calculation function<topics:calculations:concepts:calcfunctions>`"
msgstr ""
" :ref:`calculation function<topics:calculations:concepts:calcfunctions>`"

#: ../../source/topics/calculations/concepts.rst:11
msgid ":ref:`calculation job<topics:calculations:concepts:calcjobs>`"
msgstr " :ref:`calculation job<topics:calculations:concepts:calcjobs>`"

#: ../../source/topics/calculations/concepts.rst:13
msgid ""
"The first one is the simplest of the two and is basically a python function "
"that is magically transformed into a process. This is ideal for calculations"
" that are not very computationally intensive and can be easily implemented "
"in a python function. For more taxing calculations, typically performed by "
"external codes that are optionally run on remote computing clusters, the "
"calculation job is the better alternative."
msgstr ""
"第一种是两种方法中最简单的一种，基本上是将一个 python 函数神奇地转换成一个进程。这非常适合计算密集度不高的计算，而且可以在 python "
"函数中轻松实现。对于计算量较大的计算（通常由可选择在远程计算集群上运行的外部代码执行），计算作业是更好的选择。"

#: ../../source/topics/calculations/concepts.rst:17
msgid ""
"In the following sections, both concepts will be explained but without going"
" too much into detail on how to implement or run them. For a more detailed "
"exposé, please refer to the respective advanced sections on "
":ref:`calculation functions<topics:calculations:usage:calcfunctions>` and "
":ref:`calculation jobs<topics:calculations:usage:calcjobs>`."
msgstr ""
"在下面的章节中，我们将解释这两个概念，但不会过多地介绍如何实现或运行它们。如需更详细的介绍，请参阅 :ref:`calculation "
"functions<topics:calculations:usage:calcfunctions>` 和 :ref:`calculation "
"jobs<topics:calculations:usage:calcjobs>` 的相关高级章节。"

#: ../../source/topics/calculations/concepts.rst:24
#: ../../source/topics/calculations/usage.rst:20
msgid "Calculation functions"
msgstr "计算功能"

#: ../../source/topics/calculations/concepts.rst:26
msgid "Consider the following computational task at hand:"
msgstr "请看下面的计算任务："

#: ../../source/topics/calculations/concepts.rst:29
msgid ""
"Given three integers, add the first two and then multiply the sum by the "
"third."
msgstr "给定三个整数，将前两个相加，然后将和乘以第三个。"

#: ../../source/topics/calculations/concepts.rst:31
msgid ""
"In plain python code, the solution would look something like the following:"
msgstr "在简单的 python 代码中，解决方法如下："

#: ../../source/topics/calculations/concepts.rst:36
msgid ""
"This simple code snippet will achieve the goal of getting the desired "
"result, however, the provenance is lost. There is no connection between the "
"output of the functions and their inputs. The remedy to this problem is the "
":py:func:`~aiida.engine.processes.functions.calcfunction`. The "
"``calcfunction`` in AiiDA is a `function decorator "
"<https://docs.python.org/3/glossary.html#term-decorator>`_ that transforms a"
" regular python function in a calculation process, which automatically "
"stores the provenance of its output in the :ref:`provenance "
"graph<topics:provenance>` when executed. Updating the previous snippet with "
"``calcfunction`` decorators yields:"
msgstr "这个简单的代码片段可以实现获得预期结果的目标，但是，provenance 却丢失了。函数的输出和输入之间没有连接。解决这一问题的方法是使用 :py:func:`~aiida.engine.processes.functions.calcfunction`。AiiDA 中的 ``calcfunction`` 是一个 `function decorator <https://docs.python.org/3/glossary.html#term-decorator>`_，它在计算过程中转换了一个普通的 python 函数，执行时自动将输出的 provenance 保存在 :ref:`provenance graph<topics:provenance>` 中。用 ``calcfunction`` 装饰器更新前面的代码段，结果如下"

#: ../../source/topics/calculations/concepts.rst:45
msgid ""
"The only thing we had to do to decorate the two functions was to add the "
"line ``@calcfunction`` just before the function definition. Adding the "
"decorator tells AiiDA that the provenance for this function should be stored"
" in the provenance graph when it is executed. This means linking up the "
"inputs and the outputs for a calculation node, which represents the function"
" that was executed. The final change that has to be performed to make this "
"possible, is to make the inputs and the outputs storable. In the previous "
"snippet, the inputs are plain python integer types, which cannot be "
"automatically stored in the provenance graph as nodes. To solve this, one "
"only has to wrap them in the :py:class:`~aiida.orm.nodes.data.int.Int` node "
"sub class, which makes them storable in the database:"
msgstr "为了装饰这两个函数，我们唯一要做的就是在函数定义前添加 ``@calcfunction`` 行。添加装饰器告诉 AiiDA，当函数执行时，该函数的 provenance 应该存储在 provenance graph 中。这意味着将计算 node 的输入和输出连接起来，代表执行的函数。要实现这一点，必须进行的最后一项修改是使输入和输出可存储。在前面的代码段中，输入是普通的 python 整数类型，无法自动以 node 的形式存储在 provenance graph 中。要解决这个问题，只需将它们封装在 :py:class:`~aiida.orm.nodes.data.int.Int` node 子类中，这样就可以将它们存储在数据库中："

#: ../../source/topics/calculations/concepts.rst:55
msgid ""
"The only difference with the previous snippet is that all inputs have been "
"wrapped in the :py:class:`~aiida.orm.nodes.data.int.Int` class. The result "
"that is returned by the function, is now also an "
":py:class:`~aiida.orm.nodes.data.int.Int` node that can be stored in the "
"provenance graph, and contains the result of the computation."
msgstr "与前一个代码段的唯一区别是，所有输入都已封装在 :py:class:`~aiida.orm.nodes.data.int.Int` 类中。函数返回的结果现在也是一个 :py:class:`~aiida.orm.nodes.data.int.Int` node，可以存储在 provenance graph 中，并包含计算结果。"

#: ../../source/topics/calculations/concepts.rst:62
#: ../../source/topics/workflows/concepts.rst:45
msgid ""
"If a function argument is a Python base type (i.e. a value of type ``bool``,"
" ``dict``, ``Enum``, ``float``, ``int``, ``list`` or ``str``), it can be "
"passed straight away to the function, without first having to wrap it in the"
" corresponding AiiDA data type. That is to say, you can run the example "
"above also as:"
msgstr "如果函数参数是一个 Python 基本类型 (即类型为 ``bool``, ``dict``, ``Enum``, ``float``, ``int``, ``list`` 或 ``str`` 的值)，它可以直接传递给函数，而不需要先用相应的 AiiDA 数据类型包装它。也就是说，你也可以以下列方式运行上面的示例："

#: ../../source/topics/calculations/concepts.rst:69
#: ../../source/topics/workflows/concepts.rst:52
msgid ""
"and AiiDA will recognize that the arguments are of type ``int`` and "
"automatically wrap them in an ``Int`` node."
msgstr "而 AiiDA 会识别出参数的类型是 ``int`，并自动用 ``Int`` node 包起来。"

#: ../../source/topics/calculations/concepts.rst:73
msgid ""
"Since ``x`` and ``y`` inside the ``add`` and ``multiply`` functions are "
"already :py:class:`~aiida.orm.nodes.data.int.Int` instances the sum will "
"also be one. This is true because all arithmetic operators also work on the "
"base AiiDA classes (``Int``, ``Float``, etc.) as they would on the "
"equivalent python types. It is important to realize though that only "
":py:class:`~aiida.orm.nodes.node.Node` instances, or sub classes thereof can"
" be stored. For more information on how to return results from process "
"functions, refer to the :ref:`advanced "
"section<topics:calculations:usage:calcfunctions>`."
msgstr "由于函数 ``add`` 和 ``multiply`` 中的 ``x`` 和 ``y`` 已经是 :py:class:`~aiida.orm.nodes.data.int.Int` 实例，和也将是 1。这是真的，因为所有算术运算符都可以在 AiiDA 基类(``Int``、``Float`` 等)上使用，就像在等价的 python 类型上一样。但 import 需要注意的是，只能存储 :py:class:`~aiida.orm.nodes.node.Node` 实例或其子类。有关如何从进程函数返回结果的详细信息，请参阅 :ref:`advanced section<topics:calculations:usage:calcfunctions>`。"

#: ../../source/topics/calculations/concepts.rst:78
msgid ""
"With these trivial changes, the full provenance of the result produced by "
"running the function is maintained and looks like the following:"
msgstr "通过这些微不足道的改动，运行该函数所产生的完整结果 provenance 得到了保留，如下所示："

#: ../../source/topics/calculations/concepts.rst:83
msgid "The provenance generated by the calcfunction example"
msgstr "计算函数示例生成的 provenance"

#: ../../source/topics/calculations/concepts.rst:85
msgid ""
"The example above already shows how a calcfunction can be run: simply by "
"calling it. The value that is returned is the result returned by the "
"definition of the function. However, sometimes one would also like to have a"
" reference to the calculation node that represents the execution of the "
"function in the provenance graph. The following example shows two additional"
" launch functions that will return a tuple, which in addition to the "
"results, also return the ``pk`` or the node associated with the process"
msgstr "上面的示例已经说明了如何运行 calcfunction：只需调用它即可。返回值就是函数定义返回的结果。不过，有时我们也希望有一个计算 node 的引用，它表示函数在 provenance graph 中的执行情况。下面的示例显示了两个额外的启动函数，它们将返回一个元组，除了结果外，还将返回与流程相关的 ``pk`` 或 node"

#: ../../source/topics/calculations/concepts.rst:93
msgid ""
"This was a very short and limited description of calculation functions. For "
"a more detailed description of launching them, please refer to the section "
"on :ref:`launching processes<topics:processes:usage:launching>`. If you want"
" more details on implementing calculation functions and best practices, "
"refer to the section on :ref:`working with calculation "
"functions<topics:calculations:usage:calcfunctions>`."
msgstr "这只是对计算功能非常简短和有限的描述。如需更详细的启动说明，请参阅 :ref:`launching processes<topics:processes:usage:launching>` 章节。如果您想了解有关实现计算功能和最佳实践的更多详情，请参阅 :ref:`working with calculation functions<topics:calculations:usage:calcfunctions>` 章节。"

#: ../../source/topics/calculations/concepts.rst:101
#: ../../source/topics/calculations/usage.rst:64
msgid "Calculation jobs"
msgstr "计算工作"

#: ../../source/topics/calculations/concepts.rst:103
msgid ""
"In the previous section on :ref:`calculation "
"functions<topics:calculations:concepts:calcfunctions>`, we showed how a "
"simple python function can be transformed into a process, such that when it "
"is launched, its execution is recorded automatically in the provenance "
"graph. However, not all computations are well suited to be implemented as a "
"python function, but rather are implemented as a separate code, external to "
"AiiDA. To interface an external code with the engine of AiiDA, the "
":py:class:`~aiida.engine.processes.calcjobs.calcjob.CalcJob` process class "
"was introduced. A detailed explanation of how to implement it, the interface"
" and best practices, can be found in a :ref:`later "
"section<topics:calculations:usage:calcjobs>`. Here, instead, we will focus "
"on the big picture and explain in broad lines how a calculation job models "
"the execution of an external code and what tasks it performs when launched."
msgstr "在上一节的 :ref:`calculation functions<topics:calculations:concepts:calcfunctions>` 中，我们展示了如何将一个简单的 python 函数转换成一个进程，这样当它启动时，它的执行就会自动记录在 provenance graph 中。然而，并不是所有的计算都适合用 python 函数来实现，而是需要用 AiiDA 外部的独立代码来实现。为了将外部代码与 AiiDA 的 engine 接口，引入了 :py:class:`~aiida.engine.processes.calcjobs.calcjob.CalcJob` 进程类。关于如何实现，接口和最佳实践的详细解释，可以在 :ref:`later section<topics:calculations:usage:calcjobs>` 中找到。在此，我们将从大处着眼，大致解释计算作业如何模拟外部代码的执行，以及启动后会执行哪些任务。"

#: ../../source/topics/calculations/concepts.rst:109
msgid ""
"To illustrate how a calculation job operates, we need an external code. "
"Let's imagine an external code that consists of a bash script that reads an "
"input file containing two integers, sums them and prints the result in the "
"standard output using ``echo``, for example:"
msgstr "为了说明计算作业是如何运行的，我们需要一个外部代码。例如，让我们想象一个由 bash 脚本组成的外部代码，它读取包含两个整数的输入文件，将它们相加，然后使用 ``echo`` 在标准输出中打印结果："

#: ../../source/topics/calculations/concepts.rst:120
msgid ""
"When run, this script reads the contents of a file called ``aiida.in`` and "
"expects that it contains two integers. It will parse these into the "
"variables ``x`` and ``y`` and then print their sum. When you want to run "
"this 'code' through AiiDA, you need to tell *how* AiiDA should run it. The "
":py:class:`~aiida.calculations.arithmetic.add.ArithmeticAddCalculation` is a"
" calculation job implementation that forms an interface to accomplish "
"exactly that for the example bash script. A ``CalcJob`` implementation for a"
" specific code, often referred to as a calculation plugin, essentially "
"instructs the engine how it should be run. This includes how the necessary "
"input files should be created based on the inputs that it receives, how the "
"code executable should be called and what files should be retrieved when the"
" calculation is complete. Note the files should be 'retrieved' because "
"calculation jobs can be run not just on the localhost, but on any "
":ref:`computer that is configured in AiiDA<how-to:run-codes:computer>`, "
"including remote machines accessible over for example SSH."
msgstr "运行时，该脚本会读取名为 ``aiida.in`` 的文件内容，并希望其中包含两个整数。它将把这两个整数解析为变量 ``x`` 和 ``y``，然后打印它们的和。当你想通过 AiiDA 运行这个 'code' 时，你需要告诉 AiiDA 应该如何运行它。:py:class:`~aiida.calculations.arithmetic.add.ArithmeticAddCalculation` 是一个计算作业的实现，它形成了一个接口来完成示例 bash 脚本。一个特定代码的 ``CalcJob`` 实现，通常被称为计算插件，本质上是指示 engine 应该如何运行。这包括如何根据接收到的输入创建必要的输入文件、如何调用代码可执行文件以及计算完成后应检索哪些文件。请注意，文件应该是 ``检索``的，因为计算作业不仅可以在本地主机上运行，还可以在任何 :ref:`computer that is configured in AiiDA<how-to:run-codes:computer>` 上运行，包括通过 SSH 等方式访问的远程机器。"

#: ../../source/topics/calculations/concepts.rst:128
msgid ""
"Since a ``CalcJob`` is a process just like the :ref:`calculation "
"functions<topics:calculations:concepts:calcfunctions>` described before, "
"they can be run in an identical way."
msgstr "由于 ``CalcJob`` 与之前描述的 :ref:`calculation functions<topics:calculations:concepts:calcfunctions>` 一样是一个进程，因此它们可以以相同的方式运行。"

#: ../../source/topics/calculations/concepts.rst:133
msgid ""
"the provenance generated by running the calculation job will look something "
"like this:"
msgstr "运行计算作业后生成的 provenance 将如下所示："

#: ../../source/topics/calculations/concepts.rst:138
msgid "The provenance generated by the calculation job example"
msgstr "计算作业示例生成的 provenance"

#: ../../source/topics/calculations/concepts.rst:140
msgid ""
"The execution of the calculation job is represented in the provenance graph "
"by a process node, i.e. the pink square labeled `C\\ :sub:`1`` in "
":numref:`fig_calculation_jobs_provenance_arithmetic_add`. The integer data "
"nodes ``x`` and ``y`` that were passed as inputs are linked to the "
"calculation job as such, as well as the third input ``code``. This input is "
"required for *all* calculation jobs as it represents the external code that "
"is actually executed. These code nodes are instances of the "
":py:class:`~aiida.orm.nodes.data.code.abstract.AbstractCode` class, which is"
" a sub-class of :py:class:`~aiida.orm.nodes.data.data.Data`. This means that"
" code instances are a sort of data node. Its function is to record the path "
"to the executable and some other code related attributes defined during the "
"code setup."
msgstr "在 provenance graph 中，计算作业的执行由进程 node 表示，即标有 478EEB2C19D086EFBfig_calculation_jobs_provenance_arithmetic_addD2D16472x3D4E3C09y39AE4B56code``` 的粉色方块。所有计算作业都需要这个输入，因为它代表实际执行的外部代码。这些代码 node 是 :py:class:`~aiida.orm.nodes.data.code.abstract.AbstractCode` 类的实例，是 :py:class:`~aiida.orm.nodes.data.data.Data` 的子类。这意味着代码实例是一种数据 node。其功能是记录可执行文件的路径和其他一些在代码设置过程中定义的代码相关属性。"

#: ../../source/topics/calculations/concepts.rst:147
msgid ""
"The calculation job produced two outputs, an integer node, containing the "
"sum of ``x`` and ``y`` and a "
":py:class:`~aiida.orm.nodes.data.folder.FolderData` node, containing the "
"output files that were retrieved. Note that all outputs of calculation jobs "
"(except for the ``retrieved`` node) are technically not created by the "
"calculation job itself, but rather by an implementation of the "
":py:class:`~aiida.parsers.parser.Parser` class. In principle, this step is "
"optional, and so a calculation job is therefore not required to produce any "
"outputs, except for the ``retrieved`` folder data node, which will always be"
" there. How the parser fits into the concept of calculation jobs will be "
"addressed in :ref:`this "
"section<topics:calculations:concepts:calcjobs_parsers>`."
msgstr "计算作业产生了两个输出，一个是包含 ``x`` 和 ``y`` 之和的整数 node，另一个是包含检索到的输出文件的 :py:class:`~aiida.orm.nodes.data.folder.FolderData` node。请注意，计算作业的所有输出(``retrieved`` node 除外)在技术上都不是由计算作业本身创建的，而是由 :py:class:`~aiida.parsers.parser.Parser` 类的实现创建的。原则上，这一步是可选的，因此计算作业不需要产生任何输出，但 ``retrieved`` 文件夹中的数据 node 除外。解析器如何融入计算作业概念将在 :ref:`this section<topics:calculations:concepts:calcjobs_parsers>` 中讨论。"

#: ../../source/topics/calculations/concepts.rst:155
msgid "Transport tasks"
msgstr "运输任务"

#: ../../source/topics/calculations/concepts.rst:157
msgid ""
"To arrive at the provenance graph shown above in "
":numref:`fig_calculation_jobs_provenance_arithmetic_add`, the engine "
"performed quite some tasks. When a calculation job is launched, the engine "
"will take it roughly through the following steps:"
msgstr "为了得到上面 :numref:`fig_calculation_jobs_provenance_arithmetic_add` 中显示的 provenance graph，engine 执行了很多任务。启动计算作业时，engine 将大致执行以下步骤："

#: ../../source/topics/calculations/concepts.rst:160
msgid ""
"**Upload**: the calculation job implementation is used to transform the "
"input nodes into the required input files, which are uploaded to a 'working'"
" directory on the target machine"
msgstr "**上传** ：计算任务执行用于将输入的 nodes 转换为所需的输入文件，并将其上传到目标计算机上的 ``工作``目录中。"

#: ../../source/topics/calculations/concepts.rst:161
msgid ""
"**Submit**: to execute the calculation, a job is submitted to the scheduler "
"of the computer on which the input `code` is configured."
msgstr "**提交** ：为执行计算，向配置输入 `code` 的计算机的调度程序提交作业。"

#: ../../source/topics/calculations/concepts.rst:162
msgid ""
"**Update**: the engine will query the scheduler to check for the status of "
"the calculation job"
msgstr "**更新** ：engine 将查询调度程序以检查计算任务的状态"

#: ../../source/topics/calculations/concepts.rst:163
msgid ""
"**Retrieve**: once the job has finished, the engine will retrieve the output"
" files, specified by the calculation plugin and store them in a node "
"attached as an output node to the calculation"
msgstr "**检索** ：作业完成后，engine 将检索计算插件指定的输出文件，并将其存储在作为计算输出 node 连接的 node 中。"

#: ../../source/topics/calculations/concepts.rst:165
msgid ""
"All of these tasks require the engine to interact with the computer, or "
"machine, that will actually run the external code. Since the "
":py:class:`~aiida.orm.nodes.data.code.abstract.AbstractCode` that is used as"
" an input for the calculation job, which is configured for a specific "
":py:class:`~aiida.orm.computers.Computer`, the engine knows exactly how to "
"execute all these tasks. The ``CalcJob`` implementation itself then is "
"completely independent of the machine the code will be run on. To run the "
"calculation job on a different machine, all you have to do is change the "
"``code`` input to one that is configured for that machine. If the machine is"
" *not* the localhost, the engine will need a way to connect to the remote "
"machine in order to perform each of the four tasks listed above. The "
"mechanism that allows the engine to connect to the remote machine is called "
"a *transport* and therefore the tasks it performs using this transport are "
"called *transport tasks*."
msgstr "所有这些任务都需要 engine 与实际运行外部代码的计算机或机器进行交互。由于用作计算任务输入的 :py:class:`~aiida.orm.nodes.data.code.abstract.AbstractCode` 是为特定的 :py:class:`~aiida.orm.computers.Computer` 配置的，因此 engine 完全知道如何执行所有这些任务。因此，``CalcJob` 的实现本身完全独立于代码运行的机器。要在不同的机器上运行计算任务，只需将 ``code`` 输入改为为该机器配置的输入即可。如果机器**不是本地主机，engine 将需要一种连接到远程机器的方法，以便执行上述四项任务中的每一项。允许 engine 连接到远程机器的机制称为 *传输* ，因此使用该传输执行的任务称为 *传输任务* 。"

#: ../../source/topics/calculations/concepts.rst:176
msgid "Exponential backoff mechanism"
msgstr "指数后退机制"

#: ../../source/topics/calculations/concepts.rst:178
msgid ""
"In the case of calculation jobs being executed on a remote machine, the "
"engine will have to connect to the machine for each of the transport tasks. "
"In connecting to the remote, a whole host of potential problems may occur "
"that would cause the calculation job to fail. For example, the remote "
"machine may be down and as a result unreachable, or the engine itself may "
"lose its internet connection. However, these problems are often temporary. "
"To prevent the calculation job from excepting and it being lost forever, an "
"*exponential backoff mechanism* has been implemented. Whenever the engine "
"performs a transport task but encounters an exception, instead of letting "
"the calculation job fail, it will reschedule the same task to be executed "
"again at a later time. The task will be automatically rescheduled until it "
"finishes successfully, where the interval between tries increases "
"exponentially. If after 5 consecutive tries, the task still fails, instead "
"of rescheduling it, the engine will simply pause the calculation job. The "
"output of ``verdi process list`` will give more information on why the task "
"failed:"
msgstr "在远程计算机上执行计算作业时，engine 必须为每个传输任务连接到计算机。在连接到远程时，可能会出现一系列潜在问题，导致计算作业失败。例如，远程机器可能出现故障而无法连接，或者 engine 本身可能失去互联网连接。不过，这些问题通常都是暂时的。为了防止计算工作中断或永远丢失，engine 采用了 *指数回退机制* 。每当 engine 执行传输任务但遇到异常时，它不会让计算任务失败，而是会重新安排同一任务在稍后时间再次执行。任务会自动重新安排，直到成功完成为止，每次尝试的间隔时间会以指数形式增加。如果连续 5 次尝试后任务仍然失败，engine 不会重新安排任务，而是直接暂停计算任务。``verdi process list`` 的输出将提供更多有关任务失败原因的信息："

#: ../../source/topics/calculations/concepts.rst:197
msgid ""
"When there are calculation jobs that have been paused because the transport "
"tasks have failed multiple times, the user has the time to investigate the "
"problem. If the problem is determined to be temporary and it has been "
"resolved, one can use ``verdi process play`` to resume the paused processes."
" The engine will then automatically reschedule the task that failed last and"
" the calculation job will continue where it left off."
msgstr "当计算作业因传输任务多次失败而暂停时，用户有时间调查问题。如果确定问题是暂时的并且已经解决，则可以使用 ``verdi process play`` 恢复暂停的进程。然后，engine 将自动重新安排最后失败的任务，计算工作将继续进行。"

#: ../../source/topics/calculations/concepts.rst:201
msgid ""
"This exponential backoff mechanism makes the engine very robust with respect"
" to calculation jobs, reducing the loss of computational resources due to "
"temporary problems to an absolute minimum."
msgstr "这种指数后退机制使 engine 在计算作业方面非常稳健，将临时问题造成的计算资源损失降至最低。"

#: ../../source/topics/calculations/concepts.rst:205
msgid ""
"The parameters, such as the delays between retries and the maximum number of"
" retries, are currently not configurable, but they might be in the future."
msgstr "重试延迟和最大重试次数等参数目前无法配置，但将来可能可以配置。"

#: ../../source/topics/calculations/concepts.rst:210
msgid "Parsers"
msgstr "解析器"

#: ../../source/topics/calculations/concepts.rst:211
msgid ""
"The previous section explained how the ``CalcJob`` class functions as an "
"interface between AiiDA's engine and an external piece of code. The "
"calculation job plugin will instruct the engine how the :ref:`transport "
"tasks<topics:calculations:concepts:calcjobs_transport_tasks>` should be "
"accomplished. However, as mentioned before, those tasks stop after the "
"output files have been retrieved, which the engine will attach as a "
":py:class:`~aiida.orm.nodes.data.folder.FolderData` node with the label "
"``'retrieved'`` to the calculation job node. As far as the calculation job "
"goes that is all that is absolutely required. However, often one wants to "
"parse those output files into some specific outputs that should be "
"represented as individual nodes in the provenance graph. This can be "
"accomplished by implementing the :py:class:`~aiida.parsers.parser.Parser` "
"class and specifying it in the inputs of the calculation job. In that case, "
"the engine will call the parser after the output files created by the job "
"have been successfully retrieved. In the parser implementation, the "
"retrieved files can then be parsed and converted into output nodes. For "
"technical details on how to implement a parser for a calculation job and how"
" to specify it in the inputs, please refer to the :ref:`detailed parser "
"section<topics:calculations:usage:calcjobs:parsers>`,"
msgstr "上一节解释了 ``CalcJob`` 类如何作为 AiiDA 的 engine 与外部代码之间的接口。计算任务插件将指示 engine 如何完成 :ref:`transport tasks<topics:calculations:concepts:calcjobs_transport_tasks>` 的计算。但是，如前所述，这些任务在检索到输出文件后就会停止，engine 将以 :py:class:`~aiida.orm.nodes.data.folder.FolderData` node 标签 ``'retrieved'`` 的形式将输出文件附加到计算作业 node。就计算作业而言，这就是绝对需要的。然而，人们往往希望将这些输出文件解析为一些特定的输出，这些输出应在 provenance graph 中表示为单个的 node。这可以通过实现 :py:class:`~aiida.parsers.parser.Parser` 类并在计算任务的输入中指定它来实现。在这种情况下，engine 将在成功检索作业创建的输出文件后调用解析器。在解析器实现过程中，可以对检索到的文件进行解析，并将其转换为输出 node。有关如何为计算作业实施解析器以及如何在输入中指定解析器的技术细节，请参阅 :ref:`detailed parser section<topics:calculations:usage:calcjobs:parsers>`、"

#: ../../source/topics/calculations/index.rst:5
msgid "Calculations"
msgstr "计算"

#: ../../source/topics/calculations/index.rst:7
msgid ""
"This topic section provides detailed information on the concept of "
"calculations in AiiDA and an extensive guide on how to work with them. An "
"introductory guide to working with calculations can be found in :ref:`\"How "
"to run external codes\"<how-to:plugin-codes>`."
msgstr "本主题章节提供 AiiDA 中计算概念的详细信息，以及如何使用计算的详细指南。在 :ref:`\``How to run external codes\``<how-to:plugin-codes>` 中可以找到使用计算的入门指南。"

#: ../../source/topics/calculations/usage.rst:5
#: ../../source/topics/processes/usage.rst:5
#: ../../source/topics/workflows/usage.rst:5
msgid "Usage"
msgstr "使用方法"

#: ../../source/topics/calculations/usage.rst:7
msgid ""
"This chapter assumes knowledge of the :ref:`basic "
"concept<topics:calculations:concepts>` and difference between calculation "
"functions and calculation jobs is known and when one should use on or the "
"other."
msgstr "本章假定读者了解 :ref:`basic concept<topics:calculations:concepts>` 的知识，并知道计算功能和计算作业之间的区别，以及何时应使用其中一个或另一个。"

#: ../../source/topics/calculations/usage.rst:12
msgid ":ref:`calculation function<topics:calculations:usage:calcfunctions>`"
msgstr " :ref:`calculation function<topics:calculations:usage:calcfunctions>`"

#: ../../source/topics/calculations/usage.rst:13
msgid ":ref:`calculation job<topics:calculations:usage:calcjobs>`"
msgstr " :ref:`calculation job<topics:calculations:usage:calcjobs>`"

#: ../../source/topics/calculations/usage.rst:15
msgid ""
"This section will provide detailed information and best practices on how to "
"implement these two calculation types."
msgstr "本节将提供如何实施这两种计算类型的详细信息和最佳实践。"

#: ../../source/topics/calculations/usage.rst:22
msgid ""
"The section on the :ref:`concept of calculation "
"functions<topics:calculations:concepts:calcfunctions>` already addressed "
"their aim: automatic recording of their execution with their inputs and "
"outputs in the provenance graph. The :ref:`section on process "
"functions<topics:processes:functions>` subsequently detailed the rules that "
"apply when implementing them, all of which to calculation functions, which "
"are a sub type, just like work functions. However, there are some "
"differences given that calculation functions are 'calculation'-like "
"processes and work function behave like 'workflow'-like processes. What this"
" entails in terms of intended usage and limitations for calculation "
"functions is the scope of this section."
msgstr "关于 :ref:`concept of calculation functions<topics:calculations:concepts:calcfunctions>` 的章节已经阐述了它们的目的：在 provenance graph 中自动记录它们的执行及其输入和输出。随后，:ref:`section on process functions<topics:processes:functions>` 详细说明了执行这些功能时适用的规则，所有这些规则都适用于计算功能，计算功能与工作功能一样，都是子类型。不过，计算函数是类似 ``计算``的流程，而工作函数则是类似 ``workflow``的流程，两者之间存在一些差异。本节将介绍计算函数的预期用途和限制。"

#: ../../source/topics/calculations/usage.rst:28
msgid "Creating data"
msgstr "创建数据"

#: ../../source/topics/calculations/usage.rst:29
msgid ""
"It has been said many times before: calculation functions, like all "
"'calculation'-like processes, `create` data, but what does `create` mean "
"exactly? In this context, the term 'create' is not intended to refer to the "
"simple creation of a new data node in the graph, in an interactive shell or "
"a script for example. But rather it indicates the creation of a new piece of"
" data from some other data through a computation implemented by a process. "
"This is then exactly what the calculation function does. It takes one or "
"more data nodes as inputs and returns one or more data nodes as outputs, "
"whose content is based on those inputs. As explained in the :ref:`technical "
"section<topics:processes:functions>`, outputs are created simply by "
"returning the nodes from the function. The engine will inspect the return "
"value from the function and attach the output nodes to the calculation node "
"that represents the calculation function. To verify that the output nodes "
"are in fact 'created', the engine will check that the nodes are not stored. "
"Therefore, it is very important that you **do not store the nodes you create"
" yourself**, or the engine will raise an exception, as shown in the "
"following example:"
msgstr "计算函数和所有类似 ``计算``的过程一样，都会 `create` 数据，但 `create` 的确切含义是什么？在这里，``创建``一词并不是指在交互式 shell 或脚本中在图形中创建一个新数据 node。而是指通过进程执行的计算，从其他数据中创建新数据。这正是计算函数的作用。它接收一个或多个数据 node 作为输入，并返回一个或多个数据 node 作为输出，其内容基于这些输入。正如 :ref:`technical section<topics:processes:functions>` 中解释的那样，只需从函数返回 node 即可创建输出。engine 将检查函数的返回值，并将输出 node 连接到表示计算函数的计算 node。为了验证输出 node 是否确实 ``创建``，engine 将检查 node 是否被存储。因此，请务必**不要存储自己创建的 node，否则 engine 将引发异常，如下例所示："

#: ../../source/topics/calculations/usage.rst:42
msgid ""
"Because the returned node is already stored, the engine will raise the "
"following exception:"
msgstr ""

#: ../../source/topics/calculations/usage.rst:50
msgid ""
"The reason for this strictness is that a node that was stored after being "
"created in the function body, is indistinguishable from a node that was "
"already stored and had simply been loaded in the function body and returned,"
" e.g.:"
msgstr ""

#: ../../source/topics/calculations/usage.rst:55
msgid ""
"The loaded node would also have gotten a `create` link from the calculation "
"function, even though it was not really created by it at all. It is exactly "
"to prevent this ambiguity that calculation functions require all returned "
"output nodes to be *unstored*."
msgstr ""

#: ../../source/topics/calculations/usage.rst:58
msgid ""
"Note that work functions have exactly the opposite required and all the "
"outputs that it returns **have to be stored**, because as a 'workflow'-like "
"process, it *cannot* create new data. For more details refer to the "
":ref:`work function section<topics:workflows:usage:workfunctions>`."
msgstr ""

#: ../../source/topics/calculations/usage.rst:66
msgid ""
"To explain how a calculation job can be implemented, we will continue with "
"the example presented in the section on the :ref:`concept of the calculation"
" job<topics:calculations:concepts:calcjobs>`. There we described a code that"
" adds two integers, implemented as a simple bash script, and how the "
":py:class:`~aiida.engine.processes.calcjobs.calcjob.CalcJob` class can be "
"used to run this code through AiiDA. Since it is a sub class of the "
":py:class:`~aiida.engine.processes.process.Process` class, it shares all its"
" properties. It will be very valuable to have read the section on working "
"with :ref:`generic processes<topics:processes:usage>` before continuing, "
"because all the concepts explained there will apply also to calculation "
"jobs."
msgstr ""

#: ../../source/topics/calculations/usage.rst:75
#: ../../source/topics/workflows/usage.rst:150
msgid "Define"
msgstr ""

#: ../../source/topics/calculations/usage.rst:76
msgid ""
"To implement a calculation job, one simply sub classes the "
":py:class:`~aiida.engine.processes.calcjobs.calcjob.CalcJob` process class "
"and implements the "
":py:meth:`~aiida.engine.processes.calcjobs.calcjob.CalcJob.define` method. "
"You can pick any name that is a valid python class name. The most important "
"method of the ``CalcJob`` class, is the ``define`` class method. Here you "
"define, what inputs it takes and what outputs it will generate."
msgstr ""

#: ../../source/topics/calculations/usage.rst:84
msgid ""
"As the snippet above demonstrates, the class method takes two arguments:"
msgstr ""

#: ../../source/topics/calculations/usage.rst:86
msgid ""
"``cls`` this is the reference of the class itself and is mandatory for any "
"class method"
msgstr ""

#: ../../source/topics/calculations/usage.rst:87
msgid "``spec`` which is the 'specification'"
msgstr ""

#: ../../source/topics/calculations/usage.rst:90
msgid ""
"Do not forget to add the line ``super().define(spec)`` as the first line of "
"the ``define`` method, where you replace the class name with the name of "
"your calculation job. This will call the ``define`` method of the parent "
"class, which is necessary for the calculation job to work properly"
msgstr ""

#: ../../source/topics/calculations/usage.rst:93
msgid ""
"As the name suggests, the ``spec`` can be used to specify the properties of "
"the calculation job. For example, it can be used to define inputs that the "
"calculation job takes. In our example, we need to be able to pass two "
"integers as input, so we define those in the spec by calling "
"``spec.input()``. The first argument is the name of the input. This name "
"should be used later to specify the inputs when launching the calculation "
"job and it will also be used as the label for link to connect the data node "
"and the calculation node in the provenance graph. Additionally, as we have "
"done here, you can specify which types are valid for that particular input. "
"Since we expect integers, we specify that the valid type is the database "
"storable :py:class:`~aiida.orm.nodes.data.int.Int` class."
msgstr ""

#: ../../source/topics/calculations/usage.rst:103
msgid ""
"Since we sub class from ``CalcJob`` and call its ``define`` method, it will "
"inherit the ports that it declares as well. If you look at the "
"implementation, you will find that the base class ``CalcJob`` already "
"defines an input ``code`` that takes a ``Code`` instance. This will "
"reference the code that the user wants to run when he launches the "
"``CalcJob``. For this reason, you **do not** again have to declare this "
"input."
msgstr ""

#: ../../source/topics/calculations/usage.rst:108
msgid ""
"Next we should define what outputs we expect the calculation to produce:"
msgstr ""

#: ../../source/topics/calculations/usage.rst:113
msgid ""
"Just as for the inputs, one can specify what node type each output should "
"have. By default a defined output will be 'required', which means that if "
"the calculation job terminates and the output has not been attached, the "
"process will be marked as failed. To indicate that an output is optional, "
"one can use ``required=False`` in the ``spec.output`` call. Note that the "
"process spec, and its :py:meth:`~plumpy.ProcessSpec.input` and "
":py:meth:`~plumpy.ProcessSpec.output` methods provide a lot more "
"functionality. Fore more details, please refer to the section on "
":ref:`process specifications<topics:processes:usage:spec>`."
msgstr ""

#: ../../source/topics/calculations/usage.rst:123
msgid "Prepare"
msgstr ""

#: ../../source/topics/calculations/usage.rst:124
msgid ""
"We have now defined through the process specification, what inputs the "
"calculation job expects and what outputs it will create. The final remaining"
" task is to instruct the engine how the calculation job should actually be "
"run. To understand what the engine would have to do to accomplish this, "
"let's consider what one typically does when manually preparing to run a "
"computing job through a scheduler:"
msgstr ""

#: ../../source/topics/calculations/usage.rst:128
msgid ""
"Prepare a working directory in some scratch space on the machine where the "
"job will run"
msgstr ""

#: ../../source/topics/calculations/usage.rst:129
msgid "Create the raw input files required by the executable"
msgstr ""

#: ../../source/topics/calculations/usage.rst:130
msgid ""
"Create a launch script containing scheduler directives, loading of "
"environment variables and finally calling the executable with certain "
"command line parameters."
msgstr ""

#: ../../source/topics/calculations/usage.rst:132
msgid ""
"So all we need to do now is instruct the engine how to accomplish these "
"things for a specific calculation job. Since these instructions will be "
"calculation dependent, we will implement this with the "
":py:meth:`~aiida.engine.processes.calcjobs.calcjob.CalcJob.prepare_for_submission`"
" method. The implementation of the ``ArithmeticAddCalculation`` that we are "
"considering in the example looks like the following:"
msgstr ""

#: ../../source/topics/calculations/usage.rst:139
msgid ""
"Before we go into the code line-by-line, let's describe the big picture of "
"what is happening here. The goal of this method is to help the engine "
"accomplish the three steps required for preparing the submission a "
"calculation job, as described above. The raw input files that are required "
"can be written to a sandbox folder that is passed in as the ``folder`` "
"argument."
msgstr ""

#: ../../source/topics/calculations/usage.rst:145
msgid ""
"The ``folder`` argument points to a temporary sandbox folder on the local "
"file system that can be used to write the input files to. After the "
"``prepare_for_submission`` method returns, the engine will take those "
"contents and copy them to the working directory where the calculation will "
"be run. On top of that, these files will also be written to the file "
"repository of the node that represents the calculation as an additional "
"measure of provenance. Even though the information written there should be a"
" derivation of the contents of the nodes that were passed as input nodes, "
"since it is a derived form we store this explicitly nonetheless. Sometimes, "
"this behavior is undesirable, for example for efficiency or data privacy "
"reasons, so it can be controlled with various lists such as "
":ref:`local_copy_list "
"<topics:calculations:usage:calcjobs:file_lists_local_copy>` and "
":ref:`provenance_exclude_list "
"<topics:calculations:usage:calcjobs:file_lists_provenance_exclude>`."
msgstr ""

#: ../../source/topics/calculations/usage.rst:151
msgid ""
"All the other required information, such as the directives of which files to"
" copy and what command line options to use are defined through the "
":py:class:`~aiida.common.datastructures.CalcInfo` datastructure, which "
"should be returned from the method as the only value. In principle, this is "
"what one **should do** in the ``prepare_for_submission`` method:"
msgstr ""

#: ../../source/topics/calculations/usage.rst:154
msgid ""
"Writing raw inputs files required for the calculation to run to the "
"``folder`` sandbox folder."
msgstr ""

#: ../../source/topics/calculations/usage.rst:155
msgid ""
"Use a ``CalcInfo`` to instruct the engine which files to copy to the working"
" directory"
msgstr ""

#: ../../source/topics/calculations/usage.rst:156
msgid ""
"Use a ``CalcInfo`` to tell which codes should run, using which command line "
"parameters, such as standard input and output redirection."
msgstr ""

#: ../../source/topics/calculations/usage.rst:160
msgid ""
"The ``prepare_for_submission`` does not have to write the submission script "
"itself. The engine will know how to do this, because the codes that are to "
"be used have been configured on a specific computer, which defines what "
"scheduler is to be used. This gives the engine all the necessary information"
" on how to write the launch script such as what scheduler directives to "
"write."
msgstr ""

#: ../../source/topics/calculations/usage.rst:164
msgid ""
"Now that we know what the ``prepare_for_submission`` is expected to do, "
"let's see how the implementation of the ``ArithmeticAddCalculation`` "
"accomplishes it line-by-line. The input file required for this example "
"calculation will consist of the two integers that are passed as inputs. The "
"``self.inputs`` attribute returns an attribute dictionary with the parsed "
"and validated inputs, according to the process specification defined in the "
"``define`` method. This means that you do not have to validate the inputs "
"yourself. That is to say, if an input is marked as required and of a certain"
" type, by the time we get to the ``prepare_for_submission`` it is guaranteed"
" that the dictionary returned by ``self.inputs`` will contain that input and"
" of the correct type."
msgstr ""

#: ../../source/topics/calculations/usage.rst:170
msgid ""
"From the two inputs ``x`` and ``y`` that will have been passed when the "
"calculation job was launched, we should now generate the input file, that is"
" simply a text file with these two numbers on a single line, separated by a "
"space. We accomplish this by opening a filehandle to the input file in the "
"sandbox folder and write the values of the two ``Int`` nodes to the file."
msgstr ""

#: ../../source/topics/calculations/usage.rst:175
msgid ""
"The format of this input file just so happens to be the format that the "
":ref:`bash script<topics:calculations:concepts:calcjobs>` expects that we "
"are using in this example. The exact number of input files and their content"
" will of course depend on the code for which the calculation job is being "
"written."
msgstr ""

#: ../../source/topics/calculations/usage.rst:178
msgid ""
"With the input file written, we now have to create an instance of "
":py:class:`~aiida.common.datastructures.CalcInfo` that should be returned "
"from the method. This data structure will instruct the engine exactly what "
"needs to be done to execute the code, such as what files should be copied to"
" the remote computer where the code will be executed. In this simple "
"example, we define four simple attributes:"
msgstr ""

#: ../../source/topics/calculations/usage.rst:182
msgid ""
"``codes_info``: a list of :py:class:`~aiida.common.datastructures.CodeInfo` "
"datastructures, that tell which codes to run consecutively during the job"
msgstr ""

#: ../../source/topics/calculations/usage.rst:183
msgid ""
"``local_copy_list``: a list of tuples that instruct what files to copy to "
"the working directory from the local machine"
msgstr ""

#: ../../source/topics/calculations/usage.rst:184
msgid ""
"``remote_copy_list``: a list of tuples that instruct what files to copy to "
"the working directory from the machine on which the job will run"
msgstr ""

#: ../../source/topics/calculations/usage.rst:185
msgid ""
"``retrieve_list``: a list of tuples instructing which files should be "
"retrieved from the working directory and stored in the local repository "
"after the job has finished"
msgstr ""

#: ../../source/topics/calculations/usage.rst:187
msgid ""
"In this example we only need to run a single code, so the ``codes_info`` "
"list has a single ``CodeInfo`` datastructure. This datastructure needs to "
"define which code it needs to run, which is one of the inputs passed to the "
"``CalcJob``, and does so by means of its UUID. Through the ``stdout_name`` "
"attribute, we tell the engine where the output of the executable should be "
"redirected to. In this example this is set to the value of the  "
"``output_filename`` option. What options are available in calculation jobs, "
"what they do and how they can be set will be explained in the :ref:`section "
"on options<topics:calculations:usage:calcjobs:options>`. Finally, the "
"``cmdline_params`` attribute takes a list with command line parameters that "
"will be placed *after* the executable in the launch script. Here we use it "
"to explicitly instruct the executable to read its input from the filename "
"stored in the option ``input_filename``."
msgstr ""

#: ../../source/topics/calculations/usage.rst:197
msgid ""
"Since we instruct the executable should read the input from "
"``self.options.input_filename``, this is also the filename we used when "
"writing that very input file in the sandbox folder."
msgstr ""

#: ../../source/topics/calculations/usage.rst:199
msgid ""
"Finally, we have to define the various \"file lists\" that tell what files "
"to copy from where to where and what files to retrieve. Here we will briefly"
" describe their intended goals. The implementation details will be described"
" in full in the :ref:`file lists "
"section<topics:calculations:usage:calcjobs:file_lists>`."
msgstr ""

#: ../../source/topics/calculations/usage.rst:203
msgid ""
"The local copy list is useful to instruct the engine to copy over files that"
" you might already have stored in your database, such as instances of "
":py:class:`~aiida.orm.nodes.data.singlefile.SinglefileData` nodes, that you "
"can define and pass as inputs of the ``CalcJob``. You could have of course "
"many copied their content to the ``folder`` sandbox folder, which will also "
"have caused them to be written to the working directory. The disadvantage of"
" that method, however, is that all the contents written to the sandbox "
"folder will also be stored in the repository of the ``CalcJobNode`` that "
"will represent the execution of the ``CalcJob`` in the provenance graph. "
"This will cause duplication of the data contained within these data nodes. "
"By not writing them explicitly to the sandbox folder, you avoid this "
"duplication, without losing provenance, because the data node itself will of"
" course be recorded in the provenance graph."
msgstr ""

#: ../../source/topics/calculations/usage.rst:209
msgid ""
"The remote copy list is useful to avoid unnecessary file transfers between "
"the machine where the engine runs and where the calculation jobs are "
"executed. For example, imagine you have already completed a calculation job "
"on a remote cluster and now want to launch a second one, that requires some "
"of the output files of the first run as its inputs. The remote copy list "
"allows you to specify exactly what output files to copy to the remote "
"working directory, without them having to be retrieved to the engine's "
"machine in between."
msgstr ""

#: ../../source/topics/calculations/usage.rst:213
msgid ""
"The retrieve list, finally, allows you to instruct the engine what files "
"should be retrieved from the working directory after the job has terminated."
" These files will be downloaded to the local machine, stored in a "
":py:class:`~aiida.orm.nodes.data.folder.FolderData` data node and attached "
"as an output to the ``CalcJobNode`` with the link label ``retrieved``."
msgstr ""

#: ../../source/topics/calculations/usage.rst:218
msgid ""
"We didn't explicitly define the ``retrieved`` folder data node as an output "
"in the example ``ArithmeticAddCalculation`` implementation shown above. This"
" is because this is already defined by the ``CalcJob`` base class. Just as "
"the ``code`` input, the ``retrieved`` output is common for all calculation "
"job implementations."
msgstr ""

#: ../../source/topics/calculations/usage.rst:226
msgid "File lists"
msgstr ""

#: ../../source/topics/calculations/usage.rst:231
msgid "Local copy list"
msgstr ""

#: ../../source/topics/calculations/usage.rst:232
msgid ""
"The local copy list takes tuples of length three, each of which represents a"
" file or directory to be copied, defined through the following items:"
msgstr ""

#: ../../source/topics/calculations/usage.rst:234
msgid ""
"`node uuid`: the node whose repository contains the file, typically a "
"``SinglefileData`` or ``FolderData`` node"
msgstr ""

#: ../../source/topics/calculations/usage.rst:235
msgid ""
"`source relative path`: the relative path of the file or directory within "
"the node repository"
msgstr ""

#: ../../source/topics/calculations/usage.rst:236
msgid ""
"`target relative path`: the relative path within the working directory to "
"which to copy the file or directory contents"
msgstr ""

#: ../../source/topics/calculations/usage.rst:238
msgid ""
"As an example, consider a ``CalcJob`` implementation that receives a "
"``SinglefileData`` node as input with the name ``pseudopotential``, to copy "
"its contents one can specify:"
msgstr ""

#: ../../source/topics/calculations/usage.rst:244
msgid ""
"The ``SinglefileData`` node only contains a single file by definition, the "
"relative path of which is returned by the ``filename`` attribute. If "
"instead, you need to transfer a specific file from a ``FolderData``, you can"
" specify the explicit key of the file, like so:"
msgstr ""

#: ../../source/topics/calculations/usage.rst:251
msgid ""
"Note that the filenames in the relative source and target path need not be "
"the same. This depends fully on how the files are stored in the node's "
"repository and what files need to be written to the working directory."
msgstr ""

#: ../../source/topics/calculations/usage.rst:254
msgid ""
"To copy the contents of a directory of the source node, simply define it as "
"the `source relative path`. For example, imagine we have a `FolderData` node"
" that is passed as the `folder` input, which has the following repository "
"virtual hierarchy:"
msgstr ""

#: ../../source/topics/calculations/usage.rst:263
msgid ""
"If the entire content needs to be copied over, specify the "
"``local_copy_list`` as follows:"
msgstr ""

#: ../../source/topics/calculations/usage.rst:269
msgid ""
"The ``'.'`` here indicates that the entire contents need to be copied over. "
"Alternatively, one can specify a sub directory, e.g.:"
msgstr ""

#: ../../source/topics/calculations/usage.rst:276
msgid ""
"Finally, the `target relative path` can be used to write the contents of the"
" source repository to a particular sub directory in the working directory. "
"For example, the following statement:"
msgstr ""

#: ../../source/topics/calculations/usage.rst:283
msgid ""
"will result in the following file hierarchy in the working directory of the "
"calculation:"
msgstr ""

#: ../../source/topics/calculations/usage.rst:291
msgid ""
"One might think what the purpose of the list is, when one could just as "
"easily use normal the normal API to write the file to the ``folder`` sandbox"
" folder. It is true, that in this way the file will be copied to the working"
" directory, however, then it will *also* be copied into the repository of "
"the calculation node. Since in this case it is merely a direct one-to-one "
"copy of the file that is already part of one of the input nodes (in an "
"unaltered form), this duplication is unnecessary and adds useless weight to "
"the file repository. Using the ``local_copy_list`` prevents this unnecessary"
" duplication of file content. It can also be used if the content of a "
"particular input node is privacy sensitive and cannot be duplicated in the "
"repository."
msgstr ""

#: ../../source/topics/calculations/usage.rst:300
msgid "Provenance exclude list"
msgstr ""

#: ../../source/topics/calculations/usage.rst:301
msgid ""
"The :ref:`local_copy_list "
"<topics:calculations:usage:calcjobs:file_lists_local_copy>`  allows one to "
"instruct the engine to write files from the input files to the working "
"directory, without them *also* being copied to the file repository of the "
"calculation node. As discussed in the corresponding section, this is useful "
"in order to avoid duplication or in case where the data of the nodes is "
"proprietary or privacy sensitive and cannot be duplicated arbitrarily "
"everywhere in the file repository. However, the limitation of the "
"``local_copy_list`` is that the it can only target single files in its "
"entirety and cannot be used for arbitrary files that are written to the "
"``folder`` sandbox folder. To provide full control over what files from the "
"``folder`` are stored permanently in the calculation node file repository, "
"the ``provenance_exclude_list`` is introduced. This "
":py:class:`~aiida.common.datastructures.CalcInfo` attribute is a list of "
"filepaths, relative to the base path of the ``folder`` sandbox folder, which"
" *are not stored* in the file repository."
msgstr ""

#: ../../source/topics/calculations/usage.rst:307
msgid ""
"Consider the following file structure as written by an implementation of "
"``prepare_for_submission`` to the ``folder`` sandbox:"
msgstr ""

#: ../../source/topics/calculations/usage.rst:317
msgid ""
"Clearly, we do not want the ``personal.dat`` and ``secret.key`` files to end"
" up permanently in the file repository. This can be achieved by defining:"
msgstr ""

#: ../../source/topics/calculations/usage.rst:324
msgid ""
"With this specification, the final contents of the repository of the "
"calculation node will contain:"
msgstr ""

#: ../../source/topics/calculations/usage.rst:335
msgid "Remote copy list"
msgstr ""

#: ../../source/topics/calculations/usage.rst:336
msgid ""
"The remote copy list takes tuples of length three, each of which represents "
"a file to be copied on the remote machine where the calculation will run, "
"defined through the following items:"
msgstr ""

#: ../../source/topics/calculations/usage.rst:338
msgid ""
"`computer uuid`: this is the UUID of the ``Computer`` on which the source "
"file resides. For now the remote copy list can only copy files on the same "
"machine where the job will run."
msgstr ""

#: ../../source/topics/calculations/usage.rst:339
msgid ""
"`source absolute path`: the absolute path of the source file on the remote "
"machine"
msgstr ""

#: ../../source/topics/calculations/usage.rst:340
msgid ""
"`target relative path`: the relative path within the working directory to "
"which to copy the file"
msgstr ""

#: ../../source/topics/calculations/usage.rst:346
msgid ""
"Note that the source path can point to a directory, in which case its "
"contents will be recursively copied in its entirety."
msgstr ""

#: ../../source/topics/calculations/usage.rst:351
msgid "Retrieve list"
msgstr ""

#: ../../source/topics/calculations/usage.rst:352
msgid ""
"The retrieve list is a list of instructions of what files and folders should"
" be retrieved by the engine once a calculation job has terminated. Each "
"instruction should have one of two formats:"
msgstr ""

#: ../../source/topics/calculations/usage.rst:355
msgid ""
"a string representing a relative filepath in the remote working directory"
msgstr ""

#: ../../source/topics/calculations/usage.rst:356
msgid ""
"a tuple of length three that allows to control the name of the retrieved "
"file or folder in the retrieved folder"
msgstr ""

#: ../../source/topics/calculations/usage.rst:358
msgid ""
"The retrieve list can contain any number of instructions and can use both "
"formats at the same time. The first format is obviously the simplest, "
"however, this requires one knows the exact name of the file or folder to be "
"retrieved and in addition any subdirectories will be ignored when it is "
"retrieved. If the exact filename is not known and `glob patterns "
"<https://en.wikipedia.org/wiki/Glob_%28programming%29>`_ should be used, or "
"if the original folder structure should be (partially) kept, one should use "
"the tuple format, which has the following format:"
msgstr ""

#: ../../source/topics/calculations/usage.rst:362
msgid ""
"`source relative path`: the relative path, with respect to the working "
"directory on the remote, of the file or directory to retrieve."
msgstr ""

#: ../../source/topics/calculations/usage.rst:363
msgid ""
"`target relative path`: the relative path of the directory in the retrieved "
"folder in to which the content of the source will be copied. The string "
"``'.'`` indicates the top level in the retrieved folder."
msgstr ""

#: ../../source/topics/calculations/usage.rst:364
msgid ""
"`depth`: the number of levels of nesting in the source path to maintain when"
" copying, starting from the deepest file."
msgstr ""

#: ../../source/topics/calculations/usage.rst:366
msgid ""
"To illustrate the various possibilities, consider the following example file"
" hierarchy in the remote working directory:"
msgstr ""

#: ../../source/topics/calculations/usage.rst:377
msgid ""
"Below, you will find examples for various use cases of files and folders to "
"be retrieved. Each example starts with the format of the ``retrieve_list``, "
"followed by a schematic depiction of the final file hierarchy that would be "
"created in the retrieved folder."
msgstr ""

#: ../../source/topics/calculations/usage.rst:381
msgid "Explicit file or folder"
msgstr ""

#: ../../source/topics/calculations/usage.rst:383
msgid ""
"Retrieving a single toplevel file or folder (with all its contents) where "
"the final folder structure is not important."
msgstr ""

#: ../../source/topics/calculations/usage.rst:402
msgid "Explicit nested file or folder"
msgstr ""

#: ../../source/topics/calculations/usage.rst:404
msgid ""
"Retrieving a single file or folder (with all its contents) that is located "
"in a subdirectory in the remote working directory, where the final folder "
"structure is not important."
msgstr ""

#: ../../source/topics/calculations/usage.rst:421
msgid "Explicit nested file or folder keeping (partial) hierarchy"
msgstr ""

#: ../../source/topics/calculations/usage.rst:423
msgid ""
"The following examples show how the file hierarchy of the retrieved files "
"can be controlled. By changing the ``depth`` parameter of the tuple, one can"
" control what part of the remote folder hierarchy is kept. In the given "
"example, the maximum depth of the remote folder hierarchy is ``3``. The "
"following example shows that by specifying ``3``, the exact folder structure"
" is kept:"
msgstr ""

#: ../../source/topics/calculations/usage.rst:436
msgid ""
"For ``depth=2``, only two levels of nesting are kept (including the file "
"itself) and so the ``path`` folder is discarded."
msgstr ""

#: ../../source/topics/calculations/usage.rst:445
msgid ""
"The same applies for directories. By specifying a directory for the first "
"element, all its contents will be retrieved. With ``depth=1``, only the "
"first level ``sub`` is kept of the folder hierarchy."
msgstr ""

#: ../../source/topics/calculations/usage.rst:459
msgid "Pattern matching"
msgstr ""

#: ../../source/topics/calculations/usage.rst:461
msgid ""
"If the exact file or folder name is not known beforehand, glob patterns can "
"be used. In the following examples, all files that match ``*c.txt`` in the "
"directory ``path/sub`` will be retrieved."
msgstr ""

#: ../../source/topics/calculations/usage.rst:464
msgid "To maintain the folder structure set ``depth`` to ``None``:"
msgstr ""

#: ../../source/topics/calculations/usage.rst:474
msgid ""
"Alternatively, the ``depth`` can be used to specify the number of levels of "
"nesting that should be kept. For example, ``depth=0`` instructs to copy the "
"matched files without any subfolders:"
msgstr ""

#: ../../source/topics/calculations/usage.rst:483
msgid "and ``depth=2`` will keep two levels in the final filepath:"
msgstr ""

#: ../../source/topics/calculations/usage.rst:494
msgid "Specific target directory"
msgstr ""

#: ../../source/topics/calculations/usage.rst:496
msgid ""
"The final folder hierarchy of the retrieved files in the retrieved folder is"
" not only determined by the hierarchy of the remote working directory, but "
"can also be controlled through the second and third elements of the "
"instructions tuples. The final ``depth`` element controls what level of "
"hierarchy of the source is maintained, where the second element specifies "
"the base path in the retrieved folder into which the remote files should be "
"retrieved. For example, to retrieve a nested file, maintaining the remote "
"hierarchy and storing it locally in the ``target`` directory, one can do the"
" following:"
msgstr ""

#: ../../source/topics/calculations/usage.rst:509
msgid "The same applies for folders that are to be retrieved:"
msgstr ""

#: ../../source/topics/calculations/usage.rst:520
msgid ""
"Note that `target` here is not used to rename the retrieved file or folder, "
"but indicates the path of the directory into which the source is copied. The"
" target relative path is also compatible with glob patterns in the source "
"relative paths:"
msgstr ""

#: ../../source/topics/calculations/usage.rst:532
msgid "Retrieve temporary list"
msgstr ""

#: ../../source/topics/calculations/usage.rst:534
msgid ""
"Recall that, as explained in the :ref:`'prepare' "
"section<topics:calculations:usage:calcjobs:prepare>`, all the files that are"
" retrieved by the engine following the 'retrieve list', are stored in the "
"``retrieved`` folder data node. This means that any file you retrieve for a "
"completed calculation job will be stored in your repository. If you are "
"retrieving big files, this can cause your repository to grow significantly. "
"Often, however, you might only need a part of the information contained in "
"these retrieved files. To solve this common issue, there is the concept of "
"the 'retrieve temporary list'. The specification of the retrieve temporary "
"list is identical to that of the normal :ref:`retrieve "
"list<topics:calculations:usage:calcjobs:file_lists_retrieve>`, but it is "
"added to the ``calc_info`` under the ``retrieve_temporary_list`` attribute:"
msgstr ""

#: ../../source/topics/calculations/usage.rst:546
msgid ""
"The only difference is that, unlike the files of the retrieve list which "
"will be permanently stored in the retrieved "
":py:class:`~aiida.orm.nodes.data.folder.FolderData` node, the files of the "
"retrieve temporary list will be stored in a temporary sandbox folder. This "
"folder is then passed under the ``retrieved_temporary_folder`` keyword "
"argument to the ``parse`` method of the "
":ref:`parser<topics:calculations:usage:calcjobs:parsers>`, if one was "
"specified for the calculation job:"
msgstr ""

#: ../../source/topics/calculations/usage.rst:556
msgid ""
"The parser implementation can then parse these files and store the relevant "
"information as output nodes."
msgstr ""

#: ../../source/topics/calculations/usage.rst:560
msgid ""
"The type of ``kwargs['retrieved_temporary_folder']`` is a simple ``str`` "
"that represents the `absolute` filepath to the temporary folder. You can "
"access its contents with the ``os`` standard library module or convert it "
"into a ``pathlib.Path``."
msgstr ""

#: ../../source/topics/calculations/usage.rst:563
msgid ""
"After the parser terminates, the engine will automatically clean up the "
"sandbox folder with the temporarily retrieved files. The concept of the "
"``retrieve_temporary_list`` is essentially that the files will be available "
"during parsing and will be destroyed immediately afterwards."
msgstr ""

#: ../../source/topics/calculations/usage.rst:569
msgid "Stashing on the remote"
msgstr ""

#: ../../source/topics/calculations/usage.rst:573
msgid ""
"The ``stash`` option namespace allows a user to specify certain files and/or"
" folders that are created by the calculation job to be stashed somewhere on "
"the remote where the job is run. This can be useful if these need to be "
"stored for a longer time on a machine where the scratch space is cleaned "
"regularly, but they need to be kept on the remote machine and not retrieved."
" Examples are files that are necessary to restart a calculation but are too "
"big to be retrieved and stored permanently in the local file repository."
msgstr ""

#: ../../source/topics/calculations/usage.rst:577
msgid ""
"The files/folder that need to be stashed are specified through their "
"relative filepaths within the working directory in the ``stash.source_list``"
" option. Using the ``COPY`` mode, the target path defines another location "
"(on the same filesystem as the calculation) to copy the files to, and is set"
" through the ``stash.target_base`` option, for example:"
msgstr ""

#: ../../source/topics/calculations/usage.rst:600
msgid ""
"In the future, other methods for stashing may be implemented, such as "
"placing all files in a (compressed) tarball or even stash files on tape."
msgstr ""

#: ../../source/topics/calculations/usage.rst:604
msgid ""
"If the ``stash`` option namespace is defined for a calculation job, the "
"daemon will perform the stashing operations before the files are retrieved. "
"This means that the stashing happens before the parsing of the output files "
"(which occurs after the retrieving step), such that that the files will be "
"stashed independent of the final exit status that the parser will assign to "
"the calculation job. This may cause files to be stashed for calculations "
"that will later be considered to have failed."
msgstr ""

#: ../../source/topics/calculations/usage.rst:608
msgid ""
"The stashed files and folders are represented by an output node that is "
"attached to the calculation node through the label ``remote_stash``, as a "
"``RemoteStashFolderData`` node. Just like the ``remote_folder`` node, this "
"represents a location or files on a remote machine and so is equivalent to a"
" \"symbolic link\"."
msgstr ""

#: ../../source/topics/calculations/usage.rst:613
msgid ""
"AiiDA does not actually control the files in the remote stash, and so the "
"contents may disappear at some point."
msgstr ""

#: ../../source/topics/calculations/usage.rst:618
msgid "Options"
msgstr ""

#: ../../source/topics/calculations/usage.rst:619
msgid ""
"In addition to the common metadata inputs, such as ``label`` and "
"``description``, that all processes have, the "
":py:class:`~aiida.engine.processes.calcjobs.calcjob.CalcJob` has an "
"additonal input called ``options``. These options allow to subtly change the"
" behavior of the calculation job, for example which parser should be used "
"once it is finished and special scheduler directives. The full list of "
"available options are documented below as part of the ``CalcJob`` interface:"
msgstr ""

#: ../../source/topics/calculations/usage.rst:628
msgid ""
"The ``rerunnable`` option enables the scheduler to re-launch the calculation"
" if it has failed, for example due to node failure or a failure to launch "
"the job. It corresponds to the ``--requeue`` option in SLURM, and the ``-r``"
" option in SGE, LSF, and PBS. The following two conditions must be met in "
"order for this to work well with AiiDA:"
msgstr ""

#: ../../source/topics/calculations/usage.rst:630
msgid "the scheduler assigns the same job-id to the restarted job"
msgstr ""

#: ../../source/topics/calculations/usage.rst:631
msgid ""
"the code produces the same results if it has already partially run before "
"(not every scheduler may produce this situation)"
msgstr ""

#: ../../source/topics/calculations/usage.rst:633
msgid ""
"Because this depends on the scheduler, its configuration, and the code used,"
" we cannot say conclusively when it will work -- do your own testing! It has"
" been tested on a cluster using SLURM, but that does not guarantee other "
"SLURM clusters behave in the same way."
msgstr ""

#: ../../source/topics/calculations/usage.rst:639
msgid "Controlling MPI"
msgstr ""

#: ../../source/topics/calculations/usage.rst:641
msgid ""
"The `Message Passing Interface "
"<https://en.wikipedia.org/wiki/Message_Passing_Interface>`_ (MPI) is a "
"standardized and portable message-passing standard designed to function on "
"parallel computing architectures. AiiDA implements support for running "
"calculation jobs with or without MPI enabled. There are a number of settings"
" that can be used to control when and how MPI is used."
msgstr ""

#: ../../source/topics/calculations/usage.rst:648
msgid "The ``Computer``"
msgstr ""

#: ../../source/topics/calculations/usage.rst:650
msgid ""
"Each calculation job is executed on a compute resource, which is modeled by "
"an instance of the :class:`~aiida.orm.computers.Computer` class. If the "
"computer supports running with MPI, the command to use is stored in the "
"``mpirun_command`` attribute, which is retrieved and set using the "
":meth:`~aiida.orm.computers.Computer.get_mpirun_command` and "
":meth:`~aiida.orm.computers.Computer.get_mpirun_command`, respectively. For "
"example, if the computer has `OpenMPI <https://docs.open-"
"mpi.org/en/v5.0.x/index.html>`_ installed, it can be set to ``mpirun``. If "
"the ``Computer`` does not specify an MPI command, then enabling MPI for a "
"calculation job is ineffective."
msgstr ""

#: ../../source/topics/calculations/usage.rst:658
msgid "The ``Code``"
msgstr ""

#: ../../source/topics/calculations/usage.rst:662
msgid ""
"When creating a code, you can tell AiiDA that it should be run as an MPI "
"program, by setting the ``with_mpi`` attribute to ``True`` or ``False``. "
"From AiiDA 2.3 onward, this is the **recommended** way of controlling MPI "
"behavior. The attribute can be set from the Python API as "
"``AbstractCode(with_mpi=with_mpi)`` or through the ``--with-mpi`` / ``--no-"
"with-mpi`` option of the ``verdi code create`` CLI command. If the code can "
"be run with or without MPI, setting the ``with_mpi`` attribute can be "
"skipped. It will default to ``None``, leaving the question of whether to run"
" with or without MPI up to the ``CalcJob`` plugin or user input."
msgstr ""

#: ../../source/topics/calculations/usage.rst:671
#: ../../source/topics/calculations/usage.rst:733
msgid "The ``CalcJob`` implementation"
msgstr ""

#: ../../source/topics/calculations/usage.rst:673
msgid ""
"The ``CalcJob`` implementation instructs AiiDA how the codes should be run "
"through the :class:`~aiida.common.datastructures.CalcInfo` object, which it "
"returns from the "
":meth:`~aiida.engine.processes.calcjobs.calcjob.CalcJob.prepare_for_submission`"
" method. For each code that the job should run (usually only a single one), "
"a :class:`~aiida.common.datastructures.CodeInfo` object should be added to "
"the list of the ``CalcInfo.codes_info`` attribute. If the plugin developer "
"knows that the executable being wrapped is *always* MPI program (no serial "
"version available) or *never* an MPI program, they can set the ``withmpi`` "
"attribute of the ``CodeInfo`` to ``True`` or ``False``, respectively. Note "
"that this setting is fully optional; if the code could be run either way, it"
" is best not to set it and leave it up to the ``Code`` or the "
"``metadata.options.withmpi`` input."
msgstr ""

#: ../../source/topics/calculations/usage.rst:680
msgid ""
"When implementing a ``CalcJob`` that runs a single code, consider using "
"specifying whether MPI should be enabled or disabled through the "
":ref:`metadata option<topics:calculations:usage:calcjobs:mpi:calcjob-"
"inputs>`. This can be accomplished by changing the default in the process "
"specification:"
msgstr ""

#: ../../source/topics/calculations/usage.rst:692
msgid ""
"The advantage over using the ``CodeInfo.withmpi`` attribute is that the "
"default of the metadata option can be introspected programmatically from the"
" process spec, and so is more visible to the user."
msgstr ""

#: ../../source/topics/calculations/usage.rst:694
msgid ""
"Naturally, this approach is not viable for calculation jobs that run "
"multiple codes that are different in whether they require MPI or not. In "
"this case, one should resort to using the ``CodeInfo.withmpi`` attribute."
msgstr ""

#: ../../source/topics/calculations/usage.rst:700
msgid "The ``CalcJob`` inputs"
msgstr ""

#: ../../source/topics/calculations/usage.rst:702
msgid ""
"Finally, the MPI setting can be controlled on a per-instance basis, using "
"the ``withmpi`` :ref:`metadata "
"option<topics:calculations:usage:calcjobs:options>`. If MPI should be "
"enabled or disabled, explicitly set this option to ``True`` or ``False``, "
"respectively. For example, the following instructs to run all codes in the "
"calculation job with MPI enabled:"
msgstr ""

#: ../../source/topics/calculations/usage.rst:718
msgid ""
"The default for this option is set to ``False`` on the base ``CalcJob`` "
"implementation, but it will be overruled if explicitly defined."
msgstr ""

#: ../../source/topics/calculations/usage.rst:722
msgid ""
"The value set for the ``withmpi`` option will be applied to all codes. If a "
"calculation job runs more than one code, and each requires a different MPI "
"setting, this option should not be used, and instead MPI should be "
"controlled :ref:`through the code input "
"<topics:calculations:usage:calcjobs:mpi:code>`."
msgstr ""

#: ../../source/topics/calculations/usage.rst:728
msgid "Conflict resolution"
msgstr ""

#: ../../source/topics/calculations/usage.rst:730
msgid ""
"As described above, MPI can be enabled or disabled for a calculation job on "
"a number of levels:"
msgstr ""

#: ../../source/topics/calculations/usage.rst:732
msgid "The ``Code`` input"
msgstr ""

#: ../../source/topics/calculations/usage.rst:734
msgid "The ``metadata.options.withmpi`` input"
msgstr ""

#: ../../source/topics/calculations/usage.rst:736
msgid ""
"MPI is enabled or disabled if any of these values is explicitly set to "
"``True`` or ``False``, respectively. If multiple values are specified and "
"they are not equivalent, a ``RuntimeError`` is raised. Depending on the "
"conflict, one has to change the ``Code`` or ``metadata.options.withmpi`` "
"input. If none of the values are explicitly defined, the value specified by "
"the default of ``metadata.options.withmpi`` is taken."
msgstr ""

#: ../../source/topics/calculations/usage.rst:745
msgid "Launch"
msgstr ""

#: ../../source/topics/calculations/usage.rst:747
msgid ""
"Launching a calculation job is no different from launching any other process"
" class, so please refer to the section on :ref:`launching "
"processes<topics:processes:usage:launch>`. The only caveat that we should "
"place is that calculation jobs typically tend to take quite a bit of time. "
"The trivial example we used above of course will run very fast, but a "
"typical calculation job that will be submitted to a scheduler will most "
"likely take longer than just a few seconds. For that reason it is highly "
"advisable to **submit** calculation jobs instead of running them. By "
"submitting them to the daemon, you free up your interpreter straight away "
"and the process will be checkpointed between the various :ref:`transport "
"tasks<topics:calculations:concepts:calcjobs_transport_tasks>` that will have"
" to be performed. The exception is of course when you want to run a "
"calculation job locally for testing or demonstration purposes."
msgstr ""

#: ../../source/topics/calculations/usage.rst:758
msgid "Dry run"
msgstr ""

#: ../../source/topics/calculations/usage.rst:759
msgid ""
"The calculation job has one additional feature over all other processes when"
" it comes to launching them. Since an incorrectly configured calculation job"
" can potentially waste computational resources, one might want to inspect "
"the input files that will be written by the plugin, before actually "
"submitting the job. A so-called dry-run is possible by simply specifying it "
"in the metadata of the inputs. If you are using the process builder, it is "
"as simple as:"
msgstr ""

#: ../../source/topics/calculations/usage.rst:768
msgid ""
"When you now launch the process builder, the engine will perform the entire "
"process of a normal calculation job run, except that it will not actually "
"upload and submit the job to the remote computer. However, the "
"``prepare_for_submission`` method will be called. The inputs that it writes "
"to the input folder will be stored in temporary folder called "
"``submit_test`` that will be created in the current working directory. Each "
"time you perform a dry-run, a new sub folder will be created in the "
"``submit_test`` folder, which you allows you to perform multiple dry-runs "
"without overwriting the previous results."
msgstr ""

#: ../../source/topics/calculations/usage.rst:773
msgid "Moreover, the following applies:"
msgstr ""

#: ../../source/topics/calculations/usage.rst:775
msgid ""
"when calling :py:func:`~aiida.engine.launch.run` for a calculation with the "
"``dry_run`` flag set, you will get back its results, being always an empty "
"dictionary ``{}``;"
msgstr ""

#: ../../source/topics/calculations/usage.rst:778
msgid ""
"if you call :py:func:`~aiida.engine.launch.run_get_node`, you will get back "
"as a node an unstored ``CalcJobNode``. In this case, the unstored "
"``CalcJobNode`` (let's call it ``node``) will have an additional property "
"``node.dry_run_info``. This is a dictionary that contains additional "
"information on the dry-run output. In particular, it will have the following"
" keys:"
msgstr ""

#: ../../source/topics/calculations/usage.rst:784
msgid ""
"``folder``: the absolute path to the folder within the ``submit_test`` "
"folder where the files have been created, e.g.: "
"``/home/user/submit_test/20190726-00019``"
msgstr ""

#: ../../source/topics/calculations/usage.rst:787
msgid ""
"``script_filename``: the filename of the submission script that AiiDA "
"generated in the folder, e.g.: ``_aiidasubmit.sh``"
msgstr ""

#: ../../source/topics/calculations/usage.rst:790
msgid ""
"if you send a dry-run to the :py:func:`~aiida.engine.launch.submit` "
"function, this will be just forwarded to run and you will get back the "
"unstored node (with the same properties as above)."
msgstr ""

#: ../../source/topics/calculations/usage.rst:797
msgid ""
"By default the storing of provenance is enabled and this goes also for a dry"
" run. If you do not want any nodes to be created during a dry run, simply "
"set the metadata input ``store_provenance`` to ``False``."
msgstr ""

#: ../../source/topics/calculations/usage.rst:804
msgid "Parsing"
msgstr ""

#: ../../source/topics/calculations/usage.rst:805
msgid ""
"The previous sections explained in detail how the execution of an external "
"executable is wrapped by the ``CalcJob`` class to make it runnable by "
"AiiDA's engine. From the first steps of preparing the input files on the "
"remote machine, to retrieving the relevant files and storing them in a "
":py:class:`~aiida.orm.nodes.data.folder.FolderData` node, that is attached "
"as the ``retrieved`` output. This is the last *required* step for a "
"``CalcJob`` to terminate, but often we would *like* to parse the raw output "
"and attach them as queryable output nodes to the calculation job node. To "
"automatically trigger the parsing of a calculation job after its output has "
"been retrieved, is to specify the :ref:`parser name "
"option<topics:calculations:usage:calcjobs:options>`. If the engine find this"
" option specified, it will load the corresponding parser class, which should"
" be a sub class of :py:class:`~aiida.parsers.parser.Parser` and calls its "
":py:meth:`~aiida.parsers.parser.Parser.parse` method."
msgstr ""

#: ../../source/topics/calculations/usage.rst:811
msgid ""
"To explain the interface of the ``Parser`` class and the ``parse`` method, "
"let's take the "
":py:class:`~aiida.parsers.plugins.arithmetic.add.ArithmeticAddParser` as an "
"example. This parser is designed to parse the output produced by the simple "
"bash script that is wrapped by the ``ArithmeticAddCalculation`` discussed in"
" the previous sections."
msgstr ""

#: ../../source/topics/calculations/usage.rst:818
msgid ""
"To create a new parser implementation, simply create a new class that sub "
"classes the :py:class:`~aiida.parsers.parser.Parser` class. As usual, any "
"valid python class name will work, but the convention is to always use the "
"``Parser`` suffix and to use the same name as the calculation job for which "
"the parser is designed. For example, here we are implementing a parser for "
"the ``ArithmeticAddCalculation``, so therefore we name it "
"``ArithmeticAddParser``, just replacing the ``Calculation`` suffix for "
"``Parser``. The only method that needs to be implemented is the "
":py:meth:`~aiida.parsers.parser.Parser.parse` method. Its signature should "
"include ``**kwargs``, the reason for which will become clear later. The goal"
" of the ``parse`` method is very simple:"
msgstr ""

#: ../../source/topics/calculations/usage.rst:825
msgid ""
"Open and load the content of the output files generated by the calculation "
"job and have been retrieved by the engine"
msgstr ""

#: ../../source/topics/calculations/usage.rst:826
msgid ""
"Create data nodes out of this raw data that are attached as output nodes"
msgstr ""

#: ../../source/topics/calculations/usage.rst:827
msgid "Log human-readable warning messages in the case of worrying output"
msgstr ""

#: ../../source/topics/calculations/usage.rst:828
msgid ""
"Optionally return an :ref:`exit code<topics:processes:concepts:exit_codes>` "
"to indicate that the results of the calculation was not successful"
msgstr ""

#: ../../source/topics/calculations/usage.rst:830
msgid ""
"The advantage of adding the raw output data in different form as output "
"nodes, is that in that form the content becomes queryable. This allows one "
"to query for calculations that produced specific outputs with a certain "
"value, which becomes a very powerful approach for post-processing and "
"analyses of big databases."
msgstr ""

#: ../../source/topics/calculations/usage.rst:833
msgid ""
"The ``retrieved`` attribute of the parser will return the ``FolderData`` "
"node that should have been attached by the engine containing all the "
"retrieved files, as specified using the :ref:`retrieve "
"list<topics:calculations:usage:calcjobs:file_lists_retrieve>` in the "
":ref:`preparation step of the calculation "
"job<topics:calculations:usage:calcjobs:prepare>`. This retrieved folder can "
"be used to open and read the contents of the files it contains. In this "
"example, there should be a single output file that was written by "
"redirecting the standard output of the bash script that added the two "
"integers. The parser opens this file, reads its content and tries to parse "
"the sum from it:"
msgstr ""

#: ../../source/topics/calculations/usage.rst:844
msgid ""
"Note that this parsing action is wrapped in a try-except block to catch the "
"exceptions that would be thrown if the output file could not be read. If the"
" exception would not be caught, the engine will catch the exception instead "
"and set the process state of the corresponding calculation to ``Excepted``. "
"Note that this will happen for any uncaught exception that is thrown during "
"parsing. Instead, we catch these exceptions and return an exit code that is "
"retrieved by referencing it by its label, such as "
"``ERROR_READING_OUTPUT_FILE`` in this example, through the "
"``self.exit_codes`` property. This call will retrieve the corresponding exit"
" code defined on the ``CalcJob`` that we are currently parsing. Returning "
"this exit code from the parser will stop the parsing immediately and will "
"instruct the engine to set its exit status and exit message on the node of "
"this calculation job."
msgstr ""

#: ../../source/topics/calculations/usage.rst:851
msgid ""
"The ``parse_stdout`` method is just a small utility function to separate the"
" actual parsing of the data from the main parser code. In this case, the "
"parsing is so simple that we might have as well kept it in the main method, "
"but this is just to illustrate that you are completely free to organize the "
"code within the ``parse`` method for clarity. If we manage to parse the sum,"
" produced by the calculation, we wrap it in the appropriate "
":py:class:`~aiida.orm.nodes.data.int.Int` data node class, and register it "
"as an output through the ``out`` method:"
msgstr ""

#: ../../source/topics/calculations/usage.rst:861
msgid ""
"Note that if we encountered no problems, we do not have to return anything. "
"The engine will interpret this as the calculation having finished "
"successfully. You might now pose the question: \"what part of the raw data "
"should I parse and in what types of data nodes should I store it?\". This "
"not an easy question to answer in the general, because it will heavily "
"depend on the type of raw output that is produced by the calculation and "
"what parts you would like to be queryable. However, we can give you some "
"guidelines:"
msgstr ""

#: ../../source/topics/calculations/usage.rst:867
msgid ""
"Store data that you might want to query for, in the lightweight data nodes, "
"such as :py:class:`~aiida.orm.nodes.data.dict.Dict`, "
":py:class:`~aiida.orm.nodes.data.list.List` and "
":py:class:`~aiida.orm.nodes.data.structure.StructureData`. The contents of "
"these nodes are stored as attributes in the database, which makes sure that "
"they can be queried for."
msgstr ""

#: ../../source/topics/calculations/usage.rst:869
msgid ""
"Bigger data sets, such as large (multi-dimnensional) arrays, are better "
"stored in an :py:class:`~aiida.orm.nodes.data.array.array.ArrayData` or one "
"of its sub classes. If you were to store all this data in the database, it "
"would become unnecessarily bloated, because the chances you would have to "
"query for this data are unlikely. Instead these array type data nodes store "
"the bulk of their content in the repository. This way you still keep the "
"data and therewith the provenance of your calculations, while keeping your "
"database lean and fast!"
msgstr ""

#: ../../source/topics/calculations/usage.rst:878
msgid "Scheduler errors"
msgstr ""

#: ../../source/topics/calculations/usage.rst:880
msgid ""
"Besides the output parsers, the scheduler plugins can also provide parsing "
"of the output generated by the job scheduler, by implementing the "
":meth:`~aiida.schedulers.scheduler.Scheduler.parse_output` method. If the "
"scheduler plugin has implemented this method, the output generated by the "
"scheduler, written to the stdout and stderr file descriptors as well as the "
"output of the detailed job info command, is parsed. If the parser detects a "
"known problem, such as an out-of-memory (OOM) or out-of-walltime (OOW) "
"error, the corresponding exit code will already be set on the calculation "
"job node. The output parser, if defined in the inputs, can inspect the exit "
"status on the node and decide to keep it or override it with a different, "
"potentially more useful, exit code."
msgstr ""

#: ../../source/topics/calculations/usage.rst:903
msgid ""
"Note that in the example given above, the parser returns immediately if it "
"detects that the scheduler detected a problem. Since it returns `None`, the "
"exit code of the scheduler will be kept and will be the final exit code of "
"the calculation job. However, the parser does not have to immediately "
"return. It can still try to parse some of the retrieved output, if there is "
"any. If it finds a more specific problem than the generic scheduler error, "
"it can always return an exit code of itself to override it. The parser can "
"even return ``ExitCode(0)`` to have the calculation marked as successfully "
"finished, despite the scheduler having determined that there was a problem. "
"The following table summarizes the possible scenarios of the scheduler "
"parser and output parser returning an exit code and what the final resulting"
" exit code will be that is set on the node:"
msgstr ""

#: ../../source/topics/calculations/usage.rst:912
msgid "**Scenario**"
msgstr ""

#: ../../source/topics/calculations/usage.rst:912
msgid "**Scheduler result**"
msgstr ""

#: ../../source/topics/calculations/usage.rst:912
msgid "**Retrieved result**"
msgstr ""

#: ../../source/topics/calculations/usage.rst:912
msgid "**Final result**"
msgstr ""

#: ../../source/topics/calculations/usage.rst:914
msgid "Neither parser found any problem."
msgstr ""

#: ../../source/topics/calculations/usage.rst:914
#: ../../source/topics/calculations/usage.rst:916
#: ../../source/topics/calculations/usage.rst:919
msgid "``None``"
msgstr ""

#: ../../source/topics/calculations/usage.rst:914
#: ../../source/topics/calculations/usage.rst:924
msgid "``ExitCode(0)``"
msgstr ""

#: ../../source/topics/calculations/usage.rst:916
msgid "Scheduler parser found an issue, but output parser does not override."
msgstr ""

#: ../../source/topics/calculations/usage.rst:916
#: ../../source/topics/calculations/usage.rst:921
#: ../../source/topics/calculations/usage.rst:924
msgid "``ExitCode(100)``"
msgstr ""

#: ../../source/topics/calculations/usage.rst:919
msgid "Only output parser found a problem."
msgstr ""

#: ../../source/topics/calculations/usage.rst:919
#: ../../source/topics/calculations/usage.rst:921
msgid "``ExitCode(400)``"
msgstr ""

#: ../../source/topics/calculations/usage.rst:921
msgid ""
"Scheduler parser found an issue, but the output parser overrides with a more"
" specific error code."
msgstr ""

#: ../../source/topics/calculations/usage.rst:924
msgid ""
"Scheduler found issue but output parser overrides saying that despite that "
"the calculation should be considered finished successfully."
msgstr ""

#: ../../source/topics/cli.rst:5
msgid "Command line interface"
msgstr ""

#: ../../source/topics/cli.rst:7
msgid ""
"The command line interface utility for AiiDA is called ``verdi``. This "
"section explains the basic concepts that apply to all ``verdi`` commands."
msgstr ""

#: ../../source/topics/cli.rst:12
msgid ""
"The ``verdi`` command line interface can also be explored as a `text-based "
"user interface <https://en.wikipedia.org/wiki/Text-based_user_interface>`_ "
"(TUI). It requires ``aiida-core`` to be installed with the ``tui`` extra "
"(e.g. ``pip install aiida-core[tui]``). The TUI can then be launched with "
"``verdi tui``."
msgstr ""

#: ../../source/topics/cli.rst:20
msgid "Parameters"
msgstr ""

#: ../../source/topics/cli.rst:21
msgid "Parameters to ``verdi`` commands come in two flavors:"
msgstr ""

#: ../../source/topics/cli.rst:23
msgid ""
"Arguments: positional parameters, e.g. ``123`` in ``verdi process kill 123``"
msgstr ""

#: ../../source/topics/cli.rst:24
msgid ""
"Options: announced by a flag (e.g. ``-f`` or ``--flag``), potentially "
"followed by a value. E.g. ``verdi process list --limit 10`` or ``verdi "
"process -h``."
msgstr ""

#: ../../source/topics/cli.rst:29
msgid "Multi-value options"
msgstr ""

#: ../../source/topics/cli.rst:31
msgid ""
"Some ``verdi`` commands provide *options* that can take multiple values. "
"This allows to avoid repetition and e.g. write::"
msgstr ""

#: ../../source/topics/cli.rst:36
msgid "instead of the more lengthy::"
msgstr ""

#: ../../source/topics/cli.rst:40
msgid ""
"Note the use of the so-called 'endopts' marker ``--`` that is necessary to "
"mark the end of the ``-N`` option and distinguish it from the "
"``archive.aiida`` argument."
msgstr ""

#: ../../source/topics/cli.rst:46
msgid "Help strings"
msgstr ""

#: ../../source/topics/cli.rst:47
msgid ""
"Append the ``--help`` option to any verdi (sub-)command to get help on how "
"to use it. For example, ``verdi process kill --help`` shows::"
msgstr ""

#: ../../source/topics/cli.rst:61
msgid "All help strings consist of three parts:"
msgstr ""

#: ../../source/topics/cli.rst:63
msgid "A ``Usage:`` line describing how to invoke the command"
msgstr ""

#: ../../source/topics/cli.rst:64
msgid "A description of the command's functionality"
msgstr ""

#: ../../source/topics/cli.rst:65
msgid "A list of the available options"
msgstr ""

#: ../../source/topics/cli.rst:67
msgid ""
"The ``Usage:`` line encodes information on the command's parameters, e.g.:"
msgstr ""

#: ../../source/topics/cli.rst:69
msgid "``[OPTIONS]``: this command takes one (or more) options"
msgstr ""

#: ../../source/topics/cli.rst:70
msgid ""
"``PROCESSES``: this command *requires* a process as a positional argument"
msgstr ""

#: ../../source/topics/cli.rst:71
msgid ""
"``[PROCESSES]``: this command takes a process as an *optional* positional "
"argument"
msgstr ""

#: ../../source/topics/cli.rst:72
msgid ""
"``[PROCESSES]...``: this command takes one or more processes as *optional* "
"positional arguments"
msgstr ""

#: ../../source/topics/cli.rst:74
msgid ""
"Multi-value options are followed by ``...`` in the help string and the "
"``Usage:`` line of the corresponding command will contain the 'endopts' "
"marker. For example::"
msgstr ""

#: ../../source/topics/cli.rst:97
msgid "Profile"
msgstr ""

#: ../../source/topics/cli.rst:98
msgid ""
"AiiDA supports multiple profiles per installation, one of which is marked as"
" the default and used unless another profile is requested. Show the current "
"default profile using::"
msgstr ""

#: ../../source/topics/cli.rst:103
msgid ""
"In order to use a different profile, pass the ``-p/--profile`` option to any"
" ``verdi`` command, for example::"
msgstr ""

#: ../../source/topics/cli.rst:107
msgid ""
"Note that the specified profile will be used for this and *only* this "
"command. Use ``verdi profile setdefault`` in order to permanently change the"
" default profile."
msgstr ""

#: ../../source/topics/cli.rst:114
msgid "Verbosity"
msgstr ""

#: ../../source/topics/cli.rst:115
msgid ""
"All ``verdi`` commands have the ``-v/--verbosity`` option, which allows to "
"control the verbosity of the output that is printed by the command. The "
"option takes a value that is known as the log level and all messages that "
"are emitted with an inferior log level will be suppressed. The valid values "
"in order of increasing log level are: `NOTSET`, `DEBUG`, `INFO`, `REPORT`, "
"`WARNING`, `ERROR` and `CRITICAL`. For example, if the log level is set to "
"``ERROR``, only messages with the ``ERROR`` and ``CRITICAL`` level will be "
"shown. The choice for these log level values comes directly from `Python's "
"built-in logging module <https://docs.python.org/3/library/logging.html>`_. "
"The ``REPORT`` level is a log level that is defined and added by AiiDA that "
"sits between the ``INFO`` and ``WARNING`` level, and is the default log "
"level."
msgstr ""

#: ../../source/topics/cli.rst:122
msgid ""
"The verbosity option is case-insensitive, i.e., ``--verbosity debug`` and "
"``--verbosity DEBUG`` are identical. The option can be passed at any "
"subcommand level, for example:"
msgstr ""

#: ../../source/topics/cli.rst:129
msgid "is identical to"
msgstr ""

#: ../../source/topics/cli.rst:135
msgid ""
"When the option is specified multiple times, only the last value will be "
"considered. If the `--verbosity` option is specified, it overrides the log "
"level of all the loggers configured by AiiDA, e.g. `logging.aiida_loglevel`."
msgstr ""

#: ../../source/topics/cli.rst:142
msgid "Identifiers"
msgstr ""

#: ../../source/topics/cli.rst:144
msgid ""
"When working with AiiDA entities, you need a way to *refer* to them on the "
"command line. Any entity in AiiDA can be addressed via three identifiers:"
msgstr ""

#: ../../source/topics/cli.rst:147
msgid ""
"\"Primary Key\" (PK): An integer, e.g. ``723``, identifying your entity "
"within your database (automatically assigned)"
msgstr ""

#: ../../source/topics/cli.rst:148
msgid ""
"`Universally Unique Identifier "
"<https://en.wikipedia.org/wiki/Universally_unique_identifier#Version_4_(random)>`_"
" (UUID): A string, e.g. ``ce81c420-7751-48f6-af8e-eb7c6a30cec3`` identifying"
" your entity globally (automatically assigned)"
msgstr ""

#: ../../source/topics/cli.rst:149
msgid ""
"Label: A human-readable string, e.g. ``test_calculation`` (manually "
"assigned)"
msgstr ""

#: ../../source/topics/cli.rst:153
msgid ""
"PKs are easy to type and work as long as you stay within your database. "
"**When sharing data with others, however, always use UUIDs.**"
msgstr ""

#: ../../source/topics/cli.rst:156
msgid ""
"Any ``verdi`` command that expects an identifier as a paramter will accept "
"PKs, UUIDs and labels."
msgstr ""

#: ../../source/topics/cli.rst:158
msgid ""
"In almost all cases, this will work out of the box. Since command line "
"parameters are passed as strings, AiiDA needs to deduce the type of "
"identifier from its content, which can fail in edge cases (see "
":ref:`topics:cli:identifier_resolution` for details). You can take the "
"following precautions in order to avoid such edge cases:"
msgstr ""

#: ../../source/topics/cli.rst:162
msgid "PK: no precautions needed"
msgstr ""

#: ../../source/topics/cli.rst:163
msgid ""
"UUID: no precautions needed for full UUIDs. Partial UUIDs should include at "
"least one non-numeric character or dash"
msgstr ""

#: ../../source/topics/cli.rst:164
msgid ""
"Label: add an exclamation mark ``!`` at the end of the identifier in order "
"to force interpretation as a label"
msgstr ""

#: ../../source/topics/cli.rst:170
msgid "Implementation of identifier resolution"
msgstr ""

#: ../../source/topics/cli.rst:172
msgid "The logic for deducing the identifier type is as follows:"
msgstr ""

#: ../../source/topics/cli.rst:174
msgid "Try interpreting the identifier as a PK (integer)"
msgstr ""

#: ../../source/topics/cli.rst:175
msgid ""
"If this fails, try interpreting the identifier as a UUID (full or partial)"
msgstr ""

#: ../../source/topics/cli.rst:176
msgid "If this fails, interpret the identifier as a label"
msgstr ""

#: ../../source/topics/cli.rst:178
msgid ""
"The following example illustrates edge cases that can arise in this logic:"
msgstr ""

#: ../../source/topics/cli.rst:181
msgid "PK"
msgstr ""

#: ../../source/topics/cli.rst:181
msgid "UUID"
msgstr ""

#: ../../source/topics/cli.rst:181
msgid "LABEL"
msgstr ""

#: ../../source/topics/cli.rst:183 ../../source/topics/cli.rst:184
msgid "10"
msgstr ""

#: ../../source/topics/cli.rst:183
msgid "12dfb104-7b2b-4bca-adc0-1e4fd4ffcc88"
msgstr ""

#: ../../source/topics/cli.rst:183
msgid "group"
msgstr ""

#: ../../source/topics/cli.rst:184
msgid "11"
msgstr ""

#: ../../source/topics/cli.rst:184
msgid "deadbeef-62ba-444f-976d-31d925dac557"
msgstr ""

#: ../../source/topics/cli.rst:185
msgid "12"
msgstr ""

#: ../../source/topics/cli.rst:185
msgid "3df34a1e-5215-4e1a-b626-7f75b9586ef5"
msgstr ""

#: ../../source/topics/cli.rst:185
msgid "deadbeef"
msgstr ""

#: ../../source/topics/cli.rst:188
msgid ""
"trying to identify the first entity by its partial UUID ``12`` would match "
"the third entity by its PK instead"
msgstr ""

#: ../../source/topics/cli.rst:189
msgid ""
"trying to identify the second entity by its label ``10`` would match the "
"first entity by its PK instead"
msgstr ""

#: ../../source/topics/cli.rst:190
msgid ""
"trying to identify the third entity by its label ``deadbeef`` would match "
"the second entity on its partial UUID ``deadbeef`` instead"
msgstr ""

#: ../../source/topics/cli.rst:192
msgid ""
"The ambiguity between a partial UUID and a PK can always be resolved by "
"including a longer substring of the UUID, eventually rendering the "
"identifier no longer a valid PK."
msgstr ""

#: ../../source/topics/cli.rst:194
msgid ""
"The case of a label being also a valid PK or (partial) UUID requires a "
"different solution. For this case, ``verdi`` reserves a special character, "
"the exclamation mark ``!``, that can be appended to the identifier. Before "
"any type guessing is done, AiiDA checks for the presence of this marker and,"
" if found, will interpret the identifier as a label. I.e. to solve ambiguity"
" examples mentioned above, one would pass ``10!`` and ``deadbeef!``."
msgstr ""

#: ../../source/topics/daemon.rst:5
msgid "Daemon"
msgstr ""

#: ../../source/topics/daemon.rst:7
msgid ""
"AiiDA provides a daemon process that runs in the background which handles "
"any new processes (i.e., calculations and workflows, see :ref:`process "
"concepts <topics:processes:concepts>`) that are submitted. Unlike when "
"running a process, which blocks the current Python interpreter (see the "
":ref:`launching <topics:processes:usage:launching>` section for details on "
"the difference between *run* and *submit*), the daemon can handle multiple "
"processes asynchronously."
msgstr ""

#: ../../source/topics/daemon.rst:10
msgid "The daemon concept in AiiDA consists of multiple *system processes*."
msgstr ""

#: ../../source/topics/daemon.rst:14
msgid ""
"System processes, here, refers to processes that are run by the operating "
"system, not to the AiiDA specific collective term for all calculations and "
"workflows."
msgstr ""

#: ../../source/topics/daemon.rst:16
msgid ""
"When the daemon is started, a single system process is launched in the "
"background that runs indefinitely until it is stopped. This daemonized "
"process is responsible for launching and then monitoring one or multiple "
"daemon *workers*. Each daemon worker is another system process that connects"
" to RabbitMQ to retrieve calculations and workflows that have been submitted"
" and run them to completion. If a daemon worker dies, the daemon will "
"automatically revive it. When the daemon is requested to stop, it will send "
"a signal to all workers to shut them down before shutting down itself."
msgstr ""

#: ../../source/topics/daemon.rst:22
msgid ""
"In summary: AiiDA's daemon consists of a single system process running in "
"the background (the daemon) that manages one or more system processes that "
"handle all submitted calculations and workflows (the daemon workers)."
msgstr ""

#: ../../source/topics/daemon.rst:29
msgid "Client"
msgstr ""

#: ../../source/topics/daemon.rst:31
msgid ""
"The Python API provides the "
":class:`~aiida.engine.daemon.client.DaemonClient` class to interact with the"
" daemon. It can either be constructed directly for a given profile, or the "
":func:`aiida.engine.get_daemon_client` utility function can be used to "
"construct it. In order to control the daemon for the current default "
"profile:"
msgstr ""

#: ../../source/topics/daemon.rst:40
msgid "It is also possible to explicitly specify a profile:"
msgstr ""

#: ../../source/topics/daemon.rst:46
msgid "The daemon can be started and stopped through the client:"
msgstr ""

#: ../../source/topics/daemon.rst:54
msgid "The main methods of interest for interacting with the daemon are:"
msgstr ""

#: ../../source/topics/daemon.rst:56
msgid ":meth:`~aiida.engine.daemon.client.DaemonClient.start_daemon`"
msgstr ""

#: ../../source/topics/daemon.rst:57
msgid ":meth:`~aiida.engine.daemon.client.DaemonClient.restart_daemon`"
msgstr ""

#: ../../source/topics/daemon.rst:58
msgid ":meth:`~aiida.engine.daemon.client.DaemonClient.stop_daemon`"
msgstr ""

#: ../../source/topics/daemon.rst:59
msgid ":meth:`~aiida.engine.daemon.client.DaemonClient.get_status`"
msgstr ""

#: ../../source/topics/daemon.rst:61
msgid ""
"These methods will raise a "
":class:`~aiida.engine.daemon.client.DaemonException` if the daemon fails to "
"start or calls to it fail. All methods accept a ``timeout`` argument, which "
"is the number of seconds the client should wait for the daemon process to "
"respond, before raising a "
":class:`~aiida.engine.daemon.client.DaemonTimeoutException`. The default for"
" the ``timeout`` is taken from the ``daemon.timeout`` configuration option "
"and is set when constructing the "
":class:`~aiida.engine.daemon.client.DaemonClient`."
msgstr ""

#: ../../source/topics/daemon.rst:67
msgid ""
"The ``DaemonClient`` only directly interacts with the main daemon process, "
"not with any of the daemon workers that it manages."
msgstr ""

#: ../../source/topics/data_types.rst:5
msgid "Data types"
msgstr ""

#: ../../source/topics/data_types.rst:7
msgid ""
"AiiDA already ships with a number of useful data types. This section details"
" the most common, and some handy features/functionalities to work with them."
msgstr ""

#: ../../source/topics/data_types.rst:10
msgid ""
"The different data types can be accessed through the "
":py:func:`~aiida.plugins.factories.DataFactory` function (also exposed from "
":py:mod:`aiida.plugins`) by passing the corresponding entry point as an "
"argument, for example when working in the ``verdi shell``:"
msgstr ""

#: ../../source/topics/data_types.rst:18
msgid ""
"Many of the examples in this section will assume you are working inside the "
"``verdi shell``. If this is not the case, you will have to first load e.g. "
"the :py:func:`~aiida.plugins.factories.DataFactory()` function:"
msgstr ""

#: ../../source/topics/data_types.rst:27
msgid ""
"A list of all the data entry points can be obtain running the command "
"``verdi plugin list aiida.data``."
msgstr ""

#: ../../source/topics/data_types.rst:29
msgid ""
"For all data types, you can follow the link to the corresponding data class "
"in the API reference to read more about the class and its methods. We also "
"detail what is stored in the database (mostly as attributes, so the "
"information can be easily queried e.g. with the :ref:`QueryBuilder <how-"
"to:query>`) and what is stored as a raw file in the AiiDA file repository "
"(providing access to the file contents, but not efficiently queryable: this "
"is useful for e.g. big data files that don't need to be queried for)."
msgstr ""

#: ../../source/topics/data_types.rst:31
msgid ""
"If you need to work with some specific type of data, first check the list of"
" data types/plugins below, and if you don't find what you need, give a look "
"to :ref:`Adding support for custom data types <topics:data_types:plugin>`."
msgstr ""

#: ../../source/topics/data_types.rst:36
msgid "Core data types"
msgstr ""

#: ../../source/topics/data_types.rst:38
msgid ""
"Below is a list of the core data types already provided with AiiDA, along "
"with their entry point and where the data is stored once the node is stored "
"in the AiiDA database."
msgstr ""

#: ../../source/topics/data_types.rst:44
#: ../../source/topics/data_types.rst:759
msgid "**Class**"
msgstr ""

#: ../../source/topics/data_types.rst:44
#: ../../source/topics/data_types.rst:759
msgid "**Entry point**"
msgstr ""

#: ../../source/topics/data_types.rst:44
#: ../../source/topics/data_types.rst:759
msgid "**Stored in database**"
msgstr ""

#: ../../source/topics/data_types.rst:44
#: ../../source/topics/data_types.rst:759
msgid "**Stored in repository**"
msgstr ""

#: ../../source/topics/data_types.rst:46
msgid ":ref:`Int <topics:data_types:core:base>`"
msgstr ""

#: ../../source/topics/data_types.rst:46
msgid "``core.int``"
msgstr ""

#: ../../source/topics/data_types.rst:46
msgid "The integer value"
msgstr ""

#: ../../source/topics/data_types.rst:46 ../../source/topics/data_types.rst:48
#: ../../source/topics/data_types.rst:50 ../../source/topics/data_types.rst:52
#: ../../source/topics/data_types.rst:54 ../../source/topics/data_types.rst:56
#: ../../source/topics/data_types.rst:58 ../../source/topics/data_types.rst:60
#: ../../source/topics/data_types.rst:68 ../../source/topics/data_types.rst:72
#: ../../source/topics/data_types.rst:76 ../../source/topics/data_types.rst:80
msgid "``-``"
msgstr ""

#: ../../source/topics/data_types.rst:48
msgid ":ref:`Float <topics:data_types:core:base>`"
msgstr ""

#: ../../source/topics/data_types.rst:48
msgid "``core.float``"
msgstr ""

#: ../../source/topics/data_types.rst:48
msgid "The float value"
msgstr ""

#: ../../source/topics/data_types.rst:50
msgid ":ref:`Str <topics:data_types:core:base>`"
msgstr ""

#: ../../source/topics/data_types.rst:50
msgid "``core.str``"
msgstr ""

#: ../../source/topics/data_types.rst:50
msgid "The string"
msgstr ""

#: ../../source/topics/data_types.rst:52
msgid ":ref:`Bool <topics:data_types:core:base>`"
msgstr ""

#: ../../source/topics/data_types.rst:52
msgid "``core.bool``"
msgstr ""

#: ../../source/topics/data_types.rst:52
msgid "The boolean value"
msgstr ""

#: ../../source/topics/data_types.rst:54
msgid ":ref:`List <topics:data_types:core:base:iterable>`"
msgstr ""

#: ../../source/topics/data_types.rst:54
msgid "``core.list``"
msgstr ""

#: ../../source/topics/data_types.rst:54
msgid "The complete list"
msgstr ""

#: ../../source/topics/data_types.rst:56
msgid ":ref:`Dict <topics:data_types:core:base:iterable>`"
msgstr ""

#: ../../source/topics/data_types.rst:56
msgid "``core.dict``"
msgstr ""

#: ../../source/topics/data_types.rst:56
msgid "The complete dictionary"
msgstr ""

#: ../../source/topics/data_types.rst:58
msgid ":ref:`EnumData <topics:data_types:core:base:enum>`"
msgstr ""

#: ../../source/topics/data_types.rst:58
msgid "``core.enum``"
msgstr ""

#: ../../source/topics/data_types.rst:58
msgid "The value, name and the class identifier"
msgstr ""

#: ../../source/topics/data_types.rst:60
msgid ":ref:`JsonableData <topics:data_types:core:jsonable>`"
msgstr ""

#: ../../source/topics/data_types.rst:60
msgid "``core.jsonable``"
msgstr ""

#: ../../source/topics/data_types.rst:60
msgid "The JSON data and the class identifier"
msgstr ""

#: ../../source/topics/data_types.rst:62
msgid ":ref:`ArrayData <topics:data_types:core:array>`"
msgstr ""

#: ../../source/topics/data_types.rst:62
msgid "``core.array``"
msgstr ""

#: ../../source/topics/data_types.rst:62 ../../source/topics/data_types.rst:64
msgid "The array names and corresponding shapes"
msgstr ""

#: ../../source/topics/data_types.rst:62 ../../source/topics/data_types.rst:64
msgid "The array data in ``.npy`` format"
msgstr ""

#: ../../source/topics/data_types.rst:64
msgid ":ref:`XyData <topics:data_types:core:array:xy>`"
msgstr ""

#: ../../source/topics/data_types.rst:64
msgid "``core.array.xy``"
msgstr ""

#: ../../source/topics/data_types.rst:66
msgid ":ref:`SinglefileData <topics:data_types:core:singlefile>`"
msgstr ""

#: ../../source/topics/data_types.rst:66
msgid "``core.singlefile``"
msgstr ""

#: ../../source/topics/data_types.rst:66
msgid "The filename"
msgstr ""

#: ../../source/topics/data_types.rst:66
msgid "The file"
msgstr ""

#: ../../source/topics/data_types.rst:68
msgid ":ref:`FolderData <topics:data_types:core:folder>`"
msgstr ""

#: ../../source/topics/data_types.rst:68
msgid "``core.folder``"
msgstr ""

#: ../../source/topics/data_types.rst:68 ../../source/topics/data_types.rst:70
#: ../../source/topics/data_types.rst:74
msgid "All files and folders"
msgstr ""

#: ../../source/topics/data_types.rst:70
msgid ":ref:`RemoteData <topics:data_types:core:remote>`"
msgstr ""

#: ../../source/topics/data_types.rst:70
msgid "``core.remote``"
msgstr ""

#: ../../source/topics/data_types.rst:70
msgid "The computer and the absolute path to the folder"
msgstr ""

#: ../../source/topics/data_types.rst:72
msgid ":ref:`AbstractCode <topics:data_types:core:code>`"
msgstr ""

#: ../../source/topics/data_types.rst:72
msgid "Default plugin, append/prepend text"
msgstr ""

#: ../../source/topics/data_types.rst:74
msgid ":ref:`Code <topics:data_types:core:code:legacy>`"
msgstr ""

#: ../../source/topics/data_types.rst:74
msgid "``core.code``"
msgstr ""

#: ../../source/topics/data_types.rst:74 ../../source/topics/data_types.rst:76
msgid "The computer and the executable path"
msgstr ""

#: ../../source/topics/data_types.rst:76
msgid ":ref:`InstalledCode <topics:data_types:core:code:installed>`"
msgstr ""

#: ../../source/topics/data_types.rst:76
msgid "``core.code.installed``"
msgstr ""

#: ../../source/topics/data_types.rst:78
msgid ":ref:`PortableCode <topics:data_types:core:code:portable>`"
msgstr ""

#: ../../source/topics/data_types.rst:78
msgid "``core.code.portable``"
msgstr ""

#: ../../source/topics/data_types.rst:78
msgid "The relative path of the executable"
msgstr ""

#: ../../source/topics/data_types.rst:78
msgid "All files and folders of the code"
msgstr ""

#: ../../source/topics/data_types.rst:80
msgid ":ref:`ContainerizedCode <topics:data_types:core:code:containerized>`"
msgstr ""

#: ../../source/topics/data_types.rst:80
msgid "``core.code.containerized``"
msgstr ""

#: ../../source/topics/data_types.rst:80
msgid "The computer, the image and the executable path"
msgstr ""

#: ../../source/topics/data_types.rst:87
msgid "Base types"
msgstr ""

#: ../../source/topics/data_types.rst:89
msgid ""
"There are a number of useful classes that wrap base Python data types "
"(:py:class:`~aiida.orm.nodes.data.int.Int`, "
":py:class:`~aiida.orm.nodes.data.float.Float`, "
":py:class:`~aiida.orm.nodes.data.str.Str`, "
":py:class:`~aiida.orm.nodes.data.bool.Bool`) so they can be stored in the "
"provenance. These are automatically loaded with the ``verdi shell``, and "
"also directly exposed from :py:mod:`aiida.orm`. They are particularly useful"
" when you need to provide a single parameter to e.g. a "
":py:class:`~aiida.engine.processes.functions.workfunction`."
msgstr ""

#: ../../source/topics/data_types.rst:93
msgid ""
"Each of these classes can most often be used in a similar way as their "
"corresponding base type:"
msgstr ""

#: ../../source/topics/data_types.rst:99
msgid ""
"If you need to access the bare value and not the whole AiiDA class, use the "
"``.value`` property:"
msgstr ""

#: ../../source/topics/data_types.rst:108
msgid ""
"While this is convenient if you need to do simple manipulations like "
"multiplying two numbers, be very careful not to pass such nodes instead of "
"the corresponding Python values to libraries that perform heavy computations"
" with them. In fact, any operation on the value would be replaced with an "
"operation creating new AiiDA nodes, that however can be orders of magnitude "
"slower (see `this discussion <https://github.com/aiidateam/aiida-"
"core/issues/3320>`_ on GitHub). In this case, remember to pass the "
"node.value to the mathematical function instead."
msgstr ""

#: ../../source/topics/data_types.rst:114
msgid ""
"AiiDA has also implemented data classes for two basic Python iterables: "
":py:class:`~aiida.orm.nodes.data.list.List` and "
":py:class:`~aiida.orm.nodes.data.dict.Dict`. They can store any list or "
"dictionary where elements can be a base python type (strings, floats, "
"integers, booleans, None type):"
msgstr ""

#: ../../source/topics/data_types.rst:120
msgid ""
"Note the use of the keyword argument ``list``, this is required for the "
"constructor of the :py:class:`~aiida.orm.nodes.data.list.List` class. You "
"can also store lists or dictionaries within the iterable, at any depth "
"level. For example, you can create a dictionary where a value is a list of "
"dictionaries:"
msgstr ""

#: ../../source/topics/data_types.rst:128
msgid ""
"To obtain the Python ``list`` or ``dictionary`` from a "
":py:class:`~aiida.orm.nodes.data.list.List` or "
":py:class:`~aiida.orm.nodes.data.dict.Dict` instance, you have to use the "
":py:meth:`~aiida.orm.nodes.data.list.List.get_list()` or "
":py:meth:`~aiida.orm.nodes.data.dict.Dict.get_dict()` methods:"
msgstr ""

#: ../../source/topics/data_types.rst:138
msgid ""
"However, you can also use the list index or dictionary key to extract "
"specific values:"
msgstr ""

#: ../../source/topics/data_types.rst:148
msgid ""
"You can also use many methods of the corresponding Python base type, for "
"example:"
msgstr ""

#: ../../source/topics/data_types.rst:157
msgid ""
"For all of the base data types, their value is stored in the database in the"
" attributes column once you store the node using the "
":py:meth:`~aiida.orm.nodes.node.Node.store()` method."
msgstr ""

#: ../../source/topics/data_types.rst:161
msgid ""
"The :py:class:`~aiida.orm.List` and :py:class:`~aiida.orm.Dict` only store "
"the Python base types, not the corresponding AiiDA data type. These will be "
"converted to their corresponding Python base type when storing the "
":py:class:`~aiida.orm.List` or :py:class:`~aiida.orm.Dict` node in the "
"database."
msgstr ""

#: ../../source/topics/data_types.rst:167
msgid "EnumData"
msgstr ""

#: ../../source/topics/data_types.rst:171
msgid ""
"An `Enum` member is represented by three attributes in the "
":py:class:`~aiida.orm.EnumData` class:"
msgstr ""

#: ../../source/topics/data_types.rst:173
msgid "``name``: the member's name"
msgstr ""

#: ../../source/topics/data_types.rst:174
msgid "``value``: the member's value"
msgstr ""

#: ../../source/topics/data_types.rst:175
msgid "``identifier``: the string representation of the enum's identifier"
msgstr ""

#: ../../source/topics/data_types.rst:199
msgid "JsonableData"
msgstr ""

#: ../../source/topics/data_types.rst:203
msgid ""
":py:class:`~aiida.orm.JsonableData` is a data plugin that allows one to "
"easily wrap existing objects that are JSON-able."
msgstr ""

#: ../../source/topics/data_types.rst:205
msgid ""
"Any class that implements an ``as_dict`` method, returning a dictionary that"
" is a JSON serializable representation of the object, can be wrapped and "
"stored by this data plugin. To deserialize it should also implement a "
"``from_dict`` method, which takes the dictionary as input and returns the "
"object."
msgstr ""

#: ../../source/topics/data_types.rst:232
msgid "ArrayData"
msgstr ""

#: ../../source/topics/data_types.rst:234
msgid ""
"The :py:class:`~aiida.orm.ArrayData` class can be used to represent `numpy "
"<https://numpy.org/>`_ arrays in the provenance. Each array is assigned to a"
" name specified by the user using the "
":py:meth:`~aiida.orm.ArrayData.set_array()` method:"
msgstr ""

#: ../../source/topics/data_types.rst:245
msgid ""
"Note that one :py:class:`~aiida.orm.ArrayData` instance can store multiple "
"arrays under different names:"
msgstr ""

#: ../../source/topics/data_types.rst:251
msgid ""
"To see the list of array names stored in the "
":py:class:`~aiida.orm.ArrayData` instance, you can use the "
":py:meth:`~aiida.orm.ArrayData.get_arraynames()` method:"
msgstr ""

#: ../../source/topics/data_types.rst:258
msgid ""
"If you want the array corresponding to a certain name, simply supply the "
"name to the :py:meth:`~aiida.orm.ArrayData.get_array()` method:"
msgstr ""

#: ../../source/topics/data_types.rst:267
msgid ""
"As with all nodes, you can store the :py:class:`~aiida.orm.ArrayData` node "
"using the :py:meth:`~aiida.orm.nodes.node.Node.store()` method. However, "
"only the names and shapes of the arrays are stored to the database, the "
"content of the arrays is stored to the repository in the `numpy format "
"<https://numpy.org/doc/stable/reference/generated/numpy.lib.format.html#npy-"
"format>`_ (``.npy``)."
msgstr ""

#: ../../source/topics/data_types.rst:272
msgid "XyData"
msgstr ""

#: ../../source/topics/data_types.rst:274
msgid ""
"In case you are working with arrays that have a relationship with each "
"other, i.e. ``y`` as a function of ``x``, you can use the "
":py:class:`~aiida.orm.XyData` class:"
msgstr ""

#: ../../source/topics/data_types.rst:282
msgid ""
"This class is equipped with setter and getter methods for the ``x`` and "
"``y`` values specifically, and takes care of some validation (e.g. check "
"that they have the same shape). The user also has to specify the units for "
"both ``x`` and ``y``:"
msgstr ""

#: ../../source/topics/data_types.rst:291
msgid ""
"Note that you can set multiple ``y`` values that correspond to the ``x`` "
"grid. Same as for the :py:class:`~aiida.orm.ArrayData`, the names and shapes"
" of the arrays are stored to the database, the content of the arrays is "
"stored to the repository in the `numpy format "
"<https://numpy.org/doc/stable/reference/generated/numpy.lib.format.html#npy-"
"format>`_ (``.npy``)."
msgstr ""

#: ../../source/topics/data_types.rst:297
msgid "SinglefileData"
msgstr ""

#: ../../source/topics/data_types.rst:299
msgid ""
"In order to include a single file in the provenance, you can use the "
":py:class:`~aiida.orm.nodes.data.singlefile.SinglefileData` class. This "
"class can be initialized via the **absolute** path to the file you want to "
"store:"
msgstr ""

#: ../../source/topics/data_types.rst:308
msgid ""
"When storing the node, the filename is stored in the database and the file "
"itself is copied to the repository. The contents of the file in string "
"format can be obtained using the "
":py:meth:`~aiida.orm.nodes.data.singlefile.SinglefileData.get_content()` "
"method:"
msgstr ""

#: ../../source/topics/data_types.rst:316
#: ../../source/topics/data_types.rst:415
msgid ""
"For large files, reading the entire content into memory using "
":py:meth:`~aiida.orm.nodes.repository.NodeRepository.get_object_content()` "
"may not be desirable. Instead, a file-like handle can be opened to a file in"
" the repository which can be used to read the content as a stream. This can "
"be useful, for example, to copy a large file from the repository to a file "
"on disk, without loading it entirely into memory:"
msgstr ""

#: ../../source/topics/data_types.rst:327
#: ../../source/topics/data_types.rst:426
msgid ""
"To guarantee the file is copied over identically (and there are no encoding "
"issues), the files are opened in \"binary\" mode by including the ``b`` "
"character in the ``mode`` argument."
msgstr ""

#: ../../source/topics/data_types.rst:329
msgid ""
"For efficiency reasons, the repository interface only provides access to "
"object content through file-like objects or strings. However, for certain "
"use-cases, the object content _needs_ to be made available as a file on the "
"local file system. For example, the ``numpy.loadtxt`` method only accepts a "
"filepath, and no file-like objects. In this case, the content of the file "
"can be made available on the local file system using the "
":py:meth:`~aiida.orm.nodes.repository.NodeRepository.as_path()` context "
"manager:"
msgstr ""

#: ../../source/topics/data_types.rst:339
msgid ""
"The yielded value ``filepath`` is an instance of ``pathlib.Path`` that "
"points to a location on the local file system containing the content of the "
"file. The temporary copy on the local file system is automatically cleaned "
"up once the context manager is exited."
msgstr ""

#: ../../source/topics/data_types.rst:344
#: ../../source/topics/data_types.rst:444
msgid ""
"The temporary directory to which the content is copied is created using the "
":meth:`tempfile.TemporaryDirectory` function of the standard library. Its "
"location is chosen from a platform-dependent list or can be controlled "
"through the ``TMPDIR`` environment variable (see `the official documentation"
" <https://docs.python.org/3/library/tempfile.html#tempfile.mkstemp>`_ for "
"details)."
msgstr ""

#: ../../source/topics/data_types.rst:349
msgid ""
"The :py:meth:`~aiida.orm.nodes.repository.NodeRepository.as_path()` context "
"manager will copy the file content to a temporary folder on the local file "
"system. For large files this can be an expensive operation and it is "
"inefficient since it requires an additional read and write operation. "
"Therefore, if it is possible to use file-like objects or read the content "
"into memory, the "
":py:meth:`~aiida.orm.nodes.repository.NodeRepository.get_object_content()` "
"and :py:meth:`~aiida.orm.nodes.repository.NodeRepository.open()` methods "
"should be preferred."
msgstr ""

#: ../../source/topics/data_types.rst:357
msgid "FolderData"
msgstr ""

#: ../../source/topics/data_types.rst:359
msgid ""
"The :py:class:`~aiida.orm.nodes.data.folder.FolderData` class stores sets of"
" files and folders (including its subfolders). To store a complete "
"directory, simply use the ``tree`` keyword:"
msgstr ""

#: ../../source/topics/data_types.rst:368
msgid ""
"Alternatively, you can construct the node first and then use the various "
"repository methods to add objects from directory and file paths:"
msgstr ""

#: ../../source/topics/data_types.rst:378
msgid ""
"or from `file-like objects <https://docs.python.org/3/glossary.html#term-"
"file-like-object>`_:"
msgstr ""

#: ../../source/topics/data_types.rst:384
msgid ""
"Inversely, the content of the files stored in the "
":py:class:`~aiida.orm.nodes.data.folder.FolderData` node can be accessed "
"using the "
":py:meth:`~aiida.orm.nodes.repository.NodeRepository.get_object_content()` "
"method:"
msgstr ""

#: ../../source/topics/data_types.rst:391
msgid ""
"To see the files that are stored in the "
":py:class:`~aiida.orm.nodes.data.folder.FolderData`, you can use the "
":py:meth:`~aiida.orm.nodes.repository.NodeRepository.list_object_names()` "
"method:"
msgstr ""

#: ../../source/topics/data_types.rst:398
msgid ""
"In this example, ``subdir`` was a sub directory of "
"``/absolute/path/to/directory``, whose contents where added above. to list "
"the contents of the ``subdir`` directory, you can pass its path to the "
":py:meth:`~aiida.orm.nodes.repository.NodeRepository.list_object_names()` "
"method:"
msgstr ""

#: ../../source/topics/data_types.rst:406
msgid ""
"The content can once again be shown using the "
":py:meth:`~aiida.orm.nodes.repository.NodeRepository.get_object_content()` "
"method by passing the correct path:"
msgstr ""

#: ../../source/topics/data_types.rst:413
msgid ""
"Since the :py:class:`~aiida.orm.nodes.data.folder.FolderData` node is simply"
" a collection of files, it simply stores these files in the repository."
msgstr ""

#: ../../source/topics/data_types.rst:428
msgid ""
"For efficiency reasons, the repository interface only provides access to "
"object content through file-like objects or strings. However, for certain "
"use-cases, the object content _needs_ to be made available as a file on the "
"local file system. For example, the ``numpy.loadtxt`` method only accepts a "
"filepath, and no file-like objects. In this case, the content of the node's "
"repository can be made available on the local file system using the "
":py:meth:`~aiida.orm.nodes.repository.NodeRepository.as_path()` context "
"manager:"
msgstr ""

#: ../../source/topics/data_types.rst:439
msgid ""
"The yielded value ``dirpath`` is an instance of ``pathlib.Path`` that points"
" to a location on the local file system containing the complete content of "
"the repository. The temporary copy on the local file system is automatically"
" cleaned up once the context manager is exited."
msgstr ""

#: ../../source/topics/data_types.rst:447
msgid "Optionally, an explicit object can be specified:"
msgstr ""

#: ../../source/topics/data_types.rst:454
msgid ""
"If the object at ``path`` is a directory, the returned value points to a "
"directory that contains its contents. If it is a file, the returned value "
"points to a file with the content of the object."
msgstr ""

#: ../../source/topics/data_types.rst:459
msgid ""
"The :py:meth:`~aiida.orm.nodes.repository.NodeRepository.as_path()` context "
"manager will copy the content to a temporary folder on the local file "
"system. For large repositories this can be an expensive operation and it is "
"inefficient since it requires an additional read and write operation. "
"Therefore, if it is possible to use file-like objects or read the content "
"into memory, the "
":py:meth:`~aiida.orm.nodes.repository.NodeRepository.get_object_content()` "
"and :py:meth:`~aiida.orm.nodes.repository.NodeRepository.open()` methods "
"should be preferred."
msgstr ""

#: ../../source/topics/data_types.rst:467
msgid "RemoteData"
msgstr ""

#: ../../source/topics/data_types.rst:469
msgid ""
"The :py:class:`~aiida.orm.RemoteData` node represents a \"symbolic link\" to"
" a specific folder on a remote computer. Its main use is to allow users to "
"persist the provenance when e.g. a calculation produces data in a "
"raw/scratch folder, and the whole folder needs to be provided to "
"restart/continue. To create a :py:class:`~aiida.orm.RemoteData` instance, "
"simply pass the remote path to the folder and the computer on which it is "
"stored:"
msgstr ""

#: ../../source/topics/data_types.rst:481
msgid ""
"You can see the contents of the remote folder by using the "
":py:meth:`~aiida.orm.RemoteData.listdir()` method:"
msgstr ""

#: ../../source/topics/data_types.rst:488
msgid ""
"To see the contents of a subdirectory, pass the relative path to the "
":py:meth:`~aiida.orm.RemoteData.listdir()` method:"
msgstr ""

#: ../../source/topics/data_types.rst:497
msgid ""
"Using the :py:meth:`~aiida.orm.RemoteData.listdir()` method, or any method "
"that retrieves information from the remote computer, opens a connection to "
"the remote computer using its transport type. Their use is strongly "
"discouraged when writing scripts and/or workflows."
msgstr ""

#: ../../source/topics/data_types.rst:504
msgid "AbstractCode"
msgstr ""

#: ../../source/topics/data_types.rst:508
msgid ""
"The :class:`aiida.orm.nodes.data.code.abstract.AbstractCode` class provides "
"the abstract class for objects that represent a \"code\" that can be "
"executed through a :class:`aiida.engine.processes.calcjobs.calcjob.CalcJob` "
"plugin. There are currently four implementations of this abstract class:"
msgstr ""

#: ../../source/topics/data_types.rst:511
msgid ""
":class:`~aiida.orm.nodes.data.code.legacy.Code` (see :ref:`Code "
"<topics:data_types:core:code:legacy>`)"
msgstr ""

#: ../../source/topics/data_types.rst:512
msgid ""
":class:`~aiida.orm.nodes.data.code.installed.InstalledCode` (see "
":ref:`InstalledCode <topics:data_types:core:code:installed>`)"
msgstr ""

#: ../../source/topics/data_types.rst:513
msgid ""
":class:`~aiida.orm.nodes.data.code.portable.PortableCode` (see "
":ref:`PortableCode <topics:data_types:core:code:portable>`)"
msgstr ""

#: ../../source/topics/data_types.rst:514
msgid ""
":class:`~aiida.orm.nodes.data.code.containerized.ContainerizedCode` (see "
":ref:`ContainerizedCode <topics:data_types:core:code:containerized>`)"
msgstr ""

#: ../../source/topics/data_types.rst:520
msgid "Code"
msgstr ""

#: ../../source/topics/data_types.rst:524
msgid ""
"Historically, there was only one code implementation, the "
":class:`~aiida.orm.nodes.data.code.legacy.Code`, which implemented two "
"different types of code:"
msgstr ""

#: ../../source/topics/data_types.rst:526
msgid ""
"An executable pre-installed on a computer, represented by a "
":class:`~aiida.orm.computers.Computer`."
msgstr ""

#: ../../source/topics/data_types.rst:527
msgid ""
"A directory containing all code files including an executable which would be"
" uploaded to"
msgstr ""

#: ../../source/topics/data_types.rst:529
msgid ""
"These two types were referred to as \"remote\" and \"local\" codes. However,"
" this nomenclature would lead to confusion as a \"remote\" code could also "
"refer to an executable on the localhost, i.e., the machine where AiiDA "
"itself runs. In addition, having two different concepts implemented by a "
"single class led to a unintuitive interface. Therefore, the ``Code`` class "
"was deprecated in ``aiida-core==2.1`` and replaced by the :ref:`InstallCode "
"<topics:data_types:core:code:installed>` and :ref:`InstallCode "
"<topics:data_types:core:code:installed>`, respectively. The ``Code`` class "
"is now deprecated and will be removed in ``aiida-core==3.0``."
msgstr ""

#: ../../source/topics/data_types.rst:539
msgid "InstalledCode"
msgstr ""

#: ../../source/topics/data_types.rst:543
msgid ""
"The :class:`~aiida.orm.nodes.data.code.installed.InstalledCode` class is an "
"implementation of the "
":class:`~aiida.orm.nodes.data.code.abstract.AbstractCode` class that "
"represents an executable code on a remote computer. This plugin should be "
"used if an executable is pre-installed on a computer. The ``InstalledCode`` "
"represents the code by storing the filepath of the relevant executable and "
"the computer on which it is installed. The computer is represented by an "
"instance of :class:`~aiida.orm.computers.Computer`. Each time a "
":class:`~aiida.engine.CalcJob` is run using an ``InstalledCode``, it will "
"run its executable on the associated computer. Example of creating an "
"``InstalledCode``:"
msgstr ""

#: ../../source/topics/data_types.rst:559
msgid ""
"The ``filepath_executable`` is no longer required to be an absolute path but"
" can be just the executable name."
msgstr ""

#: ../../source/topics/data_types.rst:566
msgid "PortableCode"
msgstr ""

#: ../../source/topics/data_types.rst:570
msgid ""
"The :class:`~aiida.orm.nodes.data.code.portable.PortableCode` class is an "
"implementation of the "
":class:`~aiida.orm.nodes.data.code.abstract.AbstractCode` class that "
"represents an executable code stored in AiiDA's storage. This plugin should "
"be used for executables that are not already installed on the target "
"computer, but instead are available on the machine where AiiDA is running. "
"The plugin assumes that the code is self-contained by a single directory "
"containing all the necessary files, including a main executable. When "
"constructing a ``PortableCode``, passing the absolute filepath as "
"``filepath_files`` will make sure that all the files contained within are "
"uploaded to AiiDA's storage. The ``filepath_executable`` should indicate the"
" filename of the executable within that directory. Each time a "
":class:`~aiida.engine.CalcJob` is run using a ``PortableCode``, the uploaded"
" files will be automatically copied to the working directory on the selected"
" computer and the executable will be run there. Example of creating an "
"``PortableCode``:"
msgstr ""

#: ../../source/topics/data_types.rst:591
msgid "ContainerizedCode"
msgstr ""

#: ../../source/topics/data_types.rst:595
msgid ""
"The :class:`~aiida.orm.nodes.data.code.containerized.ContainerizedCode` "
"class allows running an executable within a container image on a target "
"computer. The data plugin stores the following information in the database:"
msgstr ""

#: ../../source/topics/data_types.rst:598
msgid ""
"``image_name``: The name of the container image (e.g., a URI like "
"``docker://alpine:3`` or an absolute file path like ``/path/to/image.sif``)."
msgstr ""

#: ../../source/topics/data_types.rst:599
msgid ""
"``filepath_executable``: The filepath of the executable within the container"
" (e.g. ``/usr/bin/bash``)."
msgstr ""

#: ../../source/topics/data_types.rst:600
msgid ""
"``engine_command``: The bash command to invoke the container image (e.g. "
"``singularity exec --bind $PWD:$PWD {image_name}``). The exact form of this "
"command will depend on the containerization technology that is used."
msgstr ""

#: ../../source/topics/data_types.rst:602
msgid ""
"``computer``: The :class:`~aiida.orm.computers.Computer` on which to run the"
" container."
msgstr ""

#: ../../source/topics/data_types.rst:606
msgid ""
"If the container image is not yet present on the target computer, most "
"container engines will pull the image from the registry at first use. This "
"can take a while if the image is large."
msgstr ""

#: ../../source/topics/data_types.rst:611
msgid ""
"If the ``engine_command`` contains variables (such as in the ``singularity "
"exec --bind $PWD:$PWD {image_name}`` example), it is crucial that the "
"``Computer`` needs to have the ``use_double_quotes`` setting set to "
"``True``. By default, a ``Computer`` will use single quotes to escape "
"command line arguments and so the ``$PWD`` would not be expanded. If this "
"wasn't defined as such when the ``Computer`` was created, it can be changed "
"through the API:"
msgstr ""

#: ../../source/topics/data_types.rst:624
msgid "Setup"
msgstr ""

#: ../../source/topics/data_types.rst:626
msgid ""
"A ``ContainerizedCode`` can be created through the CLI as well as the API. "
"The following examples show how to setup running ``bash`` in a base Docker "
"container through Singularity to be run on the ``Computer`` named ``some-"
"computer``:"
msgstr ""

#: ../../source/topics/data_types.rst:0
msgid "CLI"
msgstr ""

#: ../../source/topics/data_types.rst:0
msgid "API"
msgstr ""

#: ../../source/topics/data_types.rst:657
msgid ""
"Please refer to the section on :ref:`supported container technologies "
"<topics:data_types:core:code:installed:containerized:support>` for an "
"overview and specific setup instructions for each containerization solution."
msgstr ""

#: ../../source/topics/data_types.rst:662
msgid "Run"
msgstr ""

#: ../../source/topics/data_types.rst:664
msgid ""
"A ``ContainerizedCode`` is used to launch a calculation just like any other "
"code. If a default calculation job plugin is defined, a process builder can "
"be obtained with ``get_builder``:"
msgstr ""

#: ../../source/topics/data_types.rst:679
msgid ""
"If a containerized code is used for a calculation that enables MPI (see "
":ref:`Controlling MPI <topics:calculations:usage:calcjobs:mpi>`), the MPI "
"command line arguments are placed in front of the container runtime. For "
"example, when running Singularity with MPI enabled, the runline in the "
"submission script will be written as:"
msgstr ""

#: ../../source/topics/data_types.rst:686
msgid ""
"This means that the containerization program is launched as a normal MPI "
"program, and so it needs to support forwarding the execution context to the "
"container application. It is currently not possible to have MPI invoked "
"inside the container runtime."
msgstr ""

#: ../../source/topics/data_types.rst:693
msgid "Supported container technologies"
msgstr ""

#: ../../source/topics/data_types.rst:695
msgid ""
"The ``ContainerizedCode`` is compatible with a variety of containerization "
"technologies:"
msgstr ""

#: ../../source/topics/data_types.rst:0
msgid "Docker"
msgstr ""

#: ../../source/topics/data_types.rst:701
msgid ""
"To use `Docker <https://www.docker.com/>`_ ``aiida-core==2.3.0`` or higher "
"is required in order to be able to set ``wrap_cmdline_params = True``. When "
"setting up a code for a Docker container, use the following "
"``engine_command`` when setting up the code:"
msgstr ""

#: ../../source/topics/data_types.rst:708
msgid ""
"Currently running with MPI is not yet supported, as it needs to be called "
"inside of the container which is currently not possible. The associated "
"computer should also be configured to have the setting ``use_double_quotes ="
" False``. This can be set from the Python API using "
"``load_computer('idenfitier').set_use_double_quotes(False)``."
msgstr ""

#: ../../source/topics/data_types.rst:712
msgid ""
"The following configuration provides an example to setup Quantum ESPRESSO's "
"``pw.x`` to be run by Docker on the local host"
msgstr ""

#: ../../source/topics/data_types.rst:725
msgid ""
"Save the configuration to ``code.yml`` and create the code using the "
"``verdi`` CLI:"
msgstr ""

#: ../../source/topics/data_types.rst:0
msgid "Singularity"
msgstr ""

#: ../../source/topics/data_types.rst:733
msgid ""
"To use `Singularity <https://singularity-docs.readthedocs.io/en/latest/>`_ "
"use the following ``engine_command`` when setting up the code:"
msgstr ""

#: ../../source/topics/data_types.rst:0
msgid "Sarus"
msgstr ""

#: ../../source/topics/data_types.rst:741
msgid ""
"To use `Sarus <https://sarus.readthedocs.io/en/stable/>`_ use the following "
"``engine_command`` when setting up the code:"
msgstr ""

#: ../../source/topics/data_types.rst:750
msgid "Materials science data types"
msgstr ""

#: ../../source/topics/data_types.rst:752
msgid ""
"Since AiiDA was first developed within the computational materials science "
"community, `aiida-core` still contains several data types specific to this "
"field. This sections lists these data types and provides some important "
"examples of their usage."
msgstr ""

#: ../../source/topics/data_types.rst:761
msgid ":ref:`StructureData <topics:data_types:materials:structure>`"
msgstr ""

#: ../../source/topics/data_types.rst:761
msgid "``structure``"
msgstr ""

#: ../../source/topics/data_types.rst:761
msgid ""
"The cell, periodic boundary conditions, atomic positions, species and kinds."
msgstr ""

#: ../../source/topics/data_types.rst:761
#: ../../source/topics/data_types.rst:767
msgid "\\\\-"
msgstr ""

#: ../../source/topics/data_types.rst:763
msgid ":ref:`TrajectoryData <topics:data_types:materials:trajectory>`"
msgstr ""

#: ../../source/topics/data_types.rst:763
msgid "``array.trajectory``"
msgstr ""

#: ../../source/topics/data_types.rst:763
msgid ""
"The structure species and the shape of the cell, step and position arrays."
msgstr ""

#: ../../source/topics/data_types.rst:763
#: ../../source/topics/data_types.rst:769
#: ../../source/topics/data_types.rst:771
msgid "The array data in numpy format."
msgstr ""

#: ../../source/topics/data_types.rst:765
msgid ":ref:`UpfData <topics:data_types:materials:upf>`"
msgstr ""

#: ../../source/topics/data_types.rst:765
msgid "``upf``"
msgstr ""

#: ../../source/topics/data_types.rst:765
msgid "The MD5 of the UPF and the element of the pseudopotential."
msgstr ""

#: ../../source/topics/data_types.rst:765
msgid "The pseudopotential file."
msgstr ""

#: ../../source/topics/data_types.rst:767
msgid ":ref:`KpointsData <topics:data_types:materials:kpoints>`"
msgstr ""

#: ../../source/topics/data_types.rst:767
msgid "``array.kpoints``"
msgstr ""

#: ../../source/topics/data_types.rst:767
msgid "(as mesh) The mesh and offset."
msgstr ""

#: ../../source/topics/data_types.rst:769
msgid "(as list) The \"kpoints\" array shape, labels and their indices."
msgstr ""

#: ../../source/topics/data_types.rst:771
msgid ":ref:`BandsData <topics:data_types:materials:bands>`"
msgstr ""

#: ../../source/topics/data_types.rst:771
msgid "``array.bands``"
msgstr ""

#: ../../source/topics/data_types.rst:771
msgid ""
"The units, labels and their numbers, and shape of the bands and kpoints "
"arrays."
msgstr ""

#: ../../source/topics/data_types.rst:777
msgid "StructureData"
msgstr ""

#: ../../source/topics/data_types.rst:779
msgid ""
"The :py:class:`~aiida.orm.nodes.data.structure.StructureData` data type "
"represents a structure, i.e. a collection of sites defined in a cell. The "
"boundary conditions are periodic by default, but can be set to non-periodic "
"in any direction."
msgstr ""

#: ../../source/topics/data_types.rst:782
msgid ""
"As an example, say you want to create a "
":py:class:`~aiida.orm.nodes.data.structure.StructureData` instance for bcc "
"Li. Let's begin with creating the instance by defining its unit cell:"
msgstr ""

#: ../../source/topics/data_types.rst:795
msgid ""
"Default units for crystal structure cell and atomic coordinates in AiiDA are"
" Å (Ångström)."
msgstr ""

#: ../../source/topics/data_types.rst:797
msgid ""
"Next, you can add the Li atoms to the structure using the "
":py:class:`~aiida.orm.nodes.data.structure.StructureData.append_atom()` "
"method:"
msgstr ""

#: ../../source/topics/data_types.rst:805
msgid ""
"You can check if the cell and sites have been set up properly by checking "
"the ``cell`` and ``sites`` properties:"
msgstr ""

#: ../../source/topics/data_types.rst:815
msgid ""
"From the :py:class:`~aiida.orm.nodes.data.structure.StructureData` node you "
"can also obtain the formats of well-known materials science Python libraries"
" such as `the Atomic Simulation Environment "
"<https://wiki.fysik.dtu.dk/ase/index.html>`_ (ASE) and `pymatgen "
"<https://pymatgen.org/index.html>`_:"
msgstr ""

#: ../../source/topics/data_types.rst:835
msgid ""
":ref:`topics:data_types:core:jsonable`, which can store any other Pymatgen "
"class."
msgstr ""

#: ../../source/topics/data_types.rst:0 ../../source/topics/data_types.rst:838
#: ../../source/topics/data_types.rst:873
msgid "Exporting"
msgstr ""

#: ../../source/topics/data_types.rst:840
msgid ""
"The following export formats are available for "
":py:class:`~aiida.orm.nodes.data.structure.StructureData`:"
msgstr ""

#: ../../source/topics/data_types.rst:842
#: ../../source/topics/data_types.rst:879
msgid ""
"``xsf`` (format supported by e.g. XCrySDen and other visualization software;"
" supports periodic cells)"
msgstr ""

#: ../../source/topics/data_types.rst:843
msgid ""
"``xyz`` (classical xyz format, does not typically support periodic cells "
"(even if the cell is indicated in the comment line)"
msgstr ""

#: ../../source/topics/data_types.rst:844
msgid ""
"``cif`` (export to CIF format, without symmetry reduction, i.e. always "
"storing the structure as P1 symmetry)"
msgstr ""

#: ../../source/topics/data_types.rst:846
msgid "The node can be exported using the verdi CLI, for example:"
msgstr ""

#: ../../source/topics/data_types.rst:852
msgid ""
"Where ``<IDENTIFIER>`` is one of the possible identifiers of the node, e.g. "
"its PK or UUID. This outputs the structure in ``xsf`` format and writes it "
"to a file."
msgstr ""

#: ../../source/topics/data_types.rst:858
msgid "TrajectoryData"
msgstr ""

#: ../../source/topics/data_types.rst:860
msgid ""
"The :py:class:`~aiida.orm.nodes.data.array.trajectory.TrajectoryData` data "
"type represents a sequences of StructureData objects, where the number of "
"atomic kinds and sites does not change over time. Beside the coordinates, it"
" can also optionally store velocities. If you have a list of "
":py:class:`~aiida.orm.nodes.data.structure.StructureData` instances called "
"``structure_list`` that represent the trajectory of your system, you can "
"create a :py:class:`~aiida.orm.nodes.data.array.trajectory.TrajectoryData` "
"instance from this list:"
msgstr ""

#: ../../source/topics/data_types.rst:870
msgid ""
"Note that contrary with the "
":py:class:`~aiida.orm.nodes.data.structure.StructureData` data type, the "
"cell and atomic positions are stored a ``numpy`` array in the repository and"
" not in the database."
msgstr ""

#: ../../source/topics/data_types.rst:875
msgid ""
"You can export the "
"py:class:`~aiida.orm.nodes.data.array.trajectory.TrajectoryData` node with "
"``verdi data core.trajectory export``, which accepts a number of formats "
"including ``xsf`` and  ``cif``, and additional parameters like ``--step "
"NUM`` (to choose to export only a given trajectory step)."
msgstr ""

#: ../../source/topics/data_types.rst:877
#: ../../source/topics/data_types.rst:1135
msgid "The following export formats are available:"
msgstr ""

#: ../../source/topics/data_types.rst:881
msgid ""
"``cif`` (export to CIF format, without symmetry reduction, i.e. always "
"storing the structures as P1 symmetry)"
msgstr ""

#: ../../source/topics/data_types.rst:884
#: ../../source/topics/data_types.rst:1177 ../../source/topics/database.rst:7
msgid "Todo"
msgstr ""

#: ../../source/topics/data_types.rst:886
msgid "Think of more example use cases, see `#4529`_."
msgstr ""

#: ../../source/topics/data_types.rst:893
msgid "UpfData"
msgstr ""

#: ../../source/topics/data_types.rst:895
msgid ""
"The :py:class:`~aiida.orm.nodes.data.upf.UpfData` data type represents a "
"pseudopotential in the .UPF format (e.g. used by `Quantum ESPRESSO`_ - see "
"also the `AiiDA Quantum ESPRESSO plugin`_). Usually these will be installed "
"as part of a pseudopotential family, for example via the `aiida-pseudo "
"<https://github.com/aiidateam/aiida-pseudo>`_ package."
msgstr ""

#: ../../source/topics/data_types.rst:898
msgid ""
"To see the pseudopotential families that have been installed in your AiiDA "
"profile, you can use the verdi CLI:"
msgstr ""

#: ../../source/topics/data_types.rst:912
msgid "KpointsData"
msgstr ""

#: ../../source/topics/data_types.rst:914
msgid ""
"The :py:class:`~aiida.orm.nodes.data.array.kpoints.KpointsData` data type "
"represents either a grid of k-points (in reciprocal space, for crystal "
"structures), or explicit list of k-points (optionally with a weight "
"associated to each one)."
msgstr ""

#: ../../source/topics/data_types.rst:916
msgid ""
"To create a :py:class:`~aiida.orm.nodes.data.array.kpoints.KpointsData` "
"instance that describes a regular (2 x 2 x 2) mesh of k-points, execute the "
"following set of commands in the ``verdi shell``:"
msgstr ""

#: ../../source/topics/data_types.rst:924
msgid ""
"This will create a (2 x 2 x 2) mesh centered at the Gamma point (i.e. "
"without offset)."
msgstr ""

#: ../../source/topics/data_types.rst:926
msgid ""
"Alternatively, you can also define a "
":py:class:`~aiida.orm.nodes.data.array.kpoints.KpointsData` node from a list"
" of k-points using the "
":py:meth:`~aiida.orm.nodes.data.array.kpoints.KpointsData.set_kpoints()` "
"method:"
msgstr ""

#: ../../source/topics/data_types.rst:933
msgid ""
"In this case, you can also associate labels to (some of the) points, which "
"is very useful for generating plots of the band structure (and storing them "
"in a :py:class:`~aiida.orm.nodes.data.array.bands.BandsData` instance):"
msgstr ""

#: ../../source/topics/data_types.rst:945
msgid "Automatic computation of k-point paths"
msgstr ""

#: ../../source/topics/data_types.rst:947
msgid ""
"AiiDA provides a number of tools and wrappers to automatically compute "
"k-point paths given a cell or a crystal structure."
msgstr ""

#: ../../source/topics/data_types.rst:949
msgid ""
"The main interface is provided by the two methods "
":py:func:`aiida.tools.data.array.kpoints.main.get_kpoints_path` and "
":py:func:`aiida.tools.data.array.kpoints.main.get_explicit_kpoints_path`."
msgstr ""

#: ../../source/topics/data_types.rst:951
msgid ""
"These methods are also conveniently exported directly as, e.g., "
"``aiida.tools.get_kpoints_path``."
msgstr ""

#: ../../source/topics/data_types.rst:953
msgid "The difference between the two methods is the following:"
msgstr ""

#: ../../source/topics/data_types.rst:955
msgid ""
":py:func:`~aiida.tools.data.array.kpoints.main.get_kpoints_path` returns a "
"dictionary of k-point coordinates (e.g. ``{'GAMMA': [0. ,0. ,0. ], 'X': "
"[0.5, 0., 0.], 'L': [0.5, 0.5, 0.5]}``, and then a list of tuples of "
"endpoints of each segment, e.g. ``[('GAMMA', 'X'), ('X', 'L'), ('L', "
"'GAMMA')]`` for the :math:`\\Gamma-X-L-\\Gamma` path."
msgstr ""

#: ../../source/topics/data_types.rst:956
msgid ""
":py:func:`~aiida.tools.data.array.kpoints.main.get_explicit_kpoints_path`, "
"instead, returns a list of kpoints that follow that path, with some "
"predefined (but user-customizable) distance between points, e.g. something "
"like ``[[0., 0., 0.], [0.05, 0., 0.], [0.1, 0., 0.], ...]``."
msgstr ""

#: ../../source/topics/data_types.rst:958
msgid ""
"Depending on how the underlying code works, one method might be preferred on"
" the other."
msgstr ""

#: ../../source/topics/data_types.rst:960
msgid ""
"The docstrings of the methods describe the expected parameters. The general "
"interface requires always a ``StructureData`` as the first parameter "
"``structure``, as well as a string for the method to use (by default this is"
" `seekpath <https://github.com/giovannipizzi/seekpath/>`_, but also the "
"``legacy`` method implemented in earlier versions of AiiDA is available; see"
" description below)."
msgstr ""

#: ../../source/topics/data_types.rst:963
msgid ""
"Additional parameters are passed as ``kwargs`` to the underlying "
"implementation, that often accepts a different number of parameters."
msgstr ""

#: ../../source/topics/data_types.rst:968
msgid "Seekpath implementation"
msgstr ""

#: ../../source/topics/data_types.rst:970
msgid ""
"When specifying ``method='seekpath'``, the `seekpath "
"<https://github.com/giovannipizzi/seekpath/>`_ library is used to generate "
"the path. Note that this requires  ``seekpath`` to be installed (this is not"
" available by default, in order to reduce the dependencies of AiiDA core, "
"but can be easily installed using ``pip install seekpath``)."
msgstr ""

#: ../../source/topics/data_types.rst:973
msgid ""
"For a full description of the accepted parameters, we refer to the docstring"
" of the underlying methods "
":py:func:`aiida.tools.data.array.kpoints.seekpath.get_explicit_kpoints_path`"
" and :py:func:`aiida.tools.data.array.kpoints.seekpath.get_kpoints_path`, "
"and for more general information to the `seekpath documentation "
"<https://seekpath.readthedocs.io/>`_."
msgstr ""

#: ../../source/topics/data_types.rst:975
msgid ""
"If you use this implementation, please cite the `Hinuma paper "
"<https://doi.org/10.1016/j.commatsci.2016.10.015>`_::"
msgstr ""

#: ../../source/topics/data_types.rst:0
msgid "Legacy implementation"
msgstr ""

#: ../../source/topics/data_types.rst:984
msgid ""
"This refers to the implementation that has been available since the early "
"versions of AiiDA."
msgstr ""

#: ../../source/topics/data_types.rst:986
msgid ""
"In the 3D case (all three directions have periodic boundary conditions), "
"this implementation expects that the structure is already standardized "
"according to the Setyawan paper (see journal reference below). If this is "
"not the case, the kpoints and band structure returned will be incorrect. The"
" only case that is dealt correctly by the library is the case when axes are "
"swapped, where the library correctly takes this swapping/rotation into "
"account to assign kpoint labels and coordinates."
msgstr ""

#: ../../source/topics/data_types.rst:990
msgid ""
"We therefore suggest that you use the seekpath implementation, that is able "
"to automatically correctly identify the standardized crystal structure "
"(primitive and conventional) as described in the `Hinuma paper "
"<https://doi.org/10.1016/j.commatsci.2016.10.015>`_."
msgstr ""

#: ../../source/topics/data_types.rst:992
msgid ""
"For a full description of the accepted parameters, we refer to the docstring"
" of the underlying methods "
":py:func:`aiida.tools.data.array.kpoints.legacy.get_explicit_kpoints_path` "
"and :py:func:`aiida.tools.data.array.kpoints.legacy.get_kpoints_path`, and "
"for more general information to the `seekpath documentation "
"<https://seekpath.readthedocs.io/>`_."
msgstr ""

#: ../../source/topics/data_types.rst:994
msgid ""
"If you use this implementation, please cite the correct reference from the "
"following ones:"
msgstr ""

#: ../../source/topics/data_types.rst:996
msgid ""
"The 3D implementation is based on the `Setyawan paper "
"<https://doi.org/10.1016/j.commatsci.2010.05.010>`_::"
msgstr ""

#: ../../source/topics/data_types.rst:1003
msgid ""
"The 2D implementation is based on the `Ramirez paper "
"<https://doi.org/10.1002/qua.560300306>`_::"
msgstr ""

#: ../../source/topics/data_types.rst:1013
msgid "BandsData"
msgstr ""

#: ../../source/topics/data_types.rst:1015
msgid ""
"The :py:class:`~aiida.orm.nodes.data.array.bands.BandsData` data type is "
"dedicated to store band structures of different types (electronic bands, "
"phonons, or any other band-structure-like quantity that is a function of the"
" k-points in the Brillouin zone). In this section we describe the usage of "
"the ``BandsData`` to store the  electronic band structure of silicon and "
"some logic behind its methods. The dropdown panels below explain some "
"expanded use cases on how to create a "
":py:class:`~aiida.orm.nodes.data.array.bands.BandsData` node and plot the "
"band structure."
msgstr ""

#: ../../source/topics/data_types.rst:0
msgid "Creating a ``BandsData`` instance manually"
msgstr ""

#: ../../source/topics/data_types.rst:1021
msgid ""
"To start working with the "
":py:class:`~aiida.orm.nodes.data.array.bands.BandsData` data type we should "
"import it using the ``DataFactory`` and create an object of type "
"``BandsData``:"
msgstr ""

#: ../../source/topics/data_types.rst:1029
msgid ""
"To import the bands we need to make sure to have two arrays: one containing "
"kpoints and another containing bands. The shape of the kpoints object should"
" be ``nkpoints * 3``, while the shape of the bands should be ``nkpoints * "
"nstates``. Let's assume the number of kpoints is 12, and the number of "
"states is 5. So the kpoints and the bands array will look as follows:"
msgstr ""

#: ../../source/topics/data_types.rst:1065
msgid ""
"To insert kpoints and bands in the ``bands_data`` object we should employ "
"``set_kpoints()`` and ``set_bands()`` methods:"
msgstr ""

#: ../../source/topics/data_types.rst:0
msgid "Plotting the band structure"
msgstr ""

#: ../../source/topics/data_types.rst:1074
msgid ""
"Next we want to visualize the band structure. Before doing so, one thing "
"that we may want to add is the array of kpoint labels:"
msgstr ""

#: ../../source/topics/data_types.rst:1087
msgid "The resulting band structure will look as follows"
msgstr ""

#: ../../source/topics/data_types.rst:1093
msgid ""
"As with any AiiDA node, once the ``bands_data`` object is stored "
"(``bands_data.store()``) it won't accept any modifications."
msgstr ""

#: ../../source/topics/data_types.rst:1095
msgid ""
"You may notice that depending on how you assign the kpoints labels the "
"output of the ``show_mpl()`` method looks different. Please compare:"
msgstr ""

#: ../../source/topics/data_types.rst:1112
msgid ""
"In the first case two neighboring kpoints with ``X`` and ``Y`` labels will "
"look like ``X|Y``, while in the second case they will be separated by a "
"certain distance. The logic behind such a difference is the following. In "
"the first case the plotting method discovers the two neighboring kpoints and"
" assumes them to be a discontinuity point in the band structure (e.g. "
"Gamma-X|Y-U). In the second case the kpoints labelled ``X`` and ``Y`` are "
"not neighbors anymore, so they are plotted with a certain distance between "
"them. The intervals between the kpoints on the X axis are proportional to "
"the cartesian distance between them."
msgstr ""

#: ../../source/topics/data_types.rst:0
msgid "Dealing with spins"
msgstr ""

#: ../../source/topics/data_types.rst:1120
msgid ""
"The ``BandsData`` object can also deal with the results of spin-polarized "
"calculations. Two provide different bands for two different spins you should"
" just merge them in one array and import them again using the "
"``set_bands()`` method:"
msgstr ""

#: ../../source/topics/data_types.rst:1129
msgid ""
"Now the shape of the bands array becomes ``nspins * nkpoints * nstates``"
msgstr ""

#: ../../source/topics/data_types.rst:1133
msgid ""
"The :py:class:`~aiida.orm.nodes.data.array.bands.BandsData` data type can be"
" exported with ``verdi data core.bands export``, which accepts a number of "
"formats including (see also below) and additional parameters like "
"``--prettify-format FORMATNAME``, see valid formats below, or ``--y-min-"
"lim``, ``--y-max-lim`` to specify the ``y``-axis limits."
msgstr ""

#: ../../source/topics/data_types.rst:1137
msgid "``agr``: export a Xmgrace .agr file with the band plot"
msgstr ""

#: ../../source/topics/data_types.rst:1138
msgid ""
"``agr_batch``: export a Xmgrace batch file together with an independent .dat"
" file"
msgstr ""

#: ../../source/topics/data_types.rst:1139
msgid ""
"``dat_blocks``: export a .dat file, where each line has a data point (xy) "
"and bands are separated in blocks with empty lines."
msgstr ""

#: ../../source/topics/data_types.rst:1140
msgid ""
"``dat_multicolumn``: export a .dat file, where each line has all the values "
"for a given x coordinate: ``x y1 y2 y3 y4 ...`` (``x`` being a linear "
"coordinate along the band path and ``yN`` being the band energies)."
msgstr ""

#: ../../source/topics/data_types.rst:1141
msgid "``gnuplot``: export a gnuplot file, together with a .dat file."
msgstr ""

#: ../../source/topics/data_types.rst:1142
msgid "``json``: export a json file with the bands divided into segments."
msgstr ""

#: ../../source/topics/data_types.rst:1143
msgid ""
"``mpl_singlefile``: export a python file that when executed shows a plot "
"using the ``matplotlib`` module. All data is included in the same python "
"file as a multiline string containing the data in json format."
msgstr ""

#: ../../source/topics/data_types.rst:1145
msgid ""
"``mpl_withjson``: As above, but the json data is stored separately in a "
"different file."
msgstr ""

#: ../../source/topics/data_types.rst:1146
msgid ""
"``mpl_pdf``: As above, but after creating the .py file it runs it to export "
"the band structure in a PDF file (vectorial). **NOTE**: it requires that you"
" have the python ``matplotlib`` module installed. If ``use_latex`` is true, "
"it requires that you have LaTeX installed on your system to typeset the "
"labels, as well as the ``dvipng`` binary."
msgstr ""

#: ../../source/topics/data_types.rst:1149
msgid ""
"``mpl_png``: As above, but after creating the .py file it runs it to export "
"the band structure in a PDF file (vectorial). **NOTE**: this format has the "
"same dependencies as the ``mpl_pdf`` format above."
msgstr ""

#: ../../source/topics/data_types.rst:1152
msgid ""
"AiiDA provides a number of functions to \"prettify\" the labels of band "
"structures (if labels are present in the data node), i.e., replace ``GAMMA``"
" with :math:`\\Gamma` or ``K_1`` with :math:`K_{1}` for instance. This makes"
" sense for some output formats (e.g. Xmgrace, Gnuplot, matplotlib)."
msgstr ""

#: ../../source/topics/data_types.rst:1155
msgid ""
"The prettifier functions are defined as methods of the "
":py:class:`~aiida.common.utils.Prettifier` class and can be obtained calling"
" "
":py:meth:`Prettifier.get_prettifiers()<aiida.common.utils.Prettifier.get_prettifiers>`."
msgstr ""

#: ../../source/topics/data_types.rst:1157
msgid "The prettifiers should be chosen depending on two aspects:"
msgstr ""

#: ../../source/topics/data_types.rst:1159
msgid ""
"How the raw labels are stored in the database. Two types exist currently: "
"``seekpath``, as used in the ``seekpath`` module, where Greek letters are "
"written explicitly (e.g. ``GAMMA``) and underscores are used to indicate a "
"subscript (``K_1``); and the \"old\" ``simple`` format, where "
":math:`\\Gamma` is indicated with ``G`` and there is no underscore symbol)."
msgstr ""

#: ../../source/topics/data_types.rst:1162
msgid ""
"Depending on the output format: xmgrace has a specific syntax for Greek "
"letters and subscripts, matplotlib uses LaTeX syntax, etc."
msgstr ""

#: ../../source/topics/data_types.rst:1164
msgid ""
"Most export formats already decide which prettifier is best to use, but if "
"you need to change it, you can do it passing the ``prettify_format`` "
"parameter to the :py:meth:`~aiida.orm.nodes.data.data.Data.export()` method."
" Valid prettifiers include:"
msgstr ""

#: ../../source/topics/data_types.rst:1169
msgid ""
"``agr_seekpath``: format for Xmgrace, using ``seekpath`` raw label syntax."
msgstr ""

#: ../../source/topics/data_types.rst:1170
msgid "``agr_simple``: format for Xmgrace, using ``simple`` raw label syntax."
msgstr ""

#: ../../source/topics/data_types.rst:1171
msgid ""
"``latex_simple``: format for LaTeX (including dollar signs), using "
"``seekpath`` raw label syntax."
msgstr ""

#: ../../source/topics/data_types.rst:1172
msgid ""
"``latex_seekpath``: format for LaTeX (including dollar signs), using "
"``simple`` raw label syntax."
msgstr ""

#: ../../source/topics/data_types.rst:1173
msgid ""
"``gnuplot_simple``: format for GNUPlot (Unicode for Greek letters, LaTeX "
"syntax `without` dollar signs for underscores), using ``seekpath`` raw label"
" syntax."
msgstr ""

#: ../../source/topics/data_types.rst:1174
msgid ""
"``gnuplot_seekpath``: format for GNUPlot (Unicode for Greek letters, LaTeX "
"syntax `without` dollar signs for underscores), using ``simple`` raw label "
"syntax."
msgstr ""

#: ../../source/topics/data_types.rst:1175
msgid ""
"``pass``: no-op prettifier: leaves all strings unchanged to their raw value."
msgstr ""

#: ../../source/topics/data_types.rst:1181
msgid "title: CifData"
msgstr ""

#: ../../source/topics/data_types.rst:1185
msgid "title: OrbitalData"
msgstr ""

#: ../../source/topics/data_types.rst:1189
msgid "title: ProjectionData"
msgstr ""

#: ../../source/topics/data_types.rst:1194
msgid "Exporting data nodes"
msgstr ""

#: ../../source/topics/data_types.rst:1196
msgid ""
"Next to the CLI commands described above, each data node has a "
":py:meth:`~aiida.orm.nodes.data.data.Data.export()` method that allows to "
"export the given data node to file in a variety of available formats, e.g. "
"to pass it to a visualization software."
msgstr ""

#: ../../source/topics/data_types.rst:1198
msgid ""
"The :py:meth:`~aiida.orm.nodes.data.data.Data.export()` method asks for a "
"filename, and it will write to file the result. It is possible that more "
"than one file is written (for example, if you produce a gnuplot script, the "
"data will typically be in a different .dat file). The return value of the "
"function is a list of files that have been created."
msgstr ""

#: ../../source/topics/data_types.rst:1202
msgid ""
"The list of export formats depends on the specific Data plugin. The export "
"format is typically inferred from the file extension, but if this is not "
"possible (or you want to specify a given format), you can pass an additional"
" ``fileformat`` parameter to "
":py:meth:`~aiida.orm.nodes.data.data.Data.export()`. The list of all valid "
"export formats can be obtained calling ``Data.get_export_formats()`` method,"
" that returns a list of strings with all valid formats."
msgstr ""

#: ../../source/topics/data_types.rst:1206
msgid ""
"If you don't want to export directly to a file, but want to get simply the "
"content of the file as a string, then you can call the "
":py:meth:`~aiida.orm.nodes.data.data.Data._exportcontent()` method, passing "
"also a ``fileformat`` parameter. The return value is a tuple of length 2: "
"the first element is a string with the content of the \"main\" file, while "
"the second is a dictionary (possibly empty) with a list of additional files "
"that should be created/needed: the keys are filenames, and the values are "
"the files content."
msgstr ""

#: ../../source/topics/data_types.rst:1212
msgid "Adding support for custom data types"
msgstr ""

#: ../../source/topics/data_types.rst:1214
msgid ""
"The nodes in the :ref:`provenance graph<topics:provenance>` that are the "
"inputs and outputs of processes are referred to as `data` and are "
"represented by :class:`~aiida.orm.nodes.data.data.Data` nodes. Since data "
"can come in all shapes and forms, the "
":class:`~aiida.orm.nodes.data.data.Data` class can be sub classed. AiiDA "
"ships with some basic data types such as the "
":class:`~aiida.orm.nodes.data.int.Int` which represents a simple integer and"
" the :class:`~aiida.orm.nodes.data.dict.Dict`, representing a dictionary of "
"key-value pairs. There are also more complex data types such as the "
":class:`~aiida.orm.nodes.data.array.array.ArrayData` which can store "
"multidimensional arrays of numbers. These basic data types serve most needs "
"for the majority of applications, but more specific solutions may be useful "
"or even necessary. In the next sections, we will explain :ref:`how a new "
"data type can be created<topics:data_types:plugin:create>` and what "
":ref:`guidelines<topics:data_types:plugin:design-guidelines>` should ideally"
" be observed during the design process."
msgstr ""

#: ../../source/topics/data_types.rst:1224
msgid "Creating a data plugin"
msgstr ""

#: ../../source/topics/data_types.rst:1226
msgid ""
"Creating a new data type is as simple as creating a new sub class of the "
"base :class:`~aiida.orm.nodes.data.data.Data` class."
msgstr ""

#: ../../source/topics/data_types.rst:1237
msgid ""
"To be able to use the new ``Data`` plugin, it must be registered using an "
"entry point. See :ref:`What is an entry point?<topics:plugins:entrypoints>` "
"for details."
msgstr ""

#: ../../source/topics/data_types.rst:1240
msgid ""
"At this point, our new data type does nothing special. Typically, one "
"creates a new data type to represent a specific type of data. For the "
"purposes of this example, let's assume that the goal of our ``NewData`` type"
" is to store a single numerical value. To allow one to construct a new "
"``NewData`` data node with the desired ``value``, for example:"
msgstr ""

#: ../../source/topics/data_types.rst:1249
msgid ""
"we need to allow passing that value to the constructor of the node class. "
"Therefore, we have to override the constructor "
":meth:`~aiida.orm.nodes.node.Node.__init__`:"
msgstr ""

#: ../../source/topics/data_types.rst:1266
msgid ""
"For the class to function properly, the signature of the constructor "
"**cannot be changed** and the constructor of the parent class **has to be "
"called**. Note also that the constructor is **NOT** called when the node is "
"loaded from the database afterwards. Hence, one should not rely on "
"initializing instance attributes inside the ``__init__`` itself (here "
"\"attributes\" does not refer to the data stored in the database, but the "
"normal Python understanding of attributes that class instances have)."
msgstr ""

#: ../../source/topics/data_types.rst:1270
msgid ""
"Before calling the constructor of the base class, we have to remove the "
"``value`` keyword from the keyword arguments ``kwargs``, because the base "
"class will not expect it and will raise an exception if left in the keyword "
"arguments. The final step is to actually *store* the value that is passed by"
" the caller of the constructor. A new node has two locations to permanently "
"store any of its properties:"
msgstr ""

#: ../../source/topics/data_types.rst:1274
msgid "the database"
msgstr ""

#: ../../source/topics/data_types.rst:1275
msgid "the file repository"
msgstr ""

#: ../../source/topics/data_types.rst:1277
msgid ""
"The section on :ref:`design guidelines<topics:data_types:plugin:design-"
"guidelines>` will go into more detail what the advantages and disadvantages "
"of each option are and when to use which. For now, since we are storing only"
" a single value, the easiest and best option is to use the database. Each "
"node has *attributes* that can store any key-value pair, as long as the "
"value is JSON serializable. By adding the value to the node's attributes, "
"they will be queryable in the database once an instance of the ``NewData`` "
"node is stored."
msgstr ""

#: ../../source/topics/data_types.rst:1288
msgid ""
"After storing the node instance in the database, its attributes are frozen, "
"and ``node.base.attributes.set('value', 7)`` will fail. By storing the "
"``value`` in the attributes of the node instance, we ensure that that "
"``value`` can be retrieved even when the node is reloaded at a later point "
"in time."
msgstr ""

#: ../../source/topics/data_types.rst:1291
msgid ""
"Besides making sure that the content of a data node is stored in the "
"database or file repository, the data type class can also provide useful "
"methods for users to retrieve that data. For example, with the current state"
" of the ``NewData`` class, in order to retrieve the ``value`` of a stored "
"``NewData`` node, one needs to do:"
msgstr ""

#: ../../source/topics/data_types.rst:1299
msgid ""
"In other words, the user of the ``NewData`` class needs to know that the "
"``value`` is stored as an attribute with the name 'value'. This is not easy "
"to remember and therefore not very user-friendly. Since the ``NewData`` type"
" is a class, we can give it useful methods. Let's introduce one that will "
"return the value that was stored for it:"
msgstr ""

#: ../../source/topics/data_types.rst:1318
msgid ""
"The addition of the instance property ``value`` makes retrieving the value "
"of a ``NewData`` node a lot easier:"
msgstr ""

#: ../../source/topics/data_types.rst:1325
msgid ""
"As said before, in addition to their attributes, data types can also store "
"their properties in the file repository. Here is an example for a custom "
"data type that needs to wrap a single text file:"
msgstr ""

#: ../../source/topics/data_types.rst:1356
msgid "To create a new instance of this data type and get its content:"
msgstr ""

#: ../../source/topics/data_types.rst:1363
msgid ""
"This example is a simplified version of the "
":class:`~aiida.orm.nodes.data.singlefile.SinglefileData` data class that "
"ships with ``aiida-core``. If this happens to be your use case (or very "
"close to it), it is of course better to use that class, or you can sub class"
" it and adapt it where needed."
msgstr ""

#: ../../source/topics/data_types.rst:1366
msgid ""
"The just presented examples for new data types are of course trivial, but "
"the concept is always the same and can easily be extended to more complex "
"custom data types. The following section will provide useful guidelines on "
"how to optimally design new data types."
msgstr ""

#: ../../source/topics/data_types.rst:1372
msgid "Database or repository?"
msgstr ""

#: ../../source/topics/data_types.rst:1374
msgid ""
"When deciding where to store a property of a data type, one has the option "
"to choose between the database and the file repository. All node properties "
"that are stored in the database (such as the attributes), are directly "
"searchable as part of a database query, whereas data stored in the file "
"repository cannot be queried for. What this means is that, for example, it "
"is possible to search for all nodes where a particular database-stored "
"integer attribute falls into a certain value range, but the same value "
"stored in a file within the file repository would not be directly searchable"
" in this way. However, storing large amounts of data within the database "
"comes at the cost of slowing down database queries. Therefore, big data "
"(think large files), whose content does not necessarily need to be queried "
"for, is better stored in the file repository. A data type may safely use "
"both the database and file repository in parallel for individual properties."
" Properties stored in the database are stored as *attributes* of the node. "
"The node class has various methods to set these attributes, such as "
":py:meth:`~aiida.orm.nodes.attributes.NodeAttributes.set` and "
":py:meth:`~aiida.orm.nodes.attributes.NodeAttributes.set_many`."
msgstr ""

#: ../../source/topics/database.rst:5
msgid "Database"
msgstr ""

#: ../../source/topics/database.rst:15
msgid "Advanced querying"
msgstr ""

#: ../../source/topics/database.rst:17
msgid ""
"The basics on using the :class:`~aiida.orm.querybuilder.QueryBuilder` to "
"find the data you are interested in is explained in the :ref:`finding and "
"querying how-to<how-to:query>`. This section explains some more advanced "
"methods for querying your database and the :ref:`QueryBuilder "
"dictionary<topics:database:advancedquery>`."
msgstr ""

#: ../../source/topics/database.rst:23
msgid "Working with edges"
msgstr ""

#: ../../source/topics/database.rst:25
msgid ""
"Filters and projections can be applied to both the vertices of the query "
"path and the edges that connect them. Applying a filter or projection to an "
"edge works the same way as for vertices, but the relevant keyword is now "
"preceded by ``edge_``. Using the ``ArithmeticAddCalculation`` calculation "
"job as an example, let's say we want to query for the first input of the "
"addition, i.e. the ``Int`` nodes which have been provided as the input with "
"label ``x``:"
msgstr ""

#: ../../source/topics/database.rst:36
msgid ""
"By using the ``edge_filters`` keyword argument, we can query for only the "
"inputs that have the label ``x``. Note that any operator that can be used to"
" filter vertices can also be applied to edges. Say we want to find all input"
" ``Int`` nodes that are **not** connected to the ``CalcJobNode``'s via an "
"edge with label ``x``:"
msgstr ""

#: ../../source/topics/database.rst:46
msgid ""
"Here, the equality operator ``==`` is negated by prepending an exclamation "
"mark ``!``. See the :ref:`reference table "
"below<topics:database:advancedquery:tables:operators>` for a table with all "
"operators. Similar to filters, we can *project* information of the edge "
"using the ``edge_project`` keyword argument:"
msgstr ""

#: ../../source/topics/database.rst:56
msgid ""
"In the example above, we are querying for the edge labels of the incoming "
"``Int`` nodes of all ``CalcJobNode``'s."
msgstr ""

#: ../../source/topics/database.rst:61
msgid "Ordering and limiting results"
msgstr ""

#: ../../source/topics/database.rst:63
msgid ""
"You can order the results of your query by the properties of the entity. Say"
" you want to return the list of ``Int`` outputs from all ``CalcJobNode``'s, "
"sorted by the time they were created in *descending* order, i.e. the most "
"recent first:"
msgstr ""

#: ../../source/topics/database.rst:73
msgid ""
"This can also be used to order your results based on values in a (nested) "
"dictionary, such as the ``attributes`` column. However, as the "
":class:`~aiida.orm.querybuilder.QueryBuilder` cannot infer the type of the "
"value in this case, you have to *cast* the type:"
msgstr ""

#: ../../source/topics/database.rst:83
msgid ""
"The query above will return all ``Int`` nodes that are output of all "
"``CalcJobNode``'s, in *ascending* order of their value, i.e. from small to "
"big. Note that in this case you have to specify the order operation with a "
"dictionary, where the ``order`` key details how you want to order the query "
"results and the ``cast`` key informs the ``QueryBuilder`` of the attribute "
"type. A list of the available cast types and their aliases can be found in "
"the table below:"
msgstr ""

#: ../../source/topics/database.rst:90
msgid "**Python type**"
msgstr ""

#: ../../source/topics/database.rst:90
msgid "**Alias**"
msgstr ""

#: ../../source/topics/database.rst:90
msgid "**SQLAlchemy type**"
msgstr ""

#: ../../source/topics/database.rst:92
msgid "int"
msgstr ""

#: ../../source/topics/database.rst:92
msgid "i"
msgstr ""

#: ../../source/topics/database.rst:92
msgid "Integer"
msgstr ""

#: ../../source/topics/database.rst:94
msgid "float"
msgstr ""

#: ../../source/topics/database.rst:94
msgid "f"
msgstr ""

#: ../../source/topics/database.rst:94
msgid "Float"
msgstr ""

#: ../../source/topics/database.rst:96
msgid "bool"
msgstr ""

#: ../../source/topics/database.rst:96
msgid "b"
msgstr ""

#: ../../source/topics/database.rst:96
msgid "Boolean"
msgstr ""

#: ../../source/topics/database.rst:98
msgid "str"
msgstr ""

#: ../../source/topics/database.rst:98
msgid "t"
msgstr ""

#: ../../source/topics/database.rst:98
msgid "String"
msgstr ""

#: ../../source/topics/database.rst:100 ../../source/topics/database.rst:168
msgid "dict"
msgstr ""

#: ../../source/topics/database.rst:100
msgid "j"
msgstr ""

#: ../../source/topics/database.rst:100
msgid "JSONB"
msgstr ""

#: ../../source/topics/database.rst:102
msgid "datetime.datetime"
msgstr ""

#: ../../source/topics/database.rst:102
msgid "d"
msgstr ""

#: ../../source/topics/database.rst:102
msgid "DateTime"
msgstr ""

#: ../../source/topics/database.rst:105
msgid ""
"You can also order using multiple properties by providing a list of "
"dictionaries that each specify one sorting operation:"
msgstr ""

#: ../../source/topics/database.rst:114
msgid ""
"Here the ``Int`` nodes will first be sorted by their value in ascending "
"order. Nodes for which the value is equal are subsequently sorted by their "
"modification time in descending order."
msgstr ""

#: ../../source/topics/database.rst:117
msgid ""
"Finally, you can also limit the number of query results returned with the "
"``limit()`` method. Suppose you only want the first three results from our "
"query:"
msgstr ""

#: ../../source/topics/database.rst:126
msgid ""
"This can be easily combined with the ``order_by`` method in order to get the"
" last three ``CalcJobNode``'s that were created in the database:"
msgstr ""

#: ../../source/topics/database.rst:138
msgid "Reference tables"
msgstr ""

#: ../../source/topics/database.rst:142
msgid "List of all operators:"
msgstr ""

#: ../../source/topics/database.rst:145
msgid "**Operator**"
msgstr ""

#: ../../source/topics/database.rst:145
msgid "**Datatype**"
msgstr ""

#: ../../source/topics/database.rst:145
msgid "**Example**"
msgstr ""

#: ../../source/topics/database.rst:145
msgid "Explanation"
msgstr ""

#: ../../source/topics/database.rst:147
msgid "``==``"
msgstr ""

#: ../../source/topics/database.rst:147 ../../source/topics/database.rst:149
msgid "all"
msgstr ""

#: ../../source/topics/database.rst:147
msgid "``'id': {'==': 123}``"
msgstr ""

#: ../../source/topics/database.rst:147
msgid "Filter for equality"
msgstr ""

#: ../../source/topics/database.rst:149
msgid "``in``"
msgstr ""

#: ../../source/topics/database.rst:149
msgid "``'name': {'in': ['foo', 'bar']}``"
msgstr ""

#: ../../source/topics/database.rst:149
msgid "Filter for values that are in the given list."
msgstr ""

#: ../../source/topics/database.rst:151
msgid "``>,<,<=,>=``"
msgstr ""

#: ../../source/topics/database.rst:151
msgid "float, integer, date"
msgstr ""

#: ../../source/topics/database.rst:151
msgid "``'ctime': {'<': datetime(2016, 03, 03)}``"
msgstr ""

#: ../../source/topics/database.rst:151
msgid "Filter for values that are greater or smaller than a certain value"
msgstr ""

#: ../../source/topics/database.rst:155
msgid "``like``"
msgstr ""

#: ../../source/topics/database.rst:155 ../../source/topics/database.rst:160
msgid "string"
msgstr ""

#: ../../source/topics/database.rst:155
msgid "``'name': {'like': 'label%'}``"
msgstr ""

#: ../../source/topics/database.rst:155
msgid ""
"Filter for matching substrings where ``%`` and ``_`` are wildcards. To match"
" a literal ``%`` or ``_`` escape it by prefixing it with ``\\\\``."
msgstr ""

#: ../../source/topics/database.rst:160
msgid "``ilike``"
msgstr ""

#: ../../source/topics/database.rst:160
msgid "``'name': {'ilike': 'lAbEl%'}``"
msgstr ""

#: ../../source/topics/database.rst:160
msgid "Case insensitive version of ``like``."
msgstr ""

#: ../../source/topics/database.rst:162
msgid "``or``"
msgstr ""

#: ../../source/topics/database.rst:162 ../../source/topics/database.rst:165
msgid "list of expressions"
msgstr ""

#: ../../source/topics/database.rst:162
msgid "``'id': {'or': [{'<': 12}, {'==': 199}]}``"
msgstr ""

#: ../../source/topics/database.rst:162
msgid "A list of expressions where at least one should be matched."
msgstr ""

#: ../../source/topics/database.rst:165
msgid "``and``"
msgstr ""

#: ../../source/topics/database.rst:165
msgid "``'id': {'and': [{'<': 12}, {'>': 1}]}``"
msgstr ""

#: ../../source/topics/database.rst:165
msgid "A list of expressions where all should be matched."
msgstr ""

#: ../../source/topics/database.rst:168
msgid "``has_key``"
msgstr ""

#: ../../source/topics/database.rst:168
msgid "``'attributes': {'has_key': 'some_key'}``"
msgstr ""

#: ../../source/topics/database.rst:168
msgid "Filter for dictionaries that contain a certain key."
msgstr ""

#: ../../source/topics/database.rst:170
msgid "``of_type``"
msgstr ""

#: ../../source/topics/database.rst:170
msgid "any"
msgstr ""

#: ../../source/topics/database.rst:170
msgid "``'attributes.some_key': {'of_type': 'bool'}``"
msgstr ""

#: ../../source/topics/database.rst:170
msgid "Filter for values of a certain type."
msgstr ""

#: ../../source/topics/database.rst:172
msgid "``of_length``"
msgstr ""

#: ../../source/topics/database.rst:172 ../../source/topics/database.rst:174
#: ../../source/topics/database.rst:176 ../../source/topics/database.rst:178
msgid "lists"
msgstr ""

#: ../../source/topics/database.rst:172
msgid "``'attributes.some_list': {'of_length': 4}``"
msgstr ""

#: ../../source/topics/database.rst:172
msgid "Filter for lists of a certain length."
msgstr ""

#: ../../source/topics/database.rst:174
msgid "``shorter``"
msgstr ""

#: ../../source/topics/database.rst:174
msgid "``'attributes.some_list': {'shorter': 4}``"
msgstr ""

#: ../../source/topics/database.rst:174
msgid "Filter for lists that are shorter than a certain length."
msgstr ""

#: ../../source/topics/database.rst:176
msgid "``longer``"
msgstr ""

#: ../../source/topics/database.rst:176
msgid "``'attributes.some_list': {'longer': 4}``"
msgstr ""

#: ../../source/topics/database.rst:176
msgid "Filter for lists that are longer than a certain length."
msgstr ""

#: ../../source/topics/database.rst:178
msgid "``contains``"
msgstr ""

#: ../../source/topics/database.rst:178
msgid "``'attributes.some_key': {'contains': ['a', 'b']}``"
msgstr ""

#: ../../source/topics/database.rst:178
msgid "Filter for lists that should contain certain values."
msgstr ""

#: ../../source/topics/database.rst:181
msgid ""
"As mentioned in the :ref:`section about operatior negations<how-"
"to:query:filters:operator-negations>` all operators can be turned into their"
" associated negation (``NOT`` operator) by adding a ``!`` in front of the "
"operator."
msgstr ""

#: ../../source/topics/database.rst:184
msgid ""
"The form of (negation) operators in the rendered SQL may differ from the "
"ones specified in the ``QueryBuilder`` instance. For example, the ``!==`` "
"operator of the ``QueryBuilder`` will be rendered to ``!=`` in SQL."
msgstr ""

#: ../../source/topics/database.rst:190
msgid "List of all relationships:"
msgstr ""

#: ../../source/topics/database.rst:193
msgid "**Entity from**"
msgstr ""

#: ../../source/topics/database.rst:193
msgid "**Entity to**"
msgstr ""

#: ../../source/topics/database.rst:193
msgid "**Relationship**"
msgstr ""

#: ../../source/topics/database.rst:193
msgid "**Explanation**"
msgstr ""

#: ../../source/topics/database.rst:195 ../../source/topics/database.rst:197
#: ../../source/topics/database.rst:199 ../../source/topics/database.rst:201
#: ../../source/topics/database.rst:203 ../../source/topics/database.rst:205
#: ../../source/topics/database.rst:207 ../../source/topics/database.rst:209
#: ../../source/topics/database.rst:211 ../../source/topics/database.rst:213
#: ../../source/topics/database.rst:219 ../../source/topics/database.rst:224
msgid "Node"
msgstr ""

#: ../../source/topics/database.rst:195
msgid "*with_outgoing*"
msgstr ""

#: ../../source/topics/database.rst:195
msgid "One node as input of another node"
msgstr ""

#: ../../source/topics/database.rst:197
msgid "*with_incoming*"
msgstr ""

#: ../../source/topics/database.rst:197
msgid "One node as output of another node"
msgstr ""

#: ../../source/topics/database.rst:199
msgid "*with_descendants*"
msgstr ""

#: ../../source/topics/database.rst:199
msgid "One node as the ancestor of another node (Path)"
msgstr ""

#: ../../source/topics/database.rst:201
msgid "*with_ancestors*"
msgstr ""

#: ../../source/topics/database.rst:201
msgid "One node as descendant of another node (Path)"
msgstr ""

#: ../../source/topics/database.rst:203 ../../source/topics/database.rst:205
#: ../../source/topics/database.rst:215 ../../source/topics/database.rst:217
msgid "Group"
msgstr ""

#: ../../source/topics/database.rst:203 ../../source/topics/database.rst:207
#: ../../source/topics/database.rst:211 ../../source/topics/database.rst:219
msgid "*with_node*"
msgstr ""

#: ../../source/topics/database.rst:203
msgid "The group of a node"
msgstr ""

#: ../../source/topics/database.rst:205 ../../source/topics/database.rst:217
msgid "*with_group*"
msgstr ""

#: ../../source/topics/database.rst:205
msgid "The node is a member of a group"
msgstr ""

#: ../../source/topics/database.rst:207 ../../source/topics/database.rst:209
msgid "Computer"
msgstr ""

#: ../../source/topics/database.rst:207
msgid "The computer of a node"
msgstr ""

#: ../../source/topics/database.rst:209
msgid "*with_computer*"
msgstr ""

#: ../../source/topics/database.rst:209
msgid "The node of a computer"
msgstr ""

#: ../../source/topics/database.rst:211 ../../source/topics/database.rst:213
#: ../../source/topics/database.rst:215 ../../source/topics/database.rst:217
#: ../../source/topics/database.rst:226 ../../source/topics/database.rst:228
msgid "User"
msgstr ""

#: ../../source/topics/database.rst:211
msgid "The creator of a node is a user"
msgstr ""

#: ../../source/topics/database.rst:213 ../../source/topics/database.rst:215
#: ../../source/topics/database.rst:226
msgid "*with_user*"
msgstr ""

#: ../../source/topics/database.rst:213 ../../source/topics/database.rst:215
#: ../../source/topics/database.rst:217
msgid "The node was created by a user"
msgstr ""

#: ../../source/topics/database.rst:219
msgid "Log"
msgstr ""

#: ../../source/topics/database.rst:219
msgid "The log of a node"
msgstr ""

#: ../../source/topics/database.rst:221
msgid "Log Node"
msgstr ""

#: ../../source/topics/database.rst:221
msgid "Node Comment"
msgstr ""

#: ../../source/topics/database.rst:221
msgid "*with_log* *with_node*"
msgstr ""

#: ../../source/topics/database.rst:221
msgid "The node has a log The comment of a node"
msgstr ""

#: ../../source/topics/database.rst:224 ../../source/topics/database.rst:226
#: ../../source/topics/database.rst:228
msgid "Comment"
msgstr ""

#: ../../source/topics/database.rst:224 ../../source/topics/database.rst:228
msgid "*with_comment*"
msgstr ""

#: ../../source/topics/database.rst:224
msgid "The node has a comment"
msgstr ""

#: ../../source/topics/database.rst:226
msgid "The comment was created by a user"
msgstr ""

#: ../../source/topics/database.rst:228
msgid "The creator of a comment is a user"
msgstr ""

#: ../../source/topics/database.rst:235
msgid "Converting the QueryBuilder to/from a dictionary"
msgstr ""

#: ../../source/topics/database.rst:239
msgid ""
"In aiida-core version 1, this dictionary was accessed with "
"``QueryBuilder.queryhelp``, which is now deprecated."
msgstr ""

#: ../../source/topics/database.rst:241
msgid ""
"The :class:`~aiida.orm.querybuilder.QueryBuilder` class can be converted to "
"a dictionary and also loaded from a dictionary, for easy serialisation and "
"storage. Once you have built your query using the appender method explained "
"in the :ref:`finding and querying for data how-to<how-to:query>` and the "
"advanced sections above, you can easily store your query by saving the "
"``QueryBuilder.as_dict()`` dictionary as a JSON file for later use:"
msgstr ""

#: ../../source/topics/database.rst:255
msgid ""
"To use this dictionary to instantiate the "
":class:`~aiida.orm.querybuilder.QueryBuilder`, you can use the ``from_dict``"
" class method:"
msgstr ""

#: ../../source/topics/database.rst:264
msgid ""
"Alternatively, you can also use a dictionary to set up your query by "
"specifying the path, filters and projections and constructing the dictionary"
" by hand. To do this, you have to specify:"
msgstr ""

#: ../../source/topics/database.rst:267
msgid ""
"the ``path``: Here, the user specifies the path along which to join tables "
"as a list of dictionaries, where each list item identifies a vertex in your "
"path. You define the vertex class with the ``cls`` key::"
msgstr ""

#: ../../source/topics/database.rst:277
msgid ""
"Each entity in the query has to have a unique tag. If the tag is not "
"provided, it is set to the name of the class. However, this will not work if"
" you choose the same class twice in the query. In this case you have to "
"provide the tag using the ``tag`` key::"
msgstr ""

#: ../../source/topics/database.rst:295
msgid ""
"You also have to detail some information on the vertex edges, in order to "
"connect them correctly. There are several redundant ways this can be done:"
msgstr ""

#: ../../source/topics/database.rst:298
msgid ""
"You can specify that this node is an input or output of another node "
"preceding the current one in the list. That other node can be specified by "
"an integer or the class or type. The following examples are all valid "
"joining instructions, assuming there is a structure defined at index 2 of "
"the path with tag \"struc1\"::"
msgstr ""

#: ../../source/topics/database.rst:310
msgid "``query_dict['path'][<i>]['direction'] = integer``"
msgstr ""

#: ../../source/topics/database.rst:312
msgid ""
"If any of the above specs (\"with_outgoing\", \"with_incoming\") were not "
"specified, the key \"direction\" is looked for. Directions are defined as "
"distances in the tree. 1 is defined as one step down the tree along a link. "
"This means that 1 joins the node specified in this dictionary to the node "
"specified on list-item before **as an output**. Direction defaults to 1, "
"which is why, if nothing is specified, this node is joined to the previous "
"one as an output by default. A negative number reverse the direction of the "
"link. The absolute value of the direction defines the table to join to with "
"respect to your own position in the list. An absolute value of 1 joins one "
"table above, a value of 2 to the table defined 2 indices above. The two "
"following dictionaries yield the same query::"
msgstr ""

#: ../../source/topics/database.rst:367
msgid "what to ``project``: Determining which columns the query will return::"
msgstr ""

#: ../../source/topics/database.rst:376
msgid ""
"If you are using JSONB columns, you can also project a value stored inside "
"the json::"
msgstr ""

#: ../../source/topics/database.rst:388
msgid ""
"Returns the state and the id of all instances of ``PwCalculation`` where a "
"structures is linked as output of a relax-calculation. The strings that you "
"pass have to be name of the columns. If you pass an asterisk ('*'), the "
"query will return the instance of the AiidaClass."
msgstr ""

#: ../../source/topics/database.rst:392
msgid ""
"the ``filters``: Filters enable you to further specify the query. This is an"
" example for a query for structures that were added after a certain time "
"(say last 4 days) and have an id larger than 50::"
msgstr ""

#: ../../source/topics/database.rst:412
msgid ""
"If you want to include filters and projections on links between nodes, you "
"will have to add these to filters and projections in the query dictionary. "
"Let's take an example from before and add a few filters on the link::"
msgstr ""

#: ../../source/topics/database.rst:435
msgid ""
"Notice that the tag for the link, by default, is the tag of the two "
"connecting nodes delimited by two dashes '--' and the order DOES matter."
msgstr ""

#: ../../source/topics/database.rst:437
msgid ""
"Alternatively, you can choose the tag for the edge in the path when defining"
" the entity to join using ``edge_tag``::"
msgstr ""

#: ../../source/topics/database.rst:463
msgid "Limits and offset can be set directly like this::"
msgstr ""

#: ../../source/topics/database.rst:471
msgid ""
"That ``query_dict`` would tell the QueryBuilder to return 10 rows after the "
"first 20 have been skipped."
msgstr ""

#: ../../source/topics/index.rst:3
msgid "Topics"
msgstr ""

#: ../../source/topics/performance.rst:5
msgid "Performance"
msgstr ""

#: ../../source/topics/performance.rst:7
msgid "The performance of AiiDA depends on many factors:"
msgstr ""

#: ../../source/topics/performance.rst:9
msgid "the hardware that AiiDA is running on"
msgstr ""

#: ../../source/topics/performance.rst:10
msgid ""
"how the services for AiiDA are configured (the database, message broker, "
"filesystem, etc.)"
msgstr ""

#: ../../source/topics/performance.rst:11
msgid "the codes and their plugins that are being run."
msgstr ""

#: ../../source/topics/performance.rst:13
msgid ""
"This section gives an overview of how each of these factors influence the "
"overall performance of AiiDA and how it can be optimized."
msgstr ""

#: ../../source/topics/performance.rst:19
msgid "Hardware"
msgstr ""

#: ../../source/topics/performance.rst:21
msgid ""
"The bulk of AiiDA's workload is typically carried by the daemon and its "
"workers. The performance is typically limited by the computing power of the "
"machine on which AiiDA is running."
msgstr ""

#: ../../source/topics/performance.rst:24
msgid ""
"Each worker is a separate Python process that takes care of executing the "
"AiiDA processes that are submitted. AiiDA was designed to allow to increase "
"the throughput by adding more daemon workers that can work independently in "
"parallel. A rule of thumb is to not have more workers than the number of "
"cores of the machine's CPU on which AiiDA is running. If more workers are "
"added, they will have to start sharing and swapping resources and the "
"performance scaling will degrade."
msgstr ""

#: ../../source/topics/performance.rst:33
msgid "Services"
msgstr ""

#: ../../source/topics/performance.rst:35
msgid ""
"For the default setup, AiiDA essentially has three services that influence "
"its performance:"
msgstr ""

#: ../../source/topics/performance.rst:37
msgid "PostgreSQL (the database in which the provenance graph is stored)"
msgstr ""

#: ../../source/topics/performance.rst:38
msgid ""
"RabbitMQ (the message broker that the daemon workers use to communicate)"
msgstr ""

#: ../../source/topics/performance.rst:39
msgid ""
"Filesystem (files are stored by AiiDA in the file repository on a filesytem)"
msgstr ""

#: ../../source/topics/performance.rst:41
msgid ""
"For the simplest installations, the PostgreSQL and RabbitMQ services are "
"typically running on the same machine as AiiDA itself. Although this means "
"that a part of the machine's resources is not available for AiiDA itself and"
" its daemon, the latency for AiiDA to communicate with the services is "
"minimal."
msgstr ""

#: ../../source/topics/performance.rst:44
msgid ""
"It is possible to configure an AiiDA profile to use services that are "
"running on a different machine and can be reached over a network. However, "
"this will typically affect the performance negatively as now each time a "
"connection needs to be made to a service, the latency of the network is "
"incurred."
msgstr ""

#: ../../source/topics/performance.rst:51
msgid "Benchmarks"
msgstr ""

#: ../../source/topics/performance.rst:53
msgid ""
"The :download:`benchmark script "
"<../howto/include/scripts/performance_benchmark_base.py>` :fa:`download` "
"provides a basic way of assessing performance of the workflow engine that "
"involves all components (CPU, file system, postgresql, rabbitmq)."
msgstr ""

#: ../../source/topics/performance.rst:55
msgid ""
"It launches ``ArithmeticAddCalculation``s on the localhost and measures the "
"time until completion. Since the workload of the "
"``ArithmeticAddCalculation`` (summing two numbers) completes instantly, the "
"time per process is a reasonable measure of the overhead incurred from the "
"workflow engine."
msgstr ""

#: ../../source/topics/performance.rst:58
msgid ""
"The numbers reported in the :ref:`howto section<how-"
"to:installation:performance>` were obtained by running the processes in the "
"current shell, which is the default. The ``--daemon`` option can be used to "
"run the calculations through the AiiDA daemon instead, and to look at "
"parallelizing over multiple daemon workers:"
msgstr ""

#: ../../source/topics/performance.rst:65
msgid "# Workers"
msgstr ""

#: ../../source/topics/performance.rst:65
msgid "Total elapsed time (s)"
msgstr ""

#: ../../source/topics/performance.rst:65
msgid "Performance (s/process)"
msgstr ""

#: ../../source/topics/performance.rst:67
msgid "1"
msgstr ""

#: ../../source/topics/performance.rst:67
msgid "46.55"
msgstr ""

#: ../../source/topics/performance.rst:67
msgid "0.47"
msgstr ""

#: ../../source/topics/performance.rst:68
msgid "2"
msgstr ""

#: ../../source/topics/performance.rst:68
msgid "27.83"
msgstr ""

#: ../../source/topics/performance.rst:68
msgid "0.28"
msgstr ""

#: ../../source/topics/performance.rst:69
msgid "4"
msgstr ""

#: ../../source/topics/performance.rst:69
msgid "16.43"
msgstr ""

#: ../../source/topics/performance.rst:69
msgid "0.16"
msgstr ""

#: ../../source/topics/performance.rst:74
msgid ""
"While the process rate increases with the number of daemon workers, the "
"scaling is not quite linear. This is because, for simplicity, the benchmark "
"script measures both the time required to submit the processes to the daemon"
" (not parallelized) as well as the time needed to run the processes "
"(parallelized over daemon workers). In long-running processes, the time "
"required to submit the process (roughly 0.1 seconds per process) is not "
"relevant and linear scaling is achieved."
msgstr ""

#: ../../source/topics/performance.rst:82 ../../source/topics/plugins.rst:5
msgid "Plugins"
msgstr ""

#: ../../source/topics/performance.rst:84
msgid ""
"One of AiiDA's strengths is its plugin system, which allows it capabilities "
"to be customized in a variety of ways. However, this flexibility also means "
"that the performance of AiiDA can be affected significantly by the "
"implementation of the plugins. For example, a `CalcJob` plugin determines "
"which files are transferred from and to the computing resources. If the "
"plugin needs to transfer and store large amounts of data, this will affect "
"the process throughput of the daemon workers. Likewise, if a `Parser` plugin"
" performs heavy numerical computations to parse the retrieved data, this "
"will slow down the workers' throughput. In order to optimize the process "
"throughput, plugins should try to minize heavy computations and the transfer"
" of lots of unnecessary data."
msgstr ""

#: ../../source/topics/plugins.rst:10
msgid "What a plugin can do"
msgstr ""

#: ../../source/topics/plugins.rst:12
msgid ""
"Add a new class to AiiDA's :ref:`entry point groups "
"<topics:plugins:entrypointgroups>`, including:: calculations, parsers, "
"workflows, data types, verdi commands, schedulers, transports and "
"importers/exporters from external databases. This typically involves "
"subclassing the respective base class AiiDA provides for that purpose."
msgstr ""

#: ../../source/topics/plugins.rst:14
msgid "Install new commandline and/or GUI executables"
msgstr ""

#: ../../source/topics/plugins.rst:15
msgid ""
"Depend on, and build on top of any number of other plugins (as long as their"
" requirements do not clash)"
msgstr ""

#: ../../source/topics/plugins.rst:21
msgid "What a plugin should not do"
msgstr ""

#: ../../source/topics/plugins.rst:23
msgid "An AiiDA plugin should not:"
msgstr ""

#: ../../source/topics/plugins.rst:25
msgid "Change the database schema AiiDA uses"
msgstr ""

#: ../../source/topics/plugins.rst:26
msgid ""
"Use protected functions, methods or classes of AiiDA (those starting with an"
" underscore ``_``)"
msgstr ""

#: ../../source/topics/plugins.rst:27
msgid ""
"Monkey patch anything within the ``aiida`` namespace (or the namespace "
"itself)"
msgstr ""

#: ../../source/topics/plugins.rst:29
msgid ""
"Failure to comply will likely prevent your plugin from being listed on the "
"official `AiiDA plugin registry <registry_>`_."
msgstr ""

#: ../../source/topics/plugins.rst:31
msgid ""
"If you find yourself in a situation where you feel like you need to do any "
"of the above, please open an issue on the `AiiDA repository <core_>`_ and we"
" can try to advise on how to proceed."
msgstr ""

#: ../../source/topics/plugins.rst:40
msgid "Guidelines for plugin design"
msgstr ""

#: ../../source/topics/plugins.rst:43
msgid "CalcJob & Parser plugins"
msgstr ""

#: ../../source/topics/plugins.rst:45
msgid ""
"The following guidelines are useful to keep in mind when wrapping external "
"codes:"
msgstr ""

#: ../../source/topics/plugins.rst:47
msgid ""
"**Start simple.** Make use of existing classes like "
":py:class:`~aiida.orm.nodes.data.dict.Dict`, "
":py:class:`~aiida.orm.nodes.data.singlefile.SinglefileData`, ... Write only "
"what is necessary to pass information from and to AiiDA."
msgstr ""

#: ../../source/topics/plugins.rst:50
msgid ""
"**Don't break data provenance.** Store *at least* what is needed for full "
"reproducibility."
msgstr ""

#: ../../source/topics/plugins.rst:52
msgid ""
"**Expose the full functionality.** Standardization is good but don't "
"artificially limit the power of a code you are wrapping - or your users will"
" get frustrated. If the code can do it, there should be *some* way to do it "
"with your plugin."
msgstr ""

#: ../../source/topics/plugins.rst:55
msgid ""
"**Don't rely on AiiDA internals.** Functionality at deeper nesting levels is"
" not considered part of the public API and may change between minor AiiDA "
"releases, breaking your plugin."
msgstr ""

#: ../../source/topics/plugins.rst:57
msgid ""
"**Parse what you want to query for.** Make a list of which information to:"
msgstr ""

#: ../../source/topics/plugins.rst:60
msgid ""
"parse into the database for querying "
"(:py:class:`~aiida.orm.nodes.data.dict.Dict`, ...)"
msgstr ""

#: ../../source/topics/plugins.rst:61
msgid ""
"store in the file repository for safe-keeping "
"(:py:class:`~aiida.orm.nodes.data.singlefile.SinglefileData`, ...)"
msgstr ""

#: ../../source/topics/plugins.rst:62
msgid ""
"leave on the computer where the calculation ran "
"(:py:class:`~aiida.orm.RemoteData`, ...)"
msgstr ""

#: ../../source/topics/plugins.rst:68
msgid "What is an entry point?"
msgstr ""

#: ../../source/topics/plugins.rst:71
msgid ""
"The ``setuptools`` package (used by ``pip``) has a feature called `entry "
"points`_, which allows to associate a string (the entry point *identifier*) "
"with any python object defined inside a python package. Entry points are "
"defined in the ``pyproject.toml`` file, for example::"
msgstr ""

#: ../../source/topics/plugins.rst:80
msgid ""
"Here, we add a new entry point ``mycode.mydata`` to the entry point *group* "
"``aiida.data``. The entry point identifier points to the ``MyData`` class "
"inside the file ``mydata.py``, which is part of the ``aiida_mycode`` "
"package."
msgstr ""

#: ../../source/topics/plugins.rst:83
msgid ""
"When installing a python package that defines entry points, the entry point "
"specifications are written to a file inside the distribution's ``.egg-info``"
" folder. ``setuptools`` provides a package ``pkg_resources`` for querying "
"these entry point specifications by distribution, by entry point group "
"and/or by name of the entry point and load the data structure to which it "
"points."
msgstr ""

#: ../../source/topics/plugins.rst:87
msgid "Why entry points?"
msgstr ""

#: ../../source/topics/plugins.rst:89
msgid ""
"AiiDA defines a set of entry point groups (see "
":ref:`topics:plugins:entrypointgroups` below). By inspecting the entry "
"points added to these groups by AiiDA plugins, AiiDA can offer uniform "
"interfaces to interact with them. For example:"
msgstr ""

#: ../../source/topics/plugins.rst:93
msgid ""
"``verdi plugin list aiida.workflows`` provides an overview of all workflows "
"installed by AiiDA plugins. Users can inspect the inputs/outputs of each "
"workflow using the same command without having to study the documentation of"
" the plugin."
msgstr ""

#: ../../source/topics/plugins.rst:95
msgid ""
"The ``DataFactory``, ``CalculationFactory`` and ``WorkflowFactory`` methods "
"allow instantiating new classes through a simple short string (e.g. "
"``quantumespresso.pw``). Users don't need to remember exactly where in the "
"plugin package the class resides, and plugins can be refactored without "
"users having to re-learn the plugin's API."
msgstr ""

#: ../../source/topics/plugins.rst:102
msgid "AiiDA entry point groups"
msgstr ""

#: ../../source/topics/plugins.rst:104
msgid ""
"Below, we list the entry point groups defined and searched by AiiDA. You can"
" get the same list as the output of ``verdi plugin list``."
msgstr ""

#: ../../source/topics/plugins.rst:108
msgid "``aiida.calculations``"
msgstr ""

#: ../../source/topics/plugins.rst:110
msgid ""
"Entry points in this group are expected to be subclasses of "
":py:class:`aiida.orm.JobCalculation "
"<aiida.orm.nodes.process.calculation.calcjob.CalcJobNode>`. This replaces "
"the previous method of placing a python module with the class in question "
"inside the ``aiida/orm/calculation/job`` subpackage."
msgstr ""

#: ../../source/topics/plugins.rst:112
msgid "Example entry point specification::"
msgstr ""

#: ../../source/topics/plugins.rst:117
msgid "``aiida_mycode/calcs/mycode.py``::"
msgstr ""

#: ../../source/topics/plugins.rst:123
msgid "Will lead to usage::"
msgstr ""

#: ../../source/topics/plugins.rst:129
msgid "``aiida.parsers``"
msgstr ""

#: ../../source/topics/plugins.rst:131
msgid ""
"AiiDA expects a subclass of ``Parser``. Replaces the previous approach "
"consisting in placing a parser module under ``aiida/parsers/plugins``."
msgstr ""

#: ../../source/topics/plugins.rst:133
msgid "Example spec::"
msgstr ""

#: ../../source/topics/plugins.rst:138
msgid "``aida_mycode/parsers/myparser.py``::"
msgstr ""

#: ../../source/topics/plugins.rst:144 ../../source/topics/plugins.rst:165
#: ../../source/topics/plugins.rst:186 ../../source/topics/plugins.rst:325
msgid "Usage::"
msgstr ""

#: ../../source/topics/plugins.rst:150
msgid "``aiida.data``"
msgstr ""

#: ../../source/topics/plugins.rst:152
msgid ""
"Group for :py:class:`~aiida.orm.nodes.data.data.Data` subclasses. Previously"
" located in a subpackage of ``aiida/orm/data``."
msgstr ""

#: ../../source/topics/plugins.rst:154 ../../source/topics/plugins.rst:175
#: ../../source/topics/plugins.rst:295 ../../source/topics/plugins.rst:314
msgid "Spec::"
msgstr ""

#: ../../source/topics/plugins.rst:159
msgid "``aiida_mycode/data/mydat.py``::"
msgstr ""

#: ../../source/topics/plugins.rst:171
msgid "``aiida.workflows``"
msgstr ""

#: ../../source/topics/plugins.rst:173
msgid "Package AiiDA workflows as follows:"
msgstr ""

#: ../../source/topics/plugins.rst:180
msgid "``aiida_mycode/workflows/mywf.py``::"
msgstr ""

#: ../../source/topics/plugins.rst:191
msgid ""
"For old-style workflows the entry point mechanism of the plugin system is "
"not supported. Therefore one cannot load these workflows with the "
"``WorkflowFactory``. The only way to run these, is to store their source "
"code in the ``aiida/workflows/user`` directory and use normal python imports"
" to load the classes."
msgstr ""

#: ../../source/topics/plugins.rst:197
msgid "``aiida.cmdline``"
msgstr ""

#: ../../source/topics/plugins.rst:199
msgid ""
"``verdi`` uses the `click_` framework, which makes it possible to add new "
"subcommands to existing verdi commands, such as ``verdi data mydata``. AiiDA"
" expects each entry point to be either a ``click.Command`` or "
"``click.Group``. At present extra commands can be injected at the following "
"levels:"
msgstr ""

#: ../../source/topics/plugins.rst:202
msgid "As a :ref:`direct subcommand of verdi data<spec-verdi-data>`"
msgstr ""

#: ../../source/topics/plugins.rst:203
msgid ""
"As a :ref:`subcommand of verdi data core.structure import<spec-verdi-data-"
"structure-import>`"
msgstr ""

#: ../../source/topics/plugins.rst:208
msgid "Spec for ``verdi data``::"
msgstr ""

#: ../../source/topics/plugins.rst:213
msgid "``aiida_mycode/commands/mydata.py``::"
msgstr ""

#: ../../source/topics/plugins.rst:227 ../../source/topics/plugins.rst:254
msgid "Usage:"
msgstr ""

#: ../../source/topics/plugins.rst:235
msgid "Spec for ``verdi data core.structure import``::"
msgstr ""

#: ../../source/topics/plugins.rst:245
msgid "``aiida_mycode/commands/myformat.py``::"
msgstr ""

#: ../../source/topics/plugins.rst:262
msgid "``aiida.tools.dbexporters``"
msgstr ""

#: ../../source/topics/plugins.rst:264
msgid ""
"If your plugin package adds support for exporting to an external database, "
"use this entry point to have aiida find the module where you define the "
"necessary functions."
msgstr ""

#: ../../source/topics/plugins.rst:276
msgid "``aiida.tools.dbimporters``"
msgstr ""

#: ../../source/topics/plugins.rst:278
msgid ""
"If your plugin package adds support for importing from an external database,"
" use this entry point to have aiida find the module where you define the "
"necessary functions."
msgstr ""

#: ../../source/topics/plugins.rst:291
msgid "``aiida.schedulers``"
msgstr ""

#: ../../source/topics/plugins.rst:293
msgid ""
"We recommend naming the plugin package after the scheduler (e.g. ``aiida-"
"myscheduler``), so that the entry point name can simply equal the name of "
"the scheduler:"
msgstr ""

#: ../../source/topics/plugins.rst:300
msgid "``aiida_myscheduler/myscheduler.py``::"
msgstr ""

#: ../../source/topics/plugins.rst:306
msgid ""
"Usage: The scheduler is used in the familiar way by entering 'myscheduler' "
"as the scheduler option when setting up a computer."
msgstr ""

#: ../../source/topics/plugins.rst:309
msgid "``aiida.transports``"
msgstr ""

#: ../../source/topics/plugins.rst:311
msgid ""
"``aiida-core`` ships with two modes of transporting files and folders to "
"remote computers: ``core.ssh`` and ``core.local`` (stub for when the remote "
"computer is actually the same). We recommend naming the plugin package after"
" the mode of transport (e.g. ``aiida-mytransport``), so that the entry point"
" name can simply equal the name of the transport:"
msgstr ""

#: ../../source/topics/plugins.rst:319
msgid "``aiida_mytransport/mytransport.py``::"
msgstr ""

#: ../../source/topics/plugins.rst:330
msgid ""
"When setting up a new computer, specify ``mytransport`` as the transport "
"mode."
msgstr ""

#: ../../source/topics/plugins.rst:337
msgid "Plugin test fixtures"
msgstr ""

#: ../../source/topics/plugins.rst:339
msgid ""
"When developing AiiDA plugin packages, it is recommended to use `pytest "
"<https://docs.pytest.org/>`__ as the unit test library, which is the de-"
"facto standard in the Python ecosystem. It provides a number of `fixtures "
"<https://docs.pytest.org/en/7.1.x/how-to/fixtures.html>`__ that make it easy"
" to setup and write tests. ``aiida-core`` also provides a number fixtures "
"that are specific to AiiDA and make it easy to test various sorts of "
"plugins."
msgstr ""

#: ../../source/topics/plugins.rst:343
msgid ""
"To make use of these fixtures, create a ``conftest.py`` file in your "
"``tests`` folder and add the following code:"
msgstr ""

#: ../../source/topics/plugins.rst:349
msgid ""
"Just by adding this line, the fixtures that are provided by the "
":mod:`~aiida.manage.tests.pytest_fixtures` module are automatically "
"imported. The module provides the following fixtures:"
msgstr ""

#: ../../source/topics/plugins.rst:352
msgid ""
":ref:`aiida_manager <topics:plugins:testfixtures:aiida-manager>`: Return the"
" global instance of the :class:`~aiida.manage.manager.Manager`"
msgstr ""

#: ../../source/topics/plugins.rst:353
msgid ""
":ref:`aiida_profile <topics:plugins:testfixtures:aiida-profile>`: Provide a "
"loaded AiiDA test profile with loaded storage backend"
msgstr ""

#: ../../source/topics/plugins.rst:354
msgid ""
":ref:`aiida_profile_clean <topics:plugins:testfixtures:aiida-profile-"
"clean>`: Same as ``aiida_profile`` but the storage backend is cleaned"
msgstr ""

#: ../../source/topics/plugins.rst:355
msgid ""
":ref:`aiida_profile_clean_class <topics:plugins:testfixtures:aiida-profile-"
"clean-class>`: Same as ``aiida_profile_clean`` but should be used at the "
"class scope"
msgstr ""

#: ../../source/topics/plugins.rst:356
msgid ""
":ref:`aiida_profile_factory <topics:plugins:testfixtures:aiida-profile-"
"factory>`: Create a temporary profile ready to be used for testing"
msgstr ""

#: ../../source/topics/plugins.rst:357
msgid ""
":ref:`aiida_instance <topics:plugins:testfixtures:aiida-instance>`: Return "
"the :class:`~aiida.manage.configuration.config.Config` instance that is used"
" for the test session"
msgstr ""

#: ../../source/topics/plugins.rst:358
msgid ""
":ref:`config_psql_dos <topics:plugins:testfixtures:config-psql-dos>`: Return"
" a profile configuration for the "
":class:`~aiida.storage.psql_dos.backend.PsqlDosBackend`"
msgstr ""

#: ../../source/topics/plugins.rst:359
msgid ""
":ref:`postgres_cluster <topics:plugins:testfixtures:postgres-cluster>`: "
"Create a temporary and isolated PostgreSQL cluster using ``pgtest`` and "
"cleanup after the yield"
msgstr ""

#: ../../source/topics/plugins.rst:360
msgid ""
":ref:`aiida_local_code_factory <topics:plugins:testfixtures:aiida-local-"
"code-factory>`: Setup a "
":class:`~aiida.orm.nodes.data.code.installed.InstalledCode` instance on the "
"``localhost`` computer"
msgstr ""

#: ../../source/topics/plugins.rst:361
msgid ""
":ref:`aiida_computer <topics:plugins:testfixtures:aiida-computer>`: Setup a "
":class:`~aiida.orm.computers.Computer` instance"
msgstr ""

#: ../../source/topics/plugins.rst:362
msgid ""
":ref:`aiida_computer_local <topics:plugins:testfixtures:aiida-computer-"
"local>`: Setup the localhost as a :class:`~aiida.orm.computers.Computer` "
"using local transport"
msgstr ""

#: ../../source/topics/plugins.rst:363
msgid ""
":ref:`aiida_computer_ssh <topics:plugins:testfixtures:aiida-computer-ssh>`: "
"Setup the localhost as a :class:`~aiida.orm.computers.Computer` using SSH "
"transport"
msgstr ""

#: ../../source/topics/plugins.rst:364
msgid ""
":ref:`aiida_localhost <topics:plugins:testfixtures:aiida-localhost>`: "
"Shortcut for <topics:plugins:testfixtures:aiida-computer-local> that "
"immediately returns a :class:`~aiida.orm.computers.Computer` instance for "
"the ``localhost`` computer instead of a factory"
msgstr ""

#: ../../source/topics/plugins.rst:365
msgid ""
":ref:`submit_and_await <topics:plugins:testfixtures:submit-and-await>`: "
"Submit a process or process builder to the daemon and wait for it to reach a"
" certain process state"
msgstr ""

#: ../../source/topics/plugins.rst:366
msgid ""
":ref:`started_daemon_client <topics:plugins:testfixtures:started-daemon-"
"client>`: Same as ``daemon_client`` but the daemon is guaranteed to be "
"running"
msgstr ""

#: ../../source/topics/plugins.rst:367
msgid ""
":ref:`stopped_daemon_client <topics:plugins:testfixtures:stopped-daemon-"
"client>`: Same as ``daemon_client`` but the daemon is guaranteed to *not* be"
" running"
msgstr ""

#: ../../source/topics/plugins.rst:368
msgid ""
":ref:`daemon_client <topics:plugins:testfixtures:daemon-client>`: Return a "
":class:`~aiida.engine.daemon.client.DaemonClient` instance to control the "
"daemon"
msgstr ""

#: ../../source/topics/plugins.rst:369
msgid ""
":ref:`entry_points <topics:plugins:testfixtures:entry-points>`: Return a "
":class:`~aiida.manage.tests.pytest_fixtures.EntryPointManager` instance to "
"add and remove entry points"
msgstr ""

#: ../../source/topics/plugins.rst:375
msgid "``aiida_manager``"
msgstr ""

#: ../../source/topics/plugins.rst:377
msgid ""
"Return the global instance of the :class:`~aiida.manage.manager.Manager`. "
"Can be used, for example, to retrieve the current "
":class:`~aiida.manage.configuration.config.Config` instance:"
msgstr ""

#: ../../source/topics/plugins.rst:389
msgid "``aiida_profile``"
msgstr ""

#: ../../source/topics/plugins.rst:391
msgid ""
"This fixture ensures that an AiiDA profile is loaded with an initialized "
"storage backend, such that data can be stored. The fixture is session-scoped"
" and it has set ``autouse=True``, so it is automatically enabled for the "
"test session."
msgstr ""

#: ../../source/topics/plugins.rst:394
msgid ""
"By default, the fixture will generate a completely temporary independent "
"AiiDA instance and test profile. This includes:"
msgstr ""

#: ../../source/topics/plugins.rst:397
msgid "A temporary ``.aiida`` configuration folder with configuration files"
msgstr ""

#: ../../source/topics/plugins.rst:398
msgid "A temporary PostgreSQL cluster"
msgstr ""

#: ../../source/topics/plugins.rst:399
msgid ""
"A temporary test profile complete with storage backend (creates a database "
"in the temporary PostgreSQL cluster)"
msgstr ""

#: ../../source/topics/plugins.rst:401
msgid ""
"The temporary test instance and profile are automatically destroyed at the "
"end of the test session. The fixture guarantees that no changes are made to "
"the actual instance of AiiDA with its configuration and profiles."
msgstr ""

#: ../../source/topics/plugins.rst:404
msgid ""
"The creation of the temporary instance and profile takes a few seconds at "
"the beginning of the test suite to setup. It is possible to avoid this by "
"creating a dedicated test profile once and telling the fixture to use that "
"instead of generating one each time:"
msgstr ""

#: ../../source/topics/plugins.rst:407
msgid ""
"Create a profile, by using `verdi setup` or `verdi quicksetup` and specify "
"the ``--test-profile`` flag"
msgstr ""

#: ../../source/topics/plugins.rst:408
msgid ""
"Set the ``AIIDA_TEST_PROFILE`` environment variable to the name of the test "
"profile: ``export AIIDA_TEST_PROFILE=<test-profile-name>``"
msgstr ""

#: ../../source/topics/plugins.rst:410
msgid ""
"Although the fixture is automatically used, and so there is no need to "
"explicitly pass it into a test function, it may still be useful, as it can "
"be used to clean the storage backend from all data:"
msgstr ""

#: ../../source/topics/plugins.rst:430
msgid "``aiida_profile_clean``"
msgstr ""

#: ../../source/topics/plugins.rst:432
msgid ""
"Provides a loaded test profile through ``aiida_profile`` but empties the "
"storage before calling the test function. Note that a default user will be "
"inserted into the database after cleaning it."
msgstr ""

#: ../../source/topics/plugins.rst:440
msgid ""
"This functionality can be useful if it is easier to setup and write the test"
" if there is no pre-existing data. However, cleaning the storage may take a "
"non-negligible amount of time, so only use it when really needed in order to"
" keep tests running as fast as possible."
msgstr ""

#: ../../source/topics/plugins.rst:447
msgid "``aiida_profile_clean_class``"
msgstr ""

#: ../../source/topics/plugins.rst:449
msgid ""
"Provides the same as ``aiida_profile_clean`` but with ``scope=class``. "
"Should be used for a test class:"
msgstr ""

#: ../../source/topics/plugins.rst:460
msgid "The storage is cleaned once when the class is initialized."
msgstr ""

#: ../../source/topics/plugins.rst:466
msgid "``aiida_profile_factory``"
msgstr ""

#: ../../source/topics/plugins.rst:468
msgid ""
"Create a temporary profile, add it to the config of the loaded AiiDA "
"instance and load the profile. Can be useful to create a test profile for a "
"custom storage backend:"
msgstr ""

#: ../../source/topics/plugins.rst:488
msgid ""
"Note that the configuration above is not actually functional and the actual "
"configuration depends on the storage implementation that is used."
msgstr ""

#: ../../source/topics/plugins.rst:494
msgid "``aiida_instance``"
msgstr ""

#: ../../source/topics/plugins.rst:496
msgid ""
"Return the :class:`~aiida.manage.configuration.config.Config` instance that "
"is used for the test session."
msgstr ""

#: ../../source/topics/plugins.rst:507
msgid "``config_psql_dos``"
msgstr ""

#: ../../source/topics/plugins.rst:509
msgid ""
"Return a profile configuration for the "
":class:`~aiida.storage.psql_dos.backend.PsqlDosBackend`. This can be used in"
" combination with the ``aiida_profile_factory`` fixture to create a test "
"profile with customised database parameters:"
msgstr ""

#: ../../source/topics/plugins.rst:522
msgid ""
"Note that this is only useful if the storage configuration needs to be "
"customized. If any configuration works, simply use the ``aiida_profile`` "
"fixture straight away, which uses the ``PsqlDosStorage`` storage backend by "
"default."
msgstr ""

#: ../../source/topics/plugins.rst:529
msgid "``postgres_cluster``"
msgstr ""

#: ../../source/topics/plugins.rst:531
msgid ""
"Create a temporary and isolated PostgreSQL cluster using ``pgtest`` and "
"cleanup after the yield."
msgstr ""

#: ../../source/topics/plugins.rst:547
msgid "``aiida_localhost``"
msgstr ""

#: ../../source/topics/plugins.rst:549
msgid ""
"This test is useful if a test requires a "
":class:`~aiida.orm.computers.Computer` instance. This fixture returns a "
":class:`~aiida.orm.computers.Computer` that represents the ``localhost``."
msgstr ""

#: ../../source/topics/plugins.rst:561
msgid "``aiida_local_code_factory``"
msgstr ""

#: ../../source/topics/plugins.rst:563
msgid ""
"This test is useful if a test requires an "
":class:`~aiida.orm.nodes.data.code.installed.InstalledCode` instance. For "
"example:"
msgstr ""

#: ../../source/topics/plugins.rst:574
msgid ""
"By default, it will use the ``localhost`` computer returned by the "
"``aiida_localhost`` fixture."
msgstr ""

#: ../../source/topics/plugins.rst:580
msgid "``aiida_computer``"
msgstr ""

#: ../../source/topics/plugins.rst:582
msgid ""
"This fixture should be used to create and configure a "
":class:`~aiida.orm.computers.Computer` instance. The fixture provides a "
"factory that can be called without any arguments:"
msgstr ""

#: ../../source/topics/plugins.rst:592
msgid ""
"By default, the localhost is used for the hostname and a random label is "
"generated."
msgstr ""

#: ../../source/topics/plugins.rst:601
msgid ""
"First the database is queried to see if a computer with the given label "
"already exist. If found, the existing computer is returned, otherwise a new "
"instance is created."
msgstr ""

#: ../../source/topics/plugins.rst:604
msgid ""
"The returned computer is also configured for the current default user. The "
"configuration can be customized through the ``configuration_kwargs`` "
"dictionary:"
msgstr ""

#: ../../source/topics/plugins.rst:618
msgid "``aiida_computer_local``"
msgstr ""

#: ../../source/topics/plugins.rst:620
msgid ""
"This fixture is a shortcut for ``aiida_computer`` to setup the localhost "
"with local transport:"
msgstr ""

#: ../../source/topics/plugins.rst:629
msgid ""
"To leave a newly created computer unconfigured, pass ``configure=False``:"
msgstr ""

#: ../../source/topics/plugins.rst:637 ../../source/topics/plugins.rst:671
msgid ""
"Note that if the computer already exists and was configured before, it won't"
" be unconfigured. If you need a guarantee that the computer is not "
"configured, make sure to clean the database before the test or use a unique "
"label:"
msgstr ""

#: ../../source/topics/plugins.rst:651
msgid "``aiida_computer_ssh``"
msgstr ""

#: ../../source/topics/plugins.rst:653
msgid ""
"This fixture is a shortcut for ``aiida_computer`` to setup the localhost "
"with SSH transport:"
msgstr ""

#: ../../source/topics/plugins.rst:662
msgid ""
"This can be useful if the functionality that needs to be tested involves "
"testing the SSH transport, but these use-cases should be rare outside of "
"`aiida-core`. To leave a newly created computer unconfigured, pass "
"``configure=False``:"
msgstr ""

#: ../../source/topics/plugins.rst:685
msgid "``submit_and_await``"
msgstr ""

#: ../../source/topics/plugins.rst:687
msgid ""
"This fixture is useful when testing submitting a process to the daemon. It "
"submits the process to the daemon and will wait until it has reached a "
"certain state. By default it will wait for the process to reach "
"``ProcessState.FINISHED``:"
msgstr ""

#: ../../source/topics/plugins.rst:701
msgid ""
"Note that the fixture automatically depends on the ``started_daemon_client``"
" fixture to guarantee the daemon is running."
msgstr ""

#: ../../source/topics/plugins.rst:707
msgid "``started_daemon_client``"
msgstr ""

#: ../../source/topics/plugins.rst:709
msgid ""
"This fixture ensures that the daemon for the test profile is running and "
"returns an instance of the :class:`~aiida.engine.daemon.client.DaemonClient`"
" which can be used to control the daemon."
msgstr ""

#: ../../source/topics/plugins.rst:720
msgid "``stopped_daemon_client``"
msgstr ""

#: ../../source/topics/plugins.rst:722
msgid ""
"This fixture ensures that the daemon for the test profile is stopped and "
"returns an instance of the :class:`~aiida.engine.daemon.client.DaemonClient`"
" which can be used to control the daemon."
msgstr ""

#: ../../source/topics/plugins.rst:733
msgid "``daemon_client``"
msgstr ""

#: ../../source/topics/plugins.rst:735
msgid ""
"Return a :class:`~aiida.engine.daemon.client.DaemonClient` instance that can"
" be used to control the daemon:"
msgstr ""

#: ../../source/topics/plugins.rst:744
msgid ""
"The fixture is session scoped. At the end of the test session, this fixture "
"automatically shuts down the daemon if it is still running."
msgstr ""

#: ../../source/topics/plugins.rst:751
msgid "``entry_points``"
msgstr ""

#: ../../source/topics/plugins.rst:753
msgid ""
"Return a :class:`~aiida.manage.tests.pytest_fixtures.EntryPointManager` "
"instance to add and remove entry points."
msgstr ""

#: ../../source/topics/plugins.rst:769
msgid ""
"Any entry points additions and removals are automatically undone at the end "
"of the test."
msgstr ""

#: ../../source/topics/processes/concepts.rst:7
msgid ""
"Anything that runs in AiiDA is an instance of the "
":py:class:`~aiida.engine.processes.process.Process` class. The ``Process`` "
"class contains all the information and logic to tell, whoever is handling "
"it, how to run it to completion. Typically the one responsible for running "
"the processes is an instance of a :py:class:`~aiida.engine.runners.Runner`. "
"This can be a local runner or one of the daemon runners in case of the "
"daemon running the process."
msgstr ""

#: ../../source/topics/processes/concepts.rst:12
msgid ""
"In addition to those run instructions, any ``Process`` that has been "
"executed needs some sort of record in the database to store what happened "
"during its execution. For example it needs to record what its exact inputs "
"were, the log messages that were reported and what the final outputs were. "
"For this purpose, every process will utilize an instance of a sub class of "
"the :py:class:`~aiida.orm.ProcessNode` class. This ``ProcessNode`` class is "
"a sub class of :py:class:`~aiida.orm.Node` and serves as the record of the "
"process' execution in the database and by extension the provenance graph."
msgstr ""

#: ../../source/topics/processes/concepts.rst:17
msgid ""
"It is very important to understand this division of labor. A ``Process`` "
"describes how something should be run, and the ``ProcessNode`` serves as a "
"mere record in the database of what actually happened during execution. A "
"good thing to remember is that while it is running, we are dealing with the "
"``Process`` and when it is finished we interact with the ``ProcessNode``."
msgstr ""

#: ../../source/topics/processes/concepts.rst:24
msgid "Process types"
msgstr ""

#: ../../source/topics/processes/concepts.rst:26
msgid "Processes in AiiDA come in two flavors:"
msgstr ""

#: ../../source/topics/processes/concepts.rst:28
msgid "Calculation-like"
msgstr ""

#: ../../source/topics/processes/concepts.rst:29
msgid "Workflow-like"
msgstr ""

#: ../../source/topics/processes/concepts.rst:31
msgid ""
"The calculation-like processes have the capability to *create* data, whereas"
" the workflow-like processes orchestrate other processes and have the "
"ability to *return* data produced by calculations. Again, this is a "
"distinction that plays a big role in AiiDA and is crucial to understand. For"
" this reason, these different types of processes also get a different sub "
"class of the ``ProcessNode`` class. The hierarchy of these node classes and "
"the link types that are allowed between them and ``Data`` nodes, is "
"explained in detail in the :ref:`provenance "
"implementation<topics:provenance:implementation>` documentation."
msgstr ""

#: ../../source/topics/processes/concepts.rst:36
msgid ""
"Currently, there are four types of processes in ``aiida-core`` and the "
"following table shows with which node class it is represented in the "
"provenance graph and what the process is used for."
msgstr ""

#: ../../source/topics/processes/concepts.rst:39
msgid "Process class"
msgstr ""

#: ../../source/topics/processes/concepts.rst:39
msgid "Node class"
msgstr ""

#: ../../source/topics/processes/concepts.rst:39
msgid "Used for"
msgstr ""

#: ../../source/topics/processes/concepts.rst:41
msgid ":py:class:`~aiida.engine.processes.calcjobs.calcjob.CalcJob`"
msgstr ""

#: ../../source/topics/processes/concepts.rst:41
msgid ":py:class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode`"
msgstr ""

#: ../../source/topics/processes/concepts.rst:41
msgid "Calculations performed by external codes"
msgstr ""

#: ../../source/topics/processes/concepts.rst:42
msgid ":py:class:`~aiida.engine.processes.workchains.workchain.WorkChain`"
msgstr ""

#: ../../source/topics/processes/concepts.rst:42
msgid ":py:class:`~aiida.orm.nodes.process.workflow.workchain.WorkChainNode`"
msgstr ""

#: ../../source/topics/processes/concepts.rst:42
msgid "Workflows that run multiple calculations"
msgstr ""

#: ../../source/topics/processes/concepts.rst:43
#: ../../source/topics/processes/concepts.rst:44
msgid ":py:class:`~aiida.engine.processes.functions.FunctionProcess`"
msgstr ""

#: ../../source/topics/processes/concepts.rst:43
msgid ""
":py:class:`~aiida.orm.nodes.process.calculation.calcfunction.CalcFunctionNode`"
msgstr ""

#: ../../source/topics/processes/concepts.rst:43
msgid "Python functions decorated with the ``@calcfunction`` decorator"
msgstr ""

#: ../../source/topics/processes/concepts.rst:44
msgid ""
":py:class:`~aiida.orm.nodes.process.workflow.workfunction.WorkFunctionNode`"
msgstr ""

#: ../../source/topics/processes/concepts.rst:44
msgid "Python functions decorated with the ``@workfunction`` decorator"
msgstr ""

#: ../../source/topics/processes/concepts.rst:47
msgid ""
"For basic information on the concept of a ``CalcJob`` or ``calcfunction``, "
"refer to the :ref:`calculations concept<topics:calculations:concepts>` The "
"``WorkChain`` and ``workfunction`` are described in the :ref:`workflows "
"concept<topics:workflows:concepts>`. After having read and understood the "
"basic concept of calculation and workflow processes, detailed information on"
" how to implement and use them can be found in the dedicated developing "
"sections for :ref:`calculations<topics:calculations:usage>` and "
":ref:`workflows<topics:workflows:usage>`, respectively."
msgstr ""

#: ../../source/topics/processes/concepts.rst:51
msgid ""
"A ``FunctionProcess`` is never explicitly implemented but will be generated "
"dynamically by the engine when a python function decorated with a "
":py:func:`~aiida.engine.processes.functions.calcfunction` or "
":py:func:`~aiida.engine.processes.functions.workfunction` is run."
msgstr ""

#: ../../source/topics/processes/concepts.rst:57
msgid "Process state"
msgstr ""

#: ../../source/topics/processes/concepts.rst:58
msgid ""
"Each instance of a ``Process`` class that is being executed has a process "
"state. This property tells you about the current status of the process. It "
"is stored in the instance of the ``Process`` itself and the workflow engine,"
" the ``plumpy`` library, operates only on that value. However, the "
"``Process`` instance 'dies' as soon as it is terminated, therefore the "
"process state is also written to the calculation node that the process uses "
"as its database record, under the ``process_state`` attribute. The process "
"can be in one of six states:"
msgstr ""

#: ../../source/topics/processes/concepts.rst:65
msgid "*Active*"
msgstr ""

#: ../../source/topics/processes/concepts.rst:65
msgid "*Terminated*"
msgstr ""

#: ../../source/topics/processes/concepts.rst:67
msgid "Created"
msgstr ""

#: ../../source/topics/processes/concepts.rst:67
msgid "Killed"
msgstr ""

#: ../../source/topics/processes/concepts.rst:68
msgid "Running"
msgstr ""

#: ../../source/topics/processes/concepts.rst:68
msgid "Excepted"
msgstr ""

#: ../../source/topics/processes/concepts.rst:69
msgid "Waiting"
msgstr ""

#: ../../source/topics/processes/concepts.rst:69
msgid "Finished"
msgstr ""

#: ../../source/topics/processes/concepts.rst:72
msgid ""
"The three states in the left column are 'active' states, whereas the right "
"column displays the three 'terminal' states. Once a process reaches a "
"terminal state, it will never leave it; its execution is permanently "
"terminated. When a process is first created, it is put in the ``Created`` "
"state. As soon as it is picked up by a runner and it is active, it will be "
"in the ``Running`` state. If the process is waiting for another process, "
"that it called, to be finished, it will be in the ``Waiting`` state. If a "
"process is in the ``Killed`` state, it means the user issued a command to "
"kill it, or its parent process was killed. The ``Excepted`` state indicates "
"that during execution an exception occurred that was not caught and the "
"process was unexpectedly terminated. The final option is the ``Finished`` "
"state, which means that the process was successfully executed, and the "
"execution was nominal. Note that this does not automatically mean that the "
"result of the process can also be considered to be successful, it was just "
"executed without any problems."
msgstr ""

#: ../../source/topics/processes/concepts.rst:82
msgid ""
"To distinguish between a successful and a failed execution, there is the "
":ref:`exit status<topics:processes:concepts:exit_codes>`. This is another "
"attribute that is stored in the node of the process and is an integer that "
"can be set by the process. A ``0`` (zero) means that the result of the "
"process was successful, and a non-zero value indicates a failure. All the "
"process nodes used by the various processes are sub-classes of "
":py:class:`~aiida.orm.ProcessNode`, which defines handy properties to query "
"the process state and exit status."
msgstr ""

#: ../../source/topics/processes/concepts.rst:88
msgid "Property"
msgstr ""

#: ../../source/topics/processes/concepts.rst:88
msgid "Meaning"
msgstr ""

#: ../../source/topics/processes/concepts.rst:90
msgid "``process_state``"
msgstr ""

#: ../../source/topics/processes/concepts.rst:90
msgid "Returns the current process state"
msgstr ""

#: ../../source/topics/processes/concepts.rst:91
msgid "``exit_status``"
msgstr ""

#: ../../source/topics/processes/concepts.rst:91
msgid "Returns the exit status, or None if not set"
msgstr ""

#: ../../source/topics/processes/concepts.rst:92
msgid "``exit_message``"
msgstr ""

#: ../../source/topics/processes/concepts.rst:92
msgid "Returns the exit message, or None if not set"
msgstr ""

#: ../../source/topics/processes/concepts.rst:93
msgid "``is_terminated``"
msgstr ""

#: ../../source/topics/processes/concepts.rst:93
msgid ""
"Returns ``True`` if the process was either ``Killed``, ``Excepted``, or "
"``Finished``"
msgstr ""

#: ../../source/topics/processes/concepts.rst:94
msgid "``is_killed``"
msgstr ""

#: ../../source/topics/processes/concepts.rst:94
msgid "Returns ``True`` if the process is ``Killed``"
msgstr ""

#: ../../source/topics/processes/concepts.rst:95
msgid "``is_excepted``"
msgstr ""

#: ../../source/topics/processes/concepts.rst:95
msgid "Returns ``True`` if the process is ``Excepted``"
msgstr ""

#: ../../source/topics/processes/concepts.rst:96
msgid "``is_finished``"
msgstr ""

#: ../../source/topics/processes/concepts.rst:96
msgid "Returns ``True`` if the process is ``Finished``"
msgstr ""

#: ../../source/topics/processes/concepts.rst:97
msgid "``is_finished_ok``"
msgstr ""

#: ../../source/topics/processes/concepts.rst:97
msgid ""
"Returns ``True`` if the process is ``Finished`` and the ``exit_status`` is "
"equal to zero"
msgstr ""

#: ../../source/topics/processes/concepts.rst:98
msgid "``is_failed``"
msgstr ""

#: ../../source/topics/processes/concepts.rst:98
msgid ""
"Returns ``True`` if the process is ``Finished`` and the ``exit_status`` is "
"non-zero"
msgstr ""

#: ../../source/topics/processes/concepts.rst:101
msgid ""
"When you load a calculation node from the database, you can use these "
"property methods to inquire about its state and exit status."
msgstr ""

#: ../../source/topics/processes/concepts.rst:107
msgid "Process exit codes"
msgstr ""

#: ../../source/topics/processes/concepts.rst:109
msgid ""
"The previous section about the process state showed that a process that is "
"``Finished`` does not say anything about whether the result is 'successful' "
"or 'failed'. The ``Finished`` state means nothing more than that the engine "
"succeeded in running the process to the end of execution, without it "
"encountering exceptions or being killed. To distinguish between a "
"'successful' and 'failed' process, an 'exit status' can be defined. The "
"`exit status is a common concept in programming "
"<https://en.wikipedia.org/wiki/Exit_status>`_ and is a small integer, where "
"zero means that the result of the process was successful, and a non-zero "
"value indicates a failure. By default a process that terminates nominally "
"will get a ``0`` (zero) exit status. To mark a process as failed, one can "
"return an instance of the "
":py:class:`~aiida.engine.processes.exit_code.ExitCode` named tuple, which "
"allows to set an integer ``exit_status`` and a string message as "
"``exit_message``. When the engine receives such an ``ExitCode`` as the "
"return value from a process, it will set the exit status and message on the "
"corresponding attributes of the process node representing the process in the"
" provenance graph."
msgstr ""

#: ../../source/topics/processes/concepts.rst:119
msgid ""
"For how exit codes can be defined and returned see the :ref:`exit code usage"
" section <topics:processes:usage:exit_codes>`."
msgstr ""

#: ../../source/topics/processes/concepts.rst:124
msgid "Process lifetime"
msgstr ""

#: ../../source/topics/processes/concepts.rst:126
msgid ""
"The lifetime of a process is defined as the time from the moment it is "
"launched until it reaches a :ref:`terminal "
"state<topics:processes:concepts:state>`."
msgstr ""

#: ../../source/topics/processes/concepts.rst:131
msgid "Process and node distinction"
msgstr ""

#: ../../source/topics/processes/concepts.rst:132
msgid ""
"As explained in the :ref:`introduction of this "
"section<topics:processes:concepts>`, there is a clear and important "
"distinction between the 'process' and the 'node' that represents its "
"execution in the provenance graph. When a process is launched, an instance "
"of the ``Process`` class is created in memory which will be propagated to "
"completion by the responsible runner. This 'process' instance only exists in"
" the memory of the python interpreter that it is running in, for example "
"that of a daemon runner, and so we cannot directly inspect its state. That "
"is why the process will write any of its state changes to the corresponding "
"node representing it in the provenance graph. In this way, the node acts as "
"a 'proxy' or a mirror image that reflects the state of the process in "
"memory. This means that the output of many of the ``verdi`` commands, such "
"as ``verdi process list``, do not actually show the state of the process "
"instances, but rather the state of the node to which they have last written "
"their state."
msgstr ""

#: ../../source/topics/processes/concepts.rst:140
msgid "Process tasks"
msgstr ""

#: ../../source/topics/processes/concepts.rst:141
msgid ""
"The previous section explained how launching a process means creating an "
"instance of the ``Process`` class in memory. When the process is being 'run'"
" (see the section on :ref:`launching "
"processes<topics:processes:usage:launch>` for more details) that is to say "
"in a local interpreter, the particular process instance will die as soon as "
"the interpreter dies. This is what often makes 'submitting' the preferred "
"method of launching a process. When a process is 'submitted', an instance of"
" the ``Process`` is created, along with the node that represents it in the "
"database, and its state is then persisted (stored) in the database. This is "
"called a 'process checkpoint', more information on which :ref:`will follow "
"later<topics:processes:concepts:checkpoints>`. Subsequently, the process "
"instance is shut down and a 'continuation task' is sent to the process queue"
" of RabbitMQ. This task is simply a small message that just contains an "
"identifier for the process. In order to reconstruct the process from a "
"`checkpoint`, the process needs to be importable in the daemon environment "
"by a) giving it an :ref:`associated entry point<how-to:plugin-codes:entry-"
"points>` or b) :ref:`including its module path<how-to:faq:process-not-"
"importable-daemon>` in the ``PYTHONPATH`` that the daemon workers will have."
msgstr ""

#: ../../source/topics/processes/concepts.rst:150
msgid ""
"All the daemon runners, when they are launched, subscribe to the process "
"queue and RabbitMQ will distribute the continuation tasks to them as they "
"come in, making sure that each task is only sent to one runner at a time. "
"The receiving daemon runner can restore the process instance in memory from "
"the checkpoint that was stored in the database and continue the execution. "
"As soon as the process reaches a terminal state, the daemon runner will "
"acknowledge to RabbitMQ that the task has been completed. Until the runner "
"has confirmed that a task is completed, RabbitMQ will consider the task as "
"incomplete. If a daemon runner is shut down or dies before it got the chance"
" to finish running a process, the task will automatically be requeued by "
"RabbitMQ and sent to another daemon runner. Together with the fact that all "
"the tasks in the process queue are persisted to disk by RabbitMQ, guarantees"
" that once a continuation task has been sent to RabbitMQ, it will at some "
"point be finished, while allowing the machine to be shut down."
msgstr ""

#: ../../source/topics/processes/concepts.rst:157
msgid ""
"Each daemon runner has a maximum number of tasks that it can run "
"concurrently, which means that if there are more active tasks than available"
" slots, some of the tasks will remain queued. Processes, whose task is in "
"the queue and not with any runner, though technically 'active' as they are "
"not terminated, are not actually being run at the moment. While a process is"
" not actually being run, i.e. it is not in memory with a runner, one cannot "
"interact with it. Similarly, as soon as the task disappears, either because "
"the process was intentionally terminated (or unintentionally), the process "
"will never continue running again."
msgstr ""

#: ../../source/topics/processes/concepts.rst:164
msgid "A systems modelling representation of submitting a process."
msgstr ""

#: ../../source/topics/processes/concepts.rst:170
msgid "Process checkpoints"
msgstr ""

#: ../../source/topics/processes/concepts.rst:171
msgid ""
"A process checkpoint is a complete representation of a ``Process`` instance "
"in memory that can be stored in the database. Since it is a complete "
"representation, the ``Process`` instance can also be fully reconstructed "
"from such a checkpoint. At any state transition of a process, a checkpoint "
"will be created, by serializing the process instance and storing it as an "
"attribute on the corresponding process node. This mechanism is the final cog"
" in the machine, together with the persisted process queue of RabbitMQ as "
"explained in the previous section, that allows processes to continue after "
"the machine they were running on, has been shut down and restarted."
msgstr ""

#: ../../source/topics/processes/concepts.rst:180
msgid "Process sealing"
msgstr ""

#: ../../source/topics/processes/concepts.rst:181
msgid ""
"One of the cardinal rules of AiiDA is that once a node is *stored*, it is "
"immutable, which means that its attributes can no longer be changed. This "
"rule is a problem for processes, however, since in order to be able to start"
" running it, its corresponding process node first has to be stored. However,"
" at that point its attributes, such as the process state or other mutable "
"attributes, can no longer be changed by the engine throughout the lifetime "
"of the corresponding process. To overcome this limitation, the concept of "
"*updatable* attributes is introduced. These are special attributes that are "
"allowed to be changed *even* when the process node is already stored *and* "
"the corresponding process is still active. To mark the point where a process"
" is terminated and even the updatable attributes on the process node are to "
"be considered immutable, the node is *sealed*. A sealed process node behaves"
" exactly like a normal stored node, as in *all* of its attributes are "
"immutable. In addition, once a process node is sealed, no more incoming or "
"outgoing links can be attached to it. Unsealed process nodes can also not be"
" exported, because they belong to processes that are still active. Note that"
" the sealing concept does not apply to data nodes and they are exportable as"
" soon as they are stored. To determine whether a process node is sealed, one"
" can use the property :py:attr:`~aiida.orm.utils.mixins.Sealable.is_sealed`."
msgstr ""

#: ../../source/topics/processes/functions.rst:5
msgid "Process functions"
msgstr ""

#: ../../source/topics/processes/functions.rst:7
msgid ""
"A process function is a process (see the "
":ref:`concepts<topics:processes:concepts>` for a definition and explanation)"
" that is implemented as a decorated python function. Currently, there are "
"two types of process functions:"
msgstr ""

#: ../../source/topics/processes/functions.rst:11
msgid ":ref:`work function<topics:workflows:concepts:workfunctions>`"
msgstr ""

#: ../../source/topics/processes/functions.rst:13
msgid ""
"The former can *create* new data, whereas the latter can orchestrate other "
"processes and *return* their results. This section will provide detailed "
"information and best practices on how to implement these two process types. "
"Since the calculation function and work function are both process functions "
"and have the same implementation, all the rules explained below apply to "
"both process types."
msgstr ""

#: ../../source/topics/processes/functions.rst:17
msgid ""
"The simple example in the :ref:`introductory section on calculation "
"functions<topics:calculations:concepts:calcfunctions>` showed how a simple "
"python function can be turned into a calculation function simply by adorning"
" it with the :py:func:`~aiida.engine.processes.functions.calcfunction` "
"decorator. When the function is run, AiiDA will dynamically generate a "
":py:class:`~aiida.engine.processes.functions.FunctionProcess` and build its "
":ref:`process specification<topics:processes:usage:spec>` based on the "
"function signature. Here we will explain how this is accomplished and what "
"features of the python function signature standard are supported."
msgstr ""

#: ../../source/topics/processes/functions.rst:22
msgid "Function signatures"
msgstr ""

#: ../../source/topics/processes/functions.rst:23
msgid ""
"To explain what features of python function definitions and calls are "
"supported we first need to be clear about some terminology. When dealing "
"with functions, there are two distinct parts:"
msgstr ""

#: ../../source/topics/processes/functions.rst:26
msgid ""
"`function definitions "
"<https://docs.python.org/3/reference/compound_stmts.html#function-"
"definitions>`_"
msgstr ""

#: ../../source/topics/processes/functions.rst:27
msgid ""
"`function calls "
"<https://docs.python.org/3/reference/expressions.html#calls>`_"
msgstr ""

#: ../../source/topics/processes/functions.rst:29
msgid ""
"Consider the following code snippet that defines a simple python function:"
msgstr ""

#: ../../source/topics/processes/functions.rst:34
msgid ""
"The function takes three 'parameters', named ``x``, ``y`` and ``z``. In "
"addition, the function ``plain_function`` is said to have default values, "
"because one or more parameters (``z`` in this case) have the form `parameter"
" = expression`. When *calling* a function, the terminology changes slightly "
"and values for parameters can be passed as either 'positional' or 'keyword'."
" In the example below, the function is called with 'positional' arguments:"
msgstr ""

#: ../../source/topics/processes/functions.rst:42
msgid ""
"They are called positional, because the arguments are not explicitly named "
"and so will be matched to the corresponding parameter solely based on their "
"position in the function call. In this example, ``x``, ``y`` and ``z`` will "
"have the values ``1``, ``2`` and ``3``, respectively. Since we specified "
"three values, the default for the third parameter ``z`` was not actually "
"used. However, we are allowed to only specify two arguments, in which case "
"the default *will* be used as can be seen below:"
msgstr ""

#: ../../source/topics/processes/functions.rst:50
msgid ""
"By not specifying the third argument, the default will be used, so in this "
"case ``z`` will equal ``1``. Additionally, one can employ 'named' arguments "
"to specifically target a parameter based on its name, instead of having to "
"rely on its position:"
msgstr ""

#: ../../source/topics/processes/functions.rst:56
msgid ""
"Notice how the order in which we pass the arguments is irrelevant because we"
" specify the name of each argument explicitly when assigning the value. Now "
"that we know the difference between positional and named arguments, it is "
"important to realize a python requirement that **positional arguments have "
"to come before named arguments**. What this means is that *both* the "
"function definition and function call below are illegal, because there are "
"named arguments before positional ones:"
msgstr ""

#: ../../source/topics/processes/functions.rst:63
msgid ""
"Finally, python knows the concept of ``*args`` and ``**kwargs``, which allow"
" one to define a function that accepts a variable number of positional and "
"keyword arguments (also known as a _variadic_ function)."
msgstr ""

#: ../../source/topics/processes/functions.rst:68
msgid ""
"The placeholder for positional arguments ``*args`` receives the positionally"
" passed arguments as a tuple, while ``**kwargs`` receives the named "
"arguments as a dictionary. With the formal definitions out of the way, let's"
" now see which of these concepts are supported by process functions."
msgstr ""

#: ../../source/topics/processes/functions.rst:72
msgid "Default arguments"
msgstr ""

#: ../../source/topics/processes/functions.rst:73
msgid ""
"Default arguments are supported by calculation functions just as normal "
"python functions as long as it is a :py:class:`~aiida.orm.nodes.node.Node` "
"instance, just like the inputs or ``None``. However, just as with python "
"functions, one should only use immutable objects as function defaults "
"because mutable objects can give unexpected results as they will be kept "
"between function calls. Therefore, in order to use a default value for "
"process functions, simply use ``None`` as the default value and check for "
"its presence in the function body settings the default value if it is "
"``None``. This pattern looks like the following:"
msgstr ""

#: ../../source/topics/processes/functions.rst:81
msgid ""
"Both function calls in the example above will have the exact same result."
msgstr ""

#: ../../source/topics/processes/functions.rst:84
msgid "Variadic arguments"
msgstr ""

#: ../../source/topics/processes/functions.rst:86
msgid ""
"Keyword arguments can be used effectively if a process function should take "
"a number of arguments that is unknown beforehand:"
msgstr ""

#: ../../source/topics/processes/functions.rst:91
msgid "The provenance generated by this example looks like the following:"
msgstr ""

#: ../../source/topics/processes/functions.rst:96
msgid ""
"The link labels of the inputs are determined based on the naming of the "
"parameters when the function is called."
msgstr ""

#: ../../source/topics/processes/functions.rst:98
msgid ""
"Note that the inputs **have to be passed as keyword arguments** because they"
" are used for the link labels."
msgstr ""

#: ../../source/topics/processes/functions.rst:102
msgid "Variadic positional arguments are now supported."
msgstr ""

#: ../../source/topics/processes/functions.rst:104
msgid ""
"Variadic positional arguments can be used in case the function should accept"
" a list of inputs of unknown length. Consider the example of a calculation "
"function that computes the average of a number of ``Int`` nodes:"
msgstr ""

#: ../../source/topics/processes/functions.rst:110
msgid ""
"The result will be a ``Float`` node with value ``2``. Since in this example "
"the arguments are not explicitly declared in the function signature, nor are"
" their values passed with a keyword in the function invocation, AiiDA needs "
"to come up with a different way to determine the labels to link the input "
"nodes to the calculation. For variadic arguments, link labels are created "
"from the variable argument declaration (``*args`` in the example), followed "
"by an index. The link labels for the example above will therefore be "
"``args_0``, ``args_1`` and ``args_2``. If any of these labels were to "
"overlap with the label of a positional or keyword argument, a "
"``RuntimeError`` will be raised. In this case, the conflicting argument name"
" needs to be changed to something that does not overlap with the "
"automatically generated labels for the variadic arguments."
msgstr ""

#: ../../source/topics/processes/functions.rst:120
msgid "Type validation"
msgstr ""

#: ../../source/topics/processes/functions.rst:124
msgid ""
"Type hints (introduced with `PEP 484 <https://peps.python.org/pep-0484/>`_ "
"in Python 3.5) can be used to add automatic type validation of process "
"function arguments. For example, the following will raise a ``ValueError`` "
"exception:"
msgstr ""

#: ../../source/topics/processes/functions.rst:130
msgid ""
"When the process function is declared, the process specification "
"(``ProcessSpec``) is built dynamically. For each function argument, if a "
"correct type hint is provided, it is set as the ``valid_type`` attribute of "
"the corresponding input port. In the example above, the ``x`` and ``y`` "
"inputs have ``Int`` as type hint, which is why the call that passes a "
"``Float`` raises a ``ValueError``."
msgstr ""

#: ../../source/topics/processes/functions.rst:136
msgid "Type hints for return values are currently not parsed."
msgstr ""

#: ../../source/topics/processes/functions.rst:138
msgid ""
"If an argument accepts multiple types, the ``typing.Union`` class can be "
"used as normal:"
msgstr ""

#: ../../source/topics/processes/functions.rst:143
msgid ""
"The call with an ``Int`` and a ``Float`` will now finish correctly. "
"Similarly, optional arguments, with ``None`` as a default, can be declared "
"using ``typing.Optional``:"
msgstr ""

#: ../../source/topics/processes/functions.rst:149
msgid ""
"The `postponed evaluation of annotations introduced by PEP 563 "
"<https://peps.python.org/pep-0563/>`_ is also supported. This means it is "
"possible to use Python base types for the type hint instead of AiiDA's "
"``Data`` node equivalent:"
msgstr ""

#: ../../source/topics/processes/functions.rst:155
msgid ""
"The type hints are automatically serialized just as the actual inputs are "
"when the function is called, :ref:`as introduced in "
"v2.1<topics:calculations:concepts:calcfunctions:automatic-serialization>`."
msgstr ""

#: ../../source/topics/processes/functions.rst:157
msgid ""
"The alternative syntax for union types ``X | Y`` `as introduced by PEP 604 "
"<https://peps.python.org/pep-0604/>`_ is also supported:"
msgstr ""

#: ../../source/topics/processes/functions.rst:164
msgid ""
"The usage of notation as defined by PEP 563 and PEP 604 are not supported "
"for Python versions older than 3.10, even if the ``from __future__ import "
"annotations`` statement is added. The reason is that the type inference uses"
" the `inspect.get_annotations "
"<https://docs.python.org/3/library/inspect.html#inspect.get_annotations>`_ "
"method, which was introduced in Python 3.10. For older Python versions, the "
"`get-annotations <https://pypi.org/project/get-annotations>`_ backport is "
"used, but that does not work with PEP 563 and PEP 604, so the constructs "
"from the ``typing`` module have to be used instead."
msgstr ""

#: ../../source/topics/processes/functions.rst:168
msgid ""
"If a process function has invalid type hints, they will simply be ignored "
"and a warning message is logged: ``function 'function_name' has invalid type"
" hints``. This ensures backwards compatibility in the case existing process "
"functions had invalid type hints."
msgstr ""

#: ../../source/topics/processes/functions.rst:174
msgid "Docstring parsing"
msgstr ""

#: ../../source/topics/processes/functions.rst:178
msgid ""
"If a process function provides a docstring, AiiDA will attempt to parse it. "
"If successful, the function argument descriptions will be set as the "
"``help`` attributes of the input ports of the dynamically generated process "
"specification. This means the descriptions of the function arguments can be "
"retrieved programmatically from the process specification (as returned by "
"the ``spec`` classmethod):"
msgstr ""

#: ../../source/topics/processes/functions.rst:185
msgid ""
"This particularly useful when exposing a process function in a wrapping "
"workchain:"
msgstr ""

#: ../../source/topics/processes/functions.rst:190
msgid ""
"The user can now access the input description directly through the spec of "
"the work chain, without having to go to the process function itself. For "
"example, in an interactive shell:"
msgstr ""

#: ../../source/topics/processes/functions.rst:197
msgid "Return values"
msgstr ""

#: ../../source/topics/processes/functions.rst:198
msgid ""
"In :numref:`fig_calculation_functions_kwargs` you can see that the engine "
"used the label ``result`` for the link connecting the calculation function "
"node with its output node. This is the default link label if only a single "
"result is returned from the calculation function. If you want to specify a "
"label yourself, you can return the result in the form of a dictionary, where"
" the key will be used as the link label. By using a dictionary you can also "
"record multiple nodes as output. Consider the following snippet:"
msgstr ""

#: ../../source/topics/processes/functions.rst:207
msgid ""
"The provenance generated by running this calculation function will look "
"like:"
msgstr ""

#: ../../source/topics/processes/functions.rst:212
msgid ""
"If a dictionary is returned, the keys will be used as the labels for the "
"links that connect the output nodes with the calculation node."
msgstr ""

#: ../../source/topics/processes/functions.rst:214
msgid ""
"As always, all the values returned by a calculation function have to be "
"storable, which means they have to be instances of the "
":py:class:`~aiida.orm.nodes.node.Node` class."
msgstr ""

#: ../../source/topics/processes/functions.rst:217
msgid ""
"It is very important that you **do not call** "
":py:meth:`~aiida.orm.nodes.node.Node.store` **yourself** on the nodes before"
" returning them from a ``calcfunction``. Because of the calculation/workflow"
" duality in AiiDA, a ``calcfunction``, which is a calculation-like process, "
"can only *create* and not *return* data nodes. This means that if a node is "
"returned from a ``calcfunction`` that *is already stored*, the engine will "
"throw an exception."
msgstr ""

#: ../../source/topics/processes/functions.rst:223
msgid "Outputs can be attached with nested namespaces in the output labels:"
msgstr ""

#: ../../source/topics/processes/functions.rst:231
#: ../../source/topics/processes/usage.rst:228
#: ../../source/topics/workflows/usage.rst:108
#: ../../source/topics/workflows/usage.rst:273
msgid "Exit codes"
msgstr ""

#: ../../source/topics/processes/functions.rst:232
msgid ""
"So far we have only seen examples of calculation functions where everything "
"works out just fine. However, the real world is different, and often we will"
" encounter situations where problems arise. A calculation function may "
"receive incorrect or incoherent inputs, or the code it executes may throw an"
" exception. Of course we could throw an input validation exception or not "
"even catch the exceptions that the code we call throws, but that will lead "
"the function process to be put in the ``Excepted`` terminal state. As "
"explained in the :ref:`process state<topics:processes:concepts:state>` "
"section, this state is indeed reserved for processes that incurred an "
"exception during execution. Consider the following calculation function "
"definition and call:"
msgstr ""

#: ../../source/topics/processes/functions.rst:242
msgid ""
"Because the value for ``y`` that is being passed is zero, the engine will "
"encounter a ``ZeroDivisionError`` exception when the calculation function is"
" run. The output of ``verdi process list`` will confirm that the process has"
" excepted:"
msgstr ""

#: ../../source/topics/processes/functions.rst:253
msgid ""
"Exceptions that occur during the execution of a process are recorded as a "
"log message on the corresponding process node. To show these log messages, "
"one can use ``verdi process report``. In the case of the example above, it "
"would look something like the following:"
msgstr ""

#: ../../source/topics/processes/functions.rst:272
msgid ""
"However, in this particular example the exception is not so much an "
"unexpected error, but one we could have considered and have seen coming, so "
"it might be more applicable to simply mark the process as failed. To "
"accomplish this, there is the concept of an :ref:`exit "
"status<topics:processes:concepts:exit_codes>` that can be set on the "
"process, which is an integer that, when non-zero, marks a process in the "
"``Finished`` state as 'failed'. Since the exit status is set as an attribute"
" on the process node, it also makes it very easy to query for failed "
"processes. To set a non-zero exit status on a calculation function to "
"indicate it as failed, simply return an instance of the "
":py:class:`~aiida.engine.processes.exit_code.ExitCode` class. Time for a "
"demonstration:"
msgstr ""

#: ../../source/topics/processes/functions.rst:281
msgid ""
"When we run the calculation function now, with the same inputs, instead of "
"excepting, the process will successfully terminate and its exit status will "
"be set to the value stored in the ``ExitCode``. The exit status is also "
"displayed by ``verdi process list``:"
msgstr ""

#: ../../source/topics/processes/functions.rst:293
msgid ""
"Both approaches are valid and which one to use depends on your use case. The"
" question you should ask yourself is whether a potential problem merits "
"throwing the process on the pile of 'excepted' processes. Or maybe, as in "
"the example above, the problem is easily foreseeable and classifiable with a"
" well defined exit status, in which case it might make more sense to return "
"the exit code. At the end one should think which solution makes it easier "
"for a workflow calling the function to respond based on the result and what "
"makes it easier to query for these specific failure modes."
msgstr ""

#: ../../source/topics/processes/functions.rst:299
msgid "As class member methods"
msgstr ""

#: ../../source/topics/processes/functions.rst:303
msgid ""
"Process functions can also be declared as class member methods, for example "
"as part of a "
":class:`~aiida.engine.processes.workchains.workchain.WorkChain`:"
msgstr ""

#: ../../source/topics/processes/functions.rst:327
msgid ""
"In this example, the work chain declares a class method called "
"``compute_sum`` which is decorated with the ``calcfunction`` decorator to "
"turn it into a calculation function. It is important that the method is also"
" decorated with the ``staticmethod`` (see the `Python documentation "
"<https://docs.python.org/3/library/functions.html#staticmethod>`_) such that"
" the work chain instance is not passed when the method is invoked. The "
"calcfunction can be called from a work chain step like any other class "
"method, as is shown in the last line."
msgstr ""

#: ../../source/topics/processes/functions.rst:333
#: ../../source/topics/provenance/index.rst:5
msgid "Provenance"
msgstr ""

#: ../../source/topics/processes/functions.rst:334
msgid ""
"In addition to the basic attributes that are stored for all processes such "
"as the process state and label, the process functions automatically store "
"additional information that relates to the source code of the function they "
"represent:"
msgstr ""

#: ../../source/topics/processes/functions.rst:336
msgid "Function name"
msgstr ""

#: ../../source/topics/processes/functions.rst:337
msgid "Function namespace"
msgstr ""

#: ../../source/topics/processes/functions.rst:338
msgid "Function starting line number"
msgstr ""

#: ../../source/topics/processes/functions.rst:339
msgid "Function source file"
msgstr ""

#: ../../source/topics/processes/functions.rst:341
msgid ""
"The first three are retrieved by inspecting the python source code as soon "
"as the process function is executed and are stored as attributes on the "
"process node. They can be accessed through the corresponding properties on "
"the process node as follows:"
msgstr ""

#: ../../source/topics/processes/functions.rst:347
msgid ""
"The source code of the file in which the function is defined is also stored,"
" but since it can be quite big, it is stored as a raw file in the repository"
" of the process node. It can be retrieved through the "
":py:meth:`~aiida.orm.utils.mixins.FunctionCalculationMixin.get_function_source_code`"
" method."
msgstr ""

#: ../../source/topics/processes/functions.rst:350
msgid ""
"The attributes give some querability to the process functions stored in the "
"provenance graph and by storing the source code of the function that was "
"executed, there will be some reference in the future to track how the "
"function created its output nodes. Note, however, that just storing the "
"source file of the function does not guarantee that one can reproduce the "
"exact result. For example, one can 'leak' data into the function by reading "
"a file or loading an existing node from the database that was not explicitly"
" passed as an input. Alternatively, external code can be imported and "
"called, the source code of which will not be recorded."
msgstr ""

#: ../../source/topics/processes/functions.rst:356
msgid "Reproducibility guidelines"
msgstr ""

#: ../../source/topics/processes/functions.rst:357
msgid ""
"Due to the nature of the way process functions are implemented, it is "
"impossible to guarantee 100% reproducibility, but by following the following"
" guidelines, one can come as close as possible."
msgstr ""

#: ../../source/topics/processes/functions.rst:359
msgid "Do not leak data into functions"
msgstr ""

#: ../../source/topics/processes/functions.rst:360
msgid "Limit importing of external code"
msgstr ""

#: ../../source/topics/processes/functions.rst:361
msgid "Keep functions self-consistent and in separate files"
msgstr ""

#: ../../source/topics/processes/functions.rst:363
msgid ""
"Leaking data into functions is accomplished for example by reading a file on"
" the local file system in the function body and using its contents for the "
"creation of the outputs. Even if you store the source code, if you don't "
"possess the file that was read, it is impossible to reproduce the results. "
"Likewise, you should not load any existing data from the database through "
"the API, but rather they should be direct inputs of the process function."
msgstr ""

#: ../../source/topics/processes/functions.rst:367
msgid ""
"A similar problem occurs when importing other python code. Practically, it "
"is almost impossible to never import code into process functions, as this "
"would force massive code duplication. However, there is still a difference "
"between importing code from the ``aiida-core`` library or the repository in "
"which the process function is hosted, and the importing of a local python "
"file. Even though for both cases there can no be guarantee of "
"reproducibility, the former stands a better chance by far, as the version "
"number of the plugin package should be recorded. The rule of thumb then is "
"to keep the importing of code to a minimum, but if you have to, make sure to"
" make it part of a plugin package with a well-defined version number."
msgstr ""

#: ../../source/topics/processes/functions.rst:373
msgid ""
"Finally, as mentioned in the introduction, the source file of a process "
"function is stored as a file in the repository for *each execution*. "
"Currently there is no automatic deduplication for identical files by the "
"engine, so these files may occupy quite a bit of space. For this reason it "
"is advisable to keep each process function in its own separate file. This "
"not only improves readability, but it also minimizes the impact on the size "
"of the file repository."
msgstr ""

#: ../../source/topics/processes/index.rst:5
msgid "Processes"
msgstr ""

#: ../../source/topics/processes/index.rst:7
msgid ""
"This topic section provides extensive and detailed information on the "
"concept of processes in AiiDA and how to work with them. Since the concepts "
"explained here apply to processes in general, they also apply to its "
"subtypes: calculations and workflows. Information specific to each subtype "
"can be found in the topic sections on :ref:`calculations "
"<topics:calculations>` and :ref:`workflows <topics:workflows>`, "
"respectively."
msgstr ""

#: ../../source/topics/processes/usage.rst:7
msgid ""
"This chapter assumes knowledge of the previous section on the :ref:`basic "
"concept of processes<topics:workflows:concepts>`."
msgstr ""

#: ../../source/topics/processes/usage.rst:9
msgid ""
"This section will explain the aspects of working with processes that apply "
"to all processes. Details that only pertain to a specific sub type of "
"process, will be documented in their respective sections:"
msgstr ""

#: ../../source/topics/processes/usage.rst:12
msgid ":ref:`calculation functions<topics:calculations:usage:calcfunctions>`"
msgstr ""

#: ../../source/topics/processes/usage.rst:13
msgid ":ref:`calculation jobs<topics:calculations:usage:calcjobs>`"
msgstr ""

#: ../../source/topics/processes/usage.rst:14
msgid ":ref:`work functions<topics:workflows:usage:workfunctions>`"
msgstr ""

#: ../../source/topics/processes/usage.rst:15
msgid ":ref:`work chains<topics:workflows:usage:workchains>`"
msgstr ""

#: ../../source/topics/processes/usage.rst:21
msgid "Defining processes"
msgstr ""

#: ../../source/topics/processes/usage.rst:26
msgid "Process specification"
msgstr ""

#: ../../source/topics/processes/usage.rst:27
msgid ""
"How a process defines the inputs that it requires or can optionally take, "
"depends on the process type. The inputs of "
":py:class:`~aiida.engine.processes.calcjobs.calcjob.CalcJob` and "
":py:class:`~aiida.engine.processes.workchains.workchain.WorkChain` are given"
" by the :py:class:`~aiida.engine.processes.process_spec.ProcessSpec` class, "
"which is defined though  the "
":py:meth:`~aiida.engine.processes.process.Process.define` method. For "
"process functions, the "
":py:class:`~aiida.engine.processes.process_spec.ProcessSpec` is dynamically "
"generated by the engine from the signature of the decorated function. "
"Therefore, to determine what inputs a process takes, one simply has to look "
"at the process specification in the ``define`` method or the function "
"signature. For the "
":py:class:`~aiida.engine.processes.calcjobs.calcjob.CalcJob` and "
":py:class:`~aiida.engine.processes.workchains.workchain.WorkChain` there is "
"also the concept of the :ref:`process "
"builder<topics:processes:usage:builder>`, which will allow one to inspect "
"the inputs with tab-completion and help strings in the shell."
msgstr ""

#: ../../source/topics/processes/usage.rst:33
msgid ""
"The three most important attributes of the "
":py:class:`~aiida.engine.processes.process_spec.ProcessSpec` are:"
msgstr ""

#: ../../source/topics/processes/usage.rst:35
msgid "``inputs``"
msgstr ""

#: ../../source/topics/processes/usage.rst:36
msgid "``outputs``"
msgstr ""

#: ../../source/topics/processes/usage.rst:37
msgid "``exit_codes``"
msgstr ""

#: ../../source/topics/processes/usage.rst:39
msgid ""
"Through these attributes, one can define what inputs a process takes, what "
"outputs it will produce and what potential exit codes it can return in case "
"of errors. Just by looking at a process specification then, one will know "
"exactly *what* will happen, just not *how* it will happen. The ``inputs`` "
"and ``outputs`` attributes are *namespaces* that contain so called *ports*, "
"each one of which represents a specific input or output. The namespaces can "
"be arbitrarily nested with ports and so are called *port namespaces*. The "
"port and port namespace are implemented by the :py:class:`~plumpy.Port` and "
":py:class:`~aiida.engine.processes.ports.PortNamespace` class, respectively."
msgstr ""

#: ../../source/topics/processes/usage.rst:49
msgid "Ports and Port namespaces"
msgstr ""

#: ../../source/topics/processes/usage.rst:50
msgid ""
"To define an input for a process specification, we only need to add a port "
"to the ``inputs`` port namespace, as follows:"
msgstr ""

#: ../../source/topics/processes/usage.rst:57
msgid ""
"The ``input`` method, will create an instance of "
":py:class:`~aiida.engine.processes.ports.InputPort`, a sub class of the base"
" :py:class:`~plumpy.Port`, and will add it to the ``inputs`` port namespace "
"of the spec. Creating an output is just as easy, but one should use the "
":py:meth:`~plumpy.ProcessSpec.output` method instead:"
msgstr ""

#: ../../source/topics/processes/usage.rst:65
msgid ""
"This will cause an instance of "
":py:class:`~aiida.engine.processes.ports.CalcJobOutputPort`, also a sub "
"class of the base :py:class:`~plumpy.Port`, to be created and to be added to"
" the ``outputs`` specifcation attribute. Recall, that the ``inputs`` and "
"``output`` are instances of a "
":py:class:`~aiida.engine.processes.ports.PortNamespace`, which means that "
"they can contain any port. But the "
":py:class:`~aiida.engine.processes.ports.PortNamespace` itself is also a "
"port itself, so it can be added to another port namespace, allowing one to "
"create nested port namespaces. Creating a new namespace in for example the "
"inputs namespace is as simple as:"
msgstr ""

#: ../../source/topics/processes/usage.rst:75
msgid ""
"This will create a new ``PortNamespace`` named ``namespace`` in the "
"``inputs`` namespace of the spec. You can create arbitrarily nested "
"namespaces in one statement, by separating them with a ``.`` as shown here:"
msgstr ""

#: ../../source/topics/processes/usage.rst:83
msgid ""
"This command will result in the ``PortNamespace`` name ``namespace`` to be "
"nested inside another ``PortNamespace`` called ``nested``."
msgstr ""

#: ../../source/topics/processes/usage.rst:87
msgid ""
"Because the period is reserved to denote different nested namespaces, it "
"cannot be used in the name of terminal input and output ports as that could "
"be misinterpreted later as a port nested in a namespace."
msgstr ""

#: ../../source/topics/processes/usage.rst:89
msgid ""
"Graphically, this can be visualized as a nested dictionary and will look "
"like the following:"
msgstr ""

#: ../../source/topics/processes/usage.rst:99
msgid ""
"The ``outputs`` attribute of the ``ProcessSpec`` is also a ``PortNamespace``"
" just as the ``inputs``, with the only different that it will create "
"``OutputPort`` instead of ``InputPort`` instances. Therefore the same "
"concept of nesting through ``PortNamespaces`` applies to the outputs of a "
"``ProcessSpec``."
msgstr ""

#: ../../source/topics/processes/usage.rst:106
msgid "Validation and defaults"
msgstr ""

#: ../../source/topics/processes/usage.rst:107
msgid ""
"In the previous section, we saw that the ``ProcessSpec`` uses the "
"``PortNamespace``, ``InputPort`` and ``OutputPort`` to define the inputs and"
" outputs structure of the ``Process``. The underlying concept that allows "
"this nesting of ports is that the ``PortNamespace``, ``InputPort`` and "
"``OutputPort``, are all a subclass of :py:class:`~plumpy.ports.Port`. And as"
" different subclasses of the same class, they have more properties and "
"attributes in common, for example related to the concept of validation and "
"default values. All three have the following attributes (with the exception "
"of the ``OutputPort`` not having a ``default`` attribute):"
msgstr ""

#: ../../source/topics/processes/usage.rst:112
msgid "``default``"
msgstr ""

#: ../../source/topics/processes/usage.rst:113
msgid "``required``"
msgstr ""

#: ../../source/topics/processes/usage.rst:114
msgid "``valid_type``"
msgstr ""

#: ../../source/topics/processes/usage.rst:115
msgid "``validator``"
msgstr ""

#: ../../source/topics/processes/usage.rst:117
msgid ""
"These attributes can all be set upon construction of the port or after the "
"fact, as long as the spec has not been sealed, which means that they can be "
"altered without limit as long as it is within the ``define`` method of the "
"corresponding ``Process``. An example input port that explicitly sets all "
"these attributes is the following:"
msgstr ""

#: ../../source/topics/processes/usage.rst:124
msgid ""
"Here we define an input named ``positive_number`` that should be of type "
"``Int`` or ``Float`` and should pass the test of the ``is_number_positive`` "
"validator. If no value is passed, the default will be used."
msgstr ""

#: ../../source/topics/processes/usage.rst:129
msgid ""
"In python, it is good practice to avoid mutable defaults for function "
"arguments, `since they are instantiated at function definition and reused "
"for each invocation "
"<https://docs.python.org/3/reference/compound_stmts.html#function-"
"definitions>`_. This can lead to unexpected results when the default value "
"is changed between function calls. In the context of AiiDA, nodes (both "
"stored and unstored) are considered *mutable* and should therefore *not* be "
"used as default values for process ports. However, it is possible to use a "
"lambda that returns a node instance as done in the example above. This will "
"return a new instance of the node with the given value, each time the "
"process is instantiated."
msgstr ""

#: ../../source/topics/processes/usage.rst:135
msgid ""
"Note that the validator is nothing more than a free function which takes a "
"single argument, being the value that is to be validated. If nothing is "
"returned, the value is considered to be valid. To signal that the value is "
"invalid and to have a validation error raised, simply return a string with "
"the validation error message, for example:"
msgstr ""

#: ../../source/topics/processes/usage.rst:145
msgid ""
"The ``valid_type`` can define a single type, or a tuple of valid types."
msgstr ""

#: ../../source/topics/processes/usage.rst:149
msgid ""
"If a port is marked as optional through ``required=False`` and defines "
"``valid_type``, the port will also accept ``None`` as values, whereas before"
" this would raise validation error. This is accomplished by automatically "
"adding the ``NoneType`` to the ``valid_type`` tuple. Ports that do not "
"define a ``valid_type`` are not affected."
msgstr ""

#: ../../source/topics/processes/usage.rst:155
msgid ""
"Note that by default all ports are required, but specifying a default value "
"implies that the input is not required and as such specifying "
"``required=False`` is not necessary in that case. It was added to the "
"example above simply for clarity."
msgstr ""

#: ../../source/topics/processes/usage.rst:158
msgid ""
"The validation of input or output values with respect to the specification "
"of the corresponding port, happens at the instantiation of the process and "
"when it is finalized, respectively. If the inputs are invalid, a "
"corresponding exception will be thrown and the process instantiation will "
"fail. When the outputs fail to be validated, likewise an exception will be "
"thrown and the process state will be set to ``Excepted``."
msgstr ""

#: ../../source/topics/processes/usage.rst:166
msgid "Dynamic namespaces"
msgstr ""

#: ../../source/topics/processes/usage.rst:167
msgid ""
"In the previous section we described the various attributes related to "
"validation and claimed that all the port variants share those attributes, "
"yet we only discussed the ``InputPort`` and ``OutputPort`` explicitly. The "
"statement, however, is still correct and the ``PortNamespace`` has the same "
"attributes. You might then wonder what the meaning is of a ``valid_type`` or"
" ``default`` for a ``PortNamespace`` if all it does is contain "
"``InputPorts``, ``OutputPorts`` or other ``PortNamespaces``. The answer to "
"this question lies in the ``PortNamespace`` attribute ``dynamic``."
msgstr ""

#: ../../source/topics/processes/usage.rst:172
msgid ""
"Often when designing the specification of a ``Process``, we cannot know "
"exactly which inputs we want to be able to pass to the process. However, "
"with the concept of the ``InputPort`` and ``OutputPort`` one *does* need to "
"know exactly, how many values one expects at least, as they do have to be "
"defined. This is where the ``dynamic`` attribute of the ``PortNamespace`` "
"comes in. By default this is set to ``False``, but by setting it to "
"``True``, one indicates that that namespace can take a number of values that"
" is unknown at the time of definition of the specification. This now "
"explains the meaning of the ``valid_type``, ``validator`` and ``default`` "
"attributes in the context of the ``PortNamespace``. If you do mark a "
"namespace as dynamic, you may still want to limit the set of values that are"
" acceptable, which you can do by specifying the valid type and or validator."
" The values that will eventually be passed to the port namespace will then "
"be validated according to these rules exactly as a value for a regular input"
" port would be."
msgstr ""

#: ../../source/topics/processes/usage.rst:184
msgid "Non storable inputs"
msgstr ""

#: ../../source/topics/processes/usage.rst:185
msgid ""
"In principle, the only valid types for inputs and outputs should be "
"instances of a :py:class:`~aiida.orm.nodes.data.data.Data` node, or one of "
"its sub classes, as that is the only data type that can be recorded in the "
"provenance graph as an input or output of a process. However, there are "
"cases where you might want to pass an input to a process, whose provenance "
"you do not care about and therefore would want to pass a non-database "
"storable type anyway."
msgstr ""

#: ../../source/topics/processes/usage.rst:190
msgid ""
"AiiDA allows you to break the provenance as to be not too restrictive, but "
"always tries to urge you and guide you in a direction to keep the "
"provenance. There are legitimate reasons to break it regardless, but make "
"sure you think about the implications and whether you are really willing to "
"lose the information."
msgstr ""

#: ../../source/topics/processes/usage.rst:193
msgid ""
"For this situation, the ``InputPort`` has the attribute ``non_db``. By "
"default this is set to ``False``, but by setting it to ``True`` we can "
"indicate that the values that are passed to the port should not be stored as"
" a node in the provenance graph and linked to the process node. This allows "
"one to pass any normal value that one would also be able to pass to a normal"
" function."
msgstr ""

#: ../../source/topics/processes/usage.rst:201
msgid "Automatic input serialization"
msgstr ""

#: ../../source/topics/processes/usage.rst:203
msgid ""
"Quite often, inputs which are given as Python data types need to be cast to "
"the corresponding AiiDA type before passing them to a process. Doing this "
"manually can be cumbersome, so you can define a function when defining the "
"process specification, which does the conversion automatically. This "
"function, passed as ``serializer`` parameter to ``spec.input``, is invoked "
"if the given input is not ``None`` *and* not already an AiiDA type."
msgstr ""

#: ../../source/topics/processes/usage.rst:207
msgid ""
"For inputs which are stored in the database (``non_db=False``), the "
"serialization function should return an AiiDA data type. For ``non_db`` "
"inputs, the function must be idempotent because it might be applied more "
"than once."
msgstr ""

#: ../../source/topics/processes/usage.rst:210
msgid ""
"The following example work chain takes three inputs ``a``, ``b``, ``c``, and"
" simply returns the given inputs. The "
":func:`~aiida.orm.nodes.data.base.to_aiida_type` function is used as "
"serialization function."
msgstr ""

#: ../../source/topics/processes/usage.rst:216
msgid ""
"This work chain can now be called with native Python types, which will "
"automatically be converted to AiiDA types by the "
":func:`~aiida.orm.nodes.data.base.to_aiida_type` function. Note that the "
"module which defines the corresponding AiiDA type must be loaded for it to "
"be recognized by :func:`~aiida.orm.nodes.data.base.to_aiida_type`."
msgstr ""

#: ../../source/topics/processes/usage.rst:222
msgid ""
"Of course, you can also use the serialization feature to perform a more "
"complex serialization of the inputs."
msgstr ""

#: ../../source/topics/processes/usage.rst:229
msgid ""
"Any ``Process`` most likely will have one or multiple expected failure "
"modes. To clearly communicate to the caller what went wrong, the ``Process``"
" supports setting its ``exit_status``. This ``exit_status``, a positive "
"integer, is an attribute of the process node and by convention, when it is "
"zero means the process was successful, whereas any other value indicates "
"failure. This concept of an exit code, with a positive integer as the exit "
"status, `is a common concept in programming "
"<https://en.wikipedia.org/wiki/Exit_status>`_ and a standard way for "
"programs to communicate the result of their execution."
msgstr ""

#: ../../source/topics/processes/usage.rst:234
msgid ""
"Potential exit codes for the ``Process`` can be defined through the "
"``ProcessSpec``, just like inputs and outputs. Any exit code consists of a "
"positive non-zero integer, a string label to reference it and a more "
"detailed description of the problem that triggers the exit code. Consider "
"the following example:"
msgstr ""

#: ../../source/topics/processes/usage.rst:243
msgid ""
"This defines an exit code for the ``Process`` with exit status ``418`` and "
"exit message ``the work chain had an identity crisis``. The string "
"``ERROR_I_AM_A_TEAPOT`` is a label that the developer can use to reference "
"this particular exit code somewhere in the ``Process`` code itself."
msgstr ""

#: ../../source/topics/processes/usage.rst:246
msgid ""
"Whenever a ``Process`` exits through a particular error code, the caller "
"will be able to introspect it through the ``exit_status`` and "
"``exit_message`` attributes of the node. Assume for example that we ran a "
"``Process`` that threw the exit code described above, the caller would be "
"able to do the following:"
msgstr ""

#: ../../source/topics/processes/usage.rst:257
msgid ""
"This is useful, because the caller can now programmatically, based on the "
"``exit_status``, decide how to proceed. This is an infinitely more robust "
"way of communicating specific errors to a non-human than parsing text-based "
"logs or reports. Additionally, the exit codes make it very easy to query for"
" failed processes with specific error codes."
msgstr ""

#: ../../source/topics/processes/usage.rst:263
msgid ""
"Additional documentation, specific to certain process types, can be found in"
" the following sections:"
msgstr ""

#: ../../source/topics/processes/usage.rst:265
msgid ":ref:`Process functions<topics:processes:functions:exit_codes>`"
msgstr ""

#: ../../source/topics/processes/usage.rst:266
msgid ":ref:`Work functions<topics:workflows:usage:workfunctions:exit_codes>`"
msgstr ""

#: ../../source/topics/processes/usage.rst:267
msgid ":ref:`CalcJob parsers<topics:calculations:usage:calcjobs:parsers>`"
msgstr ""

#: ../../source/topics/processes/usage.rst:268
msgid ""
":ref:`Workchain exit code "
"specification<topics:workflows:usage:workchains:define_exit_codes>`"
msgstr ""

#: ../../source/topics/processes/usage.rst:269
msgid ":ref:`External code plugins<how-to:plugin-codes:parsing:errors>`"
msgstr ""

#: ../../source/topics/processes/usage.rst:270
msgid ":ref:`Restart workchains<how-to:restart-workchain>`"
msgstr ""

#: ../../source/topics/processes/usage.rst:275
msgid "Exit code conventions"
msgstr ""

#: ../../source/topics/processes/usage.rst:276
msgid ""
"In principle, the only restriction on the exit status of an exit code is "
"that it should be a positive integer or zero. However, to make effective use"
" of exit codes, there are some guidelines and conventions as to decide what "
"integers to use. Note that since the following rules are *guidelines* you "
"can choose to ignore them and currently the engine will not complain, but "
"this might change in the future. Regardless, we advise you to follow the "
"guidelines since it will improve the interoperability of your code with "
"other existing plugins. The following integer ranges are reserved or "
"suggested:"
msgstr ""

#: ../../source/topics/processes/usage.rst:282
msgid "0 -  99: Reserved for internal use by `aiida-core`"
msgstr ""

#: ../../source/topics/processes/usage.rst:283
msgid ""
"100 - 199: Reserved for errors parsed from scheduler output of calculation "
"jobs (note: this is not yet implemented)"
msgstr ""

#: ../../source/topics/processes/usage.rst:284
msgid "200 - 299: Suggested to be used for process input validation errors"
msgstr ""

#: ../../source/topics/processes/usage.rst:285
msgid "300 - 399: Suggested for critical process errors"
msgstr ""

#: ../../source/topics/processes/usage.rst:287
msgid "For any other exit codes, one can use the integers from 400 and up."
msgstr ""

#: ../../source/topics/processes/usage.rst:293
msgid "Process metadata"
msgstr ""

#: ../../source/topics/processes/usage.rst:295
msgid ""
"Each process, in addition to the normal inputs defined through its process "
"specification, can take optional 'metadata'. These metadata differ from "
"inputs in the sense that they are not nodes that will show up as inputs in "
"the provenance graph of the executed process. Rather, these are inputs that "
"slightly modify the behavior of the process or allow to set attributes on "
"the process node that represents its execution. The following metadata "
"inputs are available for *all* process classes:"
msgstr ""

#: ../../source/topics/processes/usage.rst:300
msgid "``label``: will set the label on the ``ProcessNode``"
msgstr ""

#: ../../source/topics/processes/usage.rst:301
msgid "``description``: will set the description on the ``ProcessNode``"
msgstr ""

#: ../../source/topics/processes/usage.rst:302
msgid ""
"``store_provenance``: boolean flag, by default ``True``, that when set to "
"``False``, will ensure that the execution of the process **is not** stored "
"in the provenance graph"
msgstr ""

#: ../../source/topics/processes/usage.rst:304
msgid ""
"Sub classes of the :py:class:`~aiida.engine.processes.process.Process` class"
" can specify further metadata inputs, refer to their specific documentation "
"for details. To pass any of these metadata options to a process, simply pass"
" them in a dictionary under the key ``metadata`` in the inputs when "
"launching the process. How a process can be launched is explained the "
"following section."
msgstr ""

#: ../../source/topics/processes/usage.rst:312
msgid "Launching processes"
msgstr ""

#: ../../source/topics/processes/usage.rst:313
msgid ""
"Any process can be launched by 'running' or 'submitting' it. Running means "
"to run the process in the current python interpreter in a blocking way, "
"whereas submitting means to send it to a daemon worker over RabbitMQ. For "
"long running processes, such as calculation jobs or complex workflows, it is"
" best advised to submit to the daemon. This has the added benefit that it "
"will directly return control to your interpreter and allow the daemon to "
"save intermediate progress during checkpoints and reload the process from "
"those if it has to restart. Running processes can be useful for trivial "
"computational tasks, such as simple calcfunctions or workfunctions, or for "
"debugging and testing purposes."
msgstr ""

#: ../../source/topics/processes/usage.rst:323
msgid "Process launch"
msgstr ""

#: ../../source/topics/processes/usage.rst:325
msgid ""
"To launch a process, one can use the free functions that can be imported "
"from the :py:mod:`aiida.engine` module. There are four different functions:"
msgstr ""

#: ../../source/topics/processes/usage.rst:328
msgid ":py:func:`~aiida.engine.launch.run`"
msgstr ""

#: ../../source/topics/processes/usage.rst:329
msgid ":py:func:`~aiida.engine.launch.run_get_node`"
msgstr ""

#: ../../source/topics/processes/usage.rst:330
msgid ":py:func:`~aiida.engine.launch.run_get_pk`"
msgstr ""

#: ../../source/topics/processes/usage.rst:331
msgid ":py:func:`~aiida.engine.launch.submit`"
msgstr ""

#: ../../source/topics/processes/usage.rst:333
msgid ""
"As the name suggest, the first three will 'run' the process and the latter "
"will 'submit' it to the daemon. Running means that the process will be "
"executed in the same interpreter in which it is launched, blocking the "
"interpreter, until the process is terminated. Submitting to the daemon, in "
"contrast, means that the process will be sent to the daemon for execution, "
"and the interpreter is released straight away."
msgstr ""

#: ../../source/topics/processes/usage.rst:337
msgid ""
"All functions have the exact same interface ``launch(process, inputs)`` "
"where:"
msgstr ""

#: ../../source/topics/processes/usage.rst:339
msgid "``process`` is the process class or process function to launch"
msgstr ""

#: ../../source/topics/processes/usage.rst:340
msgid "``inputs`` the inputs dictionary to pass to the process."
msgstr ""

#: ../../source/topics/processes/usage.rst:344
msgid ""
"Before AiiDA v2.5, the inputs could only be passed as keyword arguments. "
"This behavior is still supported, e.g., one can launch a process as "
"``launch(process, **inputs)`` or ``launch(process, input_a=value_a, "
"input_b=value_b)``. However, the recommended approach is now to use an input"
" dictionary passed as the second positional argument. The reason is that "
"certain launchers define arguments themselves which can overlap with inputs "
"of the process. For example, the ``submit`` method defines the ``wait`` "
"keyword. If the process being launched *also* defines an input named "
"``wait``, the launcher method cannot tell them apart."
msgstr ""

#: ../../source/topics/processes/usage.rst:351
msgid ""
"What inputs can be passed depends on the exact process class that is to be "
"launched. For example, when we want to run an instance of the "
":py:class:`~aiida.calculations.arithmetic.add.ArithmeticAddCalculation` "
"process, which takes two :py:class:`~aiida.orm.nodes.data.int.Int` nodes as "
"inputs under the name ``x`` and ``y`` [#f1]_, we would do the following:"
msgstr ""

#: ../../source/topics/processes/usage.rst:357
msgid ""
"The function will submit the calculation to the daemon and immediately "
"return control to the interpreter, returning the node that is used to "
"represent the process in the provenance graph."
msgstr ""

#: ../../source/topics/processes/usage.rst:360
msgid ""
"For a process to be submittable, the class or function needs to be "
"importable in the daemon environment by a) giving it an :ref:`associated "
"entry point<how-to:plugin-codes:entry-points>` or b) :ref:`including its "
"module path<how-to:faq:process-not-importable-daemon>` in the ``PYTHONPATH``"
" that the daemon workers will have."
msgstr ""

#: ../../source/topics/processes/usage.rst:364
msgid ""
"Use ``wait=True`` when calling ``submit`` to wait for the process to "
"complete before returning the node. This can be useful for tutorials and "
"demos in interactive notebooks where the user should not continue before the"
" process is done. One could of course also use ``run`` (see below), but then"
" the process would be lost if the interpreter gets accidentally shut down. "
"By using ``submit``, the process is run by the daemon which takes care of "
"saving checkpoints so it can always be restarted in case of problems. If you"
" need to launch multiple processes in parallel and want to wait for all of "
"them to be finished, simply use ``submit`` with the default ``wait=False`` "
"and collect the returned nodes in a list. You can then pass them to "
":func:`aiida.engine.launch.await_processes` which will return once all "
"processes have terminated:"
msgstr ""

#: ../../source/topics/processes/usage.rst:383
msgid ""
"The ``await_processes`` function will loop every ``wait_interval`` seconds "
"and check whether all processes (represented by the ``ProcessNode`` in the "
"``nodes`` list) have terminated."
msgstr ""

#: ../../source/topics/processes/usage.rst:386
msgid "The ``run`` function is called identically:"
msgstr ""

#: ../../source/topics/processes/usage.rst:391
msgid ""
"except that it does not submit the process to the daemon, but executes it in"
" the current interpreter, blocking it until the process is terminated. The "
"return value of the ``run`` function is also **not** the node that "
"represents the executed process, but the results returned by the process, "
"which is a dictionary of the nodes that were produced as outputs. If you "
"would still like to have the process node or the pk of the process node you "
"can use one of the following variants:"
msgstr ""

#: ../../source/topics/processes/usage.rst:398
msgid ""
"Finally, the :py:func:`~aiida.engine.launch.run` launcher has two attributes"
" ``get_node`` and ``get_pk`` that are simple proxies to the "
":py:func:`~aiida.engine.launch.run_get_node` and "
":py:func:`~aiida.engine.launch.run_get_pk` methods. This is a handy "
"shortcut, as now you can choose to use any of the three variants with just a"
" single import:"
msgstr ""

#: ../../source/topics/processes/usage.rst:404
msgid ""
"If you want to launch a process class that takes a lot more inputs, often it"
" is useful to define them in a dictionary and use the python syntax ``**`` "
"that automatically expands it into keyword argument and value pairs. The "
"examples used above would look like the following:"
msgstr ""

#: ../../source/topics/processes/usage.rst:410
msgid ""
"Process functions, i.e. :ref:`calculation "
"functions<topics:calculations:concepts:calcfunctions>` and :ref:`work "
"functions<topics:workflows:concepts:workfunctions>`, can be launched like "
"any other process as explained above. Process functions have two additional "
"methods of being launched:"
msgstr ""

#: ../../source/topics/processes/usage.rst:413
msgid "Simply *calling* the function"
msgstr ""

#: ../../source/topics/processes/usage.rst:414
msgid "Using the internal run method attributes"
msgstr ""

#: ../../source/topics/processes/usage.rst:416
msgid ""
"Using a calculation function to add two numbers as an example, these two "
"methods look like the following:"
msgstr ""

#: ../../source/topics/processes/usage.rst:425
msgid "Process builder"
msgstr ""

#: ../../source/topics/processes/usage.rst:426
msgid ""
"As explained in a :ref:`previous section<topics:processes:usage:spec>`, the "
"inputs for a :py:class:`~aiida.engine.processes.calcjobs.calcjob.CalcJob` "
"and :py:class:`~aiida.engine.processes.workchains.workchain.WorkChain` are "
"defined in the :py:meth:`~aiida.engine.processes.process.Process.define` "
"method. To know what inputs they take, one would have to read the "
"implementation, which can be annoying if you are not a developer. To "
"simplify this process, these two process classes provide a utility called "
"the 'process builder'. The process builder is essentially a tool that helps "
"you build the inputs for the specific process class that you want to run. To"
" get a *builder* for a particular ``CalcJob`` or a ``WorkChain`` "
"implementation, all you need is the class itself, which can be loaded "
"through the :py:class:`~aiida.plugins.factories.CalculationFactory` and "
":py:class:`~aiida.plugins.factories.WorkflowFactory`, respectively. Let's "
"take the "
":py:class:`~aiida.calculations.arithmetic.add.ArithmeticAddCalculation` as "
"an example::"
msgstr ""

#: ../../source/topics/processes/usage.rst:436
msgid ""
"The string ``core.arithmetic.add`` is the entry point of the "
"``ArithmeticAddCalculation`` and passing it to the ``CalculationFactory`` "
"will return the corresponding class. Calling the ``get_builder`` method on "
"that class will return an instance of the "
":py:class:`~aiida.engine.processes.builder.ProcessBuilder` class that is "
"tailored for the ``ArithmeticAddCalculation``. The builder will help you in "
"defining the inputs that the ``ArithmeticAddCalculation`` requires and has a"
" few handy tools to simplify this process."
msgstr ""

#: ../../source/topics/processes/usage.rst:440
msgid ""
"To find out which inputs the builder exposes, you can simply use tab "
"completion. In an interactive python shell, by simply typing ``builder.`` "
"and hitting the tab key, a complete list of all the available inputs will be"
" shown. Each input of the builder can also show additional information about"
" what sort of input it expects. In an interactive shell, you can get this "
"information to display as follows::"
msgstr ""

#: ../../source/topics/processes/usage.rst:455
msgid ""
"In the ``Docstring`` you will see a ``help`` string that contains more "
"detailed information about the input port. Additionally, it will display a "
"``valid_type``, which when defined shows which data types are expected. If a"
" default value has been defined, that will also be displayed. The ``non_db``"
" attribute defines whether that particular input will be stored as a proper "
"input node in the database, if the process is submitted."
msgstr ""

#: ../../source/topics/processes/usage.rst:460
msgid ""
"Defining an input through the builder is as simple as assigning a value to "
"the attribute. The following example shows how to set the ``parameters`` "
"input, as well as the ``description`` and ``label`` metadata inputs::"
msgstr ""

#: ../../source/topics/processes/usage.rst:468
msgid ""
"If you evaluate the ``builder`` instance, simply by typing the variable name"
" and hitting enter, the current values of the builder's inputs will be "
"displayed::"
msgstr ""

#: ../../source/topics/processes/usage.rst:481
msgid ""
"In this example, you can see the value that we just set for the "
"``description`` and the ``label``. In addition, it will also show any "
"namespaces, as the inputs of processes support nested namespaces, such as "
"the ``metadata.options`` namespace in this example. Note that nested "
"namespaces are also all autocompleted, and you can traverse them recursively"
" with tab-completion."
msgstr ""

#: ../../source/topics/processes/usage.rst:485
msgid ""
"All that remains is to fill in all the required inputs and we are ready to "
"launch the process builder. When all the inputs have been defined for the "
"builder, it can be used to actually launch the ``Process``. The process can "
"be launched by passing the builder to any of the free functions "
":py:mod:`~aiida.engine.launch` module, just as you would do a normal process"
" as :ref:`described above<topics:processes:usage:launching>`, i.e.:"
msgstr ""

#: ../../source/topics/processes/usage.rst:492
msgid ""
"Note that the process builder is in principle designed to be used in an "
"interactive shell, as there is where the tab-completion and automatic input "
"documentation really shines. However, it is perfectly possible to use the "
"same builder in scripts where you simply use it as an input container, "
"instead of a plain python dictionary."
msgstr ""

#: ../../source/topics/processes/usage.rst:499
msgid "Monitoring processes"
msgstr ""

#: ../../source/topics/processes/usage.rst:500
msgid ""
"When you have launched a process, you may want to investigate its status, "
"progression and the results. The :ref:`verdi<reference:command-line>` "
"command line tool provides various commands to do just this."
msgstr ""

#: ../../source/topics/processes/usage.rst:507
msgid "verdi process list"
msgstr ""

#: ../../source/topics/processes/usage.rst:508
msgid ""
"Your first point of entry will be the ``verdi`` command ``verdi process "
"list``. This command will print a list of all active processes through the "
"``ProcessNode`` stored in the database that it uses to represent its "
"execution. A typical example may look something like the following:"
msgstr ""

#: ../../source/topics/processes/usage.rst:522
msgid ""
"The 'State' column is a concatenation of the ``process_state`` and the "
"``exit_status`` of the ``ProcessNode``. By default, the command will only "
"show active items, i.e. ``ProcessNodes`` that have not yet reached a "
"terminal state. If you want to also show the nodes in a terminal states, you"
" can use the ``-a`` flag and call ``verdi process list -a``:"
msgstr ""

#: ../../source/topics/processes/usage.rst:538
msgid ""
"For more information on the meaning of the 'state' column, please refer to "
"the documentation of the :ref:`process state "
"<topics:processes:concepts:state>`. The ``-S`` flag let's you query for "
"specific process states, i.e. issuing ``verdi process list -S created`` will"
" return:"
msgstr ""

#: ../../source/topics/processes/usage.rst:550
msgid ""
"To query for a specific exit status, one can use ``verdi process list -E "
"0``:"
msgstr ""

#: ../../source/topics/processes/usage.rst:562
msgid ""
"This simple tool should give you a good idea of the current status of "
"running processes and the status of terminated ones. For a complete list of "
"all the available options, please refer to the documentation of :ref:`verdi "
"process<reference:command-line:verdi-process>`."
msgstr ""

#: ../../source/topics/processes/usage.rst:565
msgid ""
"If you are looking for information about a specific process node, the "
"following three commands are at your disposal:"
msgstr ""

#: ../../source/topics/processes/usage.rst:567
msgid ""
"``verdi process report`` gives a list of the log messages attached to the "
"process"
msgstr ""

#: ../../source/topics/processes/usage.rst:568
msgid ""
"``verdi process status`` print the call hierarchy of the process and status "
"of all its nodes"
msgstr ""

#: ../../source/topics/processes/usage.rst:569
msgid ""
"``verdi process show`` print details about the status, inputs, outputs, "
"callers and callees of the process"
msgstr ""

#: ../../source/topics/processes/usage.rst:571
msgid ""
"In the following sections, we will explain briefly how the commands work. "
"For the purpose of example, we will show the output of the commands for a "
"completed ``PwBaseWorkChain`` from the ``aiida-quantumespresso`` plugin, "
"which simply calls a ``PwCalculation``."
msgstr ""

#: ../../source/topics/processes/usage.rst:578
msgid "verdi process report"
msgstr ""

#: ../../source/topics/processes/usage.rst:579
msgid ""
"The developer of a process can attach log messages to the node of a process "
"through the :py:meth:`~aiida.engine.processes.process.Process.report` "
"method. The ``verdi process report`` command will display all the log "
"messages in chronological order:"
msgstr ""

#: ../../source/topics/processes/usage.rst:589
msgid ""
"The log message will include a timestamp followed by the level of the log, "
"which is always ``REPORT``. The second block has the format ``pk|class "
"name|function name`` detailing information about, in this case, the work "
"chain itself and the step in which the message was fired. Finally, the "
"message itself is displayed. Of course how many messages are logged and how "
"useful they are is up to the process developer. In general they can be very "
"useful for a user to understand what has happened during the execution of "
"the process, however, one has to realize that each entry is stored in the "
"database, so overuse can unnecessarily bloat the database."
msgstr ""

#: ../../source/topics/processes/usage.rst:599
msgid "verdi process status"
msgstr ""

#: ../../source/topics/processes/usage.rst:600
msgid ""
"This command is most useful for ``WorkChain`` instances, but also works for "
"``CalcJobs``. One of the more powerful aspects of work chains, is that they "
"can call ``CalcJobs`` and other ``WorkChains`` to create a nested call "
"hierarchy. If you want to inspect the status of a work chain and all the "
"children that it called, ``verdi process status`` is the go-to tool. An "
"example output is the following:"
msgstr ""

#: ../../source/topics/processes/usage.rst:610
msgid ""
"The command prints a tree representation of the hierarchical call structure,"
" that recurses all the way down. In this example, there is just a single "
"``PwBaseWorkChain`` which called a ``PwCalculation``, which is indicated by "
"it being indented one level. In addition to the call tree, each node also "
"shows its current process state and for work chains at which step in the "
"outline it is. This tool can be very useful to inspect while a work chain is"
" running at which step in the outline it currently is, as well as the status"
" of all the children calculations it called."
msgstr ""

#: ../../source/topics/processes/usage.rst:619
msgid "verdi process show"
msgstr ""

#: ../../source/topics/processes/usage.rst:620
msgid ""
"Finally, there is a command that displays detailed information about the "
"``ProcessNode``, such as its inputs, outputs and the optional other "
"processes it called and or was called by. An example output for a "
"``PwBaseWorkChain`` would look like the following:"
msgstr ""

#: ../../source/topics/processes/usage.rst:664
msgid ""
"This overview should give you all the information if you want to inspect a "
"process' inputs and outputs in closer detail as it provides you their pk's."
msgstr ""

#: ../../source/topics/processes/usage.rst:670
msgid "Manipulating processes"
msgstr ""

#: ../../source/topics/processes/usage.rst:671
msgid ""
"To understand how one can manipulate running processes, one has to "
"understand the principles of the :ref:`process/node "
"distinction<topics:processes:concepts:node_distinction>` and a "
":ref:`process' lifetime<topics:processes:concepts:lifetime>` first, so be "
"sure to have read those sections first."
msgstr ""

#: ../../source/topics/processes/usage.rst:677
msgid "verdi process pause/play/kill"
msgstr ""

#: ../../source/topics/processes/usage.rst:678
msgid ""
"The ``verdi`` command line interface provides three commands to interact "
"with 'live' processes."
msgstr ""

#: ../../source/topics/processes/usage.rst:680
msgid "``verdi process pause``"
msgstr ""

#: ../../source/topics/processes/usage.rst:681
msgid "``verdi process play``"
msgstr ""

#: ../../source/topics/processes/usage.rst:682
msgid "``verdi process kill``"
msgstr ""

#: ../../source/topics/processes/usage.rst:684
msgid ""
"The first pauses a process temporarily, the second resumes any paused "
"processes and the third one permanently kills them. The sub command names "
"might seem to tell you this already and it might look like that is all there"
" is to know, but the functionality underneath is quite complicated and "
"deserves additional explanation nonetheless."
msgstr ""

#: ../../source/topics/processes/usage.rst:687
msgid ""
"As the section on :ref:`the distinction between the process and the "
"node<topics:processes:concepts:node_distinction>` explained, manipulating a "
"process means interacting with the live process instance that lives in the "
"memory of the runner that is running it. By definition, these runners will "
"always run in a different system process than the one from which you want to"
" interact, because otherwise, you would *be* the runner, given that there "
"can only be a single runner in an interpreter and if it is running, the "
"interpreter would be blocked from performing any other operations. This "
"means that in order to interact with the live process, one has to interact "
"with another interpreter running in a different system process. This is once"
" again facilitated by the RabbitMQ message broker. When a runner starts to "
"run a process, it will also add listeners for incoming messages that are "
"being sent for that specific process over RabbitMQ."
msgstr ""

#: ../../source/topics/processes/usage.rst:695
msgid ""
"This does not just apply to daemon runners, but also normal runners. That is"
" to say that if you were to launch a process in a local runner, that "
"interpreter will be blocked, but it will still setup the listeners for that "
"process on RabbitMQ. This means that you can manipulate the process from "
"another terminal, just as if you would do with a process that is being run "
"by a daemon runner."
msgstr ""

#: ../../source/topics/processes/usage.rst:699
msgid ""
"In the case of 'pause', 'play' and 'kill', one is sending what is called a "
"Remote Procedure Call (RPC) over RabbitMQ. The RPC will include the process "
"identifier for which the action is intended and RabbitMQ will send it to "
"whoever registered itself to be listening for that specific process, in this"
" case the runner that is running the process. This immediately reveals a "
"potential problem: the RPC will fall on deaf ears if there is no one "
"listening, which can have multiple causes. For example, as explained in the "
"section on a :ref:`process' lifetime<topics:processes:concepts:lifetime>`, "
"this can be the case for a submitted process, where the corresponding task "
"is still queued, as all available process slots are occupied. But even if "
"the task *were* to be with a runner, it might be too busy to respond to the "
"RPC and the process appears to be unreachable. Whenever a process is "
"unreachable for an RPC, the command will return an error:"
msgstr ""

#: ../../source/topics/processes/usage.rst:710
msgid ""
"Depending on the cause of the process being unreachable, the problem may "
"resolve itself automatically over time and one can try again at a later "
"time, as for example in the case of the runner being too busy to respond. "
"However, to prevent this from happening, the runner has been designed to "
"have the communication happen over a separate thread and to schedule "
"callbacks for any necessary actions on the main thread, which performs all "
"the heavy lifting. This should make occurrences of the runner being too busy"
" to respond very rare. However, there is unfortunately no way of telling "
"what the actual problem is for the process not being reachable. The problem "
"will manifest itself identically if the runner just could not respond in "
"time or if the task has accidentally been lost forever due to a bug, even "
"though these are two completely separate situations."
msgstr ""

#: ../../source/topics/processes/usage.rst:716
msgid ""
"This brings us to another potential unintuitive aspect of interacting with "
"processes. The previous paragraph already mentioned it in passing, but when "
"a remote procedure call is sent, it first needs to be answered by the "
"responsible runner, if applicable, but it will not *directly execute* the "
"call. This is because the call will be incoming on the communcation thread "
"who is not allowed to have direct access to the process instance, but "
"instead it will schedule a callback on the main thread who can perform the "
"action. The callback will however not necessarily be executed directly, as "
"there may be other actions waiting to be performed. So when you pause, play "
"or kill a process, you are not doing so directly, but rather you are "
"*scheduling* a request to do so. If the runner has successfully received the"
" request and scheduled the callback, the command will therefore show "
"something like the following:"
msgstr ""

#: ../../source/topics/processes/usage.rst:727
msgid ""
"The 'scheduled' indicates that the actual killing might not necessarily have"
" happened just yet. This means that even after having called ``verdi process"
" kill`` and getting the success message, the corresponding process may still"
" be listed as active in the output of ``verdi process list``."
msgstr ""

#: ../../source/topics/processes/usage.rst:730
msgid ""
"By default, the ``pause``, ``play`` and ``kill`` commands will only ask for "
"the confirmation of the runner that the request has been scheduled and not "
"actually wait for the command to have been executed. This is because, as "
"explained, the actual action being performed might not be instantaneous as "
"the runner may be busy working with other processes, which would mean that "
"the command would block for a long time. If you want to send multiple "
"requests to a lot of processes in one go, this would be ineffective, as each"
" one would have to wait for the previous one to be completed. To change the "
"default and actually wait for the action to be completed and await its "
"response, you can use the ``--wait`` flag. If you know that your daemon "
"runners may be experiencing a heavy load, you can also increase the time "
"that the command waits before timing out, with the ``-t/--timeout`` flag."
msgstr ""

#: ../../source/topics/processes/usage.rst:738
#: ../../source/topics/workflows/usage.rst:608
msgid "Footnotes"
msgstr ""

#: ../../source/topics/processes/usage.rst:739
msgid ""
"Note that the "
":py:class:`~aiida.calculations.arithmetic.add.ArithmeticAddCalculation` "
"process class also takes a ``code`` as input, but that has been omitted for "
"the purposes of the example."
msgstr ""

#: ../../source/topics/processes/usage.rst:745
msgid "The processes API"
msgstr ""

#: ../../source/topics/processes/usage.rst:747
msgid ""
"The functionality of ``verdi process`` to ``play``, ``pause`` and ``kill`` "
"is now made available through the :meth:`aiida.engine.processes.control` "
"module. Processes can be played, paused or killed through the "
":meth:`~aiida.engine.processes.control.play_processes`, "
":meth:`~aiida.engine.processes.control.pause_processes`, and "
":meth:`~aiida.engine.processes.control.kill_processes`, respectively:"
msgstr ""

#: ../../source/topics/processes/usage.rst:760
msgid ""
"Instead of specifying an explicit list of processes, the functions also take"
" the ``all_entries`` keyword argument:"
msgstr ""

#: ../../source/topics/provenance/caching.rst:5
msgid "Caching and hashing"
msgstr ""

#: ../../source/topics/provenance/caching.rst:7
msgid ""
"This section covers the more general considerations of the hashing/caching "
"mechanism. For a more practical guide on how to enable and disable this "
"feature, please visit the corresponding :ref:`how-to section <how-to:run-"
"codes:caching>`. If you want to know more about how the internal design of "
"the mechanism is implemented, you can check the :ref:`internals section "
"<internal_architecture:engine:caching>` instead."
msgstr ""

#: ../../source/topics/provenance/caching.rst:15
msgid "How are nodes hashed"
msgstr ""

#: ../../source/topics/provenance/caching.rst:17
msgid ""
"*Hashing* is turned on by default, i.e., all nodes in AiiDA are hashed. This"
" means that even when you enable caching once you have already completed a "
"number of calculations, those calculations can still be used retro-actively "
"by the caching mechanism since their hashes have been computed."
msgstr ""

#: ../../source/topics/provenance/caching.rst:20
msgid "The hash of a ``Data`` node is computed from:"
msgstr ""

#: ../../source/topics/provenance/caching.rst:22
msgid ""
"all attributes of the node, except the ``_updatable_attributes`` and "
"``_hash_ignored_attributes``"
msgstr ""

#: ../../source/topics/provenance/caching.rst:23
msgid "the ``__version__`` of the package which defined the node class"
msgstr ""

#: ../../source/topics/provenance/caching.rst:24
msgid "the content of the repository folder of the node"
msgstr ""

#: ../../source/topics/provenance/caching.rst:25
msgid "the UUID of the computer, if the node is associated with one"
msgstr ""

#: ../../source/topics/provenance/caching.rst:27
msgid ""
"The hash of a :class:`~aiida.orm.ProcessNode` includes, on top of this, the "
"hashes of all of its input ``Data`` nodes."
msgstr ""

#: ../../source/topics/provenance/caching.rst:29
msgid ""
"Once a node is stored in the database, its hash is stored in the "
"``_aiida_hash`` extra, and this extra is used to find matching nodes. If a "
"node of the same class with the same hash already exists in the database, "
"this is considered a cache match. You can use the "
":meth:`~aiida.orm.nodes.caching.NodeCaching.get_hash` method to check the "
"hash of any node. In order to figure out why a calculation is *not* being "
"reused, the "
":meth:`~aiida.orm.nodes.caching.NodeCaching._get_objects_to_hash` method may"
" be useful:"
msgstr ""

#: ../../source/topics/provenance/caching.rst:64
msgid "Controlling hashing"
msgstr ""

#: ../../source/topics/provenance/caching.rst:67
msgid "Data nodes"
msgstr ""

#: ../../source/topics/provenance/caching.rst:69
msgid ""
"The hashing of *Data nodes* can be customized both when implementing a new "
"data node class and during runtime."
msgstr ""

#: ../../source/topics/provenance/caching.rst:71
msgid "In the :py:class:`~aiida.orm.Node` subclass:"
msgstr ""

#: ../../source/topics/provenance/caching.rst:73
msgid ""
"Use the ``_hash_ignored_attributes`` to exclude a list of node attributes "
"``['attr1', 'attr2']`` from computing the hash."
msgstr ""

#: ../../source/topics/provenance/caching.rst:74
msgid ""
"Include extra information in computing the hash by overriding the "
":meth:`~aiida.orm.nodes.caching.NodeCaching._get_objects_to_hash` method. "
"Use the ``super()`` method, and then append to the list of objects to hash."
msgstr ""

#: ../../source/topics/provenance/caching.rst:77
msgid ""
"You can also modify hashing behavior during runtime by passing a keyword "
"argument to :meth:`~aiida.orm.nodes.caching.NodeCaching.get_hash`, which are"
" forwarded to :meth:`~aiida.common.hashing.make_hash`."
msgstr ""

#: ../../source/topics/provenance/caching.rst:80
msgid "Process nodes"
msgstr ""

#: ../../source/topics/provenance/caching.rst:82
msgid ""
"The hashing of *Process nodes* is fixed and can only be influenced "
"indirectly via the hashes of their inputs. For implementation details of the"
" hashing mechanism for process nodes, see :ref:`here "
"<internal_architecture:engine:caching>`."
msgstr ""

#: ../../source/topics/provenance/caching.rst:88
msgid "Controlling Caching"
msgstr ""

#: ../../source/topics/provenance/caching.rst:90
msgid ""
"In the caching mechanism, there are two different types of roles played by "
"the nodes: the node that is currently being stored is called the `target`, "
"and the nodes already stored in the database that are considered to be "
"equivalent are referred to as a `source`."
msgstr ""

#: ../../source/topics/provenance/caching.rst:93
msgid "Targets"
msgstr ""

#: ../../source/topics/provenance/caching.rst:95
msgid ""
"Controlling what nodes will look in the database for existing equivalents "
"when being stored is done on the class level. Section :ref:`how-to:run-"
"codes:caching:configure` explains how this can be controlled globally "
"through the profile configuration, or locally through context managers."
msgstr ""

#: ../../source/topics/provenance/caching.rst:99
msgid "Sources"
msgstr ""

#: ../../source/topics/provenance/caching.rst:101
msgid ""
"When a node is being stored (the `target`) and caching is enabled for its "
"node class (see section above), a valid cache `source` is obtained through "
"the method :meth:`~aiida.orm.nodes.caching.NodeCaching._get_same_node`. This"
" method calls the iterator "
":meth:`~aiida.orm.nodes.caching.NodeCaching._iter_all_same_nodes` and takes "
"the first one it returns if there are any. To find the list of `source` "
"nodes that are equivalent to the `target` that is being stored, "
":meth:`~aiida.orm.nodes.caching.NodeCaching._iter_all_same_nodes` performs "
"the following steps:"
msgstr ""

#: ../../source/topics/provenance/caching.rst:105
msgid ""
"It queries the database for all nodes that have the same hash as the "
"`target` node."
msgstr ""

#: ../../source/topics/provenance/caching.rst:106
msgid ""
"From the result, only those nodes are returned where the property "
":meth:`~aiida.orm.nodes.caching.NodeCaching.is_valid_cache` returns "
"``True``."
msgstr ""

#: ../../source/topics/provenance/caching.rst:108
msgid ""
"The property :meth:`~aiida.orm.nodes.caching.NodeCaching.is_valid_cache` "
"therefore allows to control whether a stored node can be used as a `source` "
"in the caching mechanism. By default, for all nodes, the property returns "
"``True``. However, this can be changed on a per-node basis, by setting it to"
" ``False``"
msgstr ""

#: ../../source/topics/provenance/caching.rst:117
msgid ""
"Setting the property to ``False``, will cause an extra to be stored on the "
"node in the database, such that even when it is loaded at a later point in "
"time, ``is_valid_cache`` returns ``False``."
msgstr ""

#: ../../source/topics/provenance/caching.rst:124
msgid ""
"Through this method, it is possible to guarantee that individual nodes are "
"never used as a `source` for caching."
msgstr ""

#: ../../source/topics/provenance/caching.rst:126
msgid ""
"The :class:`~aiida.engine.processes.process.Process` class overrides the "
":meth:`~aiida.orm.nodes.caching.NodeCaching.is_valid_cache` property to give"
" more fine-grained control on process nodes as caching sources. If either "
":meth:`~aiida.orm.nodes.caching.NodeCaching.is_valid_cache` of the base "
"class or :meth:`~aiida.orm.nodes.process.process.ProcessNode.is_finished` "
"returns ``False``, the process node is not a valid source. Likewise, if the "
"process class cannot be loaded from the node, through the "
":meth:`~aiida.orm.nodes.process.process.ProcessNode.process_class`, the node"
" is not a valid caching source. Finally, if the associated process class "
"implements the "
":meth:`~aiida.engine.processes.process.Process.is_valid_cache` method, it is"
" called, passing the node as an argument. If that returns ``True``, the node"
" is considered to be a valid caching source."
msgstr ""

#: ../../source/topics/provenance/caching.rst:132
msgid ""
"The :meth:`~aiida.engine.processes.process.Process.is_valid_cache` is "
"implemented on the :class:`~aiida.engine.processes.process.Process` class. "
"It will check whether the exit code that is set on the node, if any, has the"
" keyword argument ``invalidates_cache`` set to ``True``, in which case the "
"property will return ``False`` indicating the node is not a valid caching "
"source. Whether an exit code invalidates the cache, is controlled with the "
"``invalidates_cache`` argument when it is defined on the process spec "
"through the :meth:`spec.exit_code "
"<aiida.engine.processes.process_spec.ProcessSpec.exit_code>` method."
msgstr ""

#: ../../source/topics/provenance/caching.rst:138
msgid ""
"Process plugins can override the "
":meth:`~aiida.engine.processes.process.Process.is_valid_cache` method, to "
"further control how nodes are considered valid caching sources. When doing "
"so, make sure to call :meth:`super().base.caching.is_valid_cache(node) "
"<aiida.engine.processes.process.Process.is_valid_cache>` and respect its "
"output: if it is `False`, your implementation should also return `False`. If"
" you do not comply with this, the ``invalidates_cache`` keyword on exit "
"codes will no longer work."
msgstr ""

#: ../../source/topics/provenance/caching.rst:146
msgid "Limitations and Guidelines"
msgstr ""

#: ../../source/topics/provenance/caching.rst:148
msgid ""
"Workflow nodes are not cached. In the current design this follows from the "
"requirement that the provenance graph be independent of whether caching is "
"enabled or not:"
msgstr ""

#: ../../source/topics/provenance/caching.rst:151
msgid ""
"**Calculation nodes:** Calculation nodes can have data inputs and create new"
" data nodes as outputs. In order to make it look as if a cloned calculation "
"produced its own outputs, the output nodes are copied and linked as well."
msgstr ""

#: ../../source/topics/provenance/caching.rst:153
msgid ""
"**Workflow nodes:** Workflows differ from calculations in that they can "
"*return* an input node or an output node created by a calculation. Since "
"caching does not care about the *identity* of input nodes but only their "
"*content*, it is not straightforward to figure out which node to return in a"
" cached workflow."
msgstr ""

#: ../../source/topics/provenance/caching.rst:156
msgid ""
"This limitation has typically no significant impact since the runtime of "
"AiiDA work chains is commonly dominated by expensive calculations."
msgstr ""

#: ../../source/topics/provenance/caching.rst:158
msgid ""
"The caching mechanism for calculations *should* trigger only when the inputs"
" and the calculation to be performed are exactly the same. While AiiDA's "
"hashes include the version of the Python package containing the "
"calculation/data classes, it cannot detect cases where the underlying Python"
" code was changed without increasing the version number. Another scenario "
"that can lead to an erroneous cache hit is if the parser and calculation are"
" not implemented as part of the same Python package, because the calculation"
" nodes store only the name, but not the version of the used parser."
msgstr ""

#: ../../source/topics/provenance/caching.rst:162
msgid ""
"While caching saves unnecessary computations, it does not necessarily save "
"space as the cached calculation and its output nodes are duplicated in the "
"provenance graph. However, AiiDA's default disk-objectstore storage backend "
"comes with automatic de-duplication at the object level. Disk usage "
"therefore remains unaffected with this backend, except for node metadata "
"stored at the database level."
msgstr ""

#: ../../source/topics/provenance/caching.rst:166
msgid ""
"Finally, When modifying the hashing/caching behaviour of your classes, keep "
"in mind that cache matches can go wrong in two ways:"
msgstr ""

#: ../../source/topics/provenance/caching.rst:168
msgid ""
"False negatives, where two nodes *should* have the same hash but do not"
msgstr ""

#: ../../source/topics/provenance/caching.rst:169
msgid ""
"False positives, where two different nodes get the same hash by mistake"
msgstr ""

#: ../../source/topics/provenance/caching.rst:171
msgid ""
"False negatives are **highly preferrable** because they only increase the "
"runtime of your calculations, while false positives can lead to wrong "
"results."
msgstr ""

#: ../../source/topics/provenance/concepts.rst:8
msgid "Nodes and links"
msgstr ""

#: ../../source/topics/provenance/concepts.rst:10
msgid ""
"Two of the most important concepts in AiiDA are **data** and **processes**. "
"The former are pieces of data, such as a simple integer or float, all the "
"way to more complex data concepts such as a dictionary of parameters, a "
"folder of files or a crystal structure. Processes operate on this data in "
"order to produce new data."
msgstr ""

#: ../../source/topics/provenance/concepts.rst:14
msgid "Processes come in two different forms:"
msgstr ""

#: ../../source/topics/provenance/concepts.rst:16
msgid ""
"**Calculations** are processes that are able to **create** new data. This is"
" the case, for instance, for externals simulation codes, that generate new "
"data"
msgstr ""

#: ../../source/topics/provenance/concepts.rst:17
msgid ""
"**Workflows** are processes that **orchestrate** other workflows and "
"calculations, i.e. they manage the logical flow, being able to **call** "
"other processes. Workflows have data inputs, but cannot generate new data. "
"They can only return data that is already in the database (one typical case "
"is to return data created by a calculation they called)."
msgstr ""

#: ../../source/topics/provenance/concepts.rst:19
msgid ""
"Data and processes are represented in the AiiDA provenance graph as the "
"**nodes** of that graph. The graph edges are referred to as **links** and "
"come in different forms:"
msgstr ""

#: ../../source/topics/provenance/concepts.rst:22
msgid ""
"**input** links: connect data nodes to the process nodes that used them as "
"input, both calculations and workflows"
msgstr ""

#: ../../source/topics/provenance/concepts.rst:23
msgid ""
"**create** links: connect calculation nodes to the data nodes that they "
"created"
msgstr ""

#: ../../source/topics/provenance/concepts.rst:24
msgid ""
"**return** links: connect workflow nodes to the data nodes that they "
"returned"
msgstr ""

#: ../../source/topics/provenance/concepts.rst:25
msgid ""
"**call** links: connecting workflow nodes to the process nodes that they "
"directly called, be it calculations or workflows"
msgstr ""

#: ../../source/topics/provenance/concepts.rst:27
msgid ""
"Note that the **create** and **return** links are often collectively "
"referred to as **output** links."
msgstr ""

#: ../../source/topics/provenance/concepts.rst:31
msgid "Data provenance and logical provenance"
msgstr ""

#: ../../source/topics/provenance/concepts.rst:33
msgid ""
"AiiDA automatically stores entities in its database and links them forming a"
" **directed graph**. This directed graph automatically tracks the "
"**provenance** of all data produced by calculations or returned by "
"workflows. By tracking the provenance in this way, one can always fully "
"retrace how a particular piece of data came into existence, thus ensuring "
"its reproducibility."
msgstr ""

#: ../../source/topics/provenance/concepts.rst:37
msgid "In particular, we define two types of provenance:"
msgstr ""

#: ../../source/topics/provenance/concepts.rst:39
msgid ""
"The **data provenance**, consisting of the part of the graph that *only* "
"consists of data and calculations (i.e. without considering workflows), and "
"only the **input** and **create** links that connect them. The data "
"provenance records the full history of how data has been generated. Due to "
"the causality principle, the data provenance part of the graph is a "
"**directed acyclic graph** (DAG), i.e. its nodes are connected by directed "
"edges and it does not contain any cycles."
msgstr ""

#: ../../source/topics/provenance/concepts.rst:40
msgid ""
"The **logical provenance** which consists of workflow and data nodes, "
"together with the **input**, **return** and **call** links that connect "
"them. The logical provenance is *not* acyclic, e.g. a workflow that acts as "
"a filter can return one of its own inputs, directly introducing a cycle."
msgstr ""

#: ../../source/topics/provenance/concepts.rst:42
msgid ""
"The data provenance is essentially a log of which calculation generated what"
" data using certain inputs. The data provenance alone already guarantees "
"reproducibility (one could run again one by one the calculations with the "
"provided input and would obtain the same outputs). The logical provenance "
"gives additional information on why a specific calculation was run. Imagine "
"the case in which you start from 100 structures, you have a filter operation"
" that picks one, and then you run a simulation on it. The data provenance "
"only shows the simulation you run on the structure that was picked, while "
"the logical provenance can also show that the specific structure was not "
"picked at random but via a specific workflow logic."
msgstr ""

#: ../../source/topics/provenance/concepts.rst:49
msgid "Other entities"
msgstr ""

#: ../../source/topics/provenance/concepts.rst:51
msgid ""
"Beside nodes (data and processes), AiiDA defines a few more entities, like a"
" :py:class:`~aiida.orm.computers.Computer` (representing a computer, "
"supercomputer or computer cluster where calculations are run or data is "
"stored), a :py:class:`~aiida.orm.groups.Group` (that group nodes together "
"for organizational purposes) and the :py:class:`~aiida.orm.users.User` (to "
"keep track of the user who first generated a given node, computer or group)."
msgstr ""

#: ../../source/topics/provenance/concepts.rst:53
msgid ""
"In the following section we describe in more detail how the general "
"provenance concepts above are actually implemented in AiiDA, with specific "
"reference to the python classes that implement them and the class-"
"inheritance relationships."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:5
msgid "Consistency"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:7
msgid ""
"Because of the very nature of scientific research, it becomes indispensable "
"to be able to both delete parts of a database (e.g., if errors are made, "
"inputs are misspelled, or useless calculations are performed) or export it "
"(for collaboration or publication purposes). Both these features, which are "
"provided by AiiDA, have one aspect in common: they can easily lead to a "
"provenance graph with incomplete information. To better understand why, "
"let's take a look at the following basic provenance graph:"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:14
msgid ""
"Even in this simple case, if we were to export only the calculation node and"
" the output data node (or, equivalently, delete just the input data node), "
"then we would have lost part of the critical information needed to run the "
"calculation (the |D_1| node), thus losing the reproducibility of the "
"calculation |C_1|. In this simple case, therefore, in order to have a "
"consistent provenance, whenever you export a calculation node you must also "
"import *all* of its input nodes (or, symmetrically, whenever you delete a "
"data node you must also delete all calculations that used it as an input)."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:17
msgid ""
"This is just one of the many rules that must be considered when trying to "
"manually edit a provenance database. The key message to remember is that "
"AiiDA will not only delete or export the nodes explicitly targeted by the "
"user, but will also include any other nodes that are needed for keeping a "
"consistent provenance in the resulting database."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:20
msgid ""
"It is also worth noting that if you do successive exports of partial "
"information, AiiDA will be able to reconstruct links that might have been "
"broken when dividing the data for export. So if you first where to export "
"the previous graph, and then you exported the next section of your full "
"database:"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:26
msgid ""
"Then AiiDA will be able to automatically identify the shared node |D_2| and "
"connect both sections back together during the import process. For this kind"
" of recognition it doesn't matter which sub-graph was exported first."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:29
msgid ""
"In the following section we will explain in more detail the criteria for "
"including other nodes and the corresponding traversal rules."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:34
msgid "Traversal Rules"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:36
msgid ""
"When you run ``verdi node delete [NODE_IDS]`` or ``verdi archive create -N "
"[NODE_IDS]``, AiiDA will look at the links incoming or outgoing from the "
"nodes that you specified and decide if there are other nodes that are "
"critical to keep."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:38
msgid ""
"For this decision, it is not only important to consider the type of link, "
"but also if we are following it along its direction (we will call this "
"``forward`` direction) or in the reversed direction (``backward`` "
"direction). To clarify this, in the example above, when deleting data node "
"|D_1|, AiiDA will follow the ``input_calc`` link in the ``forward`` "
"direction (in this case, it will decide that the linked node (|C_1|) must "
"then also be deleted). If the initial target node was, instead, |C_1| the "
"``input_calc`` link would be followed in the ``backward`` direction (and in "
"this case the node |D_1| will not be deleted, as we will explain below)."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:42
msgid ""
"This process will be repeated recursively for every node that has just been "
"included for deletion or export, until no more nodes need to be added. The "
"rules defining whether a linked node should be added or not to the "
"delete/export list (based on the kind and direction of the link) are called "
"*traversal rules*. In the following section we will describe these rules "
"both for the export and delete procedures."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:46
msgid ""
"The tables below are grouped according to the type of nodes and links "
"involved. We also provide illustrations of the cases considered, where the "
"encircled node is the one being targeted, and the other node (to which the "
"red arrow is pointing) is the one that is being considered for addition into"
" the delete/export list."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:50
msgid "Data and Calculation Nodes"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:52
msgid ""
"The first example above already discusses the case of deleting an input "
"node: in this case, it is necessary to also delete any calculation that uses"
" it as an input."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:54
msgid ""
"In AiiDA, we apply the same criterion also when deleting an output: in this "
"case, we follow the ``create`` link in the ``backward`` direction and we "
"mark for deletion also the calculation that created it. The reason for this "
"is that a calculation with missing outputs could be misleading. For "
"instance, some calculations produce optional outputs depending on the "
"combination of input flags that are used. A missing output might be "
"interpreted as if that piece of information was not computed by the "
"calculation. In the case of export, the rules are typically the reverse of "
"those used for deletion. Therefore, in this case, the following rule "
"applies: when exporting a calculation node, all its input data nodes and "
"created output nodes must be exported as well."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:60
msgid ""
"On the other hand, when exporting a data node, users typically do not need "
"to also export all the calculations that used it as an input. These may "
"represent further work that, by default, does not need to be exported as "
"well (unless explicitly specified by the user in the list of nodes). "
"Equivalently, when deleting a calculation, one typically wants to keep its "
"inputs, as they might be used by other unrelated calculations."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:64
msgid ""
"What should happen instead for the outputs of a calculation to be deleted? "
"Often, one might want to delete (recursively) all the outputs generated by "
"it. However, we leave the option to users to just delete the calculation, "
"keeping its outputs in the database. While we emphasize that this operation "
"removes all provenance information for the output nodes, there are cases in "
"which this is useful or even needed (removal of inputs that are protected by"
" copyright, or creating a smaller archive file to transfer to collaborators "
"who want to work with the output data)."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:70
#: ../../source/topics/provenance/consistency.rst:101
#: ../../source/topics/provenance/consistency.rst:137
msgid "Illustrative diagram (explicitly targeted node is encircled)"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:70
#: ../../source/topics/provenance/consistency.rst:101
#: ../../source/topics/provenance/consistency.rst:137
msgid "Name of Rule"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:70
#: ../../source/topics/provenance/consistency.rst:101
#: ../../source/topics/provenance/consistency.rst:137
msgid "Behavior when exporting target node"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:70
#: ../../source/topics/provenance/consistency.rst:101
#: ../../source/topics/provenance/consistency.rst:137
msgid "Behavior when deleting target node"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:73
msgid "``input_calc_forward``"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:73
#: ../../source/topics/provenance/consistency.rst:104
msgid "Default Value: ``False``"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:74
#: ../../source/topics/provenance/consistency.rst:105
#: ../../source/topics/provenance/consistency.rst:114
msgid "Linked node **won't** be exported **by default**."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:73
#: ../../source/topics/provenance/consistency.rst:76
#: ../../source/topics/provenance/consistency.rst:79
#: ../../source/topics/provenance/consistency.rst:82
#: ../../source/topics/provenance/consistency.rst:104
#: ../../source/topics/provenance/consistency.rst:107
#: ../../source/topics/provenance/consistency.rst:110
#: ../../source/topics/provenance/consistency.rst:113
#: ../../source/topics/provenance/consistency.rst:140
#: ../../source/topics/provenance/consistency.rst:143
#: ../../source/topics/provenance/consistency.rst:146
#: ../../source/topics/provenance/consistency.rst:149
msgid "Fixed Value: ``True``"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:74
#: ../../source/topics/provenance/consistency.rst:83
#: ../../source/topics/provenance/consistency.rst:105
#: ../../source/topics/provenance/consistency.rst:114
#: ../../source/topics/provenance/consistency.rst:144
#: ../../source/topics/provenance/consistency.rst:150
msgid "Linked node **will always** be deleted."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:76
msgid "``input_calc_backward``"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:77
#: ../../source/topics/provenance/consistency.rst:80
#: ../../source/topics/provenance/consistency.rst:108
#: ../../source/topics/provenance/consistency.rst:111
#: ../../source/topics/provenance/consistency.rst:141
#: ../../source/topics/provenance/consistency.rst:147
msgid "Linked node **will always** be exported."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:76
msgid "Fixed Value: ``False`` [#f01]_"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:77
#: ../../source/topics/provenance/consistency.rst:108
#: ../../source/topics/provenance/consistency.rst:111
msgid "Linked node **will never** be deleted."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:79
msgid "``create_forward``"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:79
#: ../../source/topics/provenance/consistency.rst:140
#: ../../source/topics/provenance/consistency.rst:143
#: ../../source/topics/provenance/consistency.rst:146
msgid "Default Value: ``True``"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:80
#: ../../source/topics/provenance/consistency.rst:141
#: ../../source/topics/provenance/consistency.rst:147
msgid "Linked node **will** be deleted **by default**."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:82
msgid "``create_backward``"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:82
#: ../../source/topics/provenance/consistency.rst:149
msgid "Default Value: ``True``."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:83
#: ../../source/topics/provenance/consistency.rst:144
#: ../../source/topics/provenance/consistency.rst:150
msgid "Linked node **will** be exported **by default**."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:87
msgid ""
"Although we provide the option to automatically export all calculations that"
" use as input any targeted data node (by specifying "
"``input_calc_forward=True``) we *currently* do not provide the reciprocal "
"option to delete all the data node inputs when targeting calculation nodes. "
"This is mainly for the potential danger that would imply automatically "
"enabling upwards traversal of the data provenance when deleting, which would"
" make it extremely hard to predict or control the nodes that will be "
"ultimately affected."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:92
msgid "Data and Workflow Nodes"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:94
msgid ""
"The behavior when considering ``input_work`` links is exactly the same as "
"when considering ``input_calc`` links for the same reasons. The case for "
"``return`` links is partially similar to the one for ``create`` one. Indeed,"
" it isn't desirable to have a resulting database with missing outputs, so "
"when exporting a workflow the returned data nodes will also be included (and"
" when deleting a data node, the returning workflow will also be removed). "
"However, when exporting a returned node, the default behavior is *not* to "
"traverse backwards through the ``return`` links, since a data node might be "
"returned by several unrelated workflows (representing selection procedures "
"for other studies, for example) that are unrelated to its creation. The "
"workflow responsible for coordinating its creation will be included in the "
"export, not directly, but through the chain effect of including the creating"
" calculation (through ``create_backward``) and then including its calling "
"workflows (through ``call_calc_backward`` and ``call_work_backward``, see "
"next sections)."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:104
msgid "``input_work_forward``"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:107
msgid "``input_work_backward``"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:107
msgid "Fixed Value: ``False``"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:110
msgid "``return_forward``"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:110
msgid "Fixed Value: ``False`` [#f02]_"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:113
msgid "``return_backward``"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:113
msgid "Default Value: ``False``."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:118
msgid ""
"The reason to prevent the deletion of returned data nodes is that, since the"
" logical provenance can be cyclical, this might end up deleting inputs and "
"thus propagating the deletion process to other unrelated parts of the "
"database. In most cases where you will want to delete a returned data node, "
"you will be able to do so by setting ``call_calc_forward=True`` (see below) "
"and ``create_forward=True`` (which is the default value)."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:124
msgid "Workflows and Calculation Nodes"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:126
msgid ""
"Finally, we will consider the possible (call) links between processes. The "
"results of a parent workflow depend critically on the sub-workflows or "
"calculations launched by it. When exporting a workflow node, we therefore "
"always traverse its ``call`` links (both ``call_calc`` and ``call_work``) in"
" the ``forward`` direction to include all children processes (i.e. processes"
" directly called by it). Since the traversal rules are applied recursively, "
"this means that also the children processes of any workflow that was a child"
" of the targeted one will be exported as well, and so on. Analogously, when "
"deleting a process the same applies but in the opposite direction "
"(``backward``), including the parent workflow of the targeted node (if there"
" is one), and the parent of that parent, etc."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:132
msgid ""
"Since ``call`` links are followed backward by default, targeting one process"
" for either export or deletion results in selecting not only all of its "
"child processes but also all children of any of its parent processes. As a "
"result of all ``call`` links being traversed in both directions, targeting "
"any of the process nodes in a workflow will mean the inclusion of the other "
"processes of that workflow as well. Users can disable the traversal of "
"``call`` links in one of the directions (``forward`` for deletion, "
"``backward`` for export) for fine-grained control (see examples below)."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:140
msgid "``call_calc_forward``"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:143
msgid "``call_calc_backward``"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:146
msgid "``call_work_forward``"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:149
msgid "``call_work_backward``"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:155
msgid "Cascading rules: an example"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:157
msgid ""
"In the previous sections we have described the basic rules used by AiiDA to "
"decide which nodes should also be included from an initial list of nodes to "
"delete or export. These rules are applied recursively: as new nodes are "
"included in the deletion (or export)list, the rules are applied to them as "
"well until no new nodes are included. Therefore, the consequence of using "
"these features on a given set of nodes may not always be straightforward, "
"and the final set might include more nodes than naively expected."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:161
msgid ""
"Let us first focus on the data provenance only (i.e., only ``input_calc`` "
"and ``create`` links). The following two rules apply when going in the "
"``forward`` direction:"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:163
msgid ""
"If you delete a data node, any calculation that uses it as input will "
"*always* be deleted as well (``input_calc_forward=True``)."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:164
msgid ""
"If you delete a calculation node, any output data node will be deleted *by "
"default* (``create_forward=True``)."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:166
msgid ""
"The consequence of these two together is a \"chain reaction\" in which every"
" node that can be traced back through the data provenance to any of the "
"initial targeted nodes will end up being deleted as well. The reciprocal is "
"true for the export: the default behavior is that every ancestor will also "
"be exported by default (because ``create_backward`` is ``True`` by default "
"and ``input_calc_backward`` is always ``True``)."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:169
msgid ""
"In regards to the connection between data provenance and logical provenance,"
" the most important thing to understand is how the default behavior of the "
"program treats the highest-level workflows as the units to be handled. The "
"logic behind this is the assumption that the typical user of the program "
"will be dealing with it mostly in an interactive way, running pre-defined "
"workflows through the verdi command line without needing a detailed "
"knowledge of their internal procedures. The default behavior then was "
"designed to reproduce the most intuitive outcomes for this type of usage."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:173
msgid ""
"This behavior is basically the result of the settings of "
"``call_calc_forward=True`` and ``call_work_forward=True``, which makes that "
"the inclusion of a process node will also imply the inclusion of any child "
"or parent process node as well. Following these rules in a recursive way "
"leads to the command affecting all the processes within any given workflow: "
"in this way, nodes that are sub-processes of a given highest-level workflow "
"will end up grouped together, in the sense that (by default) they will all "
"be affected in the same way when deleting or exporting."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:176
msgid ""
"More freedom to further customize the selection of sections to export or "
"delete is available through the specific switchable flags for each "
"functionality (although the final sections must always comply with the non-"
"switchable rules, see above). However, this usually requires a deeper "
"understanding of the traversal rules and may imply a more thorough analysis "
"of the particular graph. To better illustrate this, we will now consider the"
" application of the deletion procedure to the following graph:"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:184
msgid ""
"As you can see, |W_1| and |W_2| describe two similar but independent "
"procedures that were launched by a single parent workflow |W_0|. A typical "
"user would have obtained this by directly running this workflow |W_0| to "
"obtain the results |D_3| and |D_4| from the inputs |D_1| and |D_2|, and may "
"even be unaware of the internal division of |W_0| into two sub-Workflows "
"|W_1| and |W_2|. Hence, if the user considers the workflow (meaning, the "
"whole set of nodes produced by it) no longer necessary, the intuitive thing "
"to do in order to remove it from its database would be by targeting the "
"workflow node |W_0| for deletion. Indeed, this would produce the desired "
"result:"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:193
msgid ""
"The nodes |W_1| and |W_2| would be included because |W_0| is being targeted "
"(``call_work_forward=True``), then the nodes |C_1| and |C_2| would also be "
"included (``call_calc_forward=True``), and finally the nodes |D_3| and |D_4|"
" would end up being included as well (``create_forward=True``). In the end, "
"only the inputs |D_1| and |D_2| remain (since ``input_work_backward=False`` "
"always and ``input_calc_backward=False`` by default)."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:196
msgid ""
"The same result would occur if the user were to target the output nodes "
"instead (intending to delete everything associated with the obtention of "
"those results). It is important to notice that even if the user deletes only"
" one of the outputs, the whole set of nodes generated by the workflow would "
"be deleted, and not just the ones associated to the targeted data node. As "
"the results |D_3| and |D_4| where obtained from the same high-level process "
"|W_0|, then the default behavior has the underlying assumption that they are"
" interconnected and not independent from one another (as if they were two "
"different outputs of a single calculation)."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:204
msgid ""
"In this case, the node |C_1| would first be included because the data node "
"|D_3| is being targeted (``create_reverse=True``), and this in turn would "
"include the node |W_1| (``call_calc_reverse=True``) and then its parent "
"workflow |W_0| (``call_work_reverse=True``). Then nodes |W_2|, |C_2| and "
"|D_4| will be included because |W_0| was included, for the same reasons that"
" were explained in the paragraphs above."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:209
msgid "Customizing the graph traversal (for deletion or export)"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:211
msgid ""
"This dependency between nodes becomes particularly relevant when, for "
"example, a user with more knowledge of the internal procedures of the parent"
" workflow |W_0| wants to only delete the calculations and results associated"
" to workflow |W_1|. The intuitive action of targeting |W_1| does not produce"
" the desired outcome:"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:218
msgid ""
"Indeed |C_1| and |D_4| will be deleted (through ``call_calc_forward`` from "
"|W_1| to |C_1| and ``create_forward`` from |C_1| to |D_3|), but so will "
"|W_0| (through ``call_work_reverse`` from |W_1|), |W_2| "
"(``call_work_forward`` from |W_0|), |C_2| (``call_calc_forward`` from |W_2|)"
" and |D_4| (``create_forward`` from |C_2|). The way to achieve the desired "
"outcome is not trivial, although in some situations like this, one could "
"propose case-specific solutions such as targeting |W_1| with the switchable "
"flag ``call_work_forward=False`` (preventing the traversal from |W_0| to "
"|W_2|):"
msgstr ""

#: ../../source/topics/provenance/consistency.rst:225
msgid ""
"However, this approach is not generally applicable, and wouldn't work if "
"|W_1| had sub-workflows that needed to be deleted as well. A more general "
"approach is to first sever the connection to |W_2| by deleting node |W_0| "
"with all switchable traversal rules turned off. Then, once the independence "
"of |W_1| and |W_2| is explicitly reflected in the graph, node |W_1| can be "
"deleted with the default settings."
msgstr ""

#: ../../source/topics/provenance/consistency.rst:233
msgid ""
"It is worth noting that if the workflow |W_0| was itself part of a higher-"
"level workflow, all that higher-level logic would be deleted due to the non-"
"switchable rule ``call_work_reverse=True``. This is an inevitable outcome of"
" deleting part of a workflow, since due to the loss of that information it "
"has become incomplete and it makes no sense to keep it."
msgstr ""

#: ../../source/topics/provenance/implementation.rst:5
#: ../../source/topics/workflows/concepts.rst:130
msgid "Implementation"
msgstr ""

#: ../../source/topics/provenance/implementation.rst:8
msgid "Graph nodes"
msgstr ""

#: ../../source/topics/provenance/implementation.rst:10
msgid ""
"The **nodes** of the AiiDA provenance graph can be grouped into two main "
"**types**: **process nodes** (``ProcessNode``), that represent the execution"
" of calculations or workflows, and **data nodes** (``Data``), that represent"
" pieces of data."
msgstr ""

#: ../../source/topics/provenance/implementation.rst:12
msgid "In particular, **process nodes** are divided into two sub categories:"
msgstr ""

#: ../../source/topics/provenance/implementation.rst:14
msgid ""
"**calculation nodes** (``CalculationNode``): Represent code execution that "
"creates new data. These are further subdivided in two subclasses:"
msgstr ""

#: ../../source/topics/provenance/implementation.rst:16
msgid ""
":py:class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode`: "
"Represents the execution of a calculation external to AiiDA, typically via a"
" job batch scheduler (see the concept of :ref:`calculation "
"jobs<topics:calculations:concepts:calcjobs>`)."
msgstr ""

#: ../../source/topics/provenance/implementation.rst:17
msgid ""
":py:class:`~aiida.orm.nodes.process.calculation.calcfunction.CalcFunctionNode`:"
" Represents the execution of a python function (see the concept of "
":ref:`calculation functions<topics:calculations:concepts:calcfunctions>`)."
msgstr ""

#: ../../source/topics/provenance/implementation.rst:19
msgid ""
"**workflow nodes** (``WorkflowNode``): Represent python code that "
"orchestrates the execution of other workflows and calculations, that "
"optionally return the data created by the processes they called. These are "
"further subdivided in two subclasses:"
msgstr ""

#: ../../source/topics/provenance/implementation.rst:21
msgid ""
":py:class:`~aiida.orm.nodes.process.workflow.workchain.WorkChainNode`: "
"Represents the execution of a python class instance with built-in "
"checkpoints, such that the process may be paused/stopped/resumed (see the "
"concept of :ref:`work chains<topics:workflows:concepts:workchains>`)."
msgstr ""

#: ../../source/topics/provenance/implementation.rst:22
msgid ""
":py:class:`~aiida.orm.nodes.process.workflow.workfunction.WorkFunctionNode`:"
" Represents the execution of a python function calling other processes (see "
"the concept of :ref:`work "
"functions<topics:workflows:concepts:workfunctions>`)."
msgstr ""

#: ../../source/topics/provenance/implementation.rst:24
msgid "The class hierarchy of the process nodes is shown in the figure below."
msgstr ""

#: ../../source/topics/provenance/implementation.rst:29
msgid ""
"The hierarchy of the ORM classes for the process nodes. Only instances of "
"the lowest level of classes will actually enter into the provenance graph. "
"The two upper levels have a mostly taxonomical purpose as they allow us to "
"refer to multiple classes at once when reasoning about the graph as well as "
"a place to define common functionality (see section on :ref:`processes "
"<topics:processes:concepts>`)."
msgstr ""

#: ../../source/topics/provenance/implementation.rst:32
msgid ""
"For what concerns data nodes, the base class (``Data``) is subclassed to "
"provide functionalities specific to the data type and python methods to "
"operate on it. Often, the name of the subclass contains the word “Data” "
"appended to it, but this is not a requirement. A few examples:"
msgstr ""

#: ../../source/topics/provenance/implementation.rst:35
msgid ""
":py:class:`~aiida.orm.nodes.data.float.Float`, "
":py:class:`~aiida.orm.nodes.data.int.Int`, "
":py:class:`~aiida.orm.nodes.data.bool.Bool`, "
":py:class:`~aiida.orm.nodes.data.str.Str`, "
":py:class:`~aiida.orm.nodes.data.list.List`, ..."
msgstr ""

#: ../../source/topics/provenance/implementation.rst:36
msgid ""
":py:class:`~aiida.orm.nodes.data.dict.Dict`: represents a dictionary of key-"
"value pairs - these are parameters of a general nature that do not need to "
"belong to more specific data sub-classes"
msgstr ""

#: ../../source/topics/provenance/implementation.rst:37
msgid ""
":py:class:`~aiida.orm.nodes.data.structure.StructureData`: represents "
"crystal structure data (containing chemical symbols, atomic positions of the"
" atoms, periodic cell for periodic structures, …)"
msgstr ""

#: ../../source/topics/provenance/implementation.rst:38
msgid ""
":py:class:`~aiida.orm.nodes.data.array.array.ArrayData`: represents generic "
"numerical arrays of data (python numpy arrays)"
msgstr ""

#: ../../source/topics/provenance/implementation.rst:39
msgid ""
":py:class:`~aiida.orm.nodes.data.array.kpoints.KpointsData`: represents a "
"numerical array of k-points data, is a sub-class of ``ArrayData``"
msgstr ""

#: ../../source/topics/provenance/implementation.rst:41
msgid "For more detailed information see :ref:`AiiDA data types <DataTypes>`."
msgstr ""

#: ../../source/topics/provenance/implementation.rst:43
msgid ""
"In the next section we introduce the links between nodes, creating the AiiDA"
" graph, and then we show some examples to clarify what we introduced up to "
"now."
msgstr ""

#: ../../source/topics/provenance/implementation.rst:46
msgid "Graph links"
msgstr ""

#: ../../source/topics/provenance/implementation.rst:48
msgid ""
"Process nodes are connected to their input and output data nodes through "
"directed links. Calculation processes can *create* data, while workflow "
"processes can *call* calculations and *return* their outputs. Consider the "
"following graph example, where we represent **data nodes** with circles, "
"**calculation nodes** with squares and **workflow nodes** with diamond "
"shapes."
msgstr ""

#: ../../source/topics/provenance/implementation.rst:55
msgid ""
"Simple provenance graph for a workflow (W\\ :sub:`1`) *calling* a "
"calculation (C\\ :sub:`1`). The workflow takes a single **data node** (D\\ "
":sub:`1`\\) as input, and passes it to the calculation when *calling* it. "
"The calculation *creates* a new **data node** (D\\ :sub:`2`\\) that is also "
"*returned* by the **workflow node**."
msgstr ""

#: ../../source/topics/provenance/implementation.rst:57
msgid ""
"Notice that the different style and names for the two links coming into D\\ "
":sub:`2` is intentional, because it was the calculation that *created* the "
"new data, whereas the workflow merely *returned* it. This subtle distinction"
" has big consequences. By allowing workflow processes to *return* data, it "
"can also *return* data that was among its inputs."
msgstr ""

#: ../../source/topics/provenance/implementation.rst:64
msgid ""
"Provenance graph example of a **workflow node** that receives three **data "
"nodes** as input and *returns* one of those inputs. The input link from D\\ "
":sub:`3` to W\\ :sub:`1` and the return link from W\\ :sub:`1` to D\\ "
":sub:`3` introduce a cycle in the graph."
msgstr ""

#: ../../source/topics/provenance/implementation.rst:66
msgid ""
"A scenario like this, represented in :numref:`fig_provenance_cycle`, would "
"create a cycle in the provenance graph, breaking the “acyclicity” of the "
"DAG. To restore the directed acyclic graph, we separate the entire "
"provenance graph into two planes as described above: the **data provenance**"
" and the **logical provenance**. With this division, the acyclicity of the "
"graph is restored in the data provenance plane."
msgstr ""

#: ../../source/topics/provenance/implementation.rst:70
msgid ""
"An additional benefit of thinking of the provenance graph in these two "
"planes, is that it allows you to inspect it with different layers of "
"granularity. Imagine a high level workflow that calls a large number of "
"calculations and sub-workflows, that each may also call more sub-processes, "
"to finally produce and return one or more data nodes as its result."
msgstr ""

#: ../../source/topics/provenance/implementation.rst:75
msgid "Graph examples"
msgstr ""

#: ../../source/topics/provenance/implementation.rst:77
msgid ""
"With these basic definitions of AiiDA’s provenance graph in place, let’s "
"take a look at some examples. Consider the sequence of computations that "
"adds two numbers `x` and `y`, and then multiplies the result with a third "
"number `z`. This sequence as represented in the provenance graph would look "
"something like what is shown in :numref:`fig_provenance_add_multiply_data`."
msgstr ""

#: ../../source/topics/provenance/implementation.rst:84
msgid ""
"The DAG for computing `(x+y)*z`. We have two simple calculations: C\\ "
":sub:`1` represents the addition and C\\ :sub:`2` the multiplication. The "
"two data nodes D\\ :sub:`1` and D\\ :sub:`2` are the inputs of C\\ :sub:`1`,"
" which *creates* the data node D\\ :sub:`4`\\. Together with D\\ :sub:`3`, "
"D\\ :sub:`4` then forms the input of C\\ :sub:`2`, which multiplies their "
"values that *creates* the product, represented by D\\ :sub:`5`."
msgstr ""

#: ../../source/topics/provenance/implementation.rst:88
msgid ""
"In this simple example, there was no external process that controlled the "
"exact sequence of these operations. This may be imagined however, by adding "
"a workflow that calls the two calculations in succession, as shown in "
":numref:`fig_provenance_add_multiply_full`."
msgstr ""

#: ../../source/topics/provenance/implementation.rst:94
msgid ""
"The same calculation `(x+y)*z` is performed using a workflow. Here the data "
"nodes D\\ :sub:`1`, D\\ :sub:`2`, and D\\ :sub:`3` are the inputs of the "
"workflow W\\ :sub:`1`, which *calls* calculation C\\ :sub:`1` with inputs "
"D\\ :sub:`1` and D\\ :sub:`2`. It then *calls* calculation C\\ :sub:`2`, "
"using as inputs D\\ :sub:`3` and D\\ :sub:`4` (which was *created* by C\\ "
":sub:`2`\\). Calculation C\\ :sub:`2` *creates* data node D\\ :sub:`5`, "
"which is finally *returned* by workflow W\\ :sub:`1`\\."
msgstr ""

#: ../../source/topics/provenance/implementation.rst:98
msgid ""
"Notice that if we were to omit the workflow nodes and all its links from the"
" provenance graph in :numref:`fig_provenance_add_multiply_full`, one would "
"end up with the exact same graph as shown in "
":numref:`fig_provenance_add_multiply_data` (the **data provenance** graph)."
msgstr ""

#: ../../source/topics/provenance/index.rst:7
msgid ""
"In this topic section, the concept of the provenance graph and its "
"implementation will be explained. The "
":ref:`consistency<topics:provenance:consistency>` section details the rules "
"that are imposed on the consistency of the provenance graph when nodes are "
"exported or deleted."
msgstr ""

#: ../../source/topics/repository.rst:5
msgid "Repository"
msgstr ""

#: ../../source/topics/repository.rst:7
msgid ""
"In addition to the :ref:`database <topics:database>`, AiiDA also stores "
"information in the *repository* in the form of files. The repository is "
"optimized to store large amounts of files, which allows AiiDA to scale to "
"high-throughput loads. As a result, the files cannot be accessed directly "
"using file system tools, despite the fact that they are stored somewhere on "
"the local file system. Instead, you should interact with the repository "
"through the API."
msgstr ""

#: ../../source/topics/repository.rst:12
msgid ""
"Since each node can have its own *virtual* file hierarchy, the repository "
"contents of a node are accessed through the "
":class:`~aiida.orm.nodes.node.Node` class. The hierarchy is virtual because "
"the files may not actually be written to disk with the same hierarchy. For "
"more technical information on the implementation, please refer to the "
":ref:`repository internals section <internal-architecture:repository>`."
msgstr ""

#: ../../source/topics/repository.rst:20
msgid "Writing to the repository"
msgstr ""

#: ../../source/topics/repository.rst:22
msgid ""
"To write files to a node, you can use one of the following three methods:"
msgstr ""

#: ../../source/topics/repository.rst:24
msgid ""
":meth:`~aiida.orm.nodes.repository.NodeRepository.put_object_from_file`"
msgstr ""

#: ../../source/topics/repository.rst:25
msgid ""
":meth:`~aiida.orm.nodes.repository.NodeRepository.put_object_from_filelike`"
msgstr ""

#: ../../source/topics/repository.rst:26
msgid ""
":meth:`~aiida.orm.nodes.repository.NodeRepository.put_object_from_tree`"
msgstr ""

#: ../../source/topics/repository.rst:28
msgid ""
"Let's assume that you have a file on your local file system called "
"`/some/path/file.txt` that you want to copy to a node. The most "
"straightforward solution is the following:"
msgstr ""

#: ../../source/topics/repository.rst:36
msgid ""
"Note that the first argument should be an absolute filepath. The second "
"argument is the filename with which the file will be written to the "
"repository of the node. It can be any valid filename as long as it is "
"relative. The target filename can contain nested subdirectories, for example"
" `some/relative/path/file.txt`. The nested directories do not have to exist."
msgstr ""

#: ../../source/topics/repository.rst:42
msgid ""
"Alternatively, it is also possible to write a file to a node from a stream "
"or filelike-object. This is useful when the content of the file is already "
"in memory and prevents having to write it to the local filesystem first. For"
" example, one can do the following:"
msgstr ""

#: ../../source/topics/repository.rst:52
msgid ""
"which is the same as the previous example, except the file is opened first "
"in a context manager and then the filelike-object is passed in. The "
":meth:`~aiida.orm.nodes.repository.NodeRepository.put_object_from_filelike` "
"method should work with any filelike-object, for example also byte- and "
"textstreams:"
msgstr ""

#: ../../source/topics/repository.rst:61
msgid ""
"Finally, instead of writing one file at a time, you can write the contents "
"of an entire directory to the node's repository:"
msgstr ""

#: ../../source/topics/repository.rst:68
msgid ""
"The contents of the entire directory will be recursively written to the "
"node's repository. Optionally, you can write the content to a subdirectory "
"in the repository:"
msgstr ""

#: ../../source/topics/repository.rst:76
msgid ""
"As with "
":meth:`~aiida.orm.nodes.repository.NodeRepository.put_object_from_file`, the"
" sub directories do not have to be explicitly created first."
msgstr ""

#: ../../source/topics/repository.rst:82
msgid "Listing repository content"
msgstr ""

#: ../../source/topics/repository.rst:84
msgid ""
"To determine the contents of a node's repository, you can use the following "
"methods:"
msgstr ""

#: ../../source/topics/repository.rst:86
msgid ":meth:`~aiida.orm.nodes.repository.NodeRepository.list_object_names`"
msgstr ""

#: ../../source/topics/repository.rst:87
msgid ":meth:`~aiida.orm.nodes.repository.NodeRepository.list_objects`"
msgstr ""

#: ../../source/topics/repository.rst:88
msgid ":meth:`~aiida.orm.nodes.repository.NodeRepository.walk`"
msgstr ""

#: ../../source/topics/repository.rst:90
msgid ""
"The first method will return a list of file objects contained within the "
"node's repository, where an object can be either a directory or a file:"
msgstr ""

#: ../../source/topics/repository.rst:97
msgid ""
"To determine the contents of a subdirectory, simply pass the path as an "
"argument:"
msgstr ""

#: ../../source/topics/repository.rst:104
msgid ""
"Note that the elements in the returned list are simple strings and so one "
"cannot tell if they correspond to a directory or a file. If this information"
" is needed, use "
":meth:`~aiida.orm.nodes.repository.NodeRepository.list_objects` instead. "
"This method returns a list of :class:`~aiida.repository.common.File` "
"objects. These objects have a "
":meth:`~aiida.repository.common.File.file_type` and "
":meth:`~aiida.repository.common.File.name` property which returns the type "
"and name of the file object, respectively. An example usage would be the "
"following:"
msgstr ""

#: ../../source/topics/repository.rst:120
msgid ""
"To retrieve a specific file object with a particular relative path, use "
":meth:`~aiida.orm.nodes.repository.NodeRepository.get_object`:"
msgstr ""

#: ../../source/topics/repository.rst:127
msgid ""
"Finally, if you want to recursively iterate over the contents of a node's "
"repository, you can use the "
":meth:`~aiida.orm.nodes.repository.NodeRepository.walk` method. It operates "
"exactly as the |os.walk|_:"
msgstr ""

#: ../../source/topics/repository.rst:142
msgid "Reading from the repository"
msgstr ""

#: ../../source/topics/repository.rst:144
msgid ""
"To retrieve the content of files stored in a node's repository, you can use "
"the following methods:"
msgstr ""

#: ../../source/topics/repository.rst:146
msgid ":meth:`~aiida.orm.nodes.repository.NodeRepository.open`"
msgstr ""

#: ../../source/topics/repository.rst:147
msgid ":meth:`~aiida.orm.nodes.repository.NodeRepository.get_object_content`"
msgstr ""

#: ../../source/topics/repository.rst:149
msgid ""
"The first method functions exactly as Python's ``open`` built-in function:"
msgstr ""

#: ../../source/topics/repository.rst:156
msgid ""
"The :meth:`~aiida.orm.nodes.repository.NodeRepository.get_object_content` "
"method provides a short-cut for this operation in case you want to directly "
"read the content into memory:"
msgstr ""

#: ../../source/topics/repository.rst:162
msgid ""
"Both methods accept a second argument to determine whether the file should "
"be opened in text- or binary-mode. The valid values are ``'r'`` and "
"``'rb'``, respectively. Note that these methods can only be used to read "
"content from the repository and so any other read modes, such as ``'wb'``, "
"will result in an exception. To write files to the repository, use the "
"methods that are described in the section on :ref:`writing to the repository"
" <topics:repository:writing>`."
msgstr ""

#: ../../source/topics/repository.rst:171
msgid "Copying from the repository"
msgstr ""

#: ../../source/topics/repository.rst:173
msgid ""
"If you want to copy specific files from a node's repository, the section on "
":ref:`reading from the repository<topics:repository:reading>` shows how to "
"read their content which can then be written elsewhere. However, sometimes "
"you want to copy the entire contents of the node's repository, or a "
"subdirectory of it. The "
":meth:`~aiida.orm.nodes.repository.NodeRepository.copy_tree` method makes "
"this easy and can be used as follows:"
msgstr ""

#: ../../source/topics/repository.rst:181
msgid ""
"which will write the entire repository content of ``node`` to the directory "
"``/some/target/directory`` on the local file system. If you only want to "
"copy a particular subdirectory of the repository, you can pass this as the "
"second ``path`` argument:"
msgstr ""

#: ../../source/topics/repository.rst:188
msgid ""
"This method, combined with "
":meth:`~aiida.orm.nodes.repository.NodeRepository.put_object_from_tree`, "
"makes it easy to copy the entire repository content (or a subdirectory) from"
" one node to another:"
msgstr ""

#: ../../source/topics/repository.rst:200
msgid ""
"Note that this method is not the most efficient as the files are first "
"written from ``node_a`` to a temporary directory on disk, before they are "
"read in memory again and written to the repository of ``node_b``. There is a"
" more efficient method which requires a bit more code and that directly uses"
" the :meth:`~aiida.orm.nodes.repository.NodeRepository.walk` method "
"explained in the section on :ref:`listing repository content "
"<topics:repository:listing>`."
msgstr ""

#: ../../source/topics/repository.rst:214
msgid ""
"In the example above, only the files are explicitly copied over. Any "
"intermediate nested directories will be automatically created in the virtual"
" hierarchy. However, currently it is not possible to create a directory "
"explicitly. Empty directories are not yet supported."
msgstr ""

#: ../../source/topics/schedulers.rst:5
msgid "Batch Job Schedulers"
msgstr ""

#: ../../source/topics/schedulers.rst:7
msgid ""
"Batch job schedulers manage the job queues and execution on a compute "
"resource. AiiDA ships with plugins for a range of schedulers, and this "
"section describes the interface of these plugins."
msgstr ""

#: ../../source/topics/schedulers.rst:10
msgid ""
"Follow :ref:`these instructions <topics:schedulers:develop_plugin>` to add "
"support for a custom scheduler."
msgstr ""

#: ../../source/topics/schedulers.rst:13
msgid "PBSPro"
msgstr ""

#: ../../source/topics/schedulers.rst:15
msgid "The `PBSPro`_ scheduler is supported (tested: version 12.1)."
msgstr ""

#: ../../source/topics/schedulers.rst:17 ../../source/topics/schedulers.rst:28
#: ../../source/topics/schedulers.rst:39 ../../source/topics/schedulers.rst:57
#: ../../source/topics/schedulers.rst:86
msgid "All the main features are supported with this scheduler."
msgstr ""

#: ../../source/topics/schedulers.rst:19 ../../source/topics/schedulers.rst:30
#: ../../source/topics/schedulers.rst:59 ../../source/topics/schedulers.rst:88
msgid ""
"Use the :ref:`topics:schedulers:job_resources:node` when setting job "
"resources."
msgstr ""

#: ../../source/topics/schedulers.rst:24
msgid "SLURM"
msgstr ""

#: ../../source/topics/schedulers.rst:26
msgid "The `SLURM`_ scheduler is supported (tested: version 2.5.4)."
msgstr ""

#: ../../source/topics/schedulers.rst:35
msgid "SGE"
msgstr ""

#: ../../source/topics/schedulers.rst:37
msgid ""
"The `SGE`_ scheduler (Sun Grid Engine, now called Oracle Grid Engine) and "
"some of its main variants/forks are supported (tested: version GE 6.2u3)."
msgstr ""

#: ../../source/topics/schedulers.rst:41
msgid ""
"Use the :ref:`topics:schedulers:job_resources:par` when setting job "
"resources."
msgstr ""

#: ../../source/topics/schedulers.rst:46
msgid "LSF"
msgstr ""

#: ../../source/topics/schedulers.rst:48
msgid ""
"The IBM `LSF`_ scheduler is supported (tested: version 9.1.3 on the CERN "
"`lxplus` cluster)."
msgstr ""

#: ../../source/topics/schedulers.rst:53
msgid "Torque"
msgstr ""

#: ../../source/topics/schedulers.rst:55
msgid ""
"`Torque`_ (based on OpenPBS) is supported (tested: version 2.4.16 from "
"Ubuntu)."
msgstr ""

#: ../../source/topics/schedulers.rst:66
msgid "Direct execution (bypassing schedulers)"
msgstr ""

#: ../../source/topics/schedulers.rst:68
msgid ""
"The ``direct`` scheduler plugin simply executes the command in a new bash "
"shell, puts it in the background and checks for its process ID (PID) to "
"determine when the execution is completed."
msgstr ""

#: ../../source/topics/schedulers.rst:70
msgid ""
"Its main purpose is debugging on the local machine. Use a proper batch "
"scheduler for any production calculations."
msgstr ""

#: ../../source/topics/schedulers.rst:75
msgid ""
"Compared to a proper batch scheduler, direct execution mode is fragile. In "
"particular:"
msgstr ""

#: ../../source/topics/schedulers.rst:78
msgid "There is no queueing, i.e. all calculations run in parallel."
msgstr ""

#: ../../source/topics/schedulers.rst:79
msgid "PID numeration is reset during reboots."
msgstr ""

#: ../../source/topics/schedulers.rst:83
msgid ""
"Do *not* use the direct scheduler for running on a supercomputer. The job "
"will end up running on the login node (which is typically forbidden), and if"
" your centre has multiple login nodes, AiiDA may get confused if subsequent "
"SSH connections end up at a different login node (causing AiiDA to infer "
"that the job has completed)."
msgstr ""

#: ../../source/topics/schedulers.rst:94
msgid "Job resources"
msgstr ""

#: ../../source/topics/schedulers.rst:96
msgid ""
"Unsurprisingly, different schedulers have different ways of specifying the "
"resources for a job (such as the number of required nodes or the numbers of "
"MPI processes per node)."
msgstr ""

#: ../../source/topics/schedulers.rst:98
msgid ""
"In AiiDA, these differences are accounted for by subclasses of the "
"|JobResource|  class. The previous section lists which subclass to use with "
"a given scheduler."
msgstr ""

#: ../../source/topics/schedulers.rst:101
msgid ""
"All subclasses define at least the "
":py:meth:`~aiida.schedulers.datastructures.JobResource.get_tot_num_mpiprocs`"
" method that returns the total number of MPI processes requested but "
"otherwise have slightly different interfaces described in the following."
msgstr ""

#: ../../source/topics/schedulers.rst:105
msgid ""
"You can manually load a `specific` |JobResource| subclass by directly "
"importing it, e.g."
msgstr ""

#: ../../source/topics/schedulers.rst:111
msgid ""
"In practice, however, the appropriate class will be inferred from scheduler "
"configured for the relevant AiiDA computer, and you can simply set the "
"relevant fields in the ``metadata.options`` input dictionary of the "
"|CalcJob|."
msgstr ""

#: ../../source/topics/schedulers.rst:113
msgid ""
"For a scheduler with job resources of type |NodeNumberJobResource|, this "
"could be:"
msgstr ""

#: ../../source/topics/schedulers.rst:132
msgid "NodeNumberJobResource (PBS-like)"
msgstr ""

#: ../../source/topics/schedulers.rst:134
msgid ""
"The |NodeNumberJobResource| class is used for specifying job resources in "
"PBS and SLURM."
msgstr ""

#: ../../source/topics/schedulers.rst:136
#: ../../source/topics/schedulers.rst:190
msgid "The class has the following attributes:"
msgstr ""

#: ../../source/topics/schedulers.rst:138
msgid ""
"``res.num_machines``: the number of machines (also called nodes) on which "
"the code should run"
msgstr ""

#: ../../source/topics/schedulers.rst:139
msgid ""
"``res.num_mpiprocs_per_machine``: number of MPI processes to use on each "
"machine"
msgstr ""

#: ../../source/topics/schedulers.rst:140
#: ../../source/topics/schedulers.rst:193
msgid ""
"``res.tot_num_mpiprocs``: the total number of MPI processes that this job "
"requests"
msgstr ""

#: ../../source/topics/schedulers.rst:141
msgid ""
"``res.num_cores_per_machine``: the number of cores to use on each machine"
msgstr ""

#: ../../source/topics/schedulers.rst:142
msgid ""
"``res.num_cores_per_mpiproc``: the number of cores to run each MPI process "
"on"
msgstr ""

#: ../../source/topics/schedulers.rst:144
msgid ""
"You need to specify only two among the first three fields above, but they "
"have to be defined upon construction. We suggest using the first two, for "
"instance:"
msgstr ""

#: ../../source/topics/schedulers.rst:151
msgid ""
"asks the scheduler to allocate 4 machines, with 16 MPI processes on each "
"machine. This will automatically ask for a total of ``4*16=64`` total number"
" of MPI processes."
msgstr ""

#: ../../source/topics/schedulers.rst:156
msgid ""
"When creating a new computer, you will be asked for a "
"``default_mpiprocs_per_machine``. If specified, it will automatically be "
"used as the default value for ``num_mpiprocs_per_machine`` whenever creating"
" the resources for that computer."
msgstr ""

#: ../../source/topics/schedulers.rst:161
msgid ""
"If you prefer using ``res.tot_num_mpiprocs`` instead, make sure it is a "
"multiple of ``res.num_machines`` and/or ``res.num_mpiprocs_per_machine``."
msgstr ""

#: ../../source/topics/schedulers.rst:163
msgid "The first three fields are related by the equation:"
msgstr ""

#: ../../source/topics/schedulers.rst:170
msgid ""
"The ``num_cores_per_machine`` and ``num_cores_per_mpiproc`` fields are "
"optional and must satisfy the equation:"
msgstr ""

#: ../../source/topics/schedulers.rst:179
msgid ""
"In PBSPro, the ``num_mpiprocs_per_machine`` and ``num_cores_per_machine`` "
"fields are used for mpiprocs and ppn respectively."
msgstr ""

#: ../../source/topics/schedulers.rst:181
msgid ""
"In Torque, the ``num_mpiprocs_per_machine`` field is used for ppn unless the"
" ``num_mpiprocs_per_machine`` is specified."
msgstr ""

#: ../../source/topics/schedulers.rst:186
msgid "ParEnvJobResource (SGE-like)"
msgstr ""

#: ../../source/topics/schedulers.rst:188
msgid ""
"The :py:class:`~aiida.schedulers.datastructures.ParEnvJobResource` class is "
"used for specifying the resources of SGE and similar schedulers, which "
"require specifying a *parallel environment* and the *total number of CPUs* "
"requested."
msgstr ""

#: ../../source/topics/schedulers.rst:192
msgid ""
"``res.parallel_env``: the parallel environment in which you want to run your"
" job (a string)"
msgstr ""

#: ../../source/topics/schedulers.rst:195
msgid ""
"Both attributes are required. No checks are done on the consistency between "
"the specified parallel environment and the total number of MPI processes "
"requested (for instance, some parallel environments may have been configured"
" by your cluster administrator to run on a single machine). It is your "
"responsibility to make sure that the information is valid, otherwise the "
"submission will fail."
msgstr ""

#: ../../source/topics/schedulers.rst:199
msgid "Setting the fields directly in the class constructor:"
msgstr ""

#: ../../source/topics/schedulers.rst:205
msgid ""
"And setting the fields using the ``metadata.options`` input dictionary of "
"the |CalcJob|:"
msgstr ""

#: ../../source/topics/schedulers.rst:220 ../../source/topics/transport.rst:17
msgid "Developing a plugin"
msgstr ""

#: ../../source/topics/schedulers.rst:222
msgid ""
"A scheduler plugin allows AiiDA to communicate with a specific type of "
"scheduler. The plugin should subclass the "
":class:`~aiida.schedulers.scheduler.Scheduler` class and implement a number "
"of methods, that will instruct how certain key commands are to be executed, "
"such as submitting a new job or requesting the current active jobs. To get "
"you started, you can download :download:`this template "
"<include/scheduler_template.py>` and implement the following methods:"
msgstr ""

#: ../../source/topics/schedulers.rst:226
msgid ""
"``_get_joblist_command``: returns the command to report a full information "
"on existing jobs."
msgstr ""

#: ../../source/topics/schedulers.rst:227
msgid ""
"``_get_detailed_job_info_command``: returns the command to get the detailed "
"information on  a job, even after the job has finished."
msgstr ""

#: ../../source/topics/schedulers.rst:228
msgid "``_get_submit_script_header``: return the submit script header."
msgstr ""

#: ../../source/topics/schedulers.rst:229
msgid "``_get_submit_command``: return the string to submit a given script."
msgstr ""

#: ../../source/topics/schedulers.rst:230
msgid ""
"``_parse_joblist_output``: parse the queue output string, as returned by "
"executing the command returned by `_get_joblist_command`."
msgstr ""

#: ../../source/topics/schedulers.rst:231
msgid ""
"``_parse_submit_output``: parse the output of the submit command, as "
"returned by executing the command returned by `_get_submit_command`."
msgstr ""

#: ../../source/topics/schedulers.rst:232
msgid ""
"``_get_kill_command``: return the command to kill the job with specified "
"jobid."
msgstr ""

#: ../../source/topics/schedulers.rst:233
msgid "``_parse_kill_output``: parse the output of the kill command."
msgstr ""

#: ../../source/topics/schedulers.rst:234
msgid "``parse_output``: parse the output of the scheduler."
msgstr ""

#: ../../source/topics/schedulers.rst:236
msgid ""
"All these methods *have* to be implemented, except for "
"``_get_detailed_job_info_command`` and ``parse_output``, which are optional."
" In addition to these methods, the ``_job_resource_class`` class attribute "
"needs to be set to a subclass "
":class:`~aiida.schedulers.datastructures.JobResource`. For schedulers that "
"work like SLURM, Torque and PBS, one can most likely simply reuse the "
":class:`~aiida.schedulers.datastructures.NodeNumberJobResource` class, that "
"ships with ``aiida-core``. Schedulers that work like LSF and SGE, may be "
"able to reuse :class:`~aiida.schedulers.datastructures.ParEnvJobResource` "
"instead. If neither of these work, one can implement a custom subclass, a "
"template for which, the class called ``TemplateJobResource``, is already "
"included in the template file."
msgstr ""

#: ../../source/topics/schedulers.rst:245
msgid ""
"To inform AiiDA about your new scheduler plugin you must register an entry "
"point in the ``aiida.schedulers`` entry point group. Refer to :ref:`the "
"section on how to register plugins <how-to:plugins-develop:entrypoints>` for"
" instructions."
msgstr ""

#: ../../source/topics/storage.rst:5
msgid "Storage"
msgstr ""

#: ../../source/topics/storage.rst:7
msgid ""
"Each AiiDA profile defines a *storage* which is where all data in the "
"provenance graph is stored. Typically, a storage consists of a "
":ref:`database <topics:database>` and a :ref:`repository "
"<topics:repository>`. The provenance graph data itself is mostly persisted "
"to the database, whereas files attached to nodes (or other binary content) "
"are stored in the repository."
msgstr ""

#: ../../source/topics/storage.rst:11
msgid ""
"By default, the storage consists of a PostgreSQL database and a `disk-"
"objectstore container <https://disk-objectstore.readthedocs.io/en/latest/>`_"
" for the file repository. As of AiiDA 2.0, however, this storage can be "
"customized through plugins, meaning other databases and file stores can be "
"used if desired. AiiDA ships itself with a number of storage plugins that "
"each have their own strengths and weaknesses. This section gives an overview"
" of these storage plugins with suggestions of when to use them."
msgstr ""

#: ../../source/topics/storage.rst:19
msgid "core.psql_dos"
msgstr ""

#: ../../source/topics/storage.rst:23
msgid "*Default storage for production projects that require performance.*"
msgstr ""

#: ../../source/topics/storage.rst:25
msgid ":fa:`database;mr-1` PostgreSQL database"
msgstr ""

#: ../../source/topics/storage.rst:27 ../../source/topics/storage.rst:47
#: ../../source/topics/storage.rst:67
msgid ":fa:`file;mr-1` ``disk-objectstore`` container"
msgstr ""

#: ../../source/topics/storage.rst:29 ../../source/topics/storage.rst:49
#: ../../source/topics/storage.rst:69 ../../source/topics/storage.rst:89
msgid ":fa:`plus;mr-1` **Strengths**:"
msgstr ""

#: ../../source/topics/storage.rst:31
msgid "Supports all of AiiDA's functionality"
msgstr ""

#: ../../source/topics/storage.rst:32
msgid "Good performance"
msgstr ""

#: ../../source/topics/storage.rst:33
msgid "Automatic database migrations"
msgstr ""

#: ../../source/topics/storage.rst:35 ../../source/topics/storage.rst:54
#: ../../source/topics/storage.rst:74 ../../source/topics/storage.rst:94
msgid ":fa:`minus;mr-1` **Weaknesses**:"
msgstr ""

#: ../../source/topics/storage.rst:37
msgid "Requires a service running (PostgreSQL)"
msgstr ""

#: ../../source/topics/storage.rst:39
msgid "core.sqlite_dos"
msgstr ""

#: ../../source/topics/storage.rst:43
msgid "*Easy to set up storage for tests, demos and experimenting.*"
msgstr ""

#: ../../source/topics/storage.rst:45 ../../source/topics/storage.rst:65
#: ../../source/topics/storage.rst:85
msgid ":fa:`database;mr-1` SQLite database"
msgstr ""

#: ../../source/topics/storage.rst:51
msgid "Easy to set up and backup"
msgstr ""

#: ../../source/topics/storage.rst:52 ../../source/topics/storage.rst:72
#: ../../source/topics/storage.rst:91
msgid "Requires no running services"
msgstr ""

#: ../../source/topics/storage.rst:56
msgid "Performance of SQLite is inferior to PostgreSQL"
msgstr ""

#: ../../source/topics/storage.rst:57 ../../source/topics/storage.rst:77
#: ../../source/topics/storage.rst:97
msgid "Some ``QueryBuilder`` functionality is not supported :fa:`asterisk`"
msgstr ""

#: ../../source/topics/storage.rst:59
msgid "core.sqlite_zip"
msgstr ""

#: ../../source/topics/storage.rst:63
msgid "*Storage contained in single ZIP file used for export archives.*"
msgstr ""

#: ../../source/topics/storage.rst:71
msgid "Easy to set up"
msgstr ""

#: ../../source/topics/storage.rst:76
msgid "Read-only"
msgstr ""

#: ../../source/topics/storage.rst:79
msgid "core.sqlite_temp"
msgstr ""

#: ../../source/topics/storage.rst:83
msgid "*Temporary storage mostly used for unit testing or demonstrations.*"
msgstr ""

#: ../../source/topics/storage.rst:87
msgid ":fa:`file;mr-1` Sandbox directory"
msgstr ""

#: ../../source/topics/storage.rst:92
msgid "Automatic cleanup"
msgstr ""

#: ../../source/topics/storage.rst:96
msgid "Storage is deleted once session is closed"
msgstr ""

#: ../../source/topics/storage.rst:101
msgid ""
":fa:`asterisk;mr-1` The following features of the ``QueryBuilder`` are known"
" to not be supported for SQLite-based storages:"
msgstr ""

#: ../../source/topics/storage.rst:103
msgid "Use of ``contains`` in ``filters``"
msgstr ""

#: ../../source/topics/storage.rst:104
msgid "The ``get_creation_statistics`` method"
msgstr ""

#: ../../source/topics/storage.rst:111
msgid "``core.psql_dos``"
msgstr ""

#: ../../source/topics/storage.rst:113
msgid ""
"The ``core.psql_dos`` storage plugin is the default and is recommended for "
"all production work. It uses PostgreSQL for the database and the disk-"
"objectstore for the file repository. To create a profile using this storage "
"plugin, run:"
msgstr ""

#: ../../source/topics/storage.rst:121
msgid ""
"The command requires the PostgreSQL database to already exist and to be able"
" to connect to it."
msgstr ""

#: ../../source/topics/storage.rst:125
msgid ""
"Try the ``verdi quicksetup`` command to have the PostgreSQL database "
"automatically created. Certain systems require root access to do so, causing"
" the command to fail if it cannot obtain root access. In this case, the "
"database should be created manually (see :ref:`intro:install:database` for "
"details). Once created, a profile can be created using the database with the"
" command ``verdi profile setup core.psql_dos``."
msgstr ""

#: ../../source/topics/storage.rst:134
msgid "``core.sqlite_dos``"
msgstr ""

#: ../../source/topics/storage.rst:136
msgid ""
"The ``core.sqlite_dos`` storage plugin is an alternative to the "
"``core.psql_dos`` storage for use cases where performance is not critical. "
"Instead of a PostgreSQL database, it uses SQLite. This makes it easier to "
"set up as it does not require a running service, as the SQLite database is "
"just a file on disk."
msgstr ""

#: ../../source/topics/storage.rst:140
msgid ""
"A fully operational profile using this storage plugin can be created with a "
"single command:"
msgstr ""

#: ../../source/topics/storage.rst:146
msgid ""
"replacing ``<PROFILE_NAME>`` with the desired name for the profile and "
"``<EMAIL>`` with the email for the default user."
msgstr ""

#: ../../source/topics/storage.rst:148
msgid ""
"The SQLite database and disk-objectstore container are both stored in the "
"directory specified by the ``--filepath`` option of the ``verdi profile "
"setup core.sqlite_dos`` command. By default, this is a folder inside the "
"directory defined by the ``$AIIDA_PATH/repository`` of the form "
"``sqlite_dos_{UUID}``, where the suffix is randomly generated hexadecimal "
"UUID. An example of an automated generated directory is "
"``.aiida/repository/sqlite_dos_962e87af09b746c985335cb77acaa553``."
msgstr ""

#: ../../source/topics/storage.rst:154
msgid ""
"The ``$AIIDA_PATH`` environment variable :ref:`determines the location of "
"the configuration directory <how-to:installation:configure:instance-"
"isolation>`, and defaults to ``.aiida`` in the user's home folder"
msgstr ""

#: ../../source/topics/storage.rst:160
msgid "``core.sqlite_zip``"
msgstr ""

#: ../../source/topics/storage.rst:162
msgid ""
"The ``core.sqlite_zip`` is a storage plugin that is used to create export "
"archives. It functions more or less identical to the ``core.sqlite_dos`` "
"plugin, as it uses an SQLite database and a disk-objectstore container, "
"except everything is bundled up in a `zip archive "
"<https://en.wikipedia.org/wiki/ZIP_(file_format)>`_."
msgstr ""

#: ../../source/topics/storage.rst:165
msgid ""
"The storage plugin is not suited for normal use, because once the archive is"
" created, it becomes read-only. However, since otherwise it functions like "
"normal storage plugins, a profile can be created with it that make it easy "
"to explore its contents:"
msgstr ""

#: ../../source/topics/storage.rst:172
msgid ""
"replacing ``<PROFILE_NAME>`` with the desired name for the profile and "
"``<ARCHIVE>`` the path to the archive file. The created profile can now be "
"loaded like any other profile, and the contents of the provenance graph can "
"be explored as usual."
msgstr ""

#: ../../source/topics/storage.rst:179
msgid "``core.sqlite_temp``"
msgstr ""

#: ../../source/topics/storage.rst:181
msgid ""
"The ``core.sqlite_temp`` storage plugin utilises an in-memory SQLite "
"database and sandbox folder to store data. The data is automatically "
"destroyed as soon as the profile is garbage collected, which is either when "
"it is unloaded, or the Python interpreter is shut down. This makes this "
"storage plugin primarily useful for demonstration and testing purposes, "
"whereby no persistent storage is required."
msgstr ""

#: ../../source/topics/storage.rst:185
msgid "A new temporary profile can be created and loaded as follows:"
msgstr ""

#: ../../source/topics/transport.rst:5
msgid "Transport plugins"
msgstr ""

#: ../../source/topics/transport.rst:7
msgid ""
"The term `transport` in AiiDA refers to a class that the engine uses to "
"perform operations on local or remote machines where its "
":py:class:`~aiida.engine.processes.calcjobs.calcjob.CalcJob` are submitted. "
"The base class :py:class:`~aiida.transports.transport.Transport` defines an "
"interface for these operations, such as copying files and executing "
"commands. A `transport plugin` is a class that implements this base class "
"for a specific connection method. The ``aiida-core`` package ships with two "
"transport plugins: the "
":py:class:`~aiida.transports.plugins.local.LocalTransport` and "
":py:class:`~aiida.transports.plugins.ssh.SshTransport` classes. The "
"``local`` transport can be used to connect with the `localhost` and makes "
"use only of some standard python modules like ``os`` and ``shutil``. The "
"``ssh`` transport, which can be used for machines that can be connected to "
"over ssh, is simply a wrapper around the library `paramiko "
"<https://www.paramiko.org/>`_ that is installed as a required dependency of "
"``aiida-core``."
msgstr ""

#: ../../source/topics/transport.rst:19
msgid ""
"The transport class is actually almost never used directly by the user. It "
"is mostly utilized by the engine that uses the transport plugin to connect "
"to the machine where the calculation job, that it is managing, is running. "
"The engine has to be able to use always the same methods regardless of which"
" kind of transport is required to connect to the computer in question."
msgstr ""

#: ../../source/topics/transport.rst:23
msgid ""
"The generic transport class contains a set of minimal methods that an "
"implementation must support in order to be fully compatible with the other "
"plugins. If not, a ``NotImplementedError`` will be raised, interrupting the "
"managing of the calculation or whatever is using the transport plugin."
msgstr ""

#: ../../source/topics/transport.rst:26
msgid ""
"As for the general functioning of the plugin, the "
":py:meth:`~aiida.transports.transport.Transport.__init__` method is used "
"only to initialize the class instance, without actually opening the "
"transport channel. The connection must be opened only by the "
":py:meth:`~aiida.transports.transport.Transport.__enter__` method, (and "
"closed by :py:meth:`~aiida.transports.transport.Transport.__exit__`). The "
":py:meth:`~aiida.transports.transport.Transport.__enter__` method lets you "
"use the transport class using the ``with`` statement (see `python docs "
"<https://docs.python.org/3/reference/compound_stmts.html#with>`_), in a way "
"similar to the following:"
msgstr ""

#: ../../source/topics/transport.rst:35
msgid ""
"To ensure this, for example, the local plugin uses a hidden boolean variable"
" ``_is_open`` that is set when the "
":py:meth:`~aiida.transports.transport.Transport.__enter__` and "
":py:meth:`~aiida.transports.transport.Transport.__exit__` methods are "
"called. The ``ssh`` logic is instead given by the property sftp."
msgstr ""

#: ../../source/topics/transport.rst:38
msgid ""
"The other functions that require some care are the copying functions, called"
" using the following terminology:"
msgstr ""

#: ../../source/topics/transport.rst:40
msgid "``put``: from local source to remote destination"
msgstr ""

#: ../../source/topics/transport.rst:41
msgid "``get``: from remote source to local destination"
msgstr ""

#: ../../source/topics/transport.rst:42
msgid "``copy``: copying files from remote source to remote destination"
msgstr ""

#: ../../source/topics/transport.rst:44
msgid ""
"Note that these functions must accept both files and folders and internally "
"they will fallback to functions like ``putfile`` or ``puttree``."
msgstr ""

#: ../../source/topics/transport.rst:46
msgid ""
"The last function requiring care is "
":py:meth:`~aiida.transports.transport.Transport.exec_command_wait`, which is"
" an analogue to the `subprocess "
"<http://docs.python.org/3/library/subprocess.html>`_ python module. The "
"function gives the freedom to execute a string as a remote command, thus it "
"could produce nasty effects if not written with care."
msgstr ""

#: ../../source/topics/transport.rst:51
msgid "Be sure to escape any strings for bash!"
msgstr ""

#: ../../source/topics/transport.rst:53
msgid ""
"Download :download:`this template <transport_template.py>` as a starting "
"point to implementing a new transport plugin. It contains the interface with"
" all the methods that need to be implemented, including docstrings that will"
" work with Sphinx documentation."
msgstr ""

#: ../../source/topics/transport.rst:58
msgid ""
"To inform AiiDA about your new transport plugin you must register an entry "
"point in the ``aiida.transports`` entry point group. Please visit the `AiiDA"
" registry <https://aiidateam.github.io/aiida-registry/>`_ to see an example "
"of how this can be done."
msgstr ""

#: ../../source/topics/transport.rst:65
msgid "Login shells"
msgstr ""

#: ../../source/topics/transport.rst:67
msgid ""
"The base transport class :class:`aiida.transports.transport.Transport` "
"defines the ``use_login_shell`` option. When set to ``True``, all commands "
"executed over the transport will use the ``-l/--login`` option of ``bash``. "
"This instructs bash to load a login shell, which, according to the ``bash`` "
"manpage, means:"
msgstr ""

#: ../../source/topics/transport.rst:71
msgid ""
"When bash is invoked as an interactive login shell, or as a non-interactive "
"shell with the ``--login`` option, it first reads and executes commands from"
" the file ``/etc/profile``, if that file exists. After reading that file, it"
" looks for ``~/.bash_profile``, ``~/.bash_login``, and ``~/.profile``, in "
"that order, and reads and executes commands from the first one that exists "
"and is readable."
msgstr ""

#: ../../source/topics/transport.rst:74
msgid ""
"By default ``use_login_shell`` is set to ``True`` as it ensures that the "
"commands executed over the transport by AiiDA see the same shell environment"
" as the user, if they were to login manually and execute the command. "
"However, in certain cases, the login scripts might not be necessary for "
"AiiDA to properly run codes on the target computer. At the same time, it is "
"possible that the login scripts have a non-negligible run time, and so can "
"significantly slow down all the commands AiiDA has to execute. In this case,"
" it may be useful to set the ``use_login_shell`` to ``False``."
msgstr ""

#: ../../source/topics/workflows/concepts.rst:7
#: ../../source/topics/workflows/usage.rst:9
msgid ""
"A workflow in AiiDA is a process (see the :ref:`process "
"section<topics:processes:concepts>` for details) that calls other workflows "
"and calculations and optionally *returns* data and as such can encode the "
"logic of a typical scientific workflow. Currently, there are two ways of "
"implementing a workflow process:"
msgstr ""

#: ../../source/topics/workflows/concepts.rst:10
msgid ":ref:`work functions<topics:workflows:concepts:workfunctions>`"
msgstr ""

#: ../../source/topics/workflows/concepts.rst:11
msgid ":ref:`work chains<topics:workflows:concepts:workchains>`"
msgstr ""

#: ../../source/topics/workflows/concepts.rst:13
msgid ""
"The first one is the simplest of the two and is basically a python function "
"that is magically transformed into a process. This is ideal for workflows "
"that are not very computationally intensive and can be easily implemented in"
" a python function. For more complex workflows, the work chain is a better "
"alternative. By chaining work chains and work functions together, that each "
"can run other sub processes, we can define a workflow. For simplicity, from "
"here on out, we will use the terms, workflows, work chains, and work "
"functions interchangeably, as a *pars pro toto* and *totum pro parte*."
msgstr ""

#: ../../source/topics/workflows/concepts.rst:19
msgid ""
"In the following sections, both concepts will be explained but without going"
" too much into detail on how to implement or run them. For a more detailed "
"exposé, please refer to the respective advanced sections on :ref:`work "
"functions<topics:workflows:usage:workfunctions>` and :ref:`work "
"chains<topics:workflows:usage:workchains>`."
msgstr ""

#: ../../source/topics/workflows/concepts.rst:26
#: ../../source/topics/workflows/usage.rst:21
msgid "Work functions"
msgstr ""

#: ../../source/topics/workflows/concepts.rst:28
msgid ""
"A work function is implemented just as a :ref:`calculation "
"function<topics:calculations:concepts:calcfunctions>`, however, they have "
"very distinct use cases. Since the work function is a 'workflow-like' "
"process, it can only *return* existing data, whereas the calculation "
"function creates a 'calculation-like' process which can only *create* new "
"data. This difference is addressed in greater detail in the "
":ref:`process<topics:processes:concepts:types>` section and it is very "
"important that one understands this distinction."
msgstr ""

#: ../../source/topics/workflows/concepts.rst:32
msgid ""
"To explain the use of the ``@workfunction``, we will continue with the "
"example of the :ref:`calculation "
"functions<topics:calculations:concepts:calcfunctions>`, so before "
"continuing, read that section first. The example showed how the "
"``@calcfunction`` decorator can be used to create two functions that, for "
"three given integers, computes the sum of the first two, which is then "
"multiplied with the third, all the while keeping the provenance. Even though"
" the calculation functions ensured that the provenance of the data was kept,"
" the logic of *who* called these functions was not explicitly kept. From the"
" provenance graph generated by the calculation functions, it is impossible "
"to deduce whether the functions were called straight after another in a "
"single script, or whether first the ``add`` function was called and a long "
"time later, the output was used as an input for the ``multiply`` function. "
"Capturing this logical provenance of the *sequence of calls* of processes is"
" exactly what workflow-like processes, such as the ``workfunction`` are "
"designed for."
msgstr ""

#: ../../source/topics/workflows/concepts.rst:38
msgid ""
"Consider the following example, where we implement a function called "
"``add_and_multiply`` that we decorate with the ``@workfunction`` decorator."
msgstr ""

#: ../../source/topics/workflows/concepts.rst:54
msgid ""
"Instead of calling the calculation functions directly in the script, we call"
" the work function, which then consecutively calls the calculation "
"functions, passing the intermediate result from the first to the second. If "
"we look at the provenance graph generated by this example, we would see "
"something like the following:"
msgstr ""

#: ../../source/topics/workflows/concepts.rst:60
msgid "The full provenance generated by the work function example"
msgstr ""

#: ../../source/topics/workflows/concepts.rst:62
msgid ""
"It is clear that this provenance graph contains a lot more information than "
"the one for the calculation function example. Whether this information is "
"actually necessary or useful depends on the situation and is entirely up to "
"the user, but there is a big advantage. The strict separation between "
"calculation-like and workflow-like processes and the different allowed links"
" between them, as codified in the :ref:`provenance graph "
"implementation<topics:provenance:implementation>`, may seem a bit excessive "
"at a first glance and to new users. However, the addition of this parallel "
"yet distinct workflow layer that represents the logical provenance, allows "
"one to ignore all the details of the computation. This is demonstrated by "
"the provenance graph below, which is the exact same as the one before, "
"except only data and workflow nodes are shown:"
msgstr ""

#: ../../source/topics/workflows/concepts.rst:71
msgid ""
"The 'logical' provenance generated by the work function example, where only "
"the workflow and data nodes, with their links, are shown"
msgstr ""

#: ../../source/topics/workflows/concepts.rst:73
msgid ""
"With this reduced representation, the big picture of how the original inputs"
" led to the final result becomes immediately clear. Conversely, none of the "
"actual data provenance is lost. In the figure below, all the workflow nodes "
"are omitted and what we end up with is the exact same provenance graph as in"
" :numref:`fig_calculation_functions_provenance_add_multiply` of the "
":ref:`original example<topics:calculations:concepts:calcfunctions>` that "
"only used calculation functions."
msgstr ""

#: ../../source/topics/workflows/concepts.rst:80
msgid ""
"The 'data' provenance generated by the work function example, where only the"
" calculation and data nodes, with their links, are shown"
msgstr ""

#: ../../source/topics/workflows/concepts.rst:82
msgid ""
"In this simple example, the power of being able to select what part of the "
"provenance graph one is interested in is obviously limited. But workflows "
"can quickly become complex and deeply nested, at which point the ability to "
"group parts of the provenance graph together under a single node and "
"effectively 'hide' its internal parts in a transparent way, becomes "
"invaluable."
msgstr ""

#: ../../source/topics/workflows/concepts.rst:85
msgid ""
"In addition to the orchestration role that the work function can fullfill, "
"it can also be used as a filter or selection function. Imagine that you want"
" to write a process function that takes a set of input integer nodes and "
"returns the one with the highest value. We cannot employ the "
"``calcfunction`` for this, because it would have to return one of its input "
"nodes, which is explicitly forbidden. However, for the ``workfunction``, "
"returning existing nodes, even one of its inputs, is perfectly fine. An "
"example implementation might look like the following:"
msgstr ""

#: ../../source/topics/workflows/concepts.rst:94
msgid ""
"The work function above will return the input node ``x`` as one of its "
"outputs as it has the highest value. The provenance of the execution of this"
" select work function will look like the following:"
msgstr ""

#: ../../source/topics/workflows/concepts.rst:100
msgid ""
"The provenance generated by the work function that selects one of its input "
"nodes"
msgstr ""

#: ../../source/topics/workflows/concepts.rst:103
msgid ""
"It is important to realize once again that in the work function examples "
"given above, all the nodes returned by the work functions are *already "
"stored*. That is to say, they were either created by a calculation function "
"called by the work function or were passed in as one of the inputs. This is "
"no accident, as the work function **can** only return stored nodes. Trying "
"to return a node that was created by the work function itself, will raise an"
" exception. You can find a more detailed explanation for the reasoning "
"behind this design choice in the documentation on the various :ref:`process "
"types<topics:processes:concepts:types>` present in AiiDA and the "
":ref:`implementation of the provenance "
"graph<topics:provenance:implementation>`."
msgstr ""

#: ../../source/topics/workflows/concepts.rst:113
#: ../../source/topics/workflows/usage.rst:129
msgid "Work chains"
msgstr ""

#: ../../source/topics/workflows/concepts.rst:116
msgid "Why?"
msgstr ""

#: ../../source/topics/workflows/concepts.rst:118
msgid ""
"Now that we have demonstrated how easily ``workfunctions`` can be used to "
"write your workflow that automatically keeps the provenance, it is time to "
"confess that work functions are not perfect and have their shortcomings. In "
"the simple example of adding and multiplying numbers, the time to execute "
"the functions is very short, but imagine that you are performing a more "
"costly calculation, e.g. you want to run an actual ``CalcJob`` that will be "
"submitted to the scheduler and may run for a long time. If anywhere during "
"the chain, the workflow is interrupted, for whatever reason, all progress is"
" lost. There are no 'checkpoints', so to speak, by simply chaining work "
"functions together."
msgstr ""

#: ../../source/topics/workflows/concepts.rst:123
msgid ""
"But fret not! To tackle this problem, AiiDA defines the concept of the work "
"chain. As the name suggests, this construct is a way to chain multiple "
"logical steps of a workflow together in a way that allows to save the "
"progress between those steps as soon as they are successfully completed. The"
" work chain is therefore the preferred solution for parts of the workflow "
"that involve more expensive and complex calculations. To define a work "
"chain, AiiDA provides the "
":py:class:`~aiida.engine.processes.workchains.workchain.WorkChain` class."
msgstr ""

#: ../../source/topics/workflows/concepts.rst:132
msgid ""
"If we were to reimplement our work function solution of the simple example "
"problem of the previous section, but this time using a work chain, it would "
"look something like the following:"
msgstr ""

#: ../../source/topics/workflows/concepts.rst:137
msgid ""
"Don't be intimidated by all the code in this snippet. The point of this "
"example is not to explain the exact syntax, which will be done in greater "
"detail in the :ref:`advanced workflows<topics:workflows:usage:workchains>` "
"section, but to merely introduce the concept of the work chain. The core "
"attributes of a work chain are defined by its :ref:`process "
"specification<topics:processes:usage:spec>` which is setup in the "
":py:meth:`~aiida.engine.processes.process.Process.define` method. The only "
"thing you need to notice here, is that it defines the *inputs* that the work"
" chain takes, its logical *outline* and the *outputs* that it will produce. "
"The steps of the outline are implemented as class methods of the work chain."
" The ``add`` step will add the first two integers by calling the ``add`` "
"calculation function, and store the sum temporarily in the "
":ref:`context<topics:workflows:usage:workchains:context>`. The next step in "
"the outline, ``multiply``, will take the sum stored in the context that was "
"computed in the first outline step and call the ``multiply`` calculation "
"function with the third input integer. Finally, the ``result`` step will "
"take the product produced by the previous step and record it as an output of"
" the work chain. The resulting provenance when we run this work chain looks "
"like the following:"
msgstr ""

#: ../../source/topics/workflows/concepts.rst:150
msgid ""
"The provenance generated by the work chain example calling calculation "
"functions to perform the addition and multiplication."
msgstr ""

#: ../../source/topics/workflows/concepts.rst:152
msgid ""
"As you can see, the produced provenance graph is identical to that of "
":numref:`fig_work_functions_provenance_add_multiply_full` that was produced "
"by the work function solution, except that the workflow node is a work chain"
" instead of a work function node. Full data provenance is kept as the "
"calculation of the sum and the product through the work chain are "
"represented explicitly by the calculation nodes of the ``add`` and "
"``multiply`` calculation functions that are called."
msgstr ""

#: ../../source/topics/workflows/concepts.rst:157
msgid ""
"The usage of calculation functions for the computation of the sum and the "
"product is not an accident, but a concious design choice. Since work chains "
"are workflow-like processes and as such cannot *create* data, performing the"
" calculations directly in the work chain outline steps itself, would result "
"in a loss in the data provenance."
msgstr ""

#: ../../source/topics/workflows/concepts.rst:160
msgid ""
"To illustrate what it means for worklow processes not being able to *create*"
" new data and how doing so causes a loss of data provenance, let's change "
"the previous implementation to perform the sum and product in the work chain"
" outline steps itself, instead of calling the calculation functions."
msgstr ""

#: ../../source/topics/workflows/concepts.rst:165
msgid "The resulting provenance would look like the following:"
msgstr ""

#: ../../source/topics/workflows/concepts.rst:170
msgid ""
"The provenance generated by the work chain example that computes the sum and"
" product directly in its outline steps, instead of delegating it to "
"calculation functions"
msgstr ""

#: ../../source/topics/workflows/concepts.rst:172
msgid ""
"Note how, in contrast with the provenance of the previous correct solution "
"from :numref:`fig_work_chains_provenance_add_multiply_workchain_full`, there"
" are no explicit calculation nodes representing the computation of the sum "
"and the product. Instead, all that computation is abstracted and represented"
" by the single workflow node that represents the execution of the work "
"chain. The logic inside of those outline steps is then 'hidden' or "
"'encapsulated' in the provenance graph by a single workflow node. "
"Additionally, the output node representing the final product, only has a "
"``return`` link, even though it was *created* by the work chain. This is "
"because :ref:`workflow processes do not have the capacity to create new "
"nodes<topics:workflows:usage:workfunctions:returning_data>`, and therefore "
"in this example, the data provenance is lost."
msgstr ""

#: ../../source/topics/workflows/concepts.rst:178
msgid ""
"An important thing to remember is that *any computation* that happens in the"
" body of outline steps of a work chain, will not be explicitly represented, "
"but will be encapsulated by a single node in the graph that represents that "
"work chain execution. Whether that loss of data provenance is relevant "
"depends on the use case and is left to the developer of the workflow to "
"determine. These two examples demonstrate that AiiDA does not force any "
"particular method, but allows the user to choose exactly what level of "
"granularity they would like to maintain in the provenance. However, the rule"
" of thumb is that if you want to reduce the loss, or 'hiding' of provenance "
"to a minimum, one should keep real computation within the body of work "
"functions and work chains to a minimum and delegate that to calculations. "
"For any real computational work that is relevant to the data provenance, it "
"is better to implement it in explicit calculation processes, usually a "
"separate calculation function."
msgstr ""

#: ../../source/topics/workflows/concepts.rst:185
msgid "Advantages"
msgstr ""

#: ../../source/topics/workflows/concepts.rst:186
msgid ""
"The work chain solution to the add-multiply problem requires significantly "
"more code, compared to the work function solution presented in the beginning"
" of this section. Why should one then bother using the work chain? The "
"advantages for this trivial example may be difficult to see, but imagine the"
" logic of the workflow becomes more complicated and the calculations become "
"more intensive. The process specification of the work chain provides a "
"central way of defining the inputs and outputs, making it easy to see at a "
"glance how the work chain operates. In addition, the ``outline`` can give a "
"succinct summary of the logical steps that the work chain will perform, all "
"of which a work function does not have. The outline in this example was "
"trivially simple, but the :ref:`advanced work chain development "
"section<topics:workflows:usage:workchains>` will show how complex logic can "
"be implemented directly in the process specification. The process "
"specification also makes it easy to 'wrap' existing work chains into more "
"complex work chains through the :ref:`expose "
"functionality<topics:workflows:usage:workchains:expose_inputs_outputs>`."
msgstr ""

#: ../../source/topics/workflows/concepts.rst:194
msgid ""
"Finally, as mentioned before, the work chain provides the possibility of "
"checkpoints, i.e. to save progress at certain points from which the "
"computation can be continued after it had been interrupted. The state of the"
" work chain is saved after each outline step. If expensive calculation jobs "
"are performed in an individual outline step, they will be saved as soon as "
"they finish. This is impossible for work functions, and if it were to be "
"interrupted before *all* the computations had been completed, all "
"intermediate progress would be lost. The rule of thumb therefore is, as soon"
" as the worfklow becomes only slightly complex or computationally intensive,"
" preference should be given to :ref:`work "
"chains<topics:workflows:concepts:workchains>` and :ref:`calculation "
"jobs<topics:calculations:concepts:calcjobs>`."
msgstr ""

#: ../../source/topics/workflows/concepts.rst:200
msgid ""
"This was a very quick overview of the intended use of work chains and how "
"they work, but of course they have a lot more features. To learn how to "
"write work chains for real life problems, continue reading at the :ref:`work"
" chain development<topics:workflows:usage:workchains>` section, but before "
"you do, read the following part on when to use a work function and when it "
"is better to use a work chain."
msgstr ""

#: ../../source/topics/workflows/concepts.rst:205
msgid "When to use which"
msgstr ""

#: ../../source/topics/workflows/concepts.rst:206
msgid ""
"Now that we know how the two workflow components, work functions and work "
"chains, work in AiiDA, you might wonder: when should I use which one? For "
"simple operations that do not take long, the simplicity of the work function"
" may be all you need, so by all means use it. However, a good rule of thumb "
"is that as soon as the code is expected to take longer, for example when you"
" want to launch a :ref:`calculation "
"job<topics:calculations:concepts:calcjobs>` or another complex workflow, it "
"is always best to go for the work chain. The automatic checkpointing, which "
"guarantees that work between steps is saved, becomes very important. But the"
" work chain offers a lot more features than just checkpointing that may make"
" it more preferable over the work function, which you can read about in the "
"advanced :ref:`work chain development <topics:workflows:usage:workchains>` "
"section."
msgstr ""

#: ../../source/topics/workflows/index.rst:5
msgid "Workflows"
msgstr ""

#: ../../source/topics/workflows/index.rst:7
msgid ""
"This topic section provides detailed information on the concept of workflows"
" in AiiDA and an extensive guide on how to work with them. An introductory "
"guide to working with workflows can be found in :ref:`\"How to run multi-"
"step workflows\"<how-to:run-workflows>`."
msgstr ""

#: ../../source/topics/workflows/usage.rst:7
msgid ""
"This chapter assumes knowledge of the :ref:`basic "
"concept<topics:workflows:concepts>` and difference between work functions "
"and work chains is known and when one should use on or the other."
msgstr ""

#: ../../source/topics/workflows/usage.rst:12
msgid ":ref:`work function<topics:workflows:usage:workfunctions>`"
msgstr ""

#: ../../source/topics/workflows/usage.rst:13
msgid ":ref:`work chain<topics:workflows:usage:workchains>`"
msgstr ""

#: ../../source/topics/workflows/usage.rst:15
msgid ""
"This section will provide detailed information and best practices on how to "
"implement these two workflow types."
msgstr ""

#: ../../source/topics/workflows/usage.rst:23
msgid ""
"The concept of work functions and the basic rules of implementation are "
"documented in detail elsewhere:"
msgstr ""

#: ../../source/topics/workflows/usage.rst:25
msgid ""
":ref:`concept of work functions<topics:workflows:concepts:workfunctions>`"
msgstr ""

#: ../../source/topics/workflows/usage.rst:26
msgid ":ref:`implementation of process functions<topics:processes:functions>`"
msgstr ""

#: ../../source/topics/workflows/usage.rst:28
msgid ""
"Since work functions are a sub type of process functions, just like "
"calculation functions, their implementation rules are as good as identical. "
"However, their intended aim and heuristics are very different. Where "
":ref:`calculation functions<topics:calculations:usage:calcfunctions>` are "
"'calculation'-like processes that *create* new data, work functions behave "
"like 'workflow'-like processes and can only *return* data. What this entails"
" in terms of intended usage and limitations for work functions is the scope "
"of this section."
msgstr ""

#: ../../source/topics/workflows/usage.rst:36
msgid "Returning data"
msgstr ""

#: ../../source/topics/workflows/usage.rst:37
msgid ""
"It has been said many times before: work functions, like all 'workflow'-like"
" processes, `return` data, but what does `return` mean exactly? In this "
"context, the term 'return' is not intended to refer to a piece of python "
"code returning a value. Instead it refers to a workflow process recording a "
"data node as one of its outputs, that *it itself did not create*, but which "
"rather was created by some other process, that was called by the workflow. "
"The calculation process was responsable for *creating* the data node and the"
" workflow is merely *returning* it as one of its outputs."
msgstr ""

#: ../../source/topics/workflows/usage.rst:42
msgid ""
"This is then exactly what the workfunction function does. It takes one or "
"more data nodes as inputs, calls other processes to which it passes those "
"inputs and optionally returns some or all of the outputs created by the "
"calculation processes it called. As explained in the :ref:`technical "
"section<topics:processes:functions>`, outputs are recorded as 'returned' "
"nodes simply by returning the nodes from the function. The engine will "
"inspect the return value from the function and attach the output nodes to "
"the node that represents the work function. To verify that the output nodes "
"are in fact not 'created', the engine will check that the nodes are stored. "
"Therefore, it is very important that you **do not store the nodes you create"
" yourself**, or the engine will raise an exception, as shown in the "
"following example:"
msgstr ""

#: ../../source/topics/workflows/usage.rst:52
msgid ""
"Because the returned node is a newly created node and not stored, the engine"
" will raise the following exception:"
msgstr ""

#: ../../source/topics/workflows/usage.rst:60
msgid ""
"Note that you could of course circumvent this check by calling ``store`` "
"yourself on the node, but that misses the point. The problem with using a "
"``workfunction`` to 'create' new data, is that the provenance is lost. To "
"illustrate this problem, let's go back to the simple problem of implementing"
" a workflow to add two integer and multiply the result with a third. The "
":ref:`correct implementation<topics:workflows:concepts:workfunctions>` has a"
" resulting provenance graph that clearly captures the addition and the "
"multiplication as separate calculation nodes, as shown in "
":numref:`fig_work_functions_provenance_add_multiply_full`. To illustrate "
"what would happen if one does does not call calculation functions to perform"
" the computations, but instead directly perform them in the work function "
"itself and return the result, consider the following example:"
msgstr ""

#: ../../source/topics/workflows/usage.rst:69
#: ../../source/topics/workflows/usage.rst:88
msgid ""
"For the documentation skimmers: this is an explicit example on **how not to "
"use** work functions. The :ref:`correct "
"implementation<topics:workflows:concepts:workfunctions>` calls calculation "
"functions to perform the computation"
msgstr ""

#: ../../source/topics/workflows/usage.rst:71
msgid ""
"Note that in this example implementation we explicitly had to call ``store``"
" on the result before returning it to avoid the exception thrown by the "
"engine. The resulting provenance would look like the following:"
msgstr ""

#: ../../source/topics/workflows/usage.rst:77
msgid ""
"The provenance generated by the incorrect work function implementation. Note"
" how the addition and multiplication are not explicitly represented, but are"
" implicitly hidden inside the workflow node. Moreover, the result node does "
"not have a 'create' link, because a work function cannot create new data."
msgstr ""

#: ../../source/topics/workflows/usage.rst:79
msgid ""
"However, looking at the generated provenance shows exactly why we shouldn't."
" This faulty implementation loses provenance as it has no explicit "
"representations of the addition and the multiplication and the `result` node"
" does not have a `create` link, which means that if only the data provenance"
" is followed, it is as if it appears out of thin air! Compare this to the "
"provenance graph of "
":numref:`fig_work_functions_provenance_add_multiply_full`, which was "
"generated by a solution that correctly uses calculation functions to perform"
" the computations. In this trivial example, one may think that this loss of "
"information is not so important, because it is implicitly captured by the "
"workflow node. But a halfway solution may make the problem more apparent, as"
" demonstrated by the following snippet where the addition is properly done "
"by calling a calculation function, but the final product is still performed "
"by the work function itself:"
msgstr ""

#: ../../source/topics/workflows/usage.rst:90
msgid ""
"This time around the addition is correctly performed by a calculation "
"function as it should, however, its result is multiplied by the work "
"function itself and returned. Note that once again ``store`` had to be "
"called explicitly on ``product`` to avoid the engine throwing a "
"``ValueError``, which is only for the purpose of this example **and should "
"not be done in practice**. The resulting provenance would look like the "
"following:"
msgstr ""

#: ../../source/topics/workflows/usage.rst:97
msgid ""
"The provenance generated by the incorrect work function implementation that "
"uses only a calculation function for the addition but performs the "
"multiplication itself. The red cross is there to indicate that there is no "
"actual connection between the intermediate sum `D4` and the final result "
"`D5`, even though the latter in reality derives from the former."
msgstr ""

#: ../../source/topics/workflows/usage.rst:100
msgid ""
"The generated provenance shows, that although the addition is explicitly "
"represented because the work function called the calculation function, there"
" is no connection between the sum and the final result. That is to say, "
"there is no direct link between the sum `D4` and the final result `D5`, as "
"indicated by the red cross, even though we know that the final answer was "
"based on the intermediate sum. This is a direct cause of the work function "
"'creating' new data and illustrates how, in doing so, the provenance of data"
" creation is lost."
msgstr ""

#: ../../source/topics/workflows/usage.rst:110
msgid ""
"To terminate the execution of a work function and mark it as failed, one "
"simply has to return an :ref:`exit code<topics:processes:usage:exit_codes>`."
" The :py:class:`~aiida.engine.processes.exit_code.ExitCode` class is "
"constructed with an integer, to denote the desired exit status and an "
"optional message When such as exit code is returned, the engine will mark "
"the node of the work function as ``Finished`` and set the exit status and "
"message to the value of the exit code. Consider the following example:"
msgstr ""

#: ../../source/topics/workflows/usage.rst:122
msgid ""
"The execution of the work function will be immediately terminated as soon as"
" the exit code is returned, and the exit status and message will be set to "
"``418`` and ``I am a teapot``, respectively. Since no output nodes are "
"returned, the ``WorkFunctionNode`` node will have no outputs and the value "
"returned from the function call will be an empty dictionary."
msgstr ""

#: ../../source/topics/workflows/usage.rst:131
msgid ""
"The :ref:`basic concept of the work "
"chain<topics:workflows:concepts:workchains>` has been explained elsewhere. "
"This section will provide details on how a work chain can and should be "
"implemented. A work chain is implemented by the "
":py:class:`~aiida.engine.processes.workchains.workchain.WorkChain` class. "
"Since it is a sub class of the "
":py:class:`~aiida.engine.processes.process.Process` class, it shares all its"
" properties. It will be very valuable to have read the section on working "
"with :ref:`generic processes<topics:processes:usage>` before continuing, "
"because all the concepts explained there will apply also to work chains."
msgstr ""

#: ../../source/topics/workflows/usage.rst:137
msgid ""
"Let's continue with the example presented in the section on the "
":ref:`concept of workchains<topics:workflows:concepts:workchains>`, where we"
" sum two integers and multiply the result with a third. We provided a very "
"simple implementation in a code snippet, whose generated provenance graph, "
"when executed, is shown in "
":numref:`fig_work_chains_provenance_add_multiply_workchain_full`. For "
"convenience we copy the snippet here once more:"
msgstr ""

#: ../../source/topics/workflows/usage.rst:144
msgid ""
"We will now got through the implementation step-by-step and go into more "
"detail on the interface and best practices."
msgstr ""

#: ../../source/topics/workflows/usage.rst:151
msgid ""
"To implement a new work chain, simply create a new class that sub classes "
":py:class:`~aiida.engine.processes.workchains.workchain.WorkChain`. You can "
"give the new class any valid python class name, but the convention is to "
"have it end in ``WorkChain`` so that it is always immediately clear what it "
"references. After having created a new work chain class, the first and most "
"important method to implement is the "
":py:meth:`~aiida.engine.processes.process.Process.define` method. This is a "
"class method that allows the developer to define the characteristics of the "
"work chain, such as what inputs it takes, what outputs it can generate, what"
" potential exit codes it can return and the logical outline through which it"
" will accomplish all this."
msgstr ""

#: ../../source/topics/workflows/usage.rst:156
msgid ""
"To implement the ``define`` method, you have to start with the following "
"three lines:"
msgstr ""

#: ../../source/topics/workflows/usage.rst:164
msgid ""
"where you replace ``AddAndMultiplyWorkChain`` with the actual name of your "
"work chain. The ``@classmethod`` decorator indicates that this method is a "
"class method  [#f1]_ and not an instance method. The second line is the "
"method signature and specified that it will receive the class itself ``cls``"
" and ``spec`` which will be an instance of the "
":py:class:`~aiida.engine.processes.process_spec.ProcessSpec`. This is the "
"object that we will use to define our inputs, outputs and other relevant "
"properties of the work chain. The third and final line is extremely "
"important, as it will call the ``define`` method of the parent class, in "
"this case the "
":py:class:`~aiida.engine.processes.workchains.workchain.WorkChain` class."
msgstr ""

#: ../../source/topics/workflows/usage.rst:172
msgid ""
"If you forget to call ``super`` in the ``define`` method, your work chain "
"will fail miserably!"
msgstr ""

#: ../../source/topics/workflows/usage.rst:178
msgid "Inputs and outputs"
msgstr ""

#: ../../source/topics/workflows/usage.rst:179
msgid ""
"With those formalities out of the way, you can start defining the "
"interesting properties of the work chain through the ``spec``. In the "
"example you can see how the method :py:meth:`~plumpy.ProcessSpec.input` is "
"used to define multiple input ports, which document exactly which inputs the"
" work chain expects. Similarly, :py:meth:`~plumpy.ProcessSpec.output` is "
"called to instruct that the work chain will produce an output with the label"
" ``result``. These two port creation methods support a lot more "
"functionality, such as adding help string, validation and more, all of which"
" is documented in detail in the section on :ref:`ports and port "
"namespace<topics:processes:usage:ports_portnamespaces>`."
msgstr ""

#: ../../source/topics/workflows/usage.rst:188
msgid "Outline"
msgstr ""

#: ../../source/topics/workflows/usage.rst:189
msgid ""
"The outline is what sets the work chain apart from other processes. It is a "
"way of defining the higher-level logic that encodes the workflow that the "
"work chain takes. The outline is defined in the ``define`` method through "
"the :py:meth:`~plumpy.WorkChainSpec.outline`. It takes a sequence of "
"instructions that the work chain will execute, each of which is implemented "
"as a method of the work chain class. In the simple example above, the "
"outline consists of three simple instructions: ``add``, ``multiply``, "
"``results``. Since these are implemented as instance methods, they are "
"prefixed with ``cls.`` to indicate that they are in fact methods of the work"
" chain class. For that same reason, their implementation should take "
"``self`` as its one and only argument, as demonstrated in the example "
"snippet."
msgstr ""

#: ../../source/topics/workflows/usage.rst:197
msgid ""
"The outline in this simple example is not particular interesting as it "
"consists of three simple instructions that will be executed sequentially. "
"However, the outline also supports various logical constructs, such as "
"while-loops, conditionals and return statements. As usual, the best way to "
"illustrate these constructs is by example. The currently available logical "
"constructs for the work chain outline are:"
msgstr ""

#: ../../source/topics/workflows/usage.rst:202
msgid "``if``, ``elif``, ``else``"
msgstr ""

#: ../../source/topics/workflows/usage.rst:203
msgid "``while``"
msgstr ""

#: ../../source/topics/workflows/usage.rst:204
msgid "``return``"
msgstr ""

#: ../../source/topics/workflows/usage.rst:206
msgid ""
"To distinguish these constructs from the python builtins, they are suffixed "
"with an underscore, like so ``while_``. To use these in your work chain "
"design, you will have to import them:"
msgstr ""

#: ../../source/topics/workflows/usage.rst:213
msgid ""
"The following example shows how to use these logical constructs to define "
"the outline of a work chain:"
msgstr ""

#: ../../source/topics/workflows/usage.rst:233
msgid ""
"This is an implementation (and an extremely contrived one at that) of the "
"well known FizzBuzz [#f2]_ problem. The idea is that the program is supposed"
" to print in sequence the numbers from zero to some limit, except when the "
"number is a multiple of three ``Fizz`` is printed, for a multiple of five "
"``Buzz`` and when it is a multiple of both, the program should print "
"``FizzBuzz``. Note how the syntax looks very much like that of normal python"
" syntax. The methods that are used in the conditionals (between the "
"parentheses of the ``while_`` and ``if_`` constructs) for example should "
"return a boolean; ``True`` when the condition holds and ``False`` otherwise."
" The actual implementation of the outline steps themselves is now trivial:"
msgstr ""

#: ../../source/topics/workflows/usage.rst:259
msgid ""
"The intention of this example is to show that with a well designed outline, "
"a user only has to look at the outline to have a good idea *what* the work "
"chain does and *how* it does it. One should not have to look at the "
"implementation of the outline steps as all the important information is "
"captured by the outline itself. Since the goal of a work chain should be to "
"execute a very well defined task, it is the goal of the outline to capture "
"the required logic to achieve that goal, in a clear and short yet not overly"
" succint manner. The outline supports various logical flow constructs, such "
"as conditionals and while loops, so where possible this logic should be "
"expressed in the outline and not in the body of the outline functions. "
"However, one can also go overboard and put too finely grained logical blocks"
" into the outline, causing it to become bulky and difficult to understand."
msgstr ""

#: ../../source/topics/workflows/usage.rst:265
msgid ""
"A good rule of thumb in designing the outline is the following: before you "
"start designing a work chain, define very clearly the task that it should "
"carry out. Once the goal is clear, draw a schematic block diagram of the "
"necessary steps and logical decisions that connect them, in order to "
"accomplish that goal. Converting the resulting flow diagram in a one-to-one "
"fashion into an outline, often results in very reasonable outline designs."
msgstr ""

#: ../../source/topics/workflows/usage.rst:274
msgid ""
"There is one more property of a work chain that is specified through its "
"process specification, in addition to its inputs, outputs and outline. Any "
"work chain may have one to multiple failure modes, which are modelled by "
":ref:`exit codes<topics:processes:usage:exit_codes>`. A work chain can be "
"stopped at any time, simply by returning an exit code from an outline "
"method. To retrieve an exit code that is defined on the spec, one can use "
"the :py:meth:`~aiida.engine.processes.process.Process.exit_codes` property. "
"This returns an attribute dictionary where the exit code labels map to their"
" corresponding exit code. For example, with the following process spec:"
msgstr ""

#: ../../source/topics/workflows/usage.rst:286
msgid ""
"To see how exit codes can be used to terminate the execution of work chains "
"gracefully, refer to the section "
":ref:`topics:workflows:usage:workchains:aborting_and_exit_codes`."
msgstr ""

#: ../../source/topics/workflows/usage.rst:292
msgid "Launching work chains"
msgstr ""

#: ../../source/topics/workflows/usage.rst:294
msgid ""
"The rules for launching work chains are the same as those for any other "
"process, which are detailed in :ref:`this "
"section<topics:processes:usage:launching>`. On top of those basic rules, "
"there is one peculiarity in the case of work chains when submitting to the "
"daemon. When you submit a ``WorkChain`` over the daemon, or any other "
"process for that matter, you need to make sure that the daemon can find the "
"class when it needs to load it. Registering your class through the plugin "
"system with a designated entry point is one way to make sure that the daemon"
" will be able to find it. If, however, you simply have a test class and do "
"not want to go through the effort of creating an entry point for it, you "
"should make sure that the module where you define the class is in the python"
" path. Additionally, make sure that the definition of the work chain **is "
"not in the same file from which you submit it**, or the engine won't be able"
" to load it."
msgstr ""

#: ../../source/topics/workflows/usage.rst:305
msgid "Context"
msgstr ""

#: ../../source/topics/workflows/usage.rst:306
msgid ""
"In the simplest work chain example presented in the introductory section, we"
" already saw how the context can be used to persist information during the "
"execution of a work chain and pass it between outline steps. The context is "
"essentially a data container, very similar to a dictionary that can hold all"
" sorts of data. The engine will ensure that its contents are saved and "
"persisted in between steps and when the daemon shuts down or restarts. A "
"trivial example of this would be the following:"
msgstr ""

#: ../../source/topics/workflows/usage.rst:319
msgid ""
"In the ``step_one`` outline step we store the string ``'store me in the "
"context'`` in the context, which can be addressed as ``self.ctx``, under the"
" key ``some_variable``. Note that for the key you can use anything that "
"would be a valid key for a normal python dictionary. In the second outline "
"step ``step_two``, we can verify that the string was successfully persisted,"
" by checking the value stored in the context ``self.ctx.some_variable``."
msgstr ""

#: ../../source/topics/workflows/usage.rst:325
msgid "Any data that is stored in the context **has** to be serializable."
msgstr ""

#: ../../source/topics/workflows/usage.rst:327
msgid ""
"This was just a simple example to introduce the concept of the context, "
"however, it really is one of the more important parts of the work chain. The"
" context really becomes crucial when you want to submit a calculation or "
"another work chain from within the work chain. How this is accomplished, we "
"will show in the next section."
msgstr ""

#: ../../source/topics/workflows/usage.rst:334
msgid "Submitting sub processes"
msgstr ""

#: ../../source/topics/workflows/usage.rst:335
msgid ""
"One of the main tasks of a ``WorkChain`` will be to launch other processes, "
"such as a ``CalcJob`` or another ``WorkChain``. How to submit processes was "
"explained in :ref:`another section<topics:processes:usage:launch>` and is "
"accomplished by using the :py:func:`~aiida.engine.launch.submit` launch "
"function. However, when submitting a sub process from within a work chain, "
"**this should not be used**. Instead, the "
":py:class:`~aiida.engine.processes.process.Process` class provides its own "
":py:meth:`~aiida.engine.processes.process.Process.submit` method. If you do,"
" you will be greeted with the exception:"
msgstr ""

#: ../../source/topics/workflows/usage.rst:345
msgid ""
"The only change you have to make is to replace the top-level ``submit`` "
"method with the built-in method of the process class:"
msgstr ""

#: ../../source/topics/workflows/usage.rst:353
msgid ""
"The ``self.submit`` method has the exact same interface as the global "
"``aiida.engine.launch.submit`` launcher. When the ``submit`` method is "
"called, the process is created and submitted to the daemon, but at that "
"point it is not yet done. So the value that is returned by the ``submit`` "
"call is not the result of the submitted process, but rather it is the "
"process node that represents the execution of the process in the provenance "
"graph and acts as a *future*. We somehow need to tell the work chain that it"
" should wait for the sub process to be finished, and the future to resolve, "
"before it continues. To do so, however, control has to be returned to the "
"engine, which can then, when the process is completed, call the next step in"
" the outline, where we can analyse the results. The snippet above already "
"revealed that this is accomplished by returning an instance of the "
"``ToContext`` class."
msgstr ""

#: ../../source/topics/workflows/usage.rst:361
msgid "To context"
msgstr ""

#: ../../source/topics/workflows/usage.rst:362
msgid ""
"In order to store the future of the submitted process, we can store it in "
"the context with a special construct that will tell the engine that it "
"should wait for that process to finish before continuing the work chain. To "
"illustrate how this works, consider the following minimal example:"
msgstr ""

#: ../../source/topics/workflows/usage.rst:368
msgid ""
"As explained in the previous section, calling ``self.submit`` for a given "
"process that you want to submit, will return a future. To add this future to"
" the context, we can not access the context directly as explained in the "
":ref:`context section<topics:workflows:usage:workchains:context>`, but "
"rather we need to use the class "
":py:class:`~aiida.engine.processes.workchains.context.ToContext`. This class"
" has to be imported from the ``aiida.engine`` module. To add the future to "
"the context, simply construct an instance of ``ToContext``, passing the "
"future as a keyword argument, and returning it from the outline step. The "
"keyword used, ``workchain`` in this example, will be the key used under "
"which to store the node in the context once its execution has terminated. "
"Returning an instance of ``ToContext`` signals to the engine that it has to "
"wait for the futures contained within it to finish execution, store their "
"nodes in the context under the specified keys and then continue to the next "
"step in the outline. In this example, that is the ``inspect_workchain`` "
"method. At this point we are sure that the process, a work chain in this "
"case, has terminated its execution, although not necessarily successful, and"
" we can continue the logic of the work chain."
msgstr ""

#: ../../source/topics/workflows/usage.rst:379
msgid ""
"Using the ``ToContext`` construct alone is not enough to tell the engine "
"that it should wait for the sub process to finish. There **needs** to be at "
"least another step in the outline to follow the step that added the "
"awaitables. If there is no more step to follow, according to the outline, "
"the engine interprets this as the work chain being done and so it will not "
"wait for the sub process to finish. Think about it like this: if there is "
"not even a single step to follow, there is also nothing the work chain could"
" do with the results of the sub process, so there is no point in waiting."
msgstr ""

#: ../../source/topics/workflows/usage.rst:384
msgid ""
"Sometimes one wants to launch not just one, but multiple processes at the "
"same time that can run in parallel. With the mechanism described above, this"
" will not be possible since after submitting a single process and returning "
"the ``ToContext`` instance, the work chain has to wait for the process to be"
" finished before it can continue. To solve this problem, there is another "
"way to add futures to the context:"
msgstr ""

#: ../../source/topics/workflows/usage.rst:391
msgid ""
"Here we submit three work chains in a for loop in a single outline step, but"
" instead of returning an instance of ``ToContext``, we call the "
":meth:`~aiida.engine.processes.workchains.workchain.WorkChain.to_context` "
"method. This method has exactly the same syntax as the ``ToContext`` class, "
"except it is not necessary to return its value, so we can call it multiple "
"times in one outline step. Under the hood the functionality is also the same"
" as the ``ToContext`` class. At the end of the ``submit_workchains`` outline"
" step, the engine will find the futures that were added by calling "
"``to_context`` and will wait for all of them to be finished. The good thing "
"here is that these three sub work chains can be run in parallel and once all"
" of them are done, the parent work chain will go to the next step, which is "
"``inspect_workchains``. There we can find the nodes of the work chains in "
"the context under the key that was used as the keyword argument in the "
"``to_context`` call in the previous step."
msgstr ""

#: ../../source/topics/workflows/usage.rst:398
msgid ""
"Since we do not want the subsequent calls of ``to_context`` to override the "
"previous future, we had to create unique keys to store them under. In this "
"example, we chose to use the index of the for-loop. The name carries no "
"meaning and is just required to guarantee unique key names. This pattern "
"will occur often where you will want to launch multiple work chains or "
"calculations in parallel and will have to come up with unique names. In "
"essence, however, you are really just creating a list and it would be better"
" to be able to create a list in the context and simply append the future to "
"that list as you submit them. How this can be achieved is explained in the "
"next section."
msgstr ""

#: ../../source/topics/workflows/usage.rst:406
msgid "Appending"
msgstr ""

#: ../../source/topics/workflows/usage.rst:407
msgid ""
"When you want to add a future of a submitted sub process to the context, but"
" append it to a list rather than assign it to a key, you can use the "
":func:`~aiida.engine.processes.workchains.context.append_` function. "
"Consider the example from the previous section, but now we will use the "
"``append_`` function instead:"
msgstr ""

#: ../../source/topics/workflows/usage.rst:413
msgid ""
"Notice that in the ``submit_workchains`` step we no longer have to generate "
"a unique key based on the index but we simply wrap the future in the "
"``append_`` function and assign it to the generic key ``workchains``. The "
"engine will see the ``append_`` function and instead of assigning the node "
"corresponding to the future to the key ``workchains``, it will append it to "
"the list stored under that key. If the list did not yet exist, it will "
"automatically be created. The ``self.ctx.workchains`` now contains a list "
"with the nodes of the completed work chains, with the same order as they had"
" been inserted, and so in the ``inspect_workchains`` step we can simply "
"iterate over it to access all of them. Note that the use of ``append_`` is "
"not just limited to the ``to_context`` method. You can also use it in "
"exactly the same way with ``ToContext`` to append a process to a list in the"
" context in multiple outline steps."
msgstr ""

#: ../../source/topics/workflows/usage.rst:421
msgid "Nested context keys"
msgstr ""

#: ../../source/topics/workflows/usage.rst:423
msgid ""
"To simplify the organization of the context, the keys may contain dots "
"``.``, transparently creating namespaces in the process. As an example "
"compare the following to the parallel submission example above:"
msgstr ""

#: ../../source/topics/workflows/usage.rst:429
msgid ""
"This allows to create intuitively grouped and easily accessible structures "
"of child calculations or workchains."
msgstr ""

#: ../../source/topics/workflows/usage.rst:434
msgid "Reporting"
msgstr ""

#: ../../source/topics/workflows/usage.rst:435
msgid ""
"During the execution of a ``WorkChain``, we may want to keep the user "
"abreast of its progress and what is happening. For this purpose, the "
"``WorkChain`` implements the "
":py:meth:`~aiida.engine.processes.process.Process.report` method, which "
"functions as a logger of sorts. It takes a single argument, a string, that "
"is the message that needs to be reported:"
msgstr ""

#: ../../source/topics/workflows/usage.rst:444
msgid ""
"This will send that message to the internal logger of python, which will "
"cause it to be picked up by the default AiiDA logger, but it will also "
"trigger the database log handler, which will store the message in the "
"database and link it to the node of the work chain. This allows the ``verdi "
"process report`` command to retrieve all those messages that were fired "
"using the ``report`` method for a specific process. Note that the report "
"method, in addition to the pk of the work chain, will also automatically "
"record the name of the work chain and the name of the outline step in which "
"the report message was fired. This information will show up in the output of"
" ``verdi process report``, so you never have to explicitly reference the "
"work chain name, outline step name or date and time in the message itself."
msgstr ""

#: ../../source/topics/workflows/usage.rst:449
msgid ""
"It is important to note that the report system is a form of logging and as "
"such has been designed to be read by humans only. That is to say, the report"
" system is not designed to pass information programmatically by parsing the "
"log messages."
msgstr ""

#: ../../source/topics/workflows/usage.rst:455
msgid "Aborting and exit codes"
msgstr ""

#: ../../source/topics/workflows/usage.rst:456
msgid ""
"At the end of every outline step, the return value will be inspected by the "
"engine. If a non-zero integer value is detected, the engine will interpret "
"this as an exit code and will stop the execution of the work chain, while "
"setting its process state to ``Finished``. In addition, the integer return "
"value will be set as the ``exit_status`` of the work chain, which combined "
"with the ``Finished`` process state will denote that the worchain is "
"considered to be ``Failed``, as explained in the section on the "
":ref:`process state <topics:processes:concepts:state>`. This is useful "
"because it allows a workflow designer to easily exit from a work chain and "
"use the return value to communicate programmatically the reason for the work"
" chain stopping."
msgstr ""

#: ../../source/topics/workflows/usage.rst:461
msgid ""
"We assume that you have read the :ref:`section on how to define exit codes "
"<topics:workflows:usage:workchains:define_exit_codes>` through the process "
"specification of the work chain. Consider the following example work chain "
"that defines such an exit code:"
msgstr ""

#: ../../source/topics/workflows/usage.rst:468
msgid ""
"Now imagine that in the outline, we launch a calculation and in the next "
"step check whether it finished successfully. In the event that the "
"calculation did not finish successfully, the following snippet shows how you"
" can retrieve the corresponding exit code and abort the ``WorkChain`` by "
"returning it:"
msgstr ""

#: ../../source/topics/workflows/usage.rst:485
msgid ""
"In the ``inspect_calculation`` outline, we retrieve the calculation that was"
" submitted and added to the context in the previous step and check if it "
"finished successfully through the property ``is_finished_ok``. If this "
"returns ``False``, in this example we simply fire a report message and "
"return the exit code corresponding to the label "
"``ERROR_CALCULATION_FAILED``. Note that the specific exit code can be "
"retrieved through the ``WorkChain`` property ``exit_codes``. This will "
"return a collection of exit codes that have been defined for that "
"``WorkChain`` and any specific exit code can then be retrieved by accessing "
"it as an attribute. Returning this exit code, which will be an instance of "
"the :py:class:`~aiida.engine.processes.exit_code.ExitCode` class, will cause"
" the work chain to be aborted and the ``exit_status`` and ``exit_message`` "
"to be set on the node, which were defined in the spec."
msgstr ""

#: ../../source/topics/workflows/usage.rst:493
msgid ""
"The notation ``self.exit_codes.ERROR_CALCULATION_FAILED`` is just syntactic "
"sugar to retrieve the ``ExitCode`` instance that was defined in the spec "
"with that error label. Constructing your own ``ExitCode`` directly and "
"returning that from the outline step will have exactly the same effect in "
"terms of aborting the work chain execution and setting the exit status and "
"message. However, it is strongly advised to define the exit code through the"
" spec and retrieve it through the ``self.exit_codes`` collection, as that "
"makes it easily retrievable through the spec by the caller of the work "
"chain."
msgstr ""

#: ../../source/topics/workflows/usage.rst:497
msgid ""
"The ``message`` attribute of an ``ExitCode`` can also be a string that "
"contains placeholders. This is useful when the exit code's message is "
"generic enough to a host of situations, but one would just like to "
"parameterize the exit message. To concretize the template message of an exit"
" code, simply call the "
":meth:`~aiida.engine.processes.exit_code.ExitCode.format` method and pass "
"the parameters as keyword arguments:"
msgstr ""

#: ../../source/topics/workflows/usage.rst:506
msgid ""
"This concept can also be applied within the scope of a process. In the "
"process spec, we can declare a generic exit code whose exact message should "
"depend on one or multiple parameters:"
msgstr ""

#: ../../source/topics/workflows/usage.rst:513
msgid ""
"Through the ``self.exit_codes`` collection of a ``WorkChain``, this generic "
"can be easily customized as follows:"
msgstr ""

#: ../../source/topics/workflows/usage.rst:520
msgid ""
"This is no different than the example before, because "
"``self.exit_codes.ERROR_INVALID_PARAMETER`` simply returns an instance of "
"``ExitCode``, which we then call ``format`` on with the substitution "
"parameters."
msgstr ""

#: ../../source/topics/workflows/usage.rst:522
msgid ""
"In conclusion, the best part about using exit codes to abort a work chain's "
"execution, is that the exit status can now be used programmatically, by for "
"example a parent work chain. Imagine that a parent work chain submitted this"
" work chain. After it has terminated its execution, the parent work chain "
"will want to know what happened to the child work chain. As already noted in"
" the :ref:`report<topics:workflows:usage:workchains:reporting>` section, the"
" report messages of the work chain should not be used. The exit status, "
"however, is a perfect way. The parent work chain can easily request the exit"
" status of the child work chain through the ``exit_status`` property, and "
"based on its value determine how to proceed."
msgstr ""

#: ../../source/topics/workflows/usage.rst:531
msgid "Modular workflow design"
msgstr ""

#: ../../source/topics/workflows/usage.rst:532
msgid ""
"When creating complex workflows, it is a good idea to split them up into "
"smaller, modular parts. At the lowest level, each workflow should perform "
"exactly one task. These workflows can then be wrapped together by a "
"\"parent\" workflow to create a larger logical unit."
msgstr ""

#: ../../source/topics/workflows/usage.rst:536
msgid ""
"In order to make this approach manageable, it needs to be as simple as "
"possible to glue together multiple workflows in a larger parent workflow. "
"One of the tools that AiiDA provides to simplify this is the ability to "
"*expose* the ports of another process class. This can be another "
"``WorkChain`` implementation, a ``CalcJob`` or even a process function (a "
"``calcfunction`` or ``workfunction``)."
msgstr ""

#: ../../source/topics/workflows/usage.rst:543
msgid "Exposing inputs and outputs"
msgstr ""

#: ../../source/topics/workflows/usage.rst:544
msgid ""
"Consider the following example work chain, which simply takes a few inputs "
"and returns them again as outputs:"
msgstr ""

#: ../../source/topics/workflows/usage.rst:549
msgid ""
"As a first example, we will implement a thin wrapper workflow, which simply "
"forwards its inputs to ``ChildWorkChain``, and forwards the outputs of the "
"child to its outputs:"
msgstr ""

#: ../../source/topics/workflows/usage.rst:554
msgid ""
"In the ``define`` method of this simple parent work chain, we use the "
":meth:`~plumpy.process_spec.ProcessSpec.expose_inputs` and "
":meth:`~plumpy.process_spec.ProcessSpec.expose_outputs`. This creates the "
"corresponding input and output ports in the parent work chain. Additionally,"
" AiiDA remembers which inputs and outputs were exposed from that particular "
"work chain class. This is used when calling the child in the ``run_child`` "
"method. The :meth:`~aiida.engine.processes.process.Process.exposed_inputs` "
"method returns a dictionary of inputs that the parent received which were "
"exposed from the child, and so it can be used to pass these on to the child."
" Finally, in the ``finalize`` method, we use "
":meth:`~aiida.engine.processes.process.Process.exposed_outputs` to retrieve "
"the outputs of the child which were exposed to the parent. Using "
":meth:`~aiida.engine.processes.process.Process.out_many`, these outputs are "
"added to the outputs of the parent work chain. This work chain can now be "
"run in exactly the same way as the child itself:"
msgstr ""

#: ../../source/topics/workflows/usage.rst:566
msgid ""
"Next, we will see how a more complex parent work chain can be created by "
"using the additional features of the expose functionality. The following "
"work chain launches two children. These children share the input ``a``, but "
"have different ``b`` and ``c``. The output ``e`` will be taken only from the"
" first child, whereas ``d`` and ``f`` are taken from both children. In order"
" to avoid name conflicts, we need to create a *namespace* for each of the "
"two children, where the inputs and outputs which are not shared are stored. "
"Our goal is that the workflow can be called as follows:"
msgstr ""

#: ../../source/topics/workflows/usage.rst:576
msgid ""
"This is achieved by the following workflow. In the next section, we will "
"explain each of the steps."
msgstr ""

#: ../../source/topics/workflows/usage.rst:582
msgid ""
"First of all, we want to expose the ``a`` input and the ``e`` output at the "
"top-level. For this, we again use "
":meth:`~plumpy.process_spec.ProcessSpec.expose_inputs` and "
":meth:`~plumpy.process_spec.ProcessSpec.expose_outputs`, but with the "
"optional keyword ``include``. This specifies a list of keys, and only inputs"
" or outputs which are in that list will be exposed. So by passing "
"``include=['a']`` to :meth:`~plumpy.process_spec.ProcessSpec.expose_inputs`,"
" only the input ``a`` is exposed."
msgstr ""

#: ../../source/topics/workflows/usage.rst:587
msgid ""
"Additionally, we want to expose the inputs ``b`` and ``c`` (outputs ``d`` "
"and ``f``), but in a namespace specific for each of the two children. For "
"this purpose, we pass the ``namespace`` parameter to the expose functions. "
"However, since we now shouldn't expose ``a`` (``e``) again, we use the "
"``exclude`` keyword, which specifies a list of keys that will not be "
"exposed."
msgstr ""

#: ../../source/topics/workflows/usage.rst:591
msgid ""
"When calling the children, we again use the "
":meth:`~aiida.engine.processes.process.Process.exposed_inputs` method to "
"forward the exposed inputs. Since the inputs ``b`` and ``c`` are now in a "
"specific namespace, we need to pass this namespace as an additional "
"parameter. By default, "
":meth:`~aiida.engine.processes.process.Process.exposed_inputs` will search "
"through all the parent namespaces of the given namespace to search for "
"input, as shown in the call for ``child_1``. If the same input key exists in"
" multiple namespaces, the input in the lowest namespace takes precedence. "
"It's also possible to disable this behavior, and instead search only in the "
"explicit namespace that was passed. This is done by setting "
"``agglomerate=False``, as shown in the call to ``child_2``. Of course, we "
"then need to explicitly pass the input ``a``."
msgstr ""

#: ../../source/topics/workflows/usage.rst:599
msgid ""
"Finally, we use "
":meth:`~aiida.engine.processes.process.Process.exposed_outputs` and "
":meth:`~aiida.engine.processes.process.Process.out_many` to forward the "
"outputs of the children to the outputs of the parent. Again, the "
"``namespace`` and ``agglomerate`` options can be used to select which "
"outputs are returned by the "
":meth:`~aiida.engine.processes.process.Process.exposed_outputs` method."
msgstr ""

#: ../../source/topics/workflows/usage.rst:604
msgid ""
"For further practical examples of creating workflows, see the :ref:`how to "
"write workflows<how-to:write-workflows>` and :ref:`how to write error "
"resistant workflows <how-to:restart-workchain>` sections."
msgstr ""

#: ../../source/topics/workflows/usage.rst:609
msgid "https://docs.python.org/3.5/library/functions.html#classmethod"
msgstr ""

#: ../../source/topics/workflows/usage.rst:610
msgid "https://en.wikipedia.org/wiki/Fizz_buzz"
msgstr ""
