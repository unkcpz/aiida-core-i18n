# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2020, ECOLE POLYTECHNIQUE FEDERALE DE LAUSANNE (Theory and Simulation of Materials (THEOS) and National Centre for Computational Design and Discovery of Novel Materials (NCCR MARVEL)), Switzerland and ROBERT BOSCH LLC, USA. All rights reserved
# This file is distributed under the same license as the AiiDA package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Guoyu(Gloria) YANG <ygy.11@163.com>, 2020
# Jusong Yu <morty.yu@yahoo.com>, 2021
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: AiiDA 2.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-11-03 14:17+0000\n"
"PO-Revision-Date: 2020-07-01 16:11+0000\n"
"Last-Translator: Jusong Yu <morty.yu@yahoo.com>, 2021\n"
"Language-Team: Chinese (China) (https://www.transifex.com/aiidateam/teams/98967/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../source/howto/archive_profile.md:16
msgid "How to inspect an archive"
msgstr ""

#: ../../source/howto/archive_profile.md:1
msgid ""
"This tutorial can be downloaded and run as a Jupyter Notebook: {nb-"
"download}`archive_profile.ipynb` {octicon}`download`, together with the "
"archive {download}`include/process.aiida`."
msgstr ""

#: ../../source/howto/archive_profile.md:22
msgid ""
"The AiiDA archive is a file format for long term storage of data from a "
"particular profile."
msgstr ""

#: ../../source/howto/archive_profile.md:24
msgid ""
"See {ref}`how-to:share:archives` for information on how to create and "
"migrate an archive. Once you have an archive at the latest version, you can "
"inspect its contents in the same way you would with a standard AiiDA "
"profile."
msgstr ""

#: ../../source/howto/archive_profile.md:27
msgid "We first create a profile instance from the archive path:"
msgstr ""

#: ../../source/howto/archive_profile.md:37
msgid ""
"The {py:func}`~aiida.manage.configuration.profile_context` function works "
"similarly to the {py:func}`~aiida.manage.configuration.load_profile` "
"function, but is used within a context manager, that insures that the "
"storage is properly closed when the context is exited. With this, we can "
"load our archive as a profile:"
msgstr ""

#: ../../source/howto/archive_profile.md:46
msgid ""
"To directly access the storage backend, and view information about it, we "
"can use:"
msgstr ""

#: ../../source/howto/archive_profile.md:56
msgid "This is directly equivalent to the command-line call:"
msgstr ""

#: ../../source/howto/archive_profile.md:62
msgid ""
"Note, that once the context manager is exited, the storage is closed, and "
"will except on further calls."
msgstr ""

#: ../../source/howto/archive_profile.md:68
msgid ""
"As per a standard profile, we can now use the "
"{py:class}`~aiida.orm.QueryBuilder`, to [find and query for data](how-"
"to:query):"
msgstr ""

#: ../../source/howto/archive_profile.md:76
msgid ""
"and also use {py:class}`~aiida.tools.visualization.graph.Graph`, to "
"[visualize data provenance](how-to:data:visualise-provenance):"
msgstr ""

#: ../../source/howto/cookbook.rst:5
msgid "Cookbook"
msgstr "有用的代码片段"

#: ../../source/howto/cookbook.rst:7
msgid ""
"This how-to page collects useful short scripts and code snippets that may be"
" useful in the everyday usage of AiiDA."
msgstr "这个“如何做”页面收集了在AiiDA的日常使用中可能有用的简短脚本和代码片段。"

#: ../../source/howto/cookbook.rst:11
msgid "Checking the queued jobs on a scheduler"
msgstr "检查调度程序上排队的作业"

#: ../../source/howto/cookbook.rst:13
msgid ""
"If you want to know if which jobs are currently on the scheduler (e.g. to "
"dynamically decide on which computer to submit, or to delay submission, "
"etc.) you can use the following script as an example:"
msgstr "如果你想知道哪些作业当前在调度程序上(例如，动态决定要提交哪台计算机，或延迟提交，等等)，你可以使用下面的脚本作为例子:"

#: ../../source/howto/cookbook.rst:58
msgid "Use ``verdi run`` to execute it:"
msgstr "使用 ``verdi run`` 运行它:"

#: ../../source/howto/cookbook.rst:66
msgid ""
"Every time you call the function, two SSH connections are opened! So be "
"careful and run this function sparsely, or your supercomputer center might "
"block your account. A possible work around to this limitation is to pass the"
" transport as a parameter, and pass it in so that it can be reused."
msgstr ""
"每次调用该函数时，将打开两个SSH连接!所以要小心谨慎地运行这个功能，否则你的超级计算机中心可能会屏蔽你的帐户。解决此限制的一个可能方法是将transport作为参数传递，并将其传入以便重用。"

#: ../../source/howto/cookbook.rst:70
msgid "An example output would be::"
msgstr "一个输出样例是::"

#: ../../source/howto/cookbook.rst:93
msgid "Getting an ``AuthInfo`` knowing the computer and the user"
msgstr "获得一个保存有计算机和用户信息的 ``AuthInfo`` 对象 "

#: ../../source/howto/cookbook.rst:95
msgid ""
"To open a transport to a computer, you need the corresponding "
":class:`~aiida.orm.authinfos.AuthInfo` object, which contains the required "
"information for a specific user. Once you have the relevant "
":class:`~aiida.orm.computers.Computer` and :class:`~aiida.orm.users.User` "
"collection, you can obtain as follows:"
msgstr ""

#: ../../source/howto/cookbook.rst:102
msgid "Here is, as an example, a useful utility function:"
msgstr "下面是一个有用的工具函数:"

#: ../../source/howto/cookbook.rst:112
msgid "that you can then use, for instance, as follows:"
msgstr "例如，你可以这样使用:"

#: ../../source/howto/data.rst:5
msgid "How to work with data"
msgstr "如何处理数据"

#: ../../source/howto/data.rst:11
msgid "Importing data"
msgstr "导入数据"

#: ../../source/howto/data.rst:13
msgid ""
"AiiDA allows users to export data from their database into an export archive"
" file, which can be imported into any other AiiDA database. If you have an "
"AiiDA export archive that you would like to import, you can use the ``verdi "
"archive import`` command (see :ref:`the reference section<reference:command-"
"line:verdi-archive>` for details)."
msgstr ""

#: ../../source/howto/data.rst:16
msgid ""
"For information on exporting and importing data via AiiDA archives, see "
":ref:`\"How to share data\"<how-to:share:archives>`."
msgstr "有关通过AiiDA档案导出和导入数据的信息，请参见 :ref:`如何共享数据<how-to:share:archives>`。"

#: ../../source/howto/data.rst:18
msgid ""
"If, instead, you have existing data that are not yet part of an AiiDA export"
" archive, such as files, folders, tabular data, arrays or any other kind of "
"data, this how-to guide will show you how to import them into AiiDA."
msgstr ""
"相反，如果您拥有尚未成为AiiDA导出归档的一部分的现成数据，例如文件、文件夹、表格数据、数组或任何其他类型的数据，此操作指南将向您展示如何将它们导入AiiDA。"

#: ../../source/howto/data.rst:20
msgid ""
"To store any piece of data in AiiDA, it needs to be wrapped in a "
":py:class:`~aiida.orm.Data` node, such that it can be represented in the "
":ref:`provenance graph <topics:provenance>`. There are different varieties, "
"or subclasses, of this ``Data`` class that are suited for different types of"
" data. AiiDA ships with a number of built-in data types. You can list these "
"using the :ref:`verdi plugin<reference:command-line:verdi-plugin>` command. "
"Executing ``verdi plugin list aiida.data`` should display something like::"
msgstr ""

#: ../../source/howto/data.rst:38
msgid ""
"As the output suggests, you can get more information about each type by "
"appending the name to the command, for example, ``verdi plugin list "
"aiida.data singlefile``::"
msgstr ""
"如输出所示，您可以通过在命令后面附加名称来获得关于每种类型的更多信息，例如， ``verdi plugin list aiida.data "
"singlefile``::"

#: ../../source/howto/data.rst:56
msgid ""
"As you can see, the ``singlefile`` type corresponds to the "
":py:class:`~aiida.orm.nodes.data.singlefile.SinglefileData` class and is "
"designed to wrap a single file that is stored on your local filesystem. If "
"you have such a file that you would like to store in AiiDA, you can use the "
"``verdi shell`` to create it:"
msgstr ""
"如所见， ``singlefile``  类型对应于 "
":py:class:`~aiida.orm.nodes.data.singlefile.SinglefileData`类，被用于包装存储在本地文件系统上的单个文件。如果你有这样一个单独的文件，想将其存储在AiiDA中，你可以使用``verdi"
" shell`` 创建它:"

#: ../../source/howto/data.rst:65
msgid ""
"The first step is to load the class that corresponds to the data type, which"
" you do by passing the name (listed by ``verdi plugin list aiida.data``) to "
"the :py:class:`~aiida.plugins.factories.DataFactory`. Then we just construct"
" an instance of that class, passing the file of interest as an argument."
msgstr ""
"第一步是加载与数据类型对应的类，这是通过将名称(由``verdi plugin list "
"aiida.data``列出)传递给::py:class:`~aiida.plugins.factories.DataFactory` "
"来完成的。然后构造该类的一个实例，将感兴趣的文件作为参数传递。"

#: ../../source/howto/data.rst:68
msgid ""
"The exact manner of constructing an instance of any particular data type is "
"type dependent. Use the ``verdi plugin list aiida.data <ENTRY_POINT>`` "
"command to get more information for any specific type."
msgstr ""
"构造任何特定数据类型实例的确切方式取决于类型。使用``verdi plugin list aiida.data "
"<ENTRY_POINT>``。命令获取任何特定类型的更多信息。"

#: ../../source/howto/data.rst:71
msgid ""
"Note that after construction, you will get an *unstored* node. This means "
"that at this point your data is not yet stored in the database and you can "
"first inspect it and optionally modify it. If you are happy with the "
"results, you can store the new data permanently by calling the "
":py:meth:`~aiida.orm.nodes.node.Node.store` method. Every node is assigned a"
" Universal Unique Identifier (UUID) upon creation and once stored it is also"
" assigned a primary key (PK), which can be retrieved through the "
"``node.uuid`` and ``node.pk`` properties, respectively. You can use these "
"identifiers to reference and or retrieve a node. Ways to find and retrieve "
"data that have previously been imported are described in section :ref:`\"How"
" to find data\"<how-to:query>`."
msgstr ""

#: ../../source/howto/data.rst:78
msgid ""
"If none of the currently available data types, as listed by ``verdi plugin "
"list``, seem to fit your needs, you can also create your own custom type. "
"For details refer to the next section :ref:`\"How to add support for custom "
"data types\"<topics:data_types:plugin>`."
msgstr ""
"如果 ``verdi plugin list`` 列出的类型中没有你可用的数据类型，适合你的需要，你也可以创建自己的自定义类型。详细信息请参考下一节 "
":ref:`如何添加自定义数据类型的支持<topics:data_types:plugin>`。"

#: ../../source/howto/data.rst:85
msgid "Provenance"
msgstr ""

#: ../../source/howto/data.rst:87
msgid ""
"While AiiDA will automatically keep the provenance of data that is created "
"by it through calculations and workflows, this is clearly not the case when "
"creating data nodes manually, as described in the previous section. "
"Typically, the manual creation of data happens at the beginning of a project"
" when data from external databases is imported as a starting point for "
"further calculations. To still keep some form of provenance, the "
":class:`~aiida.orm.Data` base class allows to record the _source_ of the "
"data it contains. When constructing a new data node, of any type, you can "
"pass a dictionary with information of the source under the ``source`` "
"keyword argument:"
msgstr ""

#: ../../source/howto/data.rst:96
msgid ""
"Once stored, this data can always be retrieved through the ``source`` "
"property:"
msgstr ""

#: ../../source/howto/data.rst:102
msgid ""
"The following list shows all the keys that are allowed to be set in the "
"``source`` dictionary:"
msgstr ""

#: ../../source/howto/data.rst:104
msgid "'db_name': The name of the external database."
msgstr ""

#: ../../source/howto/data.rst:105
msgid "'db_uri': The base URI of the external database."
msgstr ""

#: ../../source/howto/data.rst:106
msgid ""
"'uri': The exact URI of where the data can be retrieved. Ideally this is a "
"persistent URI."
msgstr ""

#: ../../source/howto/data.rst:107
msgid ""
"'id': The external ID with which the data is identified in the external "
"database."
msgstr ""

#: ../../source/howto/data.rst:108
msgid "'version': The version of the data, if any."
msgstr ""

#: ../../source/howto/data.rst:109
msgid ""
"'extras': Optional dictionary with other fields for source description."
msgstr ""

#: ../../source/howto/data.rst:110
msgid "'source_md5': MD5 checksum of the data."
msgstr ""

#: ../../source/howto/data.rst:111
msgid ""
"'description': Human-readable free form description of the data's source."
msgstr ""

#: ../../source/howto/data.rst:112
msgid ""
"'license': A string with the type of license that applies to the data, if "
"any."
msgstr ""

#: ../../source/howto/data.rst:114
msgid ""
"If any other keys are defined, an exception will be raised by the "
"constructor."
msgstr ""

#: ../../source/howto/data.rst:120
msgid "Organizing data"
msgstr "组织数据"

#: ../../source/howto/data.rst:125
msgid "How to group nodes"
msgstr "如何对节点进行分组"

#: ../../source/howto/data.rst:127
msgid ""
"AiiDA's database is great for automatically storing all your data, but "
"sometimes it can be tricky to navigate this flat data store. To create some "
"order in this mass of data, you can *group* sets of nodes together, just as "
"you would with files in folders on your filesystem. A folder, in this "
"analogy, is represented by the :py:class:`~aiida.orm.groups.Group` class. "
"Each group instance can hold any amount of nodes and any node can be "
"contained in any number of groups. A typical use case is to store all nodes "
"that share a common property in a single group."
msgstr ""
"AiiDA的数据库非常适合自动存储您的所有数据，但有时浏览这样一个平面数据存储可能比较棘手。为了在大量数据中创建一些顺序，您可以将节点集 *分组* "
"在一起，就像您在文件系统中的文件夹中处理文件一样。在这个类比中，文件夹由 :py:class:`~aiida.orm.groups.Group` "
"表示。每个组实例可以容纳任意数量的节点，任意节点可以包含在任意数量的组中。一个典型的用例是在一个组中存储共享公共属性的所有节点。"

#: ../../source/howto/data.rst:133
msgid ""
"Below we show how to perform a typical set of operations one may want to "
"perform with groups."
msgstr "下面我们将展示如何对组执行一组可执行的典型操作。"

#: ../../source/howto/data.rst:136
msgid "Create a new group"
msgstr "创建新组"

#: ../../source/howto/data.rst:138 ../../source/howto/data.rst:202
#: ../../source/howto/data.rst:220 ../../source/howto/data.rst:254
#: ../../source/howto/data.rst:272 ../../source/howto/data.rst:295
msgid "From the command line interface:"
msgstr "使用命令行接口:"

#: ../../source/howto/data.rst:144 ../../source/howto/data.rst:227
#: ../../source/howto/data.rst:261 ../../source/howto/data.rst:302
msgid "From the Python interface:"
msgstr "使用python接口:"

#: ../../source/howto/data.rst:155
msgid "List available groups"
msgstr "*列出所有可用组"

#: ../../source/howto/data.rst:157
msgid "Example:"
msgstr "例如: "

#: ../../source/howto/data.rst:163
msgid ""
"Groups come in different types, indicated by their type string. By default "
"``verdi group list`` only shows groups of the type *core*. In case you want "
"to show groups of another type use ``-T/--type-string`` option. If you want "
"to show groups of all types, use the ``-a/--all-types`` option."
msgstr ""
"组有不同的类型，由它们的类型字符串表示。默认情况下 ``verdi group list`` 只显示类型为 *core* "
"的组。如果你想显示另一种类型的组，请使用 ``-T/--type-string`` 选项。如果要显示所有类型的组，请使用 ``-a/--all-"
"types`` 选项。"

#: ../../source/howto/data.rst:168
msgid "For example, to list groups of type ``core.auto``, use:"
msgstr "例如，列出类型为``core.auto`` 的组，使用:"

#: ../../source/howto/data.rst:174
msgid ""
"Similarly, we can use the ``type_string`` key to filter groups with the "
"``QueryBuilder``:"
msgstr "类似地，我们可以使用``QueryBuilder`` 的 ``type_string`` 键来'筛选组:"

#: ../../source/howto/data.rst:185
msgid "Add nodes to a group"
msgstr "将节点加入组"

#: ../../source/howto/data.rst:186
msgid ""
"Once the ``test_group`` has been created, we can add nodes to it. For "
"example, to add a node with ``pk=1`` to the group we could either use the "
"command line interface:"
msgstr "一旦创建了``test_group`` ，我们就可以向它添加节点。例如，要向组中添加一个``pk=1`` 的节点，我们可以使用命令行:"

#: ../../source/howto/data.rst:194
msgid "Or the Python interface:"
msgstr "或者Python接口:"

#: ../../source/howto/data.rst:201
msgid "Show information about a group"
msgstr "显示关于组的信息"

#: ../../source/howto/data.rst:219
msgid "Remove nodes from a group"
msgstr "从组中移除节点"

#: ../../source/howto/data.rst:235
msgid ""
"Alternatively, you might want to remove *all* nodes from the group. In the "
"command line you just need to add ``-c/--clear`` option to ``verdi group "
"remove-nodes ..``"
msgstr ""
"或者，您可能希望从组中删除 *所有* 节点。在命令行中你只需要添加 ``-c/--clear`` 选项到  ``verdi group remove-"
"nodes ..``"

#: ../../source/howto/data.rst:243
msgid ""
"In the Python interface you can use ``.clear()`` method to achieve the same "
"goal:"
msgstr "在Python接口中，你可以使用  ``.clear()`` 方法来实现相同的目标:"

#: ../../source/howto/data.rst:253
msgid "Rename a group"
msgstr "重命名组"

#: ../../source/howto/data.rst:271
msgid "Delete a group"
msgstr "删除组"

#: ../../source/howto/data.rst:280
msgid ""
"Any deletion operation related to groups, by default, will not affect the "
"nodes themselves. For example if you delete a group, the nodes that belonged"
" to the group will remain in the database. The same happens if you remove "
"nodes from the group -- they will remain in the database but won't belong to"
" the group anymore."
msgstr ""
"默认情况下，任何与组相关的删除操作都不会影响节点本身。例如，如果您删除一个组，属于该组的节点将保留在数据库中。如果从组中删除节点，也会发生同样的情况——这些节点将保留在数据库中，但不再属于组。"

#: ../../source/howto/data.rst:284
msgid ""
"If you also wish to delete the nodes, when deleting the group, use the "
"``--delete-nodes`` option:"
msgstr "如果你也想删除节点，在删除组时，使用 ``--delete-nodes``选项:"

#: ../../source/howto/data.rst:291
msgid "Copy one group into another"
msgstr "将一个组拷贝为其他组"

#: ../../source/howto/data.rst:292
msgid ""
"This operation will copy the nodes of the source group into the destination "
"group. If the destination group does not yet exist, it will be created "
"automatically."
msgstr "此操作将把原来的组的内容复制到目标组中。此外，如果目标组不存在，将自动创建它。"

#: ../../source/howto/data.rst:314
msgid "Examples for using groups"
msgstr "使用组的例子"

#: ../../source/howto/data.rst:316
msgid ""
"In this section, we will provide some practical examples of how one can use "
"Groups to structure and organize the nodes in the database."
msgstr "在本节中，我们将提供一些实际示例，说明如何使用组来组织和结构化数据库中的节点。"

#: ../../source/howto/data.rst:321
msgid "Group structures with a similar property"
msgstr "使用类似属性对晶体结构进行分组"

#: ../../source/howto/data.rst:323
msgid ""
"Suppose, we wanted to group all structures for which the computed bandgap is"
" higher than ``1.0 eV`` in a group named ``promising_structures``, one could"
" use the following approach:"
msgstr ""
"假设，我们想把所有计算出的带隙大于 ``1.0 eV``的结构分组到一个名为``promising_structures``的组中，可以使用以下方法:"

#: ../../source/howto/data.rst:339
msgid ""
"Any node can be included in a group only once and if it is added again, it "
"is simply ignored. This means that add_nodes can be safely called multiple "
"times, and only nodes that weren't already part of the group, will be added."
msgstr "任何节点只能被包含在一个组中一次，如果再次添加，它将被忽略。这意味着可以安全地多次调用add_nodes，并且只添加不属于该组的节点。"

#: ../../source/howto/data.rst:344
msgid "Use grouped data for further processing"
msgstr "使用分组数据进行进一步处理"

#: ../../source/howto/data.rst:346
msgid ""
"Here we demonstrate how to submit calculations for structures that all "
"belong to a group named ``promising_structures``:"
msgstr "这里我们演示了如何提交所有属于名为``promising_structures``组的结构的计算:"

#: ../../source/howto/data.rst:362
msgid ""
"Note, however, that one can also use ``group.nodes`` to access the nodes of "
"the group. To achieve the same result as above one would need to do "
"something as follows:"
msgstr "但是要注意，我们也可以使用 ``group.nodes`` 来访问组中的节点。要达到上述相同的结果，你需要做以下事情:"

#: ../../source/howto/data.rst:378
msgid ""
"To find all structures that have a property ``property_a`` with a value "
"lower than ``1`` and also belong to the ``promising_structures`` group, one "
"could build a query as follows:"
msgstr ""
"要找到属性``property_a`` 值小于 ``1`` 且属于``promising_structures``  组的所有结构，可以构建如下查询:"

#: ../../source/howto/data.rst:388
msgid ""
"The return value of ``qb.all(flat=True)`` would contain all the structures "
"matching the above mentioned criteria."
msgstr "``qb.all(flat=True)`` 的返回值将包含符合上述条件的所有结构。"

#: ../../source/howto/data.rst:393
msgid "Organise groups in hierarchies"
msgstr "按层级关系组织组"

#: ../../source/howto/data.rst:395
msgid "grouppath"
msgstr "组路径"

#: ../../source/howto/data.rst:398
msgid ""
"Groups in AiiDA are inherently \"flat\", in that groups may only contain "
"nodes and not other groups. However it is possible to construct *virtual* "
"group hierarchies based on delimited group labels, using the "
":py:class:`~aiida.tools.groups.paths.GroupPath` utility."
msgstr ""
"AiiDA中的组本质上是“扁平的”，即组可能只包含节点而不包含其他组。但是，使用 "
":py:class:`~aiida.tools.groups.paths.GroupPath` 工具可以基于分隔标签构造 *虚拟* 组层次结构"

#: ../../source/howto/data.rst:401
msgid ""
":py:class:`~aiida.tools.groups.paths.GroupPath` is designed to work in much "
"the same way as Python's :py:class:`pathlib.Path`, whereby paths are denoted"
" by forward slash characters '/' in group labels."
msgstr ""
":py:class:`~aiida.tools.groups.paths.GroupPath`  的工作方式与Python的 "
":py:class:`pathlib.Path` 很相似。因此路径在组标签中由正斜杠 '/' 表示。"

#: ../../source/howto/data.rst:403
msgid "For example say we have the groups:"
msgstr "例如，我们有这样的组:"

#: ../../source/howto/data.rst:415
msgid "We can also access them from the command-line as:"
msgstr "我们也可以从命令行访问它们:"

#: ../../source/howto/data.rst:428
msgid "Or from the python interface:"
msgstr "或使用python接口:"

#: ../../source/howto/data.rst:438
msgid "The ``GroupPath`` can be constructed using indexing or \"divisors\":"
msgstr " ``GroupPath``  可以使用索引或 \"divisors\" 来构造:"

#: ../../source/howto/data.rst:446
msgid ""
"Using the :py:func:`~aiida.tools.groups.paths.GroupPath.browse` attribute, "
"you can also construct the paths as preceding attributes. This is useful in "
"interactive environments, whereby available paths will be shown in the tab-"
"completion:"
msgstr ""
"使用 :py:func:`~aiida.tools.groups.paths.GroupPath.browse`  "
"属性，也可以将路径构造为前面的属性。这在交互式环境中很有用，可用路径将显示在tab补全中:"

#: ../../source/howto/data.rst:454
msgid "To check the existence of a path element:"
msgstr "检查path元素是否存在:"

#: ../../source/howto/data.rst:461
msgid ""
"A group may be \"virtual\", in which case its label does not directly relate"
" to a group, or the group can be retrieved with the "
":py:func:`~aiida.tools.groups.paths.GroupPath.get_group` method:"
msgstr ""
"一个组可以是“虚拟的”，在这种情况下，它的标签并不直接与一个组相关，或者可以通过 "
":py:func:`~aiida.tools.groups.paths.GroupPath.get_group`  方法来检索这个组。"

#: ../../source/howto/data.rst:474
msgid "Groups can be created and destroyed:"
msgstr "组可以创建和销毁:"

#: ../../source/howto/data.rst:486
msgid ""
"To traverse paths, use the "
":py:func:`~aiida.tools.groups.paths.GroupPath.children` attribute - for "
"recursive traversal, use "
":py:func:`~aiida.tools.groups.paths.GroupPath.walk`:"
msgstr ""
"要遍历路径，请使用 :py:func:`~aiida.tools.groups.paths.GroupPath.children` 。对于递归遍历，使用"
" :py:func:`~aiida.tools.groups.paths.GroupPath.walk`:"

#: ../../source/howto/data.rst:497
msgid ""
"You can also traverse directly through the nodes of a path, optionally "
"filtering by node class and any other filters allowed by the "
":ref:`QueryBuilder <how-to:query>`:"
msgstr ""

#: ../../source/howto/data.rst:511
msgid ""
"Finally, you can also specify the ``Group`` subclasses (as discussed above):"
msgstr "最后，你也可以指定  ``Group`` 子类(如上所述):"

#: ../../source/howto/data.rst:522
msgid ""
"A :py:class:`~aiida.tools.groups.paths.GroupPath` instance will only "
"recognise groups of the instantiated ``cls`` type. The default ``cls`` is "
"``aiida.orm.Group``:"
msgstr ""
":py:class:`~aiida.tools.groups.paths.GroupPath` 实例只会识别实例化的 ``cls`` 类型的组。默认 "
"``cls`` 是 ``aiida.orm.Group``:"

#: ../../source/howto/data.rst:538
msgid "Deleting data"
msgstr "删除数据"

#: ../../source/howto/data.rst:540
msgid ""
"By default, every time you run or submit a new calculation, AiiDA will "
"create for you new nodes in the database, and will never replace or delete "
"data. There are cases, however, when it might be useful to delete nodes that"
" are not useful anymore, for instance test runs or incorrect/wrong data and "
"calculations. For this case, AiiDA provides the ``verdi node delete`` "
"command and the :py:func:`~aiida.tools.graph.deletions.delete_nodes` "
"function, to remove the nodes from the provenance graph."
msgstr ""
"默认情况下，每当您运行或提交一个新的计算时，AiiDA将在数据库中为您创建新的节点，并且永远不会替换或删除数据。但是，在某些情况下，删除不再有用的节点可能是有用的，例如测试运行或不正确/错误的数据和计算。对于这种情况，AiiDA提供了"
" ``verdi node delete``  命令和 "
":py:func:`~aiida.tools.graph.deletions.delete_nodes`  函数，从可验证性图删除节点。"

#: ../../source/howto/data.rst:545
msgid ""
"Once the data is deleted, there is no way to recover it (unless you made a "
"backup)."
msgstr "一旦数据被删除，就没有办法恢复它了(除非您做了备份)。"

#: ../../source/howto/data.rst:547
msgid ""
"Critically, note that even if you ask to delete only one node, ``verdi node "
"delete`` will typically delete a number of additional linked nodes, in order"
" to preserve a consistent state of the provenance graph. For instance, if "
"you delete an input of a calculation, AiiDA will delete also the calculation"
" itself (as otherwise you would be effectively changing the inputs to that "
"calculation in the provenance graph). The full set of consistency rules are "
"explained in detail :ref:`here <topics:provenance:consistency>`."
msgstr ""
"重要的是，请注意，即使您要求只删除一个节点， ``verdi node delete``  "
"通常会删除许多附加的链接节点，以保持可验证性图的一致状态。例如，如果您删除一个算例的输入，AiiDA也将删除计算本身(否则您将在可验证性图中有效地更改该计算的输入)。完整的一致性规则将在"
" :ref:`这里 <topics:provenance:consistency>` 详细解释。"

#: ../../source/howto/data.rst:551
msgid ""
"Therefore: always check the output of ``verdi node delete`` to make sure "
"that it is not deleting more than you expect. You can also use the ``--dry-"
"run`` flag of ``verdi node delete`` to see what the command would do without"
" performing any actual operation."
msgstr ""
"因此:总是检查 ``verdi node delete``  的输出，以确保它所删除的内容没有超出您的预期。您还可以使用 ``verdi node "
"delete``  的 ``--dry-run``  标志来查看该命令将做什么，而不执行任何实际操作。"

#: ../../source/howto/data.rst:554
msgid ""
"In addition, there are a number of additional rules that are not mandatory "
"to ensure consistency, but can be toggled by the user. For instance, you can"
" set ``--create-forward`` if, when deleting a calculation, you want to "
"delete also the data it produced (using instead ``--no-create-forward`` will"
" delete the calculation only, keeping the output data: note that this "
"effectively strips out the provenance information of the output data). The "
"full list of these flags is available from the help command ``verdi node "
"delete -h``."
msgstr ""
"此外，还有许多附加规则，它们不是强制性的，但可以由用户进行切换。例如 ，如果在删除计算时，您也想删除它产生的数据，您可以设置 ``--create-"
"forward`` (使用 ``--no-create-forward``  将只删除计算，保留输出数据: "
"注意，这有效地删除了输出数据的来源信息)。这些标志的完整列表可以从帮助命令  ``verdi node delete -h`` 中获得。"

#: ../../source/howto/data.rst:566
msgid "Deleting computers"
msgstr "删除计算机"

#: ../../source/howto/data.rst:567
msgid ""
"To delete a computer, you can use ``verdi computer delete``. This command is"
" mostly useful if, right after creating a computer, you realise that there "
"was an error and you want to remove it. In particular, note that ``verdi "
"computer delete`` will prevent execution if the computer has been already "
"used by at least one node. In this case, you will need to use ``verdi node "
"delete`` to delete first the corresponding nodes."
msgstr ""
"要删除一台计算机，你可以使用 ``verdi computer delete`` "
"。如果在创建计算机之后，您发现出现了一个错误并想要删除它，那么这个命令非常有用。特别要注意的是，如果计算机已经被至少一个节点使用过， ``verdi "
"computer delete`` 将无法执行。在这种情况下，您需要使用 ``verdi node delete``  先删除相应的节点。"

#: ../../source/howto/data.rst:572
msgid "Deleting mutable data"
msgstr "删除可变数据"

#: ../../source/howto/data.rst:573
msgid ""
"A subset of data in AiiDA is mutable also after storing a node, and is used "
"as a convenience for the user to tag/group/comment on data. This data can be"
" safely deleted at any time. This includes, notably:"
msgstr "AiiDA中的数据子集在存储节点之后也是可变的，用户可以方便地对数据进行标记/分组/注释。这些数据可以在任何时候安全地删除。这包括:"

#: ../../source/howto/data.rst:577
msgid ""
"*Node extras*: These can be deleted using :py:attr:`Node.base.extras "
"<aiida.orm.extras.EntityExtras>`."
msgstr ""

#: ../../source/howto/data.rst:578
msgid ""
"*Node comments*: These can be removed using :py:attr:`Node.base.comments "
"<aiida.orm.nodes.comments.NodeComments>`."
msgstr ""

#: ../../source/howto/data.rst:579
msgid ""
"*Groups*: These can be deleted using :py:meth:`Group.objects.delete() "
"<aiida.orm.groups.GroupCollection.delete>`. This command will only delete "
"the group, not the nodes contained in the group."
msgstr ""

#: ../../source/howto/data.rst:583
msgid "Completely deleting an AiiDA profile"
msgstr "完全删除AiiDA的某个配置文件"

#: ../../source/howto/data.rst:584
msgid ""
"If you don't want to selectively delete some nodes, but instead want to "
"delete a whole AiiDA profile altogether, use the ``verdi profile delete`` "
"command. This command will delete both the file repository and the database."
msgstr ""
"如果您不想有选择地删除一些节点，而是想删除整个AiiDA配置文件，请使用 ``verdi profile delete`` "
"命令。这个命令将删除文件存储库和数据库。"

#: ../../source/howto/data.rst:589
msgid ""
"It is not possible to restore a deleted profile unless it was previously "
"backed up!"
msgstr "除非先前备份过，否则不可能恢复已删除的配置文件!"

#: ../../source/howto/data.rst:594
msgid "Transferring data"
msgstr "传输数据"

#: ../../source/howto/data.rst:600
msgid ""
"This feature is still in beta version and its API might change in the near "
"future. It is therefore not recommended that you rely on it for your "
"public/production workflows."
msgstr "这个特性仍然是测试版，它的API在不久的将来可能会改变。因此，不建议您在公共/生产工作流中依赖它。"

#: ../../source/howto/data.rst:603
msgid ""
"Moreover, feedback on its implementation is much appreciated (at "
"https://github.com/aiidateam/aiida-core/issues/4811)."
msgstr ""
"此外，我们非常感谢对其进行反馈(请登录https://github.com/aiidateam/aiida-core/issues/4811)。"

#: ../../source/howto/data.rst:605
msgid ""
"When a calculation job is launched, AiiDA will create a "
":py:class:`~aiida.orm.RemoteData` node that is attached as an output node to"
" the calculation node with the label ``remote_folder``. The input files "
"generated by the ``CalcJob`` plugin are copied to this remote folder and, "
"since the job is executed there as well, the code will produce its output "
"files in that same remote folder also. Since the "
":py:class:`~aiida.orm.RemoteData` node only explicitly stores the filepath "
"on the remote computer, and not its actual contents, it functions more or "
"less like a symbolic link. That means that if the remote folder gets "
"deleted, there will be no way to retrieve its contents. The ``CalcJob`` "
"plugin can for that reason specify some files that should be "
":ref:`retrieved<topics:calculations:usage:calcjobs:file_lists_retrieve>` and"
" stored locally in a :py:class:`~aiida.orm.nodes.data.folder.FolderData` "
"node for safekeeing, which is attached to the calculation node as an output "
"with the label ``retrieved_folder``."
msgstr ""

#: ../../source/howto/data.rst:611
msgid ""
"Although the "
":ref:`retrieve_list<topics:calculations:usage:calcjobs:file_lists_retrieve>`"
" allows to specify what output files are to be retrieved locally, this has "
"to be done *before* the calculation is submitted. In order to provide more "
"flexibility in deciding what files of completed calculation jobs are to be "
"stored locally, even after it has terminated, AiiDA ships with a the "
":py:class:`~aiida.calculations.transfer.TransferCalculation` plugin. This "
"calculation plugin enables to retrieve files from a remote machine and save "
"them in a local :py:class:`~aiida.orm.nodes.data.folder.FolderData`. The "
"specifications of what to copy are provided through an input of type"
msgstr ""
"尽管  :ref:`检索列表 <topics:calculations:usage:calcjobs:file_lists_retrieve>` "
"允许指定在本地检索什么输出文件，但这必须在 *提交计算之前* "
"完成。为了提供更多的灵活性来决定，即使在它终止之后，已完成的计算作业的哪些文件要存储在本地，AiiDA还附带了 "
":py:class:`~aiida.calculations.transfer.TransferCalculation`  "
"插件。这个计算插件可以从远程计算机检索文件，并将它们保存在本地 "
":py:class:`~aiida.orm.nodes.data.folder.FolderData` 中。复制内容的规范是通过类型输入提供的"

#: ../../source/howto/data.rst:625
msgid ""
"The ``'source/path/filename'`` and ``'target/path/filename'`` are both "
"relative paths (to their respective folders). The ``node_keyname`` is a "
"string that will be used when providing the source "
":py:class:`~aiida.orm.RemoteData` node to the calculation. You also need to "
"provide the computer between which the transfer will occur:"
msgstr ""

#: ../../source/howto/data.rst:636
msgid ""
"The variable ``source_node`` here corresponds to the ``RemoteData`` node "
"whose contents need to be retrieved. Finally, you just run or submit the "
"calculation as you would do with any other:"
msgstr ""
"这里的变量 ``source_node`` 对应于需要检索其内容的 ``RemoteData`` "
"节点。最后，你只是运行或提交计算，就像你做任何其他操作:"

#: ../../source/howto/data.rst:644
msgid ""
"You can also use this to copy local files into a new "
":py:class:`~aiida.orm.RemoteData` folder. For this you first have to adapt "
"the instructions to set ``'retrieve_files'`` to ``False`` and use a "
"``'local_files'`` list instead of the ``'symlink_files'``:"
msgstr ""

#: ../../source/howto/data.rst:656
msgid ""
"It is also relevant to note that, in this case, the ``source_node`` will be "
"of type :py:class:`~aiida.orm.nodes.data.folder.FolderData` so you will have"
" to manually select the computer to where you want to copy the files. You "
"can do this by looking at your available computers running ``verdi computer "
"list`` and using the label shown to load it with "
":py:func:`~aiida.orm.load_computer`:"
msgstr ""

#: ../../source/howto/data.rst:663
msgid ""
"Both when uploading or retrieving, you can copy multiple files by appending "
"them to the list of the ``local_files`` or ``symlink_files`` keys in the "
"instructions input, respectively. It is also possible to copy files from any"
" number of nodes by providing several ``source_node`` s, each with a "
"different ``'node_keyname'``. The target node will always be one (so you can"
" *\"gather\"* files in a single call, but not *\"distribute\"* them)."
msgstr ""
"无论是上传还是检索，你都可以复制多个文件，方法是将它们分别添加到指令输入中的  ``local_files`` 或 ``symlink_files``"
"  键的列表中。通过提供多个 ``source_node``，每个``source_node`` 都有一个不同的 "
"``'node_keyname'``。也可以从任意数量的节点复制文件，而目标节点总是一个(因此您可以在单个调用中 *\"收集\"* 文件，但不能 "
"*\"分发”* 文件)。"

#: ../../source/howto/faq.rst:5
msgid "Frequently Asked Questions"
msgstr "常见问题"

#: ../../source/howto/faq.rst:7
msgid ""
"If the problem you are facing is not addressed below, you can send an email "
"to the `mailing list <http://www.aiida.net/mailing-list/>`_, or `open an "
"issue on Github <https://github.com/aiidateam/aiida-"
"core/issues/new/choose>`_ if you think it concerns a bug."
msgstr ""
"如果你所面临的问题在下面没有得到解决，你可以发送电子邮件到 `邮件列表 <http://www.aiida.net/mailing-"
"list/>`_，或者如果你认为它涉及一个bug则可以 `在Github上打开一个issue "
"<https://github.com/aiidateam/aiida-core/issues/new/choose>`_ 。"

#: ../../source/howto/faq.rst:11
msgid ""
"I have updated the version of AiiDA and now it is no longer working. What "
"should I do?"
msgstr "我更新了AiiDA的版本，现在已经不能使用了。我该怎么办?"

#: ../../source/howto/faq.rst:12
msgid ""
"First, make sure that your daemon is not running. You can check this with "
"``verdi daemon status``. If you find that your daemon was actually still "
"running, that is likely the problem, so stop it first using ``verdi daemon "
"stop``. It is very important that each time you want to :ref:`update your "
"AiiDA installation<how-to:installation:update>`, you should *always* first "
"finish all running processes and stop the daemon before doing so. Restart "
"the daemon with ``verdi daemon start``."
msgstr ""

#: ../../source/howto/faq.rst:20
msgid ""
"I get a :py:class:`~aiida.common.exceptions.MissingEntryPointError` or "
":py:class:`~aiida.common.exceptions.MultipleEntryPointError` exception, "
"saying that a particular entry point cannot be found. How can I fix this?"
msgstr ""
"我得到一个 :py:class:`~aiida.common.exceptions.MissingEntryPointError`  或 "
":py:class:`~aiida.common.exceptions.MultipleEntryPointError`  "
"异常，表示无法找到特定的接入点。我该如何解决这个问题?"

#: ../../source/howto/faq.rst:21
msgid ""
"Often this is caused by an outdated entry point cache. This can happen for "
"example when you have updated your AiiDA installation or installed a new "
"plugin using ``pip install``. Make sure to also restart all daemons, to "
"ensure that the changes are picked up by the daemons as well."
msgstr ""

#: ../../source/howto/faq.rst:27
msgid ""
"I have updated the code of a :py:class:`~aiida.engine.WorkChain`, "
":py:class:`~aiida.engine.CalcJob` or whatever other Python code, but the "
"daemon does not seem to pick up the changes?"
msgstr ""

#: ../../source/howto/faq.rst:28
msgid ""
"Each time that you change your code, you should restart the daemon for the "
"changes to take effect. Each daemon worker actually is its own system "
"process with its own Python interpreter instance, and since we don't support"
" automated hot==swapping, the daemon workers will not automatically detect "
"the changes in the code. Simply calling ``verdi daemon restart`` will do the"
" trick."
msgstr ""
"每次更改代码时，都应该重新启动守护进程，使更改生效。每个守护进程实际上是它自己的系统进程，有它自己的Python解释器实例，而且由于我们不支持自动热==交换，守护进程将不会自动检测代码中的更改。你只需调用"
" ``verdi daemon restart`` 就可以了。"

#: ../../source/howto/faq.rst:34
msgid ""
"I have updated the code of a :py:class:`~aiida.engine.WorkChain`, "
":py:class:`~aiida.engine.CalcJob` or whatever other Python code, but my "
"Python shell instance does not seem to pick up the changes?"
msgstr ""

#: ../../source/howto/faq.rst:35
msgid ""
"The ``verdi shell`` is its own Python interpreter and does not automatically"
" detect code changes. Simply reloading your shell will solve the problem."
msgstr "``verdi shell`` 有它自己的Python解释器，不会自动检测代码更改。只需重新加载您的shell就可以解决这个问题。"

#: ../../source/howto/faq.rst:40
msgid ""
"Why are calculation jobs taking very long to run on remote machines even "
"though the actual computation time should be fast?"
msgstr "为什么计算任务在远程机器上运行的时间很长，而实际的计算时间理应很快?"

#: ../../source/howto/faq.rst:41
msgid ""
"First, make sure that the calculation is not actually waiting in the queue "
"of the scheduler, but it is actually running or has already completed. If it"
" then still takes seemingly a lot of time for AiiDA to update your "
"calculations, there are a couple of explanations. First, if you are running "
"many processes, your daemon workers may simply be busy managing other "
"calculations and workflows. If that is not the case, you may be witnessing "
"the effects of the built-in throttling mechanisms of AiiDA's engine. To "
"ensure that the AiiDA daemon does not overload remote computers or their "
"schedulers, there are built-in limits to how often the daemon workers are "
"allowed to open an SSH connection, or poll the scheduler. To determine the "
"minimum transport and job polling interval, use ``verdi computer configure "
"show <COMPUTER>`` and ``computer.get_minimum_job_poll_interval()``, "
"respectively. You can lower these values using:"
msgstr ""
"首先，确保计算没有在远端调度程序的队列中等待，而是实际在运行或已经完成。如果AiiDA更新你的计算似乎仍然需要很多时间，那么可能有这样几种解释。首先，如果您正在运行许多例程，那么您的守护进程可能只是忙于管理其他算例任务和工作流。如果不是这样的话，你可能会看到AiiDA引擎内置节流机制的效果。为了确保AiiDA守护进程不会使远程计算机或其调度器过载，对于允许守护进程工作者打开SSH连接或轮询调度器的频率有内置的限制。要确定最小传输和作业轮询间隔，请分别使用"
" ``verdi computer configure show <COMPUTER>`` 和 "
"``computer.get_minimum_job_poll_interval()`` 。你可以使用以下方法降低这些值:"

#: ../../source/howto/faq.rst:53
msgid "and"
msgstr "以及分别使用"

#: ../../source/howto/faq.rst:59
msgid ""
"respectively. However, be careful, if you make these intervals too short, "
"the daemon workers may spam the remote machine and/or scheduler, which could"
" have adverse effects on the machine itself or can get your account banned, "
"depending on the policy of the remote machine. An additional note of "
"importance is that each interval is guaranteed to be respected per daemon "
"worker individually, but not as a collective. That is to say, if the safe "
"interval is set to 60 seconds, any single worker is guaranteed to open a "
"connection to that machine at most once every minute, however, if you have "
"multiple active daemon workers, the machine may be accessed more than once "
"per minute."
msgstr ""
"但是，要小心，如果这些时间间隔太短，守护进程可能会被认为向远程机器和/或调度器超载发送，这可能对机器本身产生不利影响，或使您的帐户被禁止，这取决于远程机器的策略。另外需要注意的是，每个时间间隔设置保证为被每个守护进程单独地使用，而不是作为总数。也就是说，如果安全间隔设置为60秒，那么任何单个工作者都保证每分钟最多打开到该机器的连接一次，但是，如果您有多个活动的守护进程工作者，那么每分钟可能访问该机器不止一次。"

#: ../../source/howto/faq.rst:67
msgid ""
"Why would a process that runs fine locally raise an exception when submitted"
" to the daemon?"
msgstr "为什么一个在本地正常运行的例程在提交给守护进程时会引发异常?"

#: ../../source/howto/faq.rst:68
msgid ""
"This is almost always caused by an import issue. To determine exactly what "
"might be going wrong, first :ref:`set the loglevel <intro:increase-logging-"
"verbosity>` to ``DEBUG`` by executing the command:"
msgstr "这几乎总是由导入问题引起的。要准确确定可能出错的地方，首先 :ref:`通过执行以下命令将loglevel` 设置为 ``DEBUG``:"

#: ../../source/howto/faq.rst:75
msgid ""
"Then restart the daemon with ``verdi daemon restart`` for the changes to "
"take effect. Run the command ``verdi daemon logshow`` in a separate terminal"
" to see the logging output of the daemon and then submit the problematic "
"calculation or workflow again."
msgstr ""

#: ../../source/howto/faq.rst:78
msgid ""
"If the root cause is indeed due to an import problem, it will probably "
"appear as an ``ImportError`` exception in the daemon log. To solve these "
"issues, make sure that all the Python code that is being run is properly "
"importable, which means that it is part of the `PYTHONPATH "
"<https://docs.python.org/3/using/cmdline.html#envvar-PYTHONPATH>`_. Make "
"sure that the PYTHONPATH is correctly defined automatically when starting "
"your shell, so for example if you are using bash, add it to your ``.bashrc``"
" and completely reset daemon. For example, go to the directory that contains"
" the file where you defined the process and run:"
msgstr ""

#: ../../source/howto/faq.rst:92
msgid "Why is caching not enabled by default?"
msgstr "为什么缓存默认不启用?"

#: ../../source/howto/faq.rst:94
msgid ""
"Caching is designed to work in an unobtrusive way and simply save time and "
"valuable computational resources. However, this design is a double-egded "
"sword, in that a user that might not be aware of this functionality, can be "
"caught off guard by the results of their calculations."
msgstr ""
"缓存被设计为以一种不引人注目的方式工作，并只是为了节省时间和宝贵的计算资源。然而，这种设计是一把双刃剑，因为用户可能没有意识到这种功能，导致计算结果让他们措手不及。"

#: ../../source/howto/faq.rst:97
msgid ""
"The caching mechanism comes with some limitations and caveats that are "
"important to understand. Refer to the "
":ref:`topics:provenance:caching:limitations` section for more details."
msgstr ""
"缓存机制有一些限制和注意事项，理解这些限制和注意事项很重要。有关更多细节，请参阅 "
":ref:`topics:provenance:caching:limitations`  一节。"

#: ../../source/howto/index.rst:3
msgid "How-To Guides"
msgstr "操作指南"

#: ../../source/howto/installation.rst:5
msgid "How to manage your installation"
msgstr "如何管理您的安装"

#: ../../source/howto/installation.rst:11
msgid "Managing profiles"
msgstr "管理配置文件"

#: ../../source/howto/installation.rst:14
msgid "Creating profiles"
msgstr "创建配置文件"

#: ../../source/howto/installation.rst:15
msgid ""
"Each AiiDA installation can have multiple profiles, each of which can have "
"its own individual database and file repository to store the contents of the"
" :ref:`provenance graph<topics:provenance:concepts>`. Profiles allow you to "
"run multiple projects completely independently from one another with just a "
"single AiiDA installation and at least one profile is required to run AiiDA."
" A new profile can be created using :ref:`verdi "
"quicksetup<reference:command-line:verdi-quicksetup>` or :ref:`verdi "
"setup<reference:command-line:verdi-setup>`, which works similar to the "
"former but gives more control to the user."
msgstr ""
"每个AiiDA安装可以有多个配置文件，每个配置文件都可以有自己的单独数据库和文件存储库来存储 "
":ref:`可验证性图<topics:provenance:concepts>` "
"的内容。配置文件允许您在单个AiiDA安装的情况下完全独立地运行多个项目，并且至少需要一个配置文件才能运行AiiDA。可以使用  :ref:`verdi"
" quicksetup<reference:command-line:verdi-quicksetup>` or :ref:`verdi "
"setup<reference:command-line:verdi-setup>`, "
"创建一个新的配置文件，后者工作原理类似于前者，但给用户更多的配置选择。"

#: ../../source/howto/installation.rst:20
msgid "Listing profiles"
msgstr "列出配置文件"

#: ../../source/howto/installation.rst:21
msgid ""
"The :ref:`verdi profile<reference:command-line:verdi-profile>` command line "
"interface provides various commands to manage the profiles of an AiiDA "
"installation. To list the currently configured profiles, use ``verdi profile"
" list``:"
msgstr ""
" :ref:`verdi profile<reference:command-line:verdi-profile>` "
"配置文件'命令行界面提供了各种命令来管理AiiDA安装的配置文件。要列出当前配置的配置文件，请使用 ``verdi profile list``:"

#: ../../source/howto/installation.rst:30
msgid ""
"In this particular example, there are two configured profiles, ``project-"
"one`` and ``project-two``. The first one is highlighted and marked with a "
"``*`` symbol, meaning it is the default profile. A profile being the default"
" means simply that any ``verdi`` command will always be executed for that "
"profile. You can :ref:`change the profile on a per-call "
"basis<topics:cli:profile>` with the ``--p/--profile`` option. To change the "
"default profile use ``verdi profile setdefault PROFILE``."
msgstr ""
"在这个特定的例子中，有两个配置文件， ``project-one`` 和  ``project-two`` 。第一个被高亮显示，用  ``*``  "
"符号标记，这意味着它是默认配置文件。配置文件是默认的，这意味着任何 ``verdi`` 命令都会在这个配置下执行。你可以使用 "
"``--p/--profile`` 选项 :ref:`在每次调用的基础上改变配置文件<topics:cli:profile>` "
"。要更改默认配置文件，请使用 ``verdi profile setdefault PROFILE`` 。"

#: ../../source/howto/installation.rst:37
msgid "Showing profiles"
msgstr "显示配置文件"

#: ../../source/howto/installation.rst:38
msgid ""
"Each profile defines various parameters, such as the location of the file "
"repository on the file system and the connection parameters for the "
"database. To display these parameters, use ``verdi profile show``:"
msgstr ""
"每个配置文件定义多个参数，例如文件存储库在文件系统上的位置和数据库的连接参数。要显示这些参数，使用 ``verdi profile show``:"

#: ../../source/howto/installation.rst:66
msgid ""
"By default, the parameters of the default profile are shown, but one can "
"pass the profile name of another, e.g., ``verdi profile show project-two`` "
"to change that."
msgstr ""
"默认情况下，会显示默认配置文件的参数，但是可以传递另一个配置文件的名称，例如 ``verdi profile show project-two``  "
"来更改。"

#: ../../source/howto/installation.rst:69
msgid "Deleting profiles"
msgstr "删除配置文件"

#: ../../source/howto/installation.rst:70
msgid ""
"A profile can be deleted using the ``verdi profile delete`` command. By "
"default, deleting a profile will also delete its file repository and the "
"database. This behavior can be changed using the ``--skip-repository`` and "
"``--skip-db`` options."
msgstr ""
"可以使用  ``verdi profile delete``  命令删除配置文件。默认情况下，删除概要文件也将删除其文件存储库和数据库。这种行为可以使用"
" ``--skip-repository`` 和 ``--skip-db``  选项来改变。"

#: ../../source/howto/installation.rst:76
msgid ""
"In order to delete the database, the system user needs to have the required "
"rights, which is not always guaranteed depending on the system. In such "
"cases, the database deletion may fail and the user will have to perform the "
"deletion manually through PostgreSQL."
msgstr ""
"为了删除数据库，系统用户需要拥有所需的权限，但这取决于系统。在这种权限限制的情况下，删除数据库可能会失败，用户将不得不通过PostgreSQL手动执行删除。"

#: ../../source/howto/installation.rst:83
msgid "Configuring your installation"
msgstr "配置您的安装"

#: ../../source/howto/installation.rst:88
msgid "Activating tab-completion"
msgstr "开启tab补齐"

#: ../../source/howto/installation.rst:89
msgid ""
"The ``verdi`` command line interface has many commands and parameters, which"
" can be tab-completed to simplify its use. To enable tab-completion, the "
"following shell command should be executed (depending on the shell you use):"
msgstr ""

#: ../../source/howto/installation.rst:92
msgid ""
"Enable tab-completion for ``verdi`` one of the following supported shells"
msgstr ""

#: ../../source/howto/installation.rst:0
msgid "bash"
msgstr ""

#: ../../source/howto/installation.rst:0
msgid "zsh"
msgstr ""

#: ../../source/howto/installation.rst:0
msgid "fish"
msgstr ""

#: ../../source/howto/installation.rst:115
msgid ""
"Place this command in your shell or virtual environment activation script to"
" automatically enable tab completion when opening a new shell or activating "
"an environment. This file is shell specific, but likely one of the "
"following:"
msgstr ""
"将此命令放在shell或虚拟环境激活脚本中，以便在打开新shell或激活环境时自动启用tab补全。这个文件是对应特定shell的，可能是以下之一:"

#: ../../source/howto/installation.rst:118
msgid ""
"the startup file of your shell (``.bashrc``, ``.zsh``, ...), if aiida is "
"installed system-wide"
msgstr "如果aiida被安装在系统范围，你的shell启动文件应该是(``.bashrc``, ``.zsh``, ...)之一"

#: ../../source/howto/installation.rst:119
msgid ""
"the `activators "
"<https://virtualenv.pypa.io/en/latest/user_guide.html#activators>`_ of your "
"virtual environment"
msgstr ""

#: ../../source/howto/installation.rst:120
msgid ""
"a `startup file <https://conda.io/projects/conda/en/latest/user-"
"guide/tasks/manage-environments.html#saving-environment-variables>`_ for "
"your conda environment"
msgstr ""

#: ../../source/howto/installation.rst:125
msgid ""
"After you have added the line to the start up script, make sure to restart "
"the terminal or source the script for the changes to take effect."
msgstr "在将这一行添加到启动脚本之后，请确保重新启动终端或源脚本，使更改生效。"

#: ../../source/howto/installation.rst:131
msgid "Configuring profile options"
msgstr "配置文件选项"

#: ../../source/howto/installation.rst:133
msgid ""
"AiiDA provides various configurational options for profiles, which can be "
"controlled with the :ref:`verdi config<reference:command-line:verdi-config>`"
" command."
msgstr ""
"AiiDA为配置文件提供了各种配置选项，可以用 :ref:`verdi config <reference:command-line:verdi-"
"config>`  命令控制。"

#: ../../source/howto/installation.rst:135
msgid "To view all configuration options set for the current profile:"
msgstr "查看当前配置文件设置的所有配置选项。"

#: ../../source/howto/installation.rst:168
msgid ""
"Configuration option values are taken, in order of priority, from either the"
" profile specific setting, the global setting (applies to all profiles), or "
"the default value."
msgstr "配置选项值按照优先级的顺序从特定配置文件设置、全局设置(适用于所有配置文件)或默认值中获取。"

#: ../../source/howto/installation.rst:170
msgid "You can also filter by a prefix:"
msgstr "你也可以通过前缀进行过滤:"

#: ../../source/howto/installation.rst:180
msgid ""
"To show the full information for a configuration option or get its current "
"value:"
msgstr "要显示配置选项的完整信息或获取其当前值:"

#: ../../source/howto/installation.rst:197
msgid "You can also retrieve the value *via* the API:"
msgstr "你也可以通过API获取值:"

#: ../../source/howto/installation.rst:205
msgid "To set a value, at the profile or global level:"
msgstr "要在配置文件或全局级别设置一个值:"

#: ../../source/howto/installation.rst:228
msgid ""
"By default any option set through ``verdi config`` will be applied to the "
"current default profile. To change the profile you can use the :ref:`profile"
" option<topics:cli:profile>`."
msgstr ""
"默认情况下，通过  ``verdi config`` 设置的任何选项将应用于当前的默认配置文件。要更改配置文件，可以使用 :ref:`配置选项 "
"<topics:cli:profile>` 。"

#: ../../source/howto/installation.rst:231
msgid "Similarly to unset a value:"
msgstr "类似于取消设置的值:"

#: ../../source/howto/installation.rst:254
msgid ""
"Changes that affect the daemon (e.g. ``logging.aiida_loglevel``) will only "
"take affect after restarting the daemon."
msgstr "影响守护进程的更改(例如，``logging.aiida_loglevel`` )只会在重新启动守护进程后生效。"

#: ../../source/howto/installation.rst:256
msgid ":ref:`How-to configure caching <how-to:run-codes:caching>`"
msgstr ":ref:`如何配置缓存 <how-to:run-codes:caching>`"

#: ../../source/howto/installation.rst:262
msgid "Isolating multiple instances"
msgstr "分离多个实例"

#: ../../source/howto/installation.rst:263
msgid ""
"An AiiDA instance is defined as the installed source code plus the "
"configuration folder that stores the configuration files with all the "
"configured profiles. It is possible to run multiple AiiDA instances on a "
"single machine, simply by isolating the code and configuration in a virtual "
"environment."
msgstr ""
"AiiDA实例定义为已安装的源代码加上存储配置文件和所有配置文件的配置文件夹。只需在虚拟环境中分离代码和配置，就可以在一台机器上运行多个AiiDA实例。"

#: ../../source/howto/installation.rst:266
msgid ""
"To isolate the code, make sure to install AiiDA into a virtual environment, "
"e.g., with conda or venv, as described :ref:`here "
"<intro:get_started:setup>`. Whenever you activate this particular "
"environment, you will be running the particular version of AiiDA (and all "
"the plugins) that you installed specifically for it."
msgstr ""
"要分离代码，请确保将AiiDA安装到虚拟环境中，例如，使用conda或venv，如 :ref:`这里 "
"<intro:get_started:setup>` 所述。无论何时激活这个特定环境，都将运行专门为它安装的特定版本的AiiDA(以及所有插件)。"

#: ../../source/howto/installation.rst:269
msgid ""
"This is separate from the configuration of AiiDA, which is stored in the "
"configuration directory which is always named ``.aiida`` and by default is "
"stored in the home directory. Therefore, the default path of the "
"configuration directory is ``~/.aiida``. By default, each AiiDA instance "
"(each installation) will store associated profiles in this folder. A best "
"practice is to always separate the profiles together with the code to which "
"they belong. The typical approach is to place the configuration folder in "
"the virtual environment itself and have it automatically selected whenever "
"the environment is activated."
msgstr ""
"这与AiiDA的配置是分开的，配置存储在配置文件夹中，该目录总是默认命名为 ``.aiida`` "
"，并在默认情况下存储在用户家目录中。因此，配置目录的默认路径是 ``~/.aiida`` "
"。默认情况下，每个AiiDA实例(每个安装)将在这个文件夹中存储相关的配置文件。最佳实践是始终将概要文件和它们所属的代码分开。典型的方法是将配置文件夹放在虚拟环境本身中，并在激活环境时自动选择它。"

#: ../../source/howto/installation.rst:275
msgid ""
"The location of the AiiDA configuration folder can be controlled with the "
"``AIIDA_PATH`` environment variable. This allows us to change the "
"configuration folder automatically, by adding the following lines to the "
"activation script of a virtual environment. For example, if the path of your"
" virtual environment is ``/home/user/.virtualenvs/aiida``, add the following"
" line:"
msgstr ""
"AiiDA配置文件夹的位置可以用  ``AIIDA_PATH`` "
"环境变量控制。通过向虚拟环境的激活脚本添加以下行，我们可以自动更改配置文件夹。例如，如果虚拟环境的路径是 "
"``/home/user/.virtualenvs/aiida`` ，则添加以下行:"

#: ../../source/howto/installation.rst:283
msgid ""
"Make sure to reactivate the virtual environment, if it was already active, "
"for the changes to take effect."
msgstr "如果虚拟环境已经处于活动状态，请确保重新激活它，以便使更改生效。"

#: ../../source/howto/installation.rst:287
msgid ""
"For ``conda``, create a directory structure ``etc/conda/activate.d`` in the "
"root folder of your conda environment (e.g. "
"``/home/user/miniconda/envs/aiida``), and place a file ``aiida-init.sh`` in "
"that folder which exports the ``AIIDA_PATH``."
msgstr ""
"对于 ``conda``，创建目录结构 ``etc/conda/activate.d`` 。在conda环境的根目录下(例如: "
"``/home/user/miniconda/envs/aiida`` )，并将 ``aiida-init.sh`` 文件放在导出 "
"``AIIDA_PATH`` 的文件夹中。"

#: ../../source/howto/installation.rst:289
msgid ""
"You can test that everything works by first echoing the environment variable"
" with ``echo $AIIDA_PATH`` to confirm it prints the correct path. Finally, "
"you can check that AiiDA know also properly realizes the new location for "
"the configuration folder by calling ``verdi profile list``. This should "
"display the current location of the configuration directory:"
msgstr ""
"您可以先用  ``echo $AIIDA_PATH``  显示环境变量，以确认它打印的路径是正确的，再测试一切是否正常。最后，你可以通过调用 "
"``verdi profile list`` 来检查AiiDA是否也正确地实现了配置文件夹的新位置。这将显示配置目录的当前位置:"

#: ../../source/howto/installation.rst:298
msgid ""
"The second line you will only see if you haven't yet setup a profile for "
"this AiiDA instance. For information on setting up a profile, refer to "
":ref:`creating profiles<how-to:installation:profile>`."
msgstr ""
"如果您还没有为这个AiiDA实例设置配置文件，那么您将看到第二行。有关设置配置文件的信息，请参阅 :ref:`创建配置文件 <how-"
"to:installation:profile>`。"

#: ../../source/howto/installation.rst:301
msgid ""
"Besides a single path, the value of ``AIIDA_PATH`` can also be a colon-"
"separated list of paths. AiiDA will go through each of the paths and check "
"whether they contain a configuration directory, i.e., a folder with the name"
" ``.aiida``. The first configuration directory that is encountered will be "
"used as the configuration directory. If no configuration directory is found,"
" one will be created in the last path that was considered. For example, the "
"directory structure in your home folder ``~/`` might look like this::"
msgstr ""
"除了单个路径， ``AIIDA_PATH``  "
"的值也可以是一个冒号分隔的路径列表。AiiDA将遍历每个路径，并检查它们是否包含一个配置文件夹，即一个名为  ``.aiida`` "
"的文件夹。遇到的第一个配置目录将用作配置目录。如果没有找到配置目录，将在考虑的最后一个路径中创建一个。例如，你的主文件夹  ``~/`` "
"中的目录结构可能是这样的::"

#: ../../source/howto/installation.rst:313
msgid ""
"If you leave the ``AIIDA_PATH`` variable unset, the default location "
"``~/.aiida`` will be used. However, if you set:"
msgstr "如果未设置 ``AIIDA_PATH`` 变量的值，将会使用默认路径 ``~/.aiida`` 。但如果使用如下设置 :"

#: ../../source/howto/installation.rst:320
msgid "the configuration directory ``~/project_a/.aiida`` will be used."
msgstr "则就会使用 ``~/project_a/.aiida`` 作为配置路径"

#: ../../source/howto/installation.rst:324
msgid ""
"If there was no ``.aiida`` directory in ``~/project_a``, AiiDA would have "
"created it for you, so make sure to set the ``AIIDA_PATH`` correctly."
msgstr ""
"如果 ``~/project_a`` 中没有 ``.aiida`` 目录，那么AiiDA将会创建这个文件夹。因此需要特别注意是否正确设置了 "
"``AIIDA_PATH`` 环境变量。"

#: ../../source/howto/installation.rst:330
msgid "Daemon as a service"
msgstr "将守护进程作为系统服务"

#: ../../source/howto/installation.rst:332
msgid ""
"The daemon can be set up as a system service, such that it automatically "
"starts at system startup. How to do this, is operating system specific. For "
"Ubuntu, here is `a template for the service file <https://github.com/marvel-"
"nccr/ansible-role-"
"aiida/blob/c709088dff74d1e1ae4d8379e740aba35fb2ef97/templates/aiida-"
"daemon%40.service>`_ and `ansible instructions to install the service "
"<https://github.com/marvel-nccr/ansible-role-"
"aiida/blob/c709088dff74d1e1ae4d8379e740aba35fb2ef97/tasks/aiida-"
"daemon.yml>`_."
msgstr ""
"可以将守护进程设置为系统服务，以便在系统启动时自动启动。如何做到这一点，取决于操作系统。对于Ubuntu，请参考 "
"`服务文件的模板<https://github.com/marvel-nccr/ansible-role-"
"aiida/blob/c709088dff74d1e1ae4d8379e740aba35fb2ef97/templates/aiida-"
"daemon%40.service>`_ 和 `安装服务的说明 <https://github.com/marvel-nccr/ansible-"
"role-aiida/blob/c709088dff74d1e1ae4d8379e740aba35fb2ef97/tasks/aiida-"
"daemon.yml>`_ 。"

#: ../../source/howto/installation.rst:340
msgid "Tuning performance"
msgstr "性能提升"

#: ../../source/howto/installation.rst:342
msgid ""
"AiiDA supports running hundreds of thousands of calculations and graphs with"
" millions of nodes. However, optimal performance at that scale can require "
"tweaking the AiiDA configuration to balance the CPU and disk load."
msgstr ""

#: ../../source/howto/installation.rst:345
msgid ""
"Below, we share a few practical tips for assessing and tuning AiiDA "
"performance. Further in-depth information is available in the dedicated "
":ref:`topic on performance<topics:performance>`."
msgstr ""

#: ../../source/howto/installation.rst:0
msgid "Benchmark workflow engine performance"
msgstr ""

#: ../../source/howto/installation.rst:350
msgid ""
"Start the AiiDA daemon with a single worker, download the "
":download:`benchmark script <include/scripts/performance_benchmark_base.py>`"
" :fa:`download`, and run it in your AiiDA environment."
msgstr ""

#: ../../source/howto/installation.rst:368
msgid ""
"The output above was generated with a *single* daemon worker on one core of "
"an AMD Ryzen 5 3600 6-Core processor (3.6 GHz, 4.2 GHz turbo boost) using "
"AiiDA v1.6.9, and RabbitMQ and PostgreSQL running on the same machine. Here,"
" 100 ``ArithmeticAddCalculation`` processes completed in ~47s (including the"
" time needed to submit them), corresponding to an average of half a second "
"per process."
msgstr ""

#: ../../source/howto/installation.rst:371
msgid ""
"If you observe a significantly higher runtime, you may want to check whether"
" any relevant component (CPU, disk, postgresql, rabbitmq) is congested."
msgstr ""

#: ../../source/howto/installation.rst:0
msgid "Increase the number of daemon workers"
msgstr ""

#: ../../source/howto/installation.rst:375
msgid ""
"By default, the AiiDA daemon only uses a single worker, i.e. a single "
"operating system process. If ``verdi daemon status`` shows the daemon worker"
" constantly at high CPU usage, you can use ``verdi daemon incr X`` to add "
"``X`` parallel daemon workers."
msgstr ""

#: ../../source/howto/installation.rst:378
msgid ""
"Keep in mind that other processes need to run on your computer (e.g. "
"rabbitmq, the PostgreSQL database, ...), i.e. it's a good idea to stop "
"increasing the number of workers before you reach the number of cores of "
"your CPU."
msgstr ""

#: ../../source/howto/installation.rst:380
msgid "To make the change permanent, set ::"
msgstr ""

#: ../../source/howto/installation.rst:0
msgid "Increase the number of daemon worker slots"
msgstr ""

#: ../../source/howto/installation.rst:387
msgid ""
"Each daemon worker accepts only a limited number of tasks at a time. If "
"``verdi daemon status`` constantly warns about a high percentage of the "
"available daemon worker slots being used, you can increase the number of "
"tasks handled by each daemon worker (thus increasing the workload per "
"worker). Increasing it to 1000 should typically work."
msgstr ""

#: ../../source/howto/installation.rst:391
msgid "Set the corresponding config variable and restart the daemon ::"
msgstr ""

#: ../../source/howto/installation.rst:0
msgid "Prevent your operating system from indexing the file repository."
msgstr ""

#: ../../source/howto/installation.rst:398
msgid ""
"Many Linux distributions include the ``locate`` command to quickly find "
"files and folders, and run a daily cron job ``updatedb.mlocate`` to create "
"the corresponding index. A large file repository can take a long time to "
"index, up to the point where the hard drive is constantly indexing."
msgstr ""
"许多Linux发行版都包含 ``locate`` 命令来快速查找文件和文件夹，并运行一个日常的cron作业 ``updatedb.mlocate`` "
"来创建相应的索引。一个大型文件存储库可能需要很长时间才能建立索引，直到硬盘驱动器建立稳定的索引为止。"

#: ../../source/howto/installation.rst:401
msgid ""
"In order to exclude the repository folder from indexing, add its path to the"
" ``PRUNEPATH`` variable in the ``/etc/updatedb.conf`` configuration file "
"(use ``sudo``)."
msgstr ""
"为了排除存储库文件夹的索引，将其路径添加到配置文件 ``/etc/updatedb.conf`` 中的 ``PRUNEPATH`` 变量中(使用 "
"``sudo`` )。"

#: ../../source/howto/installation.rst:0
msgid ""
"Move the Postgresql database to a fast disk (SSD), ideally on a large "
"partition."
msgstr ""

#: ../../source/howto/installation.rst:405
msgid ""
"Stop the AiiDA daemon and :ref:`back up your database <how-"
"to:installation:backup>`."
msgstr ""

#: ../../source/howto/installation.rst:407
msgid ""
"Find the data directory of your postgres installation (something like "
"``/var/lib/postgresql/9.6/main``, ``/scratch/postgres/9.6/main``, ...)."
msgstr ""
"找到postgres安装的数据目录(比如  ``/var/lib/postgresql/9.6/main``, "
"``/scratch/postgres/9.6/main``, …)"

#: ../../source/howto/installation.rst:409
msgid ""
"The best way is to become the postgres UNIX user and enter the postgres "
"shell::"
msgstr "最好的方法是成为postgres UNIX用户，并进入postgres shell::"

#: ../../source/howto/installation.rst:415
msgid ""
"If you are unable to enter the postgres shell, try looking for the "
"``data_directory`` variable in a file "
"``/etc/postgresql/9.6/main/postgresql.conf`` or similar."
msgstr ""
"如果你无法进入postgres shell，试着在 ``/etc/postgresql/9.6/main/postgresql.conf`` "
"或类似文件中寻找 ``data_directory`` 变量。"

#: ../../source/howto/installation.rst:417
msgid "Stop the postgres database service::"
msgstr "停止postgres数据库服务::"

#: ../../source/howto/installation.rst:421
msgid ""
"Copy all files and folders from the postgres ``data_directory`` to the new "
"location::"
msgstr "从postgres ``data_directory`` 中复制所有文件和文件夹到新的位置::"

#: ../../source/howto/installation.rst:443
msgid ""
"Point the ``data_directory`` variable in your postgres configuration file "
"(e.g. ``/etc/postgresql/9.6/main/postgresql.conf``) to the new directory."
msgstr ""
"将 ``data_directory`` 变量指向新设置的postgres配置文件 (如 "
"``/etc/postgresql/9.6/main/postgresql.conf`` )。"

#: ../../source/howto/installation.rst:445
msgid "Restart the database daemon::"
msgstr "重启数据库守护进程::"

#: ../../source/howto/installation.rst:449
msgid "Finally, check that the data directory has indeed changed::"
msgstr "最后，检查数据目录是否确实改变了::"

#: ../../source/howto/installation.rst:455
msgid ""
"and try a simple AiiDA query with the new database. If everything went fine,"
" you can delete the old database location."
msgstr "并尝试使用新数据库进行简单的AiiDA查询。如果一切正常，您可以删除旧的数据库位置。"

#: ../../source/howto/installation.rst:458
msgid ""
"If you're still encountering performance issues, the following tips can help"
" with pinpointing performance bottlenecks."
msgstr ""

#: ../../source/howto/installation.rst:0
msgid "Analyze the RabbitMQ message rate"
msgstr ""

#: ../../source/howto/installation.rst:462
msgid ""
"If you're observing slow performance of the AiiDA engine, the `RabbitMQ "
"management plugin <https://www.rabbitmq.com/management.html>`_ provides an "
"intuitive dashboard that lets you monitor the message rate and check on what"
" the AiiDA engine is up to."
msgstr ""

#: ../../source/howto/installation.rst:464
msgid "Enable the management plugin via something like::"
msgstr ""

#: ../../source/howto/installation.rst:468
msgid ""
"Then, navigate to http://localhost:15672/ and log in with "
"``guest``/``guest``."
msgstr ""

#: ../../source/howto/installation.rst:474
msgid "Updating your installation"
msgstr "更新您的安装"

#: ../../source/howto/installation.rst:476
msgid ""
"Whenever updating your AiiDA installation, make sure you follow these "
"instructions **very carefully**, even when merely upgrading the patch "
"version! Failing to do so, may leave your installation in a broken state, or"
" worse may even damage your data, potentially irreparably."
msgstr ""
"无论何时更新您的AiiDA安装，请确保您 **非常仔细地遵循这些说明** "
"，即使只是升级补丁版本!如果不这样做，可能会使您的安装处于损坏状态，或者更糟的是，可能会损坏您的数据，并无法修复。"

#: ../../source/howto/installation.rst:479
msgid "Activate the Python environment where AiiDA is installed."
msgstr "激活安装AiiDA的Python环境。"

#: ../../source/howto/installation.rst:480
msgid "Finish all running processes."
msgstr ""

#: ../../source/howto/installation.rst:481
msgid ""
"All finished processes will be automatically migrated, but it is not "
"possible to resume unfinished processes."
msgstr ""

#: ../../source/howto/installation.rst:482
msgid "Stop the daemon using ``verdi daemon stop``."
msgstr "使用 ``verdi daemon Stop`` 停止守护进程。"

#: ../../source/howto/installation.rst:483
msgid ""
":ref:`Create a backup of your database and repository<how-"
"to:installation:backup>`."
msgstr ":ref:`创建您的数据库和存储库的备份 <how-to:installation:backup>`。"

#: ../../source/howto/installation.rst:487
msgid ""
"Once you have migrated your database, you can no longer go back to an older "
"version of ``aiida-core`` (unless you restore your database and repository "
"from a backup)."
msgstr "一旦您迁移了您的数据库，您就不能再回到 ``aida -core`` 的旧版本(除非您从备份中恢复数据库和存储库)。"

#: ../../source/howto/installation.rst:489
msgid "Update your ``aiida-core`` installation."
msgstr "更新您的 ``aida -core`` 安装。"

#: ../../source/howto/installation.rst:491
msgid ""
"If you have installed AiiDA through ``conda`` simply run: ``conda update "
"aiida-core``."
msgstr "如果你已经通过 ``conda`` 安装了AiiDA，只需运行: ``conda update aiida-core`` 。"

#: ../../source/howto/installation.rst:492
msgid ""
"If you have installed AiiDA through ``pip`` simply run: ``pip install "
"--upgrade aiida-core``."
msgstr "如果您已经通过 ``pip`` 安装了AiiDA，只需运行: ``pip install --upgrade aiida-core`` 。"

#: ../../source/howto/installation.rst:493
msgid ""
"If you have installed from the git repository using ``pip install -e .``, "
"first delete all the ``.pyc`` files (``find . -name \"*.pyc\" -delete``) "
"before updating your branch with ``git pull``."
msgstr ""
"如果通过git仓库 ``pip install -e .`` 安装的话，那么在升级分支之前，首先删除所有的 ``.pyc`` 文件（ ``find . "
"-name \"*.pyc\" -delete`` ）。"

#: ../../source/howto/installation.rst:496
msgid ""
"Migrate your database with ``verdi -p <profile_name> storage migrate``."
msgstr ""

#: ../../source/howto/installation.rst:496
msgid ""
"Depending on the size of your database and the number of migrations to "
"perform, data migration can take time, so please be patient."
msgstr ""

#: ../../source/howto/installation.rst:498
msgid ""
"After the database migration finishes, you will be able to continue working "
"with your existing data."
msgstr "数据库迁移完成后，您将能够继续处理现有数据。"

#: ../../source/howto/installation.rst:501
msgid ""
"If the update involved a change in the major version number of ``aiida-"
"core``, expect backwards incompatible changes and check whether you also "
"need to update installed plugin packages."
msgstr "如果更新涉及到 ``aida -core`` 的主版本号的变化，并知晓有向后不兼容的变化，还需要检查你是否也需要更新安装的插件包。"

#: ../../source/howto/installation.rst:504
msgid "Updating from 0.x.* to 1.*"
msgstr "从0. x.* 更新到 1.*"

#: ../../source/howto/installation.rst:505
msgid ""
"`Additional instructions on how to migrate from 0.12.x versions "
"<https://aiida.readthedocs.io/projects/aiida-"
"core/en/v1.2.1/install/updating_installation.html#updating-"
"from-0-12-to-1>`_."
msgstr ""
"`关于如何从0.12.x迁移的附加说明 <https://aiida.readthedocs.io/projects/aiida-"
"core/en/v1.2.1/install/updating_installation.html#updating-"
"from-0-12-to-1>`_。"

#: ../../source/howto/installation.rst:506
msgid ""
"`Additional instructions on how to migrate from versions 0.4 -- 0.11 "
"<https://aiida.readthedocs.io/projects/aiida-"
"core/en/v1.2.1/install/updating_installation.html#older-versions>`_."
msgstr ""
"`关于如何从0.4 - 0.11版本迁移的附加说明 <https://aiida.readthedocs.io/projects/aiida-"
"core/en/v1.2.1/install/updating_installation.html#older-versions>``_。"

#: ../../source/howto/installation.rst:507
msgid ""
"For a list of breaking changes between the 0.x and the 1.x series of AiiDA, "
"`see here <https://aiida.readthedocs.io/projects/aiida-"
"core/en/v1.2.1/install/updating_installation.html#breaking-changes-"
"from-0-12-to-1>`_."
msgstr ""
"要获取0.x到1.x之间的中断更改列表， '看这里<https://aiida.readthedocs.io/projects/aiida-"
"core/en/v1.2.1/install/updating_installation.html#breaking-changes-"
"from-0-12-to-1>' _。"

#: ../../source/howto/installation.rst:510
msgid "Updating from 1.* to 2.*"
msgstr ""

#: ../../source/howto/installation.rst:512
msgid "See the :doc:`../reference/_changelog` for a list of breaking changes."
msgstr ""

#: ../../source/howto/installation.rst:517
msgid "Backing up your installation"
msgstr "备份您的安装"

#: ../../source/howto/installation.rst:519
msgid ""
"A full backup of an AiiDA instance and AiiDA managed data requires a backup "
"of:"
msgstr "AiiDA实例和AiiDA管理数据的完整备份需要备份以下东西:"

#: ../../source/howto/installation.rst:521
msgid ""
"the AiiDA configuration folder, which is named ``.aiida``. The location of "
"the folder is shown in the output of ``verdi status``. This folder contains,"
" among other things, the ``config.json`` configuration file and log files."
msgstr ""

#: ../../source/howto/installation.rst:525
msgid ""
"the data stored for each profile. Where the data is stored, depends on the "
"storage backend used by each profile."
msgstr ""

#: ../../source/howto/installation.rst:528
#: ../../source/howto/installation.rst:586
msgid ""
"The panels below provide instructions for storage backends provided by "
"``aiida-core``. To determine what storage backend a profile uses, call "
"``verdi profile show``."
msgstr ""

#: ../../source/howto/installation.rst:531
msgid ""
"Before creating a backup, it is recommended to run ``verdi storage "
"maintain``. This will optimize the storage which can significantly reduce "
"the time required to create the backup. For optimal results, run ``verdi "
"storage maintain --full``. Note that this requires the profile to not be in "
"use by any other process."
msgstr ""

#: ../../source/howto/installation.rst:0 ../../source/howto/installation.rst:0
msgid "psql_dos"
msgstr ""

#: ../../source/howto/installation.rst:540
msgid ""
"The ``psql_dos`` storage backend is the default backend for AiiDA. It stores"
" its data in a PostgreSQL database and a file repository on the local "
"filesystem. To fully backup the data stored for a profile, you should backup"
" the associated database and file repository."
msgstr ""

#: ../../source/howto/installation.rst:544
#: ../../source/howto/installation.rst:595
msgid "**PostgreSQL database**"
msgstr ""

#: ../../source/howto/installation.rst:546
msgid ""
"To export the entire database, we recommend to use the `pg_dump "
"<https://www.postgresql.org/docs/12/app-pgdump.html>`_ utility:"
msgstr ""

#: ../../source/howto/installation.rst:552
msgid ""
"The ``-W`` flag will ensure to prompt for the database password. The "
"parameters between brackets should be replaced with the values that have "
"been configured for the profile. You can retrieve these from the "
"``storage.config`` returned by the ``verdi profile show`` command."
msgstr ""

#: ../../source/howto/installation.rst:558
msgid ""
"In order to avoid having to enter your database password each time you use "
"the script, you can create a file ``.pgpass`` in your home directory "
"containing your database credentials, as described `in the PostgreSQL "
"documentation <https://www.postgresql.org/docs/12/libpq-pgpass.html>`_."
msgstr ""
"为了避免每次使用脚本时都要输入数据库密码，你可以在您的主目录中创建一个文件 ``.pgpass`` 包含您的数据库凭证，如 `PostgreSQL文档 "
"<https://www.postgresql.org/docs/12/libpq-pgpass.html>`_ 。"

#: ../../source/howto/installation.rst:560
#: ../../source/howto/installation.rst:604
msgid "**File repository**"
msgstr ""

#: ../../source/howto/installation.rst:562
msgid ""
"The file repository is a directory on the local file system. The most "
"efficient way to create a backup is to use the `rsync "
"<https://en.wikipedia.org/wiki/Rsync>`_ utility. The path of the repository "
"is shown in the ``storage.config.repository_uri`` key returned by the "
"``verdi profile show`` command. To create a backup, simply run:"
msgstr ""

#: ../../source/howto/installation.rst:575
msgid "Restoring your installation"
msgstr ""

#: ../../source/howto/installation.rst:577
msgid "Restoring a backed up AiiDA installation requires:"
msgstr ""

#: ../../source/howto/installation.rst:579
msgid ""
"restoring the backed up ``.aiida`` folder, with at the very least the "
"``config.json`` file it contains. It should be placed in the path defined by"
" the ``AIIDA_PATH`` environment variable. To test the restoration worked, "
"run ``verdi profile list`` to verify that all profiles are displayed."
msgstr ""

#: ../../source/howto/installation.rst:583
msgid ""
"restoring the data of each backed up profile. Like the backup procedure, "
"this is dependent on the storage backend used by the profile."
msgstr ""

#: ../../source/howto/installation.rst:593
msgid ""
"To fully backup the data stored for a profile using the ``core.psql_dos`` "
"backend, you should restore the associated database and file repository."
msgstr ""

#: ../../source/howto/installation.rst:597
msgid ""
"To restore the PostgreSQL database from the ``.psql`` file that was backed "
"up, first you should create an empty database following the instructions "
"described in :ref:`database <intro:install:database>` skipping the ``verdi "
"setup`` phase. The backed up data can then be imported by calling:"
msgstr ""

#: ../../source/howto/installation.rst:606
msgid ""
"To restore the file repository, simply copy the directory that was backed up"
" to the location indicated by the ``storage.config.repository_uri`` key "
"returned by the ``verdi profile show`` command. Like the backing up process,"
" we recommend using ``rsync`` for this:"
msgstr ""

#: ../../source/howto/installation.rst:617
msgid "Managing multiple users"
msgstr "管理多个用户"

#: ../../source/howto/installation.rst:618
msgid ""
"AiiDA currently does not support multiple users running concurrently on the "
"same AiiDA profile. While AiiDA will tag any node with the "
":py:class:`~aiida.orm.users.User` who created it (the default user is "
"specified in the profile), this information is currently not used "
"internally. In particular, there is currently no permission system in place "
"to limit the operations that can be performed by a given user."
msgstr ""

#: ../../source/howto/installation.rst:622
msgid ""
"The typical setup involves each user individually installing AiiDA on their "
"operating system account. Data can be shared between private AiiDA profiles "
"through :ref:`AiiDA's export and import functionality <how-"
"to:share:archives>`."
msgstr ""

#: ../../source/howto/installation.rst:625
msgid ""
"Note that while the configuration file of an AiiDA instance contains access "
"credentials (e.g. for the postgresql database or the rabbitmq service), "
"AiiDA does not store sensitive data in the database or file repository, and "
"AiiDA export archives never contain such data."
msgstr ""

#: ../../source/howto/interact.rst:5
msgid "How to interact with AiiDA"
msgstr "如何与AiiDA交互"

#: ../../source/howto/interact.rst:7
msgid "There are a variety of manners to interact with AiiDA:"
msgstr "与AiiDA交互的方式多种多样:"

#: ../../source/howto/interact.rst:9
msgid ":ref:`Through the command line interface <how-to:interact-cli>`"
msgstr ":ref:`通过命令行接口 <how-to:interact-cli>`"

#: ../../source/howto/interact.rst:10
msgid ":ref:`Through scripts <how-to:interact-scripts>`"
msgstr ":ref:`通过脚本 <how-to:interact-scripts>`"

#: ../../source/howto/interact.rst:11
msgid ":ref:`Through interactive shells <how-to:interact-shell>`"
msgstr ":ref:`通过shell交互 <how-to:interact-shell>`"

#: ../../source/howto/interact.rst:12
msgid ":ref:`Through interactive notebooks <how-to:interact-notebook>`"
msgstr ":ref:`通过notebook交互 <how-to:interact-notebook>`"

#: ../../source/howto/interact.rst:13
msgid ":ref:`Through the REST API <how-to:interact-restapi>`"
msgstr ":ref:`通过REST API交互 <how-to:interact-restapi>`"

#: ../../source/howto/interact.rst:19
msgid "Command line interface"
msgstr "命令行接口"

#: ../../source/howto/interact.rst:21
msgid ""
"AiiDA comes with a command line interface called ``verdi``. The "
":ref:`reference:command-line` section gives an overview of all available "
"commands. For more detailed information, refer to the topic section "
":ref:`topics:cli`."
msgstr ""
"AiiDA带有一个名为 ``verdi`` 的命令行接口。:ref:`参考资料：指令` 部分提供了所有可用命令的概述。更多详细信息，请参考 "
":ref:`主题：命令行:` 章节。"

#: ../../source/howto/interact.rst:29
msgid "Scripts"
msgstr "脚本"

#: ../../source/howto/interact.rst:31
msgid ""
"AiiDA's Python API can be used in Python scripts mixed with any other Python"
" code. The only requirement is that before the API is used an AiiDA profile "
"is loaded. The recommended way of accomplishing this is to run the script "
"through the command line interface:"
msgstr ""
"AiiDA的Python "
"API可以在Python脚本中与任何其他Python代码混合使用。唯一的要求是在使用API之前加载一个AiiDA配置文件。推荐的方法是通过命令行接口运行脚本:"

#: ../../source/howto/interact.rst:39
msgid ""
"The ``verdi`` CLI will automatically load the default profile, before "
"calling the actual script, passing any command line arguments that may have "
"been specified."
msgstr "在调用实际的脚本之前， ``verdi`` CLI会自动加载默认配置文件，传递可能已经指定的任何命令行参数。"

#: ../../source/howto/interact.rst:43 ../../source/howto/interact.rst:99
msgid ""
"A :ref:`different profile can be selected <topics:cli:profile>` using the "
"``--profile`` option, just as for all other ``verdi`` commands."
msgstr ""
"使用 ``--profile`` 参数 :ref:`可在指定一个不同的配置文件 <topics:cli:profile>`  ，就像所有其他 "
"``verdi`` 命令一样。"

#: ../../source/howto/interact.rst:45
msgid ""
"Alternatively, one can also add AiiDA's specific `shebang "
"<https://en.wikipedia.org/wiki/Shebang_(Unix)>`_ to the top of the file."
msgstr ""
"或者，也可以将AiiDA的特定 `shebang<https://en.wikipedia.org/wiki/Shebang_(Unix)>`_ "
"添加到文件的顶部。"

#: ../../source/howto/interact.rst:51
msgid ""
"When a script starts with this shebang, when it is executed, it is "
"automatically passed to ``verdi run`` just as if it would have been called "
"through ``verdi run`` directly. This has the advantage that one no longer "
"has to explicitly type ``verdi run`` when running the script, but can simply"
" make it executable and execute it directly. The downside is that it does "
"not allow to specify a particular profile, but it always loads the default "
"profile."
msgstr ""
"当一个脚本以这个shebang开始时，当它被执行时，它会自动传递给 ``verdi run`` ，就像它会直接通过 ``verdi run`` "
"被调用一样。这样做的好处是，当运行脚本时，人们不再需要显式地键入 ``verdi run`` "
"，而是可以简单地使它可执行，并直接执行它。缺点是它不允许指定特定的概要文件，但是它总是加载默认的概要文件。"

#: ../../source/howto/interact.rst:55
msgid ""
"If, for whatever reason, ``verdi run`` nor the special shebang can be used, "
"a profile can also be loaded directly through the API within the Python "
"script itself:"
msgstr ""
"如果，不管出于什么原因， ``verdi run`` 或特殊的shebang都不能使用，配置文件也可以通过Python脚本本身的API直接加载:"

#: ../../source/howto/interact.rst:62 ../../source/howto/interact.rst:113
msgid ""
"One can pass a particular profile name to "
":meth:`~aiida.manage.configuration.load_profile`, otherwise the default "
"profile is loaded."
msgstr ""
"可以将特定的配置文件名称传递给  :meth:`~aiida.manage.configuration.load_profile` "
"，否则将加载默认配置文件。"

#: ../../source/howto/interact.rst:64
msgid ""
"Within a script or Python instance, you can also switch to a different "
"profile, or use one within a context manager:"
msgstr ""

#: ../../source/howto/interact.rst:86
msgid "Interactive shells"
msgstr "交互式shell"

#: ../../source/howto/interact.rst:88
msgid ""
"AiiDA provides a Python API that can be used from an interactive shell, such"
" as `IPython <https://ipython.org/>`_. The recommended way of starting an "
"interactive shell session to work with AiiDA, is through the command line "
"interface:"
msgstr ""
"AiiDA提供了一个可以从交互式shell中使用的Python API，例如 "
"`IPython<https://ipython.org/>`_。启动交互式shell会话来使用AiiDA的推荐方法是通过命令行界面:"

#: ../../source/howto/interact.rst:95
msgid ""
"This command will open a normal IPython shell but automatically loads the "
"default AiiDA profile, which is required to use the Python API."
msgstr "该命令将打开一个普通的IPython shell，但会自动加载默认的AiiDA配置文件，这是使用Python API所必需的。"

#: ../../source/howto/interact.rst:101
msgid ""
"In addition to automatically loading an AiiDA profile, certain modules from "
"AiiDA's API that are used very often are automatically imported. The modules"
" that are pre-loaded can be configured using the :ref:`reference:command-"
"line:verdi-config` command."
msgstr ""
"除了自动加载AiiDA配置文件之外，还会自动导入来自AiiDA API的一些经常使用的模块。预先加载的模块可以使用 "
":ref:`reference:command:verdi-config` 命令进行配置。"

#: ../../source/howto/interact.rst:104
msgid ""
"If, for whatever reason, you cannot use ``verdi shell``, a profile can also "
"be loaded directly through the API within the shell itself:"
msgstr "如果，不管出于什么原因，你不能使用 ``verdi shell``，配置文件也可以直接通过shell内部的API加载:"

#: ../../source/howto/interact.rst:119
msgid "Interactive notebooks"
msgstr "交互的notebook"

#: ../../source/howto/interact.rst:121
msgid ""
"Similar to :ref:`interactive shells <how-to:interact-shell>`, AiiDA is also "
"directly compatbile with interactive Python notebooks, such as `Jupyter "
"<https://jupyter.org/>`_. To use AiiDA's Python API in a notebook, first a "
"profile has to be loaded:"
msgstr ""
"类似于 :ref:`交互式shell <how-to:interact-shell>` AiiDA也直接兼容交互式Python笔记本，如 "
"`Jupyter <https://jupyter.org/>` _。要在笔记本中使用AiiDA的Python API，首先要加载一个配置文件:"

#: ../../source/howto/interact.rst:131
msgid ""
"One can pass a particular profile name to "
":meth:`~aiida.manage.configuration.load_profile`, otherwise the default "
"profile is loaded. The same can be accomplished using the following magic "
"statement:"
msgstr ""
"可以将特定的配置文件名称传递给 :meth:`~aiida.manage.configuration.load_profile` "
"，否则将加载默认配置文件。同样的事情可以用下面的magic语句来完成:"

#: ../../source/howto/interact.rst:139
msgid ""
"This magic line will replicate the same environment as :ref:`the interactive"
" shell <how-to:interact-shell>` provided by ``verdi shell``. However, it "
"does require some one-time installation, as detailed in the section on how "
"to :ref:`intro:install:jupyter`."
msgstr ""
"这行神奇的代码将复制与 ``verdi shell`` 提供的 :ref:`交互式shell <how-to:interact-"
"shell>`相同的环境。但是，它确实需要先统一地安装，如 :ref:`介绍:安装:jupyter`一节所述。"

#: ../../source/howto/interact.rst:146
msgid "REST API"
msgstr "REST API"

#: ../../source/howto/interact.rst:148
msgid ""
"AiiDA ships with a built in REST API, that allows you to query the data of a"
" particular profile. Refer to section :ref:`how-to:share:serve:launch` to "
"learn how to start the REST API. The section :ref:`how-to:share:serve:query`"
" provides information on how to interact with a running REST API."
msgstr ""
"AiiDA附带一个内置的REST API，它允许您查询特定配置文件的数据。参考章节 :ref:`如何做:共享:服务:启动` 来学习如何启动REST "
"API。`how-to:share:serve:query` 小节提供了如何与运行中的REST API交互的信息。"

#: ../../source/howto/plugin_codes.rst:5
msgid "How to write a plugin for an external code"
msgstr "如何为外部代码编写插件"

#: ../../source/howto/plugin_codes.rst:9
msgid ""
"Before starting to write a new plugin, check the `aiida plugin registry "
"<https://aiidateam.github.io/aiida-registry/>`_. If a plugin for your code "
"is already available, you can skip straight to :ref:`how-to:run-codes`."
msgstr ""
"在开始编写一个新的插件之前，检查 `aiida插件注册表 <https://aiidateam.github.io/aiida-registry/>`_"
" 。如果你的代码已经有一个插件，你可以直接跳到 :ref:`how-to:run-codes`。"

#: ../../source/howto/plugin_codes.rst:14
msgid ""
"This how to walks you through all logical steps of how AiiDA interacts with "
"an external code. If you already know the basics and would like to get "
"started with a new plugin package quickly, check out :ref:`how-to:plugins-"
"develop`."
msgstr ""
"本文将指导您完成AiiDA如何与外部代码交互的所有逻辑步骤。如果你已经知道了一些基础知识，并且想要快速开始一个新的插件包，请查看 :ref:`how-"
"to:plugins-develop`。"

#: ../../source/howto/plugin_codes.rst:17
msgid ""
"To run an external code with AiiDA, you need a corresponding *calculation* "
"plugin, which tells AiiDA how to:"
msgstr "要用AiiDA运行外部代码，你需要一个相应的 `calculation` 插件，它告诉AiiDA如何:"

#: ../../source/howto/plugin_codes.rst:19
msgid "Prepare the required input files."
msgstr "准备所需的输入文件。"

#: ../../source/howto/plugin_codes.rst:20
msgid "Run the code with the correct command line parameters."
msgstr "用一系列正确的命令行参数设置运行这个程序"

#: ../../source/howto/plugin_codes.rst:22
msgid ""
"Finally, you will probably want a *parser* plugin, which tells AiiDA how to:"
msgstr "最后，你可能需要一个 *解析* 插件，它告诉AiiDA如何:"

#: ../../source/howto/plugin_codes.rst:24
msgid "Parse the output of the code."
msgstr "解析计算代码的输出。"

#: ../../source/howto/plugin_codes.rst:26
msgid ""
"This how-to takes you through the process of :ref:`creating a calculation "
"plugin<how-to:plugin-codes:interfacing>`, using it to :ref:`run the "
"code<how-to:plugin-codes:run>`, and :ref:`writing a parser <how-to:plugin-"
"codes:parsing>` for its outputs."
msgstr ""

#: ../../source/howto/plugin_codes.rst:28
msgid ""
"In this example, our |Code| will be the ``diff`` executable that "
"\"computes\" the difference between two \"input files\" and prints the "
"difference to standard output:"
msgstr ""

#: ../../source/howto/plugin_codes.rst:46
msgid ""
"We are using ``diff`` here since it is available on almost every UNIX system"
" by default, and it takes both command line *arguments* (the two files) and "
"command line *options* (e.g. ``-i`` for case-insensitive matching). This is "
"similar to how the executables of many scientific simulation codes work, "
"making it easy to adapt this example to your use case."
msgstr ""

#: ../../source/howto/plugin_codes.rst:49
msgid "We will run ``diff`` as:"
msgstr ""

#: ../../source/howto/plugin_codes.rst:55
msgid ""
"thus writing difference between `file1.txt` and `file2.txt` to `diff.patch`."
msgstr ""

#: ../../source/howto/plugin_codes.rst:62
msgid "Interfacing external codes"
msgstr "连接外部代码"

#: ../../source/howto/plugin_codes.rst:64
msgid ""
"Start by creating a file ``calculations.py`` and subclass the |CalcJob| "
"class:"
msgstr "首先创建一个文件 ``calculation .py`` 和 |CalcJob| 类的子类:"

#: ../../source/howto/plugin_codes.rst:76
msgid ""
"In the following, we will tell AiiDA how to run our code by implementing two"
" key methods:"
msgstr "下面，我们将告诉AiiDA如何通过实现两个关键方法来运行我们的代码:"

#: ../../source/howto/plugin_codes.rst:78
msgid ":py:meth:`~aiida.engine.processes.calcjobs.calcjob.CalcJob.define`"
msgstr ":py:meth:`~aiida.engine.processes.calcjobs.calcjob.CalcJob.define`"

#: ../../source/howto/plugin_codes.rst:79
msgid ""
":py:meth:`~aiida.engine.processes.calcjobs.calcjob.CalcJob.prepare_for_submission`"
msgstr ""
":py:meth:`~aiida.engine.processes.calcjobs.calcjob.CalcJob.prepare_for_submission`"

#: ../../source/howto/plugin_codes.rst:82
msgid "Defining the spec"
msgstr "定义规范（spec）"

#: ../../source/howto/plugin_codes.rst:84
msgid ""
"The |define| method tells AiiDA which inputs the |CalcJob| expects and which"
" outputs it produces (exit codes will be :ref:`discussed later<how-"
"to:plugin-codes:parsing:errors>`). This is done through an instance of the "
":py:class:`~aiida.engine.processes.process_spec.CalcJobProcessSpec` class, "
"which is passed as the |spec| argument to the |define| method. For example:"
msgstr ""
"|define|方法告诉AiiDA |CalcJob| 所期望的输入和它产生的输出(退出代码将在 :ref:`稍后讨论<how-to:plugin-"
"codes:parsing:errors>` )。这是通过 "
":py:class:`~aiida.engine.processes.process_spec.CalcJobProcessSpec` "
"实例实现的，它作为 |spec|参数传递给 |define| 方法。例如:"

#: ../../source/howto/plugin_codes.rst:93
msgid ""
"The first line of the method calls the |define| method of the |CalcJob| "
"parent class. This necessary step defines the `inputs` and `outputs` that "
"are common to all |CalcJob|'s."
msgstr ""
"该方法的第一行调用 |CalcJob| 父类的 |define| 方法。这个必要的步骤定义了所有 |CalcJob| 通用的“输入”和“输出”。"

#: ../../source/howto/plugin_codes.rst:96
msgid ""
"Next, we use the :py:meth:`~plumpy.process_spec.ProcessSpec.input` method in"
" order to define our two input files ``file1`` and ``file2`` of type "
"|SinglefileData|."
msgstr ""

#: ../../source/howto/plugin_codes.rst:98
#: ../../source/howto/plugin_codes.rst:130
#: ../../source/howto/plugin_codes.rst:191
msgid "Further reading"
msgstr ""

#: ../../source/howto/plugin_codes.rst:100
msgid ""
"When using |SinglefileData|, AiiDA keeps track of the inputs as *files*. "
"This is very flexible but has the downside of making it difficult to query "
"for information contained in those files and ensuring that the inputs are "
"valid. :ref:`how-to:plugin-codes:cli-options` shows how to use the |Dict| "
"class to represent the ``diff`` command line options as a python dictionary."
" The `aiida-diff`_ demo plugin goes further and adds automatic validation."
msgstr ""

#: ../../source/howto/plugin_codes.rst:105
msgid ""
"We then use :py:meth:`~plumpy.process_spec.ProcessSpec.output` to define the"
" only output of the calculation with the label ``diff``. AiiDA will attach "
"the outputs defined here to a (successfully) finished calculation using the "
"link label provided."
msgstr ""

#: ../../source/howto/plugin_codes.rst:114
msgid ""
"Finally, we set a few default ``options``, such as the name of the parser "
"(which we will implement later), the name of input and output files, and the"
" computational resources to use for such a calculation. These ``options`` "
"have already been defined on the |spec| by the ``super().define(spec)`` "
"call, and they can be accessed through the "
":py:attr:`~plumpy.process_spec.ProcessSpec.inputs` attribute, which behaves "
"like a dictionary."
msgstr ""

#: ../../source/howto/plugin_codes.rst:117
msgid ""
"There is no ``return`` statement in ``define``: the ``define`` method "
"directly modifies the |spec| object it receives."
msgstr ""

#: ../../source/howto/plugin_codes.rst:121
msgid ""
"One more input required by any |CalcJob| is which external executable to "
"use."
msgstr ""

#: ../../source/howto/plugin_codes.rst:123
msgid ""
"External executables are represented by |Code|  instances that contain "
"information about the computer they reside on, their path in the file system"
" and more. They are passed to a |CalcJob| via the ``code`` input, which is "
"defined in the |CalcJob| base class, so you don't have to:"
msgstr ""

#: ../../source/howto/plugin_codes.rst:132
msgid ""
"For more details on setting up your `inputs` and `outputs` (covering "
"validation, dynamic number of inputs, etc.) see the :ref:`Defining Processes"
" <topics:processes:usage:defining>` topic."
msgstr ""

#: ../../source/howto/plugin_codes.rst:135
msgid "Preparing for submission"
msgstr "准备提交"

#: ../../source/howto/plugin_codes.rst:138
msgid ""
"The "
":py:meth:`~aiida.engine.processes.calcjobs.calcjob.CalcJob.prepare_for_submission`"
" method has two jobs: Creating the input files in the format the external "
"code expects and returning a "
":py:class:`~aiida.common.datastructures.CalcInfo` object that contains "
"instructions for the AiiDA engine on how the code should be run. For "
"example:"
msgstr ""
":py:meth:`~aiida.engine.processes.calcjobs.calcjob.CalcJob.prepare_for_submission`"
" 方法有两个作用: 以外部代码期望的格式创建输入文件，并返回一个 "
":py:class:`~aiida.common.datastructures.CalcInfo` "
"对象，该对象包含AiiDA引擎关于该计算代码应如何运行的指令。例如:"

#: ../../source/howto/plugin_codes.rst:146
msgid ""
"All inputs provided to the calculation are validated against the ``spec`` "
"*before* |prepare_for_submission| is called. Therefore, when accessing the "
":py:attr:`~plumpy.processes.Process.inputs` attribute, you can safely assume"
" that all required inputs have been set and that all inputs have a valid "
"type."
msgstr ""
"在调用 |prepare_for_submission| 之前，为计算提供的所有输入都根据 ``spec`` 进行验证。因此，当访问 "
":py:attr:`~plumpy.processes.Process.inputs` "
"的属性，您可以安全地假设所有必需的输入都已设置，并且所有输入都具有有效的类型。"

#: ../../source/howto/plugin_codes.rst:149
msgid ""
"We start by creating a |CodeInfo| object that lets AiiDA know how to run the"
" code, i.e. here:"
msgstr ""

#: ../../source/howto/plugin_codes.rst:155
msgid ""
"This includes the command line parameters (here: the names of the files that"
" we would like to ``diff``) and the UUID of the |Code| to run. Since "
"``diff`` writes directly to standard output, we redirect standard output to "
"the specified output filename."
msgstr ""

#: ../../source/howto/plugin_codes.rst:158
msgid ""
"Next, we create a |CalcInfo| object that lets AiiDA know which files to copy"
" back and forth. In our example, the two input files are already stored in "
"the AiiDA file repository and we can use the ``local_copy_list`` to pass "
"them along."
msgstr ""

#: ../../source/howto/plugin_codes.rst:163
msgid ""
"In other use cases you may need to *create* new files on the fly. This is "
"what the ``folder`` argument of "
":py:meth:`~aiida.engine.processes.calcjobs.calcjob.CalcJob.prepare_for_submission`"
" is for:"
msgstr ""

#: ../../source/howto/plugin_codes.rst:172
msgid ""
"Any files and directories created in this sandbox folder will automatically "
"be transferred to the compute resource where the actual calculation takes "
"place."
msgstr ""

#: ../../source/howto/plugin_codes.rst:182
msgid ""
"The ``retrieve_list`` on the other hand tells the engine which files to "
"retrieve from the directory where the job ran after it has finished. All "
"files listed here will be store in a |FolderData| node that is attached as "
"an output node to the calculation with the label ``retrieved``."
msgstr ""

#: ../../source/howto/plugin_codes.rst:185
msgid ""
"Finally, we pass the |CodeInfo| to a |CalcInfo| object. One calculation job "
"can involve more than one executable, so ``codes_info`` is a list. If you "
"have more than one executable in your ``codes_info``, you can set "
"``codes_run_mode`` to specify the mode with which these will be executed "
"(`CodeRunMode.SERIAL` by default). We define the ``retrieve_list`` of "
"filenames that the engine should retrieve from the directory where the job "
"ran after it has finished. The engine will store these files in a "
"|FolderData| node that will be attached as an output node to the calculation"
" with the label ``retrieved``."
msgstr ""

#: ../../source/howto/plugin_codes.rst:193
msgid ""
"There are :ref:`other file lists "
"available<topics:calculations:usage:calcjobs:file_lists>` that allow you to "
"easily customize how to move files to and from the remote working directory "
"in order to prevent the creation of unnecessary copies. For more details on "
"the |CalcJob| class, refer to the Topics section on :ref:`defining "
"calculations <topics:calculations:usage>`."
msgstr ""

#: ../../source/howto/plugin_codes.rst:200
msgid "Parsing the outputs"
msgstr "解析输出"

#: ../../source/howto/plugin_codes.rst:202
msgid ""
"Parsing the output files produced by a code into AiiDA nodes is optional, "
"but it can make your data queryable and therefore easier to access and "
"analyze."
msgstr "将代码生成的输出文件解析到AiiDA节点是可选的，但它可以使数据可查询，从而更容易访问和分析。"

#: ../../source/howto/plugin_codes.rst:204
msgid ""
"To create a parser plugin, subclass the |Parser| class in a file called "
"``parsers.py``."
msgstr ""

#: ../../source/howto/plugin_codes.rst:211
msgid ""
"Before the ``parse()`` method is called, two important attributes are set on"
" the |Parser|  instance:"
msgstr "在调用 ``parse()`` 方法之前，|Parser| 实例上设置了两个重要的属性:"

#: ../../source/howto/plugin_codes.rst:213
msgid ""
"``self.retrieved``: An instance of |FolderData|, which points to the folder "
"containing all output files that the |CalcJob| instructed to retrieve, and "
"provides the means to "
":py:meth:`~aiida.orm.nodes.repository.NodeRepository.open` any file it "
"contains."
msgstr ""

#: ../../source/howto/plugin_codes.rst:215
msgid ""
"``self.node``: The "
":py:class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode` "
"representing the finished calculation, which, among other things, provides "
"access to all of its inputs (``self.node.inputs``)."
msgstr ""
"``self.node``:  "
":py:class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode` "
"表示完成的计算，它提供对其所有输入的访问(``self.node.inputs``)。"

#: ../../source/howto/plugin_codes.rst:217
msgid ""
"Now implement its :py:meth:`~aiida.parsers.parser.Parser.parse` method as"
msgstr ""

#: ../../source/howto/plugin_codes.rst:223
msgid ""
"The "
":py:meth:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.get_option`"
" convenience method is used to get the filename of the output file."
msgstr ""

#: ../../source/howto/plugin_codes.rst:225
msgid ""
"Finally, the :py:meth:`~aiida.parsers.parser.Parser.out` method is used "
"return the output file as the ``diff`` output of the calculation: The first "
"argument is the name to be used as the label for the link that connects the "
"calculation and data node. The second argument is the node that should be "
"recorded as an output."
msgstr ""

#: ../../source/howto/plugin_codes.rst:231
msgid ""
"The outputs and their types need to match those from the process "
"specification of the corresponding |CalcJob| (or an exception will be "
"raised)."
msgstr ""

#: ../../source/howto/plugin_codes.rst:233
msgid ""
"In this minimalist example, there isn't actually much parsing going on -- we"
" are simply passing along the output file as a |SinglefileData| node. If "
"your code produces output in a structured format, instead of just returning "
"the file you may want to parse it e.g. to a python dictionary (|Dict| node) "
"to make the results easily searchable."
msgstr ""

#: ../../source/howto/plugin_codes.rst:236
msgid "Exercise"
msgstr ""

#: ../../source/howto/plugin_codes.rst:238
msgid ""
"Consider the different output files produced by your favorite simulation "
"code. Which information would you want to:"
msgstr ""

#: ../../source/howto/plugin_codes.rst:241
msgid ""
"parse into the database for querying (e.g. as |Dict|, |StructureData|, ...)?"
msgstr ""

#: ../../source/howto/plugin_codes.rst:242
msgid ""
"store in the AiiDA file repository for safe-keeping (e.g. as "
"|SinglefileData|, ...)?"
msgstr ""

#: ../../source/howto/plugin_codes.rst:243
msgid ""
"leave on the computer where the calculation ran (e.g. recording their remote"
" location using |RemoteData| or simply ignoring them)?"
msgstr ""

#: ../../source/howto/plugin_codes.rst:245
msgid ""
"Once you know the answers to these questions, you are ready to start writing"
" a parser for your code."
msgstr ""

#: ../../source/howto/plugin_codes.rst:247
msgid ""
"In order to request automatic parsing of a |CalcJob| (once it has finished),"
" users can set the ``metadata.options.parser_name`` input when launching the"
" job. If a particular parser should be used by default, the |CalcJob| "
"``define`` method can set a default value for the parser name as was done in"
" the :ref:`previous section <how-to:plugin-codes:interfacing>`:"
msgstr ""
"为了请求自动解析|CalcJob|(一旦完成)，用户可以在启动作业时设置 ``metadata.options.parser_name`` "
"。如果一个有特定的默认解析器，|CalcJob| 的 ``define`` 方法可以为解析器名称设置一个默认值，如 :ref:`前述章节 <how-"
"to:plugin-codes:interfacing>`中所做的:"

#: ../../source/howto/plugin_codes.rst:257
msgid ""
"Note that the default is not set to the |Parser| class itself, but to the "
"*entry point string* under which the parser class is registered. We will "
"register the entry point for the parser in a bit."
msgstr ""

#: ../../source/howto/plugin_codes.rst:264
msgid "Handling parsing errors"
msgstr "处理解析错误"

#: ../../source/howto/plugin_codes.rst:266
msgid ""
"So far, we have not spent much attention on dealing with potential errors "
"that can arise when running external codes. However, there are lots of ways "
"in which codes can fail to execute nominally. A |Parser| can play an "
"important role in detecting and communicating such errors, where "
":ref:`workflows <how-to:run-workflows>` can then decide how to proceed, "
"e.g., by modifying input parameters and resubmitting the calculation."
msgstr ""
"到目前为止，我们还没有花太多精力来处理运行外部代码时可能出现的潜在错误。然而，有很多方法会导致代码名义上执行失败。|Parser| "
"可以在检测和通报此类错误中发挥重要作用，其中 :ref:`工作流 <how-to:run-"
"workflows>`可以决定如何继续，例如，通过修改输入参数和重新提交计算。"

#: ../../source/howto/plugin_codes.rst:270
msgid ""
"Parsers communicate errors through :ref:`exit "
"codes<topics:processes:concepts:exit_codes>`, which are defined in the "
"|spec| of the |CalcJob| they parse. The ``DiffCalculation`` example, defines"
" the following exit code:"
msgstr ""

#: ../../source/howto/plugin_codes.rst:277
msgid "An ``exit_code`` defines:"
msgstr ""

#: ../../source/howto/plugin_codes.rst:279
msgid ""
"an exit status (a positive integer, following the "
":ref:`topics:processes:usage:exit_code_conventions`),"
msgstr ""

#: ../../source/howto/plugin_codes.rst:280
msgid ""
"a label that can be used to reference the code in the |parse| method "
"(through the ``self.exit_codes`` property, as shown below), and"
msgstr "该标签可以用来引用|parse|方法中的状态码(通过 ``self.exit_codes`` 属性，如下所示)，和"

#: ../../source/howto/plugin_codes.rst:281
msgid "a message that provides a more detailed description of the problem."
msgstr "包括了一个更详细的描述。"

#: ../../source/howto/plugin_codes.rst:283
msgid ""
"In order to inform AiiDA about a failed calculation, simply return from the "
"``parse`` method the exit code that corresponds to the detected issue. Here "
"is a more complete version of the example |Parser| presented in the previous"
" section:"
msgstr ""
"为了通知AiiDA一个失败的计算，只需从 ``parse`` 方法返回与检测到的问题对应的退出代码。下面是上一节给出的|Parser| 的完整版本:"

#: ../../source/howto/plugin_codes.rst:290
msgid ""
"This simple check makes sure that the expected output file ``diff.patch`` is"
" among the files retrieved from the computer where the calculation was run. "
"Production plugins will often scan further aspects of the output (e.g. the "
"standard error, the output file, etc.) for any issues that may indicate a "
"problem with the calculation and return a corresponding exit code."
msgstr ""

#: ../../source/howto/plugin_codes.rst:293
msgid ""
"AiiDA stores the exit code returned by the |parse| method on the calculation"
" node that is being parsed, from where it can then be inspected further down"
" the line (see the :ref:`defining processes "
"<topics:processes:usage:defining>` topic for more details). Note that some "
"scheduler plugins can detect issues at the scheduler level (by parsing the "
"job scheduler output) and set an exit code. The Topics section on "
":ref:`scheduler exit codes <topics:calculations:usage:calcjobs:scheduler-"
"errors>` explains how these can be inspected inside a parser and how they "
"can optionally be overridden."
msgstr ""

#: ../../source/howto/plugin_codes.rst:301
msgid "Customizations"
msgstr ""

#: ../../source/howto/plugin_codes.rst:306
msgid "Process label"
msgstr ""

#: ../../source/howto/plugin_codes.rst:308
msgid ""
"Each time a ``Process`` is run, a ``ProcessNode`` is stored in the database "
"to record the execution. A human-readable label is stored in the "
"``process_label`` attribute. By default, the name of the process class is "
"used as this label. If this default is not informative enough, it can be "
"customized by overriding the "
":meth:`~aiida.engine.processes.process.Process._build_process_label`: "
"method:"
msgstr ""

#: ../../source/howto/plugin_codes.rst:320
msgid ""
"Nodes created through executions of this process class will have "
"``node.process_label == 'custom_process_label'``."
msgstr ""

#: ../../source/howto/plugin_codes.rst:325
msgid "Registering entry points"
msgstr "注册接入点"

#: ../../source/howto/plugin_codes.rst:327
msgid ""
":ref:`Entry points <how-to:plugins-develop:entrypoints>` are the preferred "
"method of registering new calculation, parser and other plugins with AiiDA."
msgstr ""
":ref:`接入点Entry points <how-to:plugins-develop:entrypoints>` "
"是注册新的计算，解析器和其他插件与AiiDA的首选方法。"

#: ../../source/howto/plugin_codes.rst:329
msgid ""
"With your ``calculations.py`` and ``parsers.py`` files at hand, let's "
"register entry points for the plugins they contain:"
msgstr "有了 ``calculation .py`` 和 ``parser .py`` 文件，让我们为它们包含的插件注册接入点:"

#: ../../source/howto/plugin_codes.rst:331
msgid "Move your two scripts into a subfolder ``aiida_diff_tutorial``:"
msgstr ""

#: ../../source/howto/plugin_codes.rst:339
msgid "You have just created an ``aiida_diff_tutorial`` Python *package*!"
msgstr ""

#: ../../source/howto/plugin_codes.rst:341
msgid ""
"Add a minimal set of metadata for your package by writing a "
"``pyproject.toml`` file:"
msgstr ""

#: ../../source/howto/plugin_codes.rst:370
msgid ""
"This allows for the project metadata to be fully specified in the "
"pyproject.toml file, using the PEP 621 format."
msgstr ""

#: ../../source/howto/plugin_codes.rst:373
msgid "Install your new ``aiida-diff-tutorial`` plugin package."
msgstr ""

#: ../../source/howto/plugin_codes.rst:379
msgid "See the :ref:`how-to:plugins-install` section for details."
msgstr ""

#: ../../source/howto/plugin_codes.rst:381
msgid "After this, you should see your plugins listed:"
msgstr "在这之后，你应该能看到你的插件列表:"

#: ../../source/howto/plugin_codes.rst:393
msgid "Running a calculation"
msgstr "运行算例"

#: ../../source/howto/plugin_codes.rst:395
msgid ""
"With the entry points set up, you are ready to launch your first calculation"
" with the new plugin:"
msgstr "设置好接入点后，你就可以开始使用新插件进行第一次计算了:"

#: ../../source/howto/plugin_codes.rst:398
msgid ""
"If you haven't already done so, :ref:`set up your computer<how-to:run-"
"codes:computer>`. In the following we assume it to be the localhost:"
msgstr "如果您还没有这样做，请使用 :ref:`设置计算资源 ` 。下面我们假设它是localhost:"

#: ../../source/howto/plugin_codes.rst:406
msgid "Create the input files for our calculation"
msgstr ""

#: ../../source/howto/plugin_codes.rst:415
msgid "Write a ``launch.py`` script:"
msgstr "编写一个 ``launch.py`` 脚本:"

#: ../../source/howto/plugin_codes.rst:422
msgid ""
"The ``launch.py`` script sets up an AiiDA |Code| instance that associates "
"the ``/usr/bin/diff`` executable with the ``DiffCalculation`` class (through"
" its entry point ``diff``)."
msgstr ""

#: ../../source/howto/plugin_codes.rst:424
msgid ""
"This code is automatically set on the ``code`` input port of the builder and"
" passed as an input to the calculation plugin."
msgstr ""

#: ../../source/howto/plugin_codes.rst:426
#: ../../source/howto/plugin_codes.rst:472
msgid "Launch the calculation:"
msgstr "启动算例:"

#: ../../source/howto/plugin_codes.rst:433
msgid ""
"If everything goes well, this should print the results of your calculation, "
"something like:"
msgstr "如果一切顺利，这应该会打印出你的计算结果，像这样:"

#: ../../source/howto/plugin_codes.rst:446
msgid ""
"If you encountered a parsing error, it can be helpful to make a "
":ref:`topics:calculations:usage:calcjobs:dry_run`, which allows you to "
"inspect the input folder generated by AiiDA before any calculation is "
"launched."
msgstr ""
"如果遇到解析错误，可以使用 :ref:`主题:算例:使用:算例任务:dry_run`，它允许您在启动任何计算之前检查AiiDA生成的输入文件夹。"

#: ../../source/howto/plugin_codes.rst:450
msgid ""
"Finally instead of running your calculation in the current shell, you can "
"submit your calculation to the AiiDA daemon:"
msgstr "最后，你可以将你的计算提交给AiiDA守护进程，而不是在当前shell中运行你的计算:"

#: ../../source/howto/plugin_codes.rst:452
msgid "(Re)start the daemon to update its Python environment:"
msgstr "(重新)启动守护进程来更新它的Python环境:"

#: ../../source/howto/plugin_codes.rst:458
msgid "Update your launch script to use:"
msgstr "更新你的启动脚本以供使用:"

#: ../../source/howto/plugin_codes.rst:469
msgid ""
"``node`` is the |CalcJobNode| representing the state of the underlying "
"calculation process (which may not be finished yet)."
msgstr "``node`` 是|CalcJobNode|，表示底层计算过程的状态(可能还没有完成)。"

#: ../../source/howto/plugin_codes.rst:478
msgid "This should print the UUID and the PK of the submitted calculation."
msgstr "这应该打印提交算例的UUID和PK。"

#: ../../source/howto/plugin_codes.rst:480
msgid ""
"You can use the verdi command line interface to "
":ref:`monitor<topics:processes:usage:monitoring>` this processes:"
msgstr "你可以使用verdi命令行接口 :ref:`监视 <topics:processes:usage:monitoring>` 这个进程:"

#: ../../source/howto/plugin_codes.rst:486
msgid ""
"This should show the processes of both calculations you just ran. Use "
"``verdi calcjob outputcat <pk>`` to check the output of the calculation you "
"submitted to the daemon."
msgstr ""

#: ../../source/howto/plugin_codes.rst:489
msgid ""
"Congratulations - you can now write plugins for external simulation codes "
"and use them to submit calculations!"
msgstr ""

#: ../../source/howto/plugin_codes.rst:491
msgid ""
"If you still have time left, consider going through the optional exercise "
"below."
msgstr ""

#: ../../source/howto/plugin_codes.rst:496
msgid "Writing importers for existing computations"
msgstr ""

#: ../../source/howto/plugin_codes.rst:500
msgid ""
"New users to your plugin may often have completed many previous computations"
" without the use of AiiDA, which they wish to import into AiiDA. In these "
"cases, it is possible to write an importer for their inputs/outputs, which "
"generates the provenance nodes for the corresponding |CalcJob|."
msgstr ""

#: ../../source/howto/plugin_codes.rst:503
msgid ""
"The importer must be written as a subclass of "
":class:`~aiida.engine.processes.calcjobs.importer.CalcJobImporter`, for an "
"example see "
":class:`aiida.calculations.importers.arithmetic.add.ArithmeticAddCalculationImporter`."
msgstr ""

#: ../../source/howto/plugin_codes.rst:506
msgid ""
"To associate the importer with the |CalcJob| class, the importer must be "
"registered with an entry point in the group "
"``aiida.calculations.importers``."
msgstr ""

#: ../../source/howto/plugin_codes.rst:515
msgid ""
"Note that the entry point name can be any valid entry point name. If the "
"importer plugin is provided by the same package as the corresponding "
"|CalcJob| plugin, it is recommended that the entry point name of the "
"importer and |CalcJob| plugin are the same. This will allow the "
":meth:`~aiida.engine.processes.calcjobs.calcjob.CalcJob.get_importer` method"
" to automatically fetch the associated importer. If the entry point names "
"differ, the entry point name of the desired importer implementation needs to"
" be passed to "
":meth:`~aiida.engine.processes.calcjobs.calcjob.CalcJob.get_importer` as an "
"argument."
msgstr ""

#: ../../source/howto/plugin_codes.rst:520
msgid ""
"Users can then import their calculations via the "
":py:meth:`~aiida.engine.processes.calcjobs.calcjob.CalcJob.get_importer` "
"method:"
msgstr ""

#: ../../source/howto/plugin_codes.rst:533
msgid ""
":doc:`aep:004_calcjob_importer/readme`, for the design considerations around"
" this feature."
msgstr ""

#: ../../source/howto/plugin_codes.rst:538
msgid "Exercise - Support command-line options"
msgstr ""

#: ../../source/howto/plugin_codes.rst:540
msgid "As discussed before, ``diff`` knows a couple of command-line options:"
msgstr ""

#: ../../source/howto/plugin_codes.rst:556
msgid ""
"For simplicity let's focus on the excerpt of options shown above and allow "
"the user of our plugin to pass these along."
msgstr ""

#: ../../source/howto/plugin_codes.rst:558
msgid ""
"Notice that one of the options (``--ignore-matching-lines``) requires the "
"user to pass a regular expression string, while the other options don't "
"require any value."
msgstr ""

#: ../../source/howto/plugin_codes.rst:560
msgid "One way to represent a set of command line options like"
msgstr ""

#: ../../source/howto/plugin_codes.rst:566
msgid "would be using a python dictionary:"
msgstr ""

#: ../../source/howto/plugin_codes.rst:576
msgid ""
"Here is a simple code snippet for translating the dictionary to a list of "
"command line options:"
msgstr ""

#: ../../source/howto/plugin_codes.rst:599
msgid ""
"When passing parameters along to your simulation code, try *validating* "
"them. This detects errors directly at *submission* of the calculation and "
"thus prevents calculations with malformed inputs from ever entering the "
"queue of your HPC system."
msgstr ""

#: ../../source/howto/plugin_codes.rst:602
msgid ""
"For the sake of brevity we are *not* performing validation here but there "
"are numerous python libraries, such as `voluptuous`_ (used by `aiida-diff`_,"
" see `example <https://github.com/aiidateam/aiida-"
"diff/blob/92c61bdcc2db201d69da4d8b83a2b3f5dd529bf1/aiida_diff/data/__init__.py#L14-L20>`_),"
" `marshmallow`_ or `pydantic`_, that help you define a schema to validate "
"input against."
msgstr ""

#: ../../source/howto/plugin_codes.rst:605
msgid ""
"Let's open our previous ``calculations.py`` file and start modifying the "
"``DiffCalculation`` class:"
msgstr ""

#: ../../source/howto/plugin_codes.rst:607
msgid ""
"In the ``define`` method, add a new ``input`` to the ``spec`` with label "
"``'parameters'`` and type |Dict|  (``from aiida.orm import Dict``)"
msgstr ""

#: ../../source/howto/plugin_codes.rst:0
msgid ""
"In the ``prepare_for_submission`` method run the ``cli_options`` function "
"from above on ``self.inputs.parameters.get_dict()`` to get the list of "
"command-line options."
msgstr ""

#: ../../source/howto/plugin_codes.rst:0
msgid "Add them to the ``codeinfo.cmdline_params``."
msgstr ""

#: ../../source/howto/plugin_codes.rst:0
msgid "Solution"
msgstr ""

#: ../../source/howto/plugin_codes.rst:613
msgid "For 1. add the following line to the ``define`` method:"
msgstr ""

#: ../../source/howto/plugin_codes.rst:619
msgid ""
"For 2. copy the ``cli_options`` snippet at the end of ``calculations.py`` "
"and set the ``cmdline_params`` to:"
msgstr ""

#: ../../source/howto/plugin_codes.rst:626
msgid ""
"That's it. Let's now open the ``launch.py`` script and pass along our "
"command line parameters:"
msgstr ""

#: ../../source/howto/plugin_codes.rst:634
msgid ""
"Change the capitalization of one of the characters in the first line of "
"``file1.txt``. Then, restart the daemon and submit the new calculation:"
msgstr ""

#: ../../source/howto/plugin_codes.rst:642
msgid ""
"If everything worked as intended, the capitalization difference in the first"
" line should be ignored (and thus not show up in the output)."
msgstr ""

#: ../../source/howto/plugin_codes.rst:644
msgid "This marks the end of this how-to."
msgstr "教程的如何做部分到这儿就完结了。"

#: ../../source/howto/plugin_codes.rst:646
msgid ""
"The |CalcJob| and |Parser| plugins are still rather basic and the ``aiida-"
"diff-tutorial`` plugin package is missing a number of useful features, such "
"as package metadata, documentation, tests, CI, etc. Continue with :ref:`how-"
"to:plugins-develop` in order to learn how to quickly create a feature-rich "
"new plugin package from scratch."
msgstr ""

#: ../../source/howto/plugins_develop.rst:5
msgid "How to package plugins"
msgstr "如何打包插件"

#: ../../source/howto/plugins_develop.rst:7
msgid ""
"This section focuses on how to *package* AiiDA extensions (plugins) so that "
"they can be tested, published and eventually reused by others."
msgstr ""

#: ../../source/howto/plugins_develop.rst:11
msgid ""
"For guides on writing specific extensions, see :ref:`how-to:plugin-codes`, "
":ref:`topics:data_types:plugin`, :ref:`topics:schedulers:develop_plugin`, or"
" :ref:`topics:transport:develop_plugin`."
msgstr ""

#: ../../source/howto/plugins_develop.rst:17
msgid "Creating a plugin package"
msgstr "创建插件包"

#: ../../source/howto/plugins_develop.rst:20
msgid ""
"AiiDA plugins can be bundled and distributed in a `Python package "
"<packages_>`_ that provides a set of extensions to AiiDA."
msgstr ""

#: ../../source/howto/plugins_develop.rst:24
msgid ""
"The Python community uses the term 'package' rather loosely. Depending on "
"context, it may refer simply to a folder containing individual Python "
"modules or it may include the files necessary for building and installing a "
"package to be distributed via the `Python Package Index (PyPI) <pypi_>`_."
msgstr ""

#: ../../source/howto/plugins_develop.rst:31
msgid "Quickstart"
msgstr "快速入门"

#: ../../source/howto/plugins_develop.rst:33
msgid ""
"The fastest way to jumpstart an AiiDA plugin package is to use the `AiiDA "
"plugin cutter <plugin-cutter_>`_ in order to template the basic folder "
"structure, already customized according to the desired name of your plugin, "
"following AiiDA conventions."
msgstr ""

#: ../../source/howto/plugins_develop.rst:35
msgid ""
"Simply go to the `AiiDA plugin cutter <plugin-cutter_>`_ and follow the "
"usage instructions. See also the `aiida-diff`_ demo plugin package for an "
"in-depth explanation of the files & folders produced by the plugin cutter."
msgstr ""

#: ../../source/howto/plugins_develop.rst:38
msgid ""
"In the following, we explain some of the conventions implemented by the "
"AiiDA plugin cutter."
msgstr "下面，我们将解释AiiDA插件cutter实现的一些约定。"

#: ../../source/howto/plugins_develop.rst:42
msgid "Choosing a name"
msgstr "选择一个名字"

#: ../../source/howto/plugins_develop.rst:44
msgid ""
"The naming convention for AiiDA plugin packages is ``aiida-mycode`` for the "
"plugin distribution on `PyPI`_ and ``aiida_mycode`` for the corresponding "
"python package, leading to the following folder structure::"
msgstr ""
"AiiDA插件包的命名约定是 ``aiida -mycode`` ，对于在 `PyPI`_ 上发布的插件，对应的python包是 "
"``aiida_mycode`` ，它有如下的文件夹结构::"

#: ../../source/howto/plugins_develop.rst:52
msgid "Python package names cannot contain dashes, thus the underscore."
msgstr "Python包名不能包含破折号，因此使用下划线。"

#: ../../source/howto/plugins_develop.rst:54
msgid ""
"If you intend to eventually publish your plugin package, please go to the "
"`AiiDA plugin registry <registry_>`_  and choose a name that is not already "
"taken. You are also encouraged to pre-register your package (instructions "
"provided on the registry), both to reserve your plugin name and to inform "
"others of your ongoing development."
msgstr ""

#: ../../source/howto/plugins_develop.rst:61
#: ../../source/howto/plugins_develop.rst:145
msgid "Folder structure"
msgstr "目录结构"

#: ../../source/howto/plugins_develop.rst:63
msgid ""
"The overall folder structure of your plugin is up to you, but it is useful "
"to follow a set of basic conventions. Here is an example of a folder "
"structure for an AiiDA plugin, illustrating different levels of nesting (see"
" also the `aiida-diff demo plugin <aiida-diff_>`_)::"
msgstr ""

#: ../../source/howto/plugins_develop.rst:89
msgid "A minimal plugin package instead might look like::"
msgstr "一个最精简的插件包是这样的::"

#: ../../source/howto/plugins_develop.rst:99
msgid "Registering plugins through entry points"
msgstr "注册插件接入点"

#: ../../source/howto/plugins_develop.rst:101
msgid ""
"An AiiDA plugin is an extension of AiiDA that announces itself by means of a"
" new *entry point* (for details, see :ref:`topics:plugins:entrypoints`). "
"Adding a new entry point consists of the following steps:"
msgstr ""
"AiiDA插件是AiiDA的扩展，它通过一个新的 *接入点* 来指定自己(详细信息，参见 "
":ref:`topics:plugins:entrypoints`)。添加新的接入点包括以下步骤:"

#: ../../source/howto/plugins_develop.rst:104
msgid ""
"Deciding a name. We *strongly* suggest to start the name of each entry point"
" with the name of the plugin package (omitting the 'aiida-' prefix). For a "
"package ``aiida-mycode``, this will usually mean ``\"mycode.<something>\"``"
msgstr ""
"选定一个名字。我们强烈建议每个接入点的名称以插件包的名称开头(省略 'aiida-' 前缀)。对于一个包 ``aiida -mycode`` "
"，这通常意味着 ``\"mycode.<something>\"``"

#: ../../source/howto/plugins_develop.rst:108
msgid ""
"Finding the right entry point group. You can list the entry point groups "
"defined by AiiDA via ``verdi plugin list``. For a documentation of the "
"groups, see :ref:`topics:plugins:entrypointgroups`."
msgstr ""
"找到正确的接入点分组。你可以通过 ``verdi plugin list`` 列出AiiDA定义的入口点组。有关分组的文档，请参见 "
":ref:`topics:plugins:entrypointgroups` 。"

#: ../../source/howto/plugins_develop.rst:111
msgid ""
"Adding the entry point to the ``entry_points`` field in the "
"``pyproject.toml`` file::"
msgstr ""

#: ../../source/howto/plugins_develop.rst:118
msgid ""
"Your new entry point should now show up in ``verdi plugin list "
"aiida.calculations``."
msgstr "你的新入口点现在应该显示在  ``verdi plugin list aiida.calculations`` 中。"

#: ../../source/howto/plugins_develop.rst:122
msgid ""
"Taking a package with the name ``aiida-diff`` as example, what does ``pip "
"install aiida-diff`` do?"
msgstr "以一个名为 ``aiida-diff`` 的包为例，那么 ``pip install aiida -diff`` 的作用是什么呢?"

#: ../../source/howto/plugins_develop.rst:124
msgid "It resolves and installs the dependencies on other python packages"
msgstr "它解析并安装依赖的python包"

#: ../../source/howto/plugins_develop.rst:125
msgid ""
"It creates a folder ``aiida_diff.egg-info/`` with metadata about the package"
msgstr "它创建文件夹 ``aiida_diff.egg-info/`` 及其包相关的元数据"

#: ../../source/howto/plugins_develop.rst:126
msgid ""
"If the ``-e`` option is given, a symbolic link from the python package "
"search path to the ``aiida-diff`` directory is created and the ``.egg-info``"
" folder is put there instead. Changes to the **source code** will be picked "
"up by python without reinstalling (when restarting the interpreter),  but "
"changes to the **metadata** will not."
msgstr ""
"如果参数 ``-e`` 被使用，那么会创建一个从python包使用路径到 ``aiida-diff`` 源代码文件夹的链接，并将文件夹 ``.egg-"
"info`` 存放在使用路径中。对 **源代码** 的修改将不用重装就能被python载入 (重新安装解释器), 但是对 **元数据** "
"的修改不会被重载。"

#: ../../source/howto/plugins_develop.rst:129
msgid ""
"For further details, see the Python `packaging user guide <packaging_>`_."
msgstr ""

#: ../../source/howto/plugins_develop.rst:136
msgid "Testing a plugin package"
msgstr "测试插件包"

#: ../../source/howto/plugins_develop.rst:138
msgid ""
"Writing tests for your AiiDA plugins and running continuous integration "
"tests using free platforms like `GitHub Actions <ghactions_>`_ is the best "
"way to ensure that your plugin works and keeps working as it is being "
"developed. We recommend using the `pytest`_ framework for testing AiiDA "
"plugins."
msgstr ""

#: ../../source/howto/plugins_develop.rst:141
msgid ""
"For an example of how to write tests and how to set up continuous "
"integration, see the `aiida-diff`_ demo plugin package."
msgstr "有关如何编写测试和如何设置持续集成的示例，请参见 `aiida-diff`_ 样例插件包。"

#: ../../source/howto/plugins_develop.rst:147
msgid ""
"We suggest the following folder structure for including tests in AiiDA "
"plugin packages::"
msgstr "我们建议使用以下文件夹结构在AiiDA插件包中包含测试:"

#: ../../source/howto/plugins_develop.rst:154
msgid ""
"Keeping the tests outside the plugin package keeps the distribution of your "
"plugin package light."
msgstr "将测试放在插件包之外可以使插件包的分发轻量化。"

#: ../../source/howto/plugins_develop.rst:157
msgid "AiiDA's fixtures"
msgstr "AiiDA的fixtures"

#: ../../source/howto/plugins_develop.rst:159
msgid ""
"Many tests require a full AiiDA environment to be set up before the test "
"starts, e.g. some AiiDA data nodes. The pytest library has the concept of "
"`fixtures`_ for encapsulating code you would like to run before a test "
"starts. AiiDA ships with a number of fixtures in "
":py:mod:`aiida.manage.tests.pytest_fixtures` that take care of setting up "
"the test environment for you (for more details, see "
":ref:`topics:plugins:testfixtures`)."
msgstr ""
"许多测试需要在测试开始之前设置完整的AiiDA环境，例如一些AiiDA数据节点。pytest库有 `fixture`_ "
"的概念，用于封装你想在测试开始前运行的代码。AiiDA在 :py:mod:`aiida.manage.tests.pytest_fixtures` "
"中附带了一些fixture，会负责为您设置测试环境(更多详细信息，请参阅 :ref:`topics:plugins:testfixtures` )。"

#: ../../source/howto/plugins_develop.rst:163
msgid ""
"In order to make these fixtures available to your tests, create a "
"``conftest.py`` (see also `pytest docs <conftest_>`_) at the root level of "
"your plugin package as follows::"
msgstr ""

#: ../../source/howto/plugins_develop.rst:181
msgid ""
"You can now start writing tests e.g. in a ``tests/test_calculations.py`` "
"file::"
msgstr "你现在可以开始编写测试了，例如在 ``tests/test_calculations.py`` 文件中::"

#: ../../source/howto/plugins_develop.rst:201
msgid ""
"In order to run your tests, simply type ``pytest`` at the root level or your"
" package. pytest automatically discovers and executes files, classes and "
"function names starting with the word ``test``."
msgstr "要运行测试，只需在根级别或您的包中键入 ``pytest`` 。Pytest自动发现并执行以 ``test`` 开头的文件、类和函数名。"

#: ../../source/howto/plugins_develop.rst:211
msgid "Documenting a plugin package"
msgstr "为插件包编制文档"

#: ../../source/howto/plugins_develop.rst:213
msgid ""
"AiiDA plugin packages are python packages, and general `best practises for "
"writing python documentation <https://docs.python-"
"guide.org/writing/documentation/>`_ apply."
msgstr ""
"AiiDA插件包是python包，通常遵循 `编写python文档的最佳实践 <https://docs.python-"
"guide.org/writing/documentation/>`_ 。"

#: ../../source/howto/plugins_develop.rst:215
msgid ""
"In the following, we mention a few hints that apply specifically to AiiDA "
"plugins."
msgstr "下面，我们将提到一些特别适用于AiiDA插件的提示"

#: ../../source/howto/plugins_develop.rst:218
msgid "Repository-level documentation"
msgstr "全代码仓库层次的文档"

#: ../../source/howto/plugins_develop.rst:220
msgid ""
"Since the source code of most AiiDA plugins is hosted on GitHub, the first "
"contact of a new user with your plugin package is likely the landing page of"
" your GitHub repository."
msgstr "由于大多数AiiDA插件的源代码都托管在GitHub上，所以使用你的插件包的新用户，第一个接触的很可能是你的GitHub库的登录页面。"

#: ../../source/howto/plugins_develop.rst:222
msgid ""
"Make sure to have a useful ``README.md``, describing what your plugin does "
"and how to install it."
msgstr "确保有一个有用的 ``README.md`` ，描述你的插件做什么和如何安装它。"

#: ../../source/howto/plugins_develop.rst:223
msgid "Leaving a contact email and adding a license is also a good idea."
msgstr "留下联系邮件并添加许可也是必要的。"

#: ../../source/howto/plugins_develop.rst:224
msgid ""
"Make sure the information in the ``pyproject.toml`` file is correct and up "
"to date (in particular the version number), since this information is used "
"to advertise your package on the AiiDA plugin registry."
msgstr ""

#: ../../source/howto/plugins_develop.rst:227
msgid "Source-code-level documentation"
msgstr "代码级别文档"

#: ../../source/howto/plugins_develop.rst:229
msgid ""
"Source-code level documentations matters both for users of your plugin's "
"python API and, particularly, for attracting contributions from others."
msgstr "源代码级别的文档对于插件的python API的用户来说很重要，特别是有助于吸引其他人的贡献。"

#: ../../source/howto/plugins_develop.rst:231
msgid ""
"When adding new types of calculations or workflows, make sure to use "
"`docstrings <https://www.python.org/dev/peps/pep-0257/#what-is-a-"
"docstring>`_, and use the ``help`` argument to document input ports and "
"output ports. Users of your plugin can then inspect which inputs the "
"calculations/workflows expect and which outputs they produce directly "
"through the ``verdi`` cli. For example, try::"
msgstr ""
"当添加新的算例类型或工作流时，请确保使用 `docstrings "
"<https://www.python.org/dev/peps/pep-0257/#what-is-a-docstring>`_ ，并使用 "
"``help`` 参数记录输入端口和输出端口。你的插件的用户可以通过 ``verdi`` "
"命令行接口检查算例/工作流期望的输入和他们直接产生的输出。例如,尝试运行:"

#: ../../source/howto/plugins_develop.rst:238
msgid "Documentation website"
msgstr "文档的网站"

#: ../../source/howto/plugins_develop.rst:240
msgid ""
"For simple plugins, a well-written ``README.md`` can be a good start. Once "
"the README grows out of proportion, you may want to consider creating a "
"dedicated documentation website."
msgstr "对于简单的插件，一个好的  ``README.md`` 是一个好的开始。一旦README变得很大，您可能需要考虑创建一个专门的文档网站。"

#: ../../source/howto/plugins_develop.rst:243
msgid ""
"The `Sphinx <http://www.sphinx-doc.org/en/master/>`_ tool makes it very easy"
" to create documentation websites for python packages, and the `ReadTheDocs "
"<http://readthedocs.org/>`_ service will host your sphinx documentation "
"online for free. The `aiida-diff demo plugin <aiida-diff_>`_ comes with a "
"full template for a sphinx-based documentation, including a mix of manually "
"written pages and an automatically generated documentation of your plugin's "
"python API. See the `developer guide of aiida-diff <https://aiida-"
"diff.readthedocs.io/en/latest/developer_guide/index.html>`_ for instructions"
" on how to build it."
msgstr ""

#: ../../source/howto/plugins_develop.rst:247
msgid ""
"AiiDA provides a sphinx extension for inserting automatically generated "
"documentations of ``Process`` classes (calculations and workflows) into your"
" sphinx documentation (analogous to the information displayed by ``verdi "
"plugin list``). Enable the extension by adding ``aiida.sphinxext`` to the "
"list of ``extensions`` in your ``docs/conf.py`` file. You can now use the "
"``aiida-process``, ``aiida-calcjob`` or ``aiida-workchain`` directives in "
"your ReST files like so::"
msgstr ""
"AiiDA提供了一个sphinx扩展，用于插入 ``Process`` 类(算例和工作流)的自动生成文档到你的sphinx文档(类似于 ``verdi "
"plugin list`` )。启用扩展添加 ``aiida.sphinxext`` 到 ``docs/conf.py`` 文件的 "
"``extensions`` 列表中。你现在可以在你的ReST文件中使用 ``aiida-process`` ， ``aiida-calcjob`` 或"
" ``aiida-workchain`` 指令，如下:"

#: ../../source/howto/plugins_develop.rst:255
msgid "Here,"
msgstr "这里，"

#: ../../source/howto/plugins_develop.rst:257
msgid "``MyWorkChain`` is the name of the workchain to be documented."
msgstr "``MyWorkChain`` 是要记录的工作链的名称。"

#: ../../source/howto/plugins_develop.rst:258
msgid ""
"``:module:`` is the python module from which the workchain can be imported."
msgstr "``:module:`` 是可以导入工作链的python模块。"

#: ../../source/howto/plugins_develop.rst:259
msgid ""
"``:hide-unstored-inputs:`` hides workchain inputs that are not stored in the"
" database (shown by default)."
msgstr "``:hide-unstored-inputs:`` 隐藏没有存储在数据库中的工作链输入(默认显示)。"

#: ../../source/howto/plugins_develop.rst:263
msgid ""
"The ``aiida-workchain`` directive is hooked into ``sphinx.ext.autodoc``, "
"i.e. it is used automatically by the generic ``automodule``, ``autoclass`` "
"directives when applied to workchain classes."
msgstr ""
"``aiida-workchain`` 指令被连接到 ``sphinx.ext.autodoc`` ，也就是说，当应用于工作链类时，它会被泛型 "
"``automodule`` 和 ``autoclass`` 指令自动使用。"

#: ../../source/howto/plugins_develop.rst:270
msgid "Publishing a plugin package"
msgstr "发布插件包"

#: ../../source/howto/plugins_develop.rst:272
msgid ""
"AiiDA plugin packages are published on the `AiiDA plugin registry "
"<registry_>`_ and the `python package index (PyPI) <pypi_>`_."
msgstr ""

#: ../../source/howto/plugins_develop.rst:274
msgid "Before publishing your plugin, make sure your plugin comes with:"
msgstr "在发布你的插件之前，确保你的插件带有:"

#: ../../source/howto/plugins_develop.rst:276
msgid ""
"a ``pyproject.toml`` file with the plugin metadata and for installing your "
"plugin via ``pip``"
msgstr ""

#: ../../source/howto/plugins_develop.rst:277
msgid "a license"
msgstr "一个软件许可证"

#: ../../source/howto/plugins_develop.rst:279
msgid ""
"For examples of these files, see the `aiida-diff demo plugin <aiida-"
"diff_>`_."
msgstr ""

#: ../../source/howto/plugins_develop.rst:284
msgid "Publishing on the plugin registry"
msgstr "在插件注册表上发布"

#: ../../source/howto/plugins_develop.rst:286
msgid ""
"The `AiiDA plugin registry <registry_>`_ aims to be the home for all "
"publicly available AiiDA plugins. It collects information on the type of "
"plugins provided by your package, which AiiDA versions it is compatible "
"with, etc."
msgstr ""

#: ../../source/howto/plugins_develop.rst:289
msgid ""
"In order to register your plugin package, simply go to the `plugin registry "
"<registry_>`_ and follow the instructions in the README."
msgstr ""

#: ../../source/howto/plugins_develop.rst:293
msgid ""
"The plugin registry reads the metadata of your plugin from the "
"``pyproject.toml`` file in your plugin repository."
msgstr ""

#: ../../source/howto/plugins_develop.rst:296
msgid ""
"We encourage you to **get your plugin package listed as soon as possible**, "
"both in order to reserve the plugin name and to inform others of the ongoing"
" development."
msgstr "我们鼓励您 **尽快列出您的插件包** ，这既是为了保留插件名称，也是为了告知其他人正在进行的开发。"

#: ../../source/howto/plugins_develop.rst:299
msgid "Publishing on PyPI"
msgstr "PyPI上发布"

#: ../../source/howto/plugins_develop.rst:301
msgid ""
"For distributing AiiDA plugin packages, we recommend to follow the "
"`guidelines for packaging python projects <packaging_>`_, which include "
"making the plugin available on the `python package index <PyPI_>`_. This "
"makes it possible for users to simply ``pip install aiida-myplugin``."
msgstr ""

#: ../../source/howto/plugins_install.rst:5
msgid "How to install plugins"
msgstr "如何安装插件"

#: ../../source/howto/plugins_install.rst:7
msgid ""
"The functionality of AiiDA can be extended through plugins. There are "
"various types of functionality that can be extended, such as new :ref:`data "
"types<topics:data_types:plugin>`, :ref:`calculation plugins<how-to:plugin-"
"codes>` and much more. Multiple plugins can be bundled together and "
"distributed in a :ref:`plugin package<how-to:plugins-develop>`. The `AiiDA "
"plugin registry <https://aiidateam.github.io/aiida-registry>`_ gives an "
"overview of public plugin packages."
msgstr ""
"AiiDA的功能可以通过插件进行扩展。有各种类型的功能可以扩展，如新的 :ref:`数据类型 <topics:data_types:plugin>` ，"
" :ref:`算例插件 <how-to:plugin-codes>` 等等。多个插件可以捆绑在一起，并在一个 :ref:`插件包 <how-"
"to:plugins-develop>` 中分发。 `AiiDA插件注册表 <https://aiidateam.github.io/aiida-"
"registry>`_ 给出了公共插件包的概述。"

#: ../../source/howto/plugins_install.rst:12
msgid ""
"Installing an AiiDA plugin package is done with `pip "
"<https://pypi.org/project/pip/>`_. If the package is distributed via the "
"`Python Package Index (PyPI) <https://pypi.org/search/?q=aiida>`_ you can "
"install it as follows:"
msgstr ""
"安装AiiDA插件包是通过 `pip <https://pypi.org/project/pip/>`_ 完成的。如果该包是通过 `Python "
"Package Index (PyPI) <https://pypi.org/search/?q=aiida>`_  分发的，你可以按照如下方式安装它:"

#: ../../source/howto/plugins_install.rst:19
msgid ""
"A package can also be installed from the source code. For example, if the "
"code is available through a Git repository:"
msgstr "也可以从源代码安装包。例如，如果源代码可以通过Git存储库获得:"

#: ../../source/howto/plugins_install.rst:30
msgid ""
"If your daemon was running when installing or updating a plugin package, "
"make sure to restart it with the ``--reset`` flag for changes to take "
"effect:"
msgstr "如果你的守护进程在安装或更新一个插件包时处于运行状态，请确保使用 ``--reset`` 标志重启它使更改生效:"

#: ../../source/howto/plugins_install.rst:36
msgid "To verify which plugins are currently installed, use the command:"
msgstr "要验证当前安装了哪些插件，可以使用以下命令:"

#: ../../source/howto/plugins_install.rst:42
msgid ""
"It will list the various categories of functionality that can be extended "
"through plugins. To see which plugins are installed for any of these "
"categories, pass the category name as an argument, e.g.:"
msgstr "它将列出可以通过插件扩展的各种功能类别。要查看这些类别中安装了哪些插件，请传递类别名称作为参数，例如:"

#: ../../source/howto/query.rst:5
msgid "How to find and query for data"
msgstr ""

#: ../../source/howto/query.rst:7
msgid ""
"An AiiDA database stores a graph of connected entities, which can be "
"*queried* with the :class:`~aiida.orm.querybuilder.QueryBuilder` class."
msgstr ""

#: ../../source/howto/query.rst:9
msgid "Before starting to write a query, it helps to:"
msgstr ""

#: ../../source/howto/query.rst:0
msgid "Know what you want to query for."
msgstr ""

#: ../../source/howto/query.rst:0
msgid ""
"In the language of databases, you need to tell the backend what *entity* you"
" are looking for and optionally which of its properties you want to "
"*project*."
msgstr ""

#: ../../source/howto/query.rst:0
msgid ""
"For example, you might be interested in the label of a calculation and the "
"PKs of all its outputs."
msgstr ""

#: ../../source/howto/query.rst:0
msgid "Know the relationships between entities you are interested in."
msgstr ""

#: ../../source/howto/query.rst:0
msgid "Nodes of an AiiDA graph (vertices) are connected with links (edges)."
msgstr ""

#: ../../source/howto/query.rst:0
msgid ""
"A node can for example be either the input or output of another node, but "
"also an ancestor or a descendant."
msgstr ""

#: ../../source/howto/query.rst:0
msgid "Know how you want to filter the results of your query."
msgstr "知道您希望如何过滤查询结果。"

#: ../../source/howto/query.rst:19
msgid ""
"Once you are clear about what you want and how you can get it, the "
":class:`~aiida.orm.querybuilder.QueryBuilder` will build an SQL-query for "
"you."
msgstr ""
"一旦你清楚了你想要什么和你如何能得到它， :class:`~aiida.orm.querybuilder.QueryBuilder` "
"将为您构建一个sql查询。"

#: ../../source/howto/query.rst:21
msgid ""
"There are two ways of using the "
":class:`~aiida.orm.querybuilder.QueryBuilder`:"
msgstr "有两种使用 :class:`~aiida.orm.querybuilder.QueryBuilder` 的方法:"

#: ../../source/howto/query.rst:23
msgid ""
"In the *appender* method, you construct your query step by step using the "
"``QueryBuilder.append()`` method."
msgstr "在 *追加查询条件* 的方法中，使用 `QueryBuilder.append()``  方法逐步构造查询。"

#: ../../source/howto/query.rst:24
msgid ""
"In the *dictionary* approach, you construct a dictionary that defines your "
"query and pass it to the :class:`~aiida.orm.querybuilder.QueryBuilder`."
msgstr ""

#: ../../source/howto/query.rst:26
msgid ""
"Both APIs provide the same functionality - the appender method may be more "
"suitable for interactive use, e.g., in the ``verdi shell``, whereas the "
"dictionary method can be useful in scripting. In this section we will focus "
"on the basics of the appender method. For more advanced queries or more "
"details on the query dictionary, see the :ref:`topics section on advanced "
"querying <topics:database:advancedquery>`."
msgstr ""

#: ../../source/howto/query.rst:33
msgid "Selecting entities"
msgstr "选择查询实体"

#: ../../source/howto/query.rst:35
msgid ""
"Using the ``append()`` method of the "
":class:`~aiida.orm.querybuilder.QueryBuilder`, you can query for the "
"entities you are interested in. Suppose you want to query for calculation "
"job nodes in your database:"
msgstr ""
"使用 :class:`~aiida.orm.querybuilder.QueryBuilder` 的``append()`` "
"方法，你可以查询你感兴趣的实体。假设您想查询数据库中的「算例」作业节点:"

#: ../../source/howto/query.rst:44
msgid ""
"If you are interested in instances of different classes, you can also pass "
"an iterable of classes. However, they have to be of the same ORM-type (e.g. "
"all have to be subclasses of :class:`~aiida.orm.nodes.node.Node`):"
msgstr ""
"如果您对不同类的实例感兴趣，您也可以传递一个类的可迭代对象。但是，它们必须是相同的ORM类型(例如，必须是 "
":class:`~aiida.orm.nodes.node.Node` 的子类):"

#: ../../source/howto/query.rst:54
msgid ""
"Processes have both a run-time "
":class:`~aiida.engine.processes.process.Process` that executes them and a "
":class:`~aiida.orm.nodes.node.Node` that stores their data in the database "
"(see the :ref:`corresponding topics "
"section<topics:processes:concepts:types>` for a detailed explanation). The "
":class:`~aiida.orm.querybuilder.QueryBuilder` allows you to pass either the "
":class:`~aiida.orm.nodes.node.Node` class (e.g. "
":class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode`) or the "
":class:`~aiida.engine.processes.process.Process` class (e.g. "
":class:`~aiida.engine.processes.calcjobs.calcjob.CalcJob`), which will "
"automatically select the right entity for the query. Using either "
":class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode` or "
":class:`~aiida.engine.processes.calcjobs.calcjob.CalcJob` will produce the "
"same query results."
msgstr ""
"「列程」都有一个运行时:class:`~aiida.engine.processes.process.Process` 用以执行进程和一个 "
":class:`~aiida.orm.nodes.node.Node` 其将数据存储在数据库中(详细说明请参见 "
":ref:`相应的主题部分<topics:processes:concepts:types>`)。:类 "
":class:`~aiida.orm.querybuilder.QueryBuilder` "
"允许你传递:class:`~aiida.orm.nodes.node.Node` "
"类(例如:class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode` "
")或::class:`~aiida.engine.processes.process.Process` "
"类(例如:class:`~aiida.engine.processes.calcjobs.calcjob.CalcJob`)，它将自动为查询选择正确的数据实体。使用:class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode`"
" 或 :class:`~aiida.engine.processes.calcjobs.calcjob.CalcJob` 将产生相同的查询结果。"

#: ../../source/howto/query.rst:61
msgid "Retrieving results"
msgstr "结果检索"

#: ../../source/howto/query.rst:63
msgid ""
"Once you have *appended* the entity you want to query for to the "
":class:`~aiida.orm.querybuilder.QueryBuilder`, the next question is how to "
"get the results. There are several ways to obtain data from a query:"
msgstr ""
"一旦你将你想要查询的实体 *缀加* 到 "
":class:`~aiida.orm.querybuilder.QueryBuilder`，下一个问题是如何得到结果。有几种方法可以从查询中获取数据:"

#: ../../source/howto/query.rst:77
msgid ""
"In case you are working with a large dataset, you can also return your query"
" as a generator:"
msgstr "如果你正在处理一个大型数据集，你可以返回你的查询作为一个生成器:"

#: ../../source/howto/query.rst:85
msgid ""
"This will retrieve the data in batches, and you can start working with the "
"data before the query has completely finished. For example, you can iterate "
"over the results of your query in a for loop:"
msgstr "这将批量检索数据，您可以在查询完全完成之前开始处理数据。例如，你可以在For循环中遍历你的查询结果:"

#: ../../source/howto/query.rst:96
msgid "Filters"
msgstr "过滤器"

#: ../../source/howto/query.rst:98
msgid ""
"Usually you do not want to query for *all* entities of a certain class, but "
"rather *filter* the results based on certain properties. Suppose you do not "
"want all :class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode` "
"data, but only those that are ``finished``:"
msgstr ""
"通常您不希望查询某个类的 *所有* "
"数据实体，而是根据某些属性*过滤*结果。假设您不需要所有:class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode`"
" ，而只有那些是 ``finished`` 状态的数据:"

#: ../../source/howto/query.rst:111
msgid ""
"You can apply multiple filters to one entity in a query. Say you are "
"interested in all calculation jobs in your database that are ``finished`` "
"**and** have ``exit_status == 0``:"
msgstr ""
"可以对查询中的一个实体应用多个筛选器。假设你对数据库中所有已经 ``完成`` 的并且有 ``exit_status == 0`` 的计算作业感兴趣，:"

#: ../../source/howto/query.rst:125
msgid ""
"In case you want to query for calculation jobs that satisfy one of these "
"conditions, you can use the ``or`` operator:"
msgstr "如果你想查询只要满足其中一个条件的「算例」作业，你可以使用 ``or`` 操作符:"

#: ../../source/howto/query.rst:140
msgid ""
"If we had written ``and`` instead of ``or`` in the example above, we would "
"have performed the exact same query as the previous one, because ``and`` is "
"the default behavior if you provide several filters as key-value pairs in a "
"dictionary to the ``filters`` argument. In case you want all calculation "
"jobs with state ``finished`` or ``excepted``, you can also use the ``in`` "
"operator:"
msgstr ""
"如果我们在上面的例子中写了``and``而不是 ``or``，我们将执行与前一个完全相同的查询，因为 "
"``and``是默认的行为，如果你在字典中为'``filters``参数提供几个键值对的过滤器。如果你想要所有状态为``finished``或``excepted``的计算作业，你也可以使用"
" ``in`` 操作符:"

#: ../../source/howto/query.rst:153
msgid ""
"You can negate a filter by adding an exclamation mark in front of the "
"operator. So, to query for all calculation jobs that are not a ``finished`` "
"or ``excepted`` state:"
msgstr "可以通过在运算符前添加感叹号来否定过滤器。因此，要查询所有状态不为``finished`` 或 ``excepted``的计算作业:"

#: ../../source/howto/query.rst:168
msgid ""
"The above rule applies to all operators. For example, you can check non-"
"equality with ``!==``, since this is the equality operator (``==``) with a "
"negation prepended."
msgstr "上述规则适用于所有操作符。例如，你可以用``!==`` 来作不等价操作，因为这是带有否定前缀的相等操作符(``==``)。"

#: ../../source/howto/query.rst:171
msgid ""
"A complete list of all available operators can be found in the "
":ref:`advanced querying "
"section<topics:database:advancedquery:tables:operators>`."
msgstr ""
"所有可用运算符的完整列表可以在:ref:`高级查询部分<topics:database:advancedquery:tables:operators>`中找到。"

#: ../../source/howto/query.rst:176
msgid "Relationships"
msgstr "关系查找"

#: ../../source/howto/query.rst:178
msgid ""
"It is possible to query for data based on its relationship to another entity"
" in the database. Imagine you are not interested in the calculation jobs "
"themselves, but in one of the outputs they create. You can build upon your "
"initial query for all  "
":class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode`'s in the "
"database using the relationship of the output to the first step in the "
"query:"
msgstr ""
"可以根据数据与数据库中另一个实体的关系来查询数据。假设您对算例作业本身不感兴趣，而是对它们创建的一个输出感兴趣。你可以对所有 "
":class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode` "
"建立你的初始查询，在数据库中使用输出到查询的第一步的关系:"

#: ../../source/howto/query.rst:188
msgid ""
"In the first ``append`` call, we query for all  "
":class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode`'s in the "
"database, and *tag* this step with the *unique* identifier ``'calcjob'``. "
"Next, we look for all ``Int`` nodes that are an output of the  "
":class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode`'s found in"
" the first step, using the ``with_incoming`` relationship argument. The "
"``Int`` node was created by the  "
":class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode` and as "
"such has an *incoming* create link."
msgstr ""
"在第一个``append``调用中，我们查询所有:class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode`，并"
" *标记* 这一步与 *唯一* 标识符 ``'calcjob'`` "
"。接下来，我们寻找::class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode`'"
" 输出的所有 ``Int`` 节点。使用 ``with_incoming`` 关系参数。``Int`` 节点是由 "
":class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode` 创建的并与之有一个 "
"*incoming* 创建类型的链接。"

#: ../../source/howto/query.rst:192
msgid ""
"In the context of our query, we are building a *path* consisting of "
"*vertices* (i.e. the entities we query for) connected by *edges* defined by "
"the relationships between them. The complete set of all possible "
"relationships you can use query for, as well as the entities that they "
"connect to, can be found in the :ref:`advanced querying "
"section<topics:database:advancedquery:tables:relationships>`."
msgstr ""
"在我们的查询上下文中，我们构建了一个由*顶点*(即我们要查询的实体)组成的 *路径* ，这些顶点由 *边* "
"(由它们之间的关系定义)连接。你可以使用query查询所有可能的关系的完整集合，以及它们连接到的实体，更多相关指令可以在 :ref:`进阶查找章节 "
"<topics:database:advancedquery:tables:relationships>`中找到。"

#: ../../source/howto/query.rst:197
msgid ""
"The ``tag`` identifier can be any alphanumeric string, it is simply a label "
"used to refer to a previous vertex along the query path when defining a "
"relationship."
msgstr " ``tag`` 标识符可以是任何字母数字字符串，它只是一个标签，用于在定义关系时引用查询路径上的前一个顶点。"

#: ../../source/howto/query.rst:202
msgid "Projections"
msgstr "投影"

#: ../../source/howto/query.rst:204
msgid ""
"By default, the :class:`~aiida.orm.querybuilder.QueryBuilder` returns the "
"instances of the entities corresponding to the final append to the query "
"path. For example:"
msgstr ""
"默认情况下，:class:`~aiida.orm.querybuilder.QueryBuilder` "
"返回与查询路径的最终附加项相对应的实体实例。例如:"

#: ../../source/howto/query.rst:213
msgid ""
"The above code snippet will return all ``Int`` nodes that are outputs of any"
"  :class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode`. "
"However, you can also *project* other entities in the path by adding "
"``project='*'`` to the corresponding ``append()`` call:"
msgstr ""
"上面的代码片段将返回所有``Int``节点，它们是 "
":class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode` "
"的输出。但是，你也可以通过在对应的``append()`` 调用中添加``project='*'``来 *投影* 路径中的其他实体:"

#: ../../source/howto/query.rst:222
msgid ""
"This will return all  "
":class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode`'s that "
"have an ``Int`` output node."
msgstr ""
"这将返回所有，有一个 ``Int`` "
"输出节点的:class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJob"

#: ../../source/howto/query.rst:224
msgid ""
"However, in many cases we are not interested in the entities themselves, but"
" rather their PK, UUID, *attributes* or some other piece of information "
"stored by the entity. This can be achieved by providing the corresponding "
"*column* to the ``project`` keyword argument:"
msgstr ""
"然而，在许多情况下，我们对实体本身并不感兴趣，而是对它们的PK、UUID、 *属性* "
"或实体存储的其他一些信息感兴趣。这可以通过向``project``关键字参数提供相应的 *列* 来实现:"

#: ../../source/howto/query.rst:233
msgid ""
"In the above example, executing the query returns all *PK's* of the ``Int`` "
"nodes which are outputs of all  "
":class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode`'s in the "
"database. Moreover, you can project more than one piece of information for "
"one vertex by providing a list:"
msgstr ""
"在上面的例子中，执行查询返回``Int``节点的所有:class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode`"
" 类的 *主键PK* ，此外，你可以通过提供一个列表来为一个顶点投射多个信息:"

#: ../../source/howto/query.rst:242
msgid ""
"For the query above, ``qb.all()`` will return a list of lists, for which "
"each element corresponds to one entity and contains two items: the PK of the"
" ``Int`` node and its value. Finally, you can project information for "
"multiple vertices along the query path:"
msgstr ""
"对于上面的查询，``qb.all()`` 将返回一个列表的列表，其中每个元素对应于一个实体并包含两项: ``Int`` "
"节点的PK及其值。最后，你可以沿着查询路径投影多个顶点的信息:"

#: ../../source/howto/query.rst:251
msgid ""
"All projections must start with one of the *columns* of the entities in the "
"database, or project the instances themselves using ``'*'``. Examples of "
"columns we have encountered so far are ``id``, ``uuid`` and ``attributes``. "
"If the column is a dictionary, you can expand the dictionary values using a "
"dot notation, as we have done in the previous example to obtain the "
"``attributes.value``. This can be used to project the values of nested "
"dictionaries as well."
msgstr ""
"所有投影必须以数据库中实体的 *列* 之一开始，或者使用``'*'`` 投影实例本身。到目前为止，我们遇到的列的例子是``id``, ``uuid`` "
"和 "
"``attributes``。如果列是一个字典，您可以使用点号展开字典值，就像我们在前面的示例中所做的那样，以获得``attributes.value``。这还可以用于投影嵌套字典的值。"

#: ../../source/howto/query.rst:258
msgid ""
"Be aware that for consistency, ``QueryBuilder.all()`` / ``iterall()`` always"
" returns a list of lists, even if you only project one property of a single "
"entity. Use ``QueryBuilder.all(flat=True)`` to return the query result as a "
"flat list in this case."
msgstr ""
"请注意，为了一致性，``QueryBuilder.all()`` / ``iterall()`` "
"总是返回列表的列表，即使您只投射单个实体的一个属性。在本例中，使用 ``QueryBuilder.all(flat=True)`` "
"以平面列表的形式返回查询结果。"

#: ../../source/howto/query.rst:261
msgid ""
"As mentioned in the beginning, this section provides only a brief "
"introduction to the :class:`~aiida.orm.querybuilder.QueryBuilder`'s basic "
"functionality. To learn about more advanced queries, please see :ref:`the "
"corresponding topics section<topics:database:advancedquery>`."
msgstr ""
"正如前面提到的，本节只提供了对:class:`~aiida.orm.querybuilder.QueryBuilder`的简要介绍。要了解更多高级查询，请参见:ref:`相应的主题部分<topics:database:advancedquery>`。"

#: ../../source/howto/query.rst:269
msgid "Shortcuts"
msgstr ""

#: ../../source/howto/query.rst:271
msgid ""
"The :class:`~aiida.orm.querybuilder.QueryBuilder` is the generic way of "
"querying for data in AiiDA. For certain common queries, shortcuts have been "
"added to the AiiDA python API to save you a couple of lines of code."
msgstr ""

#: ../../source/howto/query.rst:277
msgid "Incoming and outgoing links"
msgstr "数据输入和数据输出链接"

#: ../../source/howto/query.rst:279
msgid ""
"The provenance graph in AiiDA is a :ref:`directed graph "
"<topics:provenance:concepts>`. The vertices of the graph are the *nodes*, "
"and the edges that connect them are called *links*. Since the graph is "
"directed, any node can have *incoming* and *outgoing* links that connect it "
"to neighboring nodes."
msgstr ""
"AiiDA中的可验证性图是一个 :ref:`有向图 <topics:provenance:concepts>`。图的顶点是 *节点* "
"，连接它们的边称为*链接*。由于图是有向的，任何节点都可以有连接到邻近节点的 *输入* 和 *输出* 链接。"

#: ../../source/howto/query.rst:283
msgid ""
"To discover the neighbors of a given node, you can use the methods "
":meth:`~aiida.orm.nodes.links.NodeLinks.get_incoming` and "
":meth:`~aiida.orm.nodes.links.NodeLinks.get_outgoing`. They have the exact "
"same interface but will return the neighbors connected to the current node "
"with a link coming into it or with links going out of it, respectively. For "
"example, for a given ``node``, to inspect all the neighboring nodes from "
"which a link is incoming to the ``node``:"
msgstr ""

#: ../../source/howto/query.rst:291
msgid ""
"This will return an instance of the "
":class:`~aiida.orm.utils.links.LinkManager`. From that manager, you can "
"request the results in a specific format. If you are only interested in the "
"neighboring nodes themselves, you can call the "
":class:`~aiida.orm.utils.links.LinkManager.all_nodes` method:"
msgstr ""
"这将返回 :class:`~aiida.orm.utils.links.LinkManager` "
"的一个实例。从该管理器中，您可以以特定格式请求结果。如果你只对相邻节点本身感兴趣，你可以调用 "
":class:`~aiida.orm.utils.links.LinkManager.all_nodes`  方法:"

#: ../../source/howto/query.rst:299
msgid ""
"This will return a list of :class:`~aiida.orm.nodes.node.Node` instances "
"that correspond to the nodes that are neighbors of ``node``, where the link "
"is going towards ``node``. Calling the "
":meth:`~aiida.orm.utils.links.LinkManager.all` method of the manager instead"
" will return a list of :class:`~aiida.orm.utils.links.LinkTriple` named "
"tuples. These tuples contain, in addition to the neighboring node, also the "
"link label and the link type with which they are connected to the origin "
"``node``. For example, to list all the neighbors of a node from which a link"
" is incoming:"
msgstr ""
"这将返回一个 :class:`~aiida.orm.nodes.node.Node`  的列表。``node`` 实例对应的节点是 ``node`` "
"的邻居，在那里链接是指向 ``node`` 的。调用 :meth:`~aiida.orm.utils.links.LinkManager.all` "
"将返回一个由 :class:`~aiida.orm.utils.links.LinkTriple`  "
"元组组成的列表。这些元组除了包含邻近节点外，还包含链接标签和链接类型，它们是用这些链接连接到原始节点的。例如，若要列出一个链接进入的节点的所有邻居，可以使用:"

#: ../../source/howto/query.rst:309
msgid ""
"Note that the :class:`~aiida.orm.utils.links.LinkManager` provides many "
"convenience methods to get information from the neigboring nodes, such as "
":meth:`~aiida.orm.utils.links.LinkManager.all_link_labels` if you only need "
"the list of link labels."
msgstr ""
"注意  :class:`~aiida.orm.utils.links.LinkManager` "
"提供了许多方便的方法来从邻近的节点获取信息，例如，如果你只需要链接标签的列表你可以使用 "
":meth:`~aiida.orm.utils.links.LinkManager.all_link_labels` 。"

#: ../../source/howto/query.rst:311
msgid ""
"The :meth:`~aiida.orm.nodes.links.NodeLinks.get_incoming` and "
":meth:`~aiida.orm.nodes.links.NodeLinks.get_outgoing` methods accept various"
" arguments that allow one to filter what neighboring nodes should be "
"matched:"
msgstr ""

#: ../../source/howto/query.rst:313
msgid ""
"``node_class``: accepts a subclass of :class:`~aiida.orm.nodes.node.Node`, "
"only neighboring nodes with a class that matches this will be returned"
msgstr ""
"``node_class``: 接受 :class:`~aiida.orm.nodes.node.Node` 的子类，只有与该类匹配的相邻节点才会被返回"

#: ../../source/howto/query.rst:314
msgid ""
"``link_type``: accepts a value of :class:`~aiida.common.links.LinkType`, "
"only neighboring nodes that are linked with this link type will be returned"
msgstr ""
"``link_type``: 接受值 :class:`~aiida.common.links.LinkType` "
"，只有与此链接类型相连的邻居节点才会返回"

#: ../../source/howto/query.rst:315
msgid ""
"``link_label_filter``: accepts a string  expression (with optional wildcards"
" using the syntax of SQL ``LIKE`` patterns, see below), only neighboring "
"nodes that are linked with a link label that matches the pattern will be "
"returned"
msgstr ""
"``link_label_filter`` :接受字符串表达式(使用SQL ``LIKE`` "
"模式的语法使用可选通配符，见下文)，只有与匹配的链接标签连接的邻近节点将被返回"

#: ../../source/howto/query.rst:317
msgid "As an example:"
msgstr "作为一个例子:"

#: ../../source/howto/query.rst:323
msgid ""
"will return only neighboring data nodes that are linked to the ``node`` with"
" a link of type ``LinkType.INPUT_CALC`` and where the link label matches the"
" pattern ``'output%node_'``. Reminder on the syntax of SQL `LIKE` patterns: "
"the ``%`` character matches any string of zero or more characters, while the"
" ``_`` character matches exactly one character. These two special characters"
" can be escaped by prepending them with a backslash (note that when putting "
"a backslash in a Python string you have to escape the backslash itself, so "
"you will need two backslashes: e.g., to match exactly a link label ``a_b`` "
"you need to pass ``link_label_filter='a\\\\_b'``)."
msgstr ""
"将只返回链接到  ``node`` 链接类型为``LinkType.INPUT_CALC``  的相邻数据节点，且其链接标签匹配 "
"``'output%node_'``  。提示SQL `LIKE` 模式的语法: ``%``  字符匹配任何零或多个字符的字符串，而  ``_`` "
"字符只匹配一个字符。这两个特殊字符可以通过将反斜杠转义(注意，一个Python字符串中的反斜杠必须用反斜杠转义，所以你将需要两个反斜杠：例如,完全匹配一个链接标签"
" ``a_b`` 你需要使用 ``link_label_filter='a\\\\_b'`` )."

#: ../../source/howto/query.rst:331
msgid "Inputs and outputs of processes"
msgstr ""

#: ../../source/howto/query.rst:333
msgid ""
"The :meth:`~aiida.orm.nodes.links.NodeLinks.get_incoming` and "
":meth:`~aiida.orm.nodes.links.NodeLinks.get_outgoing` methods, described in "
"the :ref:`previous section <how-to:query:shortcuts:incoming-outgoing>`, can "
"be used to access all neighbors from a certain node and provide advanced "
"filtering options. However, often one doesn't need this expressivity and "
"simply wants to retrieve all neighboring nodes with a syntax that is as "
"succint as possible. A prime example is to retrieve the *inputs* or "
"*outputs* of :ref:`a process <topics:processes:concepts>`. Instead of using "
":meth:`~aiida.orm.nodes.links.NodeLinks.get_incoming` and "
":meth:`~aiida.orm.nodes.links.NodeLinks.get_outgoing`, to get the inputs and"
" outputs of a ``process_node`` one can do:"
msgstr ""

#: ../../source/howto/query.rst:343
msgid ""
"These properties do not return the actual inputs and outputs directly, but "
"instead return an instance of "
":class:`~aiida.orm.utils.managers.NodeLinksManager`. The reason is because "
"through the manager, the inputs or outputs are accessible through their link"
" label (that, for inputs and outputs of processes, is unique) and can be "
"tab-completed. For example, if the ``process_node`` has an output with the "
"label ``result``, it can be retrieved as:"
msgstr ""
"这些属性不直接返回实际的输入和输出，而是返回 :class:`~aiida.orm.utils.managers.NodeLinksManager` "
"。这是因为通过管理器类，输入或输出可以通过它们的链接标签访问(对于过程的输入和输出来说，链接标签是惟一的)，并且可以用tab补全。例如，如果 "
"``process_node`` 有一个带有``result`` 标签的输出，它可以被检索为:"

#: ../../source/howto/query.rst:351
msgid "The inputs or outputs can also be accessed through key dereferencing:"
msgstr "输入或输出也可以通过键引用来访问:"

#: ../../source/howto/query.rst:357
msgid ""
"If there is no neighboring output with the given link label, a "
":class:`~aiida.common.exceptions.NotExistentAttributeError` or "
":class:`~aiida.common.exceptions.NotExistentKeyError` will be raised, "
"respectively."
msgstr ""
"如果没有与给定链接标签相邻的输出，将分别引发 "
":class:`~aiida.common.exceptions.NotExistentAttributeError` 或 "
":class:`~aiida.common.exceptions.NotExistentKeyError` 。"

#: ../../source/howto/query.rst:361
msgid ""
"The ``inputs`` and ``outputs`` properties are only defined for "
":class:`~aiida.orm.nodes.process.process.ProcessNode`'s. This means that you"
" cannot *chain* these calls, because an input or output of a process node is"
" guaranteed to be a :class:`~aiida.orm.Data` node, which does not have "
"inputs or outputs."
msgstr ""

#: ../../source/howto/query.rst:368
msgid "Creator, caller and called"
msgstr "创建器，调用者和调用"

#: ../../source/howto/query.rst:370
msgid ""
"Similar to the ``inputs`` and ``outputs`` properties of process nodes, there"
" are some more properties that make exploring the provenance graph easier:"
msgstr "类似于例程节点的 ``inputs`` 和 ``outputs`` 属性，有更多的属性可以帮助更容易地探索可验证性图:"

#: ../../source/howto/query.rst:372
msgid ""
":meth:`~aiida.orm.nodes.process.process.ProcessNode.called`: defined for "
":class:`~aiida.orm.nodes.process.process.ProcessNode`'s and returns the list"
" of process nodes called by this node. If this process node did not call any"
" other processes, this property returns an empty list."
msgstr ""
":meth:`~aiida.orm.nodes.process.process.ProcessNode.called` 为 "
":class:`~aiida.orm.nodes.process.process.ProcessNode` "
"所定义。并返回此节点调用的例程节点列表。如果此例程节点没有调用任何其他进程，则此属性返回一个空列表。"

#: ../../source/howto/query.rst:374
msgid ""
":meth:`~aiida.orm.nodes.process.process.ProcessNode.caller`: defined for "
":class:`~aiida.orm.nodes.process.process.ProcessNode`'s and returns the "
"process node that called this node. If this node was not called by a "
"process, this property returns ``None``."
msgstr ""
":meth:`~aiida.orm.nodes.process.process.ProcessNode.caller` 为 "
":class:`~aiida.orm.nodes.process.process.ProcessNode` "
"所定义。并返回此节点调用的例程节点列表。如果此例程节点没有被任何其他进程调用，则此属性返回一个``None``。"

#: ../../source/howto/query.rst:376
msgid ""
":meth:`~aiida.orm.Data.creator`: defined for :class:`~aiida.orm.Data` nodes "
"and returns the process node that created it. If the node was not created by"
" a process, this property returns ``None``."
msgstr ""

#: ../../source/howto/query.rst:381
msgid ""
"Using the ``creator`` and ``inputs`` properties, one can easily move *up* "
"the provenance graph. For example, starting from some data node that "
"represents the result of a long workflow, one can move up the provenance "
"graph to find an initial input node of interest: "
"``result.creator.inputs.some_input.creator.inputs.initial_input``."
msgstr ""
"使用 ``creator`` 和 ``inputs`` 属性，可以轻松地 *向上* "
"回溯可验证性图。例如，从某个表示长工作流结果的数据节点开始，可以向上回溯可验证性图，找到感兴趣的初始输入节点: "
"``result.creator.inputs.some_input.creator.inputs.initial_input`` 。"

#: ../../source/howto/query.rst:387
msgid "Calculation job results"
msgstr "算例任务的结果"

#: ../../source/howto/query.rst:389
msgid ""
":class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode`'s provide "
"the :meth:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.res` "
"property, that can give easy access to the results of the calculation job. "
"The requirement is that the "
":class:`~aiida.engine.processes.calcjobs.calcjob.CalcJob` class that "
"produced the node, defines a *default output node* in its spec. This node "
"should be a :class:`~aiida.orm.nodes.data.dict.Dict` output that will always"
" be created. An example is the "
":class:`~aiida.calculations.templatereplacer.TemplatereplacerCalculation` "
"plugin, that has the ``output_parameters`` output that is specified as its "
"default output node."
msgstr ""
":class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode` 提供 "
":meth:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.res`  "
"的性质，可以很容易地访问算例任务的结果。前提是 "
":class:`~aiida.engine.processes.calcjobs.calcjob.CalcJob`  类在其spec中定义了一个 "
"*默认输出节点* 。将总是创建的 :class:`~aiida.orm.nodes.data.dict.Dict` 输出。一个例子是 "
":class:`~aiida.calculations.templatereplacer.TemplatereplacerCalculation` 它有"
"  ``output_parameters`` 输出，被指定为它的默认输出节点。"

#: ../../source/howto/query.rst:394
msgid ""
"The :meth:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.res` "
"property will give direct easy access to all the keys within this dictionary"
" output. For example, the following:"
msgstr ""
":meth:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.res` "
"的属性可以直接方便地访问这个字典输出中的所有键。例如:"

#: ../../source/howto/query.rst:401
msgid ""
"will return a list of all the keys in the output node. Individual keys can "
"then be accessed through attribute dereferencing:"
msgstr "将返回输出节点中所有键的列表。然后可以通过属性引用来访问单个键:"

#: ../../source/howto/query.rst:408
msgid ""
"In an interactive shell, the available keys are also tab-completed. If you "
"type ``node.res.`` followed by the tab key twice, a list of the available "
"keys is printed."
msgstr ""
"在交互式shell中，可用的键也是可用tab补全的。如果您键入 ``node.res.`` 后面跟着TAB键两次，可用键的列表将被显示出来。"

#: ../../source/howto/query.rst:413
msgid ""
"The :meth:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.res` "
"property is really just a shortcut to quickly and easily access an attribute"
" of the default output node of a calculation job. For example, if the "
"default output node link label is ``output_parameters``, then "
"``node.res.some_key`` is exactly equivalent to "
"``node.outputs.output_parameters.dict.some_key``. That is to say, when using"
" ``res``, one is accessing attributes of one of the output nodes, and not of"
" the calculation job node itself."
msgstr ""
":meth:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.res` "
"属性实际上只是快速方便地访问算例任务的默认输出节点的属性的快捷方式。例如，如果默认输出节点链接标签为 ``output_parameters``，则  "
"``node.res.some_key`` 完全等价于 ``node.outputs.output_parameters.dict.some_key``"
" 。也就是说，当使用  ``res`` 时，访问的是一个输出节点的属性，而不是算例任务节点本身的属性。"

#: ../../source/howto/run_codes.rst:5
msgid "How to run external codes"
msgstr "如何运行外部计算代码"

#: ../../source/howto/run_codes.rst:7
msgid ""
"This how-to walks you through the steps of setting up a (possibly remote) "
"compute resource, setting up a code on that computer, and submitting a "
"calculation through AiiDA (similar to the :ref:`introductory tutorial "
"<tutorial:basic:calcjob>`, but in more detail)."
msgstr ""
"这篇指南引导您完成设置(可能是远程)计算资源的步骤，在计算机上设置计算代码，并通过AiiDA提交计算(类似于 :ref:`入门教程 "
"<tutorial:basic:calcjob>` ，但更详细)。"

#: ../../source/howto/run_codes.rst:9
msgid ""
"To run an external code with AiiDA, you need an appropriate "
":ref:`calculation plugin <topics:plugins>`. In the following, we assume that"
" a plugin for your code is already available from the `aiida plugin registry"
" <https://aiidateam.github.io/aiida-registry/>`_ and installed on your "
"machine. Refer to the :ref:`how-to:plugins-install` section for details on "
"how to install an existing plugin. If a plugin for your code is not yet "
"available, see :ref:`how-to:plugin-codes`."
msgstr ""
"要使用AiiDA运行外部代码，你需要一个适当的 :ref:`算例插件 <topics:plugins>` 。在下面，我们假设你的代码的插件已经在 "
"`aiida插件注册表 <https://aiidateam.github.io/aiida-registry/>`_ 请参阅 :ref:`how-"
"to:plugins-install` 部分，了解如何安装现有插件的详细信息。如果你的计算代码还没有插件可用，请参阅 :ref:`how-"
"to:plugin-codes`。"

#: ../../source/howto/run_codes.rst:14
msgid ""
"Throughout the process, you will be prompted for information on the computer"
" and code. In these prompts:"
msgstr "在整个过程中，系统会提示您输入有关计算机器和代码的信息。在这些提示:"

#: ../../source/howto/run_codes.rst:17
msgid ""
"Type ``?`` followed by ``<enter>`` to get help on what is being asked at any"
" prompt."
msgstr "键入 ``?`` 后 ``<enter>``，以便在任何时候就被要求的问题获得帮助。"

#: ../../source/howto/run_codes.rst:18
msgid ""
"Press ``<CTRL>+C`` at any moment to abort the setup process. Your AiiDA "
"database will remain unmodified."
msgstr "随时按 ``<CTRL>+C`` 终止安装进程。您的AiiDA数据库将保持不变。"

#: ../../source/howto/run_codes.rst:23
msgid ""
"The ``verdi`` commands use ``readline`` extensions to provide default "
"answers, which require an advanced terminal. Use a standard terminal -- "
"terminals embedded in some text editors (such as ``emacs``) have been known "
"to cause problems."
msgstr ""
"``verdi`` 命令使用 ``readline`` 扩展来提供默认答案，这需要一个高级终端。使用标准终端——嵌入某些文本编辑器(如 "
"``emacs`` )中的终端已知会引起问题。"

#: ../../source/howto/run_codes.rst:29
msgid "How to set up a computer"
msgstr "如何配置计算机器"

#: ../../source/howto/run_codes.rst:31
msgid ""
"A |Computer| in AiiDA denotes a computational resource on which you will run"
" your calculations. It can either be:"
msgstr "AiiDA中的|Computer|表示您将在其上运行计算的计算资源。它可以是:"

#: ../../source/howto/run_codes.rst:34
msgid "the machine where AiiDA is installed or"
msgstr "安装AiiDA的机器或"

#: ../../source/howto/run_codes.rst:35
msgid ""
"any machine that is accessible via `SSH "
"<https://en.wikipedia.org/wiki/Secure_Shell>`_ from the machine where AiiDA "
"is installed (possibly :ref:`via a proxy server<how-to:ssh:proxy>`)."
msgstr ""
"任何可以从安装了AiiDA的机器上通过 `SSH <https://en.wikipedia.org/wiki/Secure_Shell>`_ "
"访问的机器(可能是 :ref:`通过代理服务器 <how-to:ssh:proxy>` )。"

#: ../../source/howto/run_codes.rst:37
msgid ""
"The second option allows managing multiple remote compute resources "
"(including HPC clusters and cloud services) from the same AiiDA installation"
" and moving computational jobs between them."
msgstr "第二个选项允许从相同的AiiDA安装管理多个远程计算资源(包括HPC集群和云服务)，并在它们之间转移计算作业。"

#: ../../source/howto/run_codes.rst:41
msgid ""
"The second option requires access through an SSH keypair. If your compute "
"resource demands two-factor authentication, you may need to install AiiDA "
"directly on the compute resource instead."
msgstr "第二个选项需要通过SSH密钥对进行访问。如果计算资源需要双因素身份验证，则可能需要直接在计算资源上安装AiiDA。"

#: ../../source/howto/run_codes.rst:46
msgid "Computer requirements"
msgstr "远端计算机的需求"

#: ../../source/howto/run_codes.rst:48
msgid "Each computer must satisfy the following requirements:"
msgstr "每台计算机器必须满足以下要求:"

#: ../../source/howto/run_codes.rst:50
msgid ""
"It runs a Unix-like operating system (Linux distros and MacOS should work "
"fine)"
msgstr "它运行一个类Unix的操作系统(Linux发行版和MacOS均可)"

#: ../../source/howto/run_codes.rst:51
msgid "It has ``bash`` installed"
msgstr "它必须要安装有 ``bash`` "

#: ../../source/howto/run_codes.rst:52
msgid ""
"(optional) It has batch scheduler installed (see the :ref:`list of supported"
" schedulers <topics:schedulers>`)"
msgstr "(可选)它安装了调度程序(见 :ref:`支持调度程序列表 <topics:schedulers>` )"

#: ../../source/howto/run_codes.rst:54
msgid ""
"If you are configuring a remote computer, start by :ref:`configuring "
"password-less SSH access <how-to:ssh>` to it."
msgstr "如果您正在配置一台远程计算机，请从 :ref:`配置无密码SSH访问<how-to:ssh>` 开始"

#: ../../source/howto/run_codes.rst:58
msgid ""
"AiiDA will use ``bash`` on the remote computer, regardless of the default "
"shell. Please ensure that your remote ``bash`` configuration does not load a"
" different shell."
msgstr ""
"AiiDA会在远端机器上使用 ``bash`` ， 而不论远端的默认shell是什么。因此，确保你的远端机器上的 ``bash`` "
"配置中没有加载其他shell。"

#: ../../source/howto/run_codes.rst:65
msgid "Computer setup"
msgstr "计算资源的设置"

#: ../../source/howto/run_codes.rst:67
msgid ""
"The configuration of computers happens in two steps: setting up the public "
"metadata associated with the |Computer| in AiiDA provenance graphs, and "
"configuring private connection details."
msgstr "计算机的配置分两个步骤进行:在AiiDA可验证性图中设置与|Computer|关联的公共元数据，以及配置私有连接详细信息。"

#: ../../source/howto/run_codes.rst:69
msgid "Start by creating a new computer instance in the database:"
msgstr "首先在数据库中创建一个新的计算机器实例:"

#: ../../source/howto/run_codes.rst:75
msgid ""
"At the end, the command will open your default editor on a file containing a"
" summary of the configuration up to this point. You can add ``bash`` "
"commands that will be executed"
msgstr "最后，该命令将在最后打开默认编辑器并包含到此为止的配置信息。您可以添加将要执行的 ``bash`` 命令"

#: ../../source/howto/run_codes.rst:78
msgid ""
"*before* the actual execution of the job (under 'Pre-execution script'), and"
msgstr "实际执行任务 *前* (在 ``预执行脚本`` 下)，和"

#: ../../source/howto/run_codes.rst:79
msgid "*after* the script submission (under 'Post execution script')."
msgstr "在脚本提交 *后* (在 ``后执行脚本``下)。"

#: ../../source/howto/run_codes.rst:81
msgid ""
"Use these additional lines to perform any further set up of the environment "
"on the computer, for example loading modules or exporting environment "
"variables:"
msgstr "使用这些额外的行在计算机上执行任何进一步的环境设置，例如加载模块或导出环境变量:"

#: ../../source/howto/run_codes.rst:90
msgid ""
"Don't specify settings here that are specific to a code or calculation: you "
"can set further pre-execution commands at the ``Code`` and even ``CalcJob`` "
"level."
msgstr "请不要在这里设置计算代码，算例相关的指令——你可以在 ``Code`` 和 ``CalcJob`` 层面设置前置命令。"

#: ../../source/howto/run_codes.rst:92
msgid ""
"When you are done editing, save and quit. The computer has now been created "
"in the database but you still need to *configure* access to it using your "
"credentials."
msgstr "当你完成编辑保存并退出。 现在计算资源就被创建在数据库中了，但你还需要 *配置* 访问该资源的方式及凭证。"

#: ../../source/howto/run_codes.rst:96
msgid ""
"In order to avoid having to retype the setup information the next time "
"around, you can provide some (or all) of the information via a configuration"
" file:"
msgstr "为了避免下次重复输入配置信息，可以使用配置文件来包含上述信息以配置代码 ::"

#: ../../source/howto/run_codes.rst:102
msgid ""
"where ``computer.yml`` is a configuration file in the `YAML format "
"<https://en.wikipedia.org/wiki/YAML#Syntax>`__. This file contains the "
"information in a series of key-value pairs:"
msgstr ""
"其中 ``computer.yml`` 是 `YAML format "
"<https://en.wikipedia.org/wiki/YAML#Syntax>`__ 格式的配置文件，该文件中包含一系列键值对。"

#: ../../source/howto/run_codes.rst:119
msgid ""
"The list of the keys for the ``yaml`` file is given by the options of the "
"``computer setup`` command:"
msgstr "“yaml”文件的键列表是通过  ``computer setup``  命令的选项给出的:"

#: ../../source/howto/run_codes.rst:130
msgid "Computer connection configuration"
msgstr "计算机器连接配置"

#: ../../source/howto/run_codes.rst:132
msgid "The second step configures private connection details using:"
msgstr "第二步使用以下方法配置私有连接细节:"

#: ../../source/howto/run_codes.rst:138
msgid ""
"Replace ``COMPUTERLABEL`` with the computer label chosen during the setup "
"and replace ``TRANSPORTTYPE`` with the name of chosen transport type, i.e., "
"``local`` for the localhost computer and ``ssh`` for any remote computer."
msgstr ""
"将 ``COMPUTERLABEL`` 替换为在设置过程中选择的计算机标签，并将 ``TRANSPORTTYPE`` 替换为所选传输类型的名称，即 "
"``local`` 用于本地主机计算机， ``ssh`` 用于任何远程计算机。"

#: ../../source/howto/run_codes.rst:140
msgid ""
"After the setup and configuration have been completed, let's check that "
"everything is working properly:"
msgstr "安装和配置完成后，让我们检查是否一切正常工作:"

#: ../../source/howto/run_codes.rst:146
msgid ""
"This command will perform various tests to make sure that AiiDA can connect "
"to the computer, create new files in the scratch directory, retrieve files "
"and query the job scheduler."
msgstr "该命令将执行各种测试，以确保AiiDA可以连接到计算机、在临时目录中创建新文件、检索文件和查询作业调度器。"

#: ../../source/howto/run_codes.rst:151
msgid "Mitigating connection overloads"
msgstr "减少连接过载"

#: ../../source/howto/run_codes.rst:153
msgid ""
"Some compute resources, particularly large supercomputing centers, may not "
"tolerate submitting too many jobs at once, executing scheduler commands too "
"frequently, or opening too many SSH connections."
msgstr "一些计算资源，特别是大型超级计算中心，可能不允许同时提交太多作业、过于频繁地执行调度程序命令或打开过多的SSH连接。"

#: ../../source/howto/run_codes.rst:155
msgid "Limit the number of jobs in the queue."
msgstr "限制队列中的作业数量。"

#: ../../source/howto/run_codes.rst:157
msgid ""
"Set a limit for the maximum number of workflows to submit, and only submit "
"new ones once previous workflows start to complete. The supported number of "
"jobs depends on the supercomputer configuration which may be documented as "
"part of the center's user documentation. The supercomputer administrators "
"may also find the information found on `this page "
"<https://github.com/aiidateam/aiida-core/wiki/Optimising-the-SLURM-"
"scheduler-configuration-(for-cluster-administrators)>`_ useful."
msgstr ""
"设置要提交的最大工作流数量的限制，并且只有在以前的工作流开始完成后才提交新的工作流。支持的作业数量取决于超级计算机配置，该配置可能被记录为中心用户文档的一部分。超级计算机管理员可能也会参考"
" `这个页面 <https://github.com/aiidateam/aiida-core/wiki/Optimising-the-SLURM-"
"scheduler-configuration-(for-cluster-administrators)>`_ 上的信息。"

#: ../../source/howto/run_codes.rst:161
msgid "Increase the time interval between polling the job queue."
msgstr "增加轮询作业队列之间的时间间隔。"

#: ../../source/howto/run_codes.rst:163
msgid ""
"The time interval (in seconds) can be set through the Python API by loading "
"the corresponding |Computer| node, e.g. in the ``verdi shell``:"
msgstr ""
"时间间隔(以秒为单位)可以通过Python API加载相应的 |Computer| 节点来设置，例如在 ``verdi shell`` 中:"

#: ../../source/howto/run_codes.rst:169
msgid "Increase the connection cooldown time."
msgstr "增加连接冷却时间。"

#: ../../source/howto/run_codes.rst:171
msgid ""
"This is the minimum time (in seconds) to wait between opening a new "
"connection. Modify it for an existing computer using:"
msgstr "这是打开新连接之间等待的最小时间(以秒为单位)。使用下列指令修改计算机器的这个参数:"

#: ../../source/howto/run_codes.rst:180
msgid ""
"The two intervals apply *per daemon worker*, i.e. doubling the number of "
"workers may end up putting twice the load on the remote computer."
msgstr "这两个间隔作用于 *每个守护进程* ，也就是说，加倍的工作进程数量最终可能会给远程计算机带来两倍的负载。"

#: ../../source/howto/run_codes.rst:183
msgid "Managing your computers"
msgstr "管理你的计算机器"

#: ../../source/howto/run_codes.rst:185
msgid "Fully configured computers can be listed with:"
msgstr "完全配置的计算机可以如下列出:"

#: ../../source/howto/run_codes.rst:191
msgid ""
"To get detailed information on the specific computer named "
"``COMPUTERLABEL``:"
msgstr "要获取名为 ``COMPUTERLABEL`` 的特定计算机器的详细信息:"

#: ../../source/howto/run_codes.rst:197
msgid "To rename a computer or remove it from the database:"
msgstr "重命名计算机器或将其从数据库中删除:"

#: ../../source/howto/run_codes.rst:206
msgid ""
"Before deleting a |Computer|, you will need to delete *all* nodes linked to "
"it (e.g. any ``CalcJob`` and ``RemoteData`` nodes). Otherwise, AiiDA will "
"prevent you from doing so in order to preserve provenance."
msgstr ""
"在删除 |Computer| 之前，您需要删除所有链接到它的节点(例如任何 ``CalcJob`` 和 ``RemoteData`` "
"节点)。否则，AiiDA会阻止你这样做，以保存可验证性。"

#: ../../source/howto/run_codes.rst:209
msgid ""
"If a remote machine is under maintenance (or no longer operational), you may"
" want to **disable** the corresponding |Computer|. Doing so will prevent "
"AiiDA from connecting to the given computer to check the state of "
"calculations or to submit new calculations."
msgstr ""
"如果远程计算机正在维护中(或不再运行)，您可能希望 **禁用** "
"相应的|Computer|。这样做将阻止AiiDA连接到给定的计算机来检查计算状态或提交新的计算。"

#: ../../source/howto/run_codes.rst:220
msgid "How to create a code"
msgstr ""

#: ../../source/howto/run_codes.rst:222
msgid ""
"Before you can run a calculation, you need to define a \"code\" which "
"represents what code the calculation should execute and how it should be "
"executed. AiiDA supports a variety of codes:"
msgstr ""

#: ../../source/howto/run_codes.rst:225
msgid ""
"``Installed``: The executable code is already installed on the target "
"computer"
msgstr ""

#: ../../source/howto/run_codes.rst:226
msgid ""
"``Portable``: The executable code is stored by AiiDA and can be deployed on "
"a variety of computers"
msgstr ""

#: ../../source/howto/run_codes.rst:227
msgid ""
"``Containerized``: The executable code is part of a container image that can"
" be deployed and run on the target computer"
msgstr ""

#: ../../source/howto/run_codes.rst:229
msgid ""
"Each of these scenarios are supported through a code plugin, which stores "
"all necessary data to fully define the code. A configured code is stored in "
"the provenance graph, which besides being important for reproducibility, "
"makes it easy to query for all calculations that were run with a given code."
msgstr ""

#: ../../source/howto/run_codes.rst:234
msgid ""
"In most cases, it is advisable to install the executables to be used by "
"AiiDA on the target machine *before* submitting calculations using them, in "
"order to take advantage of the compilers and libraries present on the target"
" machine. This is the ``installed`` scenario."
msgstr ""

#: ../../source/howto/run_codes.rst:237
msgid ""
"Occasionally, you may need to run small, reasonably machine-independent "
"scripts (e.g. Python or bash), and copying them manually to a number of "
"different target computers can be tedious. For this use case, the "
"``portable`` code is ideal. The executable and associated files of the code "
"are stored by AiiDA and automatically copied to the target computer for "
"every execution."
msgstr ""

#: ../../source/howto/run_codes.rst:241
msgid ""
"Do *not* use local codes as a way of encapsulating the environment of "
"complex executables. For this use case, it is best to use the "
"``containerized`` code. Create a container of the required compute "
"environment and create a containerized code."
msgstr ""

#: ../../source/howto/run_codes.rst:245
msgid ""
"A new code can be configured in AiiDA through the ``verdi code create`` "
"command. The type of code is specified as the first argument and the rest of"
" the information is provided through options:"
msgstr ""

#: ../../source/howto/run_codes.rst:0
msgid "Installed"
msgstr ""

#: ../../source/howto/run_codes.rst:261
msgid ""
"For more information, please refer to the dedicated :ref:`topic section "
"<topics:data_types:core:code:installed>`."
msgstr ""

#: ../../source/howto/run_codes.rst:0
msgid "Portable"
msgstr ""

#: ../../source/howto/run_codes.rst:265
msgid ""
"The following example shows how to create a portable code for an executable "
"``executable.py`` in the ``/path/to/directory`` folder:"
msgstr ""

#: ../../source/howto/run_codes.rst:274
msgid ""
"Any other files that are part of ``/path/to/directory`` will also be stored "
"by the code plugin."
msgstr ""

#: ../../source/howto/run_codes.rst:276
msgid ""
"For more information, please refer to the dedicated :ref:`topic section "
"<topics:data_types:core:code:portable>`."
msgstr ""

#: ../../source/howto/run_codes.rst:0
msgid "Containerized"
msgstr ""

#: ../../source/howto/run_codes.rst:280
msgid ""
"The following example shows how to setup running ``bash`` in a base Docker "
"container through Singularity to be run on the ``Computer`` named ``some-"
"computer``:"
msgstr ""

#: ../../source/howto/run_codes.rst:292
msgid ""
"For more information, please refer to the dedicated :ref:`topic section "
"<topics:data_types:core:code:containerized>`."
msgstr ""

#: ../../source/howto/run_codes.rst:294
msgid ""
"The code create command will prompt for any additional options. It will also"
" open a text editor to specify the ``--prepend-text`` and ``--append-text`` "
"options, where you can include ``bash`` commands that will be executed"
msgstr ""

#: ../../source/howto/run_codes.rst:297
msgid ""
"*before* running the submission script (after the 'Pre execution script' "
"lines), and"
msgstr "运行提交脚本 *前* (在'Pre execution script'行之后)"

#: ../../source/howto/run_codes.rst:298
msgid ""
"*after* running the submission script (after the 'Post execution script' "
"separator)."
msgstr "运行提交脚本 *后* (在'Post execution script'分隔符之后)。"

#: ../../source/howto/run_codes.rst:300
msgid ""
"Use this, for instance, to load modules or set variables that are needed by "
"the code, such as:"
msgstr "例如，使用它来加载模块或设置代码所需的变量，例如:"

#: ../../source/howto/run_codes.rst:306
msgid ""
"At the end, you receive a confirmation, with the *PK* and the *UUID* of your"
" new code."
msgstr "最后，您将收到一个确认，其中包含新代码的 *PK* 和 *UUID* 。"

#: ../../source/howto/run_codes.rst:310
msgid ""
"The ``verdi code create`` command performs minimal checks in order to keep "
"it performant and not rely on an internet connection. If you want additional"
" checks to verify the code is properly configured and usable, run the `verdi"
" code test` command. For installed codes for example, this will check "
"whether the associated computer can be connected to and whether the "
"specified executable exists. Look at the command help to see what other "
"checks may be run."
msgstr ""

#: ../../source/howto/run_codes.rst:317
msgid ""
"Analogous to a :ref:`computer setup <how-to:run-codes:computer>`, some (or "
"all) the information described above can be provided via a configuration "
"file:"
msgstr ""
"类似于 :ref:`计算机器设置 <how-to:run-codes:computer>` ，上面描述的部分(或全部)信息可以通过配置文件提供:"

#: ../../source/howto/run_codes.rst:323
msgid ""
"where ``code.yml`` is a configuration file in the `YAML format "
"<https://en.wikipedia.org/wiki/YAML#Syntax>`_."
msgstr ""
"其中 ``code.yml`` 是 `YAML format <https://en.wikipedia.org/wiki/YAML#Syntax>`_"
" 格式的配置文件。"

#: ../../source/howto/run_codes.rst:325
msgid "This file contains the information in a series of key:value pairs:"
msgstr "该文件以键值对的方式存放了一系列信息 :"

#: ../../source/howto/run_codes.rst:340
msgid ""
"The list of the keys for the ``yaml`` file is given by the available options"
" of the ``code create`` sub-command:"
msgstr ""

#: ../../source/howto/run_codes.rst:346
msgid ""
"Note: remove the ``--`` prefix and replace ``-`` within the keys with an "
"underscore ``_``."
msgstr "注意语法上的区别：去掉键选项前的 ``--`` 前缀，并将键中的 ``-`` 替换为下划线 ``_`` 。"

#: ../../source/howto/run_codes.rst:349
msgid "Managing codes"
msgstr "管理计算代码"

#: ../../source/howto/run_codes.rst:351
msgid "You can change the label of a code by using the following command:"
msgstr "你可以使用下面指令修改计算代码的标签 :"

#: ../../source/howto/run_codes.rst:357
msgid ""
"where <IDENTIFIER> can be the numeric *PK*, the *UUID* or the label of the "
"code (either ``label`` or ``label@computername``) if the label is unique."
msgstr ""
"其中 <IDENTIFIER> 可以是数字 *PK* ，  *UUID* 或计算代码的标签(可以是 ``label`` 或 "
"``label@computername`` )，如果标签是唯一的。"

#: ../../source/howto/run_codes.rst:359
msgid "You can also list all available codes and their identifiers with:"
msgstr "你可以使用下面命令列出所有可用的计算代码（及其对应的ID） ::"

#: ../../source/howto/run_codes.rst:365
msgid ""
"which also accepts flags to filter only codes on a given computer, or only "
"codes using a specific plugin, etc. (use the ``-h`` option)."
msgstr "它也接受标志来过滤给定计算机器上的计算代码，或只使用特定插件的代码，等等(使用 ``-h`` 查看更多选项)。"

#: ../../source/howto/run_codes.rst:367
msgid "You can get the information of a specific code with:"
msgstr "你之后可以通过下面代码获取特定计算代码的信息 :"

#: ../../source/howto/run_codes.rst:373
msgid "Finally, to delete a code use:"
msgstr "最后可以使用下面代码删除配置的计算代码 :"

#: ../../source/howto/run_codes.rst:379
msgid ""
"(only if it wasn't used by any calculation, otherwise an exception is "
"raised)."
msgstr "(仅当该计算代码不被任何算例使用，否则会抛出一个异常)."

#: ../../source/howto/run_codes.rst:383
msgid ""
"Codes are a subclass of :py:class:`Node <aiida.orm.Node>` and, as such, you "
"can attach ``extras`` to a code, for example:"
msgstr ""

#: ../../source/howto/run_codes.rst:390
msgid ""
"These can be useful for querying, for instance in order to find all runs "
"done with the CP2K code of version 6.1 or later."
msgstr "这些对查询很有用，例如，为了查找使用版本6.1或更高版本的CP2K代码完成的所有运行。"

#: ../../source/howto/run_codes.rst:395
msgid "How to submit a calculation"
msgstr "如何提交算例"

#: ../../source/howto/run_codes.rst:397
msgid ""
"After :ref:`setting up your computer <how-to:run-codes:computer>` and "
":ref:`setting up your code <how-to:run-codes:code>`, you are ready to launch"
" your calculations!"
msgstr ""

#: ../../source/howto/run_codes.rst:399
msgid "Make sure the daemon is running:"
msgstr "确保守护进程正在运行:"

#: ../../source/howto/run_codes.rst:405
msgid "Figure out which inputs your |CalcJob|  plugin needs, e.g. using:"
msgstr "找出|CalcJob|插件需要哪些输入，例如:"

#: ../../source/howto/run_codes.rst:411
msgid "Write a ``submit.py`` script:"
msgstr "编写一个``submit.py``脚本:"

#: ../../source/howto/run_codes.rst:431
msgid ""
"Of course, the code label and builder inputs need to be adapted to your code"
" and calculation."
msgstr "当然，计算代码标签和构建器输入需要适应您的代码和算例。"

#: ../../source/howto/run_codes.rst:433
msgid "Submit your calculation to the AiiDA daemon:"
msgstr "提交你的算例到AiiDA守护进程:"

#: ../../source/howto/run_codes.rst:439
msgid ""
"After this, use ``verdi process list`` to monitor the status of the "
"calculations."
msgstr "在这之后，使用 ``verdi process list`` 来监控算例的状态。"

#: ../../source/howto/run_codes.rst:443
msgid ""
"If you ever need to resubmit a previous calculation with modified inputs, "
"you can get a pre-populated copy of its process builder with"
msgstr ""

#: ../../source/howto/run_codes.rst:452
msgid ""
"where ``<IDENTIFIER>`` is the ``PK`` or ``UUID`` (or label) of your "
"*calculation*."
msgstr ""

#: ../../source/howto/run_codes.rst:455
msgid ""
"See :ref:`topics:processes:usage:launching` and "
":ref:`topics:processes:usage:monitoring` for more details."
msgstr ""
"参见 :ref:`topics:processes:usage:launching` 和 "
":ref:`topics:processes:usage:monitoring` 了解更多细节。"

#: ../../source/howto/run_codes.rst:462
msgid "How to save compute time with caching"
msgstr "如何通过缓存机制节省计算时间"

#: ../../source/howto/run_codes.rst:464
msgid ""
"Over the course of a project, you may end up re-running the same "
"calculations multiple times - be it because two workflows include the same "
"calculation or because one needs to restart a workflow that failed due to "
"some infrastructure problem."
msgstr "在项目的过程中，您可能会多次运行相同的计算——可能是因为两个工作流包含相同的计算，也可能是因为需要重新启动由于某些基础问题而失败的工作流。"

#: ../../source/howto/run_codes.rst:466
msgid ""
"Since AiiDA stores the full provenance of each calculation, it can detect "
"whether a calculation has been run before and, instead of running it again, "
"simply reuse its outputs, thereby saving valuable computational resources. "
"This is what we mean by **caching** in AiiDA."
msgstr ""
"由于AiiDA存储每个计算的完整起源，它可以检测之前是否运行了一个计算，重用其输出，而不是再次运行它，从而节省宝贵的计算资源。这就是我们所说的AiiDA中的缓存机制。"

#: ../../source/howto/run_codes.rst:469
msgid ""
"With caching enabled, AiiDA searches the database for a calculation of the "
"same :ref:`hash<topics:provenance:caching:hashing>`. If found, AiiDA creates"
" a copy of the calculation node and its results, thus ensuring that the "
"resulting provenance graph is independent of whether caching is enabled or "
"not (see :numref:`fig_caching`)."
msgstr ""
"启用缓存机制后，AiiDA会在数据库中搜索相同的 :ref:`哈希 <topics:provenance:caching:hashing>` "
"计算。如果找到，AiiDA将创建计算节点及其结果的一个副本，从而确保产生的可验证性图与是否启用缓存无关(参见 "
":numref:`fig_caching`)。"

#: ../../source/howto/run_codes.rst:477
msgid ""
"When reusing the results of a calculation **C** for a new calculation "
"**C'**, AiiDA simply makes a copy of the result nodes and links them up as "
"usual. This diagram depicts the same input node **D1** being used for both "
"calculations, but an input node **D1'** with the same *hash* as **D1** would"
" trigger the cache as well."
msgstr ""
"当为一个新的计算 **C** 重用一个计算 **C** "
"的结果时，AiiDA只是简单地复制结果节点并像往常一样将它们连接起来。这个图描述了用于这两个计算的同一个输入节点 **D1** ，但是一个与 "
"**D1** 具有相同的哈希值的输入节点 **D1'** 也会触发缓存。"

#: ../../source/howto/run_codes.rst:480
msgid ""
"Caching happens on the *calculation* level (no caching at the workflow "
"level, see :ref:`topics:provenance:caching:limitations`). By default, both "
"successful and failed calculations enter the cache once they are *finished*."
" Excepted and killed calculations do *not* enter the cache (more details in "
":ref:`topics:provenance:caching:control-caching`)."
msgstr ""

#: ../../source/howto/run_codes.rst:487
msgid "How to enable caching"
msgstr "如何启用缓存"

#: ../../source/howto/run_codes.rst:489
msgid ""
"Caching is **not** enabled by default, see :ref:`the faq <how-"
"to:faq:caching-not-enabled>`."
msgstr "缓存默认情况下是不启用的，参见 :ref:`常见问题 <how-to:faq:caching-not-enabled>`。"

#: ../../source/howto/run_codes.rst:491
msgid ""
"Caching is controlled on a per-profile level via the :ref:`verdi config cli "
"<how-to:installation:configure:options>`."
msgstr ""
"缓存通过 :ref:`verdi config cli <how-to:installation:configure:options>` "
"在每个配置文件级别上进行控制。"

#: ../../source/howto/run_codes.rst:493
msgid "View your current caching configuration:"
msgstr "查看您当前的缓存配置:"

#: ../../source/howto/run_codes.rst:504
msgid ""
"Enable caching for your current profile or globally (for all profiles):"
msgstr "为当前配置文件或全局(所有配置文件)启用缓存机制:"

#: ../../source/howto/run_codes.rst:523
msgid ""
"Configuring caching via the ``cache_config.yml`` is deprecated as of AiiDA "
"1.6.0. Existing ``cache_config.yml`` files will be migrated to the central "
"``config.json`` file automatically."
msgstr ""
"通过 ``cache_config.yml`` 配置缓存机制，在AiiDA 1.6.0中已弃用。现有的 ``cache_config.yml`` "
"文件将被迁移到中央配置 ``config.json`` 文件。"

#: ../../source/howto/run_codes.rst:527
msgid ""
"From this point onwards, when you launch a new calculation, AiiDA will "
"compare its hash (a fixed size string, unique for a calulation's type and "
"inputs, see :ref:`topics:provenance:caching:hashing`) against other "
"calculations already present in your database. If another calculation with "
"the same hash is found, AiiDA will reuse its results without repeating the "
"actual calculation."
msgstr ""
"从现在开始，当您启动一个新的计算时，AiiDA将把它的哈希值(一个固定大小的字符串，对于计算的类型和输入是唯一的，参见 :ref:`topics: "
"origin:caching:hash` "
")与数据库中已经存在的其他计算值进行比较。如果找到具有相同散列的另一个计算，AiiDA将重用其结果，而不重复实际计算。"

#: ../../source/howto/run_codes.rst:532
msgid ""
"In contrast to caching, hashing **is** enabled by default, i.e. hashes for "
"all your calculations will already have been computed."
msgstr "与缓存相比，哈希 **是** 默认启用，即所有的计算的哈希将已计算给出。"

#: ../../source/howto/run_codes.rst:537
msgid "How to configure caching"
msgstr "如何配置缓存机制"

#: ../../source/howto/run_codes.rst:539
msgid ""
"The caching mechanism can be configured on a process class level, meaning "
"the rules will automatically be applied to all instances of the given class,"
" or on a per-instance level, meaning it can be controlled for individual "
"process instances when they are launch."
msgstr ""
"可以在例程类级别上配置缓存机制，这意味着规则将自动应用于给定类的所有实例，也可以在每个实例级别上配置，这意味着可以在启动单个流程实例时对其进行控制。"

#: ../../source/howto/run_codes.rst:542
msgid "Class level"
msgstr "类层级"

#: ../../source/howto/run_codes.rst:544
msgid ""
"Besides the on/off switch set by ``caching.default_enabled``, caching can be"
" controlled at the level of specific calculations using their corresponding "
"entry point strings (see the output of ``verdi plugin list "
"aiida.calculations``):"
msgstr ""
"除了由 ``caching.default_enabled`` "
"设置的on/off开关，缓存可以使用它们对应的接入点字符串在特定的算例级别上进行控制(参见 ``verdi plugin list "
"aiida.calculations`` 的输出):"

#: ../../source/howto/run_codes.rst:562
msgid ""
"In this example, caching is enabled by default, but explicitly disabled for "
"calculations of the ``TemplatereplacerCalculation`` class, identified by its"
" corresponding ``aiida.calculations:core.templatereplacer`` entry point "
"string. It also shows how to enable caching for particular calculations "
"(which has no effect here due to the profile-wide default)."
msgstr ""

#: ../../source/howto/run_codes.rst:565
msgid "To set multiple entry-points at once, use a ``,`` delimiter."
msgstr "若要一次性设置多个接入点，请使用 ``,`` 分隔符。"

#: ../../source/howto/run_codes.rst:567
msgid ""
"For the available entry-points in your environment, you can list which are "
"enabled/disabled using:"
msgstr "对于环境中可用的接入点，您可以使用以下方法列出启用/禁用的接入点:"

#: ../../source/howto/run_codes.rst:579
msgid ""
"For calculations which do not have an entry point, you need to specify the "
"fully qualified Python name instead. For example, the "
"``seekpath_structure_analysis`` calcfunction defined in "
"``aiida_quantumespresso.workflows.functions.seekpath_structure_analysis`` is"
" labelled as "
"``aiida_quantumespresso.workflows.functions.seekpath_structure_analysis.seekpath_structure_analysis``."
" From an existing :class:`~aiida.orm.CalculationNode`, you can get the "
"identifier string through the ``process_type`` attribute."
msgstr ""

#: ../../source/howto/run_codes.rst:583
msgid ""
"The caching configuration also accepts ``*`` wildcards. For example, the "
"following configuration disables caching for all calculation entry points."
msgstr "缓存机制配置也接受 ``*`` 通配符。例如，以下配置禁用所有计算接入点的缓存。"

#: ../../source/howto/run_codes.rst:598
msgid ""
"Any entry with a wildcard is overridden by a more specific entry. The "
"following configuration disables caching for all ``aiida.calculation`` entry"
" points, except those of ``arithmetic``:"
msgstr ""
"任何带有通配符的条目都会被更具体的条目覆盖。下面的配置禁用了所有 ``aiida.calculation`` 接入点的缓存。 "
"``arithmetic`` 的接入点除外:"

#: ../../source/howto/run_codes.rst:620
msgid "Instance level"
msgstr "实例层级"

#: ../../source/howto/run_codes.rst:622
msgid ""
"Caching can be enabled or disabled on a case-by-case basis by using the "
":class:`~aiida.manage.caching.enable_caching` or "
":class:`~aiida.manage.caching.disable_caching` context manager, "
"respectively, regardless of the profile settings:"
msgstr ""
"缓存可以通过使用 :class:`~aiida.manage.caching.enable_caching` 或  "
":class:`~aiida.manage.caching.disable_caching`  "
"上下文管理器据具体情况来启用或禁用，而不根据配置文件设置:"

#: ../../source/howto/run_codes.rst:633
msgid ""
"This affects only the current Python interpreter and won't change the "
"behavior of the daemon workers. This means that this technique is only "
"useful when using :py:class:`~aiida.engine.run`, and **not** with "
":py:class:`~aiida.engine.submit`."
msgstr ""
"这只会影响当前的Python解释器，不会改变守护进程的行为。这意味着这种技术只在使用 :py:class:`~aiida.engine.run` "
"时有用，而使用 :py:class:`~aiida.engine.submit` 时则 **不** 生效。"

#: ../../source/howto/run_codes.rst:637
msgid ""
"Besides controlling which process classes are cached, it may be useful or "
"necessary to control what already _stored_ nodes are used as caching "
"_sources_. Section :ref:`topics:provenance:caching:control-caching` provides"
" details how AiiDA decides which stored nodes are equivalent to the node "
"being stored and which are considered valid caching sources."
msgstr ""

#: ../../source/howto/run_workflows.rst:5
msgid "How to run multi-step workflows"
msgstr "如何运行多步骤工作流"

#: ../../source/howto/run_workflows.rst:8
msgid "Launching a predefined workflow"
msgstr "启动预定义的工作流"

#: ../../source/howto/run_workflows.rst:10
msgid ""
"The first step to launching a predefined workflow is loading the work "
"function or work chain class that defines the workflow you want to run. The "
"recommended method for loading a workflow is using the ``WorkflowFactory``, "
"for example:"
msgstr ""
"启动预定义工作流的第一步是加载定义要运行的工作流的工作函数或工作链类。加载工作流的推荐方法是使用 ``WorkflowFactory`` ，例如:"

#: ../../source/howto/run_workflows.rst:19
msgid ""
"This is essentially the same as importing the workflow from its respective "
"module, but using the ``WorkflowFactory`` has the advantage that the so "
"called *entry point* (e.g. ``'core.arithmetic.multiply_add'``) will not "
"change when the packages or plugins are reorganised. This means your code is"
" less likely to break when updating AiiDA or the plugin that supplies the "
"workflow."
msgstr ""

#: ../../source/howto/run_workflows.rst:22
msgid ""
"The list of installed plugins can be easily accessed via the verdi CLI:"
msgstr "安装插件列表可以通过verdi命令行轻松访问:"

#: ../../source/howto/run_workflows.rst:28
msgid "To see the list of workflow entry points, simply use:"
msgstr "要查看工作流接入点的列表，只需使用:"

#: ../../source/howto/run_workflows.rst:34
msgid ""
"By further specifying the entry point of the workflow, you can see its "
"description, inputs, outputs and exit codes:"
msgstr "通过进一步指定工作流的接入点，您可以看到它的描述、输入、输出和退出状态码:"

#: ../../source/howto/run_workflows.rst:41
msgid "Work functions"
msgstr "工作函数"

#: ../../source/howto/run_workflows.rst:43
msgid ""
"Running a work function is as simple as calling a typical Python function: "
"simply call it with the required input arguments:"
msgstr "运行一个工作函数就像调用一个典型的Python函数一样简单:只需使用所需的输入参数调用它:"

#: ../../source/howto/run_workflows.rst:53
msgid ""
"Here, the ``add_and_multiply`` work function returns the output ``Int`` node"
" and we assign it to the variable ``result``. Note that the input arguments "
"of a work function must be an instance of ``Data`` node, or any of its "
"subclasses. Just calling the ``add_and_multiply`` function with regular "
"integers will result in a ``ValueError``, as these cannot be stored in the "
"provenance graph."
msgstr ""
"这里， ``add_and_multiply``  工作函数返回输出 ``Int`` 节点，并将其赋给变量 ``result`` "
"。请注意，工作函数的输入参数必须是 ``Data`` 节点或其任何子类的实例。使用普通的整数调用 ``add_and_multiply`` 函数将导致 "
"``ValueError`` ，因为这些实例不能存储在可验证性图中。"

#: ../../source/howto/run_workflows.rst:59
msgid ""
"If a function argument is a Python base type (i.e. a value of type ``bool``,"
" ``dict``, ``Enum``, ``float``, ``int``, ``list`` or ``str``), it can be "
"passed straight away to the function, without first having to wrap it in the"
" corresponding AiiDA data type. That is to say, you can run the example "
"above also as:"
msgstr ""

#: ../../source/howto/run_workflows.rst:66
msgid ""
"and AiiDA will recognize that the arguments are of type ``int`` and "
"automatically wrap them in an ``Int`` node."
msgstr ""

#: ../../source/howto/run_workflows.rst:71
msgid ""
"Although the example above shows the most straightforward way to run the "
"``add_and_multiply`` work function, there are several other ways of running "
"processes that can return more than just the result. For example, the "
"``run_get_node`` function from the AiiDA engine returns both the result of "
"the workflow and the work function node. See the :ref:`corresponding topics "
"section for more details <topics:processes:usage:launching>`."
msgstr ""
"虽然上面的例子展示了运行 ``add_and_multiply`` "
"工作函数的最简单的方法，但是还有其他几种运行进程的方法可以返回不仅仅是结果。例如，AiiDA引擎中的 ``run_get_node`` "
"函数返回工作流和工作函数节点的结果。参见 :ref:`相应的主题部分了解更多细节 "
"<topics:processes:usage:launching>`。"

#: ../../source/howto/run_workflows.rst:76
msgid "Work chains"
msgstr "工作链"

#: ../../source/howto/run_workflows.rst:78
msgid ""
"To launch a work chain, you can either use the ``run`` or ``submit`` "
"functions. For either function, you need to provide the class of the work "
"chain as the first argument, followed by the inputs as keyword arguments. "
"When \"running the work chain\" (using the ``run`` function), it will be "
"executed in the same system process as the interpreter in which it is "
"launched:"
msgstr ""
"要启动一个工作链，你可以使用 ``run`` 或 ``submit`` "
"函数。对于任何一个函数，都需要提供工作链的类作为第一个参数，然后提供输入作为关键字参数。当使用 ``run`` 函数 “运行工作链” "
"时，它将在与启动它的解释器相同的系统进程中执行:"

#: ../../source/howto/run_workflows.rst:93
msgid ""
"Alternatively, you can first construct a dictionary of the inputs, and pass "
"it to the ``run`` function by taking advantage of `Python's automatic "
"keyword expansion "
"<https://docs.python.org/3/tutorial/controlflow.html#unpacking-argument-"
"lists>`_:"
msgstr ""
"或者，你可以先构造一个输入字典，然后利用 `Python的自动关键字扩展 "
"<https://docs.python.org/3/tutorial/controlflow.html#unpacking-argument-"
"lists>`_ 把它传递给 ``run`` 函数:"

#: ../../source/howto/run_workflows.rst:100
msgid ""
"This is particularly useful in case you have a workflow with a lot of "
"inputs. In both cases, running the ``MultiplyAddWorkChain`` workflow returns"
" the **results** of the workflow, i.e. a dictionary of the nodes that are "
"produced as outputs, where the keys of the dictionary correspond to the "
"labels of each respective output."
msgstr ""
"这在您的工作流程中有很多输入时特别有用。在这两种情况下，运行 ``MultiplyAddWorkChain`` 工作流返回工作流的 **结果** "
"，即作为输出产生的节点字典，其中字典的键对应于每个各自输出的标签。"

#: ../../source/howto/run_workflows.rst:105
msgid ""
"Similar to other processes, there are multiple functions for launching a "
"work chain. See the section on :ref:`launching processes for more "
"details<topics:processes:usage:launching>`."
msgstr ""
"与其他列程类似，有多个用于启动工作链的功能。详见 :ref:`启动列程 <topics:processes:usage:launching>`一节。"

#: ../../source/howto/run_workflows.rst:108
msgid ""
"Since *running* a workflow will block the interpreter, you will have to wait"
" until the workflow is finished before you get back control. Moreover, you "
"won't be able to turn your computer or even your terminal off until the "
"workflow has fully terminated, and it is difficult to run multiple workflows"
" in parallel. So, it is advisable to *submit* more complex or longer work "
"chains to the daemon:"
msgstr ""
"因为 *运行* "
"工作流会阻塞解释器，你必须等到工作流完成后才能重新获得控制权。此外，在工作流完全终止之前，你不能关闭你的计算机甚至你的终端，而且并行运行多个工作流是很困难的。因此，建议通过*提交*的方式将更复杂或更长的工作链放到守护进程运行:"

#: ../../source/howto/run_workflows.rst:124
msgid ""
"Note that when using ``submit`` the work chain is not run in the local "
"interpreter but is sent off to the daemon and you get back control "
"instantly. This allows you to submit multiple work chains at the same time "
"and the daemon will start working on them in parallel. Once the ``submit`` "
"call returns, you will not get the result as with ``run``, but you will get "
"the **node** that represents the work chain. Submitting a work chain instead"
" of directly running it not only makes it easier to execute multiple work "
"chains in parallel, but also ensures that the progress of a workchain is not"
" lost when you restart your computer."
msgstr ""
"请注意，当使用 ``submit`` "
"时，工作链不是在本地解释器中运行，而是被发送给守护进程，你立即获得控制权。这允许您同时提交多个工作链，守护进程将开始并行地处理它们。一旦 "
"``submit`` 调用返回，你将不会像 ``run`` 一样得到结果，但你会得到表示工作链的 **节点** "
"。提交一个工作链，而不是直接运行它，不仅更容易并行执行多个工作链，而且还确保当你重启计算机时，工作链的进度不会丢失。"

#: ../../source/howto/run_workflows.rst:131
msgid ""
"As of AiiDA v1.5.0, it is possible to submit both work *chains* and work "
"*functions* to the daemon. Older versions only allow the submission of work "
"*chains*, whereas work *functions* cannot be submitted to the daemon, and "
"hence can only be *run*."
msgstr ""
"从AiiDA v1.5.0开始，可以将工作链和工作函数提交给守护进程。旧版本只允许提交工作链，而工作函数不能提交给守护进程，只能 *运行* 。"

#: ../../source/howto/run_workflows.rst:133
msgid ""
"If you are unfamiliar with the inputs of a particular ``WorkChain``, a "
"convenient tool for setting up the work chain is the :ref:`process "
"builder<topics:processes:usage:builder>`. This can be obtained by using the "
"``get_builder()`` method, which is implemented for every ``CalcJob`` and "
"``WorkChain``:"
msgstr ""
"如果你不熟悉特定的 ``工作链`` 的输入，设置工作链的一个方便的工具是 "
":ref:`列程构建器<topics:processes:usage:builder>` 。它可以通过 ``get_builder()`` "
"方法获得，该方法在每个 ``CalcJob`` 和 ``WorkChain`` 中都有实现:"

#: ../../source/howto/run_workflows.rst:143
msgid ""
"To explore the inputs of the work chain, you can use tab autocompletion by "
"typing ``builder.`` and then hitting ``TAB``. If you want to get more "
"details on a specific input, you can simply add a ``?`` and press enter:"
msgstr ""
"要查看工作链的输入，可以通过键入 ``builder.`` 然后敲击 ``Tab`` "
"键自动完成。如果你想获得一个特定输入的更多细节，你可以简单地添加一个 ``?`` ，然后回车:"

#: ../../source/howto/run_workflows.rst:153
msgid ""
"Here you can see that the ``x`` input is required, needs to be of the "
"``Int`` type and is stored in the database (``\"non_db\": \"False\"``)."
msgstr "这里可以看到输入 ``x`` 是必需的，需要是 ``Int`` 类型，并存储在数据库中( ``non_db``: ``False``)。"

#: ../../source/howto/run_workflows.rst:155
msgid ""
"Using the builder, the inputs of the ``WorkChain`` can be provided one by "
"one:"
msgstr "使用构建器， ``WorkChain`` 的输入可以一个一个地提供:"

#: ../../source/howto/run_workflows.rst:164
msgid ""
"Once the *required* inputs of the workflow have been provided to the "
"builder, you can either run the work chain or submit it to the daemon:"
msgstr "一旦工作流所 *必需的* 输入被提供给了构建器，你就可以运行工作链或者将它提交给守护进程:"

#: ../../source/howto/run_workflows.rst:173
msgid ""
"For more detail on the process builder, see the :ref:`corresponding topics "
"section<topics:processes:usage:builder>`."
msgstr "有关列程构建器的更多详细信息，请参见 :ref:`相应的主题部分 <topics:processes:usage:builder>`。"

#: ../../source/howto/run_workflows.rst:175
msgid ""
"Now that you know how to run a pre-defined workflow, you may want to start "
":ref:`writing your own<how-to:write-workflows>`."
msgstr ""
"现在你知道了如何运行一个预定义的工作流，你可能想要开始 :ref:`编写你自己的工作流 <how-to:write-workflows>`。"

#: ../../source/howto/share_data.rst:5
msgid "How to share data"
msgstr "如何共享数据"

#: ../../source/howto/share_data.rst:7
msgid ""
"AiiDA offers two avenues for sharing data with others: archive files and the"
" REST API."
msgstr "AiiDA提供了与他人共享数据的两种途径:归档文件和REST API。"

#: ../../source/howto/share_data.rst:13
msgid "Sharing AiiDA archives"
msgstr "分享AiiDA归档"

#: ../../source/howto/share_data.rst:15
msgid ""
"You have performed your calculations with AiiDA and you would like to share "
"your AiiDA provenance graph, for example to make your scientific study "
"reproducible."
msgstr "您已经使用AiiDA执行了计算，并且您希望分享您的AiiDA可验证性图，例如，使您的科学研究可重复。"

#: ../../source/howto/share_data.rst:17
msgid ""
"Since AiiDA keeps track of the provenance of every computed result, this "
"step is easy: Tell AiiDA the **final results** you would like to be "
"reproducible, and AiiDA will automatically include their entire provenance "
"using the :ref:`topics:provenance:consistency:traversal-rules`."
msgstr ""
"由于AiiDA跟踪每个计算结果的出处，这个步骤很简单:告诉AiiDA您想要再现的 **最终结果** ，AiiDA将使用 :ref:`topics: "
"origin:consistency:traversal-rules` 自动包括它们的整个可验证性。"

#: ../../source/howto/share_data.rst:20
msgid ""
":ref:`internal_architecture:storage:sqlite_zip` and :ref:`how-"
"to:data:share:archive:profile`."
msgstr ""

#: ../../source/howto/share_data.rst:23
msgid "Exporting individual nodes"
msgstr "导出独立的节点"

#: ../../source/howto/share_data.rst:25
msgid ""
"Let's say the key results of your study are contained in three AiiDA nodes "
"with PKs ``12``, ``123``, ``1234``. Exporting those results together with "
"their provenance is as easy as:"
msgstr ""
"假设您的研究的关键结果包含在三个AiiDA节点中，其PKs为 ``12``, ``123``, ``1234`` 。导出这些结果和它们的来源很简单:"

#: ../../source/howto/share_data.rst:32
msgid ""
"As usual, you can use any identifier (label, PK or UUID) to specify the "
"nodes to be exported."
msgstr "通常，您可以使用任何标识符(标签、PK或UUID)来指定要导出的节点。"

#: ../../source/howto/share_data.rst:34
msgid ""
"The resulting archive file ``my-calculations.aiida`` contains all "
"information pertaining to the exported nodes. The default traversal rules "
"make sure to include the complete provenance of any node specified and "
"should be sufficient for most cases. See ``verdi archive create --help`` for"
" ways to modify the traversal rules."
msgstr ""
"生成的归档文件 ``my-calculations.aiida`` "
"包含与导出节点有关的所有信息。默认遍历规则确保包含任何指定节点的完整起源，并且对于大多数情况应该足够了。请参见 ``verdi archive "
"create --help``  获取修改遍历规则的方法。"

#: ../../source/howto/share_data.rst:40
msgid ""
"To see what would be exported, before exporting, you can use the ``--test-"
"run`` option:"
msgstr ""

#: ../../source/howto/share_data.rst:46
msgid ""
"Please remember to use **UUIDs** when pointing your colleagues to data "
"*inside* an AiiDA archive, since UUIDs are guaranteed to be universally "
"unique (while PKs aren't)."
msgstr ""
"请记住你需要使用 **UUIDs** 告知您的同事如何访问AiiDA归档中的数据，因为 **UUIDs** 被保证是唯一的(而PKs不是)。"

#: ../../source/howto/share_data.rst:49
msgid "Exporting large numbers of nodes"
msgstr ""

#: ../../source/howto/share_data.rst:51
msgid ""
"If the number of results to be exported is large, for example in a high-"
"throughput study, use the ``QueryBuilder`` to add the corresponding nodes to"
" a group ``my-results`` (see :ref:`how-to:data:organize:group`). Then export"
" the group:"
msgstr ""
"如果要导出的结果数量很大，例如在高通量的研究中，使用 ``QueryBuilder`` 将相应的节点添加到 ``my-results`` 组中(参见 "
":ref:`howto:data:organize:group`)。然后导出组:"

#: ../../source/howto/share_data.rst:58
msgid "Alternatively, export your entire profile with:"
msgstr ""

#: ../../source/howto/share_data.rst:65
msgid "Publishing AiiDA archive files"
msgstr "发布AiiDA归档文件"

#: ../../source/howto/share_data.rst:67
msgid ""
"AiiDA archive files can be published on any research data repository, for "
"example the `Materials Cloud Archive`_, `Zenodo`_, or the `Open Science "
"Framework`_. When publishing AiiDA archives on the `Materials Cloud "
"Archive`_, you also get an interactive *EXPLORE* section, which allows peers"
" to browse the AiiDA provenance graph directly in the browser."
msgstr ""
"AiiDA的档案文件可以发布在任何研究数据仓库，例如 `Materials Cloud Archive`_, `Zenodo`_, 或 `Open "
"Science Framework`_ 。当在 `Materials Cloud Archive`_ 上发布AiiDA档案时，你也会得到一个交互式的 "
"*EXPLORE* 部分，它允许同行在浏览器中直接浏览AiiDA可验证性图。"

#: ../../source/howto/share_data.rst:75
msgid "Inspecting an archive"
msgstr ""

#: ../../source/howto/share_data.rst:77
msgid ""
"In order to get a quick overview of an archive file *without* importing it "
"into your AiiDA profile, use ``verdi archive info``:"
msgstr ""

#: ../../source/howto/share_data.rst:147
msgid ""
"You can also use the Python API to inspect the archive file as a profile, "
"see :ref:`how-to:data:share:archive:profile`."
msgstr ""

#: ../../source/howto/share_data.rst:150
msgid "Importing an archive"
msgstr "导入归档"

#: ../../source/howto/share_data.rst:152
msgid ""
"Use ``verdi archive import`` to import AiiDA archives into your current "
"AiiDA profile. ``verdi archive import`` accepts URLs, e.g.:"
msgstr ""
"使用 ``verdi archive import`` 导入AiiDA档案到当前的AiiDA配置文件。 ``verdi archive import``"
" 接受使用URLs，例如:"

#: ../../source/howto/share_data.rst:159
msgid ""
"During import, AiiDA will avoid identifier collisions and node duplication "
"based on UUIDs (and email comparisons for :py:class:`~aiida.orm.users.User` "
"entries). By default, existing entities will be updated with the most recent"
" changes. Node extras and comments have special modes for determining how to"
" import them - for more details, see ``verdi archive import --help``."
msgstr ""
"在导入过程中，AiiDA将基于uuid(以及  :py:class:`~aiida.orm.users.User`  "
"的电子邮件比较)避免标识符冲突和节点重复)。默认情况下，现有实体将使用最新的更改进行更新。额外的节点和注释有特殊的模式来决定如何导入它们-"
"更多详细信息，请参见 ``verdi archive import --help`` 。"

#: ../../source/howto/share_data.rst:163
msgid ""
"To see what would be imported, before importing, you can use the ``--test-"
"run`` option:"
msgstr ""

#: ../../source/howto/share_data.rst:169
msgid ""
"The AiiDA archive format has evolved over time, but you can still import "
"archives created with previous AiiDA versions. If an outdated archive "
"version is detected during import, the archive file will be automatically "
"migrated to the newest version (within a temporary folder) and the import "
"retried."
msgstr ""
"AiiDA归档格式随着时间的推移而发展，但是您仍然可以导入使用以前的AiiDA版本创建的存档。如果在导入过程中检测到过期的归档文件版本，归档文件将自动迁移到最新版本(在一个临时文件夹中)，然后重试导入。"

#: ../../source/howto/share_data.rst:172
msgid ""
"You can also use ``verdi archive migrate`` to create updated archive files "
"from existing archive files (or update them in place)."
msgstr "您还可以使用 ``verdi archive migrate`` 从现有的归档文件创建更新的归档文件(或在特定地方更新它们)。"

#: ../../source/howto/share_data.rst:177
msgid "Serving data through the REST API"
msgstr "通过REST API提供数据"

#: ../../source/howto/share_data.rst:179
msgid ""
"The AiiDA REST API allows to query your AiiDA database over HTTP(S) and "
"returns results in :ref:`JSON format <reference:rest-api:endpoints-"
"responses>`."
msgstr ""
"AiiDA REST API允许通过HTTP(S)查询AiiDA数据库，并以 :ref:`JSON格式 <reference:rest-"
"api:endpoints-responses>` 返回结果。"

#: ../../source/howto/share_data.rst:183
msgid ""
"As of October 2020, the AiiDA REST API only supports ``GET`` methods "
"(reading); in particular, it does *not* yet support workflow management. "
"This feature is, however, part of the `AiiDA roadmap "
"<https://github.com/aiidateam/aiida-core/wiki/AiiDA-release-roadmap>`_."
msgstr ""
"截至2020年10月，AiiDA REST API只支持 ``GET`` 方法(读取);特别是，它还不支持工作流管理。然而，这个特性是 "
"`AiiDA未来计划<https://github.com/aiidateam/aiida-core/wiki/AiiDA-release-"
"roadmap>`_ 的一部分。"

#: ../../source/howto/share_data.rst:188
msgid ""
"To ensure that when serving ``orm.ArrayData`` one always obtains a valid "
"JSON compliant with the `ECMA-262 standard <https://www.ecma-"
"international.org/publications-and-standards/standards/ecma-262/>`_, any "
"``np.nan``, ``np.inf`` and/or ``-np.inf`` entries will be replaced by "
"``None`` which will be rendered as ``null`` when getting the array via the "
"API call."
msgstr ""

#: ../../source/howto/share_data.rst:194
msgid "Launching the REST API"
msgstr "启动REST API"

#: ../../source/howto/share_data.rst:196
msgid "Start serving data from your default AiiDA profile via the REST API:"
msgstr "开始通过REST API从默认的AiiDA配置文件中提供数据:"

#: ../../source/howto/share_data.rst:209
msgid "The REST API is now running on port ``5000`` of your local computer."
msgstr "REST API现在运行在本地计算机的端口 ``5000`` 上。"

#: ../../source/howto/share_data.rst:211
msgid ""
"Like all ``verdi`` commands, you can select a different AiiDA profile via "
"the ``-p PROFILE`` option:"
msgstr "像所有 ``verdi`` 命令一样，你可以通过 ``-p profile`` 选项选择一个不同的AiiDA配置文件:"

#: ../../source/howto/share_data.rst:219
msgid "REST API version history:"
msgstr "REST API版本历史:"

#: ../../source/howto/share_data.rst:223
msgid "Version history"
msgstr "版本历史"

#: ../../source/howto/share_data.rst:225
msgid ""
"``aiida-core`` >= 1.0.0b6: ``v4``. Simplified endpoints; only ``/nodes``, "
"``/processes``, ``/calcjobs``, ``/groups``, ``/computers`` and ``/servers`` "
"remain."
msgstr ""
"``aiida-core`` >= 1.0.0b6: ``v4``. 简单的接入点; 仅支持 ``/nodes``, ``/processes``, "
"``/calcjobs``, ``/groups``, ``/computers`` 以及保留 ``/servers`` ."

#: ../../source/howto/share_data.rst:226
msgid ""
"``aiida-core`` >= 1.0.0b3, <1.0.0b6: ``v3``. Development version, never "
"shipped with a stable release."
msgstr "``aiida-core`` >= 1.0.0b3, <1.0.0b6: ``v3``. 开发版本，从不与稳定版本一起发布。"

#: ../../source/howto/share_data.rst:227
msgid ""
"``aiida-core`` <1.0.0b3: ``v2``. First API version, with new endpoints added"
" step by step."
msgstr "``aiida-core`` <1.0.0b3: ``v2``. 第一个API版本，逐步添加了新的接入点。"

#: ../../source/howto/share_data.rst:233
msgid "Querying the REST API"
msgstr "查询REST API"

#: ../../source/howto/share_data.rst:235
msgid "A URL to query the REST API consists of:"
msgstr "一个查询REST API的URL包含:"

#: ../../source/howto/share_data.rst:237
msgid "The *base URL*, by default:"
msgstr "默认情况下， *base URL*:"

#: ../../source/howto/share_data.rst:239
msgid "http://127.0.0.1:5000/api/v4"
msgstr "http://127.0.0.1:5000/api/v4"

#: ../../source/howto/share_data.rst:241
msgid "Querying the base URL returns a list of all available endpoints."
msgstr "查询这个URL将返回所有可用接入点的列表。"

#: ../../source/howto/share_data.rst:243
msgid ""
"The *path* defining the requested *resource*, optionally followed by a more "
"specific *endpoint*. For example::"
msgstr "定义被请求的 *资源* 的 *路径* ，可以选择后面跟着一个更具体的 *接入点* 。例如::"

#: ../../source/howto/share_data.rst:252
msgid ""
"If no endpoint is appended, the API returns a list of objects of that "
"resource. In order to request a specific object of a resource, append its "
"*UUID*."
msgstr "如果没有附加接入点，API将返回该资源的对象列表。为了请求一个资源的特定对象，需要附加它的 *UUID* 。"

#: ../../source/howto/share_data.rst:257
msgid "As usual, you can use partial UUIDs as long as they are unique."
msgstr "通常，只要输入的uuid部分是惟一的，就可以使用它们。"

#: ../../source/howto/share_data.rst:259
msgid ""
"In order to query by *PK* you need to use the ``id`` filter (see below). "
"This also applies to :py:class:`~aiida.orm.users.User` s, which don't have "
"UUIDs (but instead uses email)."
msgstr ""
"为了通过 *PK* 进行查询，您需要使用 ``id`` 过滤器(见下文)。这也适用于 :py:class:`~aiida.orm.users.User`"
"  ，它没有UUID(而是使用电子邮件)。"

#: ../../source/howto/share_data.rst:262
msgid ""
"(Optional) The *query string* for filtering, ordering and pagination of "
"results. For example::"
msgstr "(可选)用于过滤、排序和分页结果的 *查询字符串* 。例如::"

#: ../../source/howto/share_data.rst:269
msgid "Here are some examples to try::"
msgstr "下面是一些可用的例子:"

#: ../../source/howto/share_data.rst:277
msgid ""
"The interactive `EXPLORE sections on Materials Cloud "
"<https://www.materialscloud.org/explore/menu>`_ are all powered by the AiiDA"
" REST API and you can query the underlying API, either using your web "
"browser or using a tool like ``curl``:"
msgstr ""
"`在 Materials Cloud 的 EXPLORE 部分 "
"<https://www.materialscloud.org/explore/menu>`_ 的交互都是由AiiDA REST "
"API提供的，你可以查询底层API，可以使用你的web浏览器或使用像 ``curl`` 这样的工具:"

#: ../../source/howto/share_data.rst:283
msgid ""
"For an extensive user documentation of the endpoints, the query string as "
"well as the format of the responses, see the :ref:`AiiDA REST API reference "
"<reference:rest-api>`."
msgstr ""
"有关接入点的详细用户文档、查询字符串以及响应的格式，请参见 :ref:``AiiDA REST API参考 <reference:rest-api>``"
" 。"

#: ../../source/howto/share_data.rst:287
msgid ""
"It is possible to allow a request to declare a specific profile for which to"
" run the profile. This makes it possible to use a single REST API to serve "
"the content of all configured profiles. The profile switching functionality "
"is disabled by default but can be enabled through the config:"
msgstr ""

#: ../../source/howto/share_data.rst:295
msgid ""
"After the REST API is restarted, it will now accept the `profile` query "
"parameter, for example:"
msgstr ""

#: ../../source/howto/share_data.rst:301
msgid ""
"If the specified is already loaded, the REST API functions exactly as "
"without profile switching enabled. If another profile is specified, the REST"
" API will first switch profiles before executing the request."
msgstr ""

#: ../../source/howto/share_data.rst:306
msgid ""
"If the profile parameter is specified in a request and the REST API does not"
" have profile switching enabled, a 400 response is returned."
msgstr ""

#: ../../source/howto/share_data.rst:311
msgid "Deploying a REST API server"
msgstr "部署REST API服务器"

#: ../../source/howto/share_data.rst:313
msgid ""
"The ``verdi restapi`` command runs the REST API through the ``werkzeug`` "
"python-based HTTP server. In order to deploy production instances of the "
"REST API for serving your data to others, we recommend using a fully fledged"
" web server, such as `Apache <https://httpd.apache.org/>`_ or `NGINX "
"<https://www.nginx.com/>`_, which then runs the REST API python application "
"through the `web server gateway interface (WSGI) "
"<https://wsgi.readthedocs.io/>`_."
msgstr ""

#: ../../source/howto/share_data.rst:317
msgid ""
"One Apache/NGINX server can host multiple instances of the REST APIs, e.g. "
"serving data from different AiiDA profiles."
msgstr "一个Apache/NGINX服务器可以承载多个REST API实例，例如服务来自不同AiiDA配置文件的数据。"

#: ../../source/howto/share_data.rst:319
msgid ""
"A ``myprofile-rest.wsgi`` script for an AiiDA profile ``myprofile`` would "
"look like this:"
msgstr "AiiDA配置文件 ``myprofile`` 的` `myprofile-rest.wsgi`` 脚本看起来如下:"

#: ../../source/howto/share_data.rst:323
msgid ""
"See the documentation of :py:func:`~aiida.restapi.run_api.configure_api` for"
" all available configuration options."
msgstr "请参阅 :py:func:`~aiida.restapi.run_api.configure_api` 的文档获取所有可用的配置选项。"

#: ../../source/howto/share_data.rst:325
msgid ""
"In the following, we explain how to run this wsgi application using Apache "
"on Ubuntu."
msgstr "下面，我们将解释如何在Ubuntu上使用Apache运行这个wsgi应用程序。"

#: ../../source/howto/share_data.rst:327
msgid ""
"Install and enable the ``mod_wsgi`` `WSGI module "
"<https://modwsgi.readthedocs.io/>`_ module:"
msgstr ""

#: ../../source/howto/share_data.rst:334
msgid ""
"Place the WSGI script in a folder on your server, for example "
"``/home/ubuntu/wsgi/myprofile-rest.wsgi``."
msgstr "将WSGI脚本放在服务器上的一个文件夹中，例如 ``/home/ubuntu/ WSGI /myprofile-rest.wsgi`` 。"

#: ../../source/howto/share_data.rst:336
msgid ""
"Configure apache to run the WSGI application using a virtual host "
"configuration similar to:"
msgstr "配置apache以运行WSGI应用程序，使用类似于以下的虚拟主机配置:"

#: ../../source/howto/share_data.rst:340
msgid "Place this ``aiida-rest.conf`` file in ``/etc/apache2/sites-enabled``"
msgstr "将 ``aiida-rest.conf`` 文件放到 ``/etc/apache2/sites-enabled`` 中"

#: ../../source/howto/share_data.rst:342
msgid "Restart apache: ``sudo service apache2 restart``."
msgstr "重启apache: ``sudo service apache2 restart`` 。"

#: ../../source/howto/share_data.rst:344
msgid ""
"You should now be able to reach your REST API at "
"``localhost/myprofile/api/v4`` (Port 80)."
msgstr "您现在应该能够在 ``localhost/myprofile/API/v4`` (端口80) 处访问您的REST API。"

#: ../../source/howto/ssh.rst:5
msgid "How to setup SSH connections"
msgstr "如何建立SSH连接"

#: ../../source/howto/ssh.rst:7
msgid ""
"AiiDA communicates with remote computers via the SSH protocol. There are two"
" ways of setting up an SSH connection for AiiDA:"
msgstr "AiiDA通过SSH协议与远程计算机进行通信。有两种方法为AiiDA建立SSH连接:"

#: ../../source/howto/ssh.rst:10
msgid "Using a passwordless SSH key (easier, less safe)"
msgstr "使用无密码SSH密钥(更容易，更不安全)"

#: ../../source/howto/ssh.rst:11
msgid ""
"Using a password-protected SSH key through ``ssh-agent`` (one more step, "
"safer)"
msgstr "通过 ``SSH -agent`` 使用受密码保护的SSH密钥(多一步，更安全)"

#: ../../source/howto/ssh.rst:16
msgid "Using a passwordless SSH key"
msgstr "使用无密码SSH密钥"

#: ../../source/howto/ssh.rst:19
msgid ""
"There are numerous tutorials on the web, see e.g. `here "
"<https://www.redhat.com/sysadmin/passwordless-ssh>`_. Very briefly, first "
"create a new private/public keypair (``aiida``/``aiida.pub``), leaving "
"passphrase emtpy:"
msgstr ""
"网上有很多教程，比如 `参考材料< https://www.redhat.com/sysadmin/passwordless-ssh>`_ "
"。简单地说，首先创建一个新的私有/公共密钥对( ``aiida``/``aiida.pub``)，让密码短语为空:"

#: ../../source/howto/ssh.rst:26
msgid ""
"Copy the public key to the remote machine, normally this will add the public"
" key to the remote machine's ``~/.ssh/authorized_keys``:"
msgstr ""

#: ../../source/howto/ssh.rst:32
msgid ""
"Add the following lines to your ``~/.ssh/config`` file (or create it, if it "
"does not exist):"
msgstr "将以下行添加到您的 ``~/.ssh/config`` 文件(或创建它，如果它不存在):"

#: ../../source/howto/ssh.rst:42
msgid ""
"If your cluster needs you to connect to another computer *PROXY* first, you "
"can use the ``ProxyJump`` or ``ProxyCommand`` feature of SSH, see :ref:`how-"
"to:ssh:proxy`."
msgstr ""

#: ../../source/howto/ssh.rst:44
msgid ""
"You should now be able to access the remote computer (without the need to "
"type a password) *via*:"
msgstr "你现在应该可以通过下面指令访问远程计算机(不需要输入密码):"

#: ../../source/howto/ssh.rst:52
msgid "Connection closed failures"
msgstr "连接关闭失败"

#: ../../source/howto/ssh.rst:56
msgid ""
"If the ``ssh`` command works, but the ``sftp`` command prints ``Connection "
"closed``, there may be a line in the ``~/.bashrc`` file **on the cluster** "
"that either produces text output or an error. Remove/comment lines from this"
" file until no output or error is produced: this should make ``sftp`` work "
"again."
msgstr ""
"如果 ``ssh`` 命令可以工作，但 ``sftp`` 命令却不行 (例如打印 ``Connection closed``) ，一个可能的原因是 "
"**在集群上** 文件 ``~/.bashrc`` 中有打印文本或存在错误。删除/注释这些行，直到没有输出没有错误：这让 ``sftp`` 正常工作."

#: ../../source/howto/ssh.rst:59
msgid ""
"Finally, if you are planning to use a batch scheduler on the remote "
"computer, try also:"
msgstr "最后，如果您计划在远程计算机上使用调度程序，请尝试:"

#: ../../source/howto/ssh.rst:65
msgid ""
"replacing ``QUEUE_VISUALIZATION_COMMAND`` by ``squeue`` (SLURM), ``qstat`` "
"(PBSpro) or the equivalent command of your scheduler and check that it "
"prints a list of the job queue without errors."
msgstr ""
"将 ``QUEUE_VISUALIZATION_COMMAND`` 替换为 ``squeue``(SLURM)， ``qstat`` "
"(PBSpro)或其他调度程序的等价命令，并检查它是否打印作业队列的列表而没有错误。"

#: ../../source/howto/ssh.rst:67
msgid "Scheduler errors?"
msgstr "任务调度程序错误?"

#: ../../source/howto/ssh.rst:70
msgid ""
"If the previous command errors with ``command not found``, while the same "
"``QUEUE_VISUALIZATION_COMMAND`` works fine after you've logged in via SSH, "
"it may be that a guard in the ``.bashrc`` file on the cluster prevents "
"necessary modules from being loaded."
msgstr ""
"如果前面的指令提示 ``命令没有找到`` ，而相同的 ``QUEUE_VISUALIZATION_COMMAND`` "
"在您通过SSH登录后工作正常，它可能是由于集群上 ``.bashrc`` 文件阻止了必要模块的加载。"

#: ../../source/howto/ssh.rst:72
msgid "Look for lines like:"
msgstr "寻找这样一行:"

#: ../../source/howto/ssh.rst:78
msgid "or:"
msgstr "或者:"

#: ../../source/howto/ssh.rst:87
msgid "which will prevent any instructions that follow from being executed."
msgstr "这将阻止后面的指令被执行。"

#: ../../source/howto/ssh.rst:89
msgid ""
"You can either move relevant instructions before these lines or delete the "
"guards entirely. If you are wondering whether the ``PATH`` environment "
"variable is set correctly, you can check its value using:"
msgstr ""
"您可以将相关的指令移动到这些行之前，或者完全删除这个阻止加载地行为。如果你想知道 ``PATH`` "
"环境变量是否被正确设置，你可以使用以下方法检查它的值:"

#: ../../source/howto/ssh.rst:99
msgid "Using passphrase-protected keys *via* an ssh-agent"
msgstr "通过 ssh-agent使用密码短语保护的密钥"

#: ../../source/howto/ssh.rst:102
msgid ""
"Tools like ``ssh-agent`` (available on most Linux distros and MacOS) allow "
"you to enter the passphrase of a protected key *once* and provide access to "
"the decrypted key for as long as the agent is running. This allows you to "
"use a passphrase-protected key (required by some HPC centres), while making "
"the decrypted key available to AiiDA for automatic SSH operations."
msgstr ""
"像 ``ssh-agent`` 这样的工具(在大多数Linux发行版和MacOS上可用)允许您 *仅一次* 输入受保护密钥的口令，并在 ssh-"
"agent "
"运行期间提供对解密密钥的访问。这允许您使用密码短语保护的密钥(一些HPC中心需要这样的操作以确保安全性)，同时使解密的密钥对AiiDA可用以进行自动SSH操作。"

#: ../../source/howto/ssh.rst:106
msgid "Creating the key"
msgstr "创建钥匙"

#: ../../source/howto/ssh.rst:108
msgid ""
"Start by following the instructions above for :ref:`how-"
"to:ssh:passwordless`, the only difference being that you enter a passphrase "
"when creating the key (and when logging in to the remote computer)."
msgstr ""
"首先按照上面的说明操作 :ref:`how-to:ssh:passwordless` "
"，唯一的区别是在创建密钥时输入一个密码短语(以及登录到远程计算机时)。"

#: ../../source/howto/ssh.rst:111
msgid "Adding the key to the agent"
msgstr "向 ssh-agent 添加密钥"

#: ../../source/howto/ssh.rst:113
msgid "Now provide the passphrase for your private key to the agent:"
msgstr "现在向 ssh-agent 提供您的私钥的密码短语:"

#: ../../source/howto/ssh.rst:119
msgid ""
"The private key and the relative passphrase are now recorded in an instance "
"of the agent."
msgstr "私钥和相对密码短语现在 ssh-agent 在代理的一个实例中。"

#: ../../source/howto/ssh.rst:123
msgid ""
"The passphase is stored in the agent only until the next reboot. If you shut"
" down or restart the AiiDA machine, before starting the AiiDA deamon "
"remember to run the ``ssh-add`` command again."
msgstr ""
"密码短语只存储在代理中，直到下一次重新启动。如果您关闭或重新启动AiiDA机器，在启动AiiDA守护进程之前，请记住再次运行 ``ssh-add`` "
"命令。"

#: ../../source/howto/ssh.rst:127
msgid "Starting the ssh-agent"
msgstr "启动ssh-agent"

#: ../../source/howto/ssh.rst:129
msgid ""
"On most modern Linux installations, the ``ssh-agent`` starts automatically "
"at login (e.g. Ubuntu 16.04 and later or MacOS 10.5 and later). If you "
"received an error ``Could not open a connection to your authentication "
"agent``, you will need to start the agent manually instead."
msgstr ""
"在大多数现代Linux安装中， ``ssh-agent`` 会在登录时自动启动(例如Ubuntu 16.04及更高版本或MacOS "
"10.5及更高版本)。如果你收到错误 ``Could not open a connection to your authentication "
"agent`` ，你将需要手动启动代理。"

#: ../../source/howto/ssh.rst:132
msgid ""
"Check whether you can start an ``ssh-agent`` **in your current shell**:"
msgstr "检查你是否 **在你当前的shell** 启动了 ``ssh-agent`` :"

#: ../../source/howto/ssh.rst:138
msgid ""
"In order to reuse the same agent instance everywhere (including the AiiDA "
"daemon), the environment variables of ``ssh-agent`` need to be reused by "
"*all* shells. Download the script :download:`load-singlesshagent.sh "
"<include/load-singlesshagent.sh>` and place it e.g. in ``~/bin``. Then add "
"the following lines to your ``~/.bashrc`` file:"
msgstr ""
"为了在所有地方重用同一个代理实例(包括AiiDA守护进程)， ``ssh-agent`` 的环境变量需要被 *所有* shell重用。下载脚本 "
":download:`load-singlesshagent.sh <include/load-singlesshagent.sh>`  ，并将其放置在"
" ``~/bin`` 中。然后将以下行添加到您的 ``~/.bashrc`` 文件:"

#: ../../source/howto/ssh.rst:148
msgid "To check that it works:"
msgstr "要检查它是否工作:"

#: ../../source/howto/ssh.rst:150
msgid "Open a new shell (``~/.bashrc`` file is sourced)."
msgstr "打开一个新的shell (``~/.bashrc`` 确保文件被加载)。"

#: ../../source/howto/ssh.rst:151
msgid "Run ``ssh-add``."
msgstr "运行 ``ssh-add``."

#: ../../source/howto/ssh.rst:152
msgid "Close the shell."
msgstr "关闭shell。"

#: ../../source/howto/ssh.rst:153
msgid "Open a new shell and try logging in to the remote computer."
msgstr "打开一个新的shell，并尝试登录到远程计算机。"

#: ../../source/howto/ssh.rst:155
msgid ""
"Try logging in to the remote computer; it should no longer require a "
"passphrase."
msgstr "尝试登录到远程计算机;它应该不再需要密码短语。"

#: ../../source/howto/ssh.rst:157
msgid ""
"The key and its corresponding passphrase are now stored by the agent until "
"it is stopped. After a reboot, remember to run ``ssh-add ~/.ssh/aiida`` "
"again before starting the AiiDA daemon."
msgstr ""
"密钥及其对应的密码短语现在由代理存储，到它停止为止。在重新启动后，记得在启动aiida守护进程之前再次运行 ``ssh-add "
"~/.ssh/aiida``  。"

#: ../../source/howto/ssh.rst:161
msgid "Integrating the ssh-agent with keychain on OSX"
msgstr "在OSX上将ssh-agent和keychain集成"

#: ../../source/howto/ssh.rst:163
msgid ""
"On OSX Sierra and later, the native ``ssh-add`` client allows passphrases to"
" be stored persistently in the `OSX keychain <https://support.apple.com/en-"
"gb/guide/keychain-access/kyca1083/mac>`__. Store the passphrase in the "
"keychain using the OSX-specific ``-k`` argument:"
msgstr ""
"在OSX Sierra和更高版本上，本机 ``ssh-add`` 客户端允许密码短语被持久化存储在  `OSX keychain "
"<https://support.apple.com/en-gb/guide/keychain-access/kyca1083/mac>`__ "
"。使用OSX特定的 ``-k`` 参数在keychain中存储密码短语:"

#: ../../source/howto/ssh.rst:170
msgid ""
"To instruct ssh to look in the OSX keychain for key passphrases, add the "
"following lines to ``~/.ssh/config``:"
msgstr "要指示ssh在OSX keychain中查找密钥密码短语，在 ``~/.ssh/config`` 中添加以下行:"

#: ../../source/howto/ssh.rst:178 ../../source/howto/ssh.rst:245
msgid "AiiDA configuration"
msgstr "AiiDA配置"

#: ../../source/howto/ssh.rst:180
msgid ""
"When :ref:`configuring the computer in AiiDA <how-to:run-"
"codes:computer:configuration>`, simply make sure that ``Allow ssh agent`` is"
" set to ``true`` (default)."
msgstr ""
"当 :ref:`在AiiDA中配置计算机器 <how-to:run-codes:computer:configuration>` 时，只需确保 "
"``Allow ssh agent`` 被设置为 ``true`` (默认)。"

#: ../../source/howto/ssh.rst:185
msgid "Connecting to a remote computer *via* a proxy server"
msgstr "通过代理服务器连接到远程计算机"

#: ../../source/howto/ssh.rst:187
msgid ""
"Some compute clusters require you to connect to an intermediate server "
"*PROXY*, from which you can then connect to the cluster *TARGET* on which "
"you run your calculations. This section explains how to use the "
"``ProxyJump`` or ``ProxyCommand`` feature of ``ssh`` in order to make this "
"jump automatically."
msgstr ""

#: ../../source/howto/ssh.rst:192
msgid ""
"This method can also be used to avoid having to start a virtual private "
"network (VPN) client if you have an SSH account on a proxy/jumphost server "
"which is accessible from your current network **and** from which you can "
"access the *TARGET* machine directly."
msgstr ""

#: ../../source/howto/ssh.rst:196
msgid "SSH configuration"
msgstr "SSH配置"

#: ../../source/howto/ssh.rst:198
msgid ""
"To decide whether to use the ``ProxyJump`` (recommended) or the "
"``ProxyCommand`` directive, please check the version of your SSH client "
"first with ``ssh -V``. The ``ProxyJump`` directive has been added in version"
" 7.3 of OpenSSH, hence if you are using an older version of SSH (on your "
"machine or the *PROXY*) you have to use the older ``ProxyCommand``."
msgstr ""

#: ../../source/howto/ssh.rst:201
msgid ""
"To setup the proxy configuration with ``ProxyJump``, edit the "
"``~/.ssh/config`` file on the computer on which you installed AiiDA (or "
"create it if missing) and add the following lines::"
msgstr ""

#: ../../source/howto/ssh.rst:213 ../../source/howto/ssh.rst:229
msgid ""
"Replace the ``..._TARGET`` and ``..._PROXY`` variables with the host/user "
"names of the respective servers."
msgstr ""

#: ../../source/howto/ssh.rst:0
msgid ":fa:`plus-circle` Alternative setup with ``ProxyCommand``"
msgstr ""

#: ../../source/howto/ssh.rst:217
msgid ""
"To setup the proxy configuration with ``ProxyCommand`` **instead**, edit the"
" ``~/.ssh/config`` file on the computer on which you installed AiiDA (or "
"create it if missing) and add the following lines::"
msgstr ""

#: ../../source/howto/ssh.rst:231
msgid ""
"In both cases, this should allow you to directly connect to the *TARGET* "
"server using"
msgstr ""

#: ../../source/howto/ssh.rst:241
msgid ""
"If the user directory is not shared between the *PROXY* and the *TARGET* (in"
" most supercomputing facilities your user directory is shared between the "
"machines), you need to follow the :ref:`instructions for a passwordless "
"connection <how-to:ssh:passwordless>` *twice*: once for the connection from "
"your computer to the *PROXY* server, and once for the connection from the "
"*PROXY* server to the *TARGET* server (e.g. the public key must be listed in"
" the ``~/.ssh/authorized_keys`` file of both the *PROXY* and the *TARGET* "
"server)."
msgstr ""

#: ../../source/howto/ssh.rst:247
msgid ""
"When :ref:`configuring the computer in AiiDA <how-to:run-"
"codes:computer:configuration>`, AiiDA will automatically parse most of "
"required information from your ``~/.ssh/config`` file. A notable exception "
"to this is the ``proxy_jump`` directive, which **must** be specified "
"manually."
msgstr ""

#: ../../source/howto/ssh.rst:249
msgid ""
"Simply copy & paste the same instructions as you have used for ``ProxyJump``"
" in your ``~/.ssh/config`` to the input for ``proxy_jump``:"
msgstr ""

#: ../../source/howto/ssh.rst:258
msgid ""
"A chain of proxies can be specified as a comma-separated list. If you need "
"to specify a different username, you can so with ``USER_PROXY@...``. If no "
"username is specified for the proxy the same username as for the *TARGET* is"
" used."
msgstr ""

#: ../../source/howto/ssh.rst:260
msgid "Specifying the ``proxy_command`` manually"
msgstr ""

#: ../../source/howto/ssh.rst:262
msgid ""
"When specifying or updating the ``proxy_command`` option via ``verdi "
"computer configure ssh``, please **do not use placeholders** ``%h`` and "
"``%p`` but provide the *actual* hostname and port. AiiDA replaces them only "
"when parsing from the ``~/.ssh/config`` file."
msgstr ""
"当通过 ``verdi computer configure ssh`` 指定或更新 ``proxy_command`` 选项时，请 "
"**不要使用占位符**  ``%h`` 和 ``%p``，而是提供 *实际的* 主机名和端口。AiiDA只在解析  ``~/.ssh/config`` "
"时替换它们。"

#: ../../source/howto/ssh.rst:267
msgid "Using kerberos tokens"
msgstr "使用kerberos令牌"

#: ../../source/howto/ssh.rst:269
msgid ""
"If the remote machine requires authentication through a Kerberos token (that"
" you need to obtain before using ssh), you typically need to"
msgstr "如果远程计算机需要通过Kerberos令牌(在使用ssh之前需要获得)进行身份验证，那么通常需要这样做"

#: ../../source/howto/ssh.rst:271
msgid "install ``libffi`` (``sudo apt-get install libffi-dev`` under Ubuntu)"
msgstr "安装 ``libffi`` （在Ubuntu使用 ``sudo apt-get install libffi-dev`` ）"

#: ../../source/howto/ssh.rst:272
msgid ""
"install the ``ssh_kerberos`` extra during the installation of aiida-core "
"(see :ref:`intro:install:setup`)."
msgstr ""
"在安装 ``aiida-core`` 时安装额外的 ``ssh_kerberos`` (请参见 :ref:`intro:install:setup` "
")。"

#: ../../source/howto/ssh.rst:274
msgid ""
"If you provide all necessary ``GSSAPI`` options in your ``~/.ssh/config`` "
"file, ``verdi computer configure`` should already pick up the appropriate "
"values for all the gss-related options."
msgstr ""
"如果你在你的  ``~/.ssh/config`` 中提供所有必要的 ``GSSAPI`` 选项。``verdi computer "
"configure`` 应该已经为所有gss相关选项选择了适当的值。"

#: ../../source/howto/visualising_graphs.md:16
msgid "How to visualize provenance"
msgstr "如将可验证性可视地输出"

#: ../../source/howto/visualising_graphs.md:1
msgid ""
"This tutorial can be downloaded and run as a Jupyter Notebook: {nb-"
"download}`visualising_graphs.ipynb` {octicon}`download`"
msgstr ""

#: ../../source/howto/visualising_graphs.md:22
msgid ""
"The provenance graph of a database can be visually inspected, *via* "
"[graphviz](https://www.graphviz.org/), using both the python API and "
"command-line interface."
msgstr ""

#: ../../source/howto/visualising_graphs.md:1
msgid "`verdi graph generate -h`"
msgstr ""

#: ../../source/howto/visualising_graphs.md:28
msgid ""
"We first load a profile, containing the provenance graph (in this case we "
"load an archive as the profile)."
msgstr ""

#: ../../source/howto/visualising_graphs.md:45
msgid ""
"The {py:class}`~aiida.tools.visualization.graph.Graph` class is used to "
"store visual representations of the nodes and edges, which can be added "
"separately or cumulatively by one of the graph traversal methods. The "
"{py:attr}`~aiida.tools.visualization.graph.Graph.graphviz` attribute returns"
" a [graphviz.Digraph](https://graphviz.readthedocs.io/en/stable/) instance, "
"which will auto-magically render the graph in the notebook, or can be used "
"to save the graph to file."
msgstr ""

#: ../../source/howto/visualising_graphs.md:68
msgid ""
"The {py:class}`~aiida.tools.visualization.graph.Graph` can also be "
"initialized with global style attributes, as outlined in the [graphviz "
"attributes table](https://www.graphviz.org/doc/info/attrs.html)."
msgstr ""

#: ../../source/howto/visualising_graphs.md:81
msgid ""
"Additionally functions can be parsed to the "
"{py:class}`~aiida.tools.visualization.graph.Graph` initializer, to specify "
"exactly how each node will be represented. For example, the "
"{py:func}`~aiida.tools.visualization.graph.pstate_node_styles` function "
"colors process nodes by their process state."
msgstr ""

#: ../../source/howto/visualising_graphs.md:95
msgid ""
"Edges can be annotated by one or both of their edge label and link type."
msgstr "边线可用边线标签与连线类型或是两者来作注释。"

#: ../../source/howto/visualising_graphs.md:106
msgid ""
"The {py:meth}`~aiida.tools.visualization.graph.Graph.recurse_descendants` "
"and {py:meth}`~aiida.tools.visualization.graph.Graph.recurse_ancestors` "
"methods can be used to construct a full provenance graph."
msgstr ""

#: ../../source/howto/visualising_graphs.md:119
msgid ""
"The link types can also be filtered, to view only the 'data' or 'logical' "
"provenance."
msgstr ""

#: ../../source/howto/visualising_graphs.md:145
msgid ""
"If you wish to highlight specific node classes, then the `highlight_classes`"
" option can be used to only color specified nodes:"
msgstr ""

#: ../../source/howto/workchains_restart.rst:5
msgid "How to write error-resistant workflows"
msgstr "如何编写不易出错的工作流"

#: ../../source/howto/workchains_restart.rst:7
msgid "Overview"
msgstr "概览"

#: ../../source/howto/workchains_restart.rst:9
msgid ""
"This how-to introduces the "
":py:class:`~aiida.engine.processes.workchains.restart.BaseRestartWorkChain`,"
" and how it can be sub-classed to handle known failure modes of processes "
"and calculations."
msgstr ""
"该howto章节介绍了 "
":py:class:`~aiida.engine.processes.workchains.restart.BaseRestartWorkChain` "
"，以及如何将其子类化来处理流程和算例的已知失败模式。"

#: ../../source/howto/workchains_restart.rst:11
msgid ""
"In the :ref:`how-to on writing workflows <how-to:write-workflows>` we "
"discussed how to write a simple multi-step workflow using work chains. "
"However, there is one thing that we did not consider there:"
msgstr ""
"在 :ref:`如何写工作流 <how-to:write-"
"workflows>`中，我们讨论了如何使用工作链编写一个简单的多步骤工作流。然而，有一件事我们没有考虑到:"

#: ../../source/howto/workchains_restart.rst:14
msgid "What if a calculation step fails?"
msgstr "如果算例中间步骤失败了怎么办?"

#: ../../source/howto/workchains_restart.rst:16
msgid ""
"For example with the "
":py:class:`~aiida.workflows.arithmetic.multiply_add.MultiplyAddWorkChain`; "
"it launches a "
":py:class:`~aiida.calculations.arithmetic.add.ArithmeticAddCalculation`. If "
"that were to fail, the work chain would except because the line "
"``self.ctx.addition.outputs.sum`` will raise an ``AttributeError``. In this "
"case, where the work chain just runs a single calculation, that is not such "
"a big deal but for real-life work chains that run a number of calculations "
"in sequence, having the work chain except will cause all the work up to that"
" point to be lost. Take as an example a workflow that computes the phonons "
"of a crystal structure using Quantum ESPRESSO:"
msgstr ""
"例如  "
":py:class:`~aiida.workflows.arithmetic.multiply_add.MultiplyAddWorkChain`; "
"它启动一个  "
":py:class:`~aiida.calculations.arithmetic.add.ArithmeticAddCalculation` "
"。如果失败，工作链将会抛出异常，因为行 ``self.ctx.addition.outputs.sum`` 将引发 ``AttributeError``"
" "
"。在这种情况下，工作链只运行一个算例，对于这个例子这不是什么大问题，但对于按顺序运行大量计算的实际工作链，工作链在中间异常将导致在此点之前的所有工作都丢失。以一个使用Quantum"
" ESPRESSO计算晶体结构声子的工作流为例:"

#: ../../source/howto/workchains_restart.rst:23
msgid ""
"Schematic diagram of a workflow that computes the phonons of a crystal "
"structure using Quantum ESPRESSO. The workflow consists of four consecutive "
"calculations using the ``pw.x``, ``ph.x``, ``q2r.x`` and ``matdyn.x`` code, "
"respectively."
msgstr ""
"使用Quantum ESPRESSO计算晶体结构的声子的工作流程示意图。该工作流由使用 ``pw.x``, ``ph.x``, ``q2r.x`` 和 "
"``matdyn.x``  四个计算代码的步骤连续组成。"

#: ../../source/howto/workchains_restart.rst:26
msgid ""
"If all calculations run without problems, the workflow itself will of course"
" also run fine and produce the desired final result. But, now imagine the "
"third calculation actually fails. If the workflow does not explicitly check "
"for this failure, but instead blindly assumes that the calculation have "
"produced the required results, it will fail itself, losing the progress it "
"made with the first two calculations."
msgstr ""
"如果所有计算都能顺利运行，那么工作流本身当然也能正常运行，并产生所需的最终结果。但是，现在想象第三个计算实际上失败了。如果工作流没有明确地检查这个失败，而是盲目地假设计算已经产生了所需的结果，那么工作流本身就会失败，失去前两个计算所取得的进展。"

#: ../../source/howto/workchains_restart.rst:32
msgid ""
"Example execution of the Quantum ESPRESSO phonon workflow where the third "
"step, the ``q2r.x`` code, failed, and because the workflow blindly assumed "
"it would have finished without errors also fails."
msgstr ""
" Quantum ESPRESSO声子工作流第三步 ``q2r.x`` 执行失败，而且因为工作流简单地认为它会在没有错误的情况下完成，所以也失败了。"

#: ../../source/howto/workchains_restart.rst:34
msgid ""
"The solution seems simple then. After each calculation, we simply add a "
"check to verify that it finished successfully and produced the required "
"outputs before continuing with the next calculation. What do we do, though, "
"when the calculation failed? Depending on the cause of the failure, we might"
" actually be able to fix the problem, and re-run the calculation, "
"potentially with corrected inputs. A common example is that the calculation "
"ran out of wall time (requested time from the job scheduler) and was "
"cancelled by the job scheduler. In this case, simply restarting the "
"calculation (if the code supports restarts), and optionally giving the job "
"more wall time or resources, may fix the problem."
msgstr ""
"解决办法似乎很简单。即在每次计算之后，我们只需添加一个检查，以验证它成功完成并产生所需的输出，然后继续进行下一个计算。但是，当计算失败时，我们该怎么办?根据故障的原因，我们实际上可能能够修复问题，并重新运行计算，可能使用校正后的输入。一个常见的例子是，计算耗尽了上限时间(从作业调度器请求的时间)，并被作业调度器取消。在这种情况下，只需重新启动计算(如果计算代码支持重新启动)，并有选择性地给作业更多的时间或资源，就可以解决问题。"

#: ../../source/howto/workchains_restart.rst:41
msgid ""
"You might be tempted to add this error handling directly into the workflow. "
"However, this requires implementing the same error-handling code many times "
"in other workflows that just happen to run the same codes. For example, we "
"could add the error handling for the ``pw.x`` code directly in our phonon "
"workflow, but a structure optimization workflow will also have to run "
"``pw.x`` and will have to implement the same error-handling logic. Is there "
"a way that we can implement this once and easily reuse it in various "
"workflows?"
msgstr ""
"您可能想直接将此错误处理添加到工作流中。然而，这需要在运行相同代码的其他工作流中多次实现相同的错误处理代码。例如，我们可以直接在我们的声子工作流中为 "
"``pw.x`` 代码添加错误处理。但一个结构优化工作流程也将运行 ``pw.x`` "
"并实现相同的错误处理逻辑。是否有一种方法可以一次性实现，并在各种工作流中轻松重用它?"

#: ../../source/howto/workchains_restart.rst:46
msgid ""
"Yes! Instead of directly running a calculation in a workflow, one should "
"rather run a work chain that is explicitly designed to run the calculation "
"to completion. This *base* work chain knows about the various failure modes "
"of the calculation and can try to fix the problem and restart the "
"calculation whenever it fails, until it finishes successfully. This logic of"
" such a base work chain is very generic and can be applied to any "
"calculation, and actually any process:"
msgstr ""
"是的!与其在工作流中直接运行计算，不如运行一个明确设计为运行算例直至完成的工作链。这个 *base* "
"工作链知道算例的各种失败模式，并且可以尝试修复问题并在算例失败时重新启动计算，直到成功完成。这种基本工作链的逻辑非常通用，可以应用于任何计算，甚至任何流程:"

#: ../../source/howto/workchains_restart.rst:54
msgid ""
"Schematic flow diagram of the logic of a *base* work chain, whose job it is "
"to run a subprocess repeatedly, fixing any potential errors, until it "
"finishes successfully."
msgstr "*base* 工作链的逻辑流程图，其工作是重复运行子进程，修复任何潜在的错误，直到成功完成。"

#: ../../source/howto/workchains_restart.rst:56
msgid ""
"The work chain runs the subprocess. Once it has finished, it then inspects "
"the status. If the subprocess finished successfully, the work chain returns "
"the results and its job is done. If, instead, the subprocess failed, the "
"work chain should inspect the cause of failure, and attempt to fix the "
"problem and restart the subprocess. This cycle is repeated until the "
"subprocess finishes successfully. Of course this runs the risk of entering "
"into an infinite loop if the work chain never manages to fix the problem, so"
" we want to build in a limit to the maximum number of calculations that can "
"be re-run:"
msgstr ""
"工作链运行子例程。一旦完成，它就会检查状态。如果子流程成功完成，则工作链返回结果，其工作也就完成了。相反，如果子流程失败了，工作链应该检查失败的原因，并尝试修复问题并重新启动子流程。重复此循环，直到子流程成功完成。当然，如果工作链永远无法解决问题，这就有进入无限循环的风险，所以我们想要构建一个可以重新运行的最大计算数量的限制:"

#: ../../source/howto/workchains_restart.rst:68
msgid ""
"An improved flow diagram for the base work chain that limits the maximum "
"number of iterations that the work chain can try and get the calculation to "
"finish successfully."
msgstr "改进后基本工作链的流程图，该流程图限制了工作链可以尝试的最大迭代次数并使计算最后完成。"

#: ../../source/howto/workchains_restart.rst:70
msgid ""
"Since this is such a common logical flow for a base work chain that is to "
"wrap another :py:class:`~aiida.engine.processes.process.Process` and restart"
" it until it is finished successfully, we have implemented it as an abstract"
" base class in ``aiida-core``. The "
":py:class:`~aiida.engine.processes.workchains.restart.BaseRestartWorkChain` "
"implements the logic of the flow diagram shown above. Although the "
"``BaseRestartWorkChain`` is a subclass of "
":py:class:`~aiida.engine.processes.workchains.workchain.WorkChain` itself, "
"you cannot launch it. The reason is that it is completely general and so "
"does not know which :py:class:`~aiida.engine.processes.process.Process` "
"class it should run. Instead, to make use of the base restart work chain, "
"you should subclass it for the process class that you want to wrap."
msgstr ""
"因为这是一个基本工作链的常见逻辑流，该工作链将封装另一个 "
":py:class:`~aiida.engine.processes.process.Process`  并重启它，直到它成功完成，我们在 "
"``aiida-core`` "
"中将它作为一个抽象基类实现。:py:class:`~aiida.engine.processes.workchains.restart.BaseRestartWorkChain`"
" 实现了上面所示的流程图的逻辑。虽然 ``BaseRestartWorkChain`` 是 "
":py:class:`~aiida.engine.processes.workchains.workchain.WorkChain` "
"的子类，但你不能启动它。原因是它被设计为是通用的类，所以并不知道应该运行哪个 "
":py:class:`~aiida.engine.processes.process.Process` "
"进程类。相反，要使用基restart工作链，您应该为想要包装的流程类创建它的子类。"

#: ../../source/howto/workchains_restart.rst:78
msgid "Writing a base restart work chain"
msgstr "编写基础重启工作链"

#: ../../source/howto/workchains_restart.rst:80
msgid ""
"In this how-to, we will show how to implement the ``BaseRestartWorkChain`` "
"for the "
":py:class:`~aiida.calculations.arithmetic.add.ArithmeticAddCalculation`. We "
"start by importing the relevant base classes and create a subclass:"
msgstr ""
"在这个how-to中，我们将展示如何为 "
":py:class:`~aiida.calculations.arithmetic.add.ArithmeticAddCalculation` 实现  "
"``BaseRestartWorkChain`` 。我们首先导入相关的基类并创建一个子类:"

#: ../../source/howto/workchains_restart.rst:95
msgid ""
"As you can see, all we had to do is create a subclass of the "
"``BaseRestartWorkChain`` class, which we called "
"``ArithmeticAddBaseWorkChain``, and set the ``_process_class`` class "
"attribute to ``ArithmeticAddCalculation``. The latter instructs the work "
"chain what type of process it should launch. Next, as with all work chains, "
"we should *define* its process specification:"
msgstr ""
"正如你所看到的，我们所要做的就是创建一个 ``BaseRestartWorkChain`` 类的子类，我们将其命名为 "
"``ArithmeticAddBaseWorkChain`` ，并将 ``_process_class`` 类属性设置为 "
"``ArithmeticAddCalculation`` 。后者指示工作链应该启动哪种类型的过程。接下来，和所有的工作链一样，我们应该 "
"*define*它的列程规范:"

#: ../../source/howto/workchains_restart.rst:121
msgid ""
"The inputs and output that we define are essentially determined by the sub "
"process that the work chain will be running. Since the "
"``ArithmeticAddCalculation`` requires the inputs ``x`` and ``y``, and "
"produces the ``sum`` as output, we `mirror` those in the specification of "
"the work chain, otherwise we wouldn't be able to pass the necessary inputs. "
"Finally, we define the logical outline, which if you look closely, resembles"
" the logical flow chart presented in :numref:`workflow-error-handling-flow-"
"loop` a lot. We start by *setting up* the work chain and then enter a loop: "
"*while* the subprocess has not yet finished successfully *and* we haven't "
"exceeded the maximum number of iterations, we *run* another instance of the "
"process and then *inspect* the results. The while conditions are implemented"
" in the ``should_run_process`` outline step. When the process finishes "
"successfully or we have to abandon, we report the *results*. Now unlike with"
" normal work chain implementations, we *do not* have to implement these "
"outline steps ourselves. They have already been implemented by the "
"``BaseRestartWorkChain`` so that we don't have to. This is why the base "
"restart work chain is so useful, as it saves us from writing and repeating a"
" lot of `boilerplate code "
"<https://en.wikipedia.org/wiki/Boilerplate_code>`__."
msgstr ""
"我们定义的输入和输出本质上由工作链将运行的子例程决定。由于 ``ArithmeticAddCalculation`` 需要输入 ``x`` 和 "
"``y`` ，并生成 ``sum`` 作为输出，我们将这些输入输出 ``mirror`` "
"到工作链的规范中，否则我们将无法传递必要的输入。最后，我们定义了逻辑大纲，如果你仔细观察，就会发现它非常接近 :numref:`workflow-"
"error-handling-flow-loop`  中的逻辑流程图。我们首先 *设置* "
"工作链，然后进入一个循环:*当*子进程尚未成功完成*和*我们还没有超过最大迭代次数时，我们*运行*进程的另一个实例，然后 *检查* "
"结果。while条件在 ``should_run_process`` 大纲步骤中实现。当过程成功完成或我们不得不放弃时，我们报告 *结果* "
"。现在，与普通的工作链实现不同，我们 *不必* 自己实现这些大纲步骤。它们已经被 ``BaseRestartWorkChain`` "
"实现了，所以我们不需要。这就是为什么基础可重启工作链是如此有用，因为它节省了我们编写和重复大量的 `boilerplate code "
"<https://en.wikipedia.org/wiki/Boilerplate_code>`__ 。"

#: ../../source/howto/workchains_restart.rst:133
msgid ""
"This minimal outline definition is required for the work chain to work "
"properly. If you change the logic, the names of the steps or omit some "
"steps, the work chain will not run. Adding extra outline steps to add custom"
" functionality, however, is fine and actually encouraged if it makes sense."
msgstr ""
"我们定义的输入和输出本质上是确定的。这个最小的概要定义是工作链正常工作所必需的。如果您更改了逻辑、步骤的名称或省略了某些步骤，工作链将不会运行。然而，添加额外的大纲步骤来添加自定义功能是很好的，如果有意义的话，实际上是值得鼓励的。"

#: ../../source/howto/workchains_restart.rst:137
msgid ""
"The last part of the puzzle is to define in the setup what inputs the work "
"chain should pass to the subprocess. You might wonder why this is necessary,"
" because we already define the inputs in the specification, but those are "
"not the only inputs that will be passed. The ``BaseRestartWorkChain`` also "
"defines some inputs of its own, such as ``max_iterations`` as you can see in"
" its "
":py:meth:`~aiida.engine.processes.workchains.restart.BaseRestartWorkChain.define`"
" method. To make it absolutely clear what inputs are intended for the "
"subprocess, we define them as a dictionary in the context under the key "
"``inputs``. One way of doing this is to reuse the "
":py:meth:`~aiida.engine.processes.workchains.restart.BaseRestartWorkChain.setup`"
" method:"
msgstr ""
"难题的最后一部分是在设置中定义工作链应该传递给子流程的输入。您可能想知道为什么有必要这样做，因为我们已经在规范中定义了输入，但这些不是将要传递的唯一输入。"
" ``BaseRestartWorkChain`` 也定义了自己的一些输入，例如 ``max_iterations`` ，正如你可以在它的 "
":py:meth:`~aiida.engine.processes.workchains.restart.BaseRestartWorkChain.define`"
" 方法中看到的。为了使子流程的输入更加清晰，我们将它们定义为键  ``inputs`` 的上下文的字典。一种方法是重用 "
":py:meth:`~aiida.engine.processes.workchains.restart.BaseRestartWorkChain.setup`"
" :"

#: ../../source/howto/workchains_restart.rst:154
msgid ""
"Note that, as explained before, the ``setup`` step forms a crucial part of "
"the logical outline of any base restart work chain. Omitting it from the "
"outline will break the work chain, but so will overriding it completely, "
"except as long as we call the ``super``."
msgstr ""
"请注意，如前所述， ``setup`` 步骤构成了任何基础重启工作链逻辑大纲的关键部分。从大纲中删除它将破坏工作链，并完全覆盖它，除非我们调用 "
"``super`` 。"

#: ../../source/howto/workchains_restart.rst:157
msgid ""
"This is all the code we have to write to have a functional work chain. We "
"can now launch it like any other work chain and the ``BaseRestartWorkChain``"
" will work its magic:"
msgstr ""
"这是我们必须编写的所有代码，以拥有一个有效的工作链。我们现在可以像其他任何工作链一样启动它， ``BaseRestartWorkChain`` "
"将发挥它的魔力:"

#: ../../source/howto/workchains_restart.rst:164
msgid ""
"Once the work chain finished, we can inspect what has happened with, for "
"example, ``verdi process status``:"
msgstr "一旦工作链完成，我们可以检查发生了什么，例如， ``verdi process status`` :"

#: ../../source/howto/workchains_restart.rst:172
msgid ""
"As you can see the work chain launched a single instance of the "
"``ArithmeticAddCalculation`` which finished successfully, so the job of the "
"work chain was done as well."
msgstr ""
"正如你所看到的，工作链启动了一个 ``ArithmeticAddCalculation``  的单一实例，它成功地完成了，所以工作链的工作也完成了。"

#: ../../source/howto/workchains_restart.rst:176
msgid ""
"If the work chain excepted, make sure the directory containing the WorkChain"
" definition is in the ``PYTHONPATH``."
msgstr "如果工作链异常，请确保包含工作链定义的目录在 ``PYTHONPATH`` 中。"

#: ../../source/howto/workchains_restart.rst:178
msgid ""
"You can add the folder in which you have your Python file defining the "
"WorkChain to the ``PYTHONPATH`` through:"
msgstr "你可以通过以下方法将定义工作链的Python文件的文件夹添加到 ``PYTHONPATH`` 中:"

#: ../../source/howto/workchains_restart.rst:184
msgid "After this, it is **very important** to restart the daemon:"
msgstr "在这之后，重启守护进程是非常重要的:"

#: ../../source/howto/workchains_restart.rst:190
msgid ""
"Indeed, when updating an existing work chain file or adding a new one, it is"
" **necessary** to restart the daemon **every time** after all changes have "
"taken place."
msgstr "实际上，当更新现有的工作链文件或添加新的工作链文件时，在所有更改发生后， **有必要每次** 都重启守护进程。"

#: ../../source/howto/workchains_restart.rst:193
#: ../../source/howto/write_workflows.rst:180
msgid "Exposing inputs and outputs"
msgstr "暴露输入和输出"

#: ../../source/howto/workchains_restart.rst:195
msgid ""
"Any base restart work chain *needs* to *expose* the inputs of the subprocess"
" it wraps, and most likely *wants* to do the same for the outputs it "
"produces, although the latter is not necessary. For the simple example "
"presented in the previous section, simply copy-pasting the input and output "
"port definitions of the subprocess ``ArithmeticAddCalculation`` was not too "
"troublesome. However, this quickly becomes tedious, and more importantly, "
"error-prone once you start to wrap processes with quite a few more inputs. "
"To prevent the copy-pasting of input and output specifications, the "
":class:`~aiida.engine.processes.process_spec.ProcessSpec` class provides the"
" :meth:`~plumpy.ProcessSpec.expose_inputs` and "
":meth:`~plumpy.ProcessSpec.expose_outputs` methods:"
msgstr ""
"任何基础可重启工作链*都需要*暴露*它包装的子例程的输入，并且很可能 *希望* "
"对它产生的输出做同样的事情，尽管后者不是必需的。对于前一节中给出的简单示例，简单地复制粘贴子进程 "
"``ArithmeticAddCalculation``  "
"的输入和输出端口定义并不太麻烦。但是，一旦您开始使用较多的输入来包装流程，这很快就会变得冗余，而且是容易出错。为了防止输入和输出规范的复制-粘贴， "
":class:`~aiida.engine.processes.process_spec.ProcessSpec` 类提供了 "
":meth:`~plumpy.ProcessSpec.expose_inputs` 和 "
":meth:`~plumpy.ProcessSpec.expose_outputs` 方法:"

#: ../../source/howto/workchains_restart.rst:212
msgid ""
"For more detail on exposing inputs and outputs, see the basic "
":ref:`Workchain usage section "
"<topics:workflows:usage:workchains:expose_inputs_outputs>`."
msgstr ""
"有关暴露输入和输出的更多细节，请参阅 :ref:`工作链的使用 "
"<topics:workflows:usage:workchains:expose_inputs_outputs>`。"

#: ../../source/howto/workchains_restart.rst:214
msgid ""
"That takes care of exposing the port specification of the wrapped process "
"class in a very efficient way. To efficiently retrieve the inputs that have "
"been passed to the process, one can use the "
":meth:`~aiida.engine.processes.process.Process.exposed_inputs` method. Note "
"the past tense of the method name. The method takes a process class and an "
"optional namespace as arguments, and will return the inputs that have been "
"passed into that namespace when it was launched. This utility now allows us "
"to simplify the ``setup`` outline step that we have shown before:"
msgstr ""
"这将以一种非常有效的方式暴露包装的例程类的端口规范。为了有效地检索传递给流程的输入，可以使用 "
":meth:`~aiida.engine.processes.process.Process.exposed_inputs` "
"方法。注意方法名的过去时态。该方法以一个流程类和一个可选的名称空间作为参数，并将返回在启动该名称空间时传递给该名称空间的输入。这个实用程序现在允许我们简化我们之前展示过的"
" ``setup`` 大纲步骤:"

#: ../../source/howto/workchains_restart.rst:231
msgid ""
"This way we don't have to manually fish out all the individual inputs from "
"the ``self.inputs`` but have to just call this single method, saving a lot "
"of time and lines of code."
msgstr "这样我们就不必手动从 ``self.inputs`` 中找出所有的输入。仅须调用这个单一的方法，节省了大量的时间和代码行。"

#: ../../source/howto/workchains_restart.rst:233
msgid ""
"When submitting or running the work chain using namespaced inputs (``add`` "
"in the example above), it is important to use the namespace:"
msgstr "当使用命名空间输入(上面例子中的 ``add`` )提交或运行工作链时，使用命名空间很重要:"

#: ../../source/howto/workchains_restart.rst:248
msgid ""
"Every time you make changes to the ``ArithmeticAddBaseWorkChain``, don't "
"forget to restart the daemon with:"
msgstr "每次你对  ``ArithmeticAddBaseWorkChain`` 进行更改时，不要忘记用以下命令重启守护进程:"

#: ../../source/howto/workchains_restart.rst:256
msgid "Customizing outputs"
msgstr ""

#: ../../source/howto/workchains_restart.rst:258
msgid ""
"By default, the ``BaseRestartWorkChain`` will attach the exposed outputs of "
"the last completed calculation job. In most cases this is the correct "
"behavior, but there might be use-cases where one wants to modify exactly "
"what outputs are attached to the work chain. This can be achieved by "
"overriding the "
":meth:`aiida.engine.processes.workchains.restart.BaseRestartWorkChain.get_outputs`"
" method. For example, if you want to remove a particular output from being "
"attached, you can do the following:"
msgstr ""

#: ../../source/howto/workchains_restart.rst:271
msgid ""
"It is also possible to update the contents of one of the outputs returned by"
" the last completed calculation job. In this case, it is important to go "
"through a ``calcfunction``, as always, as to not lose any provenance."
msgstr ""

#: ../../source/howto/workchains_restart.rst:276
msgid "Error handling"
msgstr "错误处理"

#: ../../source/howto/workchains_restart.rst:278
msgid ""
"So far you have seen how easy it is to get a work chain up and running that "
"will run a subprocess using the ``BaseRestartWorkChain``. However, the whole"
" point of this exercise, as described in the introduction, was for the work "
"chain to be able to deal with *failing* processes, yet in the previous "
"example it finished without any problems."
msgstr ""
"到目前为止，你已经看到我们很容易可以创建一个工作链，并使用 ``BaseRestartWorkChain`` "
"运行所包含一个子例程。然而，正如在介绍中所描述的，这个练习的全部要点是让工作链能够处理 *失败* 流程，而在前面的示例中，它完成时没有出错。"

#: ../../source/howto/workchains_restart.rst:281
msgid "What would have happened if the subprocess had failed?"
msgstr "如果子流程失败会发生什么?"

#: ../../source/howto/workchains_restart.rst:283
msgid ""
"If the computed sum of the inputs ``x`` and ``y`` is negative, the "
"``ArithmeticAddCalculation`` fails with exit code ``410`` which corresponds "
"to ``ERROR_NEGATIVE_NUMBER``."
msgstr ""
"如果计算的输入 ``x`` 和 ``y`` 的和是负数， ``ArithmeticAddCalculation`` 将失败，退出码 ``410`` "
"对应于 ``ERROR_NEGATIVE_NUMBER`` 。"

#: ../../source/howto/workchains_restart.rst:287
msgid ""
"The :ref:`exit code usage section<topics:processes:usage:exit_codes>`, for a"
" more detailed explanation of exit codes."
msgstr "参考 :ref:`退出码章节 <topics:processes:usage:exit_codes>` ，获取更详细的退出码解释。"

#: ../../source/howto/workchains_restart.rst:289
msgid ""
"Let's launch the work chain with inputs that will cause the calculation to "
"fail, e.g. by making one of the operands negative, and see what happens:"
msgstr "让我们用会导致算例失败的输入来启动工作链，例如让一个操作数为负，看看会发生什么:"

#: ../../source/howto/workchains_restart.rst:295
msgid ""
"This time we will see that the work chain takes quite a different path:"
msgstr "这一次，我们将看到工作链采取了完全不同的运行路径:"

#: ../../source/howto/workchains_restart.rst:304
msgid ""
"As expected, the ``ArithmeticAddCalculation`` failed this time with a "
"``410``. The work chain noticed the failure when inspecting the result of "
"the subprocess in ``inspect_process``, and in keeping with its name and "
"design, restarted the calculation. However, since the inputs were not "
"changed, the calculation inevitably and wholly expectedly failed once more "
"with the exact same error code. Unlike after the first iteration, however, "
"the work chain did not restart again, but gave up and returned the exit code"
" ``402`` itself, which stands for "
"``ERROR_SECOND_CONSECUTIVE_UNHANDLED_FAILURE``. As the name suggests, the "
"work chain tried to run the subprocess but it failed twice in a row without "
"the problem being *handled*. The obvious question now of course is: \"How "
"exactly can we instruct the base work chain to handle certain problems?\""
msgstr ""
"如预期的，   ``ArithmeticAddCalculation`` 这次以 ``410`` 失败了。工作链在检查 "
"``inspect_process`` "
"中的子进程的结果时检测到失败，并根据其名称设计和重新启动计算。然而，由于输入没有改变，计算不可避免地再次失败，并给出完全相同的错误代码。然而，与第一次迭代后不同的是，工作链没有重新启动，而是放弃并返回退出码"
" ``402`` ，它代表 ``ERROR_SECOND_CONSECUTIVE_UNHANDLED_FAILURE`` "
"。顾名思义，工作链试图运行子流程，但连续失败了两次，问题没有得到 *处理* 。现在显而易见的问题当然是:“我们究竟如何指导基层工作链去处理某些问题?”"

#: ../../source/howto/workchains_restart.rst:311
msgid ""
"Since the problems are necessarily dependent on the subprocess that the work"
" chain will run, it cannot be implemented by the ``BaseRestartWorkChain`` "
"class itself, but rather will have to be implemented by the subclass. If the"
" subprocess fails, the ``BaseRestartWorkChain`` calls a set of *process "
"handlers* in the ``inspect_process`` step. Each process handler gets passed "
"the node of the subprocess that was just run, such that it can inspect the "
"results and potentially fix any problems that it finds. To \"register\" a "
"process handler for a base restart work chain implementation, you simply "
"define a method that takes a node as its single argument and decorate it "
"with the :func:`~aiida.engine.processes.workchains.utils.process_handler` "
"decorator:"
msgstr ""
"由于问题必然依赖于工作链将运行的子流程，因此它不能由 ``BaseRestartWorkChain`` 类本身实现，而是必须由子类实现。如果子进程失败，"
" ``BaseRestartWorkChain`` 在 ``inspect_process`` 步骤中调用一组 *例程处理备案* "
"。每个例程处理备案都会传递刚刚运行的子流程的节点，这样它就可以检查结果并可能修复它发现的任何问题。要为基础重启工作链实现“注册”一个例程处理备案，只需定义一个方法，该方法将一个节点作为其单个参数，并使用"
"  :func:`~aiida.engine.processes.workchains.utils.process_handler` 装饰器:"

#: ../../source/howto/workchains_restart.rst:341
msgid ""
"The method name can be anything as long as it is a valid Python method name "
"and does not overlap with one of the base work chain's methods. For better "
"readability, it is, however, recommended to have the method name start with "
"``handle_``. In this example, we want to specifically check for a particular"
" failure mode of the ``ArithmeticAddCalculation``, so we compare the "
":meth:`~aiida.orm.nodes.process.process.ProcessNode.exit_status` of the node"
" with that of the spec of the process. If the exit code matches, we know "
"that the problem was due to the sum being negative. Fixing this fictitious "
"problem for this example is as simple as making sure that the inputs are all"
" positive, which we can do by taking the absolute value of them. We assign "
"the new values to the ``self.ctx.inputs`` just as where we defined the "
"original inputs in the ``setup`` step. Finally, to indicate that we have "
"handled the problem, we return an instance of "
":class:`~aiida.engine.processes.workchains.utils.ProcessHandlerReport`. This"
" will instruct the work chain to restart the subprocess, taking the updated "
"inputs from the context. With this simple addition, we can now launch the "
"work chain again:"
msgstr ""
"方法名可以是任何名称，只要它是有效的Python方法名，且不与基本工作链的某个方法重叠。但为了更好的可读性，建议方法名以 ``handle_`` "
"开头。在这个例子中，我们想要特别检查  ``ArithmeticAddCalculation`` 的特定故障模式，所以我们比较 "
":meth:`~aiida.orm.nodes.process.process.ProcessNode.exit_status` "
"与例程的规格的节点。如果退出码匹配，我们就知道问题是由于和为负造成的。为这个例子修复这个虚构的问题很简单，只要确保输入都是正的，这可以通过取它们的绝对值来实现。我们将新值赋给"
" ``self.ctx.inputs`` 就像我们在 ``setup`` "
"步骤中定义的原始输入一样。最后，为了表明我们已经处理了这个问题，我们返回以下类的一个实例:这将指示工作链重新启动子例程，从上下文获取更新后的输入。通过这个简单的添加，我们现在可以再次启动工作链:"

#: ../../source/howto/workchains_restart.rst:358
msgid ""
"This time around, although the first subprocess fails again with a ``410``, "
"the new process handler is called. It \"fixes\" the inputs, and when the "
"work chain restarts the subprocess with the new inputs it finishes "
"successfully. With this simple process you can add as many process handlers "
"as you would like to deal with any potential problem that might occur for "
"the specific subprocess type of the work chain implementation. To make the "
"code even more readable, the "
":func:`~aiida.engine.processes.workchains.utils.process_handler` decorator "
"comes with various syntactic sugar. Instead of having a conditional at the "
"start of each handler to compare the exit status of the node to a particular"
" exit code of the subprocess, you can define it through the ``exit_codes`` "
"keyword argument of the decorator:"
msgstr ""
"这一次，尽管第一个子例程再次以 ``410`` "
"失败，但将调用新的进程处理程序。它“修复”了输入，当工作链使用新的输入重新启动子流程时，它将成功完成。通过这个简单的流程，您可以添加尽可能多的流程处理备案，以处理工作链实现的特定子例程类型可能出现的任何潜在问题。为了使代码更具可读性，可以使用"
" :func:`~aiida.engine.processes.workchains.utils.process_handler`  "
"的装饰器带有各种语法糖。你可以通过装饰器的 ``exit_codes`` "
"关键字参数来定义推出状态，而不是在每个处理程序的开头用一个条件来比较节点的退出状态和子进程的特定退出代码:"

#: ../../source/howto/workchains_restart.rst:373
msgid ""
"If the ``exit_codes`` keyword is defined, which can be either a single "
"instance of :class:`~aiida.engine.processes.exit_code.ExitCode` or a list "
"thereof, the process handler will only be called if the exit status of the "
"node corresponds to one of those exit codes, otherwise it will simply be "
"skipped."
msgstr ""
"如果定义了 ``exit_codes`` 关键字，它可以是单个 "
":class:`~aiida.engine.processes.exit_code.ExitCode` "
"实例或它的一个列表，只有当节点的退出状态对应于这些退出代码之一时，进程处理程序才会被调用，否则它将被简单地跳过。"

#: ../../source/howto/workchains_restart.rst:376
msgid "Multiple process handlers"
msgstr "多个进程处理备案"

#: ../../source/howto/workchains_restart.rst:378
msgid ""
"Since typically a base restart work chain implementation will have more than"
" one process handler, one might want to control the order in which they are "
"called. This can be done through the ``priority`` keyword:"
msgstr "由于基本重启工作链实现通常有多个进程处理程序，因此可能希望控制调用它们的顺序。这可以通过 ``priority`` 关键字来实现:"

#: ../../source/howto/workchains_restart.rst:390
msgid ""
"The process handlers with a higher priority will be called first. In this "
"scenario, in addition to controlling the order with which the handlers are "
"called, you may also want to stop the process handling once you have "
"determined the problem. This can be achieved by setting the ``do_break`` "
"argument of the ``ProcessHandler`` to ``True``:"
msgstr ""
"优先级更高的进程处理备案将首先被调用。在此场景中，除了控制调用处理程序的顺序外，您可能还希望在确定问题后停止例程处理。这可以通过将  "
"``ProcessHandler`` 的 ``do_break`` 参数设置为 ``True`` 来实现:"

#: ../../source/howto/workchains_restart.rst:403
msgid ""
"Finally, sometimes one detects a problem that simply cannot or should not be"
" corrected by the work chain. In this case, the handler can signal that the "
"work chain should abort by setting an "
":class:`~aiida.engine.processes.exit_code.ExitCode` instance on the "
"``exit_code`` argument of the ``ProcessHandler``:"
msgstr ""
"最后，有时会发现一个问题不能或不应该由工作链来纠正。在这种情况下，处理备案可以通过设置 "
":class:`~aiida.engine.processes.exit_code.ExitCode` 来通过 ``ProcessHandler`` "
"发出中止工作链的信号设置实例的 ``exit_code`` 参数:"

#: ../../source/howto/workchains_restart.rst:415
msgid ""
"The base restart work chain will detect this exit code and abort the work "
"chain, setting the corresponding status and message on the node as usual:"
msgstr "基本重启工作链将检测此退出码并中止工作链，像往常一样在节点上设置相应的状态和消息:"

#: ../../source/howto/workchains_restart.rst:423
msgid ""
"With these basic tools, a broad range of use-cases can be addressed while "
"preventing a lot of boilerplate code."
msgstr "这些基本工具，适用解决各种广泛用例，同时防止编写大量重复的样板代码。"

#: ../../source/howto/workchains_restart.rst:427
msgid "Handler overrides"
msgstr ""

#: ../../source/howto/workchains_restart.rst:429
msgid ""
"It is possible to change the priority of handlers and enable/disable them "
"without changing the source code of the work chain. These properties of the "
"handlers can be controlled through the ``handler_overrides`` input of the "
"work chain. This input takes a ``Dict`` node, that has the following form:"
msgstr ""

#: ../../source/howto/workchains_restart.rst:442
msgid ""
"As you can see, the keys are the name of the handler to affect and the value"
" is a dictionary that can take two keys: ``enabled`` and ``priority``. To "
"enable or disable a handler, set ``enabled`` to ``True`` or ``False``, "
"respectively. The ``priority`` key takes an integer and determines the "
"priority of the handler. Note that the values of the ``handler_overrides`` "
"are fully optional and will override the values configured by the process "
"handler decorator in the source code of the work chain. The changes also "
"only affect the work chain instance that receives the ``handler_overrides`` "
"input, all other instances of the work chain that will be launched will be "
"unaffected."
msgstr ""

#: ../../source/howto/write_workflows.rst:5
msgid "How to write and extend workflows"
msgstr "如何编写和扩展工作流"

#: ../../source/howto/write_workflows.rst:8
msgid "Writing workflows"
msgstr "编写工作流"

#: ../../source/howto/write_workflows.rst:10
msgid ""
"A workflow in AiiDA is a :ref:`process <topics:processes:concepts>` that "
"calls other workflows and calculations and optionally *returns* data and as "
"such can encode the logic of a typical scientific workflow. Currently, there"
" are two ways of implementing a workflow process:"
msgstr ""
"AiiDA中的工作流是一个 :ref:`例程 <topics:processes:concepts>` 它能够调用其他工作流和其他算例并可以 *返回* "
"数据，因此能够编码特定的科学工作流逻辑。当前，有两类工作流流程的实现："

#: ../../source/howto/write_workflows.rst:13
msgid ":ref:`work functions<topics:workflows:concepts:workfunctions>`"
msgstr ":ref:`工作函数（work functions）<topics:workflows:concepts:workfunctions>`"

#: ../../source/howto/write_workflows.rst:14
msgid ":ref:`work chains<topics:workflows:concepts:workchains>`"
msgstr ":ref:`工作链（work chains）<topics:workflows:concepts:workchains>`"

#: ../../source/howto/write_workflows.rst:16
msgid ""
"Here we present a brief introduction on how to write both workflow types."
msgstr "在这里，我们将简要介绍如何编写这两种工作流类型。"

#: ../../source/howto/write_workflows.rst:20
msgid ""
"For more details on the concept of a workflow, and the difference between a "
"work function and a work chain, please see the corresponding :ref:`topics "
"section<topics:workflows:concepts>`."
msgstr ""
"有关工作流概念的更多细节，以及工作函数和工作链之间的区别，请参阅相应的 :ref:`主题部分 <topics:workflows:concepts>` "
"。"

#: ../../source/howto/write_workflows.rst:24
msgid ""
"Developing workflows may involve running several lengthy calculations. "
"Consider :ref:`enabling caching <how-to:run-codes:caching>` to help avoid "
"repeating long workflow steps."
msgstr ""
"开发工作流可能涉及运行冗长的计算。考虑 :ref:`启用缓存 <how-to:run-codes:caching>` ，以帮助避免重复冗长的工作流步骤。"

#: ../../source/howto/write_workflows.rst:27
msgid "Work function"
msgstr "工作函数"

#: ../../source/howto/write_workflows.rst:29
msgid ""
"A *work function* is a process function that calls one or more calculation "
"functions and *returns* data that has been *created* by the calculation "
"functions it has called. Moreover, work functions can also call other work "
"functions, allowing you to write nested workflows. Writing a work function, "
"whose provenance is automatically stored, is as simple as writing a Python "
"function and decorating it with the "
":class:`~aiida.engine.processes.functions.workfunction` decorator:"
msgstr ""
"*工作函数* 是一个例程函数，它调用一个或多个计算函数，并 *返回* "
"由它调用的计算函数创建的数据。此外，工作函数还可以调用其他工作函数，从而允许您编写嵌套的工作流。编写一个可验证性被自动存储的工作函数，就像编写一个Python函数一样简单，仅需额外使用"
" :class:`~aiida.engine.processes.functions.workfunction`  来装饰它。"

#: ../../source/howto/write_workflows.rst:37
msgid ""
"It is important to reiterate here that the "
":class:`~aiida.engine.processes.functions.workfunction`-decorated "
"``add_multiply()`` function does not *create* any new data nodes. The "
"``add()`` and ``multiply()`` calculation functions create the ``Int`` data "
"nodes, all the work function does is *return* the results of the "
"``multiply()`` calculation function. Moreover, both calculation and workflow"
" functions can only accept and return data nodes, i.e. instances of classes "
"that subclass the :class:`~aiida.orm.nodes.data.data.Data` class."
msgstr ""
"重要的是要在这里重申  :class:`~aiida.engine.processes.functions.workfunction` 装饰 "
"``add_multiply()`` 不会 *创建* 任何新的数据节点。 ``add()`` 和 ``multiply()`` 两个计算函数创建 "
"``Int`` 数据节点，所有的工作函数做的是*返回* ``multiply()`` "
"计算函数的结果。而且，计算函数和工作流函数都只能接受和返回数据节点，即继承 "
":class:`~aiida.orm.nodes.data.data.Data`  类的实例。"

#: ../../source/howto/write_workflows.rst:42
msgid "Work chain"
msgstr "工作链"

#: ../../source/howto/write_workflows.rst:44
msgid ""
"When the workflow you want to run is more complex and takes longer to "
"finish, it is better to write a *work chain*. Writing a work chain in AiiDA "
"requires creating a class that inherits from the "
":class:`~aiida.engine.processes.workchains.workchain.WorkChain` class. Below"
" is an example of a work chain that takes three integers as inputs, "
"multiplies the first two and then adds the third to obtain the final result:"
msgstr ""
"当您想要运行的工作流更复杂，需要更长的时间来完成时，最好编写一个 *工作链* 。在AiiDA中编写工作链需要创建一个继承自 "
":class:`~aiida.engine.processes.workchains.workchain.WorkChain`  "
"的类。下面是一个工作链的例子，它以三个整数作为输入，乘以前两个，然后加上第三个，得到最终结果:"

#: ../../source/howto/write_workflows.rst:52
msgid ""
"You can give the work chain any valid Python class name, but the convention "
"is to have it end in "
":class:`~aiida.engine.processes.workchains.workchain.WorkChain` so that it "
"is always immediately clear what it references. Let's go over the methods of"
" the ``MultiplyAddWorkChain`` one by one:"
msgstr ""
"你可以为工作链指定任何有效的Python类名，但约定是让它以 "
":class:`~aiida.engine.processes.workchains.workchain.WorkChain` "
"结尾，这样用户总是能清楚知道它引用的是什么。让我们逐一检查 ``MultiplyAddWorkChain`` 的方法:"

#: ../../source/howto/write_workflows.rst:60
msgid ""
"The most important method to implement for every work chain is the "
"``define()`` method. This class method must always start by calling the "
"``define()`` method of its parent class. Next, the ``define()`` method "
"should be used to define the specifications of the work chain, which are "
"contained in the work chain ``spec``:"
msgstr ""
"每个工作链要实现的最重要的方法是 ``define()`` 方法。这个类方法必须总是从调用其父类的 ``define()`` 方法开始。接下来， "
"``define()`` 方法应该用来定义工作链的规范，它包含在工作链 ``spec`` 中:"

#: ../../source/howto/write_workflows.rst:64
msgid ""
"the **inputs**, specified using the ``spec.input()`` method. The first "
"argument of the ``input()`` method is a string that specifies the label of "
"the input, e.g. ``'x'``. The ``valid_type`` keyword argument allows you to "
"specify the required node type of the input. Other keyword arguments allow "
"the developer to set a default for the input, or indicate that an input "
"should not be stored in the database, see :ref:`the process topics section "
"<topics:processes:usage:spec>` for more details."
msgstr ""
"**输入** ，使用 ``spec.input()`` 方法指定。 ``input()`` 方法的第一个参数是一个指定输入标签的字符串如： ``x`` "
"。关键字参数 ``valid_type`` "
"允许您指定所需的输入节点类型。其他关键字参数允许开发人员为输入设置默认值，或者指示输入不应该存储在数据库中，参见 :ref:`列程主题章节 "
"<topics:processes:usage:spec>` 了解更多细节。"

#: ../../source/howto/write_workflows.rst:68
msgid ""
"the **outline** or logic of the workflow, specified using the "
"``spec.outline()`` method. The outline of the workflow is constructed from "
"the methods of the "
":class:`~aiida.engine.processes.workchains.workchain.WorkChain` class. For "
"the ``MultiplyAddWorkChain``, the outline is a simple linear sequence of "
"steps, but it's possible to include actual logic, directly in the outline, "
"in order to define more complex workflows as well. See the :ref:`work chain "
"outline section <topics:workflows:usage:workchains:define_outline>` for more"
" details."
msgstr ""
"工作流的 **大纲** 或逻辑，使用 ``spec.outline()`` 方法指定。工作流的轮廓是由类 "
":class:`~aiida.engine.processes.workchains.workchain.WorkChain` 的方法构造的。对于 "
"``MultiplyAddWorkChain`` ，大纲是一个简单的线性序列的步骤，但它可以包括实际的逻辑，直接在大纲中定义更复杂的工作流。请参阅 "
":ref:`工作链大纲章节 <topics:workflows:usage:workchains:define_outline>` 以获得更多细节。"

#: ../../source/howto/write_workflows.rst:72
msgid ""
"the **outputs**, specified using the ``spec.output()`` method. This method "
"is very similar in its usage to the ``input()`` method."
msgstr "**输出** ，使用 ``spec.output()`` 方法指定。这个方法的用法与 ``input()`` 方法非常相似。"

#: ../../source/howto/write_workflows.rst:74
msgid ""
"the **exit codes** of the work chain, specified using the "
"``spec.exit_code()`` method. Exit codes are used to clearly communicate "
"known failure modes of the work chain to the user. The first and second "
"arguments define the ``exit_status`` of the work chain in case of failure "
"(``400``) and the string that the developer can use to reference the exit "
"code (``ERROR_NEGATIVE_NUMBER``). A descriptive exit message can be provided"
" using the ``message`` keyword argument. For the ``MultiplyAddWorkChain``, "
"we demand that the final result is not a negative number, which is checked "
"in the ``validate_result`` step of the outline."
msgstr ""
"工作链的 **退出码** ，由 ``spec.exit_code()`` "
"方法指定。退出码用于向用户清楚地传达工作链的已知故障模式。第一个和第二个参数定义了工作链在失败时的 ``exit_status`` ( ``400`` "
")和开发者可以用来引用退出码的字符串( ``ERROR_NEGATIVE_NUMBER`` )。一个描述性的退出消息可以使用 ``message`` "
"关键字参数提供。对于 ``MultiplyAddWorkChain`` ，我们要求最终结果不是负数，它在大纲的 ``validate_result`` "
"步骤中检查。"

#: ../../source/howto/write_workflows.rst:82
msgid ""
"For more information on the ``define()`` method and the process spec, see "
"the :ref:`corresponding section in the topics "
"<topics:processes:usage:defining>`."
msgstr ""
"有关 ``define()`` 方法和进程规范的更多信息，请参见主题中的 :ref:`对应部分 "
"<topics:processes:usage:defining>`。"

#: ../../source/howto/write_workflows.rst:84
msgid ""
"The ``multiply`` method is the first step in the outline of the "
"``MultiplyAddWorkChain`` work chain."
msgstr "``multiply`` 方法是 ``MultiplyAddWorkChain`` 工作链大纲中的第一步。"

#: ../../source/howto/write_workflows.rst:92
msgid ""
"This step simply involves running the calculation function ``multiply()``, "
"on the ``x`` and ``y`` **inputs** of the work chain. To store the result of "
"this function and use it in the next step of the outline, it is added to the"
" *context* of the work chain using ``self.ctx``."
msgstr ""
"这个步骤只涉及对工作链的输入 ``x`` 和 ``y`` 运行计算函数 ``multiply()`` "
"。为了存储该函数的结果并在大纲的下一步中使用它，可以使用 ``self.ctx`` 将其添加到工作链的 *context* 中。"

#: ../../source/howto/write_workflows.rst:101
msgid ""
"The ``add()`` method is the second step in the outline of the work chain. As"
" this step uses the ``ArithmeticAddCalculation`` calculation job, we start "
"by setting up the inputs for this "
":class:`~aiida.engine.processes.calcjobs.calcjob.CalcJob` in a dictionary. "
"Next, when submitting this calculation job to the daemon, it is important to"
" use the submit method from the work chain instance via ``self.submit()``. "
"Since the result of the addition is only available once the calculation job "
"is finished, the ``submit()`` method returns the "
":class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode` of the "
"*future* ``ArithmeticAddCalculation`` process. To tell the work chain to "
"wait for this process to finish before continuing the workflow, we return "
"the ``ToContext`` class, where we have passed a dictionary to specify that "
"the future calculation job node should be assigned to the ``'addition'`` "
"context key."
msgstr ""
"``add()`` 方法是工作链大纲中的第二步。由于这个步骤使用了 ``ArithmeticAddCalculation`` "
"的计算作业，我们首先在字典中为 :class:`~aiida.engine.processes.calcjobs.calcjob.CalcJob`  "
"设置输入。接下来，当向守护进程提交这个计算作业时，必须通过 ``self.submit()`` "
"来作为工作链实例的提交方法。因为添加的结果只有在计算任务完成后才可用，所以 ``submit()`` 方法返回 *未来完成的* "
"``ArithmeticAddCalculation`` 例程的 "
":class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode`  "
"节点。为了告诉工作链在继续工作流之前等待该进程完成，我们返回 ``ToContext`` 类，其中我们传递了一个字典来指定未来的计算作业节点应该分配给"
"  ``'addition'`` 上下文键。"

#: ../../source/howto/write_workflows.rst:109
msgid ""
"Never use the global ``submit()`` function to submit calculations to the "
"daemon within a "
":class:`~aiida.engine.processes.workchains.workchain.WorkChain`. Doing so "
"will raise an exception during runtime. See the :ref:`topics section on work"
" chains<topics:workflows:usage:workchains:submitting_sub_processes>` for "
"more details."
msgstr ""
"永远不要在 :class:`~aiida.engine.processes.workchains.workchain.WorkChain` 中使用全局的"
" `submit()` 函数向守护进程提交计算。这样做将在运行时引发异常。请参阅 :ref:`工作链的主题部分 "
"<topics:workflows:usage:workchains:submitting_sub_processes>`以获得更多细节。"

#: ../../source/howto/write_workflows.rst:114
msgid ""
"Instead of passing a dictionary, you can also initialize a ``ToContext`` "
"instance by passing the future process as a keyword argument, e.g. "
"``ToContext(addition=calcjob_node)``. More information on the ``ToContext`` "
"class can be found in :ref:`the topics section on submitting sub "
"processes<topics:workflows:usage:workchains:submitting_sub_processes>`."
msgstr ""
"除了传递一个字典，你也可以通过传递未来完成的例程实例作为关键字参数来初始化一个 ``ToContext`` 实例，例如。 "
"``ToContext(addition=calcjob_node)`` 。更多关于 ``ToContext`` 类的信息可以在 "
":ref:`提交子进程的主题部分 "
"<topics:workflows:usage:workchains:submitting_sub_processes>` 中找到。"

#: ../../source/howto/write_workflows.rst:123
msgid ""
"Once the ``ArithmeticAddCalculation`` calculation job is finished, the next "
"step in the work chain is to validate the result, i.e. verify that the "
"result is not a negative number. After the ``addition`` node has been "
"extracted from the context, we take the ``sum`` node from the "
"``ArithmeticAddCalculation`` outputs and store it in the ``result`` "
"variable. In case the value of this ``Int`` node is negative, the "
"``ERROR_NEGATIVE_NUMBER`` exit code - defined in the ``define()`` method - "
"is returned. Note that once an exit code is returned during any step in the "
"outline, the work chain will be terminated and no further steps will be "
"executed."
msgstr ""
"一旦  ``ArithmeticAddCalculation`` 算例任务完成，工作链中的下一步就是验证结果，即验证结果不是负数。从context中提取"
" ``addition`` 节点后，我们从  ``ArithmeticAddCalculation`` 的输出中提取 ``sum`` 节点，并将其存储在"
" ``result`` 变量中。如果这个 ``Int`` 节点的值是负数，则返回定义在 ``define()`` 方法中的 "
"``ERROR_NEGATIVE_NUMBER`` 退出码。请注意，一旦在大纲中的任何步骤中返回了退出代码，工作链将被终止，不再执行任何步骤。"

#: ../../source/howto/write_workflows.rst:134
msgid ""
"The final step in the outline is to pass the result to the outputs of the "
"work chain using the ``self.out()`` method. The first argument "
"(``'result'``) specifies the label of the output, which corresponds to the "
"label provided to the spec in the ``define()`` method. The second argument "
"is the result of the work chain, extracted from the ``Int`` node stored in "
"the context under the ``'addition'`` key."
msgstr ""
"大纲中的最后一步是使用 ``self.out()`` 方法将结果传递给工作链的输出。第一个参数( ``result`` )指定输出的标签，对应于 "
"``define()`` 方法中提供给规范的标签。第二个参数是工作链的结果，它是从存储在上下文中 ``addition`` 键下的 ``Int`` "
"节点中提取的。"

#: ../../source/howto/write_workflows.rst:138
msgid ""
"For a more complete discussion on workflows and their usage, please read "
":ref:`the corresponding topics section<topics:workflows:usage>`."
msgstr "有关工作流及其用法的更完整讨论，请阅读 :ref:`相应的主题部分 <topics:workflows:usage>` 。"

#: ../../source/howto/write_workflows.rst:143
msgid "Extending workflows"
msgstr "扩展工作流"

#: ../../source/howto/write_workflows.rst:145
msgid ""
"When designing workflows, there are many cases where you want to reuse an "
"existing process. This section explains how to extend workflows by wrapping "
"them around other processes or linking them together."
msgstr "在设计工作流时，有许多情况需要重用现有的流程。本节解释如何通过将工作流包装到其他流程或将它们链接到一起来扩展工作流。"

#: ../../source/howto/write_workflows.rst:148
msgid ""
"As an example, let's say you want to extend the ``MultiplyAddWorkChain`` by "
"adding another step of analysis that checks whether the result is an even "
"number or not. This final step can be written as a simple ``calcfunction``:"
msgstr ""
"作为一个例子，我们假设你想通过添加另一个检查结果是否为偶数的分析步骤来扩展 ``MultiplyAddWorkChain`` "
"。最后一步可以写成一个简单的 ``calcfunction`` :"

#: ../../source/howto/write_workflows.rst:155
msgid ""
"We could simply write a new workflow based off ``MultiplyAddWorkChain`` that"
" includes an extra step in the outline which runs the ``is_even`` "
"calculation function. However, this would lead to a lot of code duplication,"
" and longer workflows consisting of multiple work chains would become very "
"cumbersome to deal with (see the dropdown panel below)."
msgstr ""
"我们可以简单地写一个新的工作流基于 ``MultiplyAddWorkChain`` ，并在大纲中包括一个额外的步骤运行 ``is_even`` "
"计算函数。然而，这将导致大量的代码重复，并且由多个工作链组成的较长的工作流将变得非常难以处理(参见下面的下拉面板)。"

#: ../../source/howto/write_workflows.rst:0
msgid "``BadMultiplyAddIsEvenWorkChain``"
msgstr ""

#: ../../source/howto/write_workflows.rst:166
msgid ""
"We've removed the ``result`` step from the outline, as well as the "
"``result`` output. For this work chain, we're assuming that for now we are "
"only interested in whether or not the result is even."
msgstr ""
"我们已经从大纲中删除了 ``result`` 步骤，以及 ``result`` 输出。对于这个工作链，我们假设现在我们只关心结果是否为偶数。"

#: ../../source/howto/write_workflows.rst:169
msgid ""
"We can avoid some code duplication by simply submitting the "
"``MultiplyAddWorkChain`` within one of the steps of a new work chain which "
"would then call ``is_even`` in a second step:"
msgstr ""
"我们可以通过简单地在新工作链的一个步骤中提交 ``MultiplyAddWorkChain`` 来避免一些代码重复，然后在第二个步骤中调用 "
"``is_even`` :"

#: ../../source/howto/write_workflows.rst:175
msgid ""
"This already simplifies the extended work chain, and avoids duplicating the "
"steps of the ``MultiplyAddWorkChain`` in the outline. However, we still had "
"to copy all of the input definitions of the ``MultiplyAddWorkChain``, and "
"manually extract them from the inputs before passing them to the "
"``self.submit`` method. Fortunately, there is a better way of *exposing* the"
" inputs and outputs of subprocesses of the work chain."
msgstr ""
"这已经简化了扩展的工作链，并避免在大纲中重复 ``MultiplyAddWorkChain`` 步骤。然而，我们仍然必须复制 "
"``MultiplyAddWorkChain`` 的所有输入定义，并在将它们传递给  ``self.submit`` "
"之前从输入中手动提取它们。幸运的是，有一种更好的方法来 *暴露* 工作链子流程的输入和输出。"

#: ../../source/howto/write_workflows.rst:182
msgid ""
"In many cases it is convenient for work chains to expose the inputs of the "
"subprocesses it wraps so users can specify these inputs directly, as well as"
" exposing some of the outputs produced as one of the results of the parent "
"work chain. For the simple example presented in the previous section, simply"
" copy-pasting the input and output port definitions of the subprocess "
"``MultiplyAddWorkChain`` was not too troublesome. However, this quickly "
"becomes tedious and error-prone once you start to wrap processes with quite "
"a few more inputs."
msgstr ""
"在许多情况下，工作链可以方便地公开其包装的子流程的输入，以便用户可以直接指定这些输入，还可以暴露作为父工作链的结果之一产生的一些输出。对于前一节中给出的简单示例，简单地复制粘贴子流程"
" ``MultiplyAddWorkChain`` "
"的输入和输出端口定义并不是太麻烦。但是，一旦您开始使用更多的输入来包装流程，这很快就会变得冗长且易出错。"

#: ../../source/howto/write_workflows.rst:186
msgid ""
"To prevent the copy-pasting of input and output specifications, the "
":class:`~aiida.engine.processes.process_spec.ProcessSpec` class provides the"
" :meth:`~plumpy.ProcessSpec.expose_inputs` and "
":meth:`~plumpy.ProcessSpec.expose_outputs` methods. Calling "
":meth:`~plumpy.ProcessSpec.expose_inputs` for a particular ``Process`` "
"class, will automatically copy the inputs of the class into the inputs "
"namespace of the process specification:"
msgstr ""
"为了防止输入和输出规范的复制-粘贴， :class:`~aiida.engine.processes.process_spec.ProcessSpec`"
" 类提供了 :meth:`~plumpy.ProcessSpec.expose_inputs` 和 "
":meth:`~plumpy.ProcessSpec.expose_outputs`  方法。对特定例程类调用  "
":meth:`~plumpy.ProcessSpec.expose_inputs` 会将类的输入自动复制到进程规范的输入名称空间中:"

#: ../../source/howto/write_workflows.rst:202
msgid ""
"Be aware that any inputs that already exist in the namespace will be "
"overridden. To prevent this, the method accepts the ``namespace`` argument, "
"which will cause the inputs to be copied into that namespace instead of the "
"top-level namespace. This is especially useful for exposing inputs since "
"*all* processes have the ``metadata`` input. If you expose the inputs "
"without a namespace, the ``metadata`` input port of the exposed class will "
"override the one of the host, which is often not desirable. Let's copy the "
"inputs of the ``MultiplyAddWorkChain`` into the ``multiply_add`` namespace:"
msgstr ""
"请注意，命名空间中已经存在的任何输入都将被覆盖。为了防止这种情况，该方法接受 ``namespace`` "
"作为参数，这将导致输入被复制到该名称空间，而不是最外层命名空间。这对于暴露输入尤其有用，因为 *所有* 进程都有 ``metadata`` "
"输入。如果暴露的输入没有命名空间，那么暴露的类的 ``metadata`` 输入端口将覆盖原来的输入端口，这通常是不需要的。让我们将 "
"``MultiplyAddWorkChain`` 的输入复制到 ``multiply_add`` 命名空间中:"

#: ../../source/howto/write_workflows.rst:213
msgid ""
"That takes care of exposing the port specification of the wrapped process "
"class in a very efficient way. To easily retrieve the inputs that have been "
"passed to the process, one can use the "
":meth:`~aiida.engine.processes.process.Process.exposed_inputs` method. Note "
"the past tense of the method name. The method takes a process class and an "
"optional namespace as arguments, and will return the inputs that have been "
"passed into that namespace when it was launched. This utility now allows us "
"to simplify the ``multiply_add`` step in the outline:"
msgstr ""
"这将以一种非常有效的方式暴露包装的例程类的端口规范。为了简介地检索传递给流程的输入，可以使用 "
":meth:`~aiida.engine.processes.process.Process.exposed_inputs` "
"方法。注意方法名的过去时态。该方法以一个流程类和一个可选的名称空间作为参数，并将返回在启动该名称空间时传递给该名称空间的输入。这个实用程序现在允许我们简化"
"  ``multiply_add`` 大纲步骤:"

#: ../../source/howto/write_workflows.rst:224
msgid ""
"This way we don't have to manually fish out all the individual inputs from "
"the ``self.inputs`` but have to just call this single method, saving time "
"and lines of code. The final ``MultiplyAddIsEvenWorkChain`` can be found in "
"the dropdown panel below."
msgstr ""
"这样我们就不必手动从 ``self.inputs`` 中找出所有的输入。仅须调用这个单一的方法，节省了大量的时间和代码行。最后一个 "
"``MultiplyAddIsEvenWorkChain`` 可以在下面的下拉面板中找到。"

#: ../../source/howto/write_workflows.rst:0
msgid "``MultiplyAddIsEvenWorkChain``"
msgstr ""

#: ../../source/howto/write_workflows.rst:233
msgid ""
"When submitting or running the work chain using namespaced inputs "
"(``multiply_add`` in the example above), it is important to use the "
"namespace when providing the inputs:"
msgstr "当使用命名空间输入(上面例子中的 ``multiply_add`` )提交或运行工作链时，使用命名空间很重要:"

#: ../../source/howto/write_workflows.rst:244
msgid ""
"After running the ``MultiplyAddIsEvenWorkChain``, you can see a hierarchical"
" overview of the processes called by the work chain using the ``verdi "
"process status`` command:"
msgstr ""
"在运行 ``MultiplyAddIsEvenWorkChain`` 后，你可以使用 ``verdi process status`` "
"命令看到一个由工作链调用的进程的分级概述:"

#: ../../source/howto/write_workflows.rst:255
msgid ""
"Note that this command also recursively shows the processes called by the "
"subprocesses of the ``MultiplyAddIsEvenWorkChain`` work chain."
msgstr "注意，这个命令还递归地显示了由 ``MultiplyAddIsEvenWorkChain`` 工作链的子进程调用的进程。"

#: ../../source/howto/write_workflows.rst:257
msgid ""
"As mentioned earlier, you can also expose the outputs of the "
"``MultiplyAddWorkChain`` using the "
":meth:`~plumpy.ProcessSpec.expose_outputs` method. Say we want to add the "
"``result`` of the ``MultiplyAddWorkChain`` as one of the outputs of the "
"extended work chain:"
msgstr ""
"如前所述，您也可以使用 :meth:`~plumpy.ProcessSpec.expose_outputs` 暴露 "
"``MultiplyAddWorkChain`` 的输出。假设我们想添加 ``MultiplyAddWorkChain`` 的 ``result`` "
"作为扩展工作链的输出之一:"

#: ../../source/howto/write_workflows.rst:274
msgid ""
"Since there is not one output port that is shared by all process classes, it"
" is less critical to use the ``namespace`` argument when exposing outputs. "
"However, take care not to override the outputs of the parent work chain in "
"case they do have outputs with the same port name. We still need to pass the"
" ``result`` of the ``MultiplyAddWorkChain`` to the outputs of the parent "
"work chain. For example, we could do this in the ``is_even`` step by using "
"the :meth:`~aiida.engine.processes.process.Process.out` method:"
msgstr ""
"由于没有一个输出端口是由所有例程类共享的，所以在公开输出时使用 ``命名空间`` "
"参数就不那么重要了。但是，请注意不要覆盖父工作链的输出，以防它们的输出具有相同的端口名称。我们仍然需要传递 "
"``MultiplyAddWorkChain`` 的 ``result`` 到父工作链的输出。例如，我们可以在``is_even`` 步骤中使用 "
":meth:`~aiida.engine.processes.process.Process.out`  方法:"

#: ../../source/howto/write_workflows.rst:289
msgid ""
"This works fine if we want to pass a single output to the parent work chain,"
" but once again becomes tedious and error-prone when passing multiple "
"outputs. Instead we can use the "
":meth:`~aiida.engine.processes.process.Process.exposed_outputs` method in "
"combination with the "
":meth:`~aiida.engine.processes.process.Process.out_many` method:"
msgstr ""
"将单个输出传递给父工作链是可行的，但如果传递多个输出，则再次变得冗长且易出错。相反，我们可以使用 "
":meth:`~aiida.engine.processes.process.Process.exposed_outputs` 方法结合 "
":meth:`~aiida.engine.processes.process.Process.out_many` 方法来给出多个输出:"

#: ../../source/howto/write_workflows.rst:301
msgid ""
"The :meth:`~aiida.engine.processes.process.Process.exposed_outputs` method "
"returns a dictionary of the exposed outputs of the ``MultiplyAddWorkChain``,"
" extracted from the workchain node stored in the ``multi_addition`` key of "
"the context. The :meth:`~aiida.engine.processes.process.Process.out_many` "
"method takes this dictionary and assigns its values to the output ports with"
" names equal to the corresponding keys."
msgstr ""
" :meth:`~aiida.engine.processes.process.Process.exposed_outputs` "
"方法返回从存储在上下文的 ``multi_add`` 键中的工作链节点提取的，以字典形式表示的 ``MultiplyAddWorkChain`` "
"暴露的输出。 :meth:`~aiida.engine.processes.process.Process.out_many`  "
"方法接受这个字典，并将其值分配给对应键值相同的输出端口。"

#: ../../source/howto/write_workflows.rst:306
msgid ""
"Besides avoiding code duplication and errors, using the methods for exposing"
" inputs and outputs also has the advantage that our parent work chain "
"doesn't have to be adjusted in case the inputs or outputs of the child work "
"chain change. This makes the code much easier to maintain."
msgstr ""
"除了避免代码重复和错误之外，使用暴露输入和输出的方法还有一个优点，即父工作链不必在子工作链的输入或输出发生变化时进行调整。这使得代码更容易维护。"
