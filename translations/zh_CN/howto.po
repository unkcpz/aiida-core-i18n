# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2020, ECOLE POLYTECHNIQUE FEDERALE DE LAUSANNE (Theory and Simulation of Materials (THEOS) and National Centre for Computational Design and Discovery of Novel Materials (NCCR MARVEL)), Switzerland and ROBERT BOSCH LLC, USA. All rights reserved
# This file is distributed under the same license as the AiiDA package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Jusong Yu <jusong.yeu@gmail.com>, 2023
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: AiiDA 2.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-12-23 19:17+0000\n"
"PO-Revision-Date: 2023-12-21 01:39+0000\n"
"Last-Translator: Jusong Yu <jusong.yeu@gmail.com>, 2023\n"
"Language-Team: Chinese (China) (https://app.transifex.com/aiidateam/teams/98967/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../source/howto/archive_profile.md:16
msgid "How to inspect an archive"
msgstr "如何检查档案"

#: ../../source/howto/archive_profile.md:19
msgid ""
"This tutorial can be downloaded and run as a Jupyter Notebook: {nb-"
"download}`archive_profile.ipynb` {octicon}`download`, together with the "
"archive {download}`process.aiida`."
msgstr ""
"本教程可以 Jupyter Notebook 的形式下载和运行：{nb-download} `a rchive_profile.ipynb` "
"{octicon} `download`，以及存档 {download} `process.aiida`。"

#: ../../source/howto/archive_profile.md:22
msgid ""
"The AiiDA archive is a file format for long term storage of data from a "
"particular profile. See {ref}`how-to:share:archives` for information on how "
"to create and migrate an archive."
msgstr ""
"AiiDA 存档是一种长期存储特定配置文件数据的文件格式。有关如何创建和迁移存档的信息，请参阅 {ref}`how-"
"to:share:archives`。"

#: ../../source/howto/archive_profile.md:25
msgid ""
"The easiest way to inspect the contents of an archive is to create a profile"
" that \"mounts\" the archive as its data storage:"
msgstr "检查存档内容的最简单方法是创建一个配置文件，将存档作为其数据存储："

#: ../../source/howto/archive_profile.md:31
msgid ""
"You can now inspect the contents of the `process.aiida` archive by using the"
" `archive` profile in the same way you would a standard AiiDA profile. For "
"example, you can start an interactive shell using `verdi -p archive shell` "
"or if you are already in a notebook simply load the profile:"
msgstr ""
"现在，你可以像使用标准 AiiDA 配置文件一样，使用 `archive` 配置文件检查 `process.aiida` 存档的内容。例如，你可以使用 "
"`verdi -p archive shell` 启动一个交互式 shell，或者如果你已经在笔记本中，只需加载配置文件："

#: ../../source/howto/archive_profile.md:40
msgid ""
"A profile using the `core.sqlite_zip` storage is read-only. It is therefore "
"possible to query data, but trying to modify existing data or store new data"
" will raise an exception."
msgstr "使用 `core.sqlite_zip` 存储器的配置文件是只读的。因此可以查询数据，但试图修改现有数据或存储新数据时会出现异常。"

#: ../../source/howto/archive_profile.md:44
msgid ""
"Just as with a normal profile, we can now use the "
"{py:class}`~aiida.orm.QueryBuilder`, to [find and query for data](how-"
"to:query):"
msgstr ""
"就像使用普通配置文件一样，我们现在可以使用 {py:class}`~aiida.orm.QueryBuilder` 来 [查找和查询数据](how-"
"to:query)："

#: ../../source/howto/archive_profile.md:52
msgid ""
"and also use {py:class}`~aiida.tools.visualization.graph.Graph`, to "
"[visualize data provenance](how-to:data:visualise-provenance):"
msgstr ""
"还可以使用 {py:class}`~aiida.tools.visualization.graph.Graph`，来 [可视化数据 "
"provenance](how-to:data:visualise-provenance)："

#: ../../source/howto/archive_profile.md:64
msgid ""
"Once you are done inspecting the archive and you no longer want to keep the "
"profile around, you can delete it:"
msgstr "检查完档案后，如果不想再保留档案，就可以删除它："

#: ../../source/howto/archive_profile.md:68
msgid ""
"You will be prompted whether you also want to keep the data. If you want to "
"keep the `process.aiida` archive file, select not to delete the data."
msgstr "系统会提示您是否还要保留数据。如果要保留 `process.aiida` 存档文件，请选择不删除数据。"

#: ../../source/howto/cookbook.rst:5
msgid "Cookbook"
msgstr "食谱"

#: ../../source/howto/cookbook.rst:7
msgid ""
"This how-to page collects useful short scripts and code snippets that may be"
" useful in the everyday usage of AiiDA."
msgstr "本页收集了对 AiiDA 日常使用有用的简短脚本和代码片段。"

#: ../../source/howto/cookbook.rst:11
msgid "Checking the queued jobs on a scheduler"
msgstr "检查调度程序上的排队作业"

#: ../../source/howto/cookbook.rst:13
msgid ""
"If you want to know if which jobs are currently on the scheduler (e.g. to "
"dynamically decide on which computer to submit, or to delay submission, "
"etc.) you can use the following script as an example:"
msgstr "如果您想知道当前调度程序上有哪些作业（例如，动态决定在哪台计算机上提交，或延迟提交等），可以使用下面的脚本作为示例："

#: ../../source/howto/cookbook.rst:58
msgid "Use ``verdi run`` to execute it:"
msgstr "使用 ``verdi run`` 执行："

#: ../../source/howto/cookbook.rst:66
msgid ""
"Every time you call the function, two SSH connections are opened! So be "
"careful and run this function sparsely, or your supercomputer center might "
"block your account. A possible work around to this limitation is to pass the"
" transport as a parameter, and pass it in so that it can be reused."
msgstr ""
"每次调用该函数，都会打开两个 SSH "
"连接！因此要小心谨慎，尽量少用这个函数，否则超级计算机中心可能会封杀你的账户。解决这一限制的一个可行办法是将传输作为参数传递，这样就可以重复使用。"

#: ../../source/howto/cookbook.rst:70
msgid "An example output would be::"
msgstr "输出示例如下：："

#: ../../source/howto/cookbook.rst:93
msgid "Getting an ``AuthInfo`` knowing the computer and the user"
msgstr "了解计算机和用户，获取 ``AuthInfo``"

#: ../../source/howto/cookbook.rst:95
msgid ""
"To open a transport to a computer, you need the corresponding "
":class:`~aiida.orm.authinfos.AuthInfo` object, which contains the required "
"information for a specific user. Once you have the relevant "
":class:`~aiida.orm.computers.Computer` and :class:`~aiida.orm.users.User` "
"collection, you can obtain as follows:"
msgstr ""
"要打开到计算机的传输，需要相应的 :class:`~aiida.orm.authinfos.AuthInfo` "
"对象，其中包含特定用户所需的信息。一旦获得相关的 :class:`~aiida.orm.computers.Computer` 和 "
":class:`~aiida.orm.users.User` 集合，就可以按如下方式获取："

#: ../../source/howto/cookbook.rst:102
msgid "Here is, as an example, a useful utility function:"
msgstr "下面举例说明一个有用的效用函数："

#: ../../source/howto/cookbook.rst:112
msgid "that you can then use, for instance, as follows:"
msgstr "例如，您可以如下使用它："

#: ../../source/howto/data.rst-1
msgid "grouppath"
msgstr "群策群力"

#: ../../source/howto/data.rst:5
msgid "How to work with data"
msgstr "如何使用数据"

#: ../../source/howto/data.rst:11
msgid "Importing data"
msgstr "Importing 数据"

#: ../../source/howto/data.rst:13
msgid ""
"AiiDA allows users to export data from their database into an export archive"
" file, which can be imported into any other AiiDA database. If you have an "
"AiiDA export archive that you would like to import, you can use the ``verdi "
"archive import`` command (see :ref:`the reference section<reference:command-"
"line:verdi-archive>` for details)."
msgstr ""
"AiiDA 允许用户从他们的数据库导出数据到导出档案文件，这个档案文件可以 import 到任何其他 AiiDA 数据库。如果你有一个 AiiDA "
"导出归档文件，你可以使用 ``verdi archive import`` 命令（详见 :ref:`the reference "
"section<reference:command-line:verdi-archive>`）。"

#: ../../source/howto/data.rst:16
msgid ""
"For information on exporting and importing data via AiiDA archives, see "
":ref:`\"How to share data\"<how-to:share:archives>`."
msgstr ""
"有关通过 AiiDA 存档导出和 import 数据的信息，请参阅 :ref:`\"How to share data\"<how-"
"to:share:archives>`。"

#: ../../source/howto/data.rst:18
msgid ""
"If, instead, you have existing data that are not yet part of an AiiDA export"
" archive, such as files, folders, tabular data, arrays or any other kind of "
"data, this how-to guide will show you how to import them into AiiDA."
msgstr ""
"如果你现有的数据还不是 AiiDA 导出存档的一部分，如文件、文件夹、表格数据、数组或任何其他类型的数据，本指南将告诉你如何将它们 import 导入 "
"AiiDA。"

#: ../../source/howto/data.rst:20
msgid ""
"To store any piece of data in AiiDA, it needs to be wrapped in a "
":py:class:`~aiida.orm.Data` node, such that it can be represented in the "
":ref:`provenance graph <topics:provenance>`. There are different varieties, "
"or subclasses, of this ``Data`` class that are suited for different types of"
" data. AiiDA ships with a number of built-in data types. You can list these "
"using the :ref:`verdi plugin<reference:command-line:verdi-plugin>` command. "
"Executing ``verdi plugin list aiida.data`` should display something like::"
msgstr ""
"要在 AiiDA 中存储任何数据，都需要用 :py:class:`~aiida.orm.Data` node 进行封装，以便用 "
":ref:`provenance graph <topics:provenance>` 表示。这个 ``Data`` "
"类有不同的种类或子类，适用于不同类型的数据。AiiDA 内置了许多数据类型。你可以使用 :ref:`verdi "
"plugin<reference:command-line:verdi-plugin>` 命令列出这些类型。执行 ``verdi plugin list"
" aiida.data`` 应该会显示如下内容：："

#: ../../source/howto/data.rst:38
msgid ""
"As the output suggests, you can get more information about each type by "
"appending the name to the command, for example, ``verdi plugin list "
"aiida.data singlefile``::"
msgstr ""
"正如输出结果所示，您可以通过在命令中添加名称来获取每种类型的更多信息，例如 ``verdi plugin list aiida.data "
"singlefile``:："

#: ../../source/howto/data.rst:56
msgid ""
"As you can see, the ``singlefile`` type corresponds to the "
":py:class:`~aiida.orm.nodes.data.singlefile.SinglefileData` class and is "
"designed to wrap a single file that is stored on your local filesystem. If "
"you have such a file that you would like to store in AiiDA, you can use the "
"``verdi shell`` to create it:"
msgstr ""
"如你所见， ``singlefile`` 类型对应于 "
":py:class:`~aiida.orm.nodes.data.singlefile.SinglefileData` "
"类，设计用于封装存储在本地文件系统的单个文件。如果你想在 AiiDA 中存储这样一个文件，你可以使用 ``verdi shell`` 来创建它："

#: ../../source/howto/data.rst:65
msgid ""
"The first step is to load the class that corresponds to the data type, which"
" you do by passing the name (listed by ``verdi plugin list aiida.data``) to "
"the :py:class:`~aiida.plugins.factories.DataFactory`. Then we just construct"
" an instance of that class, passing the file of interest as an argument."
msgstr ""
"第一步是加载与数据类型相对应的类，只需将名称（由 ``verdi plugin list aiida.data`` 列出）传递给 "
":py:class:`~aiida.plugins.factories.DataFactory` "
"即可。然后，我们只需构建该类的实例，并将感兴趣的文件作为参数传递即可。"

#: ../../source/howto/data.rst:68
msgid ""
"The exact manner of constructing an instance of any particular data type is "
"type dependent. Use the ``verdi plugin list aiida.data <ENTRY_POINT>`` "
"command to get more information for any specific type."
msgstr ""
"构建任何特定数据类型实例的具体方式取决于类型。使用 ``verdi plugin list aiida.data <ENTRY_POINT>`` "
"命令可获取任何特定类型的更多信息。"

#: ../../source/howto/data.rst:71
msgid ""
"Note that after construction, you will get an *unstored* node. This means "
"that at this point your data is not yet stored in the database and you can "
"first inspect it and optionally modify it. If you are happy with the "
"results, you can store the new data permanently by calling the "
":py:meth:`~aiida.orm.nodes.node.Node.store` method. Every node is assigned a"
" Universal Unique Identifier (UUID) upon creation and once stored it is also"
" assigned a primary key (PK), which can be retrieved through the "
"``node.uuid`` and ``node.pk`` properties, respectively. You can use these "
"identifiers to reference and or retrieve a node. Ways to find and retrieve "
"data that have previously been imported are described in section :ref:`\"How"
" to find data\"<how-to:query>`."
msgstr ""
"请注意，在构建后，您将得到一个 *未存储* 的 "
"node。这意味着此时您的数据尚未存储到数据库中，您可以先检查数据，也可以选择修改数据。如果您对结果满意，可以通过调用 "
":py:meth:`~aiida.orm.nodes.node.Node.store` 方法永久存储新数据。每个 node "
"在创建时都会分配一个通用唯一标识符（UUID），存储后还会分配一个主键（PK），可分别通过 ``node.uuid`` 和 ``node.pk`` "
"属性进行检索。您可以使用这些标识符来引用或检索 node。查找和检索先前已 imported 的数据的方法在第 :ref:`\"How to find "
"data\"<how-to:query>` 节中有描述。"

#: ../../source/howto/data.rst:78
msgid ""
"If none of the currently available data types, as listed by ``verdi plugin "
"list``, seem to fit your needs, you can also create your own custom type. "
"For details refer to the next section :ref:`\"How to add support for custom "
"data types\"<topics:data_types:plugin>`."
msgstr ""
"如果 ``verdi plugin list`` 列出的现有数据类型都不符合您的需求，您也可以创建自己的自定义类型。详情请参阅下一节 "
":ref:`\"How to add support for custom data "
"types\"<topics:data_types:plugin>`。"

#: ../../source/howto/data.rst:85
msgid "Provenance"
msgstr "Provenance"

#: ../../source/howto/data.rst:87
msgid ""
"While AiiDA will automatically keep the provenance of data that is created "
"by it through calculations and workflows, this is clearly not the case when "
"creating data nodes manually, as described in the previous section. "
"Typically, the manual creation of data happens at the beginning of a project"
" when data from external databases is imported as a starting point for "
"further calculations. To still keep some form of provenance, the "
":class:`~aiida.orm.Data` base class allows to record the _source_ of the "
"data it contains. When constructing a new data node, of any type, you can "
"pass a dictionary with information of the source under the ``source`` "
"keyword argument:"
msgstr ""
"虽然 AiiDA 会自动保留通过计算和 workflow 创建的 provenance 数据，但如上节所述，在手动创建数据 node "
"时，情况显然不是这样。通常情况下，手动创建数据发生在项目开始时，即从外部数据库获取数据作为进一步计算的起点。为了保持某种形式的 "
"provenance，:class:`~aiida.orm.Data` 基类允许记录所含数据的 _来源_ 。在构建任何类型的新数据 node "
"时，都可以在 ``source`` 关键字参数下传递一个包含源信息的字典："

#: ../../source/howto/data.rst:96
msgid ""
"Once stored, this data can always be retrieved through the ``source`` "
"property:"
msgstr "这些数据一旦存储，就可以随时通过 ``source`` 属性进行检索："

#: ../../source/howto/data.rst:102
msgid ""
"The following list shows all the keys that are allowed to be set in the "
"``source`` dictionary:"
msgstr "以下列表显示了允许在 ``source`` 字典中设置的所有键："

#: ../../source/howto/data.rst:104
msgid "``db_name``: The name of the external database."
msgstr "``db_name``：外部数据库的名称。"

#: ../../source/howto/data.rst:105
msgid "``db_uri``: The base URI of the external database."
msgstr "``db_uri``:外部数据库的基本 URI。"

#: ../../source/howto/data.rst:106
msgid ""
"``uri``: The exact URI of where the data can be retrieved. Ideally this is a"
" persistent URI."
msgstr "``uri``：可检索数据的确切 URI。理想情况下，这是一个持久 URI。"

#: ../../source/howto/data.rst:107
msgid ""
"``id``: The external ID with which the data is identified in the external "
"database."
msgstr "``id``： 外部数据库中识别数据的外部 ID。"

#: ../../source/howto/data.rst:108
msgid "``version``: The version of the data, if any."
msgstr "``version``：数据版本（如果有）。"

#: ../../source/howto/data.rst:109
msgid ""
"``extras``: Optional dictionary with other fields for source description."
msgstr "``extras``：可选字典，包含其他字段的来源说明。"

#: ../../source/howto/data.rst:110
msgid "``source_md5``: MD5 checksum of the data."
msgstr "``source_md5``：数据的 MD5 校验和。"

#: ../../source/howto/data.rst:111
msgid ""
"``description``: Human-readable free form description of the data's source."
msgstr "``description``： 关于数据来源的人可读的自由格式描述。"

#: ../../source/howto/data.rst:112
msgid ""
"``license``: A string with the type of license that applies to the data, if "
"any."
msgstr "``license``：一个字符串，包含适用于数据的许可证类型（如果有）。"

#: ../../source/howto/data.rst:114
msgid ""
"If any other keys are defined, an exception will be raised by the "
"constructor."
msgstr "如果定义了任何其他键，构造函数将引发异常。"

#: ../../source/howto/data.rst:120
msgid "Organizing data"
msgstr "整理数据"

#: ../../source/howto/data.rst:125
msgid "How to group nodes"
msgstr "如何分组 nodes"

#: ../../source/howto/data.rst:127
msgid ""
"AiiDA's database is great for automatically storing all your data, but "
"sometimes it can be tricky to navigate this flat data store. To create some "
"order in this mass of data, you can *group* sets of nodes together, just as "
"you would with files in folders on your filesystem. A folder, in this "
"analogy, is represented by the :py:class:`~aiida.orm.groups.Group` class. "
"Each group instance can hold any amount of nodes and any node can be "
"contained in any number of groups. A typical use case is to store all nodes "
"that share a common property in a single group."
msgstr ""
"AiiDA "
"的数据库非常适合自动存储所有数据，但有时浏览这个平面数据存储可能会很棘手。为了在海量数据中创建一些秩序，你可以将nodes组*合在一起，就像你在文件系统中的文件夹中创建文件一样。在这个类比中，文件夹由"
" :py:class:`~aiida.orm.groups.Group` 类表示。每个组实例可以容纳任意数量的 node，任何 node "
"都可以包含在任意数量的组中。一个典型的用例是在一个组中存储所有具有共同属性的 node。"

#: ../../source/howto/data.rst:133
msgid ""
"Below we show how to perform a typical set of operations one may want to "
"perform with groups."
msgstr "下面我们将展示如何对组执行一系列典型的操作。"

#: ../../source/howto/data.rst:136
msgid "Create a new group"
msgstr "创建新组"

#: ../../source/howto/data.rst:138 ../../source/howto/data.rst:202
#: ../../source/howto/data.rst:220 ../../source/howto/data.rst:254
#: ../../source/howto/data.rst:272 ../../source/howto/data.rst:295
msgid "From the command line interface:"
msgstr "从命令行界面"

#: ../../source/howto/data.rst:144 ../../source/howto/data.rst:227
#: ../../source/howto/data.rst:261 ../../source/howto/data.rst:302
msgid "From the Python interface:"
msgstr "从 Python 界面"

#: ../../source/howto/data.rst:155
msgid "List available groups"
msgstr "列出可用组别"

#: ../../source/howto/data.rst:157
msgid "Example:"
msgstr "例如"

#: ../../source/howto/data.rst:163
msgid ""
"Groups come in different types, indicated by their type string. By default "
"``verdi group list`` only shows groups of the type *core*. In case you want "
"to show groups of another type use ``-T/--type-string`` option. If you want "
"to show groups of all types, use the ``-a/--all-types`` option."
msgstr ""
"组有不同的类型，由其类型字符串表示。默认情况下，``verdi group list`` 只显示 *core* 类型的组。如果要显示其他类型的组，请使用"
" ``-T/--type-string`` 选项。如果要显示所有类型的组，请使用 ``-a/--all-types`` 选项。"

#: ../../source/howto/data.rst:168
msgid "For example, to list groups of type ``core.auto``, use:"
msgstr "例如，要列出 ``core.auto`` 类型的组，请使用"

#: ../../source/howto/data.rst:174
msgid ""
"Similarly, we can use the ``type_string`` key to filter groups with the "
"``QueryBuilder``:"
msgstr "同样，我们可以使用 ``type_string`` 密钥来过滤 ``QueryBuilder`` 组："

#: ../../source/howto/data.rst:185
msgid "Add nodes to a group"
msgstr "将 nodes 添加到群组"

#: ../../source/howto/data.rst:186
msgid ""
"Once the ``test_group`` has been created, we can add nodes to it. For "
"example, to add a node with ``pk=1`` to the group we could either use the "
"command line interface:"
msgstr ""
"创建 ``test_group`` 后，我们就可以向其中添加 node。例如，要将 ``pk=1`` 的 node 添加到组中，我们可以使用命令行界面："

#: ../../source/howto/data.rst:194
msgid "Or the Python interface:"
msgstr "或 Python 界面："

#: ../../source/howto/data.rst:201
msgid "Show information about a group"
msgstr "显示小组信息"

#: ../../source/howto/data.rst:219
msgid "Remove nodes from a group"
msgstr "从一个组中删除 nodes"

#: ../../source/howto/data.rst:235
msgid ""
"Alternatively, you might want to remove *all* nodes from the group. In the "
"command line you just need to add ``-c/--clear`` option to ``verdi group "
"remove-nodes ..``"
msgstr ""
"或者，你也可以将所有 node 从组中删除。在命令行中，只需在 ``verdi group remove-nodes ..`` 中添加 "
"``-c/--clear`` 选项即可"

#: ../../source/howto/data.rst:243
msgid ""
"In the Python interface you can use ``.clear()`` method to achieve the same "
"goal:"
msgstr "在 Python 界面中，您可以使用 ``.clear()`` 方法来实现同样的目标："

#: ../../source/howto/data.rst:253
msgid "Rename a group"
msgstr "重命名组"

#: ../../source/howto/data.rst:271
msgid "Delete a group"
msgstr "删除组"

#: ../../source/howto/data.rst:280
msgid ""
"Any deletion operation related to groups, by default, will not affect the "
"nodes themselves. For example if you delete a group, the nodes that belonged"
" to the group will remain in the database. The same happens if you remove "
"nodes from the group -- they will remain in the database but won't belong to"
" the group anymore."
msgstr ""
"默认情况下，任何与组相关的删除操作都不会影响 nodes 本身。例如，如果删除一个组，属于该组的 node 将保留在数据库中。如果从组中删除 "
"node，也会发生同样的情况--它们会保留在数据库中，但不再属于该组。"

#: ../../source/howto/data.rst:284
msgid ""
"If you also wish to delete the nodes, when deleting the group, use the "
"``--delete-nodes`` option:"
msgstr "如果还想删除 node，请在删除组时使用 ``--delete-nodes`` 选项："

#: ../../source/howto/data.rst:291
msgid "Copy one group into another"
msgstr "将一个组复制到另一个组"

#: ../../source/howto/data.rst:292
msgid ""
"This operation will copy the nodes of the source group into the destination "
"group. If the destination group does not yet exist, it will be created "
"automatically."
msgstr "此操作将把源组的 nodes 复制到目标组。如果目标组尚不存在，则会自动创建。"

#: ../../source/howto/data.rst:314
msgid "Examples for using groups"
msgstr "使用小组的示例"

#: ../../source/howto/data.rst:316
msgid ""
"In this section, we will provide some practical examples of how one can use "
"Groups to structure and organize the nodes in the database."
msgstr "在本节中，我们将举例说明如何使用组来结构化和组织数据库中的 node。"

#: ../../source/howto/data.rst:321
msgid "Group structures with a similar property"
msgstr "将具有相似属性的结构分组"

#: ../../source/howto/data.rst:323
msgid ""
"Suppose, we wanted to group all structures for which the computed bandgap is"
" higher than ``1.0 eV`` in a group named ``promising_structures``, one could"
" use the following approach:"
msgstr ""
"假设我们想把计算带隙大于 ``1.0 eV`` 的所有结构归为一个名为 ``promising_structures`` 的组，可以采用以下方法："

#: ../../source/howto/data.rst:339
msgid ""
"Any node can be included in a group only once and if it is added again, it "
"is simply ignored. This means that add_nodes can be safely called multiple "
"times, and only nodes that weren't already part of the group, will be added."
msgstr ""
"任何 node 都只能被包含在组中一次，如果再次添加，则会被忽略。这意味着 add_nodes 可以安全地调用多次，而且只有尚未加入组的 node "
"才会被加入。"

#: ../../source/howto/data.rst:344
msgid "Use grouped data for further processing"
msgstr "使用分组数据进行进一步处理"

#: ../../source/howto/data.rst:346
msgid ""
"Here we demonstrate how to submit calculations for structures that all "
"belong to a group named ``promising_structures``:"
msgstr "在此，我们将演示如何提交都属于一个名为 ``promising_structures`` 的结构组的计算结果："

#: ../../source/howto/data.rst:362
msgid ""
"Note, however, that one can also use ``group.nodes`` to access the nodes of "
"the group. To achieve the same result as above one would need to do "
"something as follows:"
msgstr "不过请注意，我们也可以使用 ``group.nodes`` 来访问组中的 node。要获得与上述相同的结果，需要执行如下操作："

#: ../../source/howto/data.rst:378
msgid ""
"To find all structures that have a property ``property_a`` with a value "
"lower than ``1`` and also belong to the ``promising_structures`` group, one "
"could build a query as follows:"
msgstr ""
"要查找所有属性 ``property_a`` 值小于 ``1``，同时属于 ``promising_structures`` "
"组的结构，可以建立如下查询："

#: ../../source/howto/data.rst:388
msgid ""
"The return value of ``qb.all(flat=True)`` would contain all the structures "
"matching the above mentioned criteria."
msgstr "返回值 ``qb.all(flat=True)`` 将包含符合上述条件的所有结构。"

#: ../../source/howto/data.rst:393
msgid "Organise groups in hierarchies"
msgstr "按等级组织小组"

#: ../../source/howto/data.rst:398
msgid ""
"Groups in AiiDA are inherently \"flat\", in that groups may only contain "
"nodes and not other groups. However it is possible to construct *virtual* "
"group hierarchies based on delimited group labels, using the "
":py:class:`~aiida.tools.groups.paths.GroupPath` utility."
msgstr ""
"AiiDA 中的组本身就是 \"flat\" ，因为组只能包含 node，而不能包含其他组。不过，可以使用 "
":py:class:`~aiida.tools.groups.paths.GroupPath` 工具，根据分隔的组标签构建 *虚拟* 组层次结构。"

#: ../../source/howto/data.rst:401
msgid ""
":py:class:`~aiida.tools.groups.paths.GroupPath` is designed to work in much "
"the same way as Python's :py:class:`pathlib.Path`, whereby paths are denoted"
" by forward slash characters '/' in group labels."
msgstr ""
" :py:class:`~aiida.tools.groups.paths.GroupPath` 的设计工作方式与 Python 的 "
":py:class:`pathlib.Path` 基本相同，即在组标签中用正斜杠字符 '/' 表示路径。"

#: ../../source/howto/data.rst:403
msgid "For example say we have the groups:"
msgstr "例如，我们有这样几个小组"

#: ../../source/howto/data.rst:415
msgid "We can also access them from the command-line as:"
msgstr "我们还可以通过命令行访问它们："

#: ../../source/howto/data.rst:428
msgid "Or from the python interface:"
msgstr "或从 python 界面："

#: ../../source/howto/data.rst:438
msgid "The ``GroupPath`` can be constructed using indexing or \"divisors\":"
msgstr "``GroupPath`` 可通过索引或 \``divisors\`` 构建："

#: ../../source/howto/data.rst:446
msgid ""
"Using the :py:func:`~aiida.tools.groups.paths.GroupPath.browse` attribute, "
"you can also construct the paths as preceding attributes. This is useful in "
"interactive environments, whereby available paths will be shown in the tab-"
"completion:"
msgstr "使用 :py:func:`~aiida.tools.groups.paths.GroupPath.browse` 属性，还可以将路径构建为前面的属性。这在交互式环境中非常有用，可用路径将显示在选项卡完成中："

#: ../../source/howto/data.rst:454
msgid "To check the existence of a path element:"
msgstr "检查路径元素是否存在："

#: ../../source/howto/data.rst:461
msgid ""
"A group may be \"virtual\", in which case its label does not directly relate"
" to a group, or the group can be retrieved with the "
":py:func:`~aiida.tools.groups.paths.GroupPath.get_group` method:"
msgstr "组可能是 \``virtual\``，在这种情况下，其标签与组没有直接关系，也可以使用 :py:func:`~aiida.tools.groups.paths.GroupPath.get_group` 方法检索组："

#: ../../source/howto/data.rst:474
msgid "Groups can be created and destroyed:"
msgstr "可以创建和销毁群组："

#: ../../source/howto/data.rst:486
msgid ""
"To traverse paths, use the "
":py:func:`~aiida.tools.groups.paths.GroupPath.children` attribute - for "
"recursive traversal, use "
":py:func:`~aiida.tools.groups.paths.GroupPath.walk`:"
msgstr "要遍历路径，请使用 :py:func:`~aiida.tools.groups.paths.GroupPath.children` 属性；要进行递归遍历，请使用 :py:func:`~aiida.tools.groups.paths.GroupPath.walk`："

#: ../../source/howto/data.rst:497
msgid ""
"You can also traverse directly through the nodes of a path, optionally "
"filtering by node class and any other filters allowed by the "
":ref:`QueryBuilder <how-to:query>`:"
msgstr "您还可以直接遍历路径上的 node，选择性地按 node 类别和 :ref:`QueryBuilder <how-to:query>` 允许的任何其他过滤器进行过滤："

#: ../../source/howto/data.rst:511
msgid ""
"Finally, you can also specify the ``Group`` subclasses (as discussed above):"
msgstr "最后，您还可以指定 ``Group`` 子类(如上所述)："

#: ../../source/howto/data.rst:522
msgid ""
"A :py:class:`~aiida.tools.groups.paths.GroupPath` instance will only "
"recognise groups of the instantiated ``cls`` type. The default ``cls`` is "
"``aiida.orm.Group``:"
msgstr " :py:class:`~aiida.tools.groups.paths.GroupPath` 实例只能识别实例 ``cls`` 类型的组。默认的 ``cls`` 是 ``aiida.orm.Group``："

#: ../../source/howto/data.rst:538
msgid "Deleting data"
msgstr "删除数据"

#: ../../source/howto/data.rst:540
msgid ""
"By default, every time you run or submit a new calculation, AiiDA will "
"create for you new nodes in the database, and will never replace or delete "
"data. There are cases, however, when it might be useful to delete nodes that"
" are not useful anymore, for instance test runs or incorrect/wrong data and "
"calculations. For this case, AiiDA provides the ``verdi node delete`` "
"command and the :py:func:`~aiida.tools.graph.deletions.delete_nodes` "
"function, to remove the nodes from the provenance graph."
msgstr "默认情况下，每次你运行或提交一个新的计算，AiiDA会在数据库中为你创建新的node，而不会替换或删除数据。然而，在某些情况下，删除不再有用的node可能是有用的，例如测试运行或不正确/错误的数据和计算。对于这种情况，AiiDA 提供了 ``verdi node delete`` 命令和 :py:func:`~aiida.tools.graph.deletions.delete_nodes` 函数，用于删除 provenance graph 中的 node。"

#: ../../source/howto/data.rst:545
msgid ""
"Once the data is deleted, there is no way to recover it (unless you made a "
"backup)."
msgstr "数据一旦删除，就无法恢复(除非你做了备份)。"

#: ../../source/howto/data.rst:547
msgid ""
"Critically, note that even if you ask to delete only one node, ``verdi node "
"delete`` will typically delete a number of additional linked nodes, in order"
" to preserve a consistent state of the provenance graph. For instance, if "
"you delete an input of a calculation, AiiDA will delete also the calculation"
" itself (as otherwise you would be effectively changing the inputs to that "
"calculation in the provenance graph). The full set of consistency rules are "
"explained in detail :ref:`here <topics:provenance:consistency>`."
msgstr "重要的是，请注意，即使你只要求删除一个 node，``verdi node delete`` 通常也会删除一些额外的链接 node，以保持 provenance graph 的一致状态。例如，如果你删除了一个计算的输入，AiiDA 也会删除计算本身(否则，你将有效地改变 provenance graph 中该计算的输入)。完整的一致性规则在 :ref:`here <topics:provenance:consistency>` 有详细解释。"

#: ../../source/howto/data.rst:551
msgid ""
"Therefore: always check the output of ``verdi node delete`` to make sure "
"that it is not deleting more than you expect. You can also use the ``--dry-"
"run`` flag of ``verdi node delete`` to see what the command would do without"
" performing any actual operation."
msgstr "因此：请务必检查 ``verdi node delete`` 的输出，以确保删除的内容没有超出预期。您也可以使用 ``verdi node delete`` 的 ``--dry-run`` 标志，查看命令在不执行任何实际操作的情况下会做什么。"

#: ../../source/howto/data.rst:554
msgid ""
"In addition, there are a number of additional rules that are not mandatory "
"to ensure consistency, but can be toggled by the user. For instance, you can"
" set ``--create-forward`` if, when deleting a calculation, you want to "
"delete also the data it produced (using instead ``--no-create-forward`` will"
" delete the calculation only, keeping the output data: note that this "
"effectively strips out the provenance information of the output data). The "
"full list of these flags is available from the help command ``verdi node "
"delete -h``."
msgstr "此外，为了确保一致性，还有一些附加规则不是强制性的，但用户可以进行切换。例如，在删除计算时，如果希望同时删除计算产生的数据，可以设置 ``--create-forward`` (使用 ``--no-create-forward`` 将只删除计算，保留输出数据：请注意，这实际上删除了输出数据的 provenance 信息)。这些标志的完整列表可以在帮助命令 ``verdi node delete -h`` 中找到。"

#: ../../source/howto/data.rst:566
msgid "Deleting computers"
msgstr "删除计算机"

#: ../../source/howto/data.rst:567
msgid ""
"To delete a computer, you can use ``verdi computer delete``. This command is"
" mostly useful if, right after creating a computer, you realise that there "
"was an error and you want to remove it. In particular, note that ``verdi "
"computer delete`` will prevent execution if the computer has been already "
"used by at least one node. In this case, you will need to use ``verdi node "
"delete`` to delete first the corresponding nodes."
msgstr "要删除计算机，可以使用 ``verdi computer delete``。如果在创建计算机后立即发现错误并想要删除它，这条命令就非常有用。特别要注意的是，如果计算机已被至少一个 node 使用过，``verdi computer delete`` 将无法执行。在这种情况下，您需要使用 ``verdi node delete`` 先删除相应的 node。"

#: ../../source/howto/data.rst:572
msgid "Deleting mutable data"
msgstr "删除可变数据"

#: ../../source/howto/data.rst:573
msgid ""
"A subset of data in AiiDA is mutable also after storing a node, and is used "
"as a convenience for the user to tag/group/comment on data. This data can be"
" safely deleted at any time. This includes, notably:"
msgstr "AiiDA 中的数据子集在存储 node 之后也是可变的，方便用户对数据进行标记/分组/评论。这些数据可以随时安全删除。主要包括"

#: ../../source/howto/data.rst:577
msgid ""
"*Node extras*: These can be deleted using :py:attr:`Node.base.extras "
"<aiida.orm.extras.EntityExtras>`."
msgstr "*Node 额外内容*：可使用 :py:attr:`Node.base.extras <aiida.orm.extras.EntityExtras>` 删除这些内容。"

#: ../../source/howto/data.rst:578
msgid ""
"*Node comments*: These can be removed using :py:attr:`Node.base.comments "
"<aiida.orm.nodes.comments.NodeComments>`."
msgstr "*Node 注释*：可使用 :py:attr:`Node.base.comments <aiida.orm.nodes.comments.NodeComments>` 删除这些注释。"

#: ../../source/howto/data.rst:579
msgid ""
"*Groups*: These can be deleted using :py:meth:`Group.objects.delete() "
"<aiida.orm.groups.GroupCollection.delete>`. This command will only delete "
"the group, not the nodes contained in the group."
msgstr "*组* ：可使用 :py:meth:`Group.objects.delete() <aiida.orm.groups.GroupCollection.delete>` 删除这些组。该命令只会删除组，而不会删除组中的 node。"

#: ../../source/howto/data.rst:583
msgid "Completely deleting an AiiDA profile"
msgstr "完全删除 AiiDA 配置文件"

#: ../../source/howto/data.rst:584
msgid ""
"If you don't want to selectively delete some nodes, but instead want to "
"delete a whole AiiDA profile altogether, use the ``verdi profile delete`` "
"command. This command will delete both the file repository and the database."
msgstr "如果你不想选择性地删除一些 node，而是想完全删除整个 AiiDA 配置文件，请使用 ``verdi profile delete`` 命令。这条命令将同时删除文件库和数据库。"

#: ../../source/howto/data.rst:589
msgid ""
"It is not possible to restore a deleted profile unless it was previously "
"backed up!"
msgstr "除非以前备份过，否则无法恢复已删除的配置文件！"

#: ../../source/howto/data.rst:594
msgid "Transferring data"
msgstr "传输数据"

#: ../../source/howto/data.rst:600
msgid ""
"This feature is still in beta version and its API might change in the near "
"future. It is therefore not recommended that you rely on it for your "
"public/production workflows."
msgstr "该功能仍处于测试版本，其 API 在不久的将来可能会发生变化。因此，不建议在公共/生产型 workflow 中使用该功能。"

#: ../../source/howto/data.rst:603
msgid ""
"Moreover, feedback on its implementation is much appreciated (at "
"https://github.com/aiidateam/aiida-core/issues/4811)."
msgstr "此外，我们也非常欢迎对其实施情况提出反馈意见(网址：https://github.com/aiidateam/aiida-core/issues/4811)。"

#: ../../source/howto/data.rst:605
msgid ""
"When a calculation job is launched, AiiDA will create a "
":py:class:`~aiida.orm.RemoteData` node that is attached as an output node to"
" the calculation node with the label ``remote_folder``. The input files "
"generated by the ``CalcJob`` plugin are copied to this remote folder and, "
"since the job is executed there as well, the code will produce its output "
"files in that same remote folder also. Since the "
":py:class:`~aiida.orm.RemoteData` node only explicitly stores the filepath "
"on the remote computer, and not its actual contents, it functions more or "
"less like a symbolic link. That means that if the remote folder gets "
"deleted, there will be no way to retrieve its contents. The ``CalcJob`` "
"plugin can for that reason specify some files that should be "
":ref:`retrieved<topics:calculations:usage:calcjobs:file_lists_retrieve>` and"
" stored locally in a :py:class:`~aiida.orm.nodes.data.folder.FolderData` "
"node for safekeeing, which is attached to the calculation node as an output "
"with the label ``retrieved_folder``."
msgstr "当计算作业启动时，AiiDA 将创建一个 :py:class:`~aiida.orm.RemoteData` node，作为输出 node 附加到标号为 ``remote_folder`` 的计算 node。``CalcJob`` 插件生成的输入文件被复制到该远程文件夹，由于作业也在该文件夹中执行，因此代码也将在同一远程文件夹中生成输出文件。由于 :py:class:`~aiida.orm.RemoteData` node 只明确存储远程计算机上的文件路径，而非实际内容，因此其功能或多或少类似于符号链接。这意味着，如果远程文件夹被删除，将无法检索其内容。因此，``CalcJob`` 插件可以指定一些文件，这些文件应被 :ref:`retrieved<topics:calculations:usage:calcjobs:file_lists_retrieve>` 并存储在本地的 :py:class:`~aiida.orm.nodes.data.folder.FolderData` node 中以确保安全，该文件将作为标号为 ``retrieved_folder`` 的输出附加到计算 node 中。"

#: ../../source/howto/data.rst:611
msgid ""
"Although the "
":ref:`retrieve_list<topics:calculations:usage:calcjobs:file_lists_retrieve>`"
" allows to specify what output files are to be retrieved locally, this has "
"to be done *before* the calculation is submitted. In order to provide more "
"flexibility in deciding what files of completed calculation jobs are to be "
"stored locally, even after it has terminated, AiiDA ships with a the "
":py:class:`~aiida.calculations.transfer.TransferCalculation` plugin. This "
"calculation plugin enables to retrieve files from a remote machine and save "
"them in a local :py:class:`~aiida.orm.nodes.data.folder.FolderData`. The "
"specifications of what to copy are provided through an input of type"
msgstr "虽然 :ref:`retrieve_list<topics:calculations:usage:calcjobs:file_lists_retrieve>` 允许指定在本地检索哪些输出文件，但这必须在提交计算之前完成。为了提供更多的灵活性来决定完成计算工作的文件在本地存储，甚至在计算结束后，AiiDA 提供了一个 :py:class:`~aiida.calculations.transfer.TransferCalculation` 插件。这个计算插件可以从远程机器获取文件并保存到本地 :py:class:`~aiida.orm.nodes.data.folder.FolderData`。拷贝内容的规格通过一个类型为"

#: ../../source/howto/data.rst:625
msgid ""
"The ``'source/path/filename'`` and ``'target/path/filename'`` are both "
"relative paths (to their respective folders). The ``node_keyname`` is a "
"string that will be used when providing the source "
":py:class:`~aiida.orm.RemoteData` node to the calculation. You also need to "
"provide the computer between which the transfer will occur:"
msgstr "``'source/path/filename'`` 和 ``'target/path/filename'`` 都是相对路径(指向各自的文件夹)。``node_keyname`` 是一个字符串，在为计算提供源 :py:class:`~aiida.orm.RemoteData` node 时使用。您还需要提供进行传输的计算机："

#: ../../source/howto/data.rst:636
msgid ""
"The variable ``source_node`` here corresponds to the ``RemoteData`` node "
"whose contents need to be retrieved. Finally, you just run or submit the "
"calculation as you would do with any other:"
msgstr "这里的变量 ``source_node`` 对应于需要检索其内容的 ``RemoteData`` node。最后，您只需运行或提交计算，就像处理其他计算一样："

#: ../../source/howto/data.rst:644
msgid ""
"You can also use this to copy local files into a new "
":py:class:`~aiida.orm.RemoteData` folder. For this you first have to adapt "
"the instructions to set ``'retrieve_files'`` to ``False`` and use a "
"``'local_files'`` list instead of the ``'symlink_files'``:"
msgstr "您也可以用它将本地文件复制到新的 :py:class:`~aiida.orm.RemoteData` 文件夹中。为此，您首先需要调整说明，将 ``'retrieve_files'`` 设置为 ``False``，并使用 ``'local_files'`` 列表代替 ``'symlink_files'``："

#: ../../source/howto/data.rst:656
msgid ""
"It is also relevant to note that, in this case, the ``source_node`` will be "
"of type :py:class:`~aiida.orm.nodes.data.folder.FolderData` so you will have"
" to manually select the computer to where you want to copy the files. You "
"can do this by looking at your available computers running ``verdi computer "
"list`` and using the label shown to load it with "
":py:func:`~aiida.orm.load_computer`:"
msgstr "还需要注意的是，在这种情况下，``source_node`` 的类型为 :py:class:`~aiida.orm.nodes.data.folder.FolderData`，因此您必须手动选择要将文件复制到哪台计算机。您可以查看运行 ``verdi computer list`` 的可用计算机，并使用所示标签将其加载到 :py:func:`~aiida.orm.load_computer` 中："

#: ../../source/howto/data.rst:663
msgid ""
"Both when uploading or retrieving, you can copy multiple files by appending "
"them to the list of the ``local_files`` or ``symlink_files`` keys in the "
"instructions input, respectively. It is also possible to copy files from any"
" number of nodes by providing several ``source_node`` s, each with a "
"different ``'node_keyname'``. The target node will always be one (so you can"
" *\"gather\"* files in a single call, but not *\"distribute\"* them)."
msgstr "无论是上传还是检索，您都可以将多个文件分别添加到输入指令中的 ``local_files`` 或 ``symlink_files`` 键列表中，从而复制多个文件。还可以通过提供多个 ``source_node``s(每个都有不同的 ``'node_keyname'``)，从任意数量的 node 中复制文件。目标 node 将始终为一个(因此您可以在一次调用中 *\``gather\``* 文件，但不能 *\``distribute\``* 它们)。"

#: ../../source/howto/faq.rst:5
msgid "Frequently Asked Questions"
msgstr "常见问题"

#: ../../source/howto/faq.rst:7
msgid ""
"If the problem you are facing is not addressed below, please refer to the "
"`Discourse server <https://aiida.discourse.group/>`_. To file a bug report "
"or open a feature request, please `open an issue on Github "
"<https://github.com/aiidateam/aiida-core/issues/new/choose>`_."
msgstr "如果您遇到的问题没有在下面解决，请参阅 `Discourse server <https://aiida.discourse.group/>`_。要提交错误报告或开启功能请求，请联系 `open an issue on Github <https://github.com/aiidateam/aiida-core/issues/new/choose>`_。"

#: ../../source/howto/faq.rst:12
msgid ""
"I have updated the version of AiiDA and now it is no longer working. What "
"should I do?"
msgstr "我更新了 AiiDA 的版本，但现在它不再工作了。我该怎么办？"

#: ../../source/howto/faq.rst:13
msgid ""
"First, make sure that your daemon is not running. You can check this with "
"``verdi daemon status``. If you find that your daemon was actually still "
"running, that is likely the problem, so stop it first using ``verdi daemon "
"stop``. It is very important that each time you want to :ref:`update your "
"AiiDA installation<how-to:installation:update>`, you should *always* first "
"finish all running processes and stop the daemon before doing so. Restart "
"the daemon with ``verdi daemon start``."
msgstr "首先，确保您的守护进程没有运行。可以使用 ``verdi daemon status`` 检查。如果您发现守护进程仍在运行，这很可能就是问题所在，因此请先使用 ``verdi daemon stop`` 停止守护进程。important 每次要 :ref:`update your AiiDA installation<how-to:installation:update>` 时，都应**先结束所有正在运行的进程，并在此之前停止守护进程。使用 ``verdi daemon start`` 重新启动守护进程。"

#: ../../source/howto/faq.rst:21
msgid ""
"I get a :py:class:`~aiida.common.exceptions.MissingEntryPointError` or "
":py:class:`~aiida.common.exceptions.MultipleEntryPointError` exception, "
"saying that a particular entry point cannot be found. How can I fix this?"
msgstr "我收到 :py:class:`~aiida.common.exceptions.MissingEntryPointError` 或 :py:class:`~aiida.common.exceptions.MultipleEntryPointError` 异常，提示无法找到特定的 entry point。如何解决这个问题？"

#: ../../source/howto/faq.rst:22
msgid ""
"Often this is caused by an outdated entry point cache. This can happen for "
"example when you have updated your AiiDA installation or installed a new "
"plugin using ``pip install``. Make sure to also restart all daemons, to "
"ensure that the changes are picked up by the daemons as well."
msgstr "这通常是由过期的 entry point 缓存引起的。例如，当你更新了 AiiDA 安装或使用 ``pip install`` 安装了新插件时，就会发生这种情况。确保同时重启所有守护进程，以确保守护进程也能接收到更改。"

#: ../../source/howto/faq.rst:28
msgid ""
"I have updated the code of a :py:class:`~aiida.engine.WorkChain`, "
":py:class:`~aiida.engine.CalcJob` or whatever other Python code, but the "
"daemon does not seem to pick up the changes?"
msgstr "我更新了 :py:class:`~aiida.engine.WorkChain`、:py:class:`~aiida.engine.CalcJob` 或其他 Python 代码的代码，但守护进程似乎没有接收到这些更改？"

#: ../../source/howto/faq.rst:29
msgid ""
"Each time that you change your code, you should restart the daemon for the "
"changes to take effect. Each daemon worker actually is its own system "
"process with its own Python interpreter instance, and since we don't support"
" automated hot==swapping, the daemon workers will not automatically detect "
"the changes in the code. Simply calling ``verdi daemon restart`` will do the"
" trick."
msgstr "每次更改代码时，都应重新启动守护进程，以使更改生效。每个守护进程工作者实际上都是自己的系统进程，有自己的 Python 解释器实例，由于我们不支持自动热===交换，所以守护进程工作者不会自动检测代码中的更改。只需调用 ``verdi daemon restart`` 即可。"

#: ../../source/howto/faq.rst:35
msgid ""
"I have updated the code of a :py:class:`~aiida.engine.WorkChain`, "
":py:class:`~aiida.engine.CalcJob` or whatever other Python code, but my "
"Python shell instance does not seem to pick up the changes?"
msgstr "我更新了 :py:class:`~aiida.engine.WorkChain`、:py:class:`~aiida.engine.CalcJob` 或其他 Python 代码的代码，但我的 Python shell 实例似乎无法接收这些更改？"

#: ../../source/howto/faq.rst:36
msgid ""
"The ``verdi shell`` is its own Python interpreter and does not automatically"
" detect code changes. Simply reloading your shell will solve the problem."
msgstr "``verdi shell`` 是自己的 Python 解释器，不会自动检测代码更改。只需重新加载 shell 即可解决问题。"

#: ../../source/howto/faq.rst:41
msgid ""
"Why are calculation jobs taking very long to run on remote machines even "
"though the actual computation time should be fast?"
msgstr "为什么计算作业在远程计算机上运行时间很长，而实际计算时间应该很快？"

#: ../../source/howto/faq.rst:42
msgid ""
"First, make sure that the calculation is not actually waiting in the queue "
"of the scheduler, but it is actually running or has already completed. If it"
" then still takes seemingly a lot of time for AiiDA to update your "
"calculations, there are a couple of explanations. First, if you are running "
"many processes, your daemon workers may simply be busy managing other "
"calculations and workflows. If that is not the case, you may be witnessing "
"the effects of the built-in throttling mechanisms of AiiDA's engine. To "
"ensure that the AiiDA daemon does not overload remote computers or their "
"schedulers, there are built-in limits to how often the daemon workers are "
"allowed to open an SSH connection, or poll the scheduler. To determine the "
"minimum transport and job polling interval, use ``verdi computer configure "
"show <COMPUTER>`` and ``computer.get_minimum_job_poll_interval()``, "
"respectively. You can lower these values using:"
msgstr "首先，确保计算不是在调度程序的队列中等待，而是正在运行或已经完成。如果 AiiDA 更新计算仍然需要很多时间，有几种解释。首先，如果你运行了很多进程，你的守护进程可能只是忙于管理其他计算和 workflow。如果不是这样，你可能看到了AiiDA的engine内置节流机制的影响。为了确保 AiiDA 守护进程不会让远程计算机或它们的调度程序超载，对守护进程工作者打开 SSH 连接或轮询调度程序的频率有内置限制。要确定最小传输间隔和作业轮询间隔，请分别使用 ``verdi computer configure show <COMPUTER>`` 和 ``computer.get_minimum_job_poll_interval()``。您可以使用"

#: ../../source/howto/faq.rst:54
msgid "and"
msgstr "和"

#: ../../source/howto/faq.rst:60
msgid ""
"respectively. However, be careful, if you make these intervals too short, "
"the daemon workers may spam the remote machine and/or scheduler, which could"
" have adverse effects on the machine itself or can get your account banned, "
"depending on the policy of the remote machine. An additional note of "
"importance is that each interval is guaranteed to be respected per daemon "
"worker individually, but not as a collective. That is to say, if the safe "
"interval is set to 60 seconds, any single worker is guaranteed to open a "
"connection to that machine at most once every minute, however, if you have "
"multiple active daemon workers, the machine may be accessed more than once "
"per minute."
msgstr "不过要注意，如果间隔时间太短，守护进程工作者可能会向远程机器和/或调度程序发送垃圾邮件，这可能会对机器本身造成不利影响，或导致账户被封。不过要注意，如果间隔时间太短，守护进程工作者可能会向远程机器和/或调度程序发送垃圾邮件，这可能会对机器本身造成不利影响，也可能导致账户被封，具体取决于远程机器的政策。importance 的另一个注意事项是，每个守护进程都会保证遵守每个守护进程的时间间隔，但不会保证遵守所有守护进程的时间间隔。也就是说，如果安全时间间隔设置为 60 秒，则任何单个程序员都能保证每分钟最多打开一次与该机器的连接，但如果有多个活跃的守护进程程序员，则每分钟访问该机器的次数可能会超过一次。"

#: ../../source/howto/faq.rst:68
msgid ""
"Why would a process that runs fine locally raise an exception when submitted"
" to the daemon?"
msgstr "为什么在本地运行正常的进程在提交给守护进程时会出现异常？"

#: ../../source/howto/faq.rst:69
msgid ""
"This is almost always caused by an import issue. To determine exactly what "
"might be going wrong, first :ref:`set the loglevel <intro:increase-logging-"
"verbosity>` to ``DEBUG`` by executing the command:"
msgstr "这几乎总是由 import 问题引起的。要确定到底是什么问题，首先执行 :ref:`set the loglevel <intro:increase-logging-verbosity>` 至 ``DEBUG`` 命令："

#: ../../source/howto/faq.rst:76
msgid ""
"Then restart the daemon with ``verdi daemon restart`` for the changes to "
"take effect. Run the command ``verdi daemon logshow`` in a separate terminal"
" to see the logging output of the daemon and then submit the problematic "
"calculation or workflow again."
msgstr "然后使用 ``verdi daemon restart`` 重启守护进程，使更改生效。在另一个终端运行命令 ``verdi daemon logshow``，查看守护进程的日志输出，然后再次提交有问题的计算或 workflow。"

#: ../../source/howto/faq.rst:79
msgid ""
"If the root cause is indeed due to an import problem, it will probably "
"appear as an ``ImportError`` exception in the daemon log. To solve these "
"issues, make sure that all the Python code that is being run is properly "
"importable, which means that it is part of the `PYTHONPATH "
"<https://docs.python.org/3/using/cmdline.html#envvar-PYTHONPATH>`_. Make "
"sure that the PYTHONPATH is correctly defined automatically when starting "
"your shell, so for example if you are using bash, add it to your ``.bashrc``"
" and completely reset daemon. For example, go to the directory that contains"
" the file where you defined the process and run:"
msgstr "如果根本原因确实是由于 import 问题，则可能会在守护进程日志中显示为 ``ImportError`` 异常。要解决这些问题，请确保正在运行的所有 Python 代码都能正确执行 import，这意味着它们是 `PYTHONPATH <https://docs.python.org/3/using/cmdline.html#envvar-PYTHONPATH>`_ 的一部分。确保在启动 shell 时自动正确定义了 PYTHONPATH，例如，如果您使用的是 bash，请将其添加到 ``.bashrc`` 并完全重置守护进程。例如，进入包含定义进程的文件的目录，然后运行"

#: ../../source/howto/faq.rst:93
msgid "Why is caching not enabled by default?"
msgstr "为什么默认情况下不启用缓存？"

#: ../../source/howto/faq.rst:95
msgid ""
"Caching is designed to work in an unobtrusive way and simply save time and "
"valuable computational resources. However, this design is a double-egded "
"sword, in that a user that might not be aware of this functionality, can be "
"caught off guard by the results of their calculations."
msgstr "缓存的设计目的是以不显眼的方式工作，节省时间和宝贵的计算资源。然而，这种设计是一把双刃剑，因为用户可能没有意识到这一功能，他们的计算结果可能会让用户措手不及。"

#: ../../source/howto/faq.rst:98
msgid ""
"The caching mechanism comes with some limitations and caveats that are "
"important to understand. Refer to the "
":ref:`topics:provenance:caching:limitations` section for more details."
msgstr "缓存机制有一些限制和注意事项，需要 import 理解。详情请参考 :ref:`topics:provenance:caching:limitations` 部分。"

#: ../../source/howto/faq.rst:104
msgid ""
"What happens when an SSH key pair expires for an MFA-enabled remote "
"computer?"
msgstr "启用了 MFA 的远程计算机的 SSH 密钥对过期时会发生什么情况？"

#: ../../source/howto/faq.rst:106
msgid ""
"In some supercomputing centres, Multi-Factor Authentication (MFA) is "
"required to connect to the remote computer. Often, when establishing a "
"connection to such a computer, one needs to generate an SSH key pair with a "
"limited lifetime. This is the case of Swiss National Supercomputing Centre "
"(CSCS), for example."
msgstr "在一些超级计算中心，连接远程计算机需要进行多因素身份验证(MFA)。通常情况下，在建立与此类计算机的连接时，需要生成一个有效期有限的 SSH 密钥对。例如，瑞士国家超级计算中心(CSCS)就是这种情况。"

#: ../../source/howto/faq.rst:110
msgid ""
"When the SSH key pair expires, AiiDA will fail to connect to the remote "
"computer. This will cause all calculations submitted on that computer to "
"pause. To restart them, one needs to generate a new SSH key pair and play "
"the paused processes using ``verdi process play --all``. Typically, this is "
"all one needs to do - AiiDA will re-establish the connection to the computer"
" and will continue following the calculations."
msgstr "当 SSH 密钥对过期时，AiiDA 将无法连接到远程计算机。这将导致在该计算机上提交的所有计算暂停。要重新启动，需要生成一个新的 SSH 密钥对，并使用 ``verdi process play --all`` 播放暂停的进程。通常，这就是我们需要做的--AiiDA会重新建立与计算机的连接，并继续进行计算。"

#: ../../source/howto/index.rst:3
msgid "How-To Guides"
msgstr "操作指南"

#: ../../source/howto/installation.rst:5
msgid "How to manage your installation"
msgstr "如何管理您的安装"

#: ../../source/howto/installation.rst:11
msgid "Managing profiles"
msgstr "管理简介"

#: ../../source/howto/installation.rst:14
msgid "Creating profiles"
msgstr "创建简介"

#: ../../source/howto/installation.rst:15
msgid ""
"Each AiiDA installation can have multiple profiles, each of which can have "
"its own individual database and file repository to store the contents of the"
" :ref:`provenance graph<topics:provenance:concepts>`. Profiles allow you to "
"run multiple projects completely independently from one another with just a "
"single AiiDA installation and at least one profile is required to run AiiDA."
" A new profile can be created using :ref:`verdi "
"quicksetup<reference:command-line:verdi-quicksetup>` or :ref:`verdi "
"setup<reference:command-line:verdi-setup>`, which works similar to the "
"former but gives more control to the user."
msgstr "每个AiiDA安装都可以有多个配置文件，每个配置文件都有自己独立的数据库和文件库来存储 :ref:`provenance graph<topics:provenance:concepts>`的内容。预案让你只需安装一个 AiiDA 就能完全独立地运行多个项目，运行 AiiDA 至少需要一个预案。可以使用 :ref:`verdi quicksetup<reference:command-line:verdi-quicksetup>` 或 :ref:`verdi setup<reference:command-line:verdi-setup>` 创建一个新的配置文件，其工作原理与前者类似，但给予用户更多的控制权。"

#: ../../source/howto/installation.rst:20
msgid "Listing profiles"
msgstr "Listing profiles"

#: ../../source/howto/installation.rst:21
msgid ""
"The :ref:`verdi profile<reference:command-line:verdi-profile>` command line "
"interface provides various commands to manage the profiles of an AiiDA "
"installation. To list the currently configured profiles, use ``verdi profile"
" list``:"
msgstr " :ref:`verdi profile<reference:command-line:verdi-profile>` 命令行界面提供各种命令来管理 AiiDA 安装的配置文件。要列出当前配置文件，使用 ``verdi profile list``："

#: ../../source/howto/installation.rst:30
msgid ""
"In this particular example, there are two configured profiles, ``project-"
"one`` and ``project-two``. The first one is highlighted and marked with a "
"``*`` symbol, meaning it is the default profile. A profile being the default"
" means simply that any ``verdi`` command will always be executed for that "
"profile. You can :ref:`change the profile on a per-call "
"basis<topics:cli:profile>` with the ``--p/--profile`` option. To change the "
"default profile use ``verdi profile setdefault PROFILE``."
msgstr "在此示例中，有两个配置文件：``project-one`` 和 ``project-two``。第一个配置文件高亮显示并标有 ``*`` 符号，这意味着它是默认配置文件。默认配置文件的含义很简单，即任何 ``verdi`` 命令都将在该配置文件下执行。可以使用 ``--p/--profile`` 选项来执行 :ref:`change the profile on a per-call basis<topics:cli:profile>`。要更改默认配置文件，请使用 ``verdi profile setdefault PROFILE``。"

#: ../../source/howto/installation.rst:37
msgid "Showing profiles"
msgstr "显示简介"

#: ../../source/howto/installation.rst:38
msgid ""
"Each profile defines various parameters, such as the location of the file "
"repository on the file system and the connection parameters for the "
"database. To display these parameters, use ``verdi profile show``:"
msgstr "每个配置文件都定义了各种参数，如文件系统中文件存储库的位置和数据库的连接参数。要显示这些参数，请使用 ``verdi profile show``："

#: ../../source/howto/installation.rst:66
msgid ""
"By default, the parameters of the default profile are shown, but one can "
"pass the profile name of another, e.g., ``verdi profile show project-two`` "
"to change that."
msgstr "默认情况下，会显示默认配置文件的参数，但也可以通过另一个配置文件的名称(如 ``verdi profile show project-two``)来更改。"

#: ../../source/howto/installation.rst:69
msgid "Deleting profiles"
msgstr "删除个人资料"

#: ../../source/howto/installation.rst:70
msgid ""
"A profile can be deleted using the ``verdi profile delete`` command. By "
"default, deleting a profile will also delete its file repository and the "
"database. This behavior can be changed using the ``--skip-repository`` and "
"``--skip-db`` options."
msgstr "可以使用 ``verdi profile delete`` 命令删除配置文件。默认情况下，删除配置文件也会删除其文件库和数据库。可以使用 ``--skip-repository`` 和 ``--skip-db`` 选项更改这一行为。"

#: ../../source/howto/installation.rst:76
msgid ""
"In order to delete the database, the system user needs to have the required "
"rights, which is not always guaranteed depending on the system. In such "
"cases, the database deletion may fail and the user will have to perform the "
"deletion manually through PostgreSQL."
msgstr "要删除数据库，系统用户需要拥有所需的权限，但这并不总是有保证的，这取决于系统。在这种情况下，数据库删除可能会失败，用户必须通过 PostgreSQL 手动执行删除操作。"

#: ../../source/howto/installation.rst:83
msgid "Configuring your installation"
msgstr "配置安装"

#: ../../source/howto/installation.rst:88
msgid "Activating tab-completion"
msgstr "激活选项卡补全功能"

#: ../../source/howto/installation.rst:89
msgid ""
"The ``verdi`` command line interface has many commands and parameters, which"
" can be tab-completed to simplify its use. To enable tab-completion, the "
"following shell command should be executed (depending on the shell you use):"
msgstr "``verdi`` 命令行界面有许多命令和参数，可以用制表符完成，以简化使用。要启用制表符完成功能，应执行以下 shell 命令(取决于您使用的 shell)："

#: ../../source/howto/installation.rst:92
msgid ""
"Enable tab-completion for ``verdi`` one of the following supported shells"
msgstr "为 ``verdi`` 启用以下支持的外壳之一的制表符完成功能"

#: ../../source/howto/installation.rst:0
msgid "bash"
msgstr "敲击"

#: ../../source/howto/installation.rst:0
msgid "zsh"
msgstr "zsh"

#: ../../source/howto/installation.rst:0
msgid "fish"
msgstr "鱼类"

#: ../../source/howto/installation.rst:115
msgid ""
"Place this command in your shell or virtual environment activation script to"
" automatically enable tab completion when opening a new shell or activating "
"an environment. This file is shell specific, but likely one of the "
"following:"
msgstr "将此命令放在 shell 或虚拟环境激活脚本中，可在打开新 shell 或激活环境时自动启用制表符补全。该文件与 shell 有关，但很可能是以下文件之一："

#: ../../source/howto/installation.rst:118
msgid ""
"the startup file of your shell (``.bashrc``, ``.zsh``, ...), if aiida is "
"installed system-wide"
msgstr "shell 的启动文件(``.bashrc``、``.zsh``......)，如果 aiida 是在整个系统中安装的"

#: ../../source/howto/installation.rst:119
msgid ""
"the `activators "
"<https://virtualenv.pypa.io/en/latest/user_guide.html#activators>`_ of your "
"virtual environment"
msgstr "虚拟环境的 `activators <https://virtualenv.pypa.io/en/latest/user_guide.html#activators>`_"

#: ../../source/howto/installation.rst:120
msgid ""
"a `startup file <https://conda.io/projects/conda/en/latest/user-"
"guide/tasks/manage-environments.html#saving-environment-variables>`_ for "
"your conda environment"
msgstr "为您的 conda 环境提供一个 `startup file <https://conda.io/projects/conda/en/latest/user-guide/tasks/manage-environments.html#saving-environment-variables>`_"

#: ../../source/howto/installation.rst:125
msgid ""
"After you have added the line to the start up script, make sure to restart "
"the terminal or source the script for the changes to take effect."
msgstr "将该行添加到启动脚本后，确保重启终端或源代码脚本，以使更改生效。"

#: ../../source/howto/installation.rst:131
msgid "Configuring profile options"
msgstr "配置配置文件选项"

#: ../../source/howto/installation.rst:133
msgid ""
"AiiDA provides various configurational options for profiles, which can be "
"controlled with the :ref:`verdi config<reference:command-line:verdi-config>`"
" command."
msgstr "AiiDA 为配置文件提供了多种配置选项，可通过 :ref:`verdi config<reference:command-line:verdi-config>` 命令进行控制。"

#: ../../source/howto/installation.rst:135
msgid "To view all configuration options set for the current profile:"
msgstr "查看为当前配置文件设置的所有配置选项："

#: ../../source/howto/installation.rst:168
msgid ""
"Configuration option values are taken, in order of priority, from either the"
" profile specific setting, the global setting (applies to all profiles), or "
"the default value."
msgstr "配置选项值按优先顺序取自特定配置文件设置、全局设置(适用于所有配置文件)或默认值。"

#: ../../source/howto/installation.rst:170
msgid "You can also filter by a prefix:"
msgstr "您还可以通过前缀进行筛选："

#: ../../source/howto/installation.rst:180
msgid ""
"To show the full information for a configuration option or get its current "
"value:"
msgstr "显示配置选项的完整信息或获取其当前值："

#: ../../source/howto/installation.rst:197
msgid "You can also retrieve the value *via* the API:"
msgstr "您也可以通过*应用程序接口检索该值："

#: ../../source/howto/installation.rst:205
msgid "To set a value, at the profile or global level:"
msgstr "在配置文件或全局级别设置值："

#: ../../source/howto/installation.rst:228
msgid ""
"By default any option set through ``verdi config`` will be applied to the "
"current default profile. To change the profile you can use the :ref:`profile"
" option<topics:cli:profile>`."
msgstr "默认情况下，通过 ``verdi config`` 设置的任何选项都将应用于当前默认配置文件。要更改配置文件，可以使用 :ref:`profile option<topics:cli:profile>`。"

#: ../../source/howto/installation.rst:231
msgid "Similarly to unset a value:"
msgstr "类似地，取消设置值："

#: ../../source/howto/installation.rst:254
msgid ""
"Changes that affect the daemon (e.g. ``logging.aiida_loglevel``) will only "
"take affect after restarting the daemon."
msgstr "影响守护进程的更改(如 ``logging.aiida_loglevel``)只有在重启守护进程后才会生效。"

#: ../../source/howto/installation.rst:256
msgid ":ref:`How-to configure caching <how-to:run-codes:caching>`"
msgstr " :ref:`How-to configure caching <how-to:run-codes:caching>`"

#: ../../source/howto/installation.rst:262
msgid "Controlling warnings"
msgstr "控制警告"

#: ../../source/howto/installation.rst:264
msgid ""
"AiiDA may emit warnings for a variety of reasons, for example, warnings when"
" a deprecated part of the code is used. These warnings are on by default as "
"they provide the user with important information. The warnings can be turned"
" off using the ``warnings.showdeprecations`` config option, for example:"
msgstr "AiiDA 可能会因为各种原因发出警告，例如，当使用了代码的废弃部分时发出警告。这些警告默认是开启的，因为它们为用户提供了 important 信息。例如，可以使用 ``warnings.showdeprecations`` 配置选项关闭这些警告："

#: ../../source/howto/installation.rst:274
msgid ""
"The command above changes the option for the current profile. However, "
"certain warnings are emitted before a profile can be loaded, for example, "
"when certain modules are imported. To also silence these warnings, apply the"
" option globally:"
msgstr "上述命令更改了当前配置文件的选项。不过，在加载配置文件之前会发出某些警告，例如当某些模块被 imported 时。要同时消除这些警告，可全局应用该选项："

#: ../../source/howto/installation.rst:282
msgid ""
"In addition to the config option, AiiDA also provides the dedicated "
"environment variable ``AIIDA_WARN_v{version}`` for deprecation warnings. "
"Here ``{version}`` is the version number in which the deprecated code will "
"be removed, e.g., ``AIIDA_WARN_v3``. This environment variable can be used "
"to enable deprecation warnings even if ``warnings.showdeprecations`` is "
"turned off. This can be useful to temporarily enable deprecation warnings "
"for a single command, e.g.:"
msgstr "除了配置选项，AiiDA 也提供了专用的环境变量 ``AIIDA_WARN_v{version}`` 用于弃用警告。这里的 ``{version}`` 是版本号，例如 ``AIIDA_WARN_v3``。即使关闭了 ``warnings.showdeprecations``，也可以使用此环境变量启用弃用警告。这对于临时启用单个命令的弃用警告非常有用，例如"

#: ../../source/howto/installation.rst:295
msgid "Isolating multiple instances"
msgstr "隔离多个实例"

#: ../../source/howto/installation.rst:296
msgid ""
"An AiiDA instance is defined as the installed source code plus the "
"configuration folder that stores the configuration files with all the "
"configured profiles. It is possible to run multiple AiiDA instances on a "
"single machine, simply by isolating the code and configuration in a virtual "
"environment."
msgstr "AiiDA 实例的定义是已安装的源代码，加上储存所有配置文件的配置文件夹。只需在虚拟环境中隔离代码和配置，就可以在一台机器上运行多个 AiiDA 实例。"

#: ../../source/howto/installation.rst:299
msgid ""
"To isolate the code, make sure to install AiiDA into a virtual environment, "
"e.g., with conda or venv, as described :ref:`here "
"<intro:get_started:setup>`. Whenever you activate this particular "
"environment, you will be running the particular version of AiiDA (and all "
"the plugins) that you installed specifically for it."
msgstr "为了隔离代码，请确保将 AiiDA 安装到虚拟环境中，例如使用 conda 或 venv，如 :ref:`here <intro:get_started:setup>` 所述。每当你激活这个特定的环境，你将运行你专门为它安装的特定版本的 AiiDA (和所有插件)。"

#: ../../source/howto/installation.rst:302
msgid ""
"This is separate from the configuration of AiiDA, which is stored in the "
"configuration directory which is always named ``.aiida`` and by default is "
"stored in the home directory. Therefore, the default path of the "
"configuration directory is ``~/.aiida``. By default, each AiiDA instance "
"(each installation) will store associated profiles in this folder. A best "
"practice is to always separate the profiles together with the code to which "
"they belong. The typical approach is to place the configuration folder in "
"the virtual environment itself and have it automatically selected whenever "
"the environment is activated."
msgstr "这与 AiiDA 的配置是分开的，AiiDA 的配置保存在配置目录中，配置目录总是命名为 ``.aiida``，默认保存在主目录中。因此，配置目录的默认路径是 ``~/.aiida``。默认情况下，每个 AiiDA 实例(每个安装)都会在这个文件夹中存储相关的配置文件。最好的做法是将配置文件与所属代码分开。典型的方法是将配置文件夹放在虚拟环境中，并在环境激活时自动选择。"

#: ../../source/howto/installation.rst:308
msgid ""
"The location of the AiiDA configuration folder can be controlled with the "
"``AIIDA_PATH`` environment variable. This allows us to change the "
"configuration folder automatically, by adding the following lines to the "
"activation script of a virtual environment. For example, if the path of your"
" virtual environment is ``/home/user/.virtualenvs/aiida``, add the following"
" line:"
msgstr "AiiDA 配置文件夹的位置可以通过 ``AIIDA_PATH`` 环境变量来控制。通过在虚拟环境的激活脚本中添加以下行，我们可以自动更改配置文件夹。例如，如果你的虚拟环境路径是 ``/home/user/.virtualenvs/aiida``，添加以下行："

#: ../../source/howto/installation.rst:316
msgid ""
"Make sure to reactivate the virtual environment, if it was already active, "
"for the changes to take effect."
msgstr "如果虚拟环境已经激活，确保重新激活虚拟环境，以使更改生效。"

#: ../../source/howto/installation.rst:320
msgid ""
"For ``conda``, create a directory structure ``etc/conda/activate.d`` in the "
"root folder of your conda environment (e.g. "
"``/home/user/miniconda/envs/aiida``), and place a file ``aiida-init.sh`` in "
"that folder which exports the ``AIIDA_PATH``."
msgstr "对于 ``conda``，在 conda 环境的根文件夹中创建 ``etc/conda/activate.d`` 目录结构(例如 ``/home/user/miniconda/envs/aiida``)，并在该文件夹中放置导出 ``AIIDA_PATH`` 的文件 ``aiida-init.sh``。"

#: ../../source/howto/installation.rst:322
msgid ""
"You can test that everything works by first echoing the environment variable"
" with ``echo $AIIDA_PATH`` to confirm it prints the correct path. Finally, "
"you can check that AiiDA know also properly realizes the new location for "
"the configuration folder by calling ``verdi profile list``. This should "
"display the current location of the configuration directory:"
msgstr "你可以先用 ``echo $AIIDA_PATH`` 来呼应环境变量，以确认它打印了正确的路径。最后，你可以通过调用 ``verdi profile list`` 来检查 AiiDA 是否知道配置文件夹的新位置。这会显示配置目录的当前位置："

#: ../../source/howto/installation.rst:331
msgid ""
"The second line you will only see if you haven't yet setup a profile for "
"this AiiDA instance. For information on setting up a profile, refer to "
":ref:`creating profiles<how-to:installation:profile>`."
msgstr "第二行只有在你还没有为这个 AiiDA 实例设置配置文件时才会看到。有关设置配置文件的信息，请参阅 :ref:`creating profiles<how-to:installation:profile>`。"

#: ../../source/howto/installation.rst:334
msgid ""
"Besides a single path, the value of ``AIIDA_PATH`` can also be a colon-"
"separated list of paths. AiiDA will go through each of the paths and check "
"whether they contain a configuration directory, i.e., a folder with the name"
" ``.aiida``. The first configuration directory that is encountered will be "
"used as the configuration directory. If no configuration directory is found,"
" one will be created in the last path that was considered. For example, the "
"directory structure in your home folder ``~/`` might look like this::"
msgstr "除了单一路径，313120F` 的值也可以是以冒号分隔的路径列表。AiiDA 会检查每个路径是否包含配置目录，即名称为 ``.aiida`` 的文件夹。遇到的第一个配置目录将被用作配置目录。如果没有找到配置目录，则会在最后一个路径中创建一个。例如，您的主文件夹 ``~/`` 中的目录结构可能如下所示：："

#: ../../source/howto/installation.rst:346
msgid ""
"If you leave the ``AIIDA_PATH`` variable unset, the default location "
"``~/.aiida`` will be used. However, if you set:"
msgstr "如果不设置 ``AIIDA_PATH`` 变量，将使用默认位置 ``~/.aiida``。但是，如果设置"

#: ../../source/howto/installation.rst:353
msgid "the configuration directory ``~/project_a/.aiida`` will be used."
msgstr "将使用配置目录 ``~/project_a/.aiida``。"

#: ../../source/howto/installation.rst:357
msgid ""
"If there was no ``.aiida`` directory in ``~/project_a``, AiiDA would have "
"created it for you, so make sure to set the ``AIIDA_PATH`` correctly."
msgstr "如果 ``~/project_a`` 中没有 ``.aiida`` 目录，AiiDA 会为你创建，所以请确保正确设置了 ``AIIDA_PATH``。"

#: ../../source/howto/installation.rst:363
msgid "Daemon as a service"
msgstr "作为服务的守护进程"

#: ../../source/howto/installation.rst:365
msgid ""
"The daemon can be set up as a system service, such that it automatically "
"starts at system startup. How to do this, is operating system specific. For "
"Ubuntu, here is `a template for the service file <https://github.com/marvel-"
"nccr/ansible-role-"
"aiida/blob/c709088dff74d1e1ae4d8379e740aba35fb2ef97/templates/aiida-"
"daemon%40.service>`_ and `ansible instructions to install the service "
"<https://github.com/marvel-nccr/ansible-role-"
"aiida/blob/c709088dff74d1e1ae4d8379e740aba35fb2ef97/tasks/aiida-"
"daemon.yml>`_."
msgstr "可以将守护进程设置为系统服务，使其在系统启动时自动启动。具体如何操作取决于操作系统。对于 Ubuntu，这里有 `a template for the service file <https://github.com/marvel-nccr/ansible-role-aiida/blob/c709088dff74d1e1ae4d8379e740aba35fb2ef97/templates/aiida-daemon%40.service>`_ 和 `ansible instructions to install the service <https://github.com/marvel-nccr/ansible-role-aiida/blob/c709088dff74d1e1ae4d8379e740aba35fb2ef97/tasks/aiida-daemon.yml>`_。"

#: ../../source/howto/installation.rst:373
msgid "Tuning performance"
msgstr "调整性能"

#: ../../source/howto/installation.rst:375
msgid ""
"AiiDA supports running hundreds of thousands of calculations and graphs with"
" millions of nodes. However, optimal performance at that scale can require "
"tweaking the AiiDA configuration to balance the CPU and disk load."
msgstr "AiiDA 支持使用数百万个 node 运行数十万次计算和图形。然而，要在这种规模下获得最佳性能，需要调整 AiiDA 配置，以平衡 CPU 和磁盘负载。"

#: ../../source/howto/installation.rst:378
msgid ""
"Below, we share a few practical tips for assessing and tuning AiiDA "
"performance. Further in-depth information is available in the dedicated "
":ref:`topic on performance<topics:performance>`."
msgstr "下面，我们分享一些评估和调整 AiiDA 性能的实用技巧。更多详细信息，请参阅 :ref:`topic on performance<topics:performance>`。"

#: ../../source/howto/installation.rst:0
msgid "Benchmark workflow engine performance"
msgstr "基准 workflow engine 性能"

#: ../../source/howto/installation.rst:383
msgid ""
"Download the :download:`benchmark script "
"<include/scripts/performance_benchmark_base.py>` :fa:`download`, and run it "
"in your AiiDA environment."
msgstr "下载 :download:`benchmark script <include/scripts/performance_benchmark_base.py>` :fa:`download` 并在 AiiDA 环境中运行。"

#: ../../source/howto/installation.rst:402
msgid ""
"The output above was generated on an AMD Ryzen 5 3600 6-Core processor (3.6 "
"GHz, 4.2 GHz turbo boost) using AiiDA v2.2.0, and RabbitMQ and PostgreSQL "
"running on the same machine. Here, 100 ``ArithmeticAddCalculation`` "
"processes completed in ~25s, corresponding to 0.25 seconds per process."
msgstr "上述输出在 AMD Ryzen 5 3600 6 核处理器(3.6 GHz，4.2 GHz 涡轮增压)上生成，使用 AiiDA v2.2.0，RabbitMQ 和 PostgreSQL 在同一台机器上运行。在这里，100 个 ``ArithmeticAddCalculation`` 进程在 ~25 秒内完成，相当于每个进程 0.25 秒。"

#: ../../source/howto/installation.rst:405
msgid ""
"If you observe a significantly higher runtime, you may want to check whether"
" any relevant component (CPU, disk, postgresql, rabbitmq) is congested."
msgstr "如果观察到运行时间明显增加，您可能需要检查是否有任何相关组件(CPU、磁盘、postgresql、rabbitmq)出现拥塞。"

#: ../../source/howto/installation.rst:0
msgid "Increase the number of daemon workers"
msgstr "增加守护进程工作者的数量"

#: ../../source/howto/installation.rst:409
msgid ""
"By default, the AiiDA daemon only uses a single worker, i.e. a single "
"operating system process. If ``verdi daemon status`` shows the daemon worker"
" constantly at high CPU usage, you can use ``verdi daemon incr X`` to add "
"``X`` parallel daemon workers."
msgstr "默认情况下，AiiDA 守护进程只使用单个 Worker，即单个操作系统进程。如果 ``verdi daemon status`` 显示守护进程工作者的 CPU 使用率一直很高，可以使用 ``verdi daemon incr X`` 添加 ``X`` 并行守护进程工作者。"

#: ../../source/howto/installation.rst:412
msgid ""
"Keep in mind that other processes need to run on your computer (e.g. "
"rabbitmq, the PostgreSQL database, ...), i.e. it's a good idea to stop "
"increasing the number of workers before you reach the number of cores of "
"your CPU."
msgstr "请记住，您的计算机上还需要运行其他进程(如 rabbitmq、PostgreSQL 数据库......)，因此在达到 CPU 核心数之前，最好停止增加 Worker 的数量。"

#: ../../source/howto/installation.rst:414
msgid "To make the change permanent, set ::"
msgstr "要使更改永久有效，请设置 :："

#: ../../source/howto/installation.rst:0
msgid "Increase the number of daemon worker slots"
msgstr "增加守护进程工作者插槽数量"

#: ../../source/howto/installation.rst:421
msgid ""
"Each daemon worker accepts only a limited number of tasks at a time. If "
"``verdi daemon status`` constantly warns about a high percentage of the "
"available daemon worker slots being used, you can increase the number of "
"tasks handled by each daemon worker (thus increasing the workload per "
"worker). Increasing it to 1000 should typically work."
msgstr "每个守护进程处理程序一次只能接受有限数量的任务。如果 ``verdi daemon status`` 经常警告说守护进程程序员可用槽位的使用比例过高，可以增加每个守护进程程序员处理的任务数(从而增加每个程序员的工作量)。将其增加到 1000 通常会有效。"

#: ../../source/howto/installation.rst:425
msgid "Set the corresponding config variable and restart the daemon ::"
msgstr "设置相应的配置变量并重启守护进程 :："

#: ../../source/howto/installation.rst:0
msgid "Prevent your operating system from indexing the file repository."
msgstr "防止操作系统索引文件库。"

#: ../../source/howto/installation.rst:432
msgid ""
"Many Linux distributions include the ``locate`` command to quickly find "
"files and folders, and run a daily cron job ``updatedb.mlocate`` to create "
"the corresponding index. A large file repository can take a long time to "
"index, up to the point where the hard drive is constantly indexing."
msgstr "许多 Linux 发行版都包含 ``locate`` 命令，用于快速查找文件和文件夹，并运行每日 cron 作业 ``updatedb.mlocate`` 创建相应的索引。一个大型文件库可能需要很长时间才能建立索引，甚至需要硬盘不断建立索引。"

#: ../../source/howto/installation.rst:435
msgid ""
"In order to exclude the repository folder from indexing, add its path to the"
" ``PRUNEPATH`` variable in the ``/etc/updatedb.conf`` configuration file "
"(use ``sudo``)."
msgstr "为了将版本库文件夹排除在索引之外，请将其路径添加到 ``/etc/updatedb.conf`` 配置文件的 ``PRUNEPATH`` 变量中(使用 ``sudo``)。"

#: ../../source/howto/installation.rst:0
msgid ""
"Move the Postgresql database to a fast disk (SSD), ideally on a large "
"partition."
msgstr "将 Postgresql 数据库移到快速磁盘(固态硬盘)上，最好是大分区。"

#: ../../source/howto/installation.rst:439
msgid ""
"Stop the AiiDA daemon and :ref:`back up your database <how-"
"to:installation:backup>`."
msgstr "停止 AiiDA 守护进程和 :ref:`back up your database <how-to:installation:backup>`。"

#: ../../source/howto/installation.rst:441
msgid ""
"Find the data directory of your postgres installation (something like "
"``/var/lib/postgresql/9.6/main``, ``/scratch/postgres/9.6/main``, ...)."
msgstr "找到 postgres 安装的数据目录(例如 ``/var/lib/postgresql/9.6/main``、``/scratch/postgres/9.6/main``......)。"

#: ../../source/howto/installation.rst:443
msgid ""
"The best way is to become the postgres UNIX user and enter the postgres "
"shell::"
msgstr "最好的方法是成为 postgres UNIX 用户，并输入 postgres shell：："

#: ../../source/howto/installation.rst:449
msgid ""
"If you are unable to enter the postgres shell, try looking for the "
"``data_directory`` variable in a file "
"``/etc/postgresql/9.6/main/postgresql.conf`` or similar."
msgstr "如果无法进入 postgres shell，请尝试在文件 ``/etc/postgresql/9.6/main/postgresql.conf`` 或类似文件中查找 ``data_directory`` 变量。"

#: ../../source/howto/installation.rst:451
msgid "Stop the postgres database service::"
msgstr "停止 postgres 数据库服务：："

#: ../../source/howto/installation.rst:455
msgid ""
"Copy all files and folders from the postgres ``data_directory`` to the new "
"location::"
msgstr "将 postgres ``data_directory`` 中的所有文件和文件夹复制到新位置：："

#: ../../source/howto/installation.rst:477
msgid ""
"Point the ``data_directory`` variable in your postgres configuration file "
"(e.g. ``/etc/postgresql/9.6/main/postgresql.conf``) to the new directory."
msgstr "将 postgres 配置文件中的 ``data_directory`` 变量(如 ``/etc/postgresql/9.6/main/postgresql.conf``)指向新目录。"

#: ../../source/howto/installation.rst:479
msgid "Restart the database daemon::"
msgstr "重启数据库守护进程：："

#: ../../source/howto/installation.rst:483
msgid "Finally, check that the data directory has indeed changed::"
msgstr "最后，检查数据目录是否已更改：："

#: ../../source/howto/installation.rst:489
msgid ""
"and try a simple AiiDA query with the new database. If everything went fine,"
" you can delete the old database location."
msgstr "并尝试用新数据库进行简单的 AiiDA 查询。如果一切顺利，就可以删除旧数据库的位置。"

#: ../../source/howto/installation.rst:492
msgid ""
"If you're still encountering performance issues, the following tips can help"
" with pinpointing performance bottlenecks."
msgstr "如果您仍然遇到性能问题，以下提示可以帮助您找出性能瓶颈。"

#: ../../source/howto/installation.rst:0
msgid "Analyze the RabbitMQ message rate"
msgstr "分析 RabbitMQ 消息速率"

#: ../../source/howto/installation.rst:496
msgid ""
"If you're observing slow performance of the AiiDA engine, the `RabbitMQ "
"management plugin <https://www.rabbitmq.com/management.html>`_ provides an "
"intuitive dashboard that lets you monitor the message rate and check on what"
" the AiiDA engine is up to."
msgstr "如果你观察到 AiiDA engine 性能缓慢，`RabbitMQ management plugin <https://www.rabbitmq.com/management.html>`_ 提供了一个直观的仪表板，让你监控信息速率，检查 AiiDA engine 的运行情况。"

#: ../../source/howto/installation.rst:498
msgid "Enable the management plugin via something like::"
msgstr "通过以下方式启用管理插件：："

#: ../../source/howto/installation.rst:502
msgid ""
"Then, navigate to http://localhost:15672/ and log in with "
"``guest``/``guest``."
msgstr "然后，导航到 http://localhost:15672/，用 ``guest``/``guest`` 登录。"

#: ../../source/howto/installation.rst:508
msgid "Updating your installation"
msgstr "更新安装"

#: ../../source/howto/installation.rst:510
msgid ""
"Whenever updating your AiiDA installation, make sure you follow these "
"instructions **very carefully**, even when merely upgrading the patch "
"version! Failing to do so, may leave your installation in a broken state, or"
" worse may even damage your data, potentially irreparably."
msgstr "无论何时更新你的AiiDA安装，请务必仔细**这些说明，即使只是升级补丁版本！如果不这样做，可能会使你的安装处于损坏状态，更有甚者可能会损坏你的数据，可能无法挽回。"

#: ../../source/howto/installation.rst:513
msgid "Activate the Python environment where AiiDA is installed."
msgstr "激活安装 AiiDA 的 Python 环境。"

#: ../../source/howto/installation.rst:514
msgid "Finish all running processes."
msgstr "结束所有正在运行的进程。"

#: ../../source/howto/installation.rst:515
msgid ""
"All finished processes will be automatically migrated, but it is not "
"possible to resume unfinished processes."
msgstr "所有已完成的进程都将自动迁移，但无法恢复未完成的进程。"

#: ../../source/howto/installation.rst:516
msgid "Stop the daemon using ``verdi daemon stop``."
msgstr "使用 ``verdi daemon stop`` 停止守护进程。"

#: ../../source/howto/installation.rst:517
msgid ""
":ref:`Create a backup of your database and repository<how-"
"to:installation:backup>`."
msgstr " :ref:`Create a backup of your database and repository<how-to:installation:backup>`。"

#: ../../source/howto/installation.rst:521
msgid ""
"Once you have migrated your database, you can no longer go back to an older "
"version of ``aiida-core`` (unless you restore your database and repository "
"from a backup)."
msgstr "一旦迁移了数据库，就不能再返回到旧版本的 ``aiida-core`` (除非从备份中恢复数据库和版本库)。"

#: ../../source/howto/installation.rst:523
msgid "Update your ``aiida-core`` installation."
msgstr "更新您的 ``aiida-core`` 安装。"

#: ../../source/howto/installation.rst:525
msgid ""
"If you have installed AiiDA through ``conda`` simply run: ``conda update "
"aiida-core``."
msgstr "如果通过 ``conda`` 安装了 AiiDA，只需运行：``conda update aiida-core``."

#: ../../source/howto/installation.rst:526
msgid ""
"If you have installed AiiDA through ``pip`` simply run: ``pip install "
"--upgrade aiida-core``."
msgstr "如果您通过 ``pip`` 安装了 AiiDA，只需运行：``pip install --upgrade aiida-core``."

#: ../../source/howto/installation.rst:527
msgid ""
"If you have installed from the git repository using ``pip install -e .``, "
"first delete all the ``.pyc`` files (``find . -name \"*.pyc\" -delete``) "
"before updating your branch with ``git pull``."
msgstr "如果使用 ``pip install -e .`` 从 git 代码库安装，请先删除所有 ``.pyc`` 文件(``find . -name \``*.pyc\`` -delete``)，然后再使用 ``git pull`` 更新分支。"

#: ../../source/howto/installation.rst:530
msgid ""
"Migrate your database with ``verdi -p <profile_name> storage migrate``."
msgstr "使用 ``verdi -p <profile_name> storage migrate`` 迁移数据库。"

#: ../../source/howto/installation.rst:530
msgid ""
"Depending on the size of your database and the number of migrations to "
"perform, data migration can take time, so please be patient."
msgstr "根据数据库的大小和需要执行迁移的次数，数据迁移可能需要一定的时间，请耐心等待。"

#: ../../source/howto/installation.rst:532
msgid ""
"After the database migration finishes, you will be able to continue working "
"with your existing data."
msgstr "数据库迁移完成后，您可以继续使用现有数据。"

#: ../../source/howto/installation.rst:535
msgid ""
"If the update involved a change in the major version number of ``aiida-"
"core``, expect backwards incompatible changes and check whether you also "
"need to update installed plugin packages."
msgstr "如果更新涉及主要版本号 ``aiida-core`` 的更改，则应考虑向后不兼容的更改，并检查是否还需要更新已安装的插件包。"

#: ../../source/howto/installation.rst:538
msgid "Updating from 0.x.* to 1.*"
msgstr "从 0.x.* 更新到 1.*"

#: ../../source/howto/installation.rst:539
msgid ""
"`Additional instructions on how to migrate from 0.12.x versions "
"<https://aiida.readthedocs.io/projects/aiida-"
"core/en/v1.2.1/install/updating_installation.html#updating-"
"from-0-12-to-1>`_."
msgstr "`Additional instructions on how to migrate from 0.12.x versions <https://aiida.readthedocs.io/projects/aiida-core/en/v1.2.1/install/updating_installation.html#updating-from-0-12-to-1>`_."

#: ../../source/howto/installation.rst:540
msgid ""
"`Additional instructions on how to migrate from versions 0.4 -- 0.11 "
"<https://aiida.readthedocs.io/projects/aiida-"
"core/en/v1.2.1/install/updating_installation.html#older-versions>`_."
msgstr "`Additional instructions on how to migrate from versions 0.4 -- 0.11 <https://aiida.readthedocs.io/projects/aiida-core/en/v1.2.1/install/updating_installation.html#older-versions>`_."

#: ../../source/howto/installation.rst:541
msgid ""
"For a list of breaking changes between the 0.x and the 1.x series of AiiDA, "
"`see here <https://aiida.readthedocs.io/projects/aiida-"
"core/en/v1.2.1/install/updating_installation.html#breaking-changes-"
"from-0-12-to-1>`_."
msgstr "有关 AiiDA 0.x 和 1.x 系列之间的重大变更列表，请参见 `see here <https://aiida.readthedocs.io/projects/aiida-core/en/v1.2.1/install/updating_installation.html#breaking-changes-from-0-12-to-1>`_。"

#: ../../source/howto/installation.rst:544
msgid "Updating from 1.* to 2.*"
msgstr "从 1.* 更新到 2.*"

#: ../../source/howto/installation.rst:546
msgid "See the :doc:`../reference/_changelog` for a list of breaking changes."
msgstr "请参阅 :doc:`../reference/_changelog` 以获取更改列表。"

#: ../../source/howto/installation.rst:551
msgid "Backing up your installation"
msgstr "备份安装"

#: ../../source/howto/installation.rst:553
msgid ""
"A full backup of an AiiDA instance and AiiDA managed data requires a backup "
"of:"
msgstr "完整备份 AiiDA 实例和 AiiDA 管理数据需要备份以下内容："

#: ../../source/howto/installation.rst:555
msgid ""
"the AiiDA configuration folder, which is named ``.aiida``. The location of "
"the folder is shown in the output of ``verdi status``. This folder contains,"
" among other things, the ``config.json`` configuration file and log files."
msgstr "AiiDA 配置文件夹，文件夹名为 ``.aiida``。文件夹的位置显示在 ``verdi status`` 的输出中。该文件夹包含 ``config.json`` 配置文件和日志文件。"

#: ../../source/howto/installation.rst:559
msgid ""
"the data stored for each profile. Where the data is stored, depends on the "
"storage backend used by each profile."
msgstr "为每个配置文件存储的数据。数据存储在哪里，取决于每个配置文件使用的存储后端。"

#: ../../source/howto/installation.rst:562
#: ../../source/howto/installation.rst:620
msgid ""
"The panels below provide instructions for storage backends provided by "
"``aiida-core``. To determine what storage backend a profile uses, call "
"``verdi profile show``."
msgstr "下面的面板为 ``aiida-core`` 提供的存储后端提供了说明。要确定配置文件使用的存储后端，请调用 ``verdi profile show``。"

#: ../../source/howto/installation.rst:565
msgid ""
"Before creating a backup, it is recommended to run ``verdi storage "
"maintain``. This will optimize the storage which can significantly reduce "
"the time required to create the backup. For optimal results, run ``verdi "
"storage maintain --full``. Note that this requires the profile to not be in "
"use by any other process."
msgstr "创建备份前，建议运行 ``verdi storage maintain``。这将优化存储，从而大大减少创建备份所需的时间。要获得最佳效果，请运行 ``verdi storage maintain --full``。请注意，这要求配置文件未被任何其他进程使用。"

#: ../../source/howto/installation.rst:0
msgid "psql_dos"
msgstr "psql_dos"

#: ../../source/howto/installation.rst:574
msgid ""
"The ``psql_dos`` storage backend is the default backend for AiiDA. It stores"
" its data in a PostgreSQL database and a file repository on the local "
"filesystem. To fully backup the data stored for a profile, you should backup"
" the associated database and file repository."
msgstr "``psql_dos`` 存储后端是 AiiDA 的默认后端。它将数据存储在 PostgreSQL 数据库和本地文件系统的文件库中。要完全备份一个配置文件的数据，你应该备份相关的数据库和文件库。"

#: ../../source/howto/installation.rst:578
#: ../../source/howto/installation.rst:629
msgid "**PostgreSQL database**"
msgstr "**PostgreSQL数据库**"

#: ../../source/howto/installation.rst:580
msgid ""
"To export the entire database, we recommend to use the `pg_dump "
"<https://www.postgresql.org/docs/12/app-pgdump.html>`_ utility:"
msgstr "要导出整个数据库，建议使用 `pg_dump <https://www.postgresql.org/docs/12/app-pgdump.html>`_ 实用程序："

#: ../../source/howto/installation.rst:586
msgid ""
"The ``-W`` flag will ensure to prompt for the database password. The "
"parameters between brackets should be replaced with the values that have "
"been configured for the profile. You can retrieve these from the "
"``storage.config`` returned by the ``verdi profile show`` command."
msgstr "``-W`` 标志将确保提示输入数据库密码。括号中的参数应替换为为配置文件配置的值。您可以从 ``verdi profile show`` 命令返回的 ``storage.config`` 中获取这些值。"

#: ../../source/howto/installation.rst:592
msgid ""
"In order to avoid having to enter your database password each time you use "
"the script, you can create a file ``.pgpass`` in your home directory "
"containing your database credentials, as described `in the PostgreSQL "
"documentation <https://www.postgresql.org/docs/12/libpq-pgpass.html>`_."
msgstr "为了避免每次使用脚本时都要输入数据库密码，可以在主目录中创建一个包含数据库凭据的文件 ``.pgpass``，如 `in the PostgreSQL documentation <https://www.postgresql.org/docs/12/libpq-pgpass.html>`_ 所述。"

#: ../../source/howto/installation.rst:594
#: ../../source/howto/installation.rst:638
msgid "**File repository**"
msgstr "**文件存放处**"

#: ../../source/howto/installation.rst:596
msgid ""
"The file repository is a directory on the local file system. The most "
"efficient way to create a backup is to use the `rsync "
"<https://en.wikipedia.org/wiki/Rsync>`_ utility. The path of the repository "
"is shown in the ``storage.config.repository_uri`` key returned by the "
"``verdi profile show`` command. To create a backup, simply run:"
msgstr "文件存储库是本地文件系统上的一个目录。创建备份的最有效方法是使用 `rsync <https://en.wikipedia.org/wiki/Rsync>`_ 实用程序。``verdi profile show`` 命令返回的 ``storage.config.repository_uri`` 密钥中显示了存储库的路径。要创建备份，只需运行"

#: ../../source/howto/installation.rst:609
msgid "Restoring your installation"
msgstr "恢复安装"

#: ../../source/howto/installation.rst:611
msgid "Restoring a backed up AiiDA installation requires:"
msgstr "恢复已备份的 AiiDA 安装需要"

#: ../../source/howto/installation.rst:613
msgid ""
"restoring the backed up ``.aiida`` folder, with at the very least the "
"``config.json`` file it contains. It should be placed in the path defined by"
" the ``AIIDA_PATH`` environment variable. To test the restoration worked, "
"run ``verdi profile list`` to verify that all profiles are displayed."
msgstr "恢复已备份的 ``.aiida`` 文件夹，至少包括其中的 ``config.json`` 文件。它应放在 ``AIIDA_PATH`` 环境变量定义的路径中。要测试恢复是否成功，请运行 ``verdi profile list`` 验证是否显示了所有配置文件。"

#: ../../source/howto/installation.rst:617
msgid ""
"restoring the data of each backed up profile. Like the backup procedure, "
"this is dependent on the storage backend used by the profile."
msgstr "恢复每个已备份配置文件的数据。与备份程序一样，这取决于配置文件使用的存储后端。"

#: ../../source/howto/installation.rst:627
msgid ""
"To fully backup the data stored for a profile using the ``core.psql_dos`` "
"backend, you should restore the associated database and file repository."
msgstr "要完全备份使用 ``core.psql_dos`` 后端存储的配置文件数据，应还原相关数据库和文件存储库。"

#: ../../source/howto/installation.rst:631
msgid ""
"To restore the PostgreSQL database from the ``.psql`` file that was backed "
"up, first you should create an empty database following the instructions "
"described in :ref:`database <intro:install:database>` skipping the ``verdi "
"setup`` phase. The backed up data can then be imported by calling:"
msgstr "要从备份的 ``.psql`` 文件恢复 PostgreSQL 数据库，首先应按照 :ref:`database <intro:install:database>` 中的说明创建一个空数据库，跳过 ``verdi setup`` 阶段。然后，可以通过调用 imported 来备份数据："

#: ../../source/howto/installation.rst:640
msgid ""
"To restore the file repository, simply copy the directory that was backed up"
" to the location indicated by the ``storage.config.repository_uri`` key "
"returned by the ``verdi profile show`` command. Like the backing up process,"
" we recommend using ``rsync`` for this:"
msgstr "要恢复文件存储库，只需将已备份的目录复制到 ``verdi profile show`` 命令返回的 ``storage.config.repository_uri`` 键所指示的位置即可。与备份过程一样，我们建议使用 ``rsync``："

#: ../../source/howto/installation.rst:651
msgid "Managing multiple users"
msgstr "管理多个用户"

#: ../../source/howto/installation.rst:652
msgid ""
"AiiDA currently does not support multiple users running concurrently on the "
"same AiiDA profile. While AiiDA will tag any node with the "
":py:class:`~aiida.orm.users.User` who created it (the default user is "
"specified in the profile), this information is currently not used "
"internally. In particular, there is currently no permission system in place "
"to limit the operations that can be performed by a given user."
msgstr "AiiDA目前不支持多个用户同时运行同一个AiiDA配置文件。虽然AiiDA会用创建node的 :py:class:`~aiida.orm.users.User` 标记它(默认用户在配置文件中指定)，但目前内部并没有使用这些信息。特别是，目前没有权限系统来限制特定用户可以执行的操作。"

#: ../../source/howto/installation.rst:656
msgid ""
"The typical setup involves each user individually installing AiiDA on their "
"operating system account. Data can be shared between private AiiDA profiles "
"through :ref:`AiiDA's export and import functionality <how-"
"to:share:archives>`."
msgstr "典型的设置包括每个用户在他们的操作系统账户上单独安装 AiiDA。数据可通过 :ref:`AiiDA's export and import functionality <how-to:share:archives>` 在私人 AiiDA 配置文件之间共享。"

#: ../../source/howto/installation.rst:659
msgid ""
"Note that while the configuration file of an AiiDA instance contains access "
"credentials (e.g. for the postgresql database or the rabbitmq service), "
"AiiDA does not store sensitive data in the database or file repository, and "
"AiiDA export archives never contain such data."
msgstr "请注意，虽然 AiiDA 实例的配置文件包含访问凭证(例如 postgresql 数据库或 rabbitmq 服务)，但 AiiDA 不会在数据库或文件存储库中存储敏感数据，AiiDA 导出档案也不会包含此类数据。"

#: ../../source/howto/interact.rst:5
msgid "How to interact with AiiDA"
msgstr "如何与 AiiDA 互动"

#: ../../source/howto/interact.rst:7
msgid "There are a variety of manners to interact with AiiDA:"
msgstr "与 AiiDA 交互有多种方式："

#: ../../source/howto/interact.rst:9
msgid ":ref:`Through the command line interface <how-to:interact-cli>`"
msgstr " :ref:`Through the command line interface <how-to:interact-cli>`"

#: ../../source/howto/interact.rst:10
msgid ":ref:`Through scripts <how-to:interact-scripts>`"
msgstr " :ref:`Through scripts <how-to:interact-scripts>`"

#: ../../source/howto/interact.rst:11
msgid ":ref:`Through interactive shells <how-to:interact-shell>`"
msgstr " :ref:`Through interactive shells <how-to:interact-shell>`"

#: ../../source/howto/interact.rst:12
msgid ":ref:`Through interactive notebooks <how-to:interact-notebook>`"
msgstr " :ref:`Through interactive notebooks <how-to:interact-notebook>`"

#: ../../source/howto/interact.rst:13
msgid ":ref:`Through the REST API <how-to:interact-restapi>`"
msgstr " :ref:`Through the REST API <how-to:interact-restapi>`"

#: ../../source/howto/interact.rst:19
msgid "Command line interface"
msgstr "命令行界面"

#: ../../source/howto/interact.rst:21
msgid ""
"AiiDA comes with a command line interface called ``verdi``. The "
":ref:`reference:command-line` section gives an overview of all available "
"commands. For more detailed information, refer to the topic section "
":ref:`topics:cli`."
msgstr "AiiDA 有一个名为 ``verdi`` 的命令行界面。:ref:`reference:command-line` 部分概述了所有可用的命令。更多详细信息，请参阅主题部分 :ref:`topics:cli`。"

#: ../../source/howto/interact.rst:27
msgid ""
"The ``verdi`` command line interface can also be explored as a `text-based "
"user interface <https://en.wikipedia.org/wiki/Text-based_user_interface>`_ "
"(TUI). It requires ``aiida-core`` to be installed with the ``tui`` extra "
"(e.g. ``pip install aiida-core[tui]``). The TUI can then be launched with "
"``verdi tui``."
msgstr "``verdi`` 命令行界面也可以作为 `text-based user interface <https://en.wikipedia.org/wiki/Text-based_user_interface>`_(TUI)进行探索。这需要在安装 ``aiida-core`` 时附加 ``tui`` (例如 ``pip install aiida-core[tui]``)。然后可以使用 ``verdi tui`` 启动 TUI。"

#: ../../source/howto/interact.rst:35
msgid "Scripts"
msgstr "脚本"

#: ../../source/howto/interact.rst:37
msgid ""
"AiiDA's Python API can be used in Python scripts mixed with any other Python"
" code. The only requirement is that before the API is used an AiiDA profile "
"is loaded. The recommended way of accomplishing this is to run the script "
"through the command line interface:"
msgstr "AiiDA 的 Python API 可以在 Python 脚本中与其他 Python 代码混合使用。唯一的要求是，在使用 API 之前，必须加载 AiiDA 配置文件。推荐的方法是通过命令行界面运行脚本："

#: ../../source/howto/interact.rst:45
msgid ""
"The ``verdi`` CLI will automatically load the default profile, before "
"calling the actual script, passing any command line arguments that may have "
"been specified."
msgstr "在调用实际脚本之前，``verdi`` CLI 会自动加载默认配置文件，并传递可能指定的任何命令行参数。"

#: ../../source/howto/interact.rst:49 ../../source/howto/interact.rst:105
msgid ""
"A :ref:`different profile can be selected <topics:cli:profile>` using the "
"``--profile`` option, just as for all other ``verdi`` commands."
msgstr "A :ref:`different profile can be selected <topics:cli:profile>` 使用 ``--profile`` 选项，与所有其他 ``verdi`` 命令一样。"

#: ../../source/howto/interact.rst:51
msgid ""
"Alternatively, one can also add AiiDA's specific `shebang "
"<https://en.wikipedia.org/wiki/Shebang_(Unix)>`_ to the top of the file."
msgstr "或者，也可以在文件顶部添加 AiiDA 的特定 `shebang <https://en.wikipedia.org/wiki/Shebang_(Unix)>`_。"

#: ../../source/howto/interact.rst:57
msgid ""
"When a script starts with this shebang, when it is executed, it is "
"automatically passed to ``verdi run`` just as if it would have been called "
"through ``verdi run`` directly. This has the advantage that one no longer "
"has to explicitly type ``verdi run`` when running the script, but can simply"
" make it executable and execute it directly. The downside is that it does "
"not allow to specify a particular profile, but it always loads the default "
"profile."
msgstr "当脚本以这个 Shebang 开始时，当它被执行时，它会自动传递给 ``verdi run``，就像直接通过 ``verdi run`` 调用一样。这样做的好处是，在运行脚本时不必再明确键入 ``verdi run``，而只需使其可执行并直接执行即可。缺点是不能指定特定的配置文件，而是始终加载默认配置文件。"

#: ../../source/howto/interact.rst:61
msgid ""
"If, for whatever reason, ``verdi run`` nor the special shebang can be used, "
"a profile can also be loaded directly through the API within the Python "
"script itself:"
msgstr "如果由于某种原因，不能使用 ``verdi run`` 或特殊的 Shebang，也可以通过 Python 脚本本身的 API 直接加载配置文件："

#: ../../source/howto/interact.rst:68 ../../source/howto/interact.rst:119
msgid ""
"One can pass a particular profile name to "
":meth:`~aiida.manage.configuration.load_profile`, otherwise the default "
"profile is loaded."
msgstr "可以向 :meth:`~aiida.manage.configuration.load_profile` 传递特定的配置文件名称，否则将加载默认配置文件。"

#: ../../source/howto/interact.rst:70
msgid ""
"Within a script or Python instance, you can also switch to a different "
"profile, or use one within a context manager:"
msgstr "在脚本或 Python 实例中，也可以切换到不同的配置文件，或使用上下文管理器中的配置文件："

#: ../../source/howto/interact.rst:92
msgid "Interactive shells"
msgstr "交互式外壳"

#: ../../source/howto/interact.rst:94
msgid ""
"AiiDA provides a Python API that can be used from an interactive shell, such"
" as `IPython <https://ipython.org/>`_. The recommended way of starting an "
"interactive shell session to work with AiiDA, is through the command line "
"interface:"
msgstr "AiiDA 提供一个 Python API，可以在交互式 shell 中使用，例如 `IPython <https://ipython.org/>`_。建议通过命令行界面启动交互式 shell 会话来使用 AiiDA："

#: ../../source/howto/interact.rst:101
msgid ""
"This command will open a normal IPython shell but automatically loads the "
"default AiiDA profile, which is required to use the Python API."
msgstr "该命令将打开一个普通的 IPython shell，但会自动加载默认的 AiiDA 配置文件，这是使用 Python API 所必需的。"

#: ../../source/howto/interact.rst:107
msgid ""
"In addition to automatically loading an AiiDA profile, certain modules from "
"AiiDA's API that are used very often are automatically imported. The modules"
" that are pre-loaded can be configured using the :ref:`reference:command-"
"line:verdi-config` command."
msgstr "除了自动加载 AiiDA 配置文件，AiiDA API 中的某些常用模块也会自动 import。可以使用 :ref:`reference:command-line:verdi-config` 命令配置预加载的模块。"

#: ../../source/howto/interact.rst:110
msgid ""
"If, for whatever reason, you cannot use ``verdi shell``, a profile can also "
"be loaded directly through the API within the shell itself:"
msgstr "如果由于某种原因无法使用 ``verdi shell``，也可以通过 shell 本身的 API 直接加载配置文件："

#: ../../source/howto/interact.rst:125
msgid "Interactive notebooks"
msgstr "互动笔记本"

#: ../../source/howto/interact.rst:127
msgid ""
"Similar to :ref:`interactive shells <how-to:interact-shell>`, AiiDA is also "
"directly compatbile with interactive Python notebooks, such as `Jupyter "
"<https://jupyter.org/>`_. To use AiiDA's Python API in a notebook, first a "
"profile has to be loaded:"
msgstr "与 :ref:`interactive shells <how-to:interact-shell>` 类似，AiiDA 也直接兼容交互式 Python 笔记本，如 `Jupyter <https://jupyter.org/>`_。要在笔记本中使用 AiiDA 的 Python API，首先必须加载配置文件："

#: ../../source/howto/interact.rst:137
msgid ""
"One can pass a particular profile name to "
":meth:`~aiida.manage.configuration.load_profile`, otherwise the default "
"profile is loaded. The same can be accomplished using the following magic "
"statement:"
msgstr "可以向 :meth:`~aiida.manage.configuration.load_profile` 传递一个特定的配置文件名称，否则将加载默认配置文件。使用下面的神奇语句也可以达到同样的目的："

#: ../../source/howto/interact.rst:145
msgid ""
"This magic line will replicate the same environment as :ref:`the interactive"
" shell <how-to:interact-shell>` provided by ``verdi shell``. However, it "
"does require some one-time installation, as detailed in the section on how "
"to :ref:`intro:install:jupyter`."
msgstr "这条神奇的线路将复制与 ``verdi shell`` 提供的 :ref:`the interactive shell <how-to:interact-shell>` 相同的环境。不过，它需要进行一次性安装，详见如何安装 :ref:`intro:install:jupyter` 的章节。"

#: ../../source/howto/interact.rst:152
msgid "REST API"
msgstr "REST API"

#: ../../source/howto/interact.rst:154
msgid ""
"AiiDA ships with a built in REST API, that allows you to query the data of a"
" particular profile. Refer to section :ref:`how-to:share:serve:launch` to "
"learn how to start the REST API. The section :ref:`how-to:share:serve:query`"
" provides information on how to interact with a running REST API."
msgstr "AiiDA 内置 REST API，允许你查询特定配置文件的数据。参考 :ref:`how-to:share:serve:launch` 章节了解如何启动 REST API。:ref:`how-to:share:serve:query` 小节提供了如何与运行中的 REST API 交互的信息。"

#: ../../source/howto/plugin_codes.rst:5
msgid "How to write a plugin for an external code"
msgstr "如何为外部代码编写插件"

#: ../../source/howto/plugin_codes.rst:9
msgid ""
"Before starting to write a new plugin, check the `aiida plugin registry "
"<https://aiidateam.github.io/aiida-registry/>`_. If a plugin for your code "
"is already available, you can skip straight to :ref:`how-to:run-codes`."
msgstr "在开始编写新插件之前，请检查 `aiida plugin registry <https://aiidateam.github.io/aiida-registry/>`_。如果已经有适用于您代码的插件，您可以直接跳到 :ref:`how-to:run-codes`。"

#: ../../source/howto/plugin_codes.rst:14
msgid ""
"This how to walks you through all logical steps of how AiiDA interacts with "
"an external code. If you already know the basics and would like to get "
"started with a new plugin package quickly, check out :ref:`how-to:plugins-"
"develop`."
msgstr "本手册引导你了解 AiiDA 如何与外部代码交互的所有逻辑步骤。如果你已经了解基础知识，并希望快速开始使用新的插件包，请查看 :ref:`how-to:plugins-develop`。"

#: ../../source/howto/plugin_codes.rst:17
msgid ""
"To run an external code with AiiDA, you need a corresponding *calculation* "
"plugin, which tells AiiDA how to:"
msgstr "要使用 AiiDA 运行外部代码，你需要一个相应的 *计算* 插件，告诉 AiiDA 如何运行："

#: ../../source/howto/plugin_codes.rst:19
msgid "Prepare the required input files."
msgstr "准备所需的输入文件。"

#: ../../source/howto/plugin_codes.rst:20
msgid "Run the code with the correct command line parameters."
msgstr "使用正确的命令行参数运行代码。"

#: ../../source/howto/plugin_codes.rst:22
msgid ""
"Finally, you will probably want a *parser* plugin, which tells AiiDA how to:"
msgstr "最后，你可能需要一个 *解析器* 插件，它告诉 AiiDA 如何处理："

#: ../../source/howto/plugin_codes.rst:24
msgid "Parse the output of the code."
msgstr "解析代码输出。"

#: ../../source/howto/plugin_codes.rst:26
msgid ""
"This how-to takes you through the process of :ref:`creating a calculation "
"plugin<how-to:plugin-codes:interfacing>`, using it to :ref:`run the "
"code<how-to:plugin-codes:run>`, and :ref:`writing a parser <how-to:plugin-"
"codes:parsing>` for its outputs."
msgstr "本教程将带您了解 :ref:`creating a calculation plugin<how-to:plugin-codes:interfacing>` 的使用过程，将其用于 :ref:`run the code<how-to:plugin-codes:run>` 和 :ref:`writing a parser <how-to:plugin-codes:parsing>` 的输出。"

#: ../../source/howto/plugin_codes.rst:28
msgid ""
"In this example, our |Code| will be the ``diff`` executable that "
"\"computes\" the difference between two \"input files\" and prints the "
"difference to standard output:"
msgstr "在本例中，我们的 |Code| 将是 ``diff`` 可执行文件，它可以 \``computes\`` 两个 \``input files\`` 之间的差值，并将差值打印到标准输出："

#: ../../source/howto/plugin_codes.rst:46
msgid ""
"We are using ``diff`` here since it is available on almost every UNIX system"
" by default, and it takes both command line *arguments* (the two files) and "
"command line *options* (e.g. ``-i`` for case-insensitive matching). This is "
"similar to how the executables of many scientific simulation codes work, "
"making it easy to adapt this example to your use case."
msgstr "我们在这里使用 ``diff``，因为几乎所有 UNIX 系统都默认使用它，而且它既接受命令行参数 *(两个文件)，也接受命令行选项* (例如 ``-i``，用于不区分大小写的匹配)。这与许多科学模拟代码的可执行文件的工作方式类似，因此很容易将本示例调整为适合您的使用情况。"

#: ../../source/howto/plugin_codes.rst:49
msgid "We will run ``diff`` as:"
msgstr "我们将以如下方式运行 ``diff``："

#: ../../source/howto/plugin_codes.rst:55
msgid ""
"thus writing difference between `file1.txt` and `file2.txt` to `diff.patch`."
msgstr "因此将 `file1.txt` 和 `file2.txt` 之间的差值写入 `diff.patch`。"

#: ../../source/howto/plugin_codes.rst:62
msgid "Interfacing external codes"
msgstr "连接外部代码"

#: ../../source/howto/plugin_codes.rst:64
msgid ""
"Start by creating a file ``calculations.py`` and subclass the |CalcJob| "
"class:"
msgstr "首先创建文件 ``calculations.py``，然后子类化 |CalcJob| 类："

#: ../../source/howto/plugin_codes.rst:76
msgid ""
"In the following, we will tell AiiDA how to run our code by implementing two"
" key methods:"
msgstr "下面，我们将通过实现两个关键方法来告诉 AiiDA 如何运行我们的代码："

#: ../../source/howto/plugin_codes.rst:78
msgid ":py:meth:`~aiida.engine.processes.calcjobs.calcjob.CalcJob.define`"
msgstr " :py:meth:`~aiida.engine.processes.calcjobs.calcjob.CalcJob.define`"

#: ../../source/howto/plugin_codes.rst:79
msgid ""
":py:meth:`~aiida.engine.processes.calcjobs.calcjob.CalcJob.prepare_for_submission`"
msgstr " :py:meth:`~aiida.engine.processes.calcjobs.calcjob.CalcJob.prepare_for_submission`"

#: ../../source/howto/plugin_codes.rst:82
msgid "Defining the spec"
msgstr "定义规格"

#: ../../source/howto/plugin_codes.rst:84
msgid ""
"The |define| method tells AiiDA which inputs the |CalcJob| expects and which"
" outputs it produces (exit codes will be :ref:`discussed later<how-"
"to:plugin-codes:parsing:errors>`). This is done through an instance of the "
":py:class:`~aiida.engine.processes.process_spec.CalcJobProcessSpec` class, "
"which is passed as the |spec| argument to the |define| method. For example:"
msgstr "|define| 方法告诉 AiiDA |CalcJob| 期望的输入和输出(退出代码将是 :ref:`discussed later<how-to:plugin-codes:parsing:errors>`)。这是通过 :py:class:`~aiida.engine.processes.process_spec.CalcJobProcessSpec` 类的实例完成的，该实例作为 |spec| 参数传递给 |define| 方法。例如"

#: ../../source/howto/plugin_codes.rst:93
msgid ""
"The first line of the method calls the |define| method of the |CalcJob| "
"parent class. This necessary step defines the `inputs` and `outputs` that "
"are common to all |CalcJob|'s."
msgstr "该方法的第一行调用 |CalcJob| 父类的 |define| 方法。这一必要步骤定义了所有 |CalcJob| 共用的 `inputs` 和 `outputs`。"

#: ../../source/howto/plugin_codes.rst:96
msgid ""
"Next, we use the :py:meth:`~plumpy.process_spec.ProcessSpec.input` method in"
" order to define our two input files ``file1`` and ``file2`` of type "
"|SinglefileData|."
msgstr "接下来，我们使用 :py:meth:`~plumpy.process_spec.ProcessSpec.input` 方法定义两个 |SinglefileData| 类型的输入文件 ``file1`` 和 ``file2`` 。"

#: ../../source/howto/plugin_codes.rst:98
#: ../../source/howto/plugin_codes.rst:130
#: ../../source/howto/plugin_codes.rst:191
msgid "Further reading"
msgstr "更多阅读"

#: ../../source/howto/plugin_codes.rst:100
msgid ""
"When using |SinglefileData|, AiiDA keeps track of the inputs as *files*. "
"This is very flexible but has the downside of making it difficult to query "
"for information contained in those files and ensuring that the inputs are "
"valid. :ref:`how-to:plugin-codes:cli-options` shows how to use the |Dict| "
"class to represent the ``diff`` command line options as a python dictionary."
" The `aiida-diff`_ demo plugin goes further and adds automatic validation."
msgstr "当使用 |SinglefileData| 时，AiiDA 会以 *文件* 的形式记录输入。这非常灵活，但缺点是很难查询这些文件中的信息，也很难确保输入是有效的。:ref:`how-to:plugin-codes:cli-options` 演示了如何使用 |Dict| 类将 ``diff`` 命令行选项表示为 python 字典。`aiida-diff`_ 演示插件则更进一步，增加了自动验证功能。"

#: ../../source/howto/plugin_codes.rst:105
msgid ""
"We then use :py:meth:`~plumpy.process_spec.ProcessSpec.output` to define the"
" only output of the calculation with the label ``diff``. AiiDA will attach "
"the outputs defined here to a (successfully) finished calculation using the "
"link label provided."
msgstr "然后我们使用 :py:meth:`~plumpy.process_spec.ProcessSpec.output` 来定义计算的唯一输出，标签为 ``diff``。AiiDA 会使用提供的链接标签将这里定义的输出附加到(成功)完成的计算中。"

#: ../../source/howto/plugin_codes.rst:114
msgid ""
"Finally, we set a few default ``options``, such as the name of the parser "
"(which we will implement later), the name of input and output files, and the"
" computational resources to use for such a calculation. These ``options`` "
"have already been defined on the |spec| by the ``super().define(spec)`` "
"call, and they can be accessed through the "
":py:attr:`~plumpy.process_spec.ProcessSpec.inputs` attribute, which behaves "
"like a dictionary."
msgstr "最后，我们设置了一些默认的 ``options``，例如解析器的名称(我们稍后将实现)、输入和输出文件的名称，以及用于此类计算的计算资源。这些 ``options`` 已经通过 ``super().define(spec)`` 调用在 |spec| 上定义，可以通过 :py:attr:`~plumpy.process_spec.ProcessSpec.inputs` 属性访问它们，其行为类似于字典。"

#: ../../source/howto/plugin_codes.rst:117
msgid ""
"There is no ``return`` statement in ``define``: the ``define`` method "
"directly modifies the |spec| object it receives."
msgstr "``define`` 中没有 ``return`` 语句：``define`` 方法直接修改它接收到的 |spec| 对象。"

#: ../../source/howto/plugin_codes.rst:121
msgid ""
"One more input required by any |CalcJob| is which external executable to "
"use."
msgstr "|CalcJob| 所需的另一项输入是使用哪个外部可执行文件。"

#: ../../source/howto/plugin_codes.rst:123
msgid ""
"External executables are represented by |Code|  instances that contain "
"information about the computer they reside on, their path in the file system"
" and more. They are passed to a |CalcJob| via the ``code`` input, which is "
"defined in the |CalcJob| base class, so you don't have to:"
msgstr "外部可执行文件由 |Code| 实例表示，其中包含有关其所在计算机、文件系统路径等信息。外部可执行文件通过 ``code`` 输入传递给 |CalcJob|，该输入在 |CalcJob| 基类中定义，因此您不必这样做："

#: ../../source/howto/plugin_codes.rst:132
msgid ""
"For more details on setting up your `inputs` and `outputs` (covering "
"validation, dynamic number of inputs, etc.) see the :ref:`Defining Processes"
" <topics:processes:usage:defining>` topic."
msgstr "有关设置 `inputs` 和 `outputs` 的详细信息(包括验证、动态输入数等)，请参阅 :ref:`Defining Processes <topics:processes:usage:defining>` 主题。"

#: ../../source/howto/plugin_codes.rst:135
msgid "Preparing for submission"
msgstr "准备提交"

#: ../../source/howto/plugin_codes.rst:138
msgid ""
"The "
":py:meth:`~aiida.engine.processes.calcjobs.calcjob.CalcJob.prepare_for_submission`"
" method has two jobs: Creating the input files in the format the external "
"code expects and returning a "
":py:class:`~aiida.common.datastructures.CalcInfo` object that contains "
"instructions for the AiiDA engine on how the code should be run. For "
"example:"
msgstr " :py:meth:`~aiida.engine.processes.calcjobs.calcjob.CalcJob.prepare_for_submission` 方法有两项工作：按照外部代码期望的格式创建输入文件，并返回一个 :py:class:`~aiida.common.datastructures.CalcInfo` 对象，其中包含 AiiDA engine 如何运行代码的指令。例如"

#: ../../source/howto/plugin_codes.rst:146
msgid ""
"All inputs provided to the calculation are validated against the ``spec`` "
"*before* |prepare_for_submission| is called. Therefore, when accessing the "
":py:attr:`~plumpy.processes.Process.inputs` attribute, you can safely assume"
" that all required inputs have been set and that all inputs have a valid "
"type."
msgstr "在调用 |prepare_for_submission| 之前，所有提供给计算的输入都会根据 ``spec`` 进行验证。因此，在访问 :py:attr:`~plumpy.processes.Process.inputs` 属性时，可以放心地假设所有必需的输入都已设置，并且所有输入的类型都有效。"

#: ../../source/howto/plugin_codes.rst:149
msgid ""
"We start by creating a |CodeInfo| object that lets AiiDA know how to run the"
" code, i.e. here:"
msgstr "我们首先创建一个 |CodeInfo| 对象，让 AiiDA 知道如何运行代码，即这里："

#: ../../source/howto/plugin_codes.rst:155
msgid ""
"This includes the command line parameters (here: the names of the files that"
" we would like to ``diff``) and the UUID of the |Code| to run. Since "
"``diff`` writes directly to standard output, we redirect standard output to "
"the specified output filename."
msgstr "这包括命令行参数(此处：我们希望 ``diff`` 运行的文件名)和要运行的 |Code| 的 UUID。由于 ``diff`` 会直接写入标准输出，因此我们会将标准输出重定向到指定的输出文件名。"

#: ../../source/howto/plugin_codes.rst:158
msgid ""
"Next, we create a |CalcInfo| object that lets AiiDA know which files to copy"
" back and forth. In our example, the two input files are already stored in "
"the AiiDA file repository and we can use the ``local_copy_list`` to pass "
"them along."
msgstr "接下来，我们创建一个 |CalcInfo| 对象，让 AiiDA 知道哪些文件需要来回拷贝。在我们的例子中，两个输入文件已经存储在 AiiDA 文件库中，我们可以使用 ``local_copy_list`` 来传递它们。"

#: ../../source/howto/plugin_codes.rst:163
msgid ""
"In other use cases you may need to *create* new files on the fly. This is "
"what the ``folder`` argument of "
":py:meth:`~aiida.engine.processes.calcjobs.calcjob.CalcJob.prepare_for_submission`"
" is for:"
msgstr "在其他使用情况下，您可能需要临时 *创建* 新文件。这就是 :py:meth:`~aiida.engine.processes.calcjobs.calcjob.CalcJob.prepare_for_submission` 的 ``folder`` 参数的作用："

#: ../../source/howto/plugin_codes.rst:172
msgid ""
"Any files and directories created in this sandbox folder will automatically "
"be transferred to the compute resource where the actual calculation takes "
"place."
msgstr "在该沙盒文件夹中创建的任何文件和目录都将自动转移到进行实际计算的计算资源中。"

#: ../../source/howto/plugin_codes.rst:182
msgid ""
"The ``retrieve_list`` on the other hand tells the engine which files to "
"retrieve from the directory where the job ran after it has finished. All "
"files listed here will be store in a |FolderData| node that is attached as "
"an output node to the calculation with the label ``retrieved``."
msgstr "另一方面，``retrieve_list`` 则告诉 engine 在作业完成后从作业运行的目录中检索哪些文件。此处列出的所有文件都将存储在 |FolderData| node 中，作为标号为 ``retrieved`` 的输出 node 附加到计算中。"

#: ../../source/howto/plugin_codes.rst:185
msgid ""
"Finally, we pass the |CodeInfo| to a |CalcInfo| object. One calculation job "
"can involve more than one executable, so ``codes_info`` is a list. If you "
"have more than one executable in your ``codes_info``, you can set "
"``codes_run_mode`` to specify the mode with which these will be executed "
"(`CodeRunMode.SERIAL` by default). We define the ``retrieve_list`` of "
"filenames that the engine should retrieve from the directory where the job "
"ran after it has finished. The engine will store these files in a "
"|FolderData| node that will be attached as an output node to the calculation"
" with the label ``retrieved``."
msgstr "最后，我们将 |CodeInfo| 传递给一个 |CalcInfo| 对象。一个计算任务可能涉及多个可执行文件，因此 ``codes_info`` 是一个列表。如果 ``codes_info`` 中有多个可执行文件，可以设置 ``codes_run_mode`` 来指定执行这些文件的模式(默认为 `CodeRunMode.SERIAL`)。我们定义了 ``retrieve_list`` 文件名，engine 应在作业完成后从作业运行的目录中检索这些文件名。engine 会将这些文件存储在 |FolderData| node 中，并作为输出 node 附加到计算中，标签为 ``retrieved``。"

#: ../../source/howto/plugin_codes.rst:193
msgid ""
"There are :ref:`other file lists "
"available<topics:calculations:usage:calcjobs:file_lists>` that allow you to "
"easily customize how to move files to and from the remote working directory "
"in order to prevent the creation of unnecessary copies. For more details on "
"the |CalcJob| class, refer to the Topics section on :ref:`defining "
"calculations <topics:calculations:usage>`."
msgstr "通过 :ref:`other file lists available<topics:calculations:usage:calcjobs:file_lists>`，您可以轻松自定义如何将文件移入或移出远程工作目录，以防止创建不必要的副本。有关 |CalcJob| 类的更多详情，请参阅 :ref:`defining calculations <topics:calculations:usage>` 上的主题部分。"

#: ../../source/howto/plugin_codes.rst:200
msgid "Parsing the outputs"
msgstr "解析输出结果"

#: ../../source/howto/plugin_codes.rst:202
msgid ""
"Parsing the output files produced by a code into AiiDA nodes is optional, "
"but it can make your data queryable and therefore easier to access and "
"analyze."
msgstr "将代码生成的输出文件解析为 AiiDA nodes 是可选的，但它可以使你的数据可查询，从而更容易访问和分析。"

#: ../../source/howto/plugin_codes.rst:204
msgid ""
"To create a parser plugin, subclass the |Parser| class in a file called "
"``parsers.py``."
msgstr "要创建解析器插件，请在名为 ``parsers.py`` 的文件中子类化 |Parser| 类。"

#: ../../source/howto/plugin_codes.rst:211
msgid ""
"Before the ``parse()`` method is called, two important attributes are set on"
" the |Parser|  instance:"
msgstr "在调用 ``parse()`` 方法之前，会在 |Parser| 实例上设置两个 important 属性："

#: ../../source/howto/plugin_codes.rst:213
msgid ""
"``self.retrieved``: An instance of |FolderData|, which points to the folder "
"containing all output files that the |CalcJob| instructed to retrieve, and "
"provides the means to "
":py:meth:`~aiida.orm.nodes.repository.NodeRepository.open` any file it "
"contains."
msgstr "``self.retrieved``：|FolderData| 的实例，该实例指向包含 |CalcJob| 指示检索的所有输出文件的文件夹，并提供了对其中包含的任何文件进行 :py:meth:`~aiida.orm.nodes.repository.NodeRepository.open` 的方法。"

#: ../../source/howto/plugin_codes.rst:215
msgid ""
"``self.node``: The "
":py:class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode` "
"representing the finished calculation, which, among other things, provides "
"access to all of its inputs (``self.node.inputs``)."
msgstr "``self.node``：代表已完成计算的 :py:class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode`，除其他外，可访问其所有输入 (``self.node.inputs``)。"

#: ../../source/howto/plugin_codes.rst:217
msgid ""
"Now implement its :py:meth:`~aiida.parsers.parser.Parser.parse` method as"
msgstr "现在将其 :py:meth:`~aiida.parsers.parser.Parser.parse` 方法执行为"

#: ../../source/howto/plugin_codes.rst:223
msgid ""
"The "
":py:meth:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.get_option`"
" convenience method is used to get the filename of the output file."
msgstr " :py:meth:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.get_option` 方便方法用于获取输出文件的文件名。"

#: ../../source/howto/plugin_codes.rst:225
msgid ""
"Finally, the :py:meth:`~aiida.parsers.parser.Parser.out` method is used "
"return the output file as the ``diff`` output of the calculation: The first "
"argument is the name to be used as the label for the link that connects the "
"calculation and data node. The second argument is the node that should be "
"recorded as an output."
msgstr "最后，使用 :py:meth:`~aiida.parsers.parser.Parser.out` 方法返回输出文件，作为计算的 ``diff`` 输出：第一个参数是连接计算和数据 node 的链接标签名称。第二个参数是应作为输出记录的 node。"

#: ../../source/howto/plugin_codes.rst:231
msgid ""
"The outputs and their types need to match those from the process "
"specification of the corresponding |CalcJob| (or an exception will be "
"raised)."
msgstr "输出及其类型必须与相应 |CalcJob| 的流程规范相符(否则会出现异常)。"

#: ../../source/howto/plugin_codes.rst:233
msgid ""
"In this minimalist example, there isn't actually much parsing going on -- we"
" are simply passing along the output file as a |SinglefileData| node. If "
"your code produces output in a structured format, instead of just returning "
"the file you may want to parse it e.g. to a python dictionary (|Dict| node) "
"to make the results easily searchable."
msgstr "在这个简约的示例中，实际上并没有进行太多解析--我们只是将输出文件作为 |SinglefileData| node 传递。如果你的代码会产生结构化格式的输出，你可能不想只返回文件，而是想将其解析为 python 字典 (|Dict| node)，以便于搜索结果。"

#: ../../source/howto/plugin_codes.rst:236
msgid "Exercise"
msgstr "运动"

#: ../../source/howto/plugin_codes.rst:238
msgid ""
"Consider the different output files produced by your favorite simulation "
"code. Which information would you want to:"
msgstr "考虑一下您最喜欢的仿真代码产生的不同输出文件。您希望获得哪些信息？"

#: ../../source/howto/plugin_codes.rst:241
msgid ""
"parse into the database for querying (e.g. as |Dict|, |StructureData|, ...)?"
msgstr "解析到数据库中进行查询(如 |Dict|、|StructureData|......)？"

#: ../../source/howto/plugin_codes.rst:242
msgid ""
"store in the AiiDA file repository for safe-keeping (e.g. as "
"|SinglefileData|, ...)?"
msgstr "存储在 AiiDA 文件库中保管(例如作为 |SinglefileData|，......)？"

#: ../../source/howto/plugin_codes.rst:243
msgid ""
"leave on the computer where the calculation ran (e.g. recording their remote"
" location using |RemoteData| or simply ignoring them)?"
msgstr "在运行计算的计算机上留下(例如，使用 |RemoteData| 记录其远程位置或直接忽略它们)？"

#: ../../source/howto/plugin_codes.rst:245
msgid ""
"Once you know the answers to these questions, you are ready to start writing"
" a parser for your code."
msgstr "知道这些问题的答案后，您就可以开始为代码编写解析器了。"

#: ../../source/howto/plugin_codes.rst:247
msgid ""
"In order to request automatic parsing of a |CalcJob| (once it has finished),"
" users can set the ``metadata.options.parser_name`` input when launching the"
" job. If a particular parser should be used by default, the |CalcJob| "
"``define`` method can set a default value for the parser name as was done in"
" the :ref:`previous section <how-to:plugin-codes:interfacing>`:"
msgstr "为了要求自动解析 |CalcJob|(一旦完成)，用户可以在启动作业时设置 ``metadata.options.parser_name`` 输入。如果默认使用特定的解析器，|CalcJob| ``define`` 方法可以为解析器名称设置默认值，如 :ref:`previous section <how-to:plugin-codes:interfacing>` 所做的那样："

#: ../../source/howto/plugin_codes.rst:257
msgid ""
"Note that the default is not set to the |Parser| class itself, but to the "
"*entry point string* under which the parser class is registered. We will "
"register the entry point for the parser in a bit."
msgstr "请注意，默认值不是设置为 |Parser| 类本身，而是设置为*entry point 字符串*，解析器类是在该字符串下注册的。我们稍后将为解析器注册 entry point。"

#: ../../source/howto/plugin_codes.rst:264
msgid "Handling parsing errors"
msgstr "处理解析错误"

#: ../../source/howto/plugin_codes.rst:266
msgid ""
"So far, we have not spent much attention on dealing with potential errors "
"that can arise when running external codes. However, there are lots of ways "
"in which codes can fail to execute nominally. A |Parser| can play an "
"important role in detecting and communicating such errors, where "
":ref:`workflows <how-to:run-workflows>` can then decide how to proceed, "
"e.g., by modifying input parameters and resubmitting the calculation."
msgstr "到目前为止，我们还没有花太多精力来处理运行外部代码时可能出现的错误。然而，有很多方法可以导致代码无法正常执行。|Parser| 可以在检测和通报此类错误方面发挥 important 的作用，然后 :ref:`workflows <how-to:run-workflows>` 可以决定如何继续，例如修改输入参数并重新提交计算。"

#: ../../source/howto/plugin_codes.rst:270
msgid ""
"Parsers communicate errors through :ref:`exit "
"codes<topics:processes:concepts:exit_codes>`, which are defined in the "
"|spec| of the |CalcJob| they parse. The ``DiffCalculation`` example, defines"
" the following exit code:"
msgstr "解析器通过 :ref:`exit codes<topics:processes:concepts:exit_codes>` 传递错误，这些错误定义在其解析的 |CalcJob| 的 |spec| 中。``DiffCalculation`` 示例定义了以下退出代码："

#: ../../source/howto/plugin_codes.rst:277
msgid "An ``exit_code`` defines:"
msgstr "``exit_code`` 定义："

#: ../../source/howto/plugin_codes.rst:279
msgid ""
"an exit status (a positive integer, following the "
":ref:`topics:processes:usage:exit_code_conventions`),"
msgstr "退出状态(一个正整数，沿用 :ref:`topics:processes:usage:exit_code_conventions`)、"

#: ../../source/howto/plugin_codes.rst:280
msgid ""
"a label that can be used to reference the code in the |parse| method "
"(through the ``self.exit_codes`` property, as shown below), and"
msgstr "可用于引用 |parse| 方法中代码的标签(通过 ``self.exit_codes`` 属性，如下所示)，以及"

#: ../../source/howto/plugin_codes.rst:281
msgid "a message that provides a more detailed description of the problem."
msgstr "信息，对问题进行更详细的描述。"

#: ../../source/howto/plugin_codes.rst:283
msgid ""
"In order to inform AiiDA about a failed calculation, simply return from the "
"``parse`` method the exit code that corresponds to the detected issue. Here "
"is a more complete version of the example |Parser| presented in the previous"
" section:"
msgstr "为了通知 AiiDA 计算失败，只需从 ``parse`` 方法返回与检测到的问题相对应的退出代码。下面是上一节 |Parser| 例子的更完整版本："

#: ../../source/howto/plugin_codes.rst:290
msgid ""
"This simple check makes sure that the expected output file ``diff.patch`` is"
" among the files retrieved from the computer where the calculation was run. "
"Production plugins will often scan further aspects of the output (e.g. the "
"standard error, the output file, etc.) for any issues that may indicate a "
"problem with the calculation and return a corresponding exit code."
msgstr "这个简单的检查可以确保从运行计算的计算机获取的文件中包含预期输出文件 ``diff.patch``。生产插件通常会扫描输出的其他方面(如标准错误、输出文件等)，查找可能表明计算有问题的任何问题，并返回相应的退出代码。"

#: ../../source/howto/plugin_codes.rst:293
msgid ""
"AiiDA stores the exit code returned by the |parse| method on the calculation"
" node that is being parsed, from where it can then be inspected further down"
" the line (see the :ref:`defining processes "
"<topics:processes:usage:defining>` topic for more details). Note that some "
"scheduler plugins can detect issues at the scheduler level (by parsing the "
"job scheduler output) and set an exit code. The Topics section on "
":ref:`scheduler exit codes <topics:calculations:usage:calcjobs:scheduler-"
"errors>` explains how these can be inspected inside a parser and how they "
"can optionally be overridden."
msgstr "AiiDA 将 |parse| 方法返回的退出代码存储在正在解析的计算 node，在那里可以进一步检查(详见 :ref:`defining processes <topics:processes:usage:defining>` 主题)。请注意，某些调度程序插件可以在调度程序级别(通过解析作业调度程序输出)检测问题并设置退出代码。有关 :ref:`scheduler exit codes <topics:calculations:usage:calcjobs:scheduler-errors>` 的主题部分解释了如何在解析器内部检测这些问题，以及如何选择性地覆盖这些问题。"

#: ../../source/howto/plugin_codes.rst:301
msgid "Customizations"
msgstr "定制"

#: ../../source/howto/plugin_codes.rst:306
msgid "Process label"
msgstr "工艺标签"

#: ../../source/howto/plugin_codes.rst:308
msgid ""
"Each time a ``Process`` is run, a ``ProcessNode`` is stored in the database "
"to record the execution. A human-readable label is stored in the "
"``process_label`` attribute. By default, the name of the process class is "
"used as this label. If this default is not informative enough, it can be "
"customized by overriding the "
":meth:`~aiida.engine.processes.process.Process._build_process_label`: "
"method:"
msgstr "每次运行 ``Process`` 时，都会在数据库中存储 ``ProcessNode`` 以记录执行情况。``process_label`` 属性中会存储一个人类可读的标签。默认情况下，进程类的名称被用作此标签。如果默认值不够翔实，可通过重载 :meth:`~aiida.engine.processes.process.Process._build_process_label`: 方法进行自定义："

#: ../../source/howto/plugin_codes.rst:320
msgid ""
"Nodes created through executions of this process class will have "
"``node.process_label == 'custom_process_label'``."
msgstr "通过执行此进程类创建的 Node 将显示 ``node.process_label == 'custom_process_label'``。"

#: ../../source/howto/plugin_codes.rst:325
msgid "Registering entry points"
msgstr "注册 entry points"

#: ../../source/howto/plugin_codes.rst:327
msgid ""
":ref:`Entry points <how-to:plugins-develop:entrypoints>` are the preferred "
"method of registering new calculation, parser and other plugins with AiiDA."
msgstr " :ref:`Entry points <how-to:plugins-develop:entrypoints>` 是向 AiiDA 注册新计算、解析器和其他插件的首选方法。"

#: ../../source/howto/plugin_codes.rst:329
msgid ""
"With your ``calculations.py`` and ``parsers.py`` files at hand, let's "
"register entry points for the plugins they contain:"
msgstr "有了 ``calculations.py`` 和 ``parsers.py`` 文件，让我们为它们包含的插件注册 entry point："

#: ../../source/howto/plugin_codes.rst:331
msgid "Move your two scripts into a subfolder ``aiida_diff_tutorial``:"
msgstr "将两个脚本移至 ``aiida_diff_tutorial`` 子文件夹："

#: ../../source/howto/plugin_codes.rst:339
msgid "You have just created an ``aiida_diff_tutorial`` Python *package*!"
msgstr "您刚刚创建了一个 ``aiida_diff_tutorial`` Python *package* ！"

#: ../../source/howto/plugin_codes.rst:341
msgid ""
"Add a minimal set of metadata for your package by writing a "
"``pyproject.toml`` file:"
msgstr "通过编写 ``pyproject.toml`` 文件，为软件包添加一组最基本的元数据："

#: ../../source/howto/plugin_codes.rst:370
msgid ""
"This allows for the project metadata to be fully specified in the "
"pyproject.toml file, using the PEP 621 format."
msgstr "这样就可以在 pyproject.toml 文件中使用 PEP 621 格式完全指定项目元数据。"

#: ../../source/howto/plugin_codes.rst:373
msgid "Install your new ``aiida-diff-tutorial`` plugin package."
msgstr "安装新的 ``aiida-diff-tutorial`` 插件包。"

#: ../../source/howto/plugin_codes.rst:379
msgid "See the :ref:`how-to:plugins-install` section for details."
msgstr "详见 :ref:`how-to:plugins-install` 部分。"

#: ../../source/howto/plugin_codes.rst:381
msgid "After this, you should see your plugins listed:"
msgstr "之后，您应该会看到您的插件列表："

#: ../../source/howto/plugin_codes.rst:393
msgid "Running a calculation"
msgstr "运行计算"

#: ../../source/howto/plugin_codes.rst:395
msgid ""
"With the entry points set up, you are ready to launch your first calculation"
" with the new plugin:"
msgstr "设置好 entry point 后，您就可以使用新插件启动第一次计算了："

#: ../../source/howto/plugin_codes.rst:398
msgid ""
"If you haven't already done so, :ref:`set up your computer<how-to:run-"
"codes:computer>`. In the following we assume it to be the localhost:"
msgstr "如果您还没有这样做，:ref:`set up your computer<how-to:run-codes:computer>`。在下文中，我们假定它是 localhost："

#: ../../source/howto/plugin_codes.rst:406
msgid "Create the input files for our calculation"
msgstr "为我们的计算创建输入文件"

#: ../../source/howto/plugin_codes.rst:415
msgid "Write a ``launch.py`` script:"
msgstr "编写 ``launch.py`` 脚本："

#: ../../source/howto/plugin_codes.rst:422
msgid ""
"The ``launch.py`` script sets up an AiiDA |Code| instance that associates "
"the ``/usr/bin/diff`` executable with the ``DiffCalculation`` class (through"
" its entry point ``diff``)."
msgstr "``launch.py`` 脚本设置了一个 AiiDA |Code| 实例，将 ``/usr/bin/diff`` 可执行文件与 ``DiffCalculation`` 类关联(通过其 entry point ``diff`` 关联)。"

#: ../../source/howto/plugin_codes.rst:424
msgid ""
"This code is automatically set on the ``code`` input port of the builder and"
" passed as an input to the calculation plugin."
msgstr "该代码会自动设置在生成器的 ``code`` 输入端口上，并作为输入传递给计算插件。"

#: ../../source/howto/plugin_codes.rst:426
#: ../../source/howto/plugin_codes.rst:472
msgid "Launch the calculation:"
msgstr "启动计算："

#: ../../source/howto/plugin_codes.rst:433
msgid ""
"If everything goes well, this should print the results of your calculation, "
"something like:"
msgstr "如果一切顺利，就会打印出计算结果，类似于这样："

#: ../../source/howto/plugin_codes.rst:446
msgid ""
"If you encountered a parsing error, it can be helpful to make a "
":ref:`topics:calculations:usage:calcjobs:dry_run`, which allows you to "
"inspect the input folder generated by AiiDA before any calculation is "
"launched."
msgstr "如果遇到解析错误，制作一个 :ref:`topics:calculations:usage:calcjobs:dry_run` 可能会有帮助，它允许你在启动任何计算之前检查 AiiDA 生成的输入文件夹。"

#: ../../source/howto/plugin_codes.rst:450
msgid ""
"Finally instead of running your calculation in the current shell, you can "
"submit your calculation to the AiiDA daemon:"
msgstr "最后，你可以将计算提交给 AiiDA 守护进程，而不是在当前 shell 中运行："

#: ../../source/howto/plugin_codes.rst:452
msgid "(Re)start the daemon to update its Python environment:"
msgstr "(重新)启动守护进程，更新其 Python 环境："

#: ../../source/howto/plugin_codes.rst:458
msgid "Update your launch script to use:"
msgstr "更新启动脚本以使用"

#: ../../source/howto/plugin_codes.rst:469
msgid ""
"``node`` is the |CalcJobNode| representing the state of the underlying "
"calculation process (which may not be finished yet)."
msgstr "``node`` 是 |CalcJobNode|，代表底层计算过程的状态(可能尚未完成)。"

#: ../../source/howto/plugin_codes.rst:478
msgid "This should print the UUID and the PK of the submitted calculation."
msgstr "这将打印已提交计算的 UUID 和 PK。"

#: ../../source/howto/plugin_codes.rst:480
msgid ""
"You can use the verdi command line interface to "
":ref:`monitor<topics:processes:usage:monitoring>` this processes:"
msgstr "您可以使用 verdi 命令行界面来执行 :ref:`monitor<topics:processes:usage:monitoring>` 进程："

#: ../../source/howto/plugin_codes.rst:486
msgid ""
"This should show the processes of both calculations you just ran. Use "
"``verdi calcjob outputcat <pk>`` to check the output of the calculation you "
"submitted to the daemon."
msgstr "这将显示刚刚运行的两个计算的进程。使用 ``verdi calcjob outputcat <pk>`` 查看提交给守护进程的计算结果。"

#: ../../source/howto/plugin_codes.rst:489
msgid ""
"Congratulations - you can now write plugins for external simulation codes "
"and use them to submit calculations!"
msgstr "恭喜 - 您现在可以为外部仿真代码编写插件，并使用它们提交计算结果！"

#: ../../source/howto/plugin_codes.rst:491
msgid ""
"If you still have time left, consider going through the optional exercise "
"below."
msgstr "如果您还有时间，可以考虑做下面的选择性练习。"

#: ../../source/howto/plugin_codes.rst:496
msgid "Writing importers for existing computations"
msgstr "为现有计算编写 importers"

#: ../../source/howto/plugin_codes.rst:500
msgid ""
"New users to your plugin may often have completed many previous computations"
" without the use of AiiDA, which they wish to import into AiiDA. In these "
"cases, it is possible to write an importer for their inputs/outputs, which "
"generates the provenance nodes for the corresponding |CalcJob|."
msgstr "插件的新用户可能经常在没有使用AiiDA的情况下完成了许多以前的计算，他们希望将这些计算import到AiiDA中。在这种情况下，可以为他们的输入/输出写一个 importer ，为相应的 |CalcJob| 生成 provenance nodes 。"

#: ../../source/howto/plugin_codes.rst:503
msgid ""
"The importer must be written as a subclass of "
":class:`~aiida.engine.processes.calcjobs.importer.CalcJobImporter`, for an "
"example see "
":class:`aiida.calculations.importers.arithmetic.add.ArithmeticAddCalculationImporter`."
msgstr "importer 必须写成 :class:`~aiida.engine.processes.calcjobs.importer.CalcJobImporter` 的子类，示例见 :class:`aiida.calculations.importers.arithmetic.add.ArithmeticAddCalculationImporter`。"

#: ../../source/howto/plugin_codes.rst:506
msgid ""
"To associate the importer with the |CalcJob| class, the importer must be "
"registered with an entry point in the group "
"``aiida.calculations.importers``."
msgstr "要将 importer 与 |CalcJob| 类联系起来，必须将 importer 与 ``aiida.calculations.importers`` 组中的 entry point 注册在一起。"

#: ../../source/howto/plugin_codes.rst:515
msgid ""
"Note that the entry point name can be any valid entry point name. If the "
"importer plugin is provided by the same package as the corresponding "
"|CalcJob| plugin, it is recommended that the entry point name of the "
"importer and |CalcJob| plugin are the same. This will allow the "
":meth:`~aiida.engine.processes.calcjobs.calcjob.CalcJob.get_importer` method"
" to automatically fetch the associated importer. If the entry point names "
"differ, the entry point name of the desired importer implementation needs to"
" be passed to "
":meth:`~aiida.engine.processes.calcjobs.calcjob.CalcJob.get_importer` as an "
"argument."
msgstr "请注意，entry point 名称可以是任何有效的 entry point 名称。如果 importer 插件与相应的 |CalcJob| 插件由同一软件包提供，建议 importer 和 |CalcJob| 插件的 entry point 名称相同。这将允许 :meth:`~aiida.engine.processes.calcjobs.calcjob.CalcJob.get_importer` 方法自动获取相关的 importer。如果 entry point 名称不同，则需要将所需 importer 实现的 entry point 名称作为参数传递给 :meth:`~aiida.engine.processes.calcjobs.calcjob.CalcJob.get_importer`。"

#: ../../source/howto/plugin_codes.rst:520
msgid ""
"Users can then import their calculations via the "
":py:meth:`~aiida.engine.processes.calcjobs.calcjob.CalcJob.get_importer` "
"method:"
msgstr "然后，用户可以通过 :py:meth:`~aiida.engine.processes.calcjobs.calcjob.CalcJob.get_importer` 方法进行 import 计算："

#: ../../source/howto/plugin_codes.rst:533
msgid ""
":doc:`aep:004_calcjob_importer/readme`, for the design considerations around"
" this feature."
msgstr "请参阅 :doc:`aep:004_calcjob_importer/readme` ，了解有关此功能的设计考虑因素。"

#: ../../source/howto/plugin_codes.rst:538
msgid "Exercise - Support command-line options"
msgstr "练习 - 支持命令行选项"

#: ../../source/howto/plugin_codes.rst:540
msgid "As discussed before, ``diff`` knows a couple of command-line options:"
msgstr "如前所述，``diff`` 知道几个命令行选项："

#: ../../source/howto/plugin_codes.rst:556
msgid ""
"For simplicity let's focus on the excerpt of options shown above and allow "
"the user of our plugin to pass these along."
msgstr "为简单起见，让我们把重点放在上面显示的选项摘录上，并允许我们的插件用户传递这些选项。"

#: ../../source/howto/plugin_codes.rst:558
msgid ""
"Notice that one of the options (``--ignore-matching-lines``) requires the "
"user to pass a regular expression string, while the other options don't "
"require any value."
msgstr "请注意，其中一个选项(``--ignore-matching-lines``)要求用户传递一个正则表达式字符串，而其他选项不需要任何值。"

#: ../../source/howto/plugin_codes.rst:560
msgid "One way to represent a set of command line options like"
msgstr "表示一组命令行选项的一种方法是"

#: ../../source/howto/plugin_codes.rst:566
msgid "would be using a python dictionary:"
msgstr "将使用 python 字典："

#: ../../source/howto/plugin_codes.rst:576
msgid ""
"Here is a simple code snippet for translating the dictionary to a list of "
"command line options:"
msgstr "下面是将字典翻译成命令行选项列表的简单代码片段："

#: ../../source/howto/plugin_codes.rst:599
msgid ""
"When passing parameters along to your simulation code, try *validating* "
"them. This detects errors directly at *submission* of the calculation and "
"thus prevents calculations with malformed inputs from ever entering the "
"queue of your HPC system."
msgstr "在向仿真代码传递参数时，请尝试对参数进行 *验证。这样可以在* 提交*计算时直接检测出错误，从而防止畸形输入的计算进入高性能计算系统的队列。"

#: ../../source/howto/plugin_codes.rst:602
msgid ""
"For the sake of brevity we are *not* performing validation here but there "
"are numerous python libraries, such as `voluptuous`_ (used by `aiida-diff`_,"
" see `example <https://github.com/aiidateam/aiida-"
"diff/blob/92c61bdcc2db201d69da4d8b83a2b3f5dd529bf1/aiida_diff/data/__init__.py#L14-L20>`_),"
" `marshmallow`_ or `pydantic`_, that help you define a schema to validate "
"input against."
msgstr "为了简洁起见，我们在这里**不执行验证，但有许多 Python 库，如 `voluptuous`_(被 `aiida-diff`_ 使用，参见 `example <https://github.com/aiidateam/aiida-diff/blob/92c61bdcc2db201d69da4d8b83a2b3f5dd529bf1/aiida_diff/data/__init__.py#L14-L20>`_)、`marshmallow`_ 或 `pydantic`_，可以帮助您定义一个 schema，以验证输入。"

#: ../../source/howto/plugin_codes.rst:605
msgid ""
"Let's open our previous ``calculations.py`` file and start modifying the "
"``DiffCalculation`` class:"
msgstr "让我们打开之前的 ``calculations.py`` 文件，开始修改 ``DiffCalculation`` 类："

#: ../../source/howto/plugin_codes.rst:607
msgid ""
"In the ``define`` method, add a new ``input`` to the ``spec`` with label "
"``'parameters'`` and type |Dict|  (``from aiida.orm import Dict``)"
msgstr "在 ``define`` 方法中，在标号为 ``'parameters'`` 的 ``spec`` 中添加新的 ``input`` 并键入 |Dict| (``from aiida.orm import Dict``)"

#: ../../source/howto/plugin_codes.rst:608
msgid ""
"In the ``prepare_for_submission`` method run the ``cli_options`` function "
"from above on ``self.inputs.parameters.get_dict()`` to get the list of "
"command-line options. Add them to the ``codeinfo.cmdline_params``."
msgstr "在 ``prepare_for_submission`` 方法中，在 ``self.inputs.parameters.get_dict()`` 上运行上面的 ``cli_options`` 函数，以获取命令行选项列表。将它们添加到 ``codeinfo.cmdline_params`` 中。"

#: ../../source/howto/plugin_codes.rst:0
msgid "Solution"
msgstr "解决方案"

#: ../../source/howto/plugin_codes.rst:613
msgid "For 1. add the following line to the ``define`` method:"
msgstr "1. 在 ``define`` 方法中添加以下一行："

#: ../../source/howto/plugin_codes.rst:619
msgid ""
"For 2. copy the ``cli_options`` snippet at the end of ``calculations.py`` "
"and set the ``cmdline_params`` to:"
msgstr "复制 ``calculations.py`` 末尾的 ``cli_options`` 代码段，并将 ``cmdline_params`` 设置为："

#: ../../source/howto/plugin_codes.rst:626
msgid ""
"That's it. Let's now open the ``launch.py`` script and pass along our "
"command line parameters:"
msgstr "就是这样。现在让我们打开 ``launch.py`` 脚本，并传递命令行参数："

#: ../../source/howto/plugin_codes.rst:634
msgid ""
"Change the capitalization of one of the characters in the first line of "
"``file1.txt``. Then, restart the daemon and submit the new calculation:"
msgstr "更改 ``file1.txt`` 第一行中一个字符的大小写。然后，重新启动守护进程并提交新的计算结果："

#: ../../source/howto/plugin_codes.rst:642
msgid ""
"If everything worked as intended, the capitalization difference in the first"
" line should be ignored (and thus not show up in the output)."
msgstr "如果一切正常，第一行中的大小写差异应被忽略(因此不会显示在输出中)。"

#: ../../source/howto/plugin_codes.rst:644
msgid "This marks the end of this how-to."
msgstr "本教程到此结束。"

#: ../../source/howto/plugin_codes.rst:646
msgid ""
"The |CalcJob| and |Parser| plugins are still rather basic and the ``aiida-"
"diff-tutorial`` plugin package is missing a number of useful features, such "
"as package metadata, documentation, tests, CI, etc. Continue with :ref:`how-"
"to:plugins-develop` in order to learn how to quickly create a feature-rich "
"new plugin package from scratch."
msgstr "|CalcJob| 和 |Parser| 插件仍然相当基本，而 ``aiida-diff-tutorial`` 插件包则缺少许多有用的功能，例如包元数据、文档、测试、CI 等。请继续阅读 :ref:`how-to:plugins-develop`，了解如何从零开始快速创建功能丰富的新插件包。"

#: ../../source/howto/plugins_develop.rst:5
msgid "How to package plugins"
msgstr "如何打包插件"

#: ../../source/howto/plugins_develop.rst:7
msgid ""
"This section focuses on how to *package* AiiDA extensions (plugins) so that "
"they can be tested, published and eventually reused by others."
msgstr "本节主要介绍如何 *打包* AiiDA 扩展(插件)，以便它们可以被测试、发布并最终被其他人重用。"

#: ../../source/howto/plugins_develop.rst:11
msgid ""
"For guides on writing specific extensions, see :ref:`how-to:plugin-codes`, "
":ref:`topics:data_types:plugin`, :ref:`topics:schedulers:develop_plugin`, or"
" :ref:`topics:transport:develop_plugin`."
msgstr "有关编写特定扩展的指南，请参阅 :ref:`how-to:plugin-codes`、:ref:`topics:data_types:plugin`、:ref:`topics:schedulers:develop_plugin` 或 :ref:`topics:transport:develop_plugin`。"

#: ../../source/howto/plugins_develop.rst:17
msgid "Creating a plugin package"
msgstr "创建插件包"

#: ../../source/howto/plugins_develop.rst:20
msgid ""
"AiiDA plugins can be bundled and distributed in a `Python package "
"<packages_>`_ that provides a set of extensions to AiiDA."
msgstr "AiiDA 插件可以捆绑在 `Python package <packages_>`_ 中发布，为 AiiDA 提供一系列扩展。"

#: ../../source/howto/plugins_develop.rst:24
msgid ""
"The Python community uses the term 'package' rather loosely. Depending on "
"context, it may refer simply to a folder containing individual Python "
"modules or it may include the files necessary for building and installing a "
"package to be distributed via the `Python Package Index (PyPI) <pypi_>`_."
msgstr "Python 社区对 ``包``一词的使用相当宽松。根据上下文，它可能仅指包含单个 Python 模块的文件夹，也可能包括构建和安装通过 `Python Package Index (PyPI) <pypi_>`_ 发布的软件包所需的文件。"

#: ../../source/howto/plugins_develop.rst:31
msgid "Quickstart"
msgstr "快速入门"

#: ../../source/howto/plugins_develop.rst:33
msgid ""
"The fastest way to jumpstart an AiiDA plugin package is to use the `AiiDA "
"plugin cutter <plugin-cutter_>`_ in order to template the basic folder "
"structure, already customized according to the desired name of your plugin, "
"following AiiDA conventions."
msgstr "启动 AiiDA 插件包的最快方法是使用 `AiiDA plugin cutter <plugin-cutter_>`_，以模板化基本文件夹结构。"

#: ../../source/howto/plugins_develop.rst:35
msgid ""
"Simply go to the `AiiDA plugin cutter <plugin-cutter_>`_ and follow the "
"usage instructions. See also the `aiida-diff`_ demo plugin package for an "
"in-depth explanation of the files & folders produced by the plugin cutter."
msgstr "只需访问 `AiiDA plugin cutter <plugin-cutter_>`_ 并按照使用说明操作即可。另请参阅 `aiida-diff`_ 演示插件包，深入了解插件切割器生成的文件和文件夹。"

#: ../../source/howto/plugins_develop.rst:38
msgid ""
"In the following, we explain some of the conventions implemented by the "
"AiiDA plugin cutter."
msgstr "下面，我们将解释 AiiDA 插件切割器的一些约定。"

#: ../../source/howto/plugins_develop.rst:42
msgid "Choosing a name"
msgstr "选择名称"

#: ../../source/howto/plugins_develop.rst:44
msgid ""
"The naming convention for AiiDA plugin packages is ``aiida-mycode`` for the "
"plugin distribution on `PyPI`_ and ``aiida_mycode`` for the corresponding "
"python package, leading to the following folder structure::"
msgstr "AiiDA 插件包的命名规则是：`PyPI`_ 上的插件发布包为 ``aiida-mycode``，相应的 python 包为 ``aiida_mycode``，因此文件夹结构如下：："

#: ../../source/howto/plugins_develop.rst:52
msgid "Python package names cannot contain dashes, thus the underscore."
msgstr "Python 软件包名称不能包含破折号，因此要使用下划线。"

#: ../../source/howto/plugins_develop.rst:54
msgid ""
"If you intend to eventually publish your plugin package, please go to the "
"`AiiDA plugin registry <registry_>`_  and choose a name that is not already "
"taken. You are also encouraged to pre-register your package (instructions "
"provided on the registry), both to reserve your plugin name and to inform "
"others of your ongoing development."
msgstr "如果您打算最终发布您的插件包，请访问 `AiiDA plugin registry <registry_>`_ 并选择一个尚未被使用的名称。我们也鼓励您预先注册您的软件包(注册表上提供了说明)，这样既可以保留您的插件名称，也可以告知他人您正在进行的开发。"

#: ../../source/howto/plugins_develop.rst:61
#: ../../source/howto/plugins_develop.rst:145
msgid "Folder structure"
msgstr "文件夹结构"

#: ../../source/howto/plugins_develop.rst:63
msgid ""
"The overall folder structure of your plugin is up to you, but it is useful "
"to follow a set of basic conventions. Here is an example of a folder "
"structure for an AiiDA plugin, illustrating different levels of nesting (see"
" also the `aiida-diff demo plugin <aiida-diff_>`_)::"
msgstr "插件的整体文件夹结构由你决定，但遵循一套基本的约定是有用的。下面是一个 AiiDA 插件的文件夹结构示例，说明了不同层次的嵌套(另见 `aiida-diff demo plugin <aiida-diff_>`_)：："

#: ../../source/howto/plugins_develop.rst:89
msgid "A minimal plugin package instead might look like::"
msgstr "一个最小的插件包可能是这样的：.....："

#: ../../source/howto/plugins_develop.rst:99
msgid "Registering plugins through entry points"
msgstr "通过 entry points 注册插件"

#: ../../source/howto/plugins_develop.rst:101
msgid ""
"An AiiDA plugin is an extension of AiiDA that announces itself by means of a"
" new *entry point* (for details, see :ref:`topics:plugins:entrypoints`). "
"Adding a new entry point consists of the following steps:"
msgstr "AiiDA 插件是 AiiDA 的一个扩展，它通过一个新的 *entry point* 来宣布自己(详情请参阅 :ref:`topics:plugins:entrypoints`)。添加一个新的 entry point 包括以下步骤："

#: ../../source/howto/plugins_develop.rst:104
msgid ""
"Deciding a name. We *strongly* suggest to start the name of each entry point"
" with the name of the plugin package (omitting the 'aiida-' prefix). For a "
"package ``aiida-mycode``, this will usually mean ``\"mycode.<something>\"``"
msgstr "决定名称。我们*强烈建议每个 entry point 的名称以插件包的名称开头(省略 ``aiida-``前缀)。对于软件包 ``aiida-mycode``，通常指 ``\``mycode.<something>\````"

#: ../../source/howto/plugins_develop.rst:108
msgid ""
"Finding the right entry point group. You can list the entry point groups "
"defined by AiiDA via ``verdi plugin list``. For a documentation of the "
"groups, see :ref:`topics:plugins:entrypointgroups`."
msgstr "查找正确的 entry point 组。你可以通过 ``verdi plugin list`` 列出 AiiDA 定义的 entry point 组。有关组的文档，请参见 :ref:`topics:plugins:entrypointgroups`。"

#: ../../source/howto/plugins_develop.rst:111
msgid ""
"Adding the entry point to the ``entry_points`` field in the "
"``pyproject.toml`` file::"
msgstr "在 ``pyproject.toml`` 文件的 ``entry_points`` 字段中添加 entry point：："

#: ../../source/howto/plugins_develop.rst:118
msgid ""
"Your new entry point should now show up in ``verdi plugin list "
"aiida.calculations``."
msgstr "新的 entry point 现在应该显示在 ``verdi plugin list aiida.calculations`` 中。"

#: ../../source/howto/plugins_develop.rst:122
msgid ""
"Taking a package with the name ``aiida-diff`` as example, what does ``pip "
"install aiida-diff`` do?"
msgstr "以名称为 ``aiida-diff`` 的软件包为例，``pip install aiida-diff`` 的作用是什么？"

#: ../../source/howto/plugins_develop.rst:124
msgid "It resolves and installs the dependencies on other python packages"
msgstr "它会解析并安装其他 python 软件包的依赖关系"

#: ../../source/howto/plugins_develop.rst:125
msgid ""
"It creates a folder ``aiida_diff.egg-info/`` with metadata about the package"
msgstr "它会创建 ``aiida_diff.egg-info/`` 文件夹，其中包含软件包的元数据"

#: ../../source/howto/plugins_develop.rst:126
msgid ""
"If the ``-e`` option is given, a symbolic link from the python package "
"search path to the ``aiida-diff`` directory is created and the ``.egg-info``"
" folder is put there instead. Changes to the **source code** will be picked "
"up by python without reinstalling (when restarting the interpreter),  but "
"changes to the **metadata** will not."
msgstr "如果给出 ``-e``选项，则会从 python 软件包搜索路径创建一个指向 ``aiida-diff`` 目录的符号链接，并将 ``.egg-info`` 文件夹放在该目录下。对 **源代码** 的修改将被 python 接收，无需重新安装(重启解释器时)，但对 **元数据** 的修改不会。"

#: ../../source/howto/plugins_develop.rst:129
msgid ""
"For further details, see the Python `packaging user guide <packaging_>`_."
msgstr "更多详情，请参见 Python `packaging user guide <packaging_>`_。"

#: ../../source/howto/plugins_develop.rst:136
msgid "Testing a plugin package"
msgstr "测试插件包"

#: ../../source/howto/plugins_develop.rst:138
msgid ""
"Writing tests for your AiiDA plugins and running continuous integration "
"tests using free platforms like `GitHub Actions <ghactions_>`_ is the best "
"way to ensure that your plugin works and keeps working as it is being "
"developed. We recommend using the `pytest`_ framework for testing AiiDA "
"plugins."
msgstr "为你的AiiDA插件编写测试，并使用免费平台如`GitHub Actions <ghactions_>`_运行持续集成测试，是确保你的插件工作并在开发过程中持续工作的最好方法。我们推荐使用 `pytest`_ 框架来测试 AiiDA 插件。"

#: ../../source/howto/plugins_develop.rst:141
msgid ""
"For an example of how to write tests and how to set up continuous "
"integration, see the `aiida-diff`_ demo plugin package."
msgstr "有关如何编写测试和如何设置持续集成的示例，请参阅 `aiida-diff`_ 演示插件包。"

#: ../../source/howto/plugins_develop.rst:147
msgid ""
"We suggest the following folder structure for including tests in AiiDA "
"plugin packages::"
msgstr "我们建议在 AiiDA 插件包中包含测试时使用以下文件夹结构：："

#: ../../source/howto/plugins_develop.rst:154
msgid ""
"Keeping the tests outside the plugin package keeps the distribution of your "
"plugin package light."
msgstr "将测试放在插件包之外，可以减少插件包的分发量。"

#: ../../source/howto/plugins_develop.rst:157
msgid "AiiDA's fixtures"
msgstr "AiiDA 的固定装置"

#: ../../source/howto/plugins_develop.rst:159
msgid ""
"Many tests require a full AiiDA environment to be set up before the test "
"starts, e.g. some AiiDA data nodes. The pytest library has the concept of "
"`fixtures`_ for encapsulating code you would like to run before a test "
"starts. AiiDA ships with a number of fixtures in "
":py:mod:`aiida.manage.tests.pytest_fixtures` that take care of setting up "
"the test environment for you (for more details, see "
":ref:`topics:plugins:testfixtures`)."
msgstr "许多测试需要在测试开始前建立完整的 AiiDA 环境，例如一些 AiiDA 数据 nodes。pytest 库有 `fixtures`_ 的概念，用来封装你想在测试开始前运行的代码。AiiDA 在 :py:mod:`aiida.manage.tests.pytest_fixtures` 中附带了许多固定装置，可以为你设置测试环境(更多详情，请参阅 :ref:`topics:plugins:testfixtures`)。"

#: ../../source/howto/plugins_develop.rst:163
msgid ""
"In order to make these fixtures available to your tests, create a "
"``conftest.py`` (see also `pytest docs <conftest_>`_) at the root level of "
"your plugin package as follows::"
msgstr "为了在测试中使用这些固定装置，请在插件包的根级别创建 ``conftest.py`` (另见 `pytest docs <conftest_>`_)，如下所示：："

#: ../../source/howto/plugins_develop.rst:181
msgid ""
"You can now start writing tests e.g. in a ``tests/test_calculations.py`` "
"file::"
msgstr "现在您可以开始编写测试，例如在 ``tests/test_calculations.py`` 文件中：："

#: ../../source/howto/plugins_develop.rst:201
msgid ""
"In order to run your tests, simply type ``pytest`` at the root level or your"
" package. pytest automatically discovers and executes files, classes and "
"function names starting with the word ``test``."
msgstr "pytest 会自动发现并执行以 ``test`` 开头的文件、类和函数名。"

#: ../../source/howto/plugins_develop.rst:211
msgid "Documenting a plugin package"
msgstr "记录插件包"

#: ../../source/howto/plugins_develop.rst:213
msgid ""
"AiiDA plugin packages are python packages, and general `best practises for "
"writing python documentation <https://docs.python-"
"guide.org/writing/documentation/>`_ apply."
msgstr "AiiDA 外挂程序包是 python 程序包，适用于一般 `best practises for writing python documentation <https://docs.python-guide.org/writing/documentation/>`_。"

#: ../../source/howto/plugins_develop.rst:215
msgid ""
"In the following, we mention a few hints that apply specifically to AiiDA "
"plugins."
msgstr "在下文中，我们会提到一些特别适用于 AiiDA 插件的提示。"

#: ../../source/howto/plugins_develop.rst:218
msgid "Repository-level documentation"
msgstr "存储库级文档"

#: ../../source/howto/plugins_develop.rst:220
msgid ""
"Since the source code of most AiiDA plugins is hosted on GitHub, the first "
"contact of a new user with your plugin package is likely the landing page of"
" your GitHub repository."
msgstr "由于大多数 AiiDA 插件的源代码都托管在 GitHub 上，新用户与插件包的第一次接触很可能就是 GitHub 仓库的登陆页面。"

#: ../../source/howto/plugins_develop.rst:222
msgid ""
"Make sure to have a useful ``README.md``, describing what your plugin does "
"and how to install it."
msgstr "确保提供有用的 ``README.md``，说明您的插件的作用和安装方法。"

#: ../../source/howto/plugins_develop.rst:223
msgid "Leaving a contact email and adding a license is also a good idea."
msgstr "留下联系邮箱和添加许可证也是一个好主意。"

#: ../../source/howto/plugins_develop.rst:224
msgid ""
"Make sure the information in the ``pyproject.toml`` file is correct and up "
"to date (in particular the version number), since this information is used "
"to advertise your package on the AiiDA plugin registry."
msgstr "确保 ``pyproject.toml`` 文件中的信息是正确和最新的(尤其是版本号)，因为这些信息用于在 AiiDA 插件注册表中宣传你的软件包。"

#: ../../source/howto/plugins_develop.rst:227
msgid "Source-code-level documentation"
msgstr "源代码级文档"

#: ../../source/howto/plugins_develop.rst:229
msgid ""
"Source-code level documentations matters both for users of your plugin's "
"python API and, particularly, for attracting contributions from others."
msgstr "源代码级别的文档对于使用插件的 python API 的用户，尤其是对于吸引其他人的贡献都很重要。"

#: ../../source/howto/plugins_develop.rst:231
msgid ""
"When adding new types of calculations or workflows, make sure to use "
"`docstrings <https://www.python.org/dev/peps/pep-0257/#what-is-a-"
"docstring>`_, and use the ``help`` argument to document input ports and "
"output ports. Users of your plugin can then inspect which inputs the "
"calculations/workflows expect and which outputs they produce directly "
"through the ``verdi`` cli. For example, try::"
msgstr "添加新的计算或 workflow 时，请确保使用 `docstrings <https://www.python.org/dev/peps/pep-0257/#what-is-a-docstring>`_，并使用 ``help`` 参数记录输入端口和输出端口。这样，插件的用户就可以通过 ``verdi`` cli 直接查看计算/workflow 期望的输入和输出。例如，请尝试：："

#: ../../source/howto/plugins_develop.rst:238
msgid "Documentation website"
msgstr "文件网站"

#: ../../source/howto/plugins_develop.rst:240
msgid ""
"For simple plugins, a well-written ``README.md`` can be a good start. Once "
"the README grows out of proportion, you may want to consider creating a "
"dedicated documentation website."
msgstr "对于简单的插件而言，编写一份完善的 ``README.md`` 可以是一个良好的开端。一旦 README 的篇幅过长，您可能需要考虑创建一个专门的文档网站。"

#: ../../source/howto/plugins_develop.rst:243
msgid ""
"The `Sphinx <http://www.sphinx-doc.org/en/master/>`_ tool makes it very easy"
" to create documentation websites for python packages, and the `ReadTheDocs "
"<http://readthedocs.org/>`_ service will host your sphinx documentation "
"online for free. The `aiida-diff demo plugin <aiida-diff_>`_ comes with a "
"full template for a sphinx-based documentation, including a mix of manually "
"written pages and an automatically generated documentation of your plugin's "
"python API. See the `developer guide of aiida-diff <https://aiida-"
"diff.readthedocs.io/en/latest/developer_guide/index.html>`_ for instructions"
" on how to build it."
msgstr "`Sphinx <http://www.sphinx-doc.org/en/master/>`_ 工具可让您轻松创建 python 软件包的文档网站，而 `ReadTheDocs <http://readthedocs.org/>`_ 服务则可免费在线托管您的 sphinx 文档。`aiida-diff demo plugin <aiida-diff_>`_ 附带基于 sphinx 文档的完整模板，包括手动编写的页面和自动生成的插件 python API 文档。有关如何构建的说明，请参见 `developer guide of aiida-diff <https://aiida-diff.readthedocs.io/en/latest/developer_guide/index.html>`_。"

#: ../../source/howto/plugins_develop.rst:247
msgid ""
"AiiDA provides a sphinx extension for inserting automatically generated "
"documentations of ``Process`` classes (calculations and workflows) into your"
" sphinx documentation (analogous to the information displayed by ``verdi "
"plugin list``). Enable the extension by adding ``aiida.sphinxext`` to the "
"list of ``extensions`` in your ``docs/conf.py`` file. You can now use the "
"``aiida-process``, ``aiida-calcjob`` or ``aiida-workchain`` directives in "
"your ReST files like so::"
msgstr "AiiDA 提供了一个 sphinx 扩展，用于在你的 sphinx 文档中插入自动生成的 ``Process`` 类文档(计算和 workflow)(类似于 ``verdi plugin list`` 显示的信息)。在 ``docs/conf.py`` 文件的 ``extensions`` 列表中添加 ``aiida.sphinxext`` 以启用扩展。现在，您可以在 ReST 文件中使用 ``aiida-process``、``aiida-calcjob`` 或 ``aiida-workchain`` 指令，如：："

#: ../../source/howto/plugins_develop.rst:255
msgid "Here,"
msgstr "给你"

#: ../../source/howto/plugins_develop.rst:257
msgid "``MyWorkChain`` is the name of the workchain to be documented."
msgstr "``MyWorkChain`` 是要记录的工作链名称。"

#: ../../source/howto/plugins_develop.rst:258
msgid ""
"``:module:`` is the python module from which the workchain can be imported."
msgstr "``:module:`` 是 python 模块，工作链可通过该模块进行 import。"

#: ../../source/howto/plugins_develop.rst:259
msgid ""
"``:hide-unstored-inputs:`` hides workchain inputs that are not stored in the"
" database (shown by default)."
msgstr "``:hide-unstored-inputs:`` 隐藏未存储在数据库中的工作链输入(默认显示)。"

#: ../../source/howto/plugins_develop.rst:263
msgid ""
"The ``aiida-workchain`` directive is hooked into ``sphinx.ext.autodoc``, "
"i.e. it is used automatically by the generic ``automodule``, ``autoclass`` "
"directives when applied to workchain classes."
msgstr "``aiida-workchain`` 指令与 ``sphinx.ext.autodoc`` 挂钩，也就是说，当应用于工作链类时，通用的 ``automodule``、``autoclass`` 指令会自动使用该指令。"

#: ../../source/howto/plugins_develop.rst:270
msgid "Publishing a plugin package"
msgstr "发布插件包"

#: ../../source/howto/plugins_develop.rst:272
msgid ""
"AiiDA plugin packages are published on the `AiiDA plugin registry "
"<registry_>`_ and the `python package index (PyPI) <pypi_>`_."
msgstr "AiiDA 插件包发布在 `AiiDA plugin registry <registry_>`_ 和 `python package index (PyPI) <pypi_>`_ 上。"

#: ../../source/howto/plugins_develop.rst:274
msgid "Before publishing your plugin, make sure your plugin comes with:"
msgstr "在发布您的插件之前，请确保您的插件自带："

#: ../../source/howto/plugins_develop.rst:276
msgid ""
"a ``pyproject.toml`` file with the plugin metadata and for installing your "
"plugin via ``pip``"
msgstr "包含插件元数据的 ``pyproject.toml`` 文件，用于通过 ``pip`` 安装插件"

#: ../../source/howto/plugins_develop.rst:277
msgid "a license"
msgstr "执照"

#: ../../source/howto/plugins_develop.rst:279
msgid ""
"For examples of these files, see the `aiida-diff demo plugin <aiida-"
"diff_>`_."
msgstr "有关这些文件的示例，请参见 `aiida-diff demo plugin <aiida-diff_>`_。"

#: ../../source/howto/plugins_develop.rst:284
msgid "Publishing on the plugin registry"
msgstr "在插件注册表上发布"

#: ../../source/howto/plugins_develop.rst:286
msgid ""
"The `AiiDA plugin registry <registry_>`_ aims to be the home for all "
"publicly available AiiDA plugins. It collects information on the type of "
"plugins provided by your package, which AiiDA versions it is compatible "
"with, etc."
msgstr "`AiiDA plugin registry <registry_>`_ 旨在成为所有公开可用的 AiiDA 插件的家园。它收集的信息包括你的软件包提供的插件类型、与哪些 AiiDA 版本兼容等。"

#: ../../source/howto/plugins_develop.rst:289
msgid ""
"In order to register your plugin package, simply go to the `plugin registry "
"<registry_>`_ and follow the instructions in the README."
msgstr "要注册您的插件包，只需访问 `plugin registry <registry_>`_ 并按照 README 中的说明操作即可。"

#: ../../source/howto/plugins_develop.rst:293
msgid ""
"The plugin registry reads the metadata of your plugin from the "
"``pyproject.toml`` file in your plugin repository."
msgstr "插件注册表会从插件库中的 ``pyproject.toml`` 文件读取插件的元数据。"

#: ../../source/howto/plugins_develop.rst:296
msgid ""
"We encourage you to **get your plugin package listed as soon as possible**, "
"both in order to reserve the plugin name and to inform others of the ongoing"
" development."
msgstr "我们鼓励您 **尽快列出您的插件包** ，以便保留插件名称，并告知其他人正在进行的开发。"

#: ../../source/howto/plugins_develop.rst:299
msgid "Publishing on PyPI"
msgstr "在 PyPI 上发布"

#: ../../source/howto/plugins_develop.rst:301
msgid ""
"For distributing AiiDA plugin packages, we recommend to follow the "
"`guidelines for packaging python projects <packaging_>`_, which include "
"making the plugin available on the `python package index <PyPI_>`_. This "
"makes it possible for users to simply ``pip install aiida-myplugin``."
msgstr "对于分发 AiiDA 插件包，我们建议遵循 `guidelines for packaging python projects <packaging_>`_，其中包括在 `python package index <PyPI_>`_ 上提供插件。这使得用户可以简单地 ``pip install aiida-myplugin``。"

#: ../../source/howto/plugins_install.rst:5
msgid "How to install plugins"
msgstr "如何安装插件"

#: ../../source/howto/plugins_install.rst:7
msgid ""
"The functionality of AiiDA can be extended through plugins. There are "
"various types of functionality that can be extended, such as new :ref:`data "
"types<topics:data_types:plugin>`, :ref:`calculation plugins<how-to:plugin-"
"codes>` and much more. Multiple plugins can be bundled together and "
"distributed in a :ref:`plugin package<how-to:plugins-develop>`. The `AiiDA "
"plugin registry <https://aiidateam.github.io/aiida-registry>`_ gives an "
"overview of public plugin packages."
msgstr "AiiDA 的功能可以通过插件扩展。有多种类型的功能可以扩展，如新的 :ref:`data types<topics:data_types:plugin>`、:ref:`calculation plugins<how-to:plugin-codes>` 等等。多个插件可以捆绑在一起，并在 :ref:`plugin package<how-to:plugins-develop>` 中发布。`AiiDA plugin registry <https://aiidateam.github.io/aiida-registry>`_ 概述了公共插件包。"

#: ../../source/howto/plugins_install.rst:12
msgid ""
"Installing an AiiDA plugin package is done with `pip "
"<https://pypi.org/project/pip/>`_. If the package is distributed via the "
"`Python Package Index (PyPI) <https://pypi.org/search/?q=aiida>`_ you can "
"install it as follows:"
msgstr "使用 `pip <https://pypi.org/project/pip/>`_ 安装 AiiDA 插件包。如果软件包是通过 `Python Package Index (PyPI) <https://pypi.org/search/?q=aiida>`_ 发布的，你可以按如下方法安装："

#: ../../source/howto/plugins_install.rst:19
msgid ""
"A package can also be installed from the source code. For example, if the "
"code is available through a Git repository:"
msgstr "软件包也可以从源代码中安装。例如，如果代码可通过 Git 仓库获取："

#: ../../source/howto/plugins_install.rst:30
msgid ""
"If your daemon was running when installing or updating a plugin package, "
"make sure to restart it with the ``--reset`` flag for changes to take "
"effect:"
msgstr "如果您的守护进程在安装或更新插件包时正在运行，请确保使用 ``--reset`` 标志重新启动守护进程，以使更改生效："

#: ../../source/howto/plugins_install.rst:36
msgid "To verify which plugins are currently installed, use the command:"
msgstr "要验证当前安装了哪些插件，请使用以下命令："

#: ../../source/howto/plugins_install.rst:42
msgid ""
"It will list the various categories of functionality that can be extended "
"through plugins. To see which plugins are installed for any of these "
"categories, pass the category name as an argument, e.g.:"
msgstr "它将列出可通过插件扩展的各类功能。要查看这些类别中安装了哪些插件，请将类别名称作为参数传递，例如"

#: ../../source/howto/query.rst:5
msgid "How to find and query for data"
msgstr "如何查找和查询数据"

#: ../../source/howto/query.rst:7
msgid ""
"An AiiDA database stores a graph of connected entities, which can be "
"*queried* with the :class:`~aiida.orm.querybuilder.QueryBuilder` class."
msgstr "AiiDA 数据库存储了一个连接实体的图形，可以用 :class:`~aiida.orm.querybuilder.QueryBuilder` 类进行*查询。"

#: ../../source/howto/query.rst:9
msgid "Before starting to write a query, it helps to:"
msgstr "在开始撰写查询之前，最好先"

#: ../../source/howto/query.rst:0
msgid "Know what you want to query for."
msgstr "了解您要查询的内容。"

#: ../../source/howto/query.rst:0
msgid ""
"In the language of databases, you need to tell the backend what *entity* you"
" are looking for and optionally which of its properties you want to "
"*project*."
msgstr "在数据库语言中，您需要告诉后端您要查找的 *实体* ，以及您要 *投影* 的 *实体* 属性。"

#: ../../source/howto/query.rst:0
msgid ""
"For example, you might be interested in the label of a calculation and the "
"PKs of all its outputs."
msgstr "例如，您可能对某个计算的标签及其所有输出的 PKs 感兴趣。"

#: ../../source/howto/query.rst:0
msgid "Know the relationships between entities you are interested in."
msgstr "了解您感兴趣的实体之间的关系。"

#: ../../source/howto/query.rst:0
msgid "Nodes of an AiiDA graph (vertices) are connected with links (edges)."
msgstr "AiiDA 图的 Node 个点(顶点)通过链接(边)相连。"

#: ../../source/howto/query.rst:0
msgid ""
"A node can for example be either the input or output of another node, but "
"also an ancestor or a descendant."
msgstr "例如，一个 node 可以是另一个 node 的输入或输出，也可以是祖先或后代。"

#: ../../source/howto/query.rst:0
msgid "Know how you want to filter the results of your query."
msgstr "了解如何过滤查询结果。"

#: ../../source/howto/query.rst:19
msgid ""
"Once you are clear about what you want and how you can get it, the "
":class:`~aiida.orm.querybuilder.QueryBuilder` will build an SQL-query for "
"you."
msgstr "一旦您清楚自己想要什么以及如何获得这些信息，:class:`~aiida.orm.querybuilder.QueryBuilder` 就会为您创建一个 SQL 查询。"

#: ../../source/howto/query.rst:21
msgid ""
"There are two ways of using the "
":class:`~aiida.orm.querybuilder.QueryBuilder`:"
msgstr "使用 :class:`~aiida.orm.querybuilder.QueryBuilder` 有两种方法："

#: ../../source/howto/query.rst:23
msgid ""
"In the *appender* method, you construct your query step by step using the "
"``QueryBuilder.append()`` method."
msgstr "在 *appender* 方法中，您使用 ``QueryBuilder.append()`` 方法逐步构建查询。"

#: ../../source/howto/query.rst:24
msgid ""
"In the *dictionary* approach, you construct a dictionary that defines your "
"query and pass it to the :class:`~aiida.orm.querybuilder.QueryBuilder`."
msgstr "在 *字典* 方法中，您需要构建一个定义查询的字典，并将其传递给 :class:`~aiida.orm.querybuilder.QueryBuilder`。"

#: ../../source/howto/query.rst:26
msgid ""
"Both APIs provide the same functionality - the appender method may be more "
"suitable for interactive use, e.g., in the ``verdi shell``, whereas the "
"dictionary method can be useful in scripting. In this section we will focus "
"on the basics of the appender method. For more advanced queries or more "
"details on the query dictionary, see the :ref:`topics section on advanced "
"querying <topics:database:advancedquery>`."
msgstr "这两种应用程序接口提供相同的功能--附加器方法可能更适合交互式使用，例如在 ``verdi shell`` 中，而字典方法在脚本中可能很有用。在本节中，我们将重点介绍附加器方法的基础知识。有关更高级的查询或查询字典的更多详情，请参阅 :ref:`topics section on advanced querying <topics:database:advancedquery>`。"

#: ../../source/howto/query.rst:33
msgid "Selecting entities"
msgstr "选择实体"

#: ../../source/howto/query.rst:35
msgid ""
"Using the ``append()`` method of the "
":class:`~aiida.orm.querybuilder.QueryBuilder`, you can query for the "
"entities you are interested in. Suppose you want to query for calculation "
"job nodes in your database:"
msgstr "使用 :class:`~aiida.orm.querybuilder.QueryBuilder` 的 ``append()`` 方法，可以查询您感兴趣的实体。假设您想查询数据库中的计算作业 nodes："

#: ../../source/howto/query.rst:44
msgid ""
"If you are interested in instances of different classes, you can also pass "
"an iterable of classes. However, they have to be of the same ORM-type (e.g. "
"all have to be subclasses of :class:`~aiida.orm.nodes.node.Node`):"
msgstr "如果您对不同类的实例感兴趣，也可以传递一个可迭代类。不过，它们必须是相同的 ORM 类型(例如，所有类都必须是 :class:`~aiida.orm.nodes.node.Node` 的子类)："

#: ../../source/howto/query.rst:54
msgid ""
"Processes have both a run-time "
":class:`~aiida.engine.processes.process.Process` that executes them and a "
":class:`~aiida.orm.nodes.node.Node` that stores their data in the database "
"(see the :ref:`corresponding topics "
"section<topics:processes:concepts:types>` for a detailed explanation). The "
":class:`~aiida.orm.querybuilder.QueryBuilder` allows you to pass either the "
":class:`~aiida.orm.nodes.node.Node` class (e.g. "
":class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode`) or the "
":class:`~aiida.engine.processes.process.Process` class (e.g. "
":class:`~aiida.engine.processes.calcjobs.calcjob.CalcJob`), which will "
"automatically select the right entity for the query. Using either "
":class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode` or "
":class:`~aiida.engine.processes.calcjobs.calcjob.CalcJob` will produce the "
"same query results."
msgstr "进程既有执行进程的运行时 :class:`~aiida.engine.processes.process.Process`，也有在数据库中存储数据的 :class:`~aiida.orm.nodes.node.Node`(详见 :ref:`corresponding topics section<topics:processes:concepts:types>` 的解释)。:class:`~aiida.orm.querybuilder.QueryBuilder` 允许您传递 :class:`~aiida.orm.nodes.node.Node` 类(如 :class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode`)或 :class:`~aiida.engine.processes.process.Process` 类(如 :class:`~aiida.engine.processes.calcjobs.calcjob.CalcJob`)，这将自动为查询选择正确的实体。使用 :class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode` 或 :class:`~aiida.engine.processes.calcjobs.calcjob.CalcJob` 将产生相同的查询结果。"

#: ../../source/howto/query.rst:61
msgid "Retrieving results"
msgstr "检索结果"

#: ../../source/howto/query.rst:63
msgid ""
"Once you have *appended* the entity you want to query for to the "
":class:`~aiida.orm.querybuilder.QueryBuilder`, the next question is how to "
"get the results. There are several ways to obtain data from a query:"
msgstr "将要查询的实体应用到 :class:`~aiida.orm.querybuilder.QueryBuilder` 后，下一个问题就是如何获取查询结果。从查询中获取数据有几种方法："

#: ../../source/howto/query.rst:79
msgid ""
"If your query only has a single projection, use ``flat=True`` in the "
"``first`` and ``all`` methods to return a single value or a flat list, "
"respectively."
msgstr "如果您的查询只有一个投影，请在 ``first`` 和 ``all`` 方法中使用 ``flat=True`` 分别返回单个值或平面列表。"

#: ../../source/howto/query.rst:81
msgid "You can also return your query as a generator:"
msgstr "您也可以将查询作为生成器返回："

#: ../../source/howto/query.rst:88
msgid ""
"This will retrieve the data in batches, and you can start working with the "
"data before the query has completely finished. For example, you can iterate "
"over the results of your query in a for loop:"
msgstr "这样就可以分批检索数据，在查询完全结束之前就可以开始处理数据。例如，可以在 for 循环中遍历查询结果："

#: ../../source/howto/query.rst:98
msgid ""
"When looping over the result of a query, use the ``iterall`` (or "
"``iterdict``) generator instead of ``all`` (or ``dict``). This avoids "
"loading the entire query result into memory, and it also delays committing "
"changes made to AiiDA objects inside the loop until the end of the loop is "
"reached. If an exception is raised before the loop ends, all changes are "
"reverted."
msgstr "当循环查询结果时，使用 ``iterall`` (或 ``iterdict``) 生成器而不是 ``all`` (或 ``dict``)。这样可以避免将整个查询结果加载到内存中，也可以延迟提交循环中对 AiiDA 对象的修改，直到循环结束。如果在循环结束前出现异常，所有的修改都会被还原。"

#: ../../source/howto/query.rst:106
msgid "Filters"
msgstr "过滤器"

#: ../../source/howto/query.rst:108
msgid ""
"Usually you do not want to query for *all* entities of a certain class, but "
"rather *filter* the results based on certain properties. Suppose you do not "
"want all :class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode` "
"data, but only those that are ``finished``:"
msgstr "通常情况下，您并不想查询某一类别的 *所有* 实体，而是根据某些属性对结果进行*过滤。假设您不想要所有 :class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode` 数据，而只想要 ``finished`` 的数据："

#: ../../source/howto/query.rst:121
msgid ""
"You can apply multiple filters to one entity in a query. Say you are "
"interested in all calculation jobs in your database that are ``finished`` "
"**and** have ``exit_status == 0``:"
msgstr "您可以在查询中对一个实体应用多个过滤器。例如，您想查询数据库中 ``finished`` ***和***有 ``exit_status == 0`` 的所有计算作业："

#: ../../source/howto/query.rst:135
msgid ""
"In case you want to query for calculation jobs that satisfy one of these "
"conditions, you can use the ``or`` operator:"
msgstr "如果要查询满足这些条件之一的计算作业，可以使用 ``or`` 操作符："

#: ../../source/howto/query.rst:150
msgid ""
"If we had written ``and`` instead of ``or`` in the example above, we would "
"have performed the exact same query as the previous one, because ``and`` is "
"the default behavior if you provide several filters as key-value pairs in a "
"dictionary to the ``filters`` argument. In case you want all calculation "
"jobs with state ``finished`` or ``excepted``, you can also use the ``in`` "
"operator:"
msgstr "如果我们在上面的示例中写的是 ``and``，而不是 ``or``，我们就会执行与前面的查询完全相同的查询，因为 ``and`` 是向 ``filters`` 参数提供多个过滤器作为 dictionary 中键值对的默认行为。如果希望所有计算作业的状态都是 ``finished`` 或 ``excepted``，也可以使用 ``in`` 操作符："

#: ../../source/howto/query.rst:166
msgid "Operator negations"
msgstr "运算符否定"

#: ../../source/howto/query.rst:168
msgid ""
"A filter can be turned into its associated **negation** by adding an "
"exclamation mark, ``!``, in front of the operator. So, to query for all "
"calculation jobs that are not a ``finished`` or ``excepted`` state:"
msgstr "通过在运算符前添加感叹号 ``!``，可以将过滤器转换为相关的 **否定** 。因此，要查询所有非 ``finished`` 或 ``excepted`` 状态的计算作业，请执行以下操作"

#: ../../source/howto/query.rst:183
msgid ""
"The above rule applies to all operators. For example, you can check non-"
"equality with ``!==``, since this is the equality operator (``==``) with a "
"negation prepended."
msgstr "上述规则适用于所有运算符。例如，您可以用 ``!==`` 检查非相等运算符，因为它是带否定前置的相等运算符 (``==``)。"

#: ../../source/howto/query.rst:186
msgid ""
"A complete list of all available operators can be found in the "
":ref:`advanced querying "
"section<topics:database:advancedquery:tables:operators>`."
msgstr "所有可用操作符的完整列表可在 :ref:`advanced querying section<topics:database:advancedquery:tables:operators>` 中找到。"

#: ../../source/howto/query.rst:191
msgid "Relationships"
msgstr "关系"

#: ../../source/howto/query.rst:193
msgid ""
"It is possible to query for data based on its relationship to another entity"
" in the database. Imagine you are not interested in the calculation jobs "
"themselves, but in one of the outputs they create. You can build upon your "
"initial query for all  "
":class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode`'s in the "
"database using the relationship of the output to the first step in the "
"query:"
msgstr "可以根据数据与数据库中另一个实体的关系来查询数据。试想一下，您对计算作业本身不感兴趣，但对它们创建的某个输出结果感兴趣。您可以利用输出与查询第一步的关系，对数据库中的所有 :class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode` 进行初步查询："

#: ../../source/howto/query.rst:203
msgid ""
"In the first ``append`` call, we query for all  "
":class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode`'s in the "
"database, and *tag* this step with the *unique* identifier ``'calcjob'``. "
"Next, we look for all ``Int`` nodes that are an output of the  "
":class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode`'s found in"
" the first step, using the ``with_incoming`` relationship argument. The "
"``Int`` node was created by the  "
":class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode` and as "
"such has an *incoming* create link."
msgstr "在第一个 ``append`` 调用中，我们查询数据库中的所有 :class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode`，并在此步骤中 *标记* 唯一*标识符 ``'calcjob'``。接下来，我们使用 ``with_incoming`` 关系参数查找所有 ``Int`` node 文件，它们是第一步中找到的 :class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode` 的输出。``Int`` node 是由 :class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode` 创建的，因此有一个 * 传入 * 创建链接。"

#: ../../source/howto/query.rst:207
msgid ""
"In the context of our query, we are building a *path* consisting of "
"*vertices* (i.e. the entities we query for) connected by *edges* defined by "
"the relationships between them. The complete set of all possible "
"relationships you can use query for, as well as the entities that they "
"connect to, can be found in the :ref:`advanced querying "
"section<topics:database:advancedquery:tables:relationships>`."
msgstr "在我们查询的上下文中，我们正在构建一条 *路径* ，它由 *顶点* (即我们查询的实体)和 *边* 组成， *边* 由它们之间的关系定义。您可以在 :ref:`advanced querying section<topics:database:advancedquery:tables:relationships>` 中找到所有可能的查询关系及其连接的实体的完整集合。"

#: ../../source/howto/query.rst:212
msgid ""
"The ``tag`` identifier can be any alphanumeric string, it is simply a label "
"used to refer to a previous vertex along the query path when defining a "
"relationship."
msgstr "``tag`` 标识符可以是任何字母数字字符串，它只是一个标签，用于在定义关系时引用查询路径上的前一个顶点。"

#: ../../source/howto/query.rst:217
msgid "Projections"
msgstr "预测"

#: ../../source/howto/query.rst:219
msgid ""
"By default, the :class:`~aiida.orm.querybuilder.QueryBuilder` returns the "
"instances of the entities corresponding to the final append to the query "
"path. For example:"
msgstr "默认情况下，:class:`~aiida.orm.querybuilder.QueryBuilder` 会返回与查询路径的最后附加部分相对应的实体实例。例如"

#: ../../source/howto/query.rst:228
msgid ""
"The above code snippet will return all ``Int`` nodes that are outputs of any"
"  :class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode`. "
"However, you can also *project* other entities in the path by adding "
"``project='*'`` to the corresponding ``append()`` call:"
msgstr "上述代码片段将返回任何 :class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode` 输出的所有 ``Int`` node。不过，您也可以通过在相应的 ``append()`` 调用中添加 ``project='*'`` 来 *project* 路径中的其他实体："

#: ../../source/howto/query.rst:237
msgid ""
"This will return all  "
":class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode`'s that "
"have an ``Int`` output node."
msgstr "这将返回所有具有 ``Int`` 输出 node 的 :class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode`。"

#: ../../source/howto/query.rst:239
msgid ""
"However, in many cases we are not interested in the entities themselves, but"
" rather their PK, UUID, *attributes* or some other piece of information "
"stored by the entity. This can be achieved by providing the corresponding "
"*column* to the ``project`` keyword argument:"
msgstr "不过，在很多情况下，我们感兴趣的不是实体本身，而是实体的 PK、UUID、 *属性* 或实体存储的其他信息。这可以通过向 ``project`` 关键字参数提供相应的 *列* 来实现："

#: ../../source/howto/query.rst:248
msgid ""
"In the above example, executing the query returns all *PK's* of the ``Int`` "
"nodes which are outputs of all  "
":class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode`'s in the "
"database. Moreover, you can project more than one piece of information for "
"one vertex by providing a list:"
msgstr "在上例中，执行查询会返回 ``Int`` node 的所有 *PK's* ，这些 *PK's* 是数据库中所有 :class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode` 的输出。此外，您还可以通过提供一个列表，为一个顶点预测多个信息："

#: ../../source/howto/query.rst:257
msgid ""
"For the query above, ``qb.all()`` will return a list of lists, for which "
"each element corresponds to one entity and contains two items: the PK of the"
" ``Int`` node and its value. Finally, you can project information for "
"multiple vertices along the query path:"
msgstr "对于上述查询，``qb.all()`` 将返回一个列表，其中每个元素对应一个实体，并包含两个项目：``Int`` 的 PK node 及其值。最后，您可以沿查询路径投影多个顶点的信息："

#: ../../source/howto/query.rst:266
msgid ""
"All projections must start with one of the *columns* of the entities in the "
"database, or project the instances themselves using ``'*'``. Examples of "
"columns we have encountered so far are ``id``, ``uuid`` and ``attributes``. "
"If the column is a dictionary, you can expand the dictionary values using a "
"dot notation, as we have done in the previous example to obtain the "
"``attributes.value``. This can be used to project the values of nested "
"dictionaries as well."
msgstr "所有投影必须以数据库中实体的 *列* 之一开始，或使用 ``'*'`` 投射实例本身。目前我们遇到的列示例有 ``id``、``uuid`` 和 ``attributes``。如果列是一个字典，则可以使用点号展开字典值，就像我们在前面的示例中获得 ``attributes.value``一样。这也可用于投影嵌套字典的值。"

#: ../../source/howto/query.rst:273
msgid ""
"Be aware that for consistency, ``QueryBuilder.all()`` / ``iterall()`` always"
" returns a list of lists, even if you only project one property of a single "
"entity. Use ``QueryBuilder.all(flat=True)`` to return the query result as a "
"flat list in this case."
msgstr "请注意，为了保持一致性，``QueryBuilder.all()`` / ``iterall()`` 总是返回一个列表，即使您只预测了单个实体的一个属性。在这种情况下，请使用 ``QueryBuilder.all(flat=True)`` 以平面列表的形式返回查询结果。"

#: ../../source/howto/query.rst:276
msgid ""
"As mentioned in the beginning, this section provides only a brief "
"introduction to the :class:`~aiida.orm.querybuilder.QueryBuilder`'s basic "
"functionality. To learn about more advanced queries, please see :ref:`the "
"corresponding topics section<topics:database:advancedquery>`."
msgstr "如开头所述，本节仅简要介绍 :class:`~aiida.orm.querybuilder.QueryBuilder` 的基本功能。要了解更多高级查询，请参阅 :ref:`the corresponding topics section<topics:database:advancedquery>`。"

#: ../../source/howto/query.rst:284
msgid "Shortcuts"
msgstr "捷径"

#: ../../source/howto/query.rst:286
msgid ""
"The :class:`~aiida.orm.querybuilder.QueryBuilder` is the generic way of "
"querying for data in AiiDA. For certain common queries, shortcuts have been "
"added to the AiiDA python API to save you a couple of lines of code."
msgstr " :class:`~aiida.orm.querybuilder.QueryBuilder` 是在 AiiDA 中查询数据的通用方法。对于某些常见的查询，AiiDA python API 添加了快捷方式，以节省几行代码。"

#: ../../source/howto/query.rst:292
msgid "Incoming and outgoing links"
msgstr "输入和输出链接"

#: ../../source/howto/query.rst:294
msgid ""
"The provenance graph in AiiDA is a :ref:`directed graph "
"<topics:provenance:concepts>`. The vertices of the graph are the *nodes*, "
"and the edges that connect them are called *links*. Since the graph is "
"directed, any node can have *incoming* and *outgoing* links that connect it "
"to neighboring nodes."
msgstr "AiiDA 中的 provenance graph 是 :ref:`directed graph <topics:provenance:concepts>`。图中的顶点是 *nodes* ，连接它们的边称为 *链接* 。由于图是有向的，因此任何一个 node 都可以有连接到相邻 node 的 *入链* 和 *出链* 。"

#: ../../source/howto/query.rst:298
msgid ""
"To discover the neighbors of a given node, you can use the methods "
":meth:`~aiida.orm.nodes.links.NodeLinks.get_incoming` and "
":meth:`~aiida.orm.nodes.links.NodeLinks.get_outgoing`. They have the exact "
"same interface but will return the neighbors connected to the current node "
"with a link coming into it or with links going out of it, respectively. For "
"example, for a given ``node``, to inspect all the neighboring nodes from "
"which a link is incoming to the ``node``:"
msgstr "要查找指定 node 的邻居，可以使用 :meth:`~aiida.orm.nodes.links.NodeLinks.get_incoming` 和 :meth:`~aiida.orm.nodes.links.NodeLinks.get_outgoing` 方法。这两个方法的接口完全相同，但会分别返回与当前 node 相连并有链路进入或有链路出去的邻居。例如，对于给定的 ``node``，要检查所有有链接进入该 ``node`` 的邻接 node："

#: ../../source/howto/query.rst:306
msgid ""
"This will return an instance of the "
":class:`~aiida.orm.utils.links.LinkManager`. From that manager, you can "
"request the results in a specific format. If you are only interested in the "
"neighboring nodes themselves, you can call the "
":class:`~aiida.orm.utils.links.LinkManager.all_nodes` method:"
msgstr "这将返回一个 :class:`~aiida.orm.utils.links.LinkManager` 实例。您可以通过该管理器以特定格式请求结果。如果您只对相邻的 nodes 本身感兴趣，可以调用 :class:`~aiida.orm.utils.links.LinkManager.all_nodes` 方法："

#: ../../source/howto/query.rst:314
msgid ""
"This will return a list of :class:`~aiida.orm.nodes.node.Node` instances "
"that correspond to the nodes that are neighbors of ``node``, where the link "
"is going towards ``node``. Calling the "
":meth:`~aiida.orm.utils.links.LinkManager.all` method of the manager instead"
" will return a list of :class:`~aiida.orm.utils.links.LinkTriple` named "
"tuples. These tuples contain, in addition to the neighboring node, also the "
"link label and the link type with which they are connected to the origin "
"``node``. For example, to list all the neighbors of a node from which a link"
" is incoming:"
msgstr "这将返回一个 :class:`~aiida.orm.nodes.node.Node` 实例的列表，这些实例与 ``node`` 的 node 相邻，其中链接指向 ``node``。调用管理器的 :meth:`~aiida.orm.utils.links.LinkManager.all` 方法将返回一个名为 :class:`~aiida.orm.utils.links.LinkTriple` 的元组列表。这些图元除了包含邻接 node 外，还包含与原点 ``node`` 连接的链路标签和链路类型。例如，要列出 node 的所有邻接区，其中有一条链接来自该邻接区："

#: ../../source/howto/query.rst:324
msgid ""
"Note that the :class:`~aiida.orm.utils.links.LinkManager` provides many "
"convenience methods to get information from the neigboring nodes, such as "
":meth:`~aiida.orm.utils.links.LinkManager.all_link_labels` if you only need "
"the list of link labels."
msgstr "请注意，:class:`~aiida.orm.utils.links.LinkManager` 提供了许多从邻近 node 获取信息的便捷方法，例如，如果您只需要链接标签列表，可使用 :meth:`~aiida.orm.utils.links.LinkManager.all_link_labels`。"

#: ../../source/howto/query.rst:326
msgid ""
"The :meth:`~aiida.orm.nodes.links.NodeLinks.get_incoming` and "
":meth:`~aiida.orm.nodes.links.NodeLinks.get_outgoing` methods accept various"
" arguments that allow one to filter what neighboring nodes should be "
"matched:"
msgstr " :meth:`~aiida.orm.nodes.links.NodeLinks.get_incoming` 和 :meth:`~aiida.orm.nodes.links.NodeLinks.get_outgoing` 方法接受各种参数，允许筛选哪些相邻的 node 应该匹配："

#: ../../source/howto/query.rst:328
msgid ""
"``node_class``: accepts a subclass of :class:`~aiida.orm.nodes.node.Node`, "
"only neighboring nodes with a class that matches this will be returned"
msgstr "``node_class``：接受 :class:`~aiida.orm.nodes.node.Node` 的子类，只返回与该类匹配的相邻 nodes"

#: ../../source/howto/query.rst:329
msgid ""
"``link_type``: accepts a value of :class:`~aiida.common.links.LinkType`, "
"only neighboring nodes that are linked with this link type will be returned"
msgstr "``link_type``：接受 :class:`~aiida.common.links.LinkType` 的值，只返回与此链接类型链接的邻接 node"

#: ../../source/howto/query.rst:330
msgid ""
"``link_label_filter``: accepts a string  expression (with optional wildcards"
" using the syntax of SQL ``LIKE`` patterns, see below), only neighboring "
"nodes that are linked with a link label that matches the pattern will be "
"returned"
msgstr "``link_label_filter``：接受字符串表达式(可选通配符，使用 SQL ``LIKE`` 模式的语法，见下文)，只返回链接标签与模式匹配的邻接 nodes"

#: ../../source/howto/query.rst:332
msgid "As an example:"
msgstr "举个例子"

#: ../../source/howto/query.rst:338
msgid ""
"will return only neighboring data nodes that are linked to the ``node`` with"
" a link of type ``LinkType.INPUT_CALC`` and where the link label matches the"
" pattern ``'output%node_'``. Reminder on the syntax of SQL `LIKE` patterns: "
"the ``%`` character matches any string of zero or more characters, while the"
" ``_`` character matches exactly one character. These two special characters"
" can be escaped by prepending them with a backslash (note that when putting "
"a backslash in a Python string you have to escape the backslash itself, so "
"you will need two backslashes: e.g., to match exactly a link label ``a_b`` "
"you need to pass ``link_label_filter='a\\\\_b'``)."
msgstr "将只返回与 ``node`` 有链接且链接类型为 ``LinkType.INPUT_CALC``、链接标签符合模式 ``'output%node_'`` 的相邻数据 node。提醒注意 SQL 语法 FDBE30B3FBACC16Fa_bA400F8A5link_label_filter='a\\\\_b'``)。"

#: ../../source/howto/query.rst:346
msgid "Inputs and outputs of processes"
msgstr "流程的输入和输出"

#: ../../source/howto/query.rst:348
msgid ""
"The :meth:`~aiida.orm.nodes.links.NodeLinks.get_incoming` and "
":meth:`~aiida.orm.nodes.links.NodeLinks.get_outgoing` methods, described in "
"the :ref:`previous section <how-to:query:shortcuts:incoming-outgoing>`, can "
"be used to access all neighbors from a certain node and provide advanced "
"filtering options. However, often one doesn't need this expressivity and "
"simply wants to retrieve all neighboring nodes with a syntax that is as "
"succint as possible. A prime example is to retrieve the *inputs* or "
"*outputs* of :ref:`a process <topics:processes:concepts>`. Instead of using "
":meth:`~aiida.orm.nodes.links.NodeLinks.get_incoming` and "
":meth:`~aiida.orm.nodes.links.NodeLinks.get_outgoing`, to get the inputs and"
" outputs of a ``process_node`` one can do:"
msgstr " :ref:`previous section <how-to:query:shortcuts:incoming-outgoing>` 中描述的 :meth:`~aiida.orm.nodes.links.NodeLinks.get_incoming` 和 :meth:`~aiida.orm.nodes.links.NodeLinks.get_outgoing` 方法可用于访问某个 node 的所有邻居，并提供高级过滤选项。不过，人们往往不需要这种表达能力，而只想用尽可能简洁的语法检索所有相邻的 node。一个典型的例子是检索 :ref:`a process <topics:processes:concepts>` 的 *输入* 或 *输出* 。要获取 ``process_node`` 的输入和输出，可以不使用 :meth:`~aiida.orm.nodes.links.NodeLinks.get_incoming` 和 :meth:`~aiida.orm.nodes.links.NodeLinks.get_outgoing`，而使用"

#: ../../source/howto/query.rst:358
msgid ""
"These properties do not return the actual inputs and outputs directly, but "
"instead return an instance of "
":class:`~aiida.orm.utils.managers.NodeLinksManager`. The reason is because "
"through the manager, the inputs or outputs are accessible through their link"
" label (that, for inputs and outputs of processes, is unique) and can be "
"tab-completed. For example, if the ``process_node`` has an output with the "
"label ``result``, it can be retrieved as:"
msgstr "这些属性不会直接返回实际的输入和输出，而是返回 :class:`~aiida.orm.utils.managers.NodeLinksManager` 的实例。原因是通过管理器，输入或输出可以通过其链接标签(对于流程的输入和输出，链接标签是唯一的)进行访问，并可以用制表符完成。例如，如果 ``process_node`` 有一个标签为 ``result`` 的输出，则可以按以下方式检索："

#: ../../source/howto/query.rst:366
msgid "The inputs or outputs can also be accessed through key dereferencing:"
msgstr "输入或输出也可以通过键的反向引用来访问："

#: ../../source/howto/query.rst:372
msgid ""
"If there is no neighboring output with the given link label, a "
":class:`~aiida.common.exceptions.NotExistentAttributeError` or "
":class:`~aiida.common.exceptions.NotExistentKeyError` will be raised, "
"respectively."
msgstr "如果没有与给定链接标签相邻的输出，将分别出现 :class:`~aiida.common.exceptions.NotExistentAttributeError` 或 :class:`~aiida.common.exceptions.NotExistentKeyError`。"

#: ../../source/howto/query.rst:376
msgid ""
"The ``inputs`` and ``outputs`` properties are only defined for "
":class:`~aiida.orm.nodes.process.process.ProcessNode`'s. This means that you"
" cannot *chain* these calls, because an input or output of a process node is"
" guaranteed to be a :class:`~aiida.orm.Data` node, which does not have "
"inputs or outputs."
msgstr "``inputs`` 和 ``outputs`` 属性仅为 :class:`~aiida.orm.nodes.process.process.ProcessNode` 定义。这意味着不能 *chain* 这些调用，因为进程 node 的输入或输出保证是 :class:`~aiida.orm.Data` node，而后者没有输入或输出。"

#: ../../source/howto/query.rst:383
msgid "Creator, caller and called"
msgstr "创造者、召唤者和被召唤者"

#: ../../source/howto/query.rst:385
msgid ""
"Similar to the ``inputs`` and ``outputs`` properties of process nodes, there"
" are some more properties that make exploring the provenance graph easier:"
msgstr "与进程 node 的 ``inputs`` 和 ``outputs`` 属性类似，还有一些属性可以让我们更容易地探索 provenance graph："

#: ../../source/howto/query.rst:387
msgid ""
":meth:`~aiida.orm.nodes.process.process.ProcessNode.called`: defined for "
":class:`~aiida.orm.nodes.process.process.ProcessNode`'s and returns the list"
" of process nodes called by this node. If this process node did not call any"
" other processes, this property returns an empty list."
msgstr " :meth:`~aiida.orm.nodes.process.process.ProcessNode.called`：为 :class:`~aiida.orm.nodes.process.process.ProcessNode` 定义，返回此 node 调用的进程 node 的列表。如果此进程 node 未调用任何其他进程，则此属性返回空列表。"

#: ../../source/howto/query.rst:389
msgid ""
":meth:`~aiida.orm.nodes.process.process.ProcessNode.caller`: defined for "
":class:`~aiida.orm.nodes.process.process.ProcessNode`'s and returns the "
"process node that called this node. If this node was not called by a "
"process, this property returns ``None``."
msgstr " :meth:`~aiida.orm.nodes.process.process.ProcessNode.caller`：为 :class:`~aiida.orm.nodes.process.process.ProcessNode` 定义，返回调用此 node 的进程 node。如果此 node 未被进程调用，则此属性返回 ``None``。"

#: ../../source/howto/query.rst:391
msgid ""
":meth:`~aiida.orm.Data.creator`: defined for :class:`~aiida.orm.Data` nodes "
"and returns the process node that created it. If the node was not created by"
" a process, this property returns ``None``."
msgstr " :meth:`~aiida.orm.Data.creator`：为 :class:`~aiida.orm.Data` nodes 定义，并返回创建它的进程 node。如果 node 不是由进程创建的，该属性将返回 ``None``。"

#: ../../source/howto/query.rst:396
msgid ""
"Using the ``creator`` and ``inputs`` properties, one can easily move *up* "
"the provenance graph. For example, starting from some data node that "
"represents the result of a long workflow, one can move up the provenance "
"graph to find an initial input node of interest: "
"``result.creator.inputs.some_input.creator.inputs.initial_input``."
msgstr "利用 ``creator`` 和 ``inputs`` 属性，我们可以轻松地在 provenance graph 上**移动。例如，从表示长 workflow 结果的数据 node 开始，可以向上移动 provenance graph 以找到感兴趣的初始输入 node：``result.creator.inputs.some_input.creator.inputs.initial_input``。"

#: ../../source/howto/query.rst:402
msgid "Calculation job results"
msgstr "计算工作结果"

#: ../../source/howto/query.rst:404
msgid ""
":class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode`'s provide "
"the :meth:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.res` "
"property, that can give easy access to the results of the calculation job. "
"The requirement is that the "
":class:`~aiida.engine.processes.calcjobs.calcjob.CalcJob` class that "
"produced the node, defines a *default output node* in its spec. This node "
"should be a :class:`~aiida.orm.nodes.data.dict.Dict` output that will always"
" be created. An example is the "
":class:`~aiida.calculations.templatereplacer.TemplatereplacerCalculation` "
"plugin, that has the ``output_parameters`` output that is specified as its "
"default output node."
msgstr " :class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode` 的 :meth:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.res` 属性可以方便地访问计算作业的结果。我们的要求是，生成 node 的 :class:`~aiida.engine.processes.calcjobs.calcjob.CalcJob` 类在其规范中定义了一个 * 默认输出 node*。这个 node 应该是始终会创建的 :class:`~aiida.orm.nodes.data.dict.Dict` 输出。例如，:class:`~aiida.calculations.templatereplacer.TemplatereplacerCalculation` 插件的 ``output_parameters`` 输出被指定为默认输出 node。"

#: ../../source/howto/query.rst:409
msgid ""
"The :meth:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.res` "
"property will give direct easy access to all the keys within this dictionary"
" output. For example, the following:"
msgstr " :meth:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.res` 属性可直接轻松访问该字典输出中的所有键。例如"

#: ../../source/howto/query.rst:416
msgid ""
"will return a list of all the keys in the output node. Individual keys can "
"then be accessed through attribute dereferencing:"
msgstr "将返回输出 node 中所有键的列表。然后就可以通过属性引用访问各个键："

#: ../../source/howto/query.rst:423
msgid ""
"In an interactive shell, the available keys are also tab-completed. If you "
"type ``node.res.`` followed by the tab key twice, a list of the available "
"keys is printed."
msgstr "在交互式 shell 中，可用按键也是以 tab 键完成的。如果输入 ``node.res.``，然后按两次制表符键，就会打印出可用按键的列表。"

#: ../../source/howto/query.rst:428
msgid ""
"The :meth:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.res` "
"property is really just a shortcut to quickly and easily access an attribute"
" of the default output node of a calculation job. For example, if the "
"default output node link label is ``output_parameters``, then "
"``node.res.some_key`` is exactly equivalent to "
"``node.outputs.output_parameters.dict.some_key``. That is to say, when using"
" ``res``, one is accessing attributes of one of the output nodes, and not of"
" the calculation job node itself."
msgstr " :meth:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.res` 属性实际上只是一种快捷方式，用于快速、轻松地访问计算作业默认输出 node 的属性。例如，如果默认输出 node 的链接标签是 ``output_parameters``，则 ``node.res.some_key`` 与 ``node.outputs.output_parameters.dict.some_key`` 完全等价。也就是说，在使用 ``res`` 时，我们访问的是输出 node 的属性，而不是计算作业 node 本身的属性。"

#: ../../source/howto/run_codes.rst:5
msgid "How to run external codes"
msgstr "如何运行外部代码"

#: ../../source/howto/run_codes.rst:7
msgid ""
"This how-to walks you through the steps of setting up a (possibly remote) "
"compute resource, setting up a code on that computer, and submitting a "
"calculation through AiiDA (similar to the :ref:`introductory tutorial "
"<tutorial:basic:calcjob>`, but in more detail)."
msgstr "本手册将引导您完成设置(可能是远程)计算资源、在计算机上设置代码以及通过 AiiDA 提交计算的步骤(与 :ref:`introductory tutorial <tutorial:basic:calcjob>` 类似，但更详细)。"

#: ../../source/howto/run_codes.rst:9
msgid ""
"To run an external code with AiiDA, you need an appropriate "
":ref:`calculation plugin <topics:plugins>`. In the following, we assume that"
" a plugin for your code is already available from the `aiida plugin registry"
" <https://aiidateam.github.io/aiida-registry/>`_ and installed on your "
"machine. Refer to the :ref:`how-to:plugins-install` section for details on "
"how to install an existing plugin. If a plugin for your code is not yet "
"available, see :ref:`how-to:plugin-codes`."
msgstr "要使用 AiiDA 运行外部代码，你需要一个合适的 :ref:`calculation plugin <topics:plugins>`。在下文中，我们假设你的代码已经可以从`aiida plugin registry <https://aiidateam.github.io/aiida-registry/>`_获得插件，并安装在你的机器上。有关如何安装现有插件的详细信息，请参阅 :ref:`how-to:plugins-install` 章节。如果您的代码还没有插件，请参阅 :ref:`how-to:plugin-codes`。"

#: ../../source/howto/run_codes.rst:14
msgid ""
"Throughout the process, you will be prompted for information on the computer"
" and code. In these prompts:"
msgstr "在整个过程中，系统会提示您提供有关计算机和代码的信息。在这些提示中"

#: ../../source/howto/run_codes.rst:17
msgid ""
"Type ``?`` followed by ``<enter>`` to get help on what is being asked at any"
" prompt."
msgstr "键入 ``?``，然后键入 ``<enter>``，以获取任何提示符下的帮助信息。"

#: ../../source/howto/run_codes.rst:18
msgid ""
"Press ``<CTRL>+C`` at any moment to abort the setup process. Your AiiDA "
"database will remain unmodified."
msgstr "随时按 ``<CTRL>+C`` 终止设置过程。你的 AiiDA 数据库将保持不变。"

#: ../../source/howto/run_codes.rst:23
msgid ""
"The ``verdi`` commands use ``readline`` extensions to provide default "
"answers, which require an advanced terminal. Use a standard terminal -- "
"terminals embedded in some text editors (such as ``emacs``) have been known "
"to cause problems."
msgstr "``verdi`` 命令使用 ``readline`` 扩展来提供默认答案，这需要使用高级终端。请使用标准终端--某些文本编辑器(如 ``emacs``)中嵌入的终端可能会导致问题。"

#: ../../source/howto/run_codes.rst:29
msgid "How to set up a computer"
msgstr "如何设置电脑"

#: ../../source/howto/run_codes.rst:31
msgid ""
"A |Computer| in AiiDA denotes a computational resource on which you will run"
" your calculations. It can either be:"
msgstr "AiiDA 中的 |Computer| 表示计算资源，您将在其上运行计算。它可以是"

#: ../../source/howto/run_codes.rst:34
msgid "the machine where AiiDA is installed or"
msgstr "安装 AiiDA 的机器或"

#: ../../source/howto/run_codes.rst:35
msgid ""
"any machine that is accessible via `SSH "
"<https://en.wikipedia.org/wiki/Secure_Shell>`_ from the machine where AiiDA "
"is installed (possibly :ref:`via a proxy server<how-to:ssh:proxy>`)."
msgstr "任何可以通过 `SSH <https://en.wikipedia.org/wiki/Secure_Shell>`_ 从安装 AiiDA 的机器(可能是 :ref:`via a proxy server<how-to:ssh:proxy>`)访问的机器。"

#: ../../source/howto/run_codes.rst:37
msgid ""
"The second option allows managing multiple remote compute resources "
"(including HPC clusters and cloud services) from the same AiiDA installation"
" and moving computational jobs between them."
msgstr "第二个选项允许从同一个 AiiDA 安装管理多个远程计算资源(包括高性能计算集群和云服务)，并在它们之间移动计算作业。"

#: ../../source/howto/run_codes.rst:41
msgid ""
"The second option requires access through an SSH keypair. If your compute "
"resource demands two-factor authentication, you may need to install AiiDA "
"directly on the compute resource instead."
msgstr "第二个选项需要通过SSH密钥对访问。如果你的计算资源需要双因素验证，你可能需要直接在计算资源上安装 AiiDA。"

#: ../../source/howto/run_codes.rst:46
msgid "Computer requirements"
msgstr "计算机要求"

#: ../../source/howto/run_codes.rst:48
msgid "Each computer must satisfy the following requirements:"
msgstr "每台计算机必须满足以下要求："

#: ../../source/howto/run_codes.rst:50
msgid ""
"It runs a Unix-like operating system (Linux distros and MacOS should work "
"fine)"
msgstr "它运行类似 Unix 的操作系统(Linux 发行版和 MacOS 应可正常运行)。"

#: ../../source/howto/run_codes.rst:51
msgid "It has ``bash`` installed"
msgstr "它安装了 ``bash``."

#: ../../source/howto/run_codes.rst:52
msgid ""
"(optional) It has batch scheduler installed (see the :ref:`list of supported"
" schedulers <topics:schedulers>`)"
msgstr "(可选)已安装批处理调度程序(参见 :ref:`list of supported schedulers <topics:schedulers>`)。"

#: ../../source/howto/run_codes.rst:54
msgid ""
"If you are configuring a remote computer, start by :ref:`configuring "
"password-less SSH access <how-to:ssh>` to it."
msgstr "如果要配置远程计算机，请从 :ref:`configuring password-less SSH access <how-to:ssh>` 开始。"

#: ../../source/howto/run_codes.rst:58
msgid ""
"AiiDA will use ``bash`` on the remote computer, regardless of the default "
"shell. Please ensure that your remote ``bash`` configuration does not load a"
" different shell."
msgstr "AiiDA 将在远程计算机上使用 ``bash``，不管默认的 shell 是什么。请确保你的远程 ``bash`` 配置没有加载不同的 shell。"

#: ../../source/howto/run_codes.rst:65
msgid "Computer setup"
msgstr "计算机设置"

#: ../../source/howto/run_codes.rst:67
msgid ""
"The configuration of computers happens in two steps: setting up the public "
"metadata associated with the |Computer| in AiiDA provenance graphs, and "
"configuring private connection details."
msgstr "计算机的配置分为两步：在 AiiDA provenance graphs 中设置与 |Computer| 相关的公共元数据，以及配置专用连接细节。"

#: ../../source/howto/run_codes.rst:69
msgid "Start by creating a new computer instance in the database:"
msgstr "首先在数据库中创建一个新的计算机实例："

#: ../../source/howto/run_codes.rst:75
msgid ""
"At the end, the command will open your default editor on a file containing a"
" summary of the configuration up to this point. You can add ``bash`` "
"commands that will be executed"
msgstr "最后，该命令将打开一个文件的默认编辑器，其中包含截至目前的配置摘要。您可以添加将被执行的 ``bash`` 命令"

#: ../../source/howto/run_codes.rst:78
msgid ""
"*before* the actual execution of the job (under 'Pre-execution script'), and"
msgstr "*在* 实际执行任务之前(在 ``执行前脚本``下)，以及"

#: ../../source/howto/run_codes.rst:79
msgid "*after* the script submission (under 'Post execution script')."
msgstr "提交脚本后**(在 ``执行后脚本``下)。"

#: ../../source/howto/run_codes.rst:81
msgid ""
"Use these additional lines to perform any further set up of the environment "
"on the computer, for example loading modules or exporting environment "
"variables:"
msgstr "使用这些附加行对计算机环境进行进一步设置，例如加载模块或导出环境变量："

#: ../../source/howto/run_codes.rst:90
msgid ""
"Don't specify settings here that are specific to a code or calculation: you "
"can set further pre-execution commands at the ``Code`` and even ``CalcJob`` "
"level."
msgstr "不要在此指定代码或计算的特定设置：您可以在 ``Code`` 甚至 ``CalcJob`` 级设置更多执行前命令。"

#: ../../source/howto/run_codes.rst:92
msgid ""
"When you are done editing, save and quit. The computer has now been created "
"in the database but you still need to *configure* access to it using your "
"credentials."
msgstr "编辑完成后，保存并退出。现在，计算机已在数据库中创建，但您仍需使用凭据配置*访问权限。"

#: ../../source/howto/run_codes.rst:97
msgid ""
"In order to avoid having to retype the setup information the next time "
"around, you can provide some (or all) of the information via a configuration"
" file:"
msgstr "为了避免下次重新输入设置信息，可以通过配置文件提供部分(或全部)信息："

#: ../../source/howto/run_codes.rst:103
msgid ""
"where ``computer.yml`` is a configuration file in the `YAML format "
"<https://en.wikipedia.org/wiki/YAML#Syntax>`__. This file contains the "
"information in a series of key-value pairs:"
msgstr "其中 ``computer.yml`` 是 `YAML format <https://en.wikipedia.org/wiki/YAML#Syntax>`__ 中的配置文件。该文件包含一系列键值对信息："

#: ../../source/howto/run_codes.rst:120
msgid ""
"The list of the keys for the ``yaml`` file is given by the options of the "
"``computer setup`` command:"
msgstr "``yaml`` 文件的密钥列表由 ``computer setup`` 命令的选项提供："

#: ../../source/howto/run_codes.rst:126 ../../source/howto/run_codes.rst:348
msgid ""
"Note: remove the ``--`` prefix and replace dashes (``-``) within the keys "
"with an underscore ( ``_`` )."
msgstr "注意：删除 ``--`` 前缀，并用下划线 ( ``_`` ) 代替按键中的破折号 (``-``)。"

#: ../../source/howto/run_codes.rst:131
msgid "Computer connection configuration"
msgstr "计算机连接配置"

#: ../../source/howto/run_codes.rst:133
msgid "The second step configures private connection details using:"
msgstr "第二步是配置专用连接的详细信息："

#: ../../source/howto/run_codes.rst:139
msgid ""
"Replace ``COMPUTERLABEL`` with the computer label chosen during the setup "
"and replace ``TRANSPORTTYPE`` with the name of chosen transport type, i.e., "
"``core.local`` for the localhost computer and ``core.ssh`` for any remote "
"computer."
msgstr "将 ``COMPUTERLABEL`` 替换为设置时选择的计算机标签，将 ``TRANSPORTTYPE`` 替换为所选传输类型的名称，即 ``core.local`` 表示本地主机计算机，``core.ssh`` 表示任何远程计算机。"

#: ../../source/howto/run_codes.rst:141
msgid ""
"After the setup and configuration have been completed, let's check that "
"everything is working properly:"
msgstr "完成设置和配置后，让我们检查一下一切是否正常："

#: ../../source/howto/run_codes.rst:147
msgid ""
"This command will perform various tests to make sure that AiiDA can connect "
"to the computer, create new files in the scratch directory, retrieve files "
"and query the job scheduler."
msgstr "该命令将执行各种测试，以确保 AiiDA 可以连接到计算机、在从头开始目录中创建新文件、检索文件和查询作业调度程序。"

#: ../../source/howto/run_codes.rst:152
msgid "Mitigating connection overloads"
msgstr "减轻连接过载"

#: ../../source/howto/run_codes.rst:154
msgid ""
"Some compute resources, particularly large supercomputing centers, may not "
"tolerate submitting too many jobs at once, executing scheduler commands too "
"frequently, or opening too many SSH connections."
msgstr "某些计算资源，尤其是大型超级计算中心，可能无法容忍同时提交过多作业、过于频繁地执行调度程序命令或打开过多 SSH 连接。"

#: ../../source/howto/run_codes.rst:156
msgid "Limit the number of jobs in the queue."
msgstr "限制队列中的作业数量。"

#: ../../source/howto/run_codes.rst:158
msgid ""
"Set a limit for the maximum number of workflows to submit, and only submit "
"new ones once previous workflows start to complete. The supported number of "
"jobs depends on the supercomputer configuration which may be documented as "
"part of the center's user documentation. The supercomputer administrators "
"may also find the information found on `this page "
"<https://github.com/aiidateam/aiida-core/wiki/Optimising-the-SLURM-"
"scheduler-configuration-(for-cluster-administrators)>`_ useful."
msgstr "设置要提交的 workflow 作业的最大数量限制，只有在之前的 workflow 作业开始完成后才能提交新的作业。支持的作业数量取决于超级计算机的配置，这可能是中心用户文档的一部分。超级计算机管理员也可能会发现 `this page <https://github.com/aiidateam/aiida-core/wiki/Optimising-the-SLURM-scheduler-configuration-(for-cluster-administrators)>`_ 上的信息非常有用。"

#: ../../source/howto/run_codes.rst:162
msgid "Increase the time interval between polling the job queue."
msgstr "增加轮询作业队列的时间间隔。"

#: ../../source/howto/run_codes.rst:164
msgid ""
"The time interval (in seconds) can be set through the Python API by loading "
"the corresponding |Computer| node, e.g. in the ``verdi shell``:"
msgstr "时间间隔(以秒为单位)可通过 Python API 设置，方法是加载相应的 |Computer| node，例如在 ``verdi shell`` 中："

#: ../../source/howto/run_codes.rst:170
msgid "Increase the connection cooldown time."
msgstr "增加连接冷却时间。"

#: ../../source/howto/run_codes.rst:172
msgid ""
"This is the minimum time (in seconds) to wait between opening a new "
"connection. Modify it for an existing computer using:"
msgstr "这是打开新连接的最短等待时间(以秒为单位)。为现有计算机修改它，请使用"

#: ../../source/howto/run_codes.rst:181
msgid ""
"The two intervals apply *per daemon worker*, i.e. doubling the number of "
"workers may end up putting twice the load on the remote computer."
msgstr "这两个时间间隔适用于每个守护进程工作者*，也就是说，工作者数量增加一倍，远程计算机的负载可能会增加一倍。"

#: ../../source/howto/run_codes.rst:184
msgid "Managing your computers"
msgstr "管理电脑"

#: ../../source/howto/run_codes.rst:186
msgid "Fully configured computers can be listed with:"
msgstr "配置齐全的计算机可通过以下方式列出："

#: ../../source/howto/run_codes.rst:192
msgid ""
"To get detailed information on the specific computer named "
"``COMPUTERLABEL``:"
msgstr "获取名为 ``COMPUTERLABEL`` 的特定计算机的详细信息："

#: ../../source/howto/run_codes.rst:198
msgid "To rename a computer or remove it from the database:"
msgstr "重新命名计算机或将其从数据库中删除："

#: ../../source/howto/run_codes.rst:207
msgid ""
"Before deleting a |Computer|, you will need to delete *all* nodes linked to "
"it (e.g. any ``CalcJob`` and ``RemoteData`` nodes). Otherwise, AiiDA will "
"prevent you from doing so in order to preserve provenance."
msgstr "在删除 |Computer| 之前，你需要删除 *所有* 与之链接的 node(例如，任何 ``CalcJob``和 ``RemoteData`` node)。否则，AiiDA 会阻止你这样做，以保留 provenance。"

#: ../../source/howto/run_codes.rst:210
msgid ""
"If a remote machine is under maintenance (or no longer operational), you may"
" want to **disable** the corresponding |Computer|. Doing so will prevent "
"AiiDA from connecting to the given computer to check the state of "
"calculations or to submit new calculations."
msgstr "如果远程计算机正在维护(或不再运行)，你可能想 **禁用** 相应的 |Computer|。这样做可以防止 AiiDA 连接到指定的计算机检查计算状态或提交新的计算。"

#: ../../source/howto/run_codes.rst:221
msgid "How to create a code"
msgstr "如何创建代码"

#: ../../source/howto/run_codes.rst:223
msgid ""
"Before you can run a calculation, you need to define a \"code\" which "
"represents what code the calculation should execute and how it should be "
"executed. AiiDA supports a variety of codes:"
msgstr "在运行一个计算之前，你需要定义一个 \``code\`` 来表示计算应该执行什么代码以及如何执行。AiiDA 支持多种代码："

#: ../../source/howto/run_codes.rst:226
msgid ""
"``Installed``: The executable code is already installed on the target "
"computer"
msgstr "``Installed``:目标计算机上已安装可执行代码"

#: ../../source/howto/run_codes.rst:227
msgid ""
"``Portable``: The executable code is stored by AiiDA and can be deployed on "
"a variety of computers"
msgstr "``Portable``:可执行代码由 AiiDA 存储，可在各种计算机上部署"

#: ../../source/howto/run_codes.rst:228
msgid ""
"``Containerized``: The executable code is part of a container image that can"
" be deployed and run on the target computer"
msgstr "``Containerized``：可执行代码是可在目标计算机上部署和运行的容器映像的一部分"

#: ../../source/howto/run_codes.rst:230
msgid ""
"Each of these scenarios are supported through a code plugin, which stores "
"all necessary data to fully define the code. A configured code is stored in "
"the provenance graph, which besides being important for reproducibility, "
"makes it easy to query for all calculations that were run with a given code."
msgstr "每种情况都通过代码插件提供支持，该插件存储了完全定义代码所需的所有数据。配置好的代码存储在 provenance graph 中，除了具有 import 的可重复性外，还可以轻松查询使用给定代码运行的所有计算。"

#: ../../source/howto/run_codes.rst:235
msgid ""
"In most cases, it is advisable to install the executables to be used by "
"AiiDA on the target machine *before* submitting calculations using them, in "
"order to take advantage of the compilers and libraries present on the target"
" machine. This is the ``installed`` scenario."
msgstr "在大多数情况下，建议在目标机上安装AiiDA使用的可执行文件，然后*再提交使用它们的计算，以便利用目标机上的编译器和库。这就是``installed``的情况。"

#: ../../source/howto/run_codes.rst:238
msgid ""
"Occasionally, you may need to run small, reasonably machine-independent "
"scripts (e.g. Python or bash), and copying them manually to a number of "
"different target computers can be tedious. For this use case, the "
"``portable`` code is ideal. The executable and associated files of the code "
"are stored by AiiDA and automatically copied to the target computer for "
"every execution."
msgstr "有时，您可能需要运行小型的、在一定程度上独立于机器的脚本(如 Python 或 bash)，而手动将它们复制到多个不同的目标计算机上可能会很繁琐。在这种情况下，``portable`` 代码是理想的选择。代码的可执行文件和相关文件由 AiiDA 保存，并在每次执行时自动复制到目标计算机。"

#: ../../source/howto/run_codes.rst:242
msgid ""
"Do *not* use local codes as a way of encapsulating the environment of "
"complex executables. For this use case, it is best to use the "
"``containerized`` code. Create a container of the required compute "
"environment and create a containerized code."
msgstr "不要**使用本地代码来封装复杂可执行文件的环境。对于这种用例，最好使用 ``containerized`` 代码。创建所需计算环境的容器，并创建容器化代码。"

#: ../../source/howto/run_codes.rst:246
msgid ""
"A new code can be configured in AiiDA through the ``verdi code create`` "
"command. The type of code is specified as the first argument and the rest of"
" the information is provided through options:"
msgstr "新代码可以通过 ``verdi code create`` 命令在 AiiDA 中配置。代码类型作为第一个参数，其余信息通过选项提供："

#: ../../source/howto/run_codes.rst:0
msgid "Installed"
msgstr "已安装"

#: ../../source/howto/run_codes.rst:253
msgid ""
"The following example shows how to create an installed code for the ``bash``"
" binary on the ``localhost`` computer:"
msgstr "下面的示例显示了如何在 ``localhost`` 计算机上为 ``bash`` 二进制程序创建安装代码："

#: ../../source/howto/run_codes.rst:263
msgid ""
"For more information, please refer to the dedicated :ref:`topic section "
"<topics:data_types:core:code:installed>`."
msgstr "更多信息，请参阅专用的 :ref:`topic section <topics:data_types:core:code:installed>`。"

#: ../../source/howto/run_codes.rst:0
msgid "Portable"
msgstr "便携式"

#: ../../source/howto/run_codes.rst:267
msgid ""
"The following example shows how to create a portable code for an executable "
"``executable.py`` in the ``/path/to/directory`` folder:"
msgstr "下面的示例显示了如何为 ``/path/to/directory`` 文件夹中的可执行文件 ``executable.py`` 创建可移植代码："

#: ../../source/howto/run_codes.rst:276
msgid ""
"Any other files that are part of ``/path/to/directory`` will also be stored "
"by the code plugin."
msgstr "属于 ``/path/to/directory`` 的任何其他文件也将由代码插件存储。"

#: ../../source/howto/run_codes.rst:278
msgid ""
"For more information, please refer to the dedicated :ref:`topic section "
"<topics:data_types:core:code:portable>`."
msgstr "更多信息，请参阅专用的 :ref:`topic section <topics:data_types:core:code:portable>`。"

#: ../../source/howto/run_codes.rst:0
msgid "Containerized"
msgstr "集装箱式"

#: ../../source/howto/run_codes.rst:282
msgid ""
"The following example shows how to setup running ``bash`` in a base Docker "
"container through Singularity to be run on the ``Computer`` named ``some-"
"computer``:"
msgstr "下面的示例展示了如何通过 Singularity 在基础 Docker 容器中设置运行 ``bash`` 以在名为 ``some-computer`` 的 ``Computer`` 上运行："

#: ../../source/howto/run_codes.rst:294
msgid ""
"For more information, please refer to the dedicated :ref:`topic section "
"<topics:data_types:core:code:containerized>`."
msgstr "更多信息，请参阅专用的 :ref:`topic section <topics:data_types:core:code:containerized>`。"

#: ../../source/howto/run_codes.rst:296
msgid ""
"The code create command will prompt for any additional options. It will also"
" open a text editor to specify the ``--prepend-text`` and ``--append-text`` "
"options, where you can include ``bash`` commands that will be executed"
msgstr "代码创建命令将提示输入其他选项。它还会打开文本编辑器，指定 ``--prepend-text`` 和 ``--append-text`` 选项，您可以在其中加入将被执行的 ``bash`` 命令"

#: ../../source/howto/run_codes.rst:299
msgid ""
"*before* running the submission script (after the 'Pre execution script' "
"lines), and"
msgstr "*在* 运行提交脚本之前(在 ``预执行脚本``行之后)，以及"

#: ../../source/howto/run_codes.rst:300
msgid ""
"*after* running the submission script (after the 'Post execution script' "
"separator)."
msgstr "*在* 运行提交脚本之后(在 ``后执行脚本``分隔符之后)。"

#: ../../source/howto/run_codes.rst:302
msgid ""
"Use this, for instance, to load modules or set variables that are needed by "
"the code, such as:"
msgstr "例如，用它来加载模块或设置代码所需的变量，如"

#: ../../source/howto/run_codes.rst:308
msgid ""
"At the end, you receive a confirmation, with the *PK* and the *UUID* of your"
" new code."
msgstr "最后，您会收到一份确认函，其中包含新代码的 *PK* 和 *UUID* 。"

#: ../../source/howto/run_codes.rst:312
msgid ""
"The ``verdi code create`` command performs minimal checks in order to keep "
"it performant and not rely on an internet connection. If you want additional"
" checks to verify the code is properly configured and usable, run the "
"``verdi code test`` command. For installed codes for example, this will "
"check whether the associated computer can be connected to and whether the "
"specified executable exists. Look at the command help to see what other "
"checks may be run."
msgstr "``verdi code create`` 命令执行最低限度的检查，以保持其性能，而不依赖互联网连接。如果需要额外的检查来验证代码是否正确配置和可用，请运行 ``verdi code test`` 命令。例如，对于已安装的代码，该命令将检查相关计算机是否可以连接，以及指定的可执行文件是否存在。请查看命令帮助，了解可能运行的其他检查。"

#: ../../source/howto/run_codes.rst:319
msgid ""
"Analogous to a :ref:`computer setup <how-to:run-codes:computer>`, some (or "
"all) the information described above can be provided via a configuration "
"file:"
msgstr "与 :ref:`computer setup <how-to:run-codes:computer>` 类似，上述部分(或全部)信息可通过配置文件提供："

#: ../../source/howto/run_codes.rst:325
msgid ""
"where ``code.yml`` is a configuration file in the `YAML format "
"<https://en.wikipedia.org/wiki/YAML#Syntax>`_."
msgstr "其中 ``code.yml`` 是 `YAML format <https://en.wikipedia.org/wiki/YAML#Syntax>`_ 中的配置文件。"

#: ../../source/howto/run_codes.rst:327
msgid "This file contains the information in a series of key:value pairs:"
msgstr "该文件包含一系列键值对信息："

#: ../../source/howto/run_codes.rst:342
msgid ""
"The list of the keys for the ``yaml`` file is given by the available options"
" of the ``code create`` sub-command:"
msgstr "``yaml`` 文件的密钥列表由 ``code create`` 子命令的可用选项提供："

#: ../../source/howto/run_codes.rst:353
msgid ""
"It is possible to run codes that are provided by a `Conda environment "
"<https://docs.conda.io/en/latest/>`_. The code configuration YAML would look"
" something like the following:"
msgstr "可以运行 `Conda environment <https://docs.conda.io/en/latest/>`_ 提供的代码。代码配置 YAML 将如下所示："

#: ../../source/howto/run_codes.rst:361
msgid ""
"Note that the configuration is not complete but only shows the relevant "
"lines. For the ``conda activate`` statement to work, it needs to be properly"
" initialized in the shell in which the job is executed."
msgstr "请注意，配置并不完整，只显示了相关行。要使 ``conda activate`` 语句正常工作，需要在执行作业的 shell 中正确初始化该语句。"

#: ../../source/howto/run_codes.rst:364
msgid ""
"This can be achieved by configuring the ``shebang`` property of the "
"``Computer`` to ``#!/bin/bash -l``. This ensures that the submission script "
"uses a login shell which initializes conda properly."
msgstr "这可以通过将 ``Computer`` 的 ``shebang`` 属性配置为 ``#!/bin/bash -l`` 来实现。这将确保提交脚本使用能正确初始化 conda 的登录 shell。"

#: ../../source/howto/run_codes.rst:367
msgid ""
"If the submission script should not use a login shell (e.g. because that "
"sources other dotfiles that are unnecessary), the following ``prepend_text``"
" can be used instead:"
msgstr "如果提交脚本不应使用登录 shell(例如，因为登录 shell 会产生不必要的其他 dotfile)，则可使用下面的 ``prepend_text`` 代替："

#: ../../source/howto/run_codes.rst:376
msgid ""
"For further details, please refer to the `Conda documentation "
"<https://docs.conda.io/projects/conda/en/latest/dev-guide/deep-"
"dives/activation.html#conda-initialization>`_."
msgstr "更多详情，请参阅 `Conda documentation <https://docs.conda.io/projects/conda/en/latest/dev-guide/deep-dives/activation.html#conda-initialization>`_。"

#: ../../source/howto/run_codes.rst:380
msgid "Managing codes"
msgstr "管理代码"

#: ../../source/howto/run_codes.rst:382
msgid "You can change the label of a code by using the following command:"
msgstr "您可以使用以下命令更改代码的标签："

#: ../../source/howto/run_codes.rst:388
msgid ""
"where <IDENTIFIER> can be the numeric *PK*, the *UUID* or the label of the "
"code (either ``label`` or ``label@computername``) if the label is unique."
msgstr "其中 <IDENTIFIER> 可以是数字 *PK* 、 *UUID* 或代码标签(``label` 或 ``label@computername`)(如果标签是唯一的)。"

#: ../../source/howto/run_codes.rst:390
msgid "You can also list all available codes and their identifiers with:"
msgstr "您还可以用以下方式列出所有可用代码及其标识符："

#: ../../source/howto/run_codes.rst:396
msgid ""
"which also accepts flags to filter only codes on a given computer, or only "
"codes using a specific plugin, etc. (use the ``-h`` option)."
msgstr "还可以使用标记来只过滤特定计算机上的代码，或只过滤使用特定插件的代码等(使用 ``-h`` 选项)。"

#: ../../source/howto/run_codes.rst:398
msgid "You can get the information of a specific code with:"
msgstr "您可以通过以下方式获取特定代码的信息："

#: ../../source/howto/run_codes.rst:404
msgid "Finally, to delete a code use:"
msgstr "最后，要删除代码，请使用"

#: ../../source/howto/run_codes.rst:410
msgid ""
"(only if it wasn't used by any calculation, otherwise an exception is "
"raised)."
msgstr "(只有在任何计算都没有使用它的情况下，否则会出现异常)。"

#: ../../source/howto/run_codes.rst:414
msgid ""
"Codes are a subclass of :py:class:`Node <aiida.orm.Node>` and, as such, you "
"can attach ``extras`` to a code, for example:"
msgstr "代码是 :py:class:`Node <aiida.orm.Node>` 的子类，因此，您可以将 ``extras`` 附加到代码中："

#: ../../source/howto/run_codes.rst:421
msgid ""
"These can be useful for querying, for instance in order to find all runs "
"done with the CP2K code of version 6.1 or later."
msgstr ""

#: ../../source/howto/run_codes.rst:426
msgid "How to submit a calculation"
msgstr ""

#: ../../source/howto/run_codes.rst:428
msgid ""
"After :ref:`setting up your computer <how-to:run-codes:computer>` and "
":ref:`setting up your code <how-to:run-codes:code>`, you are ready to launch"
" your calculations!"
msgstr ""

#: ../../source/howto/run_codes.rst:430
msgid "Make sure the daemon is running:"
msgstr ""

#: ../../source/howto/run_codes.rst:436
msgid "Figure out which inputs your |CalcJob|  plugin needs, e.g. using:"
msgstr ""

#: ../../source/howto/run_codes.rst:442
msgid "Write a ``submit.py`` script:"
msgstr ""

#: ../../source/howto/run_codes.rst:462
msgid ""
"Of course, the code label and builder inputs need to be adapted to your code"
" and calculation."
msgstr ""

#: ../../source/howto/run_codes.rst:466
msgid ""
"See also the :ref:`complete list of "
"metadata<topics:calculations:usage:calcjobs:options>` you can pass to a "
"calculation."
msgstr ""

#: ../../source/howto/run_codes.rst:468
msgid "Submit your calculation to the AiiDA daemon:"
msgstr ""

#: ../../source/howto/run_codes.rst:474
msgid ""
"After this, use ``verdi process list`` to monitor the status of the "
"calculations."
msgstr ""

#: ../../source/howto/run_codes.rst:478
msgid ""
"If you ever need to resubmit a previous calculation with modified inputs, "
"you can get a pre-populated copy of its process builder with"
msgstr ""

#: ../../source/howto/run_codes.rst:487
msgid ""
"where ``<IDENTIFIER>`` is the ``PK`` or ``UUID`` (or label) of your "
"*calculation*."
msgstr ""

#: ../../source/howto/run_codes.rst:490
msgid ""
"See :ref:`topics:processes:usage:launching` and "
":ref:`topics:processes:usage:monitoring` for more details."
msgstr ""

#: ../../source/howto/run_codes.rst:496
msgid "How to monitor (and prematurely stop) a calculation"
msgstr ""

#: ../../source/howto/run_codes.rst:498
msgid "A calculation job will terminate if and only if:"
msgstr ""

#: ../../source/howto/run_codes.rst:500
msgid "The calculation terminates; either nominally or due to an error."
msgstr ""

#: ../../source/howto/run_codes.rst:501
msgid ""
"The scheduler kills the job; e.g., due to the wallclock time being exceeded "
"or the allocated memory being exhausted."
msgstr ""

#: ../../source/howto/run_codes.rst:502
msgid "The calculation job is killed through AiiDA"
msgstr ""

#: ../../source/howto/run_codes.rst:504
msgid ""
"One might want to kill the calculation job if it seems that the calculation "
"is not going anywhere, and so instead of letting the calculation run to its "
"end automatically, it is killed. It is possible to automate this procedure "
"through *monitoring* of the calculation job."
msgstr ""

#: ../../source/howto/run_codes.rst:507
msgid ""
"A monitor is a Python function that will be called in regular intervals "
"while the calculation job is running. The function has access to the working"
" directory of the running calculation and can retrieve and inspect their "
"contents. Based on the output it can decide whether the job should continue "
"running or should be killed."
msgstr ""

#: ../../source/howto/run_codes.rst:512
msgid "How to implement a monitor"
msgstr ""

#: ../../source/howto/run_codes.rst:514
msgid "A monitor is a function with the following signature:"
msgstr ""

#: ../../source/howto/run_codes.rst:529
msgid ""
"The ``node`` and the ``transport`` arguments are required. The ``node`` is a"
" reference to the calculation job node, which can be used to retrieve its "
"input, for example. The ``transport`` can be used to retrieve files from the"
" working directory of the calculation running on the remote computer. This "
"allows you to inspect the content and determine whether the job should be "
"prematurely killed."
msgstr ""

#: ../../source/howto/run_codes.rst:534
msgid ""
"A monitor can define additional keyword arguments that a user can use to "
"modify or configure its behavior. The arguments can take any value, as long "
"as it is JSON-serializable. This is necessary because the arguments that are"
" passed to a monitor are stored in the database in order to preserve "
"provenance. It is recommended to write out each supported keyword argument "
"and not use the ``**kwargs`` catch-all, for example:"
msgstr ""

#: ../../source/howto/run_codes.rst:553
msgid ""
"This will allow the engine to validate the arguments provided by a user. If "
"unsupported arguments are provided to a monitor, the calculation job will "
"not start and the user will be notified of the mistake."
msgstr ""

#: ../../source/howto/run_codes.rst:556
msgid ""
"As an example case, imagine a code that would print the string `WARNING` to "
"stdout, in which case we want to stop the calculation. The following "
"implementation would accomplish that:"
msgstr ""

#: ../../source/howto/run_codes.rst:580
msgid ""
"The content of the stdout stream, which should be written to the "
"``node.options.output_filename`` file, is retrieved using "
"``transport.getfile`` and is written to a temporary file on the local file "
"system. The content is then read from the file and if the target string is "
"detected, an error message is returned. If a monitor, attached to a "
"calculation job, returns anything other than ``None``, the calculation job "
"will be killed by the engine."
msgstr ""

#: ../../source/howto/run_codes.rst:584
msgid ""
"Finally, the monitor needs to be declared using an entry point in the "
"``aiida.calculations.monitors`` group. The next section will show how this "
"entry point is used to assign it to a calculation job."
msgstr ""

#: ../../source/howto/run_codes.rst:589
msgid "How to assign a monitor"
msgstr ""

#: ../../source/howto/run_codes.rst:591
msgid ""
"A monitor can be assigned to a calculation job by adding it to the "
"`monitors` input. It takes a dictionary of monitors, where each monitor is "
"defined by a `Dict` node with the following keys:"
msgstr ""

#: ../../source/howto/run_codes.rst:600
msgid ""
"The `entry_point` key is required and should contain an entry point that "
"refers to a monitor function registered in the `aiida.calculations.monitors`"
" group. It is possible to assign multiple monitors to a single calculation:"
msgstr ""

#: ../../source/howto/run_codes.rst:611
msgid ""
"Note that the keys used in the `monitors` input can be any valid attribute "
"name and does not influence the behavior whatsoever."
msgstr ""

#: ../../source/howto/run_codes.rst:613
msgid ""
"If a monitor supports additional custom keyword arguments, these should be "
"passed as a dictionary under the ``kwargs`` key. For example, if the monitor"
" accepts a boolean value for the keyword ``custom_keyword``, it can be "
"specified as follows:"
msgstr ""

#: ../../source/howto/run_codes.rst:623
msgid ""
"If a keyword is specified that is not declared explicitly by the monitor, "
"the validation of the ``CalcJob`` will fail."
msgstr ""

#: ../../source/howto/run_codes.rst:627
msgid "Monitor execution order"
msgstr ""

#: ../../source/howto/run_codes.rst:628
msgid ""
"By default, the monitors are executed in alphabetical order based on their "
"keys in the ``monitors`` input namespace. The order can be controlled using "
"the ``priority`` key in the ``monitors`` input."
msgstr ""

#: ../../source/howto/run_codes.rst:638
msgid ""
"Higher priorities will be executed first. It is not necessary to define a "
"priority for all monitors, in the absence of a priority, a priority of 0 is "
"assumed. For monitors with identical priority, the order remains "
"alphabetical based on their key in the ``monitors`` input namespace."
msgstr ""

#: ../../source/howto/run_codes.rst:644
msgid "Monitor execution frequency"
msgstr ""

#: ../../source/howto/run_codes.rst:645
msgid ""
"By default, all monitors are executed during each scheduler update cycle. "
"This interval is controlled by the ``minimum_scheduler_poll_interval`` "
"property of the ``Computer``, which can be retrieved and set through the "
"``get_minimum_job_poll_interval`` and ``set_minimum_job_poll_interval``, "
"respectively. The frequency of monitor execution can be reduced by setting a"
" larger interval for the ``minimum_poll_interval`` key in the monitor input "
"definition:"
msgstr ""

#: ../../source/howto/run_codes.rst:655
msgid ""
"The engine will guarantee that the interval between calls of the monitor is "
"at least the value specified by ``minimum_poll_interval``. Due to a number "
"of other intervals that are part of the ``CalcJob`` pipeline, it is possible"
" however, that the effective interval between monitor calls will be larger "
"than that."
msgstr ""

#: ../../source/howto/run_codes.rst:660
msgid "Advanced functionality"
msgstr ""

#: ../../source/howto/run_codes.rst:662
msgid ""
"The most simple implementation of a monitor simply returns a string. This is"
" interpreted by the engine that the job should be killed and the string "
"contains the reason for doing so. This behavior can be controlled by "
"returning an instance of "
":class:`~aiida.engine.processes.calcjobs.monitors.CalcJobMonitorResult` "
"instead."
msgstr ""

#: ../../source/howto/run_codes.rst:667
msgid "Disable parsing of retrieved files"
msgstr ""

#: ../../source/howto/run_codes.rst:669
msgid ""
"By default, when a job is stopped through a monitor, the engine will still "
"retrieve and parse the files. To skip the parsing of the retrieved files, "
"set ``CalcJobMonitorResult.parse`` to ``False``:"
msgstr ""

#: ../../source/howto/run_codes.rst:680
msgid "Disable retrieving of files"
msgstr ""

#: ../../source/howto/run_codes.rst:682
msgid ""
"By default, when a job is stopped through a monitor, the engine will still "
"retrieve the files from the remote working directory. To skip the file "
"retrieval, set ``CalcJobMonitorResult.retrieve`` to ``False``:"
msgstr ""

#: ../../source/howto/run_codes.rst:692
msgid ""
"Note that in this case ``parse`` should also be set to ``False`` since the "
"engine cannot parse files that have not been retrieved."
msgstr ""

#: ../../source/howto/run_codes.rst:695
msgid "Disable overriding of parse exit code"
msgstr ""

#: ../../source/howto/run_codes.rst:697
msgid ""
"By default, when a job is stopped through a monitor, the engine will set the"
" exit code ``STOPPED_BY_MONITOR``. This overrides any exit code that may be "
"returned by the parser, if one is invoked. To keep the exit code of the "
"parser instead, set ``CalcJobMonitorResult.override_exit_code`` to "
"``False``:"
msgstr ""

#: ../../source/howto/run_codes.rst:709
msgid "Disable a monitor"
msgstr ""

#: ../../source/howto/run_codes.rst:711
msgid ""
"By default, when a monitor returns anything other than ``None``, the engine "
"will immediately kill the job. In certain use-cases, a monitor may want to "
"perform an action and then let the job terminate nominally, but not invoke "
"the monitor again. To disable a monitor, set ``CalcJobMonitorResult.action``"
" to the ``DISABLE_SELF`` option of the "
":class:`~aiida.engine.processes.calcjobs.monitors.CalcJobMonitorAction`:"
msgstr ""

#: ../../source/howto/run_codes.rst:722
msgid ""
"All other monitors, if defined, will continue to be invoked by the engine."
msgstr ""

#: ../../source/howto/run_codes.rst:725
msgid "Disable all monitors"
msgstr ""

#: ../../source/howto/run_codes.rst:727
msgid ""
"By default, when a monitor returns anything other than ``None``, the engine "
"will immediately kill the job. In certain use-cases, a monitor may want to "
"perform an action and then let the job terminate nominally. An example might"
" be where the monitor writes a sentinel file in the remote working "
"directory, which will let the code running on the remote shut itself down "
"gracefully. In this case it is desirable that the engine stops calling the "
"monitors that were registered and just let the job continue normally. To "
"disable all monitors, set ``CalcJobMonitorResult.action`` to the "
"``DISABLE_ALL`` option of the "
":class:`~aiida.engine.processes.calcjobs.monitors.CalcJobMonitorAction`:"
msgstr ""

#: ../../source/howto/run_codes.rst:744
msgid "How to save compute time with caching"
msgstr ""

#: ../../source/howto/run_codes.rst:746
msgid ""
"Over the course of a project, you may end up re-running the same "
"calculations multiple times - be it because two workflows include the same "
"calculation or because one needs to restart a workflow that failed due to "
"some infrastructure problem."
msgstr ""

#: ../../source/howto/run_codes.rst:748
msgid ""
"Since AiiDA stores the full provenance of each calculation, it can detect "
"whether a calculation has been run before and, instead of running it again, "
"simply reuse its outputs, thereby saving valuable computational resources. "
"This is what we mean by **caching** in AiiDA."
msgstr ""

#: ../../source/howto/run_codes.rst:751
msgid ""
"With caching enabled, AiiDA searches the database for a calculation of the "
"same :ref:`hash<topics:provenance:caching:hashing>`. If found, AiiDA creates"
" a copy of the calculation node and its results, thus ensuring that the "
"resulting provenance graph is independent of whether caching is enabled or "
"not (see :numref:`fig_caching`)."
msgstr ""

#: ../../source/howto/run_codes.rst:759
msgid ""
"When reusing the results of a calculation **C** for a new calculation "
"**C'**, AiiDA simply makes a copy of the result nodes and links them up as "
"usual. This diagram depicts the same input node **D1** being used for both "
"calculations, but an input node **D1'** with the same *hash* as **D1** would"
" trigger the cache as well."
msgstr ""

#: ../../source/howto/run_codes.rst:762
msgid ""
"Caching happens on the *calculation* level (no caching at the workflow "
"level, see :ref:`topics:provenance:caching:limitations`). By default, both "
"successful and failed calculations enter the cache once they are *finished*."
" Excepted and killed calculations do *not* enter the cache (more details in "
":ref:`topics:provenance:caching:control-caching`)."
msgstr ""

#: ../../source/howto/run_codes.rst:769
msgid "How to enable caching"
msgstr ""

#: ../../source/howto/run_codes.rst:771
msgid ""
"Caching is **not** enabled by default, see :ref:`the faq <how-"
"to:faq:caching-not-enabled>`."
msgstr ""

#: ../../source/howto/run_codes.rst:773
msgid ""
"Caching is controlled on a per-profile level via the :ref:`verdi config cli "
"<how-to:installation:configure:options>`."
msgstr ""

#: ../../source/howto/run_codes.rst:775
msgid "View your current caching configuration:"
msgstr ""

#: ../../source/howto/run_codes.rst:786
msgid ""
"Enable caching for your current profile or globally (for all profiles):"
msgstr ""

#: ../../source/howto/run_codes.rst:805
msgid ""
"Configuring caching via the ``cache_config.yml`` is deprecated as of AiiDA "
"1.6.0. Existing ``cache_config.yml`` files will be migrated to the central "
"``config.json`` file automatically."
msgstr ""

#: ../../source/howto/run_codes.rst:809
msgid ""
"From this point onwards, when you launch a new calculation, AiiDA will "
"compare its hash (a fixed size string, unique for a calulation's type and "
"inputs, see :ref:`topics:provenance:caching:hashing`) against other "
"calculations already present in your database. If another calculation with "
"the same hash is found, AiiDA will reuse its results without repeating the "
"actual calculation."
msgstr ""

#: ../../source/howto/run_codes.rst:814
msgid ""
"In contrast to caching, hashing **is** enabled by default, i.e. hashes for "
"all your calculations will already have been computed."
msgstr ""

#: ../../source/howto/run_codes.rst:819
msgid "How to configure caching"
msgstr ""

#: ../../source/howto/run_codes.rst:821
msgid ""
"The caching mechanism can be configured on a process class level, meaning "
"the rules will automatically be applied to all instances of the given class,"
" or on a per-instance level, meaning it can be controlled for individual "
"process instances when they are launch."
msgstr ""

#: ../../source/howto/run_codes.rst:824
msgid "Class level"
msgstr ""

#: ../../source/howto/run_codes.rst:826
msgid ""
"Besides the on/off switch set by ``caching.default_enabled``, caching can be"
" controlled at the level of specific calculations using their corresponding "
"entry point strings (see the output of ``verdi plugin list "
"aiida.calculations``):"
msgstr ""

#: ../../source/howto/run_codes.rst:844
msgid ""
"In this example, caching is enabled by default, but explicitly disabled for "
"calculations of the ``TemplatereplacerCalculation`` class, identified by its"
" corresponding ``aiida.calculations:core.templatereplacer`` entry point "
"string. It also shows how to enable caching for particular calculations "
"(which has no effect here due to the profile-wide default)."
msgstr ""

#: ../../source/howto/run_codes.rst:849
msgid ""
"It is also possible to provide the full import path of the class in case it "
"does not have a registered entry point. For example, if the class can be "
"imported as ``from some.module.path import SomeClass``, it can be added as:"
msgstr ""

#: ../../source/howto/run_codes.rst:856
msgid "To set multiple entry-points at once, use a ``,`` delimiter."
msgstr ""

#: ../../source/howto/run_codes.rst:858
msgid ""
"If a specified value for ``verdi config set enabled_for/disabled_for`` is an"
" entry point that cannot be loaded, or is a path that cannot be improted, an"
" error is raised."
msgstr ""

#: ../../source/howto/run_codes.rst:860
msgid ""
"For the available entry-points in your environment, you can list which are "
"enabled/disabled using:"
msgstr ""

#: ../../source/howto/run_codes.rst:872
msgid ""
"For calculations which do not have an entry point, you need to specify the "
"fully qualified Python name instead. For example, the "
"``seekpath_structure_analysis`` calcfunction defined in "
"``aiida_quantumespresso.workflows.functions.seekpath_structure_analysis`` is"
" labelled as "
"``aiida_quantumespresso.workflows.functions.seekpath_structure_analysis.seekpath_structure_analysis``."
" From an existing :class:`~aiida.orm.CalculationNode`, you can get the "
"identifier string through the ``process_type`` attribute."
msgstr ""

#: ../../source/howto/run_codes.rst:876
msgid ""
"The caching configuration also accepts ``*`` wildcards. For example, the "
"following configuration disables caching for all calculation entry points."
msgstr ""

#: ../../source/howto/run_codes.rst:891
msgid ""
"Any entry with a wildcard is overridden by a more specific entry. The "
"following configuration disables caching for all ``aiida.calculation`` entry"
" points, except those of ``arithmetic``:"
msgstr ""

#: ../../source/howto/run_codes.rst:913
msgid "Instance level"
msgstr ""

#: ../../source/howto/run_codes.rst:915
msgid ""
"Caching can be enabled or disabled on a case-by-case basis by using the "
":class:`~aiida.manage.caching.enable_caching` or "
":class:`~aiida.manage.caching.disable_caching` context manager, "
"respectively, regardless of the profile settings:"
msgstr ""

#: ../../source/howto/run_codes.rst:926
msgid ""
"This affects only the current Python interpreter and won't change the "
"behavior of the daemon workers. This means that this technique is only "
"useful when using :py:class:`~aiida.engine.run`, and **not** with "
":py:class:`~aiida.engine.submit`."
msgstr ""

#: ../../source/howto/run_codes.rst:929
msgid ""
"By default, the ``enable_caching`` context manager will just validate that "
"the identifier is syntactically valid. It *does not* validate that the "
"identifier points to a class or entry point that actually exists and can be "
"imported or loaded. To make sure that the specified identifier is known to "
"AiiDA, pass the ``strict=True`` keyword argument:"
msgstr ""

#: ../../source/howto/run_codes.rst:940
msgid ""
"When ``strict`` is set to ``True``, the function will raise a ``ValueError``"
" if the specified class or entry point cannot be imported or loaded."
msgstr ""

#: ../../source/howto/run_codes.rst:942
msgid ""
"Besides controlling which process classes are cached, it may be useful or "
"necessary to control what already *stored* nodes are used as caching "
"*sources*. Section :ref:`topics:provenance:caching:control-caching` provides"
" details how AiiDA decides which stored nodes are equivalent to the node "
"being stored and which are considered valid caching sources."
msgstr ""

#: ../../source/howto/run_workflows.rst:5
msgid "How to run multi-step workflows"
msgstr ""

#: ../../source/howto/run_workflows.rst:8
msgid "Launching a predefined workflow"
msgstr ""

#: ../../source/howto/run_workflows.rst:10
msgid ""
"The first step to launching a predefined workflow is loading the work "
"function or work chain class that defines the workflow you want to run. The "
"recommended method for loading a workflow is using the ``WorkflowFactory``, "
"for example:"
msgstr ""

#: ../../source/howto/run_workflows.rst:19
msgid ""
"This is essentially the same as importing the workflow from its respective "
"module, but using the ``WorkflowFactory`` has the advantage that the so "
"called *entry point* (e.g. ``'core.arithmetic.multiply_add'``) will not "
"change when the packages or plugins are reorganised. This means your code is"
" less likely to break when updating AiiDA or the plugin that supplies the "
"workflow."
msgstr ""

#: ../../source/howto/run_workflows.rst:22
msgid ""
"The list of installed plugins can be easily accessed via the verdi CLI:"
msgstr ""

#: ../../source/howto/run_workflows.rst:28
msgid "To see the list of workflow entry points, simply use:"
msgstr ""

#: ../../source/howto/run_workflows.rst:34
msgid ""
"By further specifying the entry point of the workflow, you can see its "
"description, inputs, outputs and exit codes:"
msgstr ""

#: ../../source/howto/run_workflows.rst:41
msgid "Work functions"
msgstr ""

#: ../../source/howto/run_workflows.rst:43
msgid ""
"Running a work function is as simple as calling a typical Python function: "
"simply call it with the required input arguments:"
msgstr ""

#: ../../source/howto/run_workflows.rst:53
msgid ""
"Here, the ``add_and_multiply`` work function returns the output ``Int`` node"
" and we assign it to the variable ``result``. Note that the input arguments "
"of a work function must be an instance of ``Data`` node, or any of its "
"subclasses. Just calling the ``add_and_multiply`` function with regular "
"integers will result in a ``ValueError``, as these cannot be stored in the "
"provenance graph."
msgstr ""

#: ../../source/howto/run_workflows.rst:59
msgid ""
"If a function argument is a Python base type (i.e. a value of type ``bool``,"
" ``dict``, ``Enum``, ``float``, ``int``, ``list`` or ``str``), it can be "
"passed straight away to the function, without first having to wrap it in the"
" corresponding AiiDA data type. That is to say, you can run the example "
"above also as:"
msgstr ""

#: ../../source/howto/run_workflows.rst:66
msgid ""
"and AiiDA will recognize that the arguments are of type ``int`` and "
"automatically wrap them in an ``Int`` node. The same goes for argument "
"defaults; if the argument accepts a Python base type it can specify a "
"default value for it. This will be automatically converted to the "
"corresponding AiiDA data type when the function is called:"
msgstr ""

#: ../../source/howto/run_workflows.rst:78
msgid "The result will be an ``Int`` node with the value ``20``."
msgstr ""

#: ../../source/howto/run_workflows.rst:83
msgid ""
"Although the example above shows the most straightforward way to run the "
"``add_and_multiply`` work function, there are several other ways of running "
"processes that can return more than just the result. For example, the "
"``run_get_node`` function from the AiiDA engine returns both the result of "
"the workflow and the work function node. See the :ref:`corresponding topics "
"section for more details <topics:processes:usage:launching>`."
msgstr ""

#: ../../source/howto/run_workflows.rst:88
msgid "Work chains"
msgstr ""

#: ../../source/howto/run_workflows.rst:90
msgid ""
"To launch a work chain, you can either use the ``run`` or ``submit`` "
"functions. For either function, you need to provide the class of the work "
"chain as the first argument, followed by the inputs as keyword arguments. "
"When \"running the work chain\" (using the ``run`` function), it will be "
"executed in the same system process as the interpreter in which it is "
"launched:"
msgstr ""

#: ../../source/howto/run_workflows.rst:105
msgid ""
"Alternatively, you can first construct a dictionary of the inputs, and pass "
"it to the ``run`` function by taking advantage of `Python's automatic "
"keyword expansion "
"<https://docs.python.org/3/tutorial/controlflow.html#unpacking-argument-"
"lists>`_:"
msgstr ""

#: ../../source/howto/run_workflows.rst:112
msgid ""
"This is particularly useful in case you have a workflow with a lot of "
"inputs. In both cases, running the ``MultiplyAddWorkChain`` workflow returns"
" the **results** of the workflow, i.e. a dictionary of the nodes that are "
"produced as outputs, where the keys of the dictionary correspond to the "
"labels of each respective output."
msgstr ""

#: ../../source/howto/run_workflows.rst:117
msgid ""
"Similar to other processes, there are multiple functions for launching a "
"work chain. See the section on :ref:`launching processes for more "
"details<topics:processes:usage:launching>`."
msgstr ""

#: ../../source/howto/run_workflows.rst:120
msgid ""
"Since *running* a workflow will block the interpreter, you will have to wait"
" until the workflow is finished before you get back control. Moreover, you "
"won't be able to turn your computer or even your terminal off until the "
"workflow has fully terminated, and it is difficult to run multiple workflows"
" in parallel. So, it is advisable to *submit* more complex or longer work "
"chains to the daemon:"
msgstr ""

#: ../../source/howto/run_workflows.rst:136
msgid ""
"Note that when using ``submit`` the work chain is not run in the local "
"interpreter but is sent off to the daemon and you get back control "
"instantly. This allows you to submit multiple work chains at the same time "
"and the daemon will start working on them in parallel. Once the ``submit`` "
"call returns, you will not get the result as with ``run``, but you will get "
"the **node** that represents the work chain. Submitting a work chain instead"
" of directly running it not only makes it easier to execute multiple work "
"chains in parallel, but also ensures that the progress of a workchain is not"
" lost when you restart your computer."
msgstr ""

#: ../../source/howto/run_workflows.rst:143
msgid ""
"As of AiiDA v1.5.0, it is possible to submit both work *chains* and work "
"*functions* to the daemon. Older versions only allow the submission of work "
"*chains*, whereas work *functions* cannot be submitted to the daemon, and "
"hence can only be *run*."
msgstr ""

#: ../../source/howto/run_workflows.rst:145
msgid ""
"If you are unfamiliar with the inputs of a particular ``WorkChain``, a "
"convenient tool for setting up the work chain is the :ref:`process "
"builder<topics:processes:usage:builder>`. This can be obtained by using the "
"``get_builder()`` method, which is implemented for every ``CalcJob`` and "
"``WorkChain``:"
msgstr ""

#: ../../source/howto/run_workflows.rst:155
msgid ""
"To explore the inputs of the work chain, you can use tab autocompletion by "
"typing ``builder.`` and then hitting ``TAB``. If you want to get more "
"details on a specific input, you can simply add a ``?`` and press enter:"
msgstr ""

#: ../../source/howto/run_workflows.rst:165
msgid ""
"Here you can see that the ``x`` input is required, needs to be of the "
"``Int`` type and is stored in the database (``\"non_db\": \"False\"``)."
msgstr ""

#: ../../source/howto/run_workflows.rst:167
msgid ""
"Using the builder, the inputs of the ``WorkChain`` can be provided one by "
"one:"
msgstr ""

#: ../../source/howto/run_workflows.rst:176
msgid ""
"Once the *required* inputs of the workflow have been provided to the "
"builder, you can either run the work chain or submit it to the daemon:"
msgstr ""

#: ../../source/howto/run_workflows.rst:185
msgid ""
"For more detail on the process builder, see the :ref:`corresponding topics "
"section<topics:processes:usage:builder>`."
msgstr ""

#: ../../source/howto/run_workflows.rst:187
msgid ""
"Now that you know how to run a pre-defined workflow, you may want to start "
":ref:`writing your own<how-to:write-workflows>`."
msgstr ""

#: ../../source/howto/share_data.rst:5
msgid "How to share data"
msgstr ""

#: ../../source/howto/share_data.rst:7
msgid ""
"AiiDA offers two avenues for sharing data with others: archive files and the"
" REST API."
msgstr ""

#: ../../source/howto/share_data.rst:13
msgid "Sharing AiiDA archives"
msgstr ""

#: ../../source/howto/share_data.rst:15
msgid ""
"You have performed your calculations with AiiDA and you would like to share "
"your AiiDA provenance graph, for example to make your scientific study "
"reproducible."
msgstr ""

#: ../../source/howto/share_data.rst:17
msgid ""
"Since AiiDA keeps track of the provenance of every computed result, this "
"step is easy: Tell AiiDA the **final results** you would like to be "
"reproducible, and AiiDA will automatically include their entire provenance "
"using the :ref:`topics:provenance:consistency:traversal-rules`."
msgstr ""

#: ../../source/howto/share_data.rst:20
msgid ""
":ref:`internal_architecture:storage:sqlite_zip` and :ref:`how-"
"to:data:share:archive:profile`."
msgstr ""

#: ../../source/howto/share_data.rst:23
msgid "Exporting individual nodes"
msgstr ""

#: ../../source/howto/share_data.rst:25
msgid ""
"Let's say the key results of your study are contained in three AiiDA nodes "
"with PKs ``12``, ``123``, ``1234``. Exporting those results together with "
"their provenance is as easy as:"
msgstr ""

#: ../../source/howto/share_data.rst:32
msgid ""
"As usual, you can use any identifier (label, PK or UUID) to specify the "
"nodes to be exported."
msgstr ""

#: ../../source/howto/share_data.rst:34
msgid ""
"The resulting archive file ``my-calculations.aiida`` contains all "
"information pertaining to the exported nodes. The default traversal rules "
"make sure to include the complete provenance of any node specified and "
"should be sufficient for most cases. See ``verdi archive create --help`` for"
" ways to modify the traversal rules."
msgstr ""

#: ../../source/howto/share_data.rst:40
msgid ""
"To see what would be exported, before exporting, you can use the ``--test-"
"run`` option:"
msgstr ""

#: ../../source/howto/share_data.rst:46
msgid ""
"Please remember to use **UUIDs** when pointing your colleagues to data "
"*inside* an AiiDA archive, since UUIDs are guaranteed to be universally "
"unique (while PKs aren't)."
msgstr ""

#: ../../source/howto/share_data.rst:49
msgid "Exporting large numbers of nodes"
msgstr ""

#: ../../source/howto/share_data.rst:51
msgid ""
"If the number of results to be exported is large, for example in a high-"
"throughput study, use the ``QueryBuilder`` to add the corresponding nodes to"
" a group ``my-results`` (see :ref:`how-to:data:organize:group`). Then export"
" the group:"
msgstr ""

#: ../../source/howto/share_data.rst:58
msgid "Alternatively, export your entire profile with:"
msgstr ""

#: ../../source/howto/share_data.rst:65
msgid "Publishing AiiDA archive files"
msgstr ""

#: ../../source/howto/share_data.rst:67
msgid ""
"AiiDA archive files can be published on any research data repository, for "
"example the `Materials Cloud Archive`_, `Zenodo`_, or the `Open Science "
"Framework`_. When publishing AiiDA archives on the `Materials Cloud "
"Archive`_, you also get an interactive *EXPLORE* section, which allows peers"
" to browse the AiiDA provenance graph directly in the browser."
msgstr ""

#: ../../source/howto/share_data.rst:75
msgid "Inspecting an archive"
msgstr ""

#: ../../source/howto/share_data.rst:77
msgid ""
"In order to get a quick overview of an archive file *without* importing it "
"into your AiiDA profile, use ``verdi archive info``:"
msgstr ""

#: ../../source/howto/share_data.rst:147
msgid ""
"You can also use the Python API to inspect the archive file as a profile, "
"see :ref:`how-to:data:share:archive:profile`."
msgstr ""

#: ../../source/howto/share_data.rst:150
msgid "Importing an archive"
msgstr ""

#: ../../source/howto/share_data.rst:152
msgid ""
"Use ``verdi archive import`` to import AiiDA archives into your current "
"AiiDA profile. ``verdi archive import`` accepts URLs, e.g.:"
msgstr ""

#: ../../source/howto/share_data.rst:159
msgid ""
"During import, AiiDA will avoid identifier collisions and node duplication "
"based on UUIDs (and email comparisons for :py:class:`~aiida.orm.users.User` "
"entries). By default, existing entities will be updated with the most recent"
" changes. Node extras and comments have special modes for determining how to"
" import them - for more details, see ``verdi archive import --help``."
msgstr ""

#: ../../source/howto/share_data.rst:163
msgid ""
"To see what would be imported, before importing, you can use the ``--test-"
"run`` option:"
msgstr ""

#: ../../source/howto/share_data.rst:169
msgid ""
"The AiiDA archive format has evolved over time, but you can still import "
"archives created with previous AiiDA versions. If an outdated archive "
"version is detected during import, the archive file will be automatically "
"migrated to the newest version (within a temporary folder) and the import "
"retried."
msgstr ""

#: ../../source/howto/share_data.rst:172
msgid ""
"You can also use ``verdi archive migrate`` to create updated archive files "
"from existing archive files (or update them in place)."
msgstr ""

#: ../../source/howto/share_data.rst:177
msgid "Serving data through the REST API"
msgstr ""

#: ../../source/howto/share_data.rst:179
msgid ""
"The AiiDA REST API allows to query your AiiDA database over HTTP(S) and "
"returns results in :ref:`JSON format <reference:rest-api:endpoints-"
"responses>`."
msgstr ""

#: ../../source/howto/share_data.rst:183
msgid ""
"As of October 2020, the AiiDA REST API only supports ``GET`` methods "
"(reading); in particular, it does *not* yet support workflow management. "
"This feature is, however, part of the `AiiDA roadmap "
"<https://github.com/aiidateam/aiida-core/wiki/AiiDA-release-roadmap>`_."
msgstr ""

#: ../../source/howto/share_data.rst:188
msgid ""
"To ensure that when serving ``orm.ArrayData`` one always obtains a valid "
"JSON compliant with the `ECMA-262 standard <https://www.ecma-"
"international.org/publications-and-standards/standards/ecma-262/>`_, any "
"``np.nan``, ``np.inf`` and/or ``-np.inf`` entries will be replaced by "
"``None`` which will be rendered as ``null`` when getting the array via the "
"API call."
msgstr ""

#: ../../source/howto/share_data.rst:194
msgid "Launching the REST API"
msgstr ""

#: ../../source/howto/share_data.rst:196
msgid "Start serving data from your default AiiDA profile via the REST API:"
msgstr ""

#: ../../source/howto/share_data.rst:209
msgid "The REST API is now running on port ``5000`` of your local computer."
msgstr ""

#: ../../source/howto/share_data.rst:211
msgid ""
"Like all ``verdi`` commands, you can select a different AiiDA profile via "
"the ``-p PROFILE`` option:"
msgstr ""

#: ../../source/howto/share_data.rst:219
msgid "REST API version history:"
msgstr ""

#: ../../source/howto/share_data.rst:221
msgid ""
"``aiida-core`` >= 1.0.0b6: ``v4``. Simplified endpoints; only ``/nodes``, "
"``/processes``, ``/calcjobs``, ``/groups``, ``/computers`` and ``/servers`` "
"remain."
msgstr ""

#: ../../source/howto/share_data.rst:222
msgid ""
"``aiida-core`` >= 1.0.0b3, <1.0.0b6: ``v3``. Development version, never "
"shipped with a stable release."
msgstr ""

#: ../../source/howto/share_data.rst:223
msgid ""
"``aiida-core`` <1.0.0b3: ``v2``. First API version, with new endpoints added"
" step by step."
msgstr ""

#: ../../source/howto/share_data.rst:229
msgid "Querying the REST API"
msgstr ""

#: ../../source/howto/share_data.rst:231
msgid "A URL to query the REST API consists of:"
msgstr ""

#: ../../source/howto/share_data.rst:233
msgid "The *base URL*, by default:"
msgstr ""

#: ../../source/howto/share_data.rst:235
msgid "http://127.0.0.1:5000/api/v4"
msgstr ""

#: ../../source/howto/share_data.rst:237
msgid "Querying the base URL returns a list of all available endpoints."
msgstr ""

#: ../../source/howto/share_data.rst:239
msgid ""
"The *path* defining the requested *resource*, optionally followed by a more "
"specific *endpoint*. For example::"
msgstr ""

#: ../../source/howto/share_data.rst:248
msgid ""
"If no endpoint is appended, the API returns a list of objects of that "
"resource. In order to request a specific object of a resource, append its "
"*UUID*."
msgstr ""

#: ../../source/howto/share_data.rst:253
msgid "As usual, you can use partial UUIDs as long as they are unique."
msgstr ""

#: ../../source/howto/share_data.rst:255
msgid ""
"In order to query by *PK* you need to use the ``id`` filter (see below). "
"This also applies to :py:class:`~aiida.orm.users.User` s, which don't have "
"UUIDs (but instead uses email)."
msgstr ""

#: ../../source/howto/share_data.rst:258
msgid ""
"(Optional) The *query string* for filtering, ordering and pagination of "
"results. For example::"
msgstr ""

#: ../../source/howto/share_data.rst:265
msgid "Here are some examples to try::"
msgstr ""

#: ../../source/howto/share_data.rst:273
msgid ""
"The interactive `EXPLORE sections on Materials Cloud "
"<https://www.materialscloud.org/explore/menu>`_ are all powered by the AiiDA"
" REST API and you can query the underlying API, either using your web "
"browser or using a tool like ``curl``:"
msgstr ""

#: ../../source/howto/share_data.rst:279
msgid ""
"For an extensive user documentation of the endpoints, the query string as "
"well as the format of the responses, see the :ref:`AiiDA REST API reference "
"<reference:rest-api>`."
msgstr ""

#: ../../source/howto/share_data.rst:283
msgid ""
"It is possible to allow a request to declare a specific profile for which to"
" run the profile. This makes it possible to use a single REST API to serve "
"the content of all configured profiles. The profile switching functionality "
"is disabled by default but can be enabled through the config:"
msgstr ""

#: ../../source/howto/share_data.rst:291
msgid ""
"After the REST API is restarted, it will now accept the `profile` query "
"parameter, for example:"
msgstr ""

#: ../../source/howto/share_data.rst:297
msgid ""
"If the specified is already loaded, the REST API functions exactly as "
"without profile switching enabled. If another profile is specified, the REST"
" API will first switch profiles before executing the request."
msgstr ""

#: ../../source/howto/share_data.rst:302
msgid ""
"If the profile parameter is specified in a request and the REST API does not"
" have profile switching enabled, a 400 response is returned."
msgstr ""

#: ../../source/howto/share_data.rst:307
msgid "Deploying a REST API server"
msgstr ""

#: ../../source/howto/share_data.rst:309
msgid ""
"The ``verdi restapi`` command runs the REST API through the ``werkzeug`` "
"python-based HTTP server. In order to deploy production instances of the "
"REST API for serving your data to others, we recommend using a fully fledged"
" web server, such as `Apache <https://httpd.apache.org/>`_ or `NGINX "
"<https://www.nginx.com/>`_, which then runs the REST API python application "
"through the `web server gateway interface (WSGI) "
"<https://wsgi.readthedocs.io/>`_."
msgstr ""

#: ../../source/howto/share_data.rst:313
msgid ""
"One Apache/NGINX server can host multiple instances of the REST APIs, e.g. "
"serving data from different AiiDA profiles."
msgstr ""

#: ../../source/howto/share_data.rst:315
msgid ""
"A ``myprofile-rest.wsgi`` script for an AiiDA profile ``myprofile`` would "
"look like this:"
msgstr ""

#: ../../source/howto/share_data.rst:319
msgid ""
"See the documentation of :py:func:`~aiida.restapi.run_api.configure_api` for"
" all available configuration options."
msgstr ""

#: ../../source/howto/share_data.rst:321
msgid ""
"In the following, we explain how to run this wsgi application using Apache "
"on Ubuntu."
msgstr ""

#: ../../source/howto/share_data.rst:323
msgid ""
"Install and enable the ``mod_wsgi`` `WSGI module "
"<https://modwsgi.readthedocs.io/>`_ module:"
msgstr ""

#: ../../source/howto/share_data.rst:330
msgid ""
"Place the WSGI script in a folder on your server, for example "
"``/home/ubuntu/wsgi/myprofile-rest.wsgi``."
msgstr ""

#: ../../source/howto/share_data.rst:332
msgid ""
"Configure apache to run the WSGI application using a virtual host "
"configuration similar to:"
msgstr ""

#: ../../source/howto/share_data.rst:336
msgid "Place this ``aiida-rest.conf`` file in ``/etc/apache2/sites-enabled``"
msgstr ""

#: ../../source/howto/share_data.rst:338
msgid "Restart apache: ``sudo service apache2 restart``."
msgstr ""

#: ../../source/howto/share_data.rst:340
msgid ""
"You should now be able to reach your REST API at "
"``localhost/myprofile/api/v4`` (Port 80)."
msgstr ""

#: ../../source/howto/ssh.rst:5
msgid "How to setup SSH connections"
msgstr ""

#: ../../source/howto/ssh.rst:7
msgid ""
"AiiDA communicates with remote computers via the SSH protocol. There are two"
" ways of setting up an SSH connection for AiiDA:"
msgstr ""

#: ../../source/howto/ssh.rst:10
msgid "Using a passwordless SSH key (easier, less safe)"
msgstr ""

#: ../../source/howto/ssh.rst:11
msgid ""
"Using a password-protected SSH key through ``ssh-agent`` (one more step, "
"safer)"
msgstr ""

#: ../../source/howto/ssh.rst:16
msgid "Using a passwordless SSH key"
msgstr ""

#: ../../source/howto/ssh.rst:19
msgid ""
"There are numerous tutorials on the web, see e.g. `here "
"<https://www.redhat.com/sysadmin/passwordless-ssh>`_. Very briefly, first "
"create a new private/public keypair (``aiida``/``aiida.pub``), leaving "
"passphrase emtpy:"
msgstr ""

#: ../../source/howto/ssh.rst:26
msgid ""
"Copy the public key to the remote machine, normally this will add the public"
" key to the remote machine's ``~/.ssh/authorized_keys``:"
msgstr ""

#: ../../source/howto/ssh.rst:32
msgid ""
"Add the following lines to your ``~/.ssh/config`` file (or create it, if it "
"does not exist):"
msgstr ""

#: ../../source/howto/ssh.rst:42
msgid ""
"If your cluster needs you to connect to another computer *PROXY* first, you "
"can use the ``ProxyJump`` or ``ProxyCommand`` feature of SSH, see :ref:`how-"
"to:ssh:proxy`."
msgstr ""

#: ../../source/howto/ssh.rst:44
msgid ""
"You should now be able to access the remote computer (without the need to "
"type a password) *via*:"
msgstr ""

#: ../../source/howto/ssh.rst:52
msgid "Connection closed failures"
msgstr ""

#: ../../source/howto/ssh.rst:56
msgid ""
"If the ``ssh`` command works, but the ``sftp`` command prints ``Connection "
"closed``, there may be a line in the ``~/.bashrc`` file **on the cluster** "
"that either produces text output or an error. Remove/comment lines from this"
" file until no output or error is produced: this should make ``sftp`` work "
"again."
msgstr ""

#: ../../source/howto/ssh.rst:59
msgid ""
"Finally, if you are planning to use a batch scheduler on the remote "
"computer, try also:"
msgstr ""

#: ../../source/howto/ssh.rst:65
msgid ""
"replacing ``QUEUE_VISUALIZATION_COMMAND`` by ``squeue`` (SLURM), ``qstat`` "
"(PBSpro) or the equivalent command of your scheduler and check that it "
"prints a list of the job queue without errors."
msgstr ""

#: ../../source/howto/ssh.rst:67
msgid "Scheduler errors?"
msgstr ""

#: ../../source/howto/ssh.rst:70
msgid ""
"If the previous command errors with ``command not found``, while the same "
"``QUEUE_VISUALIZATION_COMMAND`` works fine after you've logged in via SSH, "
"it may be that a guard in the ``.bashrc`` file on the cluster prevents "
"necessary modules from being loaded."
msgstr ""

#: ../../source/howto/ssh.rst:72
msgid "Look for lines like:"
msgstr ""

#: ../../source/howto/ssh.rst:78
msgid "or:"
msgstr ""

#: ../../source/howto/ssh.rst:87
msgid "which will prevent any instructions that follow from being executed."
msgstr ""

#: ../../source/howto/ssh.rst:89
msgid ""
"You can either move relevant instructions before these lines or delete the "
"guards entirely. If you are wondering whether the ``PATH`` environment "
"variable is set correctly, you can check its value using:"
msgstr ""

#: ../../source/howto/ssh.rst:99
msgid "Using passphrase-protected keys *via* an ssh-agent"
msgstr ""

#: ../../source/howto/ssh.rst:102
msgid ""
"Tools like ``ssh-agent`` (available on most Linux distros and MacOS) allow "
"you to enter the passphrase of a protected key *once* and provide access to "
"the decrypted key for as long as the agent is running. This allows you to "
"use a passphrase-protected key (required by some HPC centres), while making "
"the decrypted key available to AiiDA for automatic SSH operations."
msgstr ""

#: ../../source/howto/ssh.rst:106
msgid "Creating the key"
msgstr ""

#: ../../source/howto/ssh.rst:108
msgid ""
"Start by following the instructions above for :ref:`how-"
"to:ssh:passwordless`, the only difference being that you enter a passphrase "
"when creating the key (and when logging in to the remote computer)."
msgstr ""

#: ../../source/howto/ssh.rst:111
msgid "Adding the key to the agent"
msgstr ""

#: ../../source/howto/ssh.rst:113
msgid "Now provide the passphrase for your private key to the agent:"
msgstr ""

#: ../../source/howto/ssh.rst:119
msgid ""
"The private key and the relative passphrase are now recorded in an instance "
"of the agent."
msgstr ""

#: ../../source/howto/ssh.rst:123
msgid ""
"The passphase is stored in the agent only until the next reboot. If you shut"
" down or restart the AiiDA machine, before starting the AiiDA deamon "
"remember to run the ``ssh-add`` command again."
msgstr ""

#: ../../source/howto/ssh.rst:127
msgid "Starting the ssh-agent"
msgstr ""

#: ../../source/howto/ssh.rst:129
msgid ""
"On most modern Linux installations, the ``ssh-agent`` starts automatically "
"at login (e.g. Ubuntu 16.04 and later or MacOS 10.5 and later). If you "
"received an error ``Could not open a connection to your authentication "
"agent``, you will need to start the agent manually instead."
msgstr ""

#: ../../source/howto/ssh.rst:132
msgid ""
"Check whether you can start an ``ssh-agent`` **in your current shell**:"
msgstr ""

#: ../../source/howto/ssh.rst:138
msgid ""
"In order to reuse the same agent instance everywhere (including the AiiDA "
"daemon), the environment variables of ``ssh-agent`` need to be reused by "
"*all* shells. Download the script :download:`load-singlesshagent.sh "
"<include/load-singlesshagent.sh>` and place it e.g. in ``~/bin``. Then add "
"the following lines to your ``~/.bashrc`` file:"
msgstr ""

#: ../../source/howto/ssh.rst:148
msgid "To check that it works:"
msgstr ""

#: ../../source/howto/ssh.rst:150
msgid "Open a new shell (``~/.bashrc`` file is sourced)."
msgstr ""

#: ../../source/howto/ssh.rst:151
msgid "Run ``ssh-add``."
msgstr ""

#: ../../source/howto/ssh.rst:152
msgid "Close the shell."
msgstr ""

#: ../../source/howto/ssh.rst:153
msgid "Open a new shell and try logging in to the remote computer."
msgstr ""

#: ../../source/howto/ssh.rst:155
msgid ""
"Try logging in to the remote computer; it should no longer require a "
"passphrase."
msgstr ""

#: ../../source/howto/ssh.rst:157
msgid ""
"The key and its corresponding passphrase are now stored by the agent until "
"it is stopped. After a reboot, remember to run ``ssh-add ~/.ssh/aiida`` "
"again before starting the AiiDA daemon."
msgstr ""

#: ../../source/howto/ssh.rst:161
msgid "Integrating the ssh-agent with keychain on OSX"
msgstr ""

#: ../../source/howto/ssh.rst:163
msgid ""
"On OSX Sierra and later, the native ``ssh-add`` client allows passphrases to"
" be stored persistently in the `OSX keychain <https://support.apple.com/en-"
"gb/guide/keychain-access/kyca1083/mac>`__. Store the passphrase in the "
"keychain using the OSX-specific ``-k`` argument:"
msgstr ""

#: ../../source/howto/ssh.rst:170
msgid ""
"To instruct ssh to look in the OSX keychain for key passphrases, add the "
"following lines to ``~/.ssh/config``:"
msgstr ""

#: ../../source/howto/ssh.rst:178 ../../source/howto/ssh.rst:245
msgid "AiiDA configuration"
msgstr ""

#: ../../source/howto/ssh.rst:180
msgid ""
"When :ref:`configuring the computer in AiiDA <how-to:run-"
"codes:computer:configuration>`, simply make sure that ``Allow ssh agent`` is"
" set to ``true`` (default)."
msgstr ""

#: ../../source/howto/ssh.rst:185
msgid "Connecting to a remote computer *via* a proxy server"
msgstr ""

#: ../../source/howto/ssh.rst:187
msgid ""
"Some compute clusters require you to connect to an intermediate server "
"*PROXY*, from which you can then connect to the cluster *TARGET* on which "
"you run your calculations. This section explains how to use the "
"``ProxyJump`` or ``ProxyCommand`` feature of ``ssh`` in order to make this "
"jump automatically."
msgstr ""

#: ../../source/howto/ssh.rst:192
msgid ""
"This method can also be used to avoid having to start a virtual private "
"network (VPN) client if you have an SSH account on a proxy/jumphost server "
"which is accessible from your current network **and** from which you can "
"access the *TARGET* machine directly."
msgstr ""

#: ../../source/howto/ssh.rst:196
msgid "SSH configuration"
msgstr ""

#: ../../source/howto/ssh.rst:198
msgid ""
"To decide whether to use the ``ProxyJump`` (recommended) or the "
"``ProxyCommand`` directive, please check the version of your SSH client "
"first with ``ssh -V``. The ``ProxyJump`` directive has been added in version"
" 7.3 of OpenSSH, hence if you are using an older version of SSH (on your "
"machine or the *PROXY*) you have to use the older ``ProxyCommand``."
msgstr ""

#: ../../source/howto/ssh.rst:201
msgid ""
"To setup the proxy configuration with ``ProxyJump``, edit the "
"``~/.ssh/config`` file on the computer on which you installed AiiDA (or "
"create it if missing) and add the following lines::"
msgstr ""

#: ../../source/howto/ssh.rst:213 ../../source/howto/ssh.rst:229
msgid ""
"Replace the ``..._TARGET`` and ``..._PROXY`` variables with the host/user "
"names of the respective servers."
msgstr ""

#: ../../source/howto/ssh.rst:0
msgid ":fa:`plus-circle` Alternative setup with ``ProxyCommand``"
msgstr ""

#: ../../source/howto/ssh.rst:217
msgid ""
"To setup the proxy configuration with ``ProxyCommand`` **instead**, edit the"
" ``~/.ssh/config`` file on the computer on which you installed AiiDA (or "
"create it if missing) and add the following lines::"
msgstr ""

#: ../../source/howto/ssh.rst:231
msgid ""
"In both cases, this should allow you to directly connect to the *TARGET* "
"server using"
msgstr ""

#: ../../source/howto/ssh.rst:241
msgid ""
"If the user directory is not shared between the *PROXY* and the *TARGET* (in"
" most supercomputing facilities your user directory is shared between the "
"machines), you need to follow the :ref:`instructions for a passwordless "
"connection <how-to:ssh:passwordless>` *twice*: once for the connection from "
"your computer to the *PROXY* server, and once for the connection from the "
"*PROXY* server to the *TARGET* server (e.g. the public key must be listed in"
" the ``~/.ssh/authorized_keys`` file of both the *PROXY* and the *TARGET* "
"server)."
msgstr ""

#: ../../source/howto/ssh.rst:247
msgid ""
"When :ref:`configuring the computer in AiiDA <how-to:run-"
"codes:computer:configuration>`, AiiDA will automatically parse most of "
"required information from your ``~/.ssh/config`` file. A notable exception "
"to this is the ``proxy_jump`` directive, which **must** be specified "
"manually."
msgstr ""

#: ../../source/howto/ssh.rst:249
msgid ""
"Simply copy & paste the same instructions as you have used for ``ProxyJump``"
" in your ``~/.ssh/config`` to the input for ``proxy_jump``:"
msgstr ""

#: ../../source/howto/ssh.rst:258
msgid ""
"A chain of proxies can be specified as a comma-separated list. If you need "
"to specify a different username, you can so with ``USER_PROXY@...``. If no "
"username is specified for the proxy the same username as for the *TARGET* is"
" used."
msgstr ""

#: ../../source/howto/ssh.rst:260
msgid "Specifying the ``proxy_command`` manually"
msgstr ""

#: ../../source/howto/ssh.rst:262
msgid ""
"When specifying or updating the ``proxy_command`` option via ``verdi "
"computer configure ssh``, please **do not use placeholders** ``%h`` and "
"``%p`` but provide the *actual* hostname and port. AiiDA replaces them only "
"when parsing from the ``~/.ssh/config`` file."
msgstr ""

#: ../../source/howto/ssh.rst:267
msgid "Using kerberos tokens"
msgstr ""

#: ../../source/howto/ssh.rst:269
msgid ""
"If the remote machine requires authentication through a Kerberos token (that"
" you need to obtain before using ssh), you typically need to"
msgstr ""

#: ../../source/howto/ssh.rst:271
msgid "install ``libffi`` (``sudo apt-get install libffi-dev`` under Ubuntu)"
msgstr ""

#: ../../source/howto/ssh.rst:272
msgid ""
"install the ``ssh_kerberos`` extra during the installation of aiida-core "
"(see :ref:`intro:install:setup`)."
msgstr ""

#: ../../source/howto/ssh.rst:274
msgid ""
"If you provide all necessary ``GSSAPI`` options in your ``~/.ssh/config`` "
"file, ``verdi computer configure`` should already pick up the appropriate "
"values for all the gss-related options."
msgstr ""

#: ../../source/howto/visualising_graphs.md:16
msgid "How to visualize provenance"
msgstr ""

#: ../../source/howto/visualising_graphs.md:19
msgid ""
"This tutorial can be downloaded and run as a Jupyter Notebook: {nb-"
"download}`visualising_graphs.ipynb` {octicon}`download`"
msgstr ""

#: ../../source/howto/visualising_graphs.md:22
msgid ""
"The provenance graph of a database can be visually inspected, *via* "
"[graphviz](https://www.graphviz.org/), using both the python API and "
"command-line interface."
msgstr ""

#: ../../source/howto/visualising_graphs.md:25
msgid "`verdi graph generate -h`"
msgstr ""

#: ../../source/howto/visualising_graphs.md:28
msgid ""
"We first load a profile, containing the provenance graph (in this case we "
"load an archive as the profile)."
msgstr ""

#: ../../source/howto/visualising_graphs.md:45
msgid ""
"The {py:class}`~aiida.tools.visualization.graph.Graph` class is used to "
"store visual representations of the nodes and edges, which can be added "
"separately or cumulatively by one of the graph traversal methods. The "
"{py:attr}`~aiida.tools.visualization.graph.Graph.graphviz` attribute returns"
" a [graphviz.Digraph](https://graphviz.readthedocs.io/en/stable/) instance, "
"which will auto-magically render the graph in the notebook, or can be used "
"to save the graph to file."
msgstr ""

#: ../../source/howto/visualising_graphs.md:68
msgid ""
"The {py:class}`~aiida.tools.visualization.graph.Graph` can also be "
"initialized with global style attributes, as outlined in the [graphviz "
"attributes table](https://www.graphviz.org/doc/info/attrs.html)."
msgstr ""

#: ../../source/howto/visualising_graphs.md:81
msgid ""
"Additionally functions can be parsed to the "
"{py:class}`~aiida.tools.visualization.graph.Graph` initializer, to specify "
"exactly how each node will be represented. For example, the "
"{py:func}`~aiida.tools.visualization.graph.pstate_node_styles` function "
"colors process nodes by their process state."
msgstr ""

#: ../../source/howto/visualising_graphs.md:95
msgid ""
"Edges can be annotated by one or both of their edge label and link type."
msgstr ""

#: ../../source/howto/visualising_graphs.md:106
msgid ""
"The {py:meth}`~aiida.tools.visualization.graph.Graph.recurse_descendants` "
"and {py:meth}`~aiida.tools.visualization.graph.Graph.recurse_ancestors` "
"methods can be used to construct a full provenance graph."
msgstr ""

#: ../../source/howto/visualising_graphs.md:119
msgid ""
"The link types can also be filtered, to view only the 'data' or 'logical' "
"provenance."
msgstr ""

#: ../../source/howto/visualising_graphs.md:145
msgid ""
"If you wish to highlight specific node classes, then the `highlight_classes`"
" option can be used to only color specified nodes:"
msgstr ""

#: ../../source/howto/workchains_restart.rst:5
msgid "How to write error-resistant workflows"
msgstr ""

#: ../../source/howto/workchains_restart.rst:7
msgid "Overview"
msgstr ""

#: ../../source/howto/workchains_restart.rst:9
msgid ""
"This how-to introduces the "
":py:class:`~aiida.engine.processes.workchains.restart.BaseRestartWorkChain`,"
" and how it can be sub-classed to handle known failure modes of processes "
"and calculations."
msgstr ""

#: ../../source/howto/workchains_restart.rst:11
msgid ""
"In the :ref:`how-to on writing workflows <how-to:write-workflows>` we "
"discussed how to write a simple multi-step workflow using work chains. "
"However, there is one thing that we did not consider there:"
msgstr ""

#: ../../source/howto/workchains_restart.rst:14
msgid "What if a calculation step fails?"
msgstr ""

#: ../../source/howto/workchains_restart.rst:16
msgid ""
"For example with the "
":py:class:`~aiida.workflows.arithmetic.multiply_add.MultiplyAddWorkChain`; "
"it launches a "
":py:class:`~aiida.calculations.arithmetic.add.ArithmeticAddCalculation`. If "
"that were to fail, the work chain would except because the line "
"``self.ctx.addition.outputs.sum`` will raise an ``AttributeError``. In this "
"case, where the work chain just runs a single calculation, that is not such "
"a big deal but for real-life work chains that run a number of calculations "
"in sequence, having the work chain except will cause all the work up to that"
" point to be lost. Take as an example a workflow that computes the phonons "
"of a crystal structure using Quantum ESPRESSO:"
msgstr ""

#: ../../source/howto/workchains_restart.rst:23
msgid ""
"Schematic diagram of a workflow that computes the phonons of a crystal "
"structure using Quantum ESPRESSO. The workflow consists of four consecutive "
"calculations using the ``pw.x``, ``ph.x``, ``q2r.x`` and ``matdyn.x`` code, "
"respectively."
msgstr ""

#: ../../source/howto/workchains_restart.rst:26
msgid ""
"If all calculations run without problems, the workflow itself will of course"
" also run fine and produce the desired final result. But, now imagine the "
"third calculation actually fails. If the workflow does not explicitly check "
"for this failure, but instead blindly assumes that the calculation have "
"produced the required results, it will fail itself, losing the progress it "
"made with the first two calculations."
msgstr ""

#: ../../source/howto/workchains_restart.rst:32
msgid ""
"Example execution of the Quantum ESPRESSO phonon workflow where the third "
"step, the ``q2r.x`` code, failed, and because the workflow blindly assumed "
"it would have finished without errors also fails."
msgstr ""

#: ../../source/howto/workchains_restart.rst:34
msgid ""
"The solution seems simple then. After each calculation, we simply add a "
"check to verify that it finished successfully and produced the required "
"outputs before continuing with the next calculation. What do we do, though, "
"when the calculation failed? Depending on the cause of the failure, we might"
" actually be able to fix the problem, and re-run the calculation, "
"potentially with corrected inputs. A common example is that the calculation "
"ran out of wall time (requested time from the job scheduler) and was "
"cancelled by the job scheduler. In this case, simply restarting the "
"calculation (if the code supports restarts), and optionally giving the job "
"more wall time or resources, may fix the problem."
msgstr ""

#: ../../source/howto/workchains_restart.rst:41
msgid ""
"You might be tempted to add this error handling directly into the workflow. "
"However, this requires implementing the same error-handling code many times "
"in other workflows that just happen to run the same codes. For example, we "
"could add the error handling for the ``pw.x`` code directly in our phonon "
"workflow, but a structure optimization workflow will also have to run "
"``pw.x`` and will have to implement the same error-handling logic. Is there "
"a way that we can implement this once and easily reuse it in various "
"workflows?"
msgstr ""

#: ../../source/howto/workchains_restart.rst:46
msgid ""
"Yes! Instead of directly running a calculation in a workflow, one should "
"rather run a work chain that is explicitly designed to run the calculation "
"to completion. This *base* work chain knows about the various failure modes "
"of the calculation and can try to fix the problem and restart the "
"calculation whenever it fails, until it finishes successfully. This logic of"
" such a base work chain is very generic and can be applied to any "
"calculation, and actually any process:"
msgstr ""

#: ../../source/howto/workchains_restart.rst:54
msgid ""
"Schematic flow diagram of the logic of a *base* work chain, whose job it is "
"to run a subprocess repeatedly, fixing any potential errors, until it "
"finishes successfully."
msgstr ""

#: ../../source/howto/workchains_restart.rst:56
msgid ""
"The work chain runs the subprocess. Once it has finished, it then inspects "
"the status. If the subprocess finished successfully, the work chain returns "
"the results and its job is done. If, instead, the subprocess failed, the "
"work chain should inspect the cause of failure, and attempt to fix the "
"problem and restart the subprocess. This cycle is repeated until the "
"subprocess finishes successfully. Of course this runs the risk of entering "
"into an infinite loop if the work chain never manages to fix the problem, so"
" we want to build in a limit to the maximum number of calculations that can "
"be re-run:"
msgstr ""

#: ../../source/howto/workchains_restart.rst:68
msgid ""
"An improved flow diagram for the base work chain that limits the maximum "
"number of iterations that the work chain can try and get the calculation to "
"finish successfully."
msgstr ""

#: ../../source/howto/workchains_restart.rst:70
msgid ""
"Since this is such a common logical flow for a base work chain that is to "
"wrap another :py:class:`~aiida.engine.processes.process.Process` and restart"
" it until it is finished successfully, we have implemented it as an abstract"
" base class in ``aiida-core``. The "
":py:class:`~aiida.engine.processes.workchains.restart.BaseRestartWorkChain` "
"implements the logic of the flow diagram shown above. Although the "
"``BaseRestartWorkChain`` is a subclass of "
":py:class:`~aiida.engine.processes.workchains.workchain.WorkChain` itself, "
"you cannot launch it. The reason is that it is completely general and so "
"does not know which :py:class:`~aiida.engine.processes.process.Process` "
"class it should run. Instead, to make use of the base restart work chain, "
"you should subclass it for the process class that you want to wrap."
msgstr ""

#: ../../source/howto/workchains_restart.rst:78
msgid "Writing a base restart work chain"
msgstr ""

#: ../../source/howto/workchains_restart.rst:80
msgid ""
"In this how-to, we will show how to implement the ``BaseRestartWorkChain`` "
"for the "
":py:class:`~aiida.calculations.arithmetic.add.ArithmeticAddCalculation`. We "
"start by importing the relevant base classes and create a subclass:"
msgstr ""

#: ../../source/howto/workchains_restart.rst:95
msgid ""
"As you can see, all we had to do is create a subclass of the "
"``BaseRestartWorkChain`` class, which we called "
"``ArithmeticAddBaseWorkChain``, and set the ``_process_class`` class "
"attribute to ``ArithmeticAddCalculation``. The latter instructs the work "
"chain what type of process it should launch. Next, as with all work chains, "
"we should *define* its process specification:"
msgstr ""

#: ../../source/howto/workchains_restart.rst:121
msgid ""
"The inputs and output that we define are essentially determined by the sub "
"process that the work chain will be running. Since the "
"``ArithmeticAddCalculation`` requires the inputs ``x`` and ``y``, and "
"produces the ``sum`` as output, we `mirror` those in the specification of "
"the work chain, otherwise we wouldn't be able to pass the necessary inputs. "
"Finally, we define the logical outline, which if you look closely, resembles"
" the logical flow chart presented in :numref:`workflow-error-handling-flow-"
"loop` a lot. We start by *setting up* the work chain and then enter a loop: "
"*while* the subprocess has not yet finished successfully *and* we haven't "
"exceeded the maximum number of iterations, we *run* another instance of the "
"process and then *inspect* the results. The while conditions are implemented"
" in the ``should_run_process`` outline step. When the process finishes "
"successfully or we have to abandon, we report the *results*. Now unlike with"
" normal work chain implementations, we *do not* have to implement these "
"outline steps ourselves. They have already been implemented by the "
"``BaseRestartWorkChain`` so that we don't have to. This is why the base "
"restart work chain is so useful, as it saves us from writing and repeating a"
" lot of `boilerplate code "
"<https://en.wikipedia.org/wiki/Boilerplate_code>`__."
msgstr ""

#: ../../source/howto/workchains_restart.rst:133
msgid ""
"This minimal outline definition is required for the work chain to work "
"properly. If you change the logic, the names of the steps or omit some "
"steps, the work chain will not run. Adding extra outline steps to add custom"
" functionality, however, is fine and actually encouraged if it makes sense."
msgstr ""

#: ../../source/howto/workchains_restart.rst:137
msgid ""
"The last part of the puzzle is to define in the setup what inputs the work "
"chain should pass to the subprocess. You might wonder why this is necessary,"
" because we already define the inputs in the specification, but those are "
"not the only inputs that will be passed. The ``BaseRestartWorkChain`` also "
"defines some inputs of its own, such as ``max_iterations`` as you can see in"
" its "
":py:meth:`~aiida.engine.processes.workchains.restart.BaseRestartWorkChain.define`"
" method. To make it absolutely clear what inputs are intended for the "
"subprocess, we define them as a dictionary in the context under the key "
"``inputs``. One way of doing this is to reuse the "
":py:meth:`~aiida.engine.processes.workchains.restart.BaseRestartWorkChain.setup`"
" method:"
msgstr ""

#: ../../source/howto/workchains_restart.rst:154
msgid ""
"Note that, as explained before, the ``setup`` step forms a crucial part of "
"the logical outline of any base restart work chain. Omitting it from the "
"outline will break the work chain, but so will overriding it completely, "
"except as long as we call the ``super``."
msgstr ""

#: ../../source/howto/workchains_restart.rst:157
msgid ""
"This is all the code we have to write to have a functional work chain. We "
"can now launch it like any other work chain and the ``BaseRestartWorkChain``"
" will work its magic:"
msgstr ""

#: ../../source/howto/workchains_restart.rst:164
msgid ""
"Once the work chain finished, we can inspect what has happened with, for "
"example, ``verdi process status``:"
msgstr ""

#: ../../source/howto/workchains_restart.rst:172
msgid ""
"As you can see the work chain launched a single instance of the "
"``ArithmeticAddCalculation`` which finished successfully, so the job of the "
"work chain was done as well."
msgstr ""

#: ../../source/howto/workchains_restart.rst:176
msgid ""
"If the work chain excepted, make sure the directory containing the WorkChain"
" definition is in the ``PYTHONPATH``."
msgstr ""

#: ../../source/howto/workchains_restart.rst:178
msgid ""
"You can add the folder in which you have your Python file defining the "
"WorkChain to the ``PYTHONPATH`` through:"
msgstr ""

#: ../../source/howto/workchains_restart.rst:184
msgid "After this, it is **very important** to restart the daemon:"
msgstr ""

#: ../../source/howto/workchains_restart.rst:190
msgid ""
"Indeed, when updating an existing work chain file or adding a new one, it is"
" **necessary** to restart the daemon **every time** after all changes have "
"taken place."
msgstr ""

#: ../../source/howto/workchains_restart.rst:193
#: ../../source/howto/write_workflows.rst:180
msgid "Exposing inputs and outputs"
msgstr ""

#: ../../source/howto/workchains_restart.rst:195
msgid ""
"Any base restart work chain *needs* to *expose* the inputs of the subprocess"
" it wraps, and most likely *wants* to do the same for the outputs it "
"produces, although the latter is not necessary. For the simple example "
"presented in the previous section, simply copy-pasting the input and output "
"port definitions of the subprocess ``ArithmeticAddCalculation`` was not too "
"troublesome. However, this quickly becomes tedious, and more importantly, "
"error-prone once you start to wrap processes with quite a few more inputs. "
"To prevent the copy-pasting of input and output specifications, the "
":class:`~aiida.engine.processes.process_spec.ProcessSpec` class provides the"
" :meth:`~plumpy.ProcessSpec.expose_inputs` and "
":meth:`~plumpy.ProcessSpec.expose_outputs` methods:"
msgstr ""

#: ../../source/howto/workchains_restart.rst:212
msgid ""
"For more detail on exposing inputs and outputs, see the basic "
":ref:`Workchain usage section "
"<topics:workflows:usage:workchains:expose_inputs_outputs>`."
msgstr ""

#: ../../source/howto/workchains_restart.rst:214
msgid ""
"That takes care of exposing the port specification of the wrapped process "
"class in a very efficient way. To efficiently retrieve the inputs that have "
"been passed to the process, one can use the "
":meth:`~aiida.engine.processes.process.Process.exposed_inputs` method. Note "
"the past tense of the method name. The method takes a process class and an "
"optional namespace as arguments, and will return the inputs that have been "
"passed into that namespace when it was launched. This utility now allows us "
"to simplify the ``setup`` outline step that we have shown before:"
msgstr ""

#: ../../source/howto/workchains_restart.rst:231
msgid ""
"This way we don't have to manually fish out all the individual inputs from "
"the ``self.inputs`` but have to just call this single method, saving a lot "
"of time and lines of code."
msgstr ""

#: ../../source/howto/workchains_restart.rst:233
msgid ""
"When submitting or running the work chain using namespaced inputs (``add`` "
"in the example above), it is important to use the namespace:"
msgstr ""

#: ../../source/howto/workchains_restart.rst:248
msgid ""
"Every time you make changes to the ``ArithmeticAddBaseWorkChain``, don't "
"forget to restart the daemon with:"
msgstr ""

#: ../../source/howto/workchains_restart.rst:256
msgid "Customizing outputs"
msgstr ""

#: ../../source/howto/workchains_restart.rst:258
msgid ""
"By default, the ``BaseRestartWorkChain`` will attach the exposed outputs of "
"the last completed calculation job. In most cases this is the correct "
"behavior, but there might be use-cases where one wants to modify exactly "
"what outputs are attached to the work chain. This can be achieved by "
"overriding the "
":meth:`aiida.engine.processes.workchains.restart.BaseRestartWorkChain.get_outputs`"
" method. For example, if you want to remove a particular output from being "
"attached, you can do the following:"
msgstr ""

#: ../../source/howto/workchains_restart.rst:271
msgid ""
"It is also possible to update the contents of one of the outputs returned by"
" the last completed calculation job. In this case, it is important to go "
"through a ``calcfunction``, as always, as to not lose any provenance."
msgstr ""

#: ../../source/howto/workchains_restart.rst:276
msgid "Attaching outputs"
msgstr ""

#: ../../source/howto/workchains_restart.rst:278
msgid ""
"In a normal run, the ``results`` method is the last step in the outline of "
"the ``BaseRestartWorkChain``. In this step, the outputs of the last "
"completed calculation job are \"attached\" to the work chain itself. The "
"attaching of the outputs is implemented by the "
":meth:`~aiida.engine.processes.workchains.restart.BaseRestartWorkChain._attach_outputs`"
" method. If the outputs need to be attached at a point in the workflow other"
" then the ``results`` step, this method can be called manually. An example "
"would be to call it in a process handler that will abort the work chain. In "
"this case the work chain will be stopped immediately and the ``results`` "
"step would no longer be called."
msgstr ""

#: ../../source/howto/workchains_restart.rst:287
msgid "Error handling"
msgstr ""

#: ../../source/howto/workchains_restart.rst:289
msgid ""
"So far you have seen how easy it is to get a work chain up and running that "
"will run a subprocess using the ``BaseRestartWorkChain``. However, the whole"
" point of this exercise, as described in the introduction, was for the work "
"chain to be able to deal with *failing* processes, yet in the previous "
"example it finished without any problems."
msgstr ""

#: ../../source/howto/workchains_restart.rst:292
msgid "What would have happened if the subprocess had failed?"
msgstr ""

#: ../../source/howto/workchains_restart.rst:294
msgid ""
"If the computed sum of the inputs ``x`` and ``y`` is negative, the "
"``ArithmeticAddCalculation`` fails with exit code ``410`` which corresponds "
"to ``ERROR_NEGATIVE_NUMBER``."
msgstr ""

#: ../../source/howto/workchains_restart.rst:298
msgid ""
"The :ref:`exit code usage section<topics:processes:usage:exit_codes>`, for a"
" more detailed explanation of exit codes."
msgstr ""

#: ../../source/howto/workchains_restart.rst:300
msgid ""
"Let's launch the work chain with inputs that will cause the calculation to "
"fail, e.g. by making one of the operands negative, and see what happens:"
msgstr ""

#: ../../source/howto/workchains_restart.rst:306
msgid ""
"This time we will see that the work chain takes quite a different path:"
msgstr ""

#: ../../source/howto/workchains_restart.rst:315
msgid ""
"As expected, the ``ArithmeticAddCalculation`` failed this time with a "
"``410``. The work chain noticed the failure when inspecting the result of "
"the subprocess in ``inspect_process``, and in keeping with its name and "
"design, restarted the calculation. However, since the inputs were not "
"changed, the calculation inevitably and wholly expectedly failed once more "
"with the exact same error code. Unlike after the first iteration, however, "
"the work chain did not restart again, but gave up and returned the exit code"
" ``402`` itself, which stands for "
"``ERROR_SECOND_CONSECUTIVE_UNHANDLED_FAILURE``. As the name suggests, the "
"work chain tried to run the subprocess but it failed twice in a row without "
"the problem being *handled*. The obvious question now of course is: \"How "
"exactly can we instruct the base work chain to handle certain problems?\""
msgstr ""

#: ../../source/howto/workchains_restart.rst:322
msgid ""
"Since the problems are necessarily dependent on the subprocess that the work"
" chain will run, it cannot be implemented by the ``BaseRestartWorkChain`` "
"class itself, but rather will have to be implemented by the subclass. If the"
" subprocess fails, the ``BaseRestartWorkChain`` calls a set of *process "
"handlers* in the ``inspect_process`` step. Each process handler gets passed "
"the node of the subprocess that was just run, such that it can inspect the "
"results and potentially fix any problems that it finds. To \"register\" a "
"process handler for a base restart work chain implementation, you simply "
"define a method that takes a node as its single argument and decorate it "
"with the :func:`~aiida.engine.processes.workchains.utils.process_handler` "
"decorator:"
msgstr ""

#: ../../source/howto/workchains_restart.rst:352
msgid ""
"The method name can be anything as long as it is a valid Python method name "
"and does not overlap with one of the base work chain's methods. For better "
"readability, it is, however, recommended to have the method name start with "
"``handle_``. In this example, we want to specifically check for a particular"
" failure mode of the ``ArithmeticAddCalculation``, so we compare the "
":meth:`~aiida.orm.nodes.process.process.ProcessNode.exit_status` of the node"
" with that of the spec of the process. If the exit code matches, we know "
"that the problem was due to the sum being negative. Fixing this fictitious "
"problem for this example is as simple as making sure that the inputs are all"
" positive, which we can do by taking the absolute value of them. We assign "
"the new values to the ``self.ctx.inputs`` just as where we defined the "
"original inputs in the ``setup`` step. Finally, to indicate that we have "
"handled the problem, we return an instance of "
":class:`~aiida.engine.processes.workchains.utils.ProcessHandlerReport`. This"
" will instruct the work chain to restart the subprocess, taking the updated "
"inputs from the context. With this simple addition, we can now launch the "
"work chain again:"
msgstr ""

#: ../../source/howto/workchains_restart.rst:369
msgid ""
"This time around, although the first subprocess fails again with a ``410``, "
"the new process handler is called. It \"fixes\" the inputs, and when the "
"work chain restarts the subprocess with the new inputs it finishes "
"successfully. With this simple process you can add as many process handlers "
"as you would like to deal with any potential problem that might occur for "
"the specific subprocess type of the work chain implementation. To make the "
"code even more readable, the "
":func:`~aiida.engine.processes.workchains.utils.process_handler` decorator "
"comes with various syntactic sugar. Instead of having a conditional at the "
"start of each handler to compare the exit status of the node to a particular"
" exit code of the subprocess, you can define it through the ``exit_codes`` "
"keyword argument of the decorator:"
msgstr ""

#: ../../source/howto/workchains_restart.rst:384
msgid ""
"If the ``exit_codes`` keyword is defined, which can be either a single "
"instance of :class:`~aiida.engine.processes.exit_code.ExitCode` or a list "
"thereof, the process handler will only be called if the exit status of the "
"node corresponds to one of those exit codes, otherwise it will simply be "
"skipped."
msgstr ""

#: ../../source/howto/workchains_restart.rst:387
msgid "Multiple process handlers"
msgstr ""

#: ../../source/howto/workchains_restart.rst:389
msgid ""
"Since typically a base restart work chain implementation will have more than"
" one process handler, one might want to control the order in which they are "
"called. This can be done through the ``priority`` keyword:"
msgstr ""

#: ../../source/howto/workchains_restart.rst:401
msgid ""
"The process handlers with a higher priority will be called first. In this "
"scenario, in addition to controlling the order with which the handlers are "
"called, you may also want to stop the process handling once you have "
"determined the problem. This can be achieved by setting the ``do_break`` "
"argument of the ``ProcessHandler`` to ``True``:"
msgstr ""

#: ../../source/howto/workchains_restart.rst:414
msgid ""
"Finally, sometimes one detects a problem that simply cannot or should not be"
" corrected by the work chain. In this case, the handler can signal that the "
"work chain should abort by setting an "
":class:`~aiida.engine.processes.exit_code.ExitCode` instance on the "
"``exit_code`` argument of the ``ProcessHandler``:"
msgstr ""

#: ../../source/howto/workchains_restart.rst:426
msgid ""
"The base restart work chain will detect this exit code and abort the work "
"chain, setting the corresponding status and message on the node as usual:"
msgstr ""

#: ../../source/howto/workchains_restart.rst:434
msgid ""
"With these basic tools, a broad range of use-cases can be addressed while "
"preventing a lot of boilerplate code."
msgstr ""

#: ../../source/howto/workchains_restart.rst:438
msgid "Handler overrides"
msgstr ""

#: ../../source/howto/workchains_restart.rst:440
msgid ""
"It is possible to change the priority of handlers and enable/disable them "
"without changing the source code of the work chain. These properties of the "
"handlers can be controlled through the ``handler_overrides`` input of the "
"work chain. This input takes a ``Dict`` node, that has the following form:"
msgstr ""

#: ../../source/howto/workchains_restart.rst:453
msgid ""
"As you can see, the keys are the name of the handler to affect and the value"
" is a dictionary that can take two keys: ``enabled`` and ``priority``. To "
"enable or disable a handler, set ``enabled`` to ``True`` or ``False``, "
"respectively. The ``priority`` key takes an integer and determines the "
"priority of the handler. Note that the values of the ``handler_overrides`` "
"are fully optional and will override the values configured by the process "
"handler decorator in the source code of the work chain. The changes also "
"only affect the work chain instance that receives the ``handler_overrides`` "
"input, all other instances of the work chain that will be launched will be "
"unaffected."
msgstr ""

#: ../../source/howto/write_workflows.rst:5
msgid "How to write and extend workflows"
msgstr ""

#: ../../source/howto/write_workflows.rst:8
msgid "Writing workflows"
msgstr ""

#: ../../source/howto/write_workflows.rst:10
msgid ""
"A workflow in AiiDA is a :ref:`process <topics:processes:concepts>` that "
"calls other workflows and calculations and optionally *returns* data and as "
"such can encode the logic of a typical scientific workflow. Currently, there"
" are two ways of implementing a workflow process:"
msgstr ""

#: ../../source/howto/write_workflows.rst:13
msgid ":ref:`work functions<topics:workflows:concepts:workfunctions>`"
msgstr ""

#: ../../source/howto/write_workflows.rst:14
msgid ":ref:`work chains<topics:workflows:concepts:workchains>`"
msgstr ""

#: ../../source/howto/write_workflows.rst:16
msgid ""
"Here we present a brief introduction on how to write both workflow types."
msgstr ""

#: ../../source/howto/write_workflows.rst:20
msgid ""
"For more details on the concept of a workflow, and the difference between a "
"work function and a work chain, please see the corresponding :ref:`topics "
"section<topics:workflows:concepts>`."
msgstr ""

#: ../../source/howto/write_workflows.rst:24
msgid ""
"Developing workflows may involve running several lengthy calculations. "
"Consider :ref:`enabling caching <how-to:run-codes:caching>` to help avoid "
"repeating long workflow steps."
msgstr ""

#: ../../source/howto/write_workflows.rst:27
msgid "Work function"
msgstr ""

#: ../../source/howto/write_workflows.rst:29
msgid ""
"A *work function* is a process function that calls one or more calculation "
"functions and *returns* data that has been *created* by the calculation "
"functions it has called. Moreover, work functions can also call other work "
"functions, allowing you to write nested workflows. Writing a work function, "
"whose provenance is automatically stored, is as simple as writing a Python "
"function and decorating it with the "
":class:`~aiida.engine.processes.functions.workfunction` decorator:"
msgstr ""

#: ../../source/howto/write_workflows.rst:37
msgid ""
"It is important to reiterate here that the "
":class:`~aiida.engine.processes.functions.workfunction`-decorated "
"``add_multiply()`` function does not *create* any new data nodes. The "
"``add()`` and ``multiply()`` calculation functions create the ``Int`` data "
"nodes, all the work function does is *return* the results of the "
"``multiply()`` calculation function. Moreover, both calculation and workflow"
" functions can only accept and return data nodes, i.e. instances of classes "
"that subclass the :class:`~aiida.orm.nodes.data.data.Data` class."
msgstr ""

#: ../../source/howto/write_workflows.rst:42
msgid "Work chain"
msgstr ""

#: ../../source/howto/write_workflows.rst:44
msgid ""
"When the workflow you want to run is more complex and takes longer to "
"finish, it is better to write a *work chain*. Writing a work chain in AiiDA "
"requires creating a class that inherits from the "
":class:`~aiida.engine.processes.workchains.workchain.WorkChain` class. Below"
" is an example of a work chain that takes three integers as inputs, "
"multiplies the first two and then adds the third to obtain the final result:"
msgstr ""

#: ../../source/howto/write_workflows.rst:52
msgid ""
"You can give the work chain any valid Python class name, but the convention "
"is to have it end in "
":class:`~aiida.engine.processes.workchains.workchain.WorkChain` so that it "
"is always immediately clear what it references. Let's go over the methods of"
" the ``MultiplyAddWorkChain`` one by one:"
msgstr ""

#: ../../source/howto/write_workflows.rst:60
msgid ""
"The most important method to implement for every work chain is the "
"``define()`` method. This class method must always start by calling the "
"``define()`` method of its parent class. Next, the ``define()`` method "
"should be used to define the specifications of the work chain, which are "
"contained in the work chain ``spec``:"
msgstr ""

#: ../../source/howto/write_workflows.rst:64
msgid ""
"the **inputs**, specified using the ``spec.input()`` method. The first "
"argument of the ``input()`` method is a string that specifies the label of "
"the input, e.g. ``'x'``. The ``valid_type`` keyword argument allows you to "
"specify the required node type of the input. Other keyword arguments allow "
"the developer to set a default for the input, or indicate that an input "
"should not be stored in the database, see :ref:`the process topics section "
"<topics:processes:usage:spec>` for more details."
msgstr ""

#: ../../source/howto/write_workflows.rst:68
msgid ""
"the **outline** or logic of the workflow, specified using the "
"``spec.outline()`` method. The outline of the workflow is constructed from "
"the methods of the "
":class:`~aiida.engine.processes.workchains.workchain.WorkChain` class. For "
"the ``MultiplyAddWorkChain``, the outline is a simple linear sequence of "
"steps, but it's possible to include actual logic, directly in the outline, "
"in order to define more complex workflows as well. See the :ref:`work chain "
"outline section <topics:workflows:usage:workchains:define_outline>` for more"
" details."
msgstr ""

#: ../../source/howto/write_workflows.rst:72
msgid ""
"the **outputs**, specified using the ``spec.output()`` method. This method "
"is very similar in its usage to the ``input()`` method."
msgstr ""

#: ../../source/howto/write_workflows.rst:74
msgid ""
"the **exit codes** of the work chain, specified using the "
"``spec.exit_code()`` method. Exit codes are used to clearly communicate "
"known failure modes of the work chain to the user. The first and second "
"arguments define the ``exit_status`` of the work chain in case of failure "
"(``400``) and the string that the developer can use to reference the exit "
"code (``ERROR_NEGATIVE_NUMBER``). A descriptive exit message can be provided"
" using the ``message`` keyword argument. For the ``MultiplyAddWorkChain``, "
"we demand that the final result is not a negative number, which is checked "
"in the ``validate_result`` step of the outline."
msgstr ""

#: ../../source/howto/write_workflows.rst:82
msgid ""
"For more information on the ``define()`` method and the process spec, see "
"the :ref:`corresponding section in the topics "
"<topics:processes:usage:defining>`."
msgstr ""

#: ../../source/howto/write_workflows.rst:84
msgid ""
"The ``multiply`` method is the first step in the outline of the "
"``MultiplyAddWorkChain`` work chain."
msgstr ""

#: ../../source/howto/write_workflows.rst:92
msgid ""
"This step simply involves running the calculation function ``multiply()``, "
"on the ``x`` and ``y`` **inputs** of the work chain. To store the result of "
"this function and use it in the next step of the outline, it is added to the"
" *context* of the work chain using ``self.ctx``."
msgstr ""

#: ../../source/howto/write_workflows.rst:101
msgid ""
"The ``add()`` method is the second step in the outline of the work chain. As"
" this step uses the ``ArithmeticAddCalculation`` calculation job, we start "
"by setting up the inputs for this "
":class:`~aiida.engine.processes.calcjobs.calcjob.CalcJob` in a dictionary. "
"Next, when submitting this calculation job to the daemon, it is important to"
" use the submit method from the work chain instance via ``self.submit()``. "
"Since the result of the addition is only available once the calculation job "
"is finished, the ``submit()`` method returns the "
":class:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode` of the "
"*future* ``ArithmeticAddCalculation`` process. To tell the work chain to "
"wait for this process to finish before continuing the workflow, we return "
"the ``ToContext`` class, where we have passed a dictionary to specify that "
"the future calculation job node should be assigned to the ``'addition'`` "
"context key."
msgstr ""

#: ../../source/howto/write_workflows.rst:109
msgid ""
"Never use the global ``submit()`` function to submit calculations to the "
"daemon within a "
":class:`~aiida.engine.processes.workchains.workchain.WorkChain`. Doing so "
"will raise an exception during runtime. See the :ref:`topics section on work"
" chains<topics:workflows:usage:workchains:submitting_sub_processes>` for "
"more details."
msgstr ""

#: ../../source/howto/write_workflows.rst:114
msgid ""
"Instead of passing a dictionary, you can also initialize a ``ToContext`` "
"instance by passing the future process as a keyword argument, e.g. "
"``ToContext(addition=calcjob_node)``. More information on the ``ToContext`` "
"class can be found in :ref:`the topics section on submitting sub "
"processes<topics:workflows:usage:workchains:submitting_sub_processes>`."
msgstr ""

#: ../../source/howto/write_workflows.rst:123
msgid ""
"Once the ``ArithmeticAddCalculation`` calculation job is finished, the next "
"step in the work chain is to validate the result, i.e. verify that the "
"result is not a negative number. After the ``addition`` node has been "
"extracted from the context, we take the ``sum`` node from the "
"``ArithmeticAddCalculation`` outputs and store it in the ``result`` "
"variable. In case the value of this ``Int`` node is negative, the "
"``ERROR_NEGATIVE_NUMBER`` exit code - defined in the ``define()`` method - "
"is returned. Note that once an exit code is returned during any step in the "
"outline, the work chain will be terminated and no further steps will be "
"executed."
msgstr ""

#: ../../source/howto/write_workflows.rst:134
msgid ""
"The final step in the outline is to pass the result to the outputs of the "
"work chain using the ``self.out()`` method. The first argument "
"(``'result'``) specifies the label of the output, which corresponds to the "
"label provided to the spec in the ``define()`` method. The second argument "
"is the result of the work chain, extracted from the ``Int`` node stored in "
"the context under the ``'addition'`` key."
msgstr ""

#: ../../source/howto/write_workflows.rst:138
msgid ""
"For a more complete discussion on workflows and their usage, please read "
":ref:`the corresponding topics section<topics:workflows:usage>`."
msgstr ""

#: ../../source/howto/write_workflows.rst:143
msgid "Extending workflows"
msgstr ""

#: ../../source/howto/write_workflows.rst:145
msgid ""
"When designing workflows, there are many cases where you want to reuse an "
"existing process. This section explains how to extend workflows by wrapping "
"them around other processes or linking them together."
msgstr ""

#: ../../source/howto/write_workflows.rst:148
msgid ""
"As an example, let's say you want to extend the ``MultiplyAddWorkChain`` by "
"adding another step of analysis that checks whether the result is an even "
"number or not. This final step can be written as a simple ``calcfunction``:"
msgstr ""

#: ../../source/howto/write_workflows.rst:155
msgid ""
"We could simply write a new workflow based off ``MultiplyAddWorkChain`` that"
" includes an extra step in the outline which runs the ``is_even`` "
"calculation function. However, this would lead to a lot of code duplication,"
" and longer workflows consisting of multiple work chains would become very "
"cumbersome to deal with (see the dropdown panel below)."
msgstr ""

#: ../../source/howto/write_workflows.rst:0
msgid "``BadMultiplyAddIsEvenWorkChain``"
msgstr ""

#: ../../source/howto/write_workflows.rst:166
msgid ""
"We've removed the ``result`` step from the outline, as well as the "
"``result`` output. For this work chain, we're assuming that for now we are "
"only interested in whether or not the result is even."
msgstr ""

#: ../../source/howto/write_workflows.rst:169
msgid ""
"We can avoid some code duplication by simply submitting the "
"``MultiplyAddWorkChain`` within one of the steps of a new work chain which "
"would then call ``is_even`` in a second step:"
msgstr ""

#: ../../source/howto/write_workflows.rst:175
msgid ""
"This already simplifies the extended work chain, and avoids duplicating the "
"steps of the ``MultiplyAddWorkChain`` in the outline. However, we still had "
"to copy all of the input definitions of the ``MultiplyAddWorkChain``, and "
"manually extract them from the inputs before passing them to the "
"``self.submit`` method. Fortunately, there is a better way of *exposing* the"
" inputs and outputs of subprocesses of the work chain."
msgstr ""

#: ../../source/howto/write_workflows.rst:182
msgid ""
"In many cases it is convenient for work chains to expose the inputs of the "
"subprocesses it wraps so users can specify these inputs directly, as well as"
" exposing some of the outputs produced as one of the results of the parent "
"work chain. For the simple example presented in the previous section, simply"
" copy-pasting the input and output port definitions of the subprocess "
"``MultiplyAddWorkChain`` was not too troublesome. However, this quickly "
"becomes tedious and error-prone once you start to wrap processes with quite "
"a few more inputs."
msgstr ""

#: ../../source/howto/write_workflows.rst:186
msgid ""
"To prevent the copy-pasting of input and output specifications, the "
":class:`~aiida.engine.processes.process_spec.ProcessSpec` class provides the"
" :meth:`~plumpy.ProcessSpec.expose_inputs` and "
":meth:`~plumpy.ProcessSpec.expose_outputs` methods. Calling "
":meth:`~plumpy.ProcessSpec.expose_inputs` for a particular ``Process`` "
"class, will automatically copy the inputs of the class into the inputs "
"namespace of the process specification:"
msgstr ""

#: ../../source/howto/write_workflows.rst:204
msgid ""
"The exposing functionality is not just limited to ``WorkChain`` "
"implementations but works for all process classes, such as ``CalcJob`` "
"plugins for example. It even works for process functions (i.e., "
"``calcfunctions`` and ``workfunctions``) since under the hood an actual "
"``Process`` class is generated for them on-the-fly. For process functions, "
"the ``valid_type`` and ``help`` attributes of the exposed inputs are even "
"preserved if they could be inferred from provided function type hints and "
"docstrings (see :ref:`type validation<topics:processes:functions:type-"
"validation>` and :ref:`docstring "
"parsing<topics:processes:functions:docstring-parsing>` for details)."
msgstr ""

#: ../../source/howto/write_workflows.rst:208
msgid ""
"Be aware that any inputs that already exist in the namespace will be "
"overridden. To prevent this, the method accepts the ``namespace`` argument, "
"which will cause the inputs to be copied into that namespace instead of the "
"top-level namespace. This is especially useful for exposing inputs since "
"*all* processes have the ``metadata`` input. If you expose the inputs "
"without a namespace, the ``metadata`` input port of the exposed class will "
"override the one of the host, which is often not desirable. Let's copy the "
"inputs of the ``MultiplyAddWorkChain`` into the ``multiply_add`` namespace:"
msgstr ""

#: ../../source/howto/write_workflows.rst:219
msgid ""
"That takes care of exposing the port specification of the wrapped process "
"class in a very efficient way. To easily retrieve the inputs that have been "
"passed to the process, one can use the "
":meth:`~aiida.engine.processes.process.Process.exposed_inputs` method. Note "
"the past tense of the method name. The method takes a process class and an "
"optional namespace as arguments, and will return the inputs that have been "
"passed into that namespace when it was launched. This utility now allows us "
"to simplify the ``multiply_add`` step in the outline:"
msgstr ""

#: ../../source/howto/write_workflows.rst:230
msgid ""
"This way we don't have to manually fish out all the individual inputs from "
"the ``self.inputs`` but have to just call this single method, saving time "
"and lines of code. The final ``MultiplyAddIsEvenWorkChain`` can be found in "
"the dropdown panel below."
msgstr ""

#: ../../source/howto/write_workflows.rst:0
msgid "``MultiplyAddIsEvenWorkChain``"
msgstr ""

#: ../../source/howto/write_workflows.rst:239
msgid ""
"When submitting or running the work chain using namespaced inputs "
"(``multiply_add`` in the example above), it is important to use the "
"namespace when providing the inputs:"
msgstr ""

#: ../../source/howto/write_workflows.rst:250
msgid ""
"After running the ``MultiplyAddIsEvenWorkChain``, you can see a hierarchical"
" overview of the processes called by the work chain using the ``verdi "
"process status`` command:"
msgstr ""

#: ../../source/howto/write_workflows.rst:261
msgid ""
"Note that this command also recursively shows the processes called by the "
"subprocesses of the ``MultiplyAddIsEvenWorkChain`` work chain."
msgstr ""

#: ../../source/howto/write_workflows.rst:263
msgid ""
"As mentioned earlier, you can also expose the outputs of the "
"``MultiplyAddWorkChain`` using the "
":meth:`~plumpy.ProcessSpec.expose_outputs` method. Say we want to add the "
"``result`` of the ``MultiplyAddWorkChain`` as one of the outputs of the "
"extended work chain:"
msgstr ""

#: ../../source/howto/write_workflows.rst:280
msgid ""
"Since there is not one output port that is shared by all process classes, it"
" is less critical to use the ``namespace`` argument when exposing outputs. "
"However, take care not to override the outputs of the parent work chain in "
"case they do have outputs with the same port name. We still need to pass the"
" ``result`` of the ``MultiplyAddWorkChain`` to the outputs of the parent "
"work chain. For example, we could do this in the ``is_even`` step by using "
"the :meth:`~aiida.engine.processes.process.Process.out` method:"
msgstr ""

#: ../../source/howto/write_workflows.rst:295
msgid ""
"This works fine if we want to pass a single output to the parent work chain,"
" but once again becomes tedious and error-prone when passing multiple "
"outputs. Instead we can use the "
":meth:`~aiida.engine.processes.process.Process.exposed_outputs` method in "
"combination with the "
":meth:`~aiida.engine.processes.process.Process.out_many` method:"
msgstr ""

#: ../../source/howto/write_workflows.rst:307
msgid ""
"The :meth:`~aiida.engine.processes.process.Process.exposed_outputs` method "
"returns a dictionary of the exposed outputs of the ``MultiplyAddWorkChain``,"
" extracted from the workchain node stored in the ``multi_addition`` key of "
"the context. The :meth:`~aiida.engine.processes.process.Process.out_many` "
"method takes this dictionary and assigns its values to the output ports with"
" names equal to the corresponding keys."
msgstr ""

#: ../../source/howto/write_workflows.rst:312
msgid ""
"Besides avoiding code duplication and errors, using the methods for exposing"
" inputs and outputs also has the advantage that our parent work chain "
"doesn't have to be adjusted in case the inputs or outputs of the child work "
"chain change. This makes the code much easier to maintain."
msgstr ""
