# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2020, ECOLE POLYTECHNIQUE FEDERALE DE LAUSANNE (Theory and Simulation of Materials (THEOS) and National Centre for Computational Design and Discovery of Novel Materials (NCCR MARVEL)), Switzerland and ROBERT BOSCH LLC, USA. All rights reserved
# This file is distributed under the same license as the AiiDA package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: AiiDA 2.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-12-23 19:17+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../CHANGELOG.md:2
msgid "Changelog"
msgstr ""

#: ../../../CHANGELOG.md:4
msgid "v2.5.0 - 2023-12-20"
msgstr ""

#: ../../../CHANGELOG.md:6
msgid "This minor release comes with a number of features that are focused on user friendliness of the CLI and the API. It also reduces the import time of modules, which makes the CLI faster to load and so tab-completion should be snappier. The release adds support for Python 3.12 and a great number of bugs are fixed."
msgstr ""

#: ../../../CHANGELOG.md:10
msgid "[Create profiles without a database server](#create-profiles-without-a-database-server)"
msgstr ""

#: ../../../CHANGELOG.md:11
msgid "[Changes in process launch functions](#changes-in-process-launch-functions)"
msgstr ""

#: ../../../CHANGELOG.md:12
msgid "[Improvements for built-in data types](#improvements-for-built-in-data-types)"
msgstr ""

#: ../../../CHANGELOG.md:13
msgid "[Repository interface improvements](#repository-interface-improvements)"
msgstr ""

#: ../../../CHANGELOG.md:14
#: ../../../CHANGELOG.md:442
#: ../../../CHANGELOG.md:874
msgid "[Full list of changes](#full-list-of-changes)"
msgstr ""

#: ../../../CHANGELOG.md:15
#: ../../../CHANGELOG.md:443
msgid "[Features](#features)"
msgstr ""

#: ../../../CHANGELOG.md:16
msgid "[Performance](#performance)"
msgstr ""

#: ../../../CHANGELOG.md:17
#: ../../../CHANGELOG.md:446
msgid "[Changes](#changes)"
msgstr ""

#: ../../../CHANGELOG.md:18
#: ../../../CHANGELOG.md:444
msgid "[Fixes](#fixes)"
msgstr ""

#: ../../../CHANGELOG.md:19
#: ../../../CHANGELOG.md:445
msgid "[Deprecations](#deprecations)"
msgstr ""

#: ../../../CHANGELOG.md:20
#: ../../../CHANGELOG.md:447
msgid "[Documentation](#documentation)"
msgstr ""

#: ../../../CHANGELOG.md:21
#: ../../../CHANGELOG.md:449
msgid "[Dependencies](#dependencies)"
msgstr ""

#: ../../../CHANGELOG.md:22
msgid "[Devops](#devops)"
msgstr ""

#: ../../../CHANGELOG.md:25
msgid "Create profiles without a database server"
msgstr ""

#: ../../../CHANGELOG.md:27
msgid "A new storage backend plugin has been added that uses [`SQLite`](https://www.sqlite.org/index.html) instead of PostgreSQL. This makes it a lot easier to setup across all platforms. A new profile using this storage backend can be created in a single command:"
msgstr ""

#: ../../../CHANGELOG.md:33
msgid "Although easier to setup compared to the default storage backend that uses PostgreSQL, it is less performant. This makes this storage ideally suited for use-cases that want to test or demonstrate AiiDA, or to just play around a bit. The storage is compatible with most of AiiDA's functionality, except for automated database migrations and some very specific `QueryBuilder` functionality. Therefore, for production databases, the default `core.psql_dos` storage entry point remains the recommended storage."
msgstr ""

#: ../../../CHANGELOG.md:38
msgid "It is now also possible to create a profile using an export archive:"
msgstr ""

#: ../../../CHANGELOG.md:42
msgid "where `<ARCHIVE>` should point to an export archive on disk. You can now use this profile like any other profile to inspect the data of the export archive. Note that this profile is read-only, so you will not be able to use it to mutate existing data or add new data to the profile. See the [documentation for more details and a more in-depth example](https://aiida.readthedocs.io/projects/aiida-core/en/v2.5.0/howto/archive_profile.html)."
msgstr ""

#: ../../../CHANGELOG.md:47
msgid "Finally, the original storage plugin `core.psql_dos`, which uses PostgreSQL for the database is also accessible through `verdi profile setup core.psql_dos`. Essentially this is the same as the `verdi setup` command, which is kept for now for backwards compatibility."
msgstr ""

#: ../../../CHANGELOG.md:50
msgid "See the [documentation on storage plugins](https://aiida.readthedocs.io/projects/aiida-core/en/v2.5.0/topics/storage.html) for more details on the differences between these storage plugins and when to use which."
msgstr ""

#: ../../../CHANGELOG.md:52
msgid "The `verdi profile delete` command can now also be used to delete a profile for any of these storage plugins. You will be prompted whether you also want to delete all the data, or you can specify this with the `--delete-data` or `--keep-data` flags."
msgstr ""

#: ../../../CHANGELOG.md:55
msgid "Changes in process launch functions"
msgstr ""

#: ../../../CHANGELOG.md:57
msgid "The `aiida.engine.submit` method now accepts the argument `wait`. When set to `True`, instead of returning the process node straight away, the function will wait for the process to terminate before returning. By default it is set to `False` so the current behavior remains unchanged."
msgstr ""

#: ../../../CHANGELOG.md:66
msgid "This new feature is mostly useful for interactive demos and tutorials in notebooks. In these situations, it might be beneficial to use `aiida.engine.run` because the cell will be blocking until it is finished, indicating to the user that something is processing. When using `submit`, the cell returns immediately, but the results are not ready yet and typically the next cell cannot yet be executed. Instead, the demo should redirect the user to using something like `verdi process list` to query the status of the process."
msgstr ""

#: ../../../CHANGELOG.md:71
msgid "However, using `run` has downsides as well, most notably that the process will be lost if the notebook gets disconnected. For processes that are expected to run longer, this can be really problematic, and so `submit` will have to be used regardless. With the new `wait` argument, `submit` provides the best of both worlds."
msgstr ""

#: ../../../CHANGELOG.md:75
msgid "Although very useful, the introduction of this feature does break any processes that define `wait` or `wait_interval` as an input. Since the inputs to a process are defined as keyword arguments, these inputs would overlap with the arguments to the `submit` method. To solve this problem, inputs can now _also_ be passed as a dictionary, e.g., where one would do before:"
msgstr ""

#: ../../../CHANGELOG.md:88
msgid "The new syntax allows the following:"
msgstr ""

#: ../../../CHANGELOG.md:97
msgid "Passing inputs as keyword arguments is still supported because sometimes that notation is still more legible than defining an intermediate dictionary. However, if both an input dictionary and keyword arguments are define, an exception is raised."
msgstr ""

#: ../../../CHANGELOG.md:100
msgid "Improvements for built-in data types"
msgstr ""

#: ../../../CHANGELOG.md:102
msgid "The `XyData` and `ArrayData` data plugins now allow to directly pass the content in the constructor. This allows defining the complete node in a single line"
msgstr ""

#: ../../../CHANGELOG.md:114
msgid "It is now also no longer required to specify the name in `ArrayData.get_array` as long as the node contains just a single array:"
msgstr ""

#: ../../../CHANGELOG.md:123
msgid "Repository interface improvements"
msgstr ""

#: ../../../CHANGELOG.md:125
msgid "As of `v2.0.0`, the repository interface of the `Node` class was moved to the `Node.base.repository` namespace. This was done to clean up the top-level namespace of the `Node` class which was getting very crowded, and in most use-cases, a user never needs to directly access these methods. It is up to the data plugin to provide specific methods to retrieve data that might be stored in the repository. For example, with the `ArrayData`, a user should now have to go to `ArrayData.base.repository.get_object_content` to retrieve an array from the repository, but the class provides `ArrayData.get_array` as a shortcut."
msgstr ""

#: ../../../CHANGELOG.md:130
msgid "A few data plugins that ship with `aiida-core` didn't respect this guideline, most notably the `FolderData` and `SinglefileData` plugins. This has been corrected in this release: for `FolderData`, all the repository methods are now once again directly available on the top-level namespace. The `SinglefileData` now makes it easier to get the content as bytes. Before, one had to do:"
msgstr ""

#: ../../../CHANGELOG.md:140
msgid "this can now be achieved with:"
msgstr ""

#: ../../../CHANGELOG.md:147
msgid "As of v2.0, due to the repository redesign, it was no longer possible to access a file directly by a filepath on disk. The repository interface only interacts with file-like objects to stream the content. However, a lot of Python libraries expect filepaths on disk and do not support file-like objects. This would force an AiiDA user to write the file from the repository to a temporary file on disk, and pass that temporary filepath. For example, consider the `numpy.loadtxt` function which requires a filepath, the code would look something like:"
msgstr ""

#: ../../../CHANGELOG.md:173
msgid "This burdensome boilerplate has now been made obsolete by the `as_path` method:"
msgstr ""

#: ../../../CHANGELOG.md:178
msgid "For the `FolderData` and `SinglefileData` plugins, the method can be accessed on the top-level namespace of course."
msgstr ""

#: ../../../CHANGELOG.md:180
#: ../../../CHANGELOG.md:611
#: ../../../CHANGELOG.md:770
#: ../../../CHANGELOG.md:1066
msgid "Full list of changes"
msgstr ""

#: ../../../CHANGELOG.md:182
#: ../../../CHANGELOG.md:367
#: ../../../CHANGELOG.md:613
#: ../../../CHANGELOG.md:772
#: ../../../CHANGELOG.md:1068
#: ../../../CHANGELOG.md:1943
#: ../../../CHANGELOG.md:2100
#: ../../../CHANGELOG.md:2191
#: ../../../CHANGELOG.md:2250
#: ../../../CHANGELOG.md:2294
#: ../../../CHANGELOG.md:2310
#: ../../../CHANGELOG.md:2383
msgid "Features"
msgstr ""

#: ../../../CHANGELOG.md:183
msgid "Add the `SqliteDosStorage` storage backend [[702f88788]](https://github.com/aiidateam/aiida-core/commit/702f8878829b8e2a65d81623cc2238eb40791bc6)"
msgstr ""

#: ../../../CHANGELOG.md:184
msgid "`XyData`: Allow defining array(s) on construction [[f11598dc6]](https://github.com/aiidateam/aiida-core/commit/f11598dc68a80bbfa026db064158aae64ac0e802)"
msgstr ""

#: ../../../CHANGELOG.md:185
msgid "`ArrayData`: Make `name` optional in `get_array` [[7fbe67cb6]](https://github.com/aiidateam/aiida-core/commit/7fbe67cb6273cf2bae4256cdbda284aeb89a9372)"
msgstr ""

#: ../../../CHANGELOG.md:186
msgid "`ArrayData`: Allow defining array(s) on construction [[35e669fe8]](https://github.com/aiidateam/aiida-core/commit/35e669fe86ca467e656f4e500f11d533f7492107)"
msgstr ""

#: ../../../CHANGELOG.md:187
msgid "`FolderData`: Expose repository API on top-level namespace [[3e1f87373]](https://github.com/aiidateam/aiida-core/commit/3e1f87373e3cf2c40e8a3134ac848d4c16b9dbcf)"
msgstr ""

#: ../../../CHANGELOG.md:188
msgid "Repository: Add the `as_path` context manager [[b0546e8ed]](https://github.com/aiidateam/aiida-core/commit/b0546e8ed12b0982617293ab4a03ba3ec2d8ea44)"
msgstr ""

#: ../../../CHANGELOG.md:189
msgid "Caching: Add the `strict` argument configuration validation [[f272e197e]](https://github.com/aiidateam/aiida-core/commit/f272e197e2992f445b2b51608a6ffe17a2a8f4c1)"
msgstr ""

#: ../../../CHANGELOG.md:190
msgid "Caching: Try to import an identifier if it is a class path [[2c56fc234]](https://github.com/aiidateam/aiida-core/commit/2c56fc234139e624eb1da5ee016c1761b7b1a70a)"
msgstr ""

#: ../../../CHANGELOG.md:191
msgid "CLI: Add the command `verdi profile setup` [[351021164]](https://github.com/aiidateam/aiida-core/commit/351021164d00aa3a2a78b5b6e43e8a87a8553151)"
msgstr ""

#: ../../../CHANGELOG.md:192
msgid "CLI: Add `cached` and `cached_from` projections to `verdi process list` [[3b445c4f1]](https://github.com/aiidateam/aiida-core/commit/3b445c4f1c793ecc9b5c2efce863620748610d61)"
msgstr ""

#: ../../../CHANGELOG.md:193
msgid "CLI: Add `--all` flag to `verdi process kill` [[db1375949]](https://github.com/aiidateam/aiida-core/commit/db1375949b9ec133ee3b06bc3bfe2f8185eceeb6)"
msgstr ""

#: ../../../CHANGELOG.md:194
msgid "CLI: Lazily validate entry points in parameter types [[d3807d422]](https://github.com/aiidateam/aiida-core/commit/d3807d42229ffbad4e74752b6842a60f66bbafed)"
msgstr ""

#: ../../../CHANGELOG.md:195
msgid "CLI: Add repair hint to `verdi process play/pause/kill` [[8bc31bfd1]](https://github.com/aiidateam/aiida-core/commit/8bc31bfd1dae84a2240470a8163b3407eb27ae03)"
msgstr ""

#: ../../../CHANGELOG.md:196
msgid "CLI: Add the `verdi process repair` command [[3e3d9b9f7]](https://github.com/aiidateam/aiida-core/commit/3e3d9b9f70bb1ae2f7ae86db06469b73c5ebdfae)"
msgstr ""

#: ../../../CHANGELOG.md:197
msgid "CLI: Validate strict in `verdi config set caching.disabled_for` [[9cff59232]](https://github.com//commit/9cff5923263cd349da731b02d309120e754c0b95)"
msgstr ""

#: ../../../CHANGELOG.md:198
msgid "`DynamicEntryPointCommandGroup`: Allow entry points to be excluded [[9e30ec8ba]](https://github.com//commit/9e30ec8baeee74ae6d1c08459cb6eacd46d12e8a)"
msgstr ""

#: ../../../CHANGELOG.md:199
msgid "Add the `aiida.common.log.capture_logging` utility [[9006eef3a]](https://github.com/aiidateam/aiida-core/commit/9006eef3ac1bb7b47c8ced63766e2f5346d46e91)"
msgstr ""

#: ../../../CHANGELOG.md:200
msgid "`Config`: Add the `create_profile` method [[ae7abe8a6]](https://github.com/aiidateam/aiida-core/commit/ae7abe8a6bddcf8d59b6ac213a73deeb65d4c056)"
msgstr ""

#: ../../../CHANGELOG.md:201
msgid "Engine: Add the `await_processes` utility function [[45767f050]](https://github.com/aiidateam/aiida-core/commit/45767f0509513fecd287e334fb26299db2adf14b)"
msgstr ""

#: ../../../CHANGELOG.md:202
msgid "Engine: Add the `wait` argument to `submit` [[8f5e929d1]](https://github.com/aiidateam/aiida-core/commit/8f5e929d1660b663894bac52f385874011e47872)"
msgstr ""

#: ../../../CHANGELOG.md:203
msgid "ORM: Add the `User.is_default` property [[a43c4cd0f]](https://github.com/aiidateam/aiida-core/commit/a43c4cd0fcee252202f9a5a3016aef156a36ac29)"
msgstr ""

#: ../../../CHANGELOG.md:204
msgid "ORM: Add `NodeCaching.CACHED_FROM_KEY` for `_aiida_cached_from` constant [[35fc3ae57]](https://github.com/aiidateam/aiida-core/commit/35fc3ae5790023022d4d78cf2fe7274a72b590d2)"
msgstr ""

#: ../../../CHANGELOG.md:205
msgid "ORM: Add the `Entity.get_collection` classmethod [[305f1dbf4]](https://github.com/aiidateam/aiida-core/commit/305f1dbf4ccb3e0e2e79865aee8d248e5ad55b95)"
msgstr ""

#: ../../../CHANGELOG.md:206
msgid "ORM: Add the `Dict.get` method [[184fcd16e]](https://github.com//commit/184fcd16e9a88fbf9d4e754870416f4a56de55b5)"
msgstr ""

#: ../../../CHANGELOG.md:207
msgid "ORM: Register `numpy.ndarray` with the `to_aiida_type` to `ArrayData` [[d8dd776a6]](https://github.com/aiidateam/aiida-core/commit/d8dd776a68f438702aa07b58d754b35ab0745937)"
msgstr ""

#: ../../../CHANGELOG.md:208
msgid "Manager: Add the `set_default_user_email` [[8f8f55807]](https://github.com/aiidateam/aiida-core/commit/8f8f55807fd02872e7a345b7bd10eb68f65cbcda)"
msgstr ""

#: ../../../CHANGELOG.md:209
msgid "`CalcJob`: Add support for nested targets in `remote_symlink_list` [[0ec650c1a]](https://github.com/aiidateam/aiida-core/commit/0ec650c1ae31ac42f80940103ac81cb0eb53f06d)"
msgstr ""

#: ../../../CHANGELOG.md:210
msgid "`RemoteData`: Add the `is_cleaned` property [[2a2353d3d]](https://github.com/aiidateam/aiida-core/commit/2a2353d3dd2712afda8f1ebbcf749c7cc99f06fd)"
msgstr ""

#: ../../../CHANGELOG.md:211
msgid "`SqliteTempBackend`: Add support for reading from and writing to archives [[83fc5cf69]](https://github.com/aiidateam/aiida-core/commit/83fc5cf69e8fcecba1f4c47ccb6599e6d78ba9dc)"
msgstr ""

#: ../../../CHANGELOG.md:212
msgid "`StorageBackend`: Add the `read_only` class attribute [[8a4303ff5]](https://github.com//commit/8a4303ff53ec0b14fe43fbf1f4e01b69efc689df)"
msgstr ""

#: ../../../CHANGELOG.md:213
msgid "`SinglefileData`: Add `mode` keyword to `get_content` [[d082df7f1]](https://github.com/aiidateam/aiida-core/commit/d082df7f1b53057e15c8cbbc7e662ec808c27722)"
msgstr ""

#: ../../../CHANGELOG.md:214
msgid "`BaseRestartWorkChain`: Factor out attachment of outputs [[d6093d101]](https://github.com/aiidateam/aiida-core/commit/d6093d101ddcdaba74a14b44bdd91eea95628903)"
msgstr ""

#: ../../../CHANGELOG.md:215
msgid "Add support for `NodeLinksManager` to YAML serializer [[6905c134e]](https://github.com//commit/6905c134e737183a1f366d9f86d9f77dd4d74730)"
msgstr ""

#: ../../../CHANGELOG.md:217
#: ../../../CHANGELOG.md:2245
#: ../../../CHANGELOG.md:2392
msgid "Performance"
msgstr ""

#: ../../../CHANGELOG.md:218
msgid "CLI: Make loading of config lazy for improved responsiveness [[d533b7a54]](https://github.com/aiidateam/aiida-core/commit/d533b7a540ab9d420acec1833bb7e23f50d8a7c1)"
msgstr ""

#: ../../../CHANGELOG.md:219
msgid "Cache the lookup of entry points [[12cc930db]](https://github.com/aiidateam/aiida-core/commit/12cc930dbf8f377527d89f6f39bc28a4638f8377)"
msgstr ""

#: ../../../CHANGELOG.md:220
msgid "Refactor: Delay import of heavy packages to speed up import time [[5dda6fd97]](https://github.com/aiidateam/aiida-core/commit/5dda6fd9749a886585cebf9afc288ebc46f00429)"
msgstr ""

#: ../../../CHANGELOG.md:221
msgid "Refactor: Delay import of heavy packages to speed up import time [[8e6e08dc7]](https://github.com/aiidateam/aiida-core/commit/8e6e08dc780152333e4a6b6966469a98e51fe061)"
msgstr ""

#: ../../../CHANGELOG.md:222
msgid "Do not import `aiida.cmdline` in `aiida.orm` [[0879a4e27]](https://github.com/aiidateam/aiida-core/commit/0879a4e27559ac368545afd18a1f061e9c29b8c7)"
msgstr ""

#: ../../../CHANGELOG.md:223
msgid "Lazily define `__type_string` in `orm.Group` [[ebf3101d9]](https://github.com/aiidateam/aiida-core/commit/ebf3101d9b2c6298070853bae6c7b06489a363ca)"
msgstr ""

#: ../../../CHANGELOG.md:224
msgid "Lazily define `_plugin_type_string` and `_query_type_string of `Node` [[3a61a7003]](https://github.com/aiidateam/aiida-core/commit/3a61a70032d6ace3d27f1a701be048f3f2026b43)"
msgstr ""

#: ../../../CHANGELOG.md:226
#: ../../../CHANGELOG.md:663
#: ../../../CHANGELOG.md:794
#: ../../../CHANGELOG.md:1129
#: ../../../CHANGELOG.md:2225
#: ../../../CHANGELOG.md:2353
#: ../../../CHANGELOG.md:2397
msgid "Changes"
msgstr ""

#: ../../../CHANGELOG.md:227
msgid "CLI: `verdi profile delete` is now storage plugin agnostic [[5015f5fe1]](https://github.com//commit/5015f5fe12d93024ed0d7594d860f1f2cd977548)"
msgstr ""

#: ../../../CHANGELOG.md:228
msgid "CLI: Usability improvements for interactive `verdi setup` [[c53ea20a4]](https://github.com/aiidateam/aiida-core/commit/c53ea20a497f66bc88f68d0603cf9a32614fc4c2)"
msgstr ""

#: ../../../CHANGELOG.md:229
msgid "CLI: Do not load config in defaults and callbacks during tab-completion [[062058862]](https://github.com/aiidateam/aiida-core/commit/06205886204c142f771dab37f1a78f3bf0ba7251)"
msgstr ""

#: ../../../CHANGELOG.md:230
msgid "Engine: Make process inputs in launchers positional [[6d18ccb86]](https://github.com//commit/6d18ccb8680f16e8da80deffe40808cc2e669de0)"
msgstr ""

#: ../../../CHANGELOG.md:231
msgid "Remove `aiida.manage.configuration.load_documentation_profile` [[9941266ce]](https://github.com//commit/9941266ced93f31191152034606bf5b1e049cc79)"
msgstr ""

#: ../../../CHANGELOG.md:232
msgid "ORM: `Sealable.seal()` return `self` instead of `None` [[16e3bd3b5]](https://github.com/aiidateam/aiida-core/commit/16e3bd3b5087b95d31983df2147d4c14bb331077)"
msgstr ""

#: ../../../CHANGELOG.md:233
msgid "ORM: Move deprecation warnings from module level [[c4afdb9be]](https://github.com//commit/c4afdb9be5633b68d72121c36916dfc6791d8b29)"
msgstr ""

#: ../../../CHANGELOG.md:234
msgid "Config: Switch from `jsonschema` to `pydantic` [[4203f162d]](https://github.com/aiidateam/aiida-core/commit/4203f162df803946b2396ca820e6b6139a3ecc61)"
msgstr ""

#: ../../../CHANGELOG.md:235
msgid "`DynamicEntryPointCommandGroup`: Use `pydantic` to define config model [[1d8ea2a27]](https://github.com/aiidateam/aiida-core/commit/1d8ea2a27381feeabfe38f5a3647d22ac1b825e4)"
msgstr ""

#: ../../../CHANGELOG.md:236
msgid "Config: Remove use of `NO_DEFAULT` for `Option.default` [[275718cc8]](https://github.com/aiidateam/aiida-core/commit/275718cc8dae866a6fc847fa898a3290672e9d7a)"
msgstr ""

#: ../../../CHANGELOG.md:238
#: ../../../CHANGELOG.md:379
#: ../../../CHANGELOG.md:427
#: ../../../CHANGELOG.md:644
#: ../../../CHANGELOG.md:720
#: ../../../CHANGELOG.md:726
#: ../../../CHANGELOG.md:784
#: ../../../CHANGELOG.md:821
#: ../../../CHANGELOG.md:828
#: ../../../CHANGELOG.md:1107
#: ../../../CHANGELOG.md:1188
#: ../../../CHANGELOG.md:1210
#: ../../../CHANGELOG.md:3047
msgid "Fixes"
msgstr ""

#: ../../../CHANGELOG.md:239
msgid "Add the `report` method to `logging.LoggerAdapter` [[7d6684ce1]](https://github.com/aiidateam/aiida-core/commit/7d6684ce1f46862e69c59e9b48da97ab63d9f786)"
msgstr ""

#: ../../../CHANGELOG.md:240
msgid "`CalcJob`: Fix MPI behavior if `withmpi` option default is True [[84737506e]](https://github.com//commit/84737506e99860beb3ecfa329c1d1e9d4636cd16)"
msgstr ""

#: ../../../CHANGELOG.md:241
msgid "`CalcJobNode`: Fix validation for `depth=None` in `retrieve_list` [[03c86d5c9]](https://github.com/aiidateam/aiida-core/commit/03c86d5c988d9d2e1f656ba28bd2b8292fc7b02d)"
msgstr ""

#: ../../../CHANGELOG.md:242
msgid "CLI: Fix bug in `verdi data core.trajectory show` for various formats [[fd4c1269b]](https://github.com/aiidateam/aiida-core/commit/fd4c1269bf913602660b13bdb49c3bc15360448a)"
msgstr ""

#: ../../../CHANGELOG.md:243
msgid "CLI: Add missing entry point groups for `verdi plugin list` [[ae637d8c4]](https://github.com/aiidateam/aiida-core/commit/ae637d8c474a0071031c6a9bf6f65d2a924f2e81)"
msgstr ""

#: ../../../CHANGELOG.md:244
msgid "CLI: Remove loading backend for `verdi plugin list` [[34e564ad0]](https://github.com/aiidateam/aiida-core/commit/34e564ad081143a4739c58a7aaa499e55d4e4651)"
msgstr ""

#: ../../../CHANGELOG.md:245
msgid "CLI: Fix `repository` being required for `verdi quicksetup` [[d4666009e]](https://github.com/aiidateam/aiida-core/commit/d4666009e82fc104a1fa7965b1f50934bec36f0f)"
msgstr ""

#: ../../../CHANGELOG.md:246
msgid "CLI: Fix `verdi config set` when setting list option [[314917801]](https://github.com/aiidateam/aiida-core/commit/314917801181d163f0760ca5788c543103d96bf5)"
msgstr ""

#: ../../../CHANGELOG.md:247
msgid "CLI: Keep list unique in `verdi config set --append` [[3844f86c6]](https://github.com/aiidateam/aiida-core/commit/3844f86c6bb7da1dfc40542210b450a70b8950c5)"
msgstr ""

#: ../../../CHANGELOG.md:248
msgid "CLI: Improve the formatting of `verdi user list` [[806d7e236]](https://github.com/aiidateam/aiida-core/commit/806d7e2366225bbe16ed982c320a708dbbf323f5)"
msgstr ""

#: ../../../CHANGELOG.md:249
msgid "CLI: Set defaults for user details in profile setup [[8b8887e55]](https://github.com/aiidateam/aiida-core/commit/8b8887e559e02eadac832a89f7012872040e1cbc)"
msgstr ""

#: ../../../CHANGELOG.md:250
msgid "CLI: Reuse options in `verdi user configure` from setup [[1c0b702ba]](https://github.com/aiidateam/aiida-core/commit/1c0b702bafb56c6452c975ad7020796303742405)"
msgstr ""

#: ../../../CHANGELOG.md:251
msgid "`InteractiveOption`: Fix validation being skipped if `!` provided [[c4b183bc6]](https://github.com/aiidateam/aiida-core/commit/c4b183bc6d6083dad0754e42de19e96a867ff8ed)"
msgstr ""

#: ../../../CHANGELOG.md:252
msgid "ORM: Fix problem with detached `DbAuthInfo` instances [[ec2c6a8fe]](https://github.com//commit/ec2c6a8fe3b397ab9f7314c556551114ea15c7df)"
msgstr ""

#: ../../../CHANGELOG.md:253
msgid "ORM: Check nodes are from same backend in `validate_link` [[7bd546ebe]](https://github.com/aiidateam/aiida-core/commit/7bd546ebe67845b47c0dc14567c1ef7a557c23ef)"
msgstr ""

#: ../../../CHANGELOG.md:254
msgid "ORM: `ProcessNode.is_valid_cache` is `False` for unsealed nodes [[a1f456d43]](https://github.com/aiidateam/aiida-core/commit/a1f456d436fee6a54327e4ba9b0841a980998f52)"
msgstr ""

#: ../../../CHANGELOG.md:255
msgid "ORM: Explicitly pass backend when constructing new entity [[96667c8c6]](https://github.com/aiidateam/aiida-core/commit/96667c8c63b0053e79c8a1531707890027f10e6a)"
msgstr ""

#: ../../../CHANGELOG.md:256
msgid "ORM: Replace `.collection(backend)` with `.get_collection(backend)` [[bac2152c4]](https://github.com/aiidateam/aiida-core/commit/bac2152c450a83cb6332516db315147cfc982265)"
msgstr ""

#: ../../../CHANGELOG.md:257
msgid "Make `warn_deprecation` respect the `warnings.showdeprecations` option [[6c28c63e9]](https://github.com//commit/6c28c63e95323a4e3ba8730ef720e1a708d91133)"
msgstr ""

#: ../../../CHANGELOG.md:258
msgid "`PsqlDosBackend`: Fix changes not persisted after `iterall` and `iterdict` [[2ea5087c0]](https://github.com/aiidateam/aiida-core/commit/2ea5087c079417d6d0b37cbc0502ed7cab173c11)"
msgstr ""

#: ../../../CHANGELOG.md:259
msgid "`PsqlDosBackend`: Fix `Node.store` excepting when inside a transaction [[624dcd9fc]](https://github.com/aiidateam/aiida-core/commit/624dcd9fcc1f0f9aadf54c59afa435fd78598ef7)"
msgstr ""

#: ../../../CHANGELOG.md:260
msgid "`Parser.parse_from_node`: Validate outputs against process spec [[d16792f3d]](https://github.com/aiidateam/aiida-core/commit/d16792f3d80fb1c497840ff1b0f6f1e114a262da)"
msgstr ""

#: ../../../CHANGELOG.md:261
msgid "Fix `QueryBuilder.count` for storage backends using sqlite [[5dc1555bc]](https://github.com/aiidateam/aiida-core/commit/5dc1555bc186a7b0205323801833037ae9a6bc36)"
msgstr ""

#: ../../../CHANGELOG.md:262
msgid "Process functions: Fix bug with variable arguments [[ca8bbc67f]](https://github.com//commit/ca8bbc67fcb40d6cec4e1cae32ce114495c0eb1d)"
msgstr ""

#: ../../../CHANGELOG.md:263
msgid "`SqliteZipBackend`: Return `self` in `store` [[6a43b3f15]](https://github.com/aiidateam/aiida-core/commit/6a43b3f15ca9cc2eab1a13f6670921f71809a956)"
msgstr ""

#: ../../../CHANGELOG.md:264
msgid "`SqliteZipBackend`: Ensure the `filepath` is absolute and exists [[5eac8b49d]](https://github.com//commit/5eac8b49df33287c3dc6cfbf46eae491c3196fc4)"
msgstr ""

#: ../../../CHANGELOG.md:265
msgid "Remove `with_dbenv` use in `aiida.orm` [[35c57b9eb]](https://github.com/aiidateam/aiida-core/commit/35c57b9eb63b42531111f27ac7cc76e129ccd14a)"
msgstr ""

#: ../../../CHANGELOG.md:267
#: ../../../CHANGELOG.md:415
#: ../../../CHANGELOG.md:659
#: ../../../CHANGELOG.md:1147
#: ../../../CHANGELOG.md:2221
#: ../../../CHANGELOG.md:2286
#: ../../../CHANGELOG.md:2304
#: ../../../CHANGELOG.md:2333
#: ../../../CHANGELOG.md:2742
#: ../../../CHANGELOG.md:2808
msgid "Deprecations"
msgstr ""

#: ../../../CHANGELOG.md:268
msgid "Deprecated `aiida.orm.nodes.data.upf` and `verdi data core.upf` [[6625fd245]](https://github.com/aiidateam/aiida-core/commit/6625fd2456f4ee13297d797d08925a359474e30e)"
msgstr ""

#: ../../../CHANGELOG.md:270
#: ../../../CHANGELOG.md:418
#: ../../../CHANGELOG.md:670
#: ../../../CHANGELOG.md:803
#: ../../../CHANGELOG.md:1153
#: ../../../CHANGELOG.md:1946
#: ../../../CHANGELOG.md:2336
#: ../../../CHANGELOG.md:2919
#: ../../../CHANGELOG.md:2988
msgid "Documentation"
msgstr ""

#: ../../../CHANGELOG.md:271
msgid "Add topic section on storage [[83dbe1ad9]](https://github.com//commit/83dbe1ad92be580fa26412e5db4d1f370ec91c7a)"
msgstr ""

#: ../../../CHANGELOG.md:272
msgid "Add important note on using `iterall` and `iterdict` [[0aea7e41b]](https://github.com/aiidateam/aiida-core/commit/0aea7e41b24fb479b2a1bbc71ab72f43e823f3a7)"
msgstr ""

#: ../../../CHANGELOG.md:273
msgid "Add links about \"entry point\" and \"plugin\" to tutorial [[517ffcb1c]](https://github.com/aiidateam/aiida-core/commit/517ffcb1c5ce32f281589432cde1d58588fa83e0)"
msgstr ""

#: ../../../CHANGELOG.md:274
msgid "Disable the `warnings.showdeprecations` option [[4adb06c0c]](https://github.com//commit/4adb06c0ce32335fffe5d970febfd36dcd85edd5)"
msgstr ""

#: ../../../CHANGELOG.md:275
msgid "Fix instructions for inspecting archive files [[0a9c2788e]](https://github.com//commit/0a9c2788ea54926a202c5c3393d9d34815bf4356)"
msgstr ""

#: ../../../CHANGELOG.md:276
msgid "Changes are reverted if exception during `iterall` [[17c5d8724]](https://github.com/aiidateam/aiida-core/commit/17c5d872495fbb1b6a80d985cb71088095083bb9)"
msgstr ""

#: ../../../CHANGELOG.md:277
msgid "Various minor fixes to `run_docker.rst` [[d3788adea]](https://github.com/aiidateam/aiida-core/commit/d3788adea220107bce3582d246bcc9674b5e1571)"
msgstr ""

#: ../../../CHANGELOG.md:278
msgid "Update `pydata-sphinx-theme` and add Discourse links [[13df42c14]](https://github.com/aiidateam/aiida-core/commit/13df42c14abc6145da3880616288a98b2d5ecc74)"
msgstr ""

#: ../../../CHANGELOG.md:279
msgid "Correct example of `verdi config unset` in troubleshooting [[d6143dbc8]](https://github.com/aiidateam/aiida-core/commit/d6143dbc87bbbb3b6d4758b3922a47741493897e)"
msgstr ""

#: ../../../CHANGELOG.md:280
msgid "Improvements to sections containing recently added functionality [[836419f66]](https://github.com/aiidateam/aiida-core/commit/836419f6694e9d4d8e580f1b6fd71ffa27f635ef)"
msgstr ""

#: ../../../CHANGELOG.md:281
msgid "Fix typo in `run_codes.rst` [[9bde86ec7]](https://github.com/aiidateam/aiida-core/commit/9bde86ec7700b3dd2df55c69fb8efb9887ed07d6)"
msgstr ""

#: ../../../CHANGELOG.md:282
msgid "Fixtures: Fix `suppress_warnings` of `run_cli_command` [[9807cede4]](https://github.com//commit/9807cede4601349a50ac2bff72a32173a0e3d702)"
msgstr ""

#: ../../../CHANGELOG.md:283
msgid "Update citation suggestions [[1dafdf2dd]](https://github.com/aiidateam/aiida-core/commit/1dafdf2ddb38c801d2075d9af9bbde9e0d26c8ca)"
msgstr ""

#: ../../../CHANGELOG.md:285
#: ../../../CHANGELOG.md:329
#: ../../../CHANGELOG.md:343
#: ../../../CHANGELOG.md:410
#: ../../../CHANGELOG.md:701
#: ../../../CHANGELOG.md:800
#: ../../../CHANGELOG.md:1141
#: ../../../CHANGELOG.md:1219
#: ../../../CHANGELOG.md:1874
#: ../../../CHANGELOG.md:2130
#: ../../../CHANGELOG.md:2217
msgid "Dependencies"
msgstr ""

#: ../../../CHANGELOG.md:286
msgid "Add support for Python 3.12 [[c39b4fda4]](https://github.com/aiidateam/aiida-core/commit/c39b4fda40c88737f1c56f5ad6f42cbed974478b)"
msgstr ""

#: ../../../CHANGELOG.md:287
msgid "Update to `sqlalchemy~=2.0` [[a216f5052]](https://github.com/aiidateam/aiida-core/commit/a216f5052c56bbbeffac296fcd59af177f703829)"
msgstr ""

#: ../../../CHANGELOG.md:288
msgid "Update to `disk-objectstore~=1.0` [[56f9f6ca0]](https://github.com/aiidateam/aiida-core/commit/56f9f6ca03c7b69766e725449fd955848577055a)"
msgstr ""

#: ../../../CHANGELOG.md:289
msgid "Add new extra `tui` that provides `verdi` as a TUI [[a42e09c02]](https://github.com/aiidateam/aiida-core/commit/a42e09c026e793e5670b88037d5f4863cc4097f0)"
msgstr ""

#: ../../../CHANGELOG.md:290
msgid "Add upper limit `jedi<0.19` [[fae2a9cfd]](https://github.com/aiidateam/aiida-core/commit/fae2a9cfda461a26e80b648795e45087ea8133fd)"
msgstr ""

#: ../../../CHANGELOG.md:291
msgid "Update requirement `mypy~=1.7` [[c2fcad4ab]](https://github.com/aiidateam/aiida-core/commit/c2fcad4ab3f6bc1899475af037e4b14f3497feec)"
msgstr ""

#: ../../../CHANGELOG.md:292
msgid "Add compatibility for `pymatgen>=v2023.9.2` [[4e0e7d8e9]](https://github.com/aiidateam/aiida-core/commit/4e0e7d8e9fd10c4adc3630cf24cebdf749f95351)"
msgstr ""

#: ../../../CHANGELOG.md:293
msgid "Bump `yapf` to `0.40.0` [[a8ae50853]](https://github.com/aiidateam/aiida-core/commit/a8ae508537d2b6e9ffa1de9beb140065282a30f8)"
msgstr ""

#: ../../../CHANGELOG.md:294
msgid "Update pre-commit requirement `flynt==1.0.1` [[e01ea4b97]](https://github.com/aiidateam/aiida-core/commit/e01ea4b97d094f0543b0f0c631fa0463c8baf2f5)"
msgstr ""

#: ../../../CHANGELOG.md:295
msgid "Docker: Pinning mamba version to 1.5.2 [[a6c2dbe1c]](https://github.com//commit/a6c2dbe1c434f0df7790e41632c5dc578edebb97)"
msgstr ""

#: ../../../CHANGELOG.md:296
msgid "Docker: Bump Python version to 3.10.13 [[b168f2e12]](https://github.com//commit/b168f2e12776136a8601b42dd85d7b2bb4746e30)"
msgstr ""

#: ../../../CHANGELOG.md:298
#: ../../../CHANGELOG.md:346
#: ../../../CHANGELOG.md:402
#: ../../../CHANGELOG.md:1164
msgid "Devops"
msgstr ""

#: ../../../CHANGELOG.md:299
msgid "CI: Use Python 3.10 for `pre-commit` in CI and CD workflows [[f41c8ac90]](https://github.com/aiidateam/aiida-core/commit/f41c8ac9061c379f72286631bfb1c486cc302dc8)"
msgstr ""

#: ../../../CHANGELOG.md:300
msgid "CI: Using concurrency for CI actions [[4db54b7f8]](https://github.com/aiidateam/aiida-core/commit/4db54b7f833096e2d5f3d439683c28749467b20d)"
msgstr ""

#: ../../../CHANGELOG.md:301
msgid "CI: Update tox to use Python 3.9 [[227390a52]](https://github.com/aiidateam/aiida-core/commit/227390a52a6dc77faa20cb1cc6372ec7f66e0409)"
msgstr ""

#: ../../../CHANGELOG.md:302
msgid "Docker: Bump `upload-artifact` action to v4 for Docker workflow [[bfdb2828a]](https://github.com//commit/bfdb2828a823052df52cb5cf61599cbc07b0bb4b)"
msgstr ""

#: ../../../CHANGELOG.md:303
msgid "Refactor: Replace `all` with `iterall` where beneficial [[8a2fece02]](https://github.com/aiidateam/aiida-core/commit/8a2fece02411c982eb16e8fed8991ffaf75fa76f)"
msgstr ""

#: ../../../CHANGELOG.md:304
msgid "Pre-commit: Disable `no-member` and `no-name-in-module` for `aiida.orm` [[15379bbee]](https://github.com/aiidateam/aiida-core/commit/15379bbee2cbf9889772d497e1a6b77e230aaa2f)"
msgstr ""

#: ../../../CHANGELOG.md:305
msgid "Tests: Move memory leak tests to main unit test suite [[561f93cef]](https://github.com/aiidateam/aiida-core/commit/561f93cef15355e08a3ec19173132deec031ed67)"
msgstr ""

#: ../../../CHANGELOG.md:306
msgid "Tests: Move ipython magic tests to main unit test suite [[ce9acc312]](https://github.com/aiidateam/aiida-core/commit/ce9acc312c0cfe351f188d399046de6a4248cb16)"
msgstr ""

#: ../../../CHANGELOG.md:307
msgid "Tests: Remove deprecated `aiida/manage/tests/main` module [[5b9da7d1e]](https://github.com/aiidateam/aiida-core/commit/5b9da7d1eeb3cb01474f2c95526148ba136c6f3c)"
msgstr ""

#: ../../../CHANGELOG.md:308
msgid "Tests: Refactor transport tests from `unittest` to `pytest` [[ec64780c2]](https://github.com/aiidateam/aiida-core/commit/ec64780c206cdb040eee740b17865e6f0ff81cd8)"
msgstr ""

#: ../../../CHANGELOG.md:309
msgid "Tests: Fix failing `tests/cmdline/commands/test_setup.py` [[b6f7ec188]](https://github.com/aiidateam/aiida-core/commit/b6f7ec18830d8495a76eefb3ef59e0069db49f99)"
msgstr ""

#: ../../../CHANGELOG.md:310
msgid "Tests: Print stack trace if CLI command excepts with `run_cli_command` [[08cba0f78]](https://github.com/aiidateam/aiida-core/commit/08cba0f78acbf3da760f8d9110426b80df20ab3a)"
msgstr ""

#: ../../../CHANGELOG.md:311
msgid "Tests: Make `PsqlDosStorage` profile unload test more robust [[1c72eac1f]](https://github.com/aiidateam/aiida-core/commit/1c72eac1f91e02bc464c66328ea74911762b94fd)"
msgstr ""

#: ../../../CHANGELOG.md:312
msgid "Tests: Fix flaky work chain tests using `recwarn` fixture [[207151784]](https://github.com/aiidateam/aiida-core/commit/2071517849820e218a28d3968e45d211e8cd6247)"
msgstr ""

#: ../../../CHANGELOG.md:313
msgid "Tests: Fix `StructureData` test breaking for recent `pymatgen` versions [[d1d64e800]](https://github.com/aiidateam/aiida-core/commit/d1d64e8004c31209488f71a160a4f4824d02c081)"
msgstr ""

#: ../../../CHANGELOG.md:314
msgid "Typing: Improve annotations of process functions [[a85af4f0c]](https://github.com/aiidateam/aiida-core/commit/a85af4f0c017b8c03426ef7927163a33add08004)"
msgstr ""

#: ../../../CHANGELOG.md:315
msgid "Typing: Add type hinting for `aiida.orm.nodes.data.array.xy` [[2eaa5449b]](https://github.com/aiidateam/aiida-core/commit/2eaa5449bca55ac87475900dd64ca086bddc0023)"
msgstr ""

#: ../../../CHANGELOG.md:316
msgid "Typing: Add type hinting for `aiida.orm.nodes.data.array.array` [[c19b1423a]](https://github.com/aiidateam/aiida-core/commit/c19b1423adfb0b8490cdfb899cabd8e88e03237f)"
msgstr ""

#: ../../../CHANGELOG.md:317
msgid "Typing: Add overload signatures for `open` [[0986f6b59]](https://github.com/aiidateam/aiida-core/commit/0986f6b59086e2e0947906654c1642cf264b462e)"
msgstr ""

#: ../../../CHANGELOG.md:318
msgid "Typing: Add overload signatures for `get_object_content` [[d18eedc8b]](https://github.com/aiidateam/aiida-core/commit/d18eedc8be565af12f36e48bd8392e9b29438c15)"
msgstr ""

#: ../../../CHANGELOG.md:319
msgid "Typing: Correct type annotation of `WorkChain.on_wait` [[923cc314c]](https://github.com/aiidateam/aiida-core/commit/923cc314c527a183e55819b96de8ae027c9f0612)"
msgstr ""

#: ../../../CHANGELOG.md:320
msgid "Typing: Improve type hinting for `aiida.orm.nodes.data.singlefile` [[b9d087dd4]](https://github.com/aiidateam/aiida-core/commit/b9d087dd47c2b09878d078fc6a64cede0e1ce5e1)"
msgstr ""

#: ../../../CHANGELOG.md:323
msgid "v2.4.2 - 2023-11-30"
msgstr ""

#: ../../../CHANGELOG.md:325
#: ../../../CHANGELOG.md:337
msgid "Docker"
msgstr ""

#: ../../../CHANGELOG.md:326
msgid "Disable the consumer timeout for RabbitMQ [[5ce1e7ec3]](https://github.com/aiidateam/aiida-core/commit/5ce1e7ec37207013a7733b9df943977a15e421e5)"
msgstr ""

#: ../../../CHANGELOG.md:327
msgid "Add `rsync` and `graphviz` to system requirements [[c4799add4]](https://github.com/aiidateam/aiida-core/commit/c4799add41a29944dd02be2ca44756eaf8035b1c)"
msgstr ""

#: ../../../CHANGELOG.md:330
msgid "Add upper limit `jedi<0.19` [[90e586fe3]](https://github.com/aiidateam/aiida-core/commit/90e586fe367daf8f9ebe953c2a976bc5c4d33903)"
msgstr ""

#: ../../../CHANGELOG.md:333
msgid "v2.4.1 - 2023-11-15"
msgstr ""

#: ../../../CHANGELOG.md:335
msgid "This patch release comes with an improved set of Docker images and a few fixes to provide compatibility with recent versions of `pymatgen`."
msgstr ""

#: ../../../CHANGELOG.md:338
msgid "Improved Docker images [[fec4e3bc4]](https://github.com/aiidateam/aiida-core/commit/fec4e3bc4dffd7d15b63e7ef0f306a8034ca3816)"
msgstr ""

#: ../../../CHANGELOG.md:339
msgid "Add folders that automatically run scripts before/after daemon start in Docker image [[fe4bc1d3d]](https://github.com/aiidateam/aiida-core/commit/fe4bc1d3d380686094021515baf31babf47388ac)"
msgstr ""

#: ../../../CHANGELOG.md:340
msgid "Pass environment variable to `aiida-prepare` script in Docker image [[ea47668ea]](https://github.com/aiidateam/aiida-core/commit/ea47668ea9b38581fbe1b6c72e133824043a8d38)"
msgstr ""

#: ../../../CHANGELOG.md:341
msgid "Update the `.devcontainer` to use the new docker stack [[413a0db65]](https://github.com/aiidateam/aiida-core/commit/413a0db65cb31156e6e794dac4f8d36e74b0b2cb)"
msgstr ""

#: ../../../CHANGELOG.md:344
msgid "Add compatibility for `pymatgen>=v2023.9.2` [[1f6027f06]](https://github.com/aiidateam/aiida-core/commit/1f6027f062a9eca5d8006741df91545d8ec01ed3)"
msgstr ""

#: ../../../CHANGELOG.md:347
msgid "Tests: Make `PsqlDosStorage` profile unload test more robust [[f392459bd]](https://github.com/aiidateam/aiida-core/commit/f392459bd417bec8a3ce184ee8f753649bcb77b8)"
msgstr ""

#: ../../../CHANGELOG.md:348
msgid "Tests: Fix `StructureData` test breaking for recent `pymatgen` versions [[093037d48]](https://github.com/aiidateam/aiida-core/commit/093037d48a2d92cbb6f068c1111fe1564a4500c0)"
msgstr ""

#: ../../../CHANGELOG.md:349
msgid "Trigger Docker image build when pushing to `support/*` branch [[5cf3d1d75]](https://github.com/aiidateam/aiida-core/commit/5cf3d1d75e8d22d6a3f0909c84aa63cc228bcf4b)"
msgstr ""

#: ../../../CHANGELOG.md:350
msgid "Use `aiida-core-base` image from `ghcr.io` [[0e5b1c747]](https://github.com/aiidateam/aiida-core/commit/0e5b1c7473030dd5b5027ea4eb0a658db9174091)"
msgstr ""

#: ../../../CHANGELOG.md:351
msgid "Loosen trigger conditions for Docker build CI workflow [[22e8a8069]](https://github.com/aiidateam/aiida-core/commit/22e8a80690747b792b70f96a0e332906f0e65e97)"
msgstr ""

#: ../../../CHANGELOG.md:352
msgid "Follow-up docker build runner macOS-ARM64 [[1bd9bf03d]](https://github.com/aiidateam/aiida-core/commit/1bd9bf03d19dda4c462728fb87cf4712b74c5f39)"
msgstr ""

#: ../../../CHANGELOG.md:353
msgid "Upload artifact by PR from forks for docker workflow [[afc2dad8a]](https://github.com/aiidateam/aiida-core/commit/afc2dad8a68e280f01e89fcb5b13e7a60c2fd072)"
msgstr ""

#: ../../../CHANGELOG.md:354
msgid "Update the image name for docker image [[17507b410]](https://github.com/aiidateam/aiida-core/commit/17507b4108b5dd1cd6e074b08e0bc2535bf0a164)"
msgstr ""

#: ../../../CHANGELOG.md:357
msgid "v2.4.0 - 2023-06-22"
msgstr ""

#: ../../../CHANGELOG.md:359
msgid "This minor release comes with a number of new features and improvements as well as a significant amount of bug fixes. Support for Python 3.8 has been officially dropped in accordance with [AEP 003](https://github.com/aiidateam/AEP/blob/master/003_adopt_nep_29/readme.md)."
msgstr ""

#: ../../../CHANGELOG.md:362
msgid "As a result of one of the bug fixes, related to the [caching of `CalcJob` nodes](https://github.com/aiidateam/aiida-core/commit/685e0f87d7c571df24aea8f0ce21c6c45dfbd8a0), a database migration had to be added, the first since the release of v2.0. After ugrading to v2.4.0, you will be prompted to migrate your database. The automated migration drops the hashes of existing `CalcJobNode`s and provides you with the optional command to recompute them. Execute the command if existing `CalcJobNode`s need to be usable as valid cache sources."
msgstr ""

#: ../../../CHANGELOG.md:368
msgid "Config: Add option to change recursion limit in daemon workers [[226159fd9]](https://github.com/aiidateam/aiida-core/commit/226159fd96c01782f4e1b4b52db945e3aef76285)"
msgstr ""

#: ../../../CHANGELOG.md:369
msgid "CLI: Added `compress` option to `verdi storage maintain` [[add474cbb]](https://github.com/aiidateam/aiida-core/commit/add474cbb0d67e278803e9340e521ea1046ef35c)"
msgstr ""

#: ../../../CHANGELOG.md:370
msgid "Expose `get_daemon_client` so it can be imported from `aiida.engine` [[1a0c1ee93]](https://github.com/aiidateam/aiida-core/commit/1a0c1ee932f24a6b191dc2e4d770973b8b32d66e)"
msgstr ""

#: ../../../CHANGELOG.md:371
msgid "`verdi computer test`: Improve messaging of login shell check [[062a58260]](https://github.com/aiidateam/aiida-core/commit/062a5826077907f43165084d4dc02db3f71bfb73)"
msgstr ""

#: ../../../CHANGELOG.md:372
msgid "`verdi node rehash`: Add `aiida.node` as group for `--entry-point` [[2fd07514d]](https://github.com/aiidateam/aiida-core/commit/2fd07514d9a76ceb5576dd23c02596794dea0666)"
msgstr ""

#: ../../../CHANGELOG.md:373
msgid "`verdi process status`: Add `call_link_label` to stack entries [[bd9372a5f]](https://github.com/aiidateam/aiida-core/commit/bd9372a5f4ce6681b16ef806338512c0fb02e25e)"
msgstr ""

#: ../../../CHANGELOG.md:374
msgid "`SinglefileData`: Add the `from_string` classmethod [[c25de615e]](https://github.com/aiidateam/aiida-core/commit/c25de615e4680b809f5d65d42031afdf95bd6923)"
msgstr ""

#: ../../../CHANGELOG.md:375
msgid "`DynamicEntryPointCommandGroup`: Add support for shared options [[220a65c76]](https://github.com/aiidateam/aiida-core/commit/220a65c76d9fcf3144ef77925caff8f5c653b2c9)"
msgstr ""

#: ../../../CHANGELOG.md:376
msgid "`DynamicEntryPointCommandGroup`: Pass ctx to `command` callable [[7de711be4]](https://github.com/aiidateam/aiida-core/commit/7de711be468f91e09baf6def3e319d85288e3be1)"
msgstr ""

#: ../../../CHANGELOG.md:377
msgid "`ProcessNode`: Add the `exit_code` property [[ad8a539ee]](https://github.com/aiidateam/aiida-core/commit/ad8a539ee2b481d526607b5924789fbbd1e14102)"
msgstr ""

#: ../../../CHANGELOG.md:380
msgid "Engine: Dynamically update maximum stack size close to overflow to address `RecursionError` under heavy load [[f797b4766]](https://github.com/aiidateam/aiida-core/commit/f797b476622d9b2724d1460bbe55ef989166f57d)"
msgstr ""

#: ../../../CHANGELOG.md:381
msgid "`CalcJobNode`: Fix the computation of the hash [[685e0f87d]](https://github.com/aiidateam/aiida-core/commit/685e0f87d7c571df24aea8f0ce21c6c45dfbd8a0)"
msgstr ""

#: ../../../CHANGELOG.md:382
msgid "`CalcJob`: Ignore file in `remote_copy_list` not existing [[101a8d61b]](https://github.com/aiidateam/aiida-core/commit/101a8d61ba1c9f50a0231cd249c5a7f7ff1d77a4)"
msgstr ""

#: ../../../CHANGELOG.md:383
msgid "`CalcJob`: Assign outputs from node in case of cache hit [[777b97601]](https://github.com/aiidateam/aiida-core/commit/777b976013d0041e059f86c1ac0d2f43b52884df)"
msgstr ""

#: ../../../CHANGELOG.md:384
msgid "Fix log messages being logged twice to the daemon log file [[bfd63c790]](https://github.com/aiidateam/aiida-core/commit/bfd63c790a6bd5fdcb60a2d1b840c7b285c53334)"
msgstr ""

#: ../../../CHANGELOG.md:385
msgid "Process control: Change language when not waiting for response [[68cb4579d]](https://github.com/aiidateam/aiida-core/commit/68cb4579d9e77b32dc6182dc704e6079b6f9c0c2)"
msgstr ""

#: ../../../CHANGELOG.md:386
msgid "Do not assume `pgtest` cluster started in `postgres_cluster` fixture [[1de2ca576]](https://github.com/aiidateam/aiida-core/commit/1de2ca576c7fbe5c6586f53160304b46c99a3a10)"
msgstr ""

#: ../../../CHANGELOG.md:387
msgid "Process control: Warn instead of except when daemon is not running [[ad4fbcccb]](https://github.com/aiidateam/aiida-core/commit/ad4fbcccb14ac68653a941bf17be2e532ca162bc)"
msgstr ""

#: ../../../CHANGELOG.md:388
msgid "`DirectScheduler`: Add `?` as `JobState.UNDETERMINED` [[ffc869d8f]](https://github.com/aiidateam/aiida-core/commit/ffc869d8f91a860055b12f0d3803615895fa464f)"
msgstr ""

#: ../../../CHANGELOG.md:389
msgid "CLI: Correct `verdi devel rabbitmq tasks revive` docstring [[13cadd05f]](https://github.com/aiidateam/aiida-core/commit/13cadd05f2463b0fd240dde2f979801fbac122f9)"
msgstr ""

#: ../../../CHANGELOG.md:390
msgid "`SinglefileData`: Fix bug when `filename` is `pathlib.Path` [[f36bf583c]](https://github.com/aiidateam/aiida-core/commit/f36bf583c2bb4ac532d97f843141c907ee350f69)"
msgstr ""

#: ../../../CHANGELOG.md:391
msgid "Improve clarity of various deprecation warnings [[c72a252ed]](https://github.com/aiidateam/aiida-core/commit/c72a252ed563c7f0a7604d15632331c094973b5f)"
msgstr ""

#: ../../../CHANGELOG.md:392
msgid "`CalcJob`: Remove default of `withmpi` input and make it optional [[6a88cb315]](https://github.com/aiidateam/aiida-core/commit/6a88cb3158c0b84b601a289f50f51cfe6ae42687)"
msgstr ""

#: ../../../CHANGELOG.md:393
msgid "`Process`: Have `inputs` property always return `AttributesFrozenDict` [[60756fe30]](https://github.com/aiidateam/aiida-core/commit/60756fe30dfaff443ab434d92196249eea47f166)"
msgstr ""

#: ../../../CHANGELOG.md:394
msgid "`PsqlDos`: Add migration to remove hashes for all `CalcJobNodes` [[7ad916836]](https://github.com/aiidateam/aiida-core/commit/7ad91683643a5d9134c2a9532901e00b903996b4)"
msgstr ""

#: ../../../CHANGELOG.md:395
msgid "`PsqlDosMigrator`: Commit changes when migrating existing schema [[f84fe5b60]](https://github.com/aiidateam/aiida-core/commit/f84fe5b608d0656c82a38edbcbcb7bf48b399562)"
msgstr ""

#: ../../../CHANGELOG.md:396
msgid "`PsqlDos`: Add `entry_point_string` argument to `drop_hashes` [[c7a36fa3d]](https://github.com/aiidateam/aiida-core/commit/c7a36fa3d1fcd59e5ff31348c9f64619a7835b75)"
msgstr ""

#: ../../../CHANGELOG.md:397
msgid "`PsqlDos`: Make hash reset migrations more explicit [[c447a1af3]](https://github.com/aiidateam/aiida-core/commit/c447a1af39f99f2b53cffef36828d2523ab720a5)"
msgstr ""

#: ../../../CHANGELOG.md:398
msgid "`verdi process list`: Fix double percent sign in daemon usage [[68be866e6]](https://github.com/aiidateam/aiida-core/commit/68be866e653c610e9b957a3fdedc1b77e6e41a05)"
msgstr ""

#: ../../../CHANGELOG.md:399
msgid "Fix the `daemon_client` fixture [[9e5f5eefd]](https://github.com/aiidateam/aiida-core/commit/9e5f5eefd0cd6be44f0be76efae157dcf6e160ed)"
msgstr ""

#: ../../../CHANGELOG.md:400
msgid "Transports: Raise `FileNotFoundError` in `copy` if source doesn't exist [[d82069441]](https://github.com/aiidateam/aiida-core/commit/d82069441ce4bb002c8c9b5a419a9d8a8c4446b7)"
msgstr ""

#: ../../../CHANGELOG.md:403
msgid "Add `graphviz` to system requirements of RTD build runner [[3df02550e]](https://github.com/aiidateam/aiida-core/commit/3df02550eff02cd625d0e14eb35e6d6b01b4b12d)"
msgstr ""

#: ../../../CHANGELOG.md:404
msgid "Add types for `DefaultFieldsAttributeDict` subclasses [[afed5dc46]](https://github.com/aiidateam/aiida-core/commit/afed5dc4630b25b72b2c5a27d542222c086067a7)"
msgstr ""

#: ../../../CHANGELOG.md:405
msgid "Bump Python version for RTD build [[5df446cd3]](https://github.com/aiidateam/aiida-core/commit/5df446cd3558b1b7ee11d9b60d75287d6395a693)"
msgstr ""

#: ../../../CHANGELOG.md:406
msgid "Pre-commit: Fix `mypy` warning in `aiida.orm.utils.serialize` [[c25922484]](https://github.com/aiidateam/aiida-core/commit/c2592248482c087807d550c8304fa3703744cdf2)"
msgstr ""

#: ../../../CHANGELOG.md:407
msgid "Update Docker base image `aiida-prerequisites==0.7.0` [[ac755afae]](https://github.com/aiidateam/aiida-core/commit/ac755afaec836ffc9bc05e0617065eade5ef9ca7)"
msgstr ""

#: ../../../CHANGELOG.md:408
msgid "Use f-strings in `aiida/engine/daemon/execmanager.py` [[49cffff21]](https://github.com/aiidateam/aiida-core/commit/49cffff21e9fedac517e0e3659eaf1aacb61e448)"
msgstr ""

#: ../../../CHANGELOG.md:411
msgid "Drop support for Python 3.8 [[3defb8bb7]](https://github.com/aiidateam/aiida-core/commit/3defb8bb70fab87c5a4375e34dc07144077036fd)"
msgstr ""

#: ../../../CHANGELOG.md:412
msgid "Update requirement `pylint~=2.17.4` [[397634444]](https://github.com/aiidateam/aiida-core/commit/39763444499eac6fbe76e337fe7e7ca21d675a07)"
msgstr ""

#: ../../../CHANGELOG.md:413
msgid "Update requirement `flask~=2.2` [[a2a05a69f]](https://github.com/aiidateam/aiida-core/commit/a2a05a69fb2fa6aae9a96d49d543e72008d2888f)"
msgstr ""

#: ../../../CHANGELOG.md:416
msgid "`QueryBuilder`: Deprecate `debug` argument and use logger [[603ff37a0]](https://github.com/aiidateam/aiida-core/commit/603ff37a0b6ecd3f5309c8148054b2ac5d022833)"
msgstr ""

#: ../../../CHANGELOG.md:419
msgid "Add missing `core.` prefix to all `verdi data` subcommands [[99319b3c1]](https://github.com/aiidateam/aiida-core/commit/99319b3c175b260ebc813cbec78208deefcdb562)"
msgstr ""

#: ../../../CHANGELOG.md:420
msgid "Clarify negation operator in `QueryBuilder` filters [[2c828811f]](https://github.com/aiidateam/aiida-core/commit/2c828811fbdf7e80358ae3cb223aca1dd67e9bb8)"
msgstr ""

#: ../../../CHANGELOG.md:421
msgid "Correct \"variable\" to \"variadic\" arguments [[978217693]](https://github.com/aiidateam/aiida-core/commit/978217693af987f015b51dc1c422a2e71bd39f4f)"
msgstr ""

#: ../../../CHANGELOG.md:422
msgid "Fix reference target warnings related to `flask_restful` [[4f76e0bd7]](https://github.com/aiidateam/aiida-core/commit/4f76e0bd75bdaf1bab1cae521c52c4a983708544)"
msgstr ""

#: ../../../CHANGELOG.md:425
msgid "v2.3.1 - 2023-05-22"
msgstr ""

#: ../../../CHANGELOG.md:428
msgid "`DaemonClient`: Clean stale PID file in `stop_daemon` [[#6007]](https://github.com/aiidateam/aiida-core/pull/6007)"
msgstr ""

#: ../../../CHANGELOG.md:431
msgid "v2.3.0 - 2023-04-17"
msgstr ""

#: ../../../CHANGELOG.md:433
msgid "This release comes with a number of improvements, some of the more useful and important of which are quickly highlighted. A full list of changes can be found below."
msgstr ""

#: ../../../CHANGELOG.md:436
msgid "[Process function improvements](#process-function-improvements)"
msgstr ""

#: ../../../CHANGELOG.md:437
msgid "[Scheduler plugins: including `environment_variables`](#scheduler-plugins-including-environment_variables)"
msgstr ""

#: ../../../CHANGELOG.md:438
msgid "[`WorkChain`: conditional predicates should return boolean-like](#workchain-conditional-predicates-should-return-boolean-like)"
msgstr ""

#: ../../../CHANGELOG.md:439
msgid "[Controlling usage of MPI](#controlling-usage-of-mpi)"
msgstr ""

#: ../../../CHANGELOG.md:440
msgid "[Add support for Docker containers](#add-support-for-docker-containers)"
msgstr ""

#: ../../../CHANGELOG.md:441
msgid "[Exporting code configurations](#exporting-code-configurations)"
msgstr ""

#: ../../../CHANGELOG.md:448
msgid "[DevOps](#devops)"
msgstr ""

#: ../../../CHANGELOG.md:450
msgid "[New contributors](#new-contributors)"
msgstr ""

#: ../../../CHANGELOG.md:453
msgid "Process function improvements"
msgstr ""

#: ../../../CHANGELOG.md:454
msgid "A number of improvements in the usage of process functions, i.e., `calcfunction` and `workfunction`, have been added. Each subsection title is a link to the documentation for more details."
msgstr ""

#: ../../../CHANGELOG.md:457
msgid "[Variadic arguments](https://aiida.readthedocs.io/projects/aiida-core/en/latest/topics/processes/functions.html#variadic-and-keyword-arguments)"
msgstr ""

#: ../../../CHANGELOG.md:458
msgid "Variadic arguments can be used in case the function should accept a list of inputs of unknown length. Consider the example of a calculation function that computes the average of a number of `Int` nodes:"
msgstr ""

#: ../../../CHANGELOG.md:468
msgid "[Automatic type validation](https://aiida.readthedocs.io/projects/aiida-core/en/latest/topics/processes/functions.html#type-validation)"
msgstr ""

#: ../../../CHANGELOG.md:469
msgid "Type hint annotations can now be used to add automatic type validation to process functions."
msgstr ""

#: ../../../CHANGELOG.md:478
msgid "Since the Python base types (`int`, `str`, `bool`, etc.) are automatically serialized, these can also be used in type hints. The following example is therefore identical to the previous:"
msgstr ""

#: ../../../CHANGELOG.md:486
msgid "[Docstring parsing](https://aiida.readthedocs.io/projects/aiida-core/en/latest/topics/processes/functions.html#docstring-parsing)"
msgstr ""

#: ../../../CHANGELOG.md:487
msgid "The `calcfunction` and `workfunction` generate a `Process` of the decorated function on-the-fly. In doing so, it automatically defines the `ProcessSpec` that is normally done manually, such as for a `CalcJob` or a `WorkChain`. Before, this would just define the ports that the function process accepts, but the `help` attribute of the port would be left empty. This is now parsed from the docstring, if it can be correctly parsed:"
msgstr ""

#: ../../../CHANGELOG.md:504
msgid "This functionality is particularly useful when exposing process functions in work chains. Since the process specification of the exposed function will be automatically inherited, the user can inspect the `help` string through the builder. The automatic documentation produced by the Sphinx plugin will now also display the help string parsed from the docstring."
msgstr ""

#: ../../../CHANGELOG.md:508
msgid "[Nested labels for output nodes](https://aiida.readthedocs.io/projects/aiida-core/en/latest/topics/processes/functions.html#return-values)"
msgstr ""

#: ../../../CHANGELOG.md:509
msgid "The keys in the output dictionary can now contain nested namespaces:"
msgstr ""

#: ../../../CHANGELOG.md:519
msgid "[As class member methods](https://aiida.readthedocs.io/projects/aiida-core/en/latest/topics/processes/functions.html#as-class-member-methods)"
msgstr ""

#: ../../../CHANGELOG.md:520
msgid "Process functions can now be defined as class member methods of work chains:"
msgstr ""

#: ../../../CHANGELOG.md:542
msgid "The function should be declared as a `staticmethod` and it should not include the `self` argument in its function signature. It can then be called from within the work chain as `self.function_name(*args, **kwargs)`."
msgstr ""

#: ../../../CHANGELOG.md:546
msgid "Scheduler plugins: including `environment_variables`"
msgstr ""

#: ../../../CHANGELOG.md:547
msgid "The `Scheduler` base class implements the concrete method `_get_submit_script_environment_variables` which formats the lines for the submission script that set the environment variables that were defined in the `metadata.options.environment_variables` input. Before it was left up to the plugins to actually call this method in the `_get_submit_script_header`, but this is now done by the base class in the `get_submit_script`. You can now remove the call to `_get_submit_script_environment_variables` from your scheduler plugins, as the base class will take care of it. A deprecation warning is emitted if the base class detects that the plugin is still calling it manually. See the [pull request](https://github.com/aiidateam/aiida-core/pull/5948) for more details."
msgstr ""

#: ../../../CHANGELOG.md:553
msgid "`WorkChain`: conditional predicates should return boolean-like"
msgstr ""

#: ../../../CHANGELOG.md:554
msgid "Up till now, work chain methods that are used as the predicate in a conditional, e.g., `if_` or `while_` could return any type. For example:"
msgstr ""

#: ../../../CHANGELOG.md:569
msgid "The `some_conditional` method is used as the \"predicate\" of the `if_` conditional. It returns `True` or `None`. Since the `None` value in Python is \"falsey\", it would be considered as returning `False`. However, this duck-typing could accidentally lead to unexpected situations, so we decided to be more strict on the return type. As of now, a deprecation warning is emitted if the method returns anything that is not \"boolean-like\", i.e., does not implement the `__bool__` method. If you see this warning, please make sure to return a boolean, like the built-ins `True` or `False`, or a `numpy.bool` or `aiida.orm.Bool`. See the [pull request](https://github.com/aiidateam/aiida-core/pull/5924) for more details."
msgstr ""

#: ../../../CHANGELOG.md:577
msgid "Controlling usage of MPI"
msgstr ""

#: ../../../CHANGELOG.md:578
msgid "It is now possible to define on a code object whether it should be run with or without MPI through the `with_mpi` attribute. It can be set from the Python API as `AbstractCode(with_mpi=with_mpi)` or through the `--with-mpi / --no-with-mpi` option of the `verdi code create` CLI command. This option adds a manner to control the use of MPI in calculation jobs, in addition to the existing ones defined by the `CalcJob` plugin and the `metadata.options.withmpi` input. For more details on how these are controlled and how conflicts are handled, please refer to [the documentation](https://aiida.readthedocs.io/projects/aiida-core/en/latest/topics/calculations/usage.html#controlling-mpi)."
msgstr ""

#: ../../../CHANGELOG.md:583
msgid "Add support for Docker containers"
msgstr ""

#: ../../../CHANGELOG.md:584
msgid "Support is added for running calculation within Docker containers. For example, to run Quantum ESPRESSO pw.x in a Docker container, write the following file to `config.yml`:"
msgstr ""

#: ../../../CHANGELOG.md:596
msgid "and run the CLI command:"
msgstr ""

#: ../../../CHANGELOG.md:600
msgid "This should create a `ContainerizedCode` that you can now use to launch a `PwCalculation`. For more details, please refer to [the documentation](https://aiida.readthedocs.io/projects/aiida-core/en/latest/topics/data_types.html#supported-container-technologies)."
msgstr ""

#: ../../../CHANGELOG.md:603
msgid "Exporting code configurations"
msgstr ""

#: ../../../CHANGELOG.md:604
msgid "It is now possible to export the configuration of an existing code through the `verdi code export` command. The produced YAML file can be used to recreate the code through the `verdi code create` command. Note that you should use the correct subcommand based on the type of the original code. For example, if it was an `InstalledCode` you should use `verdi code create core.code.installed`. For the legacy `Code` instances, you should use `verdi code setup`. See the [pull request](https://github.com/aiidateam/aiida-core/pull/5860) for more details."
msgstr ""

#: ../../../CHANGELOG.md:614
msgid "`AbstractCode`: Add the `with_mpi` attribute [[#5922]](https://github.com/aiidateam/aiida-core/pull/5922)"
msgstr ""

#: ../../../CHANGELOG.md:615
msgid "`ContainerizedCode`: Add support for Docker images to use as `Code` for `CalcJob`s [[#5841]](https://github.com/aiidateam/aiida-core/pull/5841)"
msgstr ""

#: ../../../CHANGELOG.md:616
msgid "`InstalledCode`: Allow relative path for `filepath_executable` [[#5879]](https://github.com/aiidateam/aiida-core/pull/5879)"
msgstr ""

#: ../../../CHANGELOG.md:617
msgid "CLI: Allow specifying output filename in `verdi node graph generate` [[#5897]](https://github.com/aiidateam/aiida-core/pull/5897)"
msgstr ""

#: ../../../CHANGELOG.md:618
msgid "CLI: Add `--timeout` option to all `verdi daemon` commands [[#5966]](https://github.com/aiidateam/aiida-core/pull/5966)"
msgstr ""

#: ../../../CHANGELOG.md:619
msgid "CLI: Add the `verdi calcjob remotecat` command [[#4861]](https://github.com/aiidateam/aiida-core/pull/4861)"
msgstr ""

#: ../../../CHANGELOG.md:620
msgid "CLI: Add the `verdi code export` command [[#5860]](https://github.com/aiidateam/aiida-core/pull/5860)"
msgstr ""

#: ../../../CHANGELOG.md:621
msgid "CLI: Improved customizability and scriptability of `verdi storage maintain` [[#5936]](https://github.com/aiidateam/aiida-core/pull/5936)"
msgstr ""

#: ../../../CHANGELOG.md:622
msgid "CLI: `verdi quicksetup`: Further reduce required user interaction [[#5768]](https://github.com/aiidateam/aiida-core/pull/5768)"
msgstr ""

#: ../../../CHANGELOG.md:623
msgid "CLI: `verdi computer test`: Add test for login shell being slow [[#5845]](https://github.com/aiidateam/aiida-core/pull/5845)"
msgstr ""

#: ../../../CHANGELOG.md:624
msgid "CLI: `verdi process list`: Add `exit_message` as projectable attribute [[#5853]](https://github.com/aiidateam/aiida-core/pull/5853)"
msgstr ""

#: ../../../CHANGELOG.md:625
msgid "CLI: `verdi node delete`: Add verbose list of pks to be deleted [[#5878]](https://github.com/aiidateam/aiida-core/pull/5878)"
msgstr ""

#: ../../../CHANGELOG.md:626
msgid "CLI: Fail command if `--config` file contains unknown key [[#5939]](https://github.com/aiidateam/aiida-core/pull/5939)"
msgstr ""

#: ../../../CHANGELOG.md:627
msgid "CLI: `verdi daemon status`: Do not except when no profiles are defined [[#5874]](https://github.com/aiidateam/aiida-core/pull/5874)"
msgstr ""

#: ../../../CHANGELOG.md:628
msgid "ORM: Add unary operations `+`, `-` and `abs` to `NumericType` [[#5946]](https://github.com/aiidateam/aiida-core/pull/5946)"
msgstr ""

#: ../../../CHANGELOG.md:629
msgid "Process functions: Support class member functions as process functions [[#4963]](https://github.com/aiidateam/aiida-core/pull/4963)"
msgstr ""

#: ../../../CHANGELOG.md:630
msgid "Process functions: Infer argument `valid_type` from type hints [[#5900]](https://github.com/aiidateam/aiida-core/pull/5900)"
msgstr ""

#: ../../../CHANGELOG.md:631
msgid "Process functions: Parse docstring to set input port help attribute [[#5919]](https://github.com/aiidateam/aiida-core/pull/5919)"
msgstr ""

#: ../../../CHANGELOG.md:632
msgid "Process functions: Add support for variadic arguments [[#5691]](https://github.com/aiidateam/aiida-core/pull/5691)"
msgstr ""

#: ../../../CHANGELOG.md:633
msgid "Process functions: Allow nested output namespaces [[#5954]](https://github.com/aiidateam/aiida-core/pull/5954)"
msgstr ""

#: ../../../CHANGELOG.md:634
msgid "`Process`: Store JSON-serializable metadata inputs on the node [[#5801]](https://github.com/aiidateam/aiida-core/pull/5801)"
msgstr ""

#: ../../../CHANGELOG.md:635
msgid "`Port`: Add the `is_metadata` keyword [[#5801]](https://github.com/aiidateam/aiida-core/pull/5801)"
msgstr ""

#: ../../../CHANGELOG.md:636
msgid "`ProcessBuilder`: Include metadata inputs in `get_builder_restart` [[#5801]](https://github.com/aiidateam/aiida-core/pull/5801)"
msgstr ""

#: ../../../CHANGELOG.md:637
msgid "`StructureData`: Add `mode` argument to `get_composition` [[#5926]](https://github.com/aiidateam/aiida-core/pull/5926)"
msgstr ""

#: ../../../CHANGELOG.md:638
msgid "`Scheduler`: Allow terminating job if submission script is invalid [[#5849]](https://github.com/aiidateam/aiida-core/pull/5849)"
msgstr ""

#: ../../../CHANGELOG.md:639
msgid "`SlurmScheduler`: Detect broken submission scripts for invalid account [[#5850]](https://github.com/aiidateam/aiida-core/pull/5850)"
msgstr ""

#: ../../../CHANGELOG.md:640
msgid "`SlurmScheduler`: Parse the `NODE_FAIL` state [[#5866]](https://github.com/aiidateam/aiida-core/pull/5866)"
msgstr ""

#: ../../../CHANGELOG.md:641
msgid "`WorkChain`: Add dataclass serialisation to context [[#5833]](https://github.com/aiidateam/aiida-core/pull/5833)"
msgstr ""

#: ../../../CHANGELOG.md:642
msgid "`IcsdDbImporter`: Add `is_theoretical` tag to queried entries [[#5868]](https://github.com/aiidateam/aiida-core/pull/5868)"
msgstr ""

#: ../../../CHANGELOG.md:645
msgid "CLI: Prefix the `verdi data` subcommands with `core.` [[#5846]](https://github.com/aiidateam/aiida-core/pull/5846)"
msgstr ""

#: ../../../CHANGELOG.md:646
msgid "CLI: Respect config log levels if `--verbosity` not explicitly passed [[#5925]](https://github.com/aiidateam/aiida-core/pull/5925)"
msgstr ""

#: ../../../CHANGELOG.md:647
msgid "CLI: `verdi config list`: Do not except if no profiles are defined [[#5921]](https://github.com/aiidateam/aiida-core/pull/5921)"
msgstr ""

#: ../../../CHANGELOG.md:648
msgid "CLI: `verdi code show`: Add missing code attributes [[#5916]](https://github.com/aiidateam/aiida-core/pull/5916)"
msgstr ""

#: ../../../CHANGELOG.md:649
msgid "CLI: `verdi quicksetup`: Fix error incorrect role when creating database [[#5828]](https://github.com/aiidateam/aiida-core/pull/5828)"
msgstr ""

#: ../../../CHANGELOG.md:650
msgid "CLI: Fix error in `aiida.cmdline.utils.log.CliFormatter` [[#5957]](https://github.com/aiidateam/aiida-core/pull/5957)"
msgstr ""

#: ../../../CHANGELOG.md:651
msgid "Daemon: Fix false-positive of stopped daemon in `verdi daemon status` [[#5862]](https://github.com/aiidateam/aiida-core/pull/5862)"
msgstr ""

#: ../../../CHANGELOG.md:652
msgid "`DaemonClient`: Fix and homogenize use of `timeout` in client calls [[#5960]](https://github.com/aiidateam/aiida-core/pull/5960)"
msgstr ""

#: ../../../CHANGELOG.md:653
msgid "`ProcessBuilder`: Fix bug in `_recursive_merge` [[#5801]](https://github.com/aiidateam/aiida-core/pull/5801)"
msgstr ""

#: ../../../CHANGELOG.md:654
msgid "`QueryBuilder`: Catch new exception raised by `sqlalchemy>=1.4.45` [[#5875]](https://github.com/aiidateam/aiida-core/pull/5875)"
msgstr ""

#: ../../../CHANGELOG.md:655
msgid "Fix the `%verdi` IPython magics utility [[#5961]](https://github.com/aiidateam/aiida-core/pull/5961)"
msgstr ""

#: ../../../CHANGELOG.md:656
msgid "Fix bug in `aiida.engine.utils.instantiate_process` [[#5952]](https://github.com/aiidateam/aiida-core/pull/5952)"
msgstr ""

#: ../../../CHANGELOG.md:657
msgid "Fix incorrect import of exception from `kiwipy.communications` [[#5947]](https://github.com/aiidateam/aiida-core/pull/5947)"
msgstr ""

#: ../../../CHANGELOG.md:660
msgid "`Scheduler`: Move setting of environment variables into base class [[#5948]](https://github.com/aiidateam/aiida-core/pull/5948)"
msgstr ""

#: ../../../CHANGELOG.md:661
msgid "`WorkChains`: Emit deprecation warning if predicate `if_/while_` does not return boolean-like [[#5924]](https://github.com/aiidateam/aiida-core/pull/5924)"
msgstr ""

#: ../../../CHANGELOG.md:664
msgid "`DaemonClient`: Refactor to include parsing of client response [[#5850]](https://github.com/aiidateam/aiida-core/pull/5850)"
msgstr ""

#: ../../../CHANGELOG.md:665
msgid "ORM: Remove `Entity.from_backend_entity` from the public API [[#5447]](https://github.com/aiidateam/aiida-core/pull/5447)"
msgstr ""

#: ../../../CHANGELOG.md:666
msgid "`PbsproScheduler`: Replace deprecated `ppn` tag with `ncpus` [[#5910]](https://github.com/aiidateam/aiida-core/pull/5910)"
msgstr ""

#: ../../../CHANGELOG.md:667
msgid "`ProcessBuilder`: Move `_prune` method to standalone utility [[#5801]](https://github.com/aiidateam/aiida-core/pull/5801)"
msgstr ""

#: ../../../CHANGELOG.md:668
msgid "`verdi process list`: Simplify the daemon load implementation [[#5850]](https://github.com/aiidateam/aiida-core/pull/5850)"
msgstr ""

#: ../../../CHANGELOG.md:671
msgid "Add FAQ on MFA-enabled computers [[#5887]](https://github.com/aiidateam/aiida-core/pull/5887)"
msgstr ""

#: ../../../CHANGELOG.md:672
msgid "Add link to all `metadata.options` inputs in `CalcJob` submission example [[#5912]](https://github.com/aiidateam/aiida-core/pull/5912)"
msgstr ""

#: ../../../CHANGELOG.md:673
msgid "Add warning that `Data` constructor is not called on loading [[#5898]](https://github.com/aiidateam/aiida-core/pull/5898)"
msgstr ""

#: ../../../CHANGELOG.md:674
msgid "Add note on how to create a code that uses Conda environment [[#5905]](https://github.com/aiidateam/aiida-core/pull/5905)"
msgstr ""

#: ../../../CHANGELOG.md:675
msgid "Add `--without-daemon` flag to benchmark script [[#5839]](https://github.com/aiidateam/aiida-core/pull/5839)"
msgstr ""

#: ../../../CHANGELOG.md:676
msgid "Add alternative for conda env activation in submission script [[#5950]](https://github.com/aiidateam/aiida-core/pull/5950)"
msgstr ""

#: ../../../CHANGELOG.md:677
msgid "Clarify that process functions can be exposed in work chains [[#5919]](https://github.com/aiidateam/aiida-core/pull/5919)"
msgstr ""

#: ../../../CHANGELOG.md:678
msgid "Fix the `intro/tutorial.md` notebook [[#5961]](https://github.com/aiidateam/aiida-core/pull/5961)"
msgstr ""

#: ../../../CHANGELOG.md:679
msgid "Fix the overindentation of lists [[#5915]](https://github.com/aiidateam/aiida-core/pull/5915)"
msgstr ""

#: ../../../CHANGELOG.md:680
msgid "Hide the \"Edit this page\" button on the API reference pages [[#5956]](https://github.com/aiidateam/aiida-core/pull/5956)"
msgstr ""

#: ../../../CHANGELOG.md:681
msgid "Note that an entry point is required for using a data plugin [[#5907]](https://github.com/aiidateam/aiida-core/pull/5907)"
msgstr ""

#: ../../../CHANGELOG.md:682
msgid "Set `use_login_shell=False` for `localhost` in performance benchmark [[#5847]](https://github.com/aiidateam/aiida-core/pull/5847)"
msgstr ""

#: ../../../CHANGELOG.md:683
msgid "Small improvements to the benchmark script [[#5854]](https://github.com/aiidateam/aiida-core/pull/5854)"
msgstr ""

#: ../../../CHANGELOG.md:684
msgid "Use mamba instead of conda [[#5891]](https://github.com/aiidateam/aiida-core/pull/5891)"
msgstr ""

#: ../../../CHANGELOG.md:686
#: ../../../CHANGELOG.md:808
msgid "DevOps"
msgstr ""

#: ../../../CHANGELOG.md:687
msgid "Add devcontainer for easy integration with VSCode [[#5913]](https://github.com/aiidateam/aiida-core/pull/5913)"
msgstr ""

#: ../../../CHANGELOG.md:688
msgid "CI: Update `sphinx-intl` and install transifex CLI [[#5908]](https://github.com/aiidateam/aiida-core/pull/5908)"
msgstr ""

#: ../../../CHANGELOG.md:689
msgid "Fix the `test-install` workflow [[#5873]](https://github.com/aiidateam/aiida-core/pull/5873)"
msgstr ""

#: ../../../CHANGELOG.md:690
msgid "Pre-commit: Improve typing of `aiida.schedulers.scheduler` [[#5849]](https://github.com/aiidateam/aiida-core/pull/5849)"
msgstr ""

#: ../../../CHANGELOG.md:691
msgid "Pre-commit: Set `yapf` option `allow_split_before_dict_value = false`[[#5931]](https://github.com/aiidateam/aiida-core/pull/5931)"
msgstr ""

#: ../../../CHANGELOG.md:692
msgid "Process functions: Replace `getfullargspec` with `signature` [[#5900]](https://github.com/aiidateam/aiida-core/pull/5900)"
msgstr ""

#: ../../../CHANGELOG.md:693
msgid "Fixtures: Add argument `use_subprocess` to `run_cli_command` [[#5846]](https://github.com/aiidateam/aiida-core/pull/5846)"
msgstr ""

#: ../../../CHANGELOG.md:694
msgid "Fixtures: Change default `use_subprocess=False` for `run_cli_command` [[#5846]](https://github.com/aiidateam/aiida-core/pull/5846)"
msgstr ""

#: ../../../CHANGELOG.md:695
msgid "Tests: Use `use_subprocess=False` and `suppress_warnings=True` [[#5846]](https://github.com/aiidateam/aiida-core/pull/5846)"
msgstr ""

#: ../../../CHANGELOG.md:696
msgid "Tests: Fix bugs revealed by running with `use_subprocess=True` [[#5846]](https://github.com/aiidateam/aiida-core/pull/5846)"
msgstr ""

#: ../../../CHANGELOG.md:697
msgid "Typing: Annotate `aiida/orm/utils/serialize.py` [[#5832]](https://github.com/aiidateam/aiida-core/pull/5832)"
msgstr ""

#: ../../../CHANGELOG.md:698
msgid "Typing: Annotate `aiida/tools/visualization/graph.py` [[#5821]](https://github.com/aiidateam/aiida-core/pull/5821)"
msgstr ""

#: ../../../CHANGELOG.md:699
msgid "Typing: Use modern syntax for `aiida.engine.processes.functions` [[#5900]](https://github.com/aiidateam/aiida-core/pull/5900)"
msgstr ""

#: ../../../CHANGELOG.md:702
msgid "Add compatibility for `ipython~=8.0` [[#5888]](https://github.com/aiidateam/aiida-core/pull/5888)"
msgstr ""

#: ../../../CHANGELOG.md:703
msgid "Bump cryptography from 36.0.0 to 39.0.1 [[#5885]](https://github.com/aiidateam/aiida-core/pull/5885)"
msgstr ""

#: ../../../CHANGELOG.md:704
msgid "Remove upper limit on `werkzeug` [[#5904]](https://github.com/aiidateam/aiida-core/pull/5904)"
msgstr ""

#: ../../../CHANGELOG.md:705
msgid "Update pre-commit requirement `isort==5.12.0` [[#5877]](https://github.com/aiidateam/aiida-core/pull/5877)"
msgstr ""

#: ../../../CHANGELOG.md:706
msgid "Update requirement `importlib-metadata~=4.13` [[#5963]](https://github.com/aiidateam/aiida-core/pull/5963)"
msgstr ""

#: ../../../CHANGELOG.md:707
msgid "Bump `graphviz` version to `0.19` [[#5965]](https://github.com/aiidateam/aiida-core/pull/5965)"
msgstr ""

#: ../../../CHANGELOG.md:709
msgid "New contributors"
msgstr ""

#: ../../../CHANGELOG.md:710
msgid "Thanks a lot to the following new contributors:"
msgstr ""

#: ../../../CHANGELOG.md:712
msgid "[Ahmed Basem](https://github.com/AhmedBasem20)"
msgstr ""

#: ../../../CHANGELOG.md:713
msgid "[Mahhheshh](https://github.com/Mahhheshh)"
msgstr ""

#: ../../../CHANGELOG.md:714
msgid "[Kyle Wang](https://github.com/TurboKyle)"
msgstr ""

#: ../../../CHANGELOG.md:715
msgid "[Kartikey Saran](https://github.com/kartikeysaran)"
msgstr ""

#: ../../../CHANGELOG.md:716
msgid "[zahid47](https://github.com/zahid47)"
msgstr ""

#: ../../../CHANGELOG.md:718
msgid "v2.2.2 - 2023-02-10"
msgstr ""

#: ../../../CHANGELOG.md:721
msgid "Critical bug fix: Fix bug causing `CalcJob`s to except after restarting daemon [[#5886]](https://github.com/aiidateam/aiida-core/pull/5886)"
msgstr ""

#: ../../../CHANGELOG.md:724
msgid "v2.2.1 - 2022-12-22"
msgstr ""

#: ../../../CHANGELOG.md:727
msgid "Critical bug fix: Revert the changes of PR [[#5804]](https://github.com/aiidateam/aiida-core/pull/5804) released with v2.2.0, which addressed a bug when mutating nodes during `QueryBuilder.iterall`. Unfortunately, the change caused changes performed by `verdi` commands (as well as changes made in `verdi shell`) to not be persisted to the database. [[#5851]](https://github.com/aiidateam/aiida-core/pull/5851)"
msgstr ""

#: ../../../CHANGELOG.md:730
msgid "v2.2.0 - 2022-12-13"
msgstr ""

#: ../../../CHANGELOG.md:732
msgid "This feature release comes with a significant feature and a number of improvements and fixes."
msgstr ""

#: ../../../CHANGELOG.md:734
msgid "Live calculation job monitoring"
msgstr ""

#: ../../../CHANGELOG.md:736
msgid "In certain use cases, it is useful to have a calculation job stopped prematurely, before it finished or the requested wallclock time runs out. Examples are calculations that seem to be going nowhere and so continuing would only waste computational resources. Up till now, a calculation job could only be \"manually\" stopped, through `verdi process kill`. In this release, functionality is added that allows calculation jobs to be monitored automatically by the daemon and have them stopped when certain conditions are met."
msgstr ""

#: ../../../CHANGELOG.md:741
msgid "Monitors can be attached to a calculation job through the `monitors` input namespace:"
msgstr ""

#: ../../../CHANGELOG.md:749
msgid "Monitors are referenced by their entry points with which they are registered in the `aiida.calculations.monitors` entry point group. A monitor is essentially a function that implements the following interface:"
msgstr ""

#: ../../../CHANGELOG.md:763
msgid "The `transport` allows to fetch files from the working directory of the calculation. If the job should be killed, the monitor simply returns a string with the message why and the daemon will send the message to kill the job."
msgstr ""

#: ../../../CHANGELOG.md:766
msgid "For more information and a complete description of the interface, please refer to the [documentation](https://aiida.readthedocs.io/projects/aiida-core/en/v2.1.0/howto/run_codes.html#how-to-monitor-and-prematurely-stop-a-calculation). This functionality was accepted based on [AEP 008](https://github.com/aiidateam/AEP/pull/36) which provides more detail on the design choices behind this implementation."
msgstr ""

#: ../../../CHANGELOG.md:773
msgid "`CalcJob`: Add functionality that allows live monitoring [[#5659]](https://github.com/aiidateam/aiida-core/pull/5659)"
msgstr ""

#: ../../../CHANGELOG.md:774
msgid "CLI: Add `--raw` option to `verdi code list` [[#5763]](https://github.com/aiidateam/aiida-core/pull/5763)"
msgstr ""

#: ../../../CHANGELOG.md:775
msgid "CLI: Add the `-h` short-hand flag for `--help` to `verdi` [[#5792]](https://github.com/aiidateam/aiida-core/pull/5792)"
msgstr ""

#: ../../../CHANGELOG.md:776
msgid "CLI: Add short option names for `verdi code create` [[#5799]](https://github.com/aiidateam/aiida-core/pull/5799)"
msgstr ""

#: ../../../CHANGELOG.md:777
msgid "`StorageBackend`: Add the `initialise` method [[#5760]](https://github.com/aiidateam/aiida-core/pull/5760)"
msgstr ""

#: ../../../CHANGELOG.md:778
msgid "Fixtures: Add support for `Process` inputs to `submit_and_await` [[#5780]](https://github.com/aiidateam/aiida-core/pull/5780)"
msgstr ""

#: ../../../CHANGELOG.md:779
msgid "Fixtures: Add `aiida_computer_local` and `aiida_computer_ssh` [[#5786]](https://github.com/aiidateam/aiida-core/pull/5786)"
msgstr ""

#: ../../../CHANGELOG.md:780
msgid "Fixtures: Modularize fixtures creating AiiDA test instance and profile [[#5758]](https://github.com/aiidateam/aiida-core/pull/5758)"
msgstr ""

#: ../../../CHANGELOG.md:781
msgid "`Computer`: Add the `is_configured` property [[#5786]](https://github.com/aiidateam/aiida-core/pull/5786)"
msgstr ""

#: ../../../CHANGELOG.md:782
msgid "Plugins: Add `aiida.storage` to `ENTRY_POINT_GROUP_FACTORY_MAPPING` [[#5798]](https://github.com/aiidateam/aiida-core/pull/5798)"
msgstr ""

#: ../../../CHANGELOG.md:785
msgid "`verdi run`: Do not add `pathlib.Path` instance to `sys.path` [[#5810]](https://github.com/aiidateam/aiida-core/pull/5810)"
msgstr ""

#: ../../../CHANGELOG.md:786
msgid "Process functions: Restore support for dynamic nested input namespaces [[#5808]](https://github.com/aiidateam/aiida-core/pull/5808)"
msgstr ""

#: ../../../CHANGELOG.md:787
msgid "`Process`: properly cleanup when exception in state transition [[#5697]](https://github.com/aiidateam/aiida-core/pull/5697)"
msgstr ""

#: ../../../CHANGELOG.md:788
msgid "`Process`: Update outputs before updating node process state [[#5813]](https://github.com/aiidateam/aiida-core/pull/5813)"
msgstr ""

#: ../../../CHANGELOG.md:789
msgid "`PsqlDosMigrator`: refactor the connection handling [[#5783]](https://github.com/aiidateam/aiida-core/pull/5783)"
msgstr ""

#: ../../../CHANGELOG.md:790
msgid "`PsqlDosBackend`: Use transaction whenever mutating session state, fixing exception when storing a node or group during `QueryBuilder.iterall` [[#5804]](https://github.com/aiidateam/aiida-core/pull/5804)"
msgstr ""

#: ../../../CHANGELOG.md:791
msgid "`InstalledCode`: Fix bug in `validate_filepath_executable` for SSH [[#5787]](https://github.com/aiidateam/aiida-core/pull/5787)"
msgstr ""

#: ../../../CHANGELOG.md:792
msgid "`WorkChain`: Protect public methods from being subclassed. Now if you accidentally override, for example, the `run` method of the `WorkChain`, an exception is raised instead of silently breaking the work chain [[#5779]](https://github.com/aiidateam/aiida-core/pull/5779)"
msgstr ""

#: ../../../CHANGELOG.md:795
msgid "Rename `PsqlDostoreMigrator` to `PsqlDosMigrator` [[#5761]](https://github.com/aiidateam/aiida-core/pull/5761)"
msgstr ""

#: ../../../CHANGELOG.md:796
msgid "ORM: Remove `pymatgen` version check in `StructureData.set_pymatgen_structure` [[#5777]](https://github.com/aiidateam/aiida-core/pull/5777)"
msgstr ""

#: ../../../CHANGELOG.md:797
msgid "`StorageBackend`: Remove `recreate_user` from `_clear` [[#5772]](https://github.com/aiidateam/aiida-core/pull/5772)"
msgstr ""

#: ../../../CHANGELOG.md:798
msgid "`PsqlDosMigrator`: Remove hardcoding of table name in database reset [[#5781]](https://github.com/aiidateam/aiida-core/pull/5781)"
msgstr ""

#: ../../../CHANGELOG.md:801
msgid "Dependencies: Add support for Python 3.11 [[#5778]](https://github.com/aiidateam/aiida-core/pull/5778)"
msgstr ""

#: ../../../CHANGELOG.md:804
msgid "Docs: Correct command to enable `verdi` tab-completion for `fish` shell  [[#5784]](https://github.com/aiidateam/aiida-core/pull/5784)"
msgstr ""

#: ../../../CHANGELOG.md:805
msgid "Docs: Fix transport & scheduler type in localhost setup [[#5785]](https://github.com/aiidateam/aiida-core/pull/5785)"
msgstr ""

#: ../../../CHANGELOG.md:806
msgid "Docs: Fix minor formatting issues in \"How to run a code\" [[#5794]](https://github.com/aiidateam/aiida-core/pull/5794)"
msgstr ""

#: ../../../CHANGELOG.md:809
msgid "CI: Increase load limit for `verdi` to 0.5 seconds [[#5773]](https://github.com/aiidateam/aiida-core/pull/5773)"
msgstr ""

#: ../../../CHANGELOG.md:810
msgid "CI: Add `workflow_dispatch` trigger to `nightly.yml` [[#5760]](https://github.com/aiidateam/aiida-core/pull/5760)"
msgstr ""

#: ../../../CHANGELOG.md:811
msgid "ORM: Fix typing of `aiida.orm.nodes.data.code` module [[#5830]](https://github.com/aiidateam/aiida-core/pull/5830)"
msgstr ""

#: ../../../CHANGELOG.md:812
msgid "Pin version of `setuptools` as it breaks dependencies [[#5782]](https://github.com/aiidateam/aiida-core/pull/5782)"
msgstr ""

#: ../../../CHANGELOG.md:813
msgid "Tests: Use explicit `aiida_profile_clean` in process control tests [[#5778]](https://github.com/aiidateam/aiida-core/pull/5778)"
msgstr ""

#: ../../../CHANGELOG.md:814
msgid "Tests: Replace all use of `aiida_profile_clean` with `aiida_profile` where a clean profile is not necessary [[#5814]](https://github.com/aiidateam/aiida-core/pull/5814)"
msgstr ""

#: ../../../CHANGELOG.md:815
msgid "Tests: Deal with `run_via_daemon` returning `None` in RPN tests [[#5813]](https://github.com/aiidateam/aiida-core/pull/5813)"
msgstr ""

#: ../../../CHANGELOG.md:816
msgid "Make type-checking opt-out [[#5811]](https://github.com/aiidateam/aiida-core/pull/5811)"
msgstr ""

#: ../../../CHANGELOG.md:819
msgid "v2.1.2 - 2022-11-14"
msgstr ""

#: ../../../CHANGELOG.md:823
msgid "`BaseRestartWorkChain`: Fix bug in `_wrap_bare_dict_inputs` introduced in `v2.1.0` [[#5757]](https://github.com/aiidateam/aiida-core/pull/5757)"
msgstr ""

#: ../../../CHANGELOG.md:826
msgid "v2.1.1 - 2022-11-10"
msgstr ""

#: ../../../CHANGELOG.md:830
msgid "Engine: Remove `*args` from the `Process.submit` method. [[#5753]](https://github.com/aiidateam/aiida-core/pull/5753) Positional arguments were silently ignored leading to a misleading error message. For example, if a user called"
msgstr ""

#: ../../../CHANGELOG.md:837
msgid "instead of the intended"
msgstr ""

#: ../../../CHANGELOG.md:842
msgid "The returned error message was that one of the required inputs was not defined. Now it will correctly raise a `TypeError` saying that positional arguments are not supported."
msgstr ""

#: ../../../CHANGELOG.md:844
msgid "Process functions: Add serialization for Python base type defaults [[#5744]](https://github.com/aiidateam/aiida-core/pull/5744) Defining Python base types as defaults, such as:"
msgstr ""

#: ../../../CHANGELOG.md:851
msgid "would raise an exception. The default is now automatically serialized, just as an input argument would be upon function call."
msgstr ""

#: ../../../CHANGELOG.md:853
msgid "Process control: Reinstate process status for paused/killed processes [[#5754]](https://github.com/aiidateam/aiida-core/pull/5754) Regression introduced in `aiida-core==2.1.0` caused the message `Killed through 'verdi process list'` to no longer be set on the `process_status` of the node."
msgstr ""

#: ../../../CHANGELOG.md:855
msgid "`QueryBuilder`: use a nested session in `iterall` and `iterdict` [[#5736]](https://github.com/aiidateam/aiida-core/pull/5736) Modifying entities yielded by `QueryBuilder.iterall` and `QueryBuilder.iterdict` would raise an exception, for example:"
msgstr ""

#: ../../../CHANGELOG.md:863
msgid "v2.1.0 - 2022-11-07"
msgstr ""

#: ../../../CHANGELOG.md:865
msgid "This feature release comes with a number of new features as well as quite a few fixes of bugs and stability issues. Further down you will find a complete list of changes, after a short description of some of the most important changes:"
msgstr ""

#: ../../../CHANGELOG.md:868
msgid "[Automatic input serialization in calculation and work functions](#automatic-input-serialization-in-calculation-and-work-functions)"
msgstr ""

#: ../../../CHANGELOG.md:869
msgid "[Improved interface for creating codes](#improved-interface-for-creating-codes)"
msgstr ""

#: ../../../CHANGELOG.md:870
msgid "[Support for running code in containers](#support-for-running-code-in-containers)"
msgstr ""

#: ../../../CHANGELOG.md:871
msgid "[Control daemon and processes from the API](#control-daemon-and-processes-from-the-api)"
msgstr ""

#: ../../../CHANGELOG.md:872
msgid "[REST API can serve multiple profiles](#rest-api-can-serve-multiple-profiles)"
msgstr ""

#: ../../../CHANGELOG.md:873
msgid "[Pluginable data storage backends](#pluginable-data-storage-backends)"
msgstr ""

#: ../../../CHANGELOG.md:876
msgid "Automatic input serialization in calculation and work functions"
msgstr ""

#: ../../../CHANGELOG.md:878
msgid "The inputs to `calcfunction`s and `workfunction`s are now automatically converted to AiiDA data types if they are one of the basic Python types (`bool`, `dict`, `Enum`, `float`, `int`, `list` or `str`). This means that code that looked like:"
msgstr ""

#: ../../../CHANGELOG.md:892
msgid "can now be simplified to:"
msgstr ""

#: ../../../CHANGELOG.md:905
msgid "Improved interface for creating codes"
msgstr ""

#: ../../../CHANGELOG.md:907
msgid "The `Code` data plugin was a single class that served two different types of codes: \"remote\" codes and \"local\" codes. These names \"remote\" and \"local\" have historically caused a lot of confusion. Likewise, using a single class `Code` for both implementations also has led to confusing interfaces."
msgstr ""

#: ../../../CHANGELOG.md:911
msgid "To address this issue, the functionality has been split into two new classes [`InstalledCode`](https://aiida.readthedocs.io/projects/aiida-core/en/v2.1.0/topics/data_types.html#installedcode) and [`PortableCode`](https://aiida.readthedocs.io/projects/aiida-core/en/v2.1.0/topics/data_types.html#portablecode), that replace the \"remote\" and \"local\" code, respectively. The installed code represents an executable binary that is already pre-installed on some compute resource. The portable code represents a code (executable plus any additional required files) that are stored in AiiDA's storage and can be automatically transfered to any computer before being executed."
msgstr ""

#: ../../../CHANGELOG.md:915
msgid "Creating a new instance of these new code types is easy:"
msgstr ""

#: ../../../CHANGELOG.md:933
msgid "Codes can also be created through the new `verdi` command `verdi code create`. To specify the type of code to create, pass the corresponding entry point name as an argument. For example, to create a new installed code, invoke:"
msgstr ""

#: ../../../CHANGELOG.md:939
msgid "The options for each subcommand are automatically generated based on the code type, and so only options that are relevant to that code type will be prompted for."
msgstr ""

#: ../../../CHANGELOG.md:941
msgid "The new code classes both subclass the `aiida.orm.nodes.data.code.abstract.AbstractCode` base class. This means that both `InstalledCode`s and `PortableCode`s can be used as the `code` input for `CalcJob`s without problems."
msgstr ""

#: ../../../CHANGELOG.md:944
msgid "The old `Code` class remains supported for the time being as well, however, it is deprecated and will be remove at some point. The same goes for the `verdi code setup` command; please use `verdi code create` instead. Existing codes will be automatically migrated to either an `InstalledCode` or a `PortableCode`. It is strongly advised that you update any code that creates new codes to use these new plugin types."
msgstr ""

#: ../../../CHANGELOG.md:949
msgid "Support for running code in containers"
msgstr ""

#: ../../../CHANGELOG.md:951
msgid "Support is added to run calculation jobs inside a container. A containerized code can be setup through the CLI:"
msgstr ""

#: ../../../CHANGELOG.md:960
msgid "as well as through the API:"
msgstr ""

#: ../../../CHANGELOG.md:970
msgid "In the example above we use the [Singularity](https://singularity-docs.readthedocs.io/en/latest/) containerization technology. For more information on what containerization programs are supported and how to configure them, please refer to the [documentation](https://aiida.readthedocs.io/projects/aiida-core/en/v2.1.0/topics/data_types.html#containerizedcode)."
msgstr ""

#: ../../../CHANGELOG.md:973
msgid "Control daemon and processes from the API"
msgstr ""

#: ../../../CHANGELOG.md:975
msgid "Up till now, the daemon and live processes could only easily be controlled through `verdi daemon` and `verdi process`, respectively. In this release, modules are added to provide the same functionality through the Python API."
msgstr ""

#: ../../../CHANGELOG.md:978
msgid "Daemon API"
msgstr ""

#: ../../../CHANGELOG.md:980
msgid "The daemon can now be started and stopped through the `DaemonClient` which can be obtained through the `get_daemon_client` utility function:"
msgstr ""

#: ../../../CHANGELOG.md:985
msgid "By default, this will give the daemon client for the current default profile. It is also possible to explicitly specify a profile:"
msgstr ""

#: ../../../CHANGELOG.md:990
msgid "The daemon can be started and stopped through the client:"
msgstr ""

#: ../../../CHANGELOG.md:997
msgid "Process API"
msgstr ""

#: ../../../CHANGELOG.md:999
msgid "The functionality of `verdi process` to `play`, `pause` and `kill` is now made available through the `aiida.engine.process.control` module. Processes can be played, paused or killed through the `play_processes`, `pause_processes`, and `kill_processes`, respectively. The processes to act upon are defined through their `ProcessNode` which can be loaded using `load_node`."
msgstr ""

#: ../../../CHANGELOG.md:1011
msgid "Instead of specifying an explicit list of processes, the functions also take the `all_entries` keyword argument:"
msgstr ""

#: ../../../CHANGELOG.md:1016
msgid "REST API can serve multiple profiles"
msgstr ""

#: ../../../CHANGELOG.md:1018
msgid "Before, a single REST API could only serve data of a single profile at a time. This limitation has been removed and a single REST API instance can now serve data from all profiles of an AiiDA instance. To maintain backwards compatibility, the new functionality needs to be explicitly enabled through the configuration:"
msgstr ""

#: ../../../CHANGELOG.md:1024
msgid "After the REST API is restarted, it will now accept the `profile` query parameter, for example:"
msgstr ""

#: ../../../CHANGELOG.md:1028
msgid "If the specified is already loaded, the REST API functions exactly as without profile switching enabled. If another profile is specified, the REST API will first switch profiles before executing the request."
msgstr ""

#: ../../../CHANGELOG.md:1031
msgid "If the profile parameter is specified in a request and the REST API does not have profile switching enabled, a 400 response is returned."
msgstr ""

#: ../../../CHANGELOG.md:1033
msgid "Pluginable data storage backends"
msgstr ""

#: ../../../CHANGELOG.md:1035
msgid "Warning: this is beta functionality. It is now possible to implement custom storage backends to control where all data of an AiiDA profile is stored. To provide a data storage plugin, one should implement the `aiida.orm.implementation.storage_backend.StorageBackend` interface. The default implementation provided by `aiida-core` is the `aiida.storage.psql_dos.backend.PsqlDosBackend` which uses a PostgreSQL database for the provenance graph and a [`disk-objectstore`](https://pypi.org/project/disk-objectstore/) container for repository files."
msgstr ""

#: ../../../CHANGELOG.md:1040
msgid "Storage backend plugins should be registered in the new entry point group `aiida.storage`. The default storage backend `PsqlDosBackend` has the `core.psql_dos` entry point name."
msgstr ""

#: ../../../CHANGELOG.md:1043
msgid "The storage backend to be used for a profile can be specified using the `--db-backend` option in `verdi setup` and `verdi quicksetup`. The entry point of the selected backend is stored in the `storage.backend` key of a profile configuration:"
msgstr ""

#: ../../../CHANGELOG.md:1062
msgid "At the moment, it is not quite clear if the abstract interface `StorageBackend` properly abstracts everything that is needed to implement any storage backend. For the time being then, it is advised to subclass the `PsqlDosBackend` and replace parts required for the use-case, such as just replacing the file repository implementation."
msgstr ""

#: ../../../CHANGELOG.md:1069
msgid "`Process`: Add hook to customize the `process_label` attribute [[#5713]](https://github.com/aiidateam/aiida-core/pull/5713)"
msgstr ""

#: ../../../CHANGELOG.md:1070
msgid "Add the `ContainerizedCode` data plugin [[#5667]](https://github.com/aiidateam/aiida-core/pull/5667)"
msgstr ""

#: ../../../CHANGELOG.md:1071
msgid "API: Add the `aiida.engine.processes.control` module [[#5630]](https://github.com/aiidateam/aiida-core/pull/5630)"
msgstr ""

#: ../../../CHANGELOG.md:1072
msgid "`PluginVersionProvider`: Add support for entry point strings [[#5662]](https://github.com/aiidateam/aiida-core/pull/5662)"
msgstr ""

#: ../../../CHANGELOG.md:1073
msgid "`verdi setup`: Add the `--profile-uuid` option [[#5673]](https://github.com/aiidateam/aiida-core/pull/5673)"
msgstr ""

#: ../../../CHANGELOG.md:1074
msgid "Process control: Add the `revive_processes` method [[#5677]](https://github.com/aiidateam/aiida-core/pull/5677)"
msgstr ""

#: ../../../CHANGELOG.md:1075
msgid "Process functions: Add the `get_source_code_function` method [[#4554]](https://github.com/aiidateam/aiida-core/pull/4554)"
msgstr ""

#: ../../../CHANGELOG.md:1076
msgid "CLI: Improve the quality of `verdi code list` output [[#5750]](https://github.com/aiidateam/aiida-core/pull/5750)"
msgstr ""

#: ../../../CHANGELOG.md:1077
msgid "CLI: Add the `verdi devel revive` command [[#5677]](https://github.com/aiidateam/aiida-core/pull/5677)"
msgstr ""

#: ../../../CHANGELOG.md:1078
msgid "CLI: `verdi process status --max-depth` [[#5727]](https://github.com/aiidateam/aiida-core/pull/5727)"
msgstr ""

#: ../../../CHANGELOG.md:1079
msgid "CLI: `verdi setup/quicksetup` store autofill user info early [[#5729]](https://github.com/aiidateam/aiida-core/pull/5729)"
msgstr ""

#: ../../../CHANGELOG.md:1080
msgid "CLI: Add the `devel launch-add` command [[#5733]](https://github.com/aiidateam/aiida-core/pull/5733)"
msgstr ""

#: ../../../CHANGELOG.md:1081
msgid "CLI: Make filename in `verdi node repo cat` optional for `SinglefileData` [[#5747]](https://github.com/aiidateam/aiida-core/pull/5747)"
msgstr ""

#: ../../../CHANGELOG.md:1082
msgid "CLI: Add the `verdi devel rabbitmq` command group [[#5718]](https://github.com/aiidateam/aiida-core/pull/5718)"
msgstr ""

#: ../../../CHANGELOG.md:1083
msgid "API: Add function to start the daemon [[#5625]](https://github.com/aiidateam/aiida-core/pull/5625)"
msgstr ""

#: ../../../CHANGELOG.md:1084
msgid "`BaseRestartWorkChain`: add the `get_outputs` hook [[#5618]](https://github.com/aiidateam/aiida-core/pull/5618)"
msgstr ""

#: ../../../CHANGELOG.md:1085
msgid "`CalcJob`: extend `retrieve_list` syntax with `depth=None` [[#5651]](https://github.com/aiidateam/aiida-core/pull/5651)"
msgstr ""

#: ../../../CHANGELOG.md:1086
msgid "`CalcJob`: allow wildcards in `stash.source_list` paths [[#5601]](https://github.com/aiidateam/aiida-core/pull/5601)"
msgstr ""

#: ../../../CHANGELOG.md:1087
msgid "Add global config option `rest_api.profile_switching` [[#5054]](https://github.com/aiidateam/aiida-core/pull/5054)"
msgstr ""

#: ../../../CHANGELOG.md:1088
msgid "REST API: make the profile configurable as request parameter [[#5054]](https://github.com/aiidateam/aiida-core/pull/5054)"
msgstr ""

#: ../../../CHANGELOG.md:1089
msgid "`ProcessFunction`: Automatically serialize Python base type inputs [[#5688]](https://github.com/aiidateam/aiida-core/pull/5688)"
msgstr ""

#: ../../../CHANGELOG.md:1090
msgid "`BaseRestartWorkChain`: allow to override priority in `handler_overrides` [[#5546]](https://github.com/aiidateam/aiida-core/pull/5546)"
msgstr ""

#: ../../../CHANGELOG.md:1091
msgid "ORM: add `entry_point` classproperty to `Node` and `Group` [[#5437]](https://github.com/aiidateam/aiida-core/pull/5437)"
msgstr ""

#: ../../../CHANGELOG.md:1092
msgid "Add the `aiida.storage` entry point group [[#5501]](https://github.com/aiidateam/aiida-core/pull/5501)"
msgstr ""

#: ../../../CHANGELOG.md:1093
msgid "Add the config option `storage.sandbox` [[#5501]](https://github.com/aiidateam/aiida-core/pull/5501)"
msgstr ""

#: ../../../CHANGELOG.md:1094
msgid "Add the `InstalledCode` and `PortableCode` data plugins [[#5510]](https://github.com/aiidateam/aiida-core/pull/5510)"
msgstr ""

#: ../../../CHANGELOG.md:1095
msgid "CLI: Add the `verdi code create` command group [[#5510]](https://github.com/aiidateam/aiida-core/pull/5510)"
msgstr ""

#: ../../../CHANGELOG.md:1096
msgid "CLI: Add the `DynamicEntryPointCommandGroup` command group [[#5510]](https://github.com/aiidateam/aiida-core/pull/5510)"
msgstr ""

#: ../../../CHANGELOG.md:1097
msgid "Add a client to connect to RabbitMQ Manamegement HTTP API [[#5718]](https://github.com/aiidateam/aiida-core/pull/5718)"
msgstr ""

#: ../../../CHANGELOG.md:1098
msgid "`LsfScheduler`: add support for `num_machines` [[#5153]](https://github.com/aiidateam/aiida-core/pull/5153)"
msgstr ""

#: ../../../CHANGELOG.md:1099
msgid "`JobResource`: add the `accepts_default_memory_per_machine` [[#5642]](https://github.com/aiidateam/aiida-core/pull/5642)"
msgstr ""

#: ../../../CHANGELOG.md:1100
msgid "`AbstractCode`: add abstraction methods for command line parameters [[#5664]](https://github.com/aiidateam/aiida-core/pull/5664)"
msgstr ""

#: ../../../CHANGELOG.md:1101
msgid "`ArithmeticAddCalculation`: Add the `metadata.options.sleep` input [[#5663]](https://github.com/aiidateam/aiida-core/pull/5663)"
msgstr ""

#: ../../../CHANGELOG.md:1102
msgid "`DaemonClient`: add the `get_env` method [[#5631]](https://github.com/aiidateam/aiida-core/pull/5631)"
msgstr ""

#: ../../../CHANGELOG.md:1103
msgid "Tests: Make daemon fixtures available to plugin packages [[#5701]](https://github.com/aiidateam/aiida-core/pull/5701)"
msgstr ""

#: ../../../CHANGELOG.md:1104
msgid "`verdi plugin list`: Show which exit codes invalidate cache [[#5710]](https://github.com/aiidateam/aiida-core/pull/5710)"
msgstr ""

#: ../../../CHANGELOG.md:1105
msgid "`verdi plugin list`: Show full help for input and output ports  [[#5711]](https://github.com/aiidateam/aiida-core/pull/5711)"
msgstr ""

#: ../../../CHANGELOG.md:1108
msgid "`ArrayData`: replace `nan` and `inf` with `None` when dumping to JSON [[#5613]](https://github.com/aiidateam/aiida-core/pull/5613)"
msgstr ""

#: ../../../CHANGELOG.md:1109
msgid "Archive: add missing migration of transport entry points [[#5604]](https://github.com/aiidateam/aiida-core/pull/5604)"
msgstr ""

#: ../../../CHANGELOG.md:1110
msgid "`BaseRestartWorkChain`: fix `handler_overrides` ignoring `enabled=False` [[#5598]](https://github.com/aiidateam/aiida-core/pull/5598)"
msgstr ""

#: ../../../CHANGELOG.md:1111
msgid "CLI: allow setting options for config without profiles [[#5544]](https://github.com/aiidateam/aiida-core/pull/5544)"
msgstr ""

#: ../../../CHANGELOG.md:1112
msgid "CLI: normalize use of colors [[#5547]](https://github.com/aiidateam/aiida-core/pull/5547)"
msgstr ""

#: ../../../CHANGELOG.md:1113
msgid "`Config`: fix bug in downgrade past version 6 [[#5528]](https://github.com/aiidateam/aiida-core/pull/5528)"
msgstr ""

#: ../../../CHANGELOG.md:1114
msgid "`DaemonClient`: close `CircusClient` after call [[#5631]](https://github.com/aiidateam/aiida-core/pull/5631)"
msgstr ""

#: ../../../CHANGELOG.md:1115
msgid "Engine: Do not call serializer for `None` values [[#5694]](https://github.com/aiidateam/aiida-core/pull/5694)"
msgstr ""

#: ../../../CHANGELOG.md:1116
msgid "Engine: Do not let `DuplicateSubcriberError` except a `Process` [[#5715]](https://github.com/aiidateam/aiida-core/pull/5715)"
msgstr ""

#: ../../../CHANGELOG.md:1117
msgid "ORM: raise when trying to pickle instance of `Entity` [[#5549]](https://github.com/aiidateam/aiida-core/pull/5549)"
msgstr ""

#: ../../../CHANGELOG.md:1118
msgid "ORM: Return `None` in `get_function_source_code` instead of excepting [[#5730]](https://github.com/aiidateam/aiida-core/pull/5730)"
msgstr ""

#: ../../../CHANGELOG.md:1119
msgid "Fix `get_entry_point` not raising even for duplicate entry points [[#5531]](https://github.com/aiidateam/aiida-core/pull/5531)"
msgstr ""

#: ../../../CHANGELOG.md:1120
msgid "Fix: reference to command in message for `verdi storage maintain` [[#5558]](https://github.com/aiidateam/aiida-core/pull/5558)"
msgstr ""

#: ../../../CHANGELOG.md:1121
msgid "Fix: `is_valid_cache` setter for `ProcessNode`s [[#5583]](https://github.com/aiidateam/aiida-core/pull/5583)"
msgstr ""

#: ../../../CHANGELOG.md:1122
msgid "Fix exception when importing an archive into a profile with many nodes [[#5740]](https://github.com/aiidateam/aiida-core/pull/5740)"
msgstr ""

#: ../../../CHANGELOG.md:1123
msgid "`Profile`: make definition of daemon filepaths dynamic [[#5631]](https://github.com/aiidateam/aiida-core/pull/5631)"
msgstr ""

#: ../../../CHANGELOG.md:1124
msgid "Fixtures: Fix bug in reset of `empty_config` fixture [[#5717]](https://github.com/aiidateam/aiida-core/pull/5717)"
msgstr ""

#: ../../../CHANGELOG.md:1125
msgid "`PsqlDosBackend`: ensure sqla sessions are garbage-collected on `close` [[#5728]](https://github.com/aiidateam/aiida-core/pull/5728)"
msgstr ""

#: ../../../CHANGELOG.md:1126
msgid "`TrajectoryData`: Fix bug in `get_step_data` [[#5734]](https://github.com/aiidateam/aiida-core/pull/5734)"
msgstr ""

#: ../../../CHANGELOG.md:1127
msgid "`ProfileManager`: restart daemon in `clear_profile` [[#5751]](https://github.com/aiidateam/aiida-core/pull/5751)"
msgstr ""

#: ../../../CHANGELOG.md:1130
msgid "Mark relevant `Process` exit codes as `invalidates_cache=True`[[#5709]](https://github.com/aiidateam/aiida-core/pull/5709)"
msgstr ""

#: ../../../CHANGELOG.md:1131
msgid "`TemplatereplacerCalculation`: Change exit codes to be in 300 range [[#5709]](https://github.com/aiidateam/aiida-core/pull/5709)"
msgstr ""

#: ../../../CHANGELOG.md:1132
msgid "Add the prefix `core.` to all storage entry points [[#5501]](https://github.com/aiidateam/aiida-core/pull/5501)"
msgstr ""

#: ../../../CHANGELOG.md:1133
msgid "`CalcJob`: Fully abstract interaction with `AbstractCode` in presubmit [[#5666]](https://github.com/aiidateam/aiida-core/pull/5666)"
msgstr ""

#: ../../../CHANGELOG.md:1134
msgid "CLI: make label the default group list order in `verdi group list` [[#5523]](https://github.com/aiidateam/aiida-core/pull/5523)"
msgstr ""

#: ../../../CHANGELOG.md:1135
msgid "Config: add migration to properly prefix storage backend [[#5501]](https://github.com/aiidateam/aiida-core/pull/5501)"
msgstr ""

#: ../../../CHANGELOG.md:1136
msgid "Move query utils from `aiida.cmdline` to `aiida.tools` [[#5630]](https://github.com/aiidateam/aiida-core/pull/5630)"
msgstr ""

#: ../../../CHANGELOG.md:1137
msgid "`SandboxFolder`: decouple the location from the profile [[#5496]](https://github.com/aiidateam/aiida-core/pull/5496)"
msgstr ""

#: ../../../CHANGELOG.md:1138
msgid "`TemplatereplacerDoublerParser`: rename and generalize implementation [[#5669]](https://github.com/aiidateam/aiida-core/pull/5669)"
msgstr ""

#: ../../../CHANGELOG.md:1139
msgid "`Process`: Allow `None` for input ports that are not required [[#5722]](https://github.com/aiidateam/aiida-core/pull/5722)"
msgstr ""

#: ../../../CHANGELOG.md:1142
msgid "RabbitMQ: Remove support for v3.5 and older [[#5718]](https://github.com/aiidateam/aiida-core/pull/5718)"
msgstr ""

#: ../../../CHANGELOG.md:1143
msgid "Relax `wrapt` requirement [[#5607]](https://github.com/aiidateam/aiida-core/pull/5607)"
msgstr ""

#: ../../../CHANGELOG.md:1144
msgid "Set upper limit `werkzeug<2.2` [[#5606]](https://github.com/aiidateam/aiida-core/pull/5606)"
msgstr ""

#: ../../../CHANGELOG.md:1145
msgid "Update requirement `click~=8.1` [[#5504]](https://github.com/aiidateam/aiida-core/pull/5504)"
msgstr ""

#: ../../../CHANGELOG.md:1148
msgid "Deprecate `Profile.repository_path` [[#5516]](https://github.com/aiidateam/aiida-core/pull/5516)"
msgstr ""

#: ../../../CHANGELOG.md:1149
msgid "Deprecate: `verdi code setup` and `CodeBuilder` [[#5510]](https://github.com/aiidateam/aiida-core/pull/5510)"
msgstr ""

#: ../../../CHANGELOG.md:1150
msgid "Deprecate the method `aiida.get_strict_version` [[#5512]](https://github.com/aiidateam/aiida-core/pull/5512)"
msgstr ""

#: ../../../CHANGELOG.md:1151
msgid "Remove use of legacy `Code` [[#5510]](https://github.com/aiidateam/aiida-core/pull/5510)"
msgstr ""

#: ../../../CHANGELOG.md:1154
msgid "Add section on basic performance benchmark with automated benchmark script [[#5724]](https://github.com/aiidateam/aiida-core/pull/5724)"
msgstr ""

#: ../../../CHANGELOG.md:1155
msgid "Add `-U` flag to PostgreSQL database backup command [[#5550]](https://github.com/aiidateam/aiida-core/pull/5550)"
msgstr ""

#: ../../../CHANGELOG.md:1156
msgid "Clarify excepted and killed calculations are not cached [[#5525]](https://github.com/aiidateam/aiida-core/pull/5525)"
msgstr ""

#: ../../../CHANGELOG.md:1157
msgid "Correct snippet for workchain context nested keys [[#5551]](https://github.com/aiidateam/aiida-core/pull/5551)"
msgstr ""

#: ../../../CHANGELOG.md:1158
msgid "Plugin package setup add PEP 621 example [[#5626]](https://github.com/aiidateam/aiida-core/pull/5626)"
msgstr ""

#: ../../../CHANGELOG.md:1159
msgid "Remove note on disk space for caching [[#5534]](https://github.com/aiidateam/aiida-core/pull/5534)"
msgstr ""

#: ../../../CHANGELOG.md:1160
msgid "Remove explicit release tag in Docker image name [[#5671]](https://github.com/aiidateam/aiida-core/pull/5671)"
msgstr ""

#: ../../../CHANGELOG.md:1161
msgid "Remove example REST API extension with POST requests [[#5737]](https://github.com/aiidateam/aiida-core/pull/5737)"
msgstr ""

#: ../../../CHANGELOG.md:1162
msgid "Resubmit a `Process` from a `ProcessNode` [[#5579]](https://github.com/aiidateam/aiida-core/pull/5579)"
msgstr ""

#: ../../../CHANGELOG.md:1165
msgid "Add a notification for nightly workflow on fail [[#5605]](https://github.com/aiidateam/aiida-core/pull/5605)"
msgstr ""

#: ../../../CHANGELOG.md:1166
msgid "CI: Remove `--use-feature` flag in `pip install` of CI [[#5703]](https://github.com/aiidateam/aiida-core/pull/5703)"
msgstr ""

#: ../../../CHANGELOG.md:1167
msgid "Fixtures: Add `started_daemon_client` and `stopped_daemon_client` [[#5631]](https://github.com/aiidateam/aiida-core/pull/5631)"
msgstr ""

#: ../../../CHANGELOG.md:1168
msgid "Fixtures: Add the `entry_points` fixture to dynamically add and remove entry points [[#5745]](https://github.com/aiidateam/aiida-core/pull/5745)"
msgstr ""

#: ../../../CHANGELOG.md:1169
msgid "Refactor: `Process` extract `CalcJob` specific input handling from `Process` [[#5539]](https://github.com/aiidateam/aiida-core/pull/5539)"
msgstr ""

#: ../../../CHANGELOG.md:1170
msgid "Refactor: remove unnecessary use of `tempfile.mkdtemp` [[#5639]](https://github.com/aiidateam/aiida-core/pull/5639)"
msgstr ""

#: ../../../CHANGELOG.md:1171
msgid "Refactor: Remove internal use of various deprecated resources [[#5716]](https://github.com/aiidateam/aiida-core/pull/5716)"
msgstr ""

#: ../../../CHANGELOG.md:1172
msgid "Refactor: Turn `aiida.manage.external.rmq` into a package [[#5718]](https://github.com/aiidateam/aiida-core/pull/5718)"
msgstr ""

#: ../../../CHANGELOG.md:1173
msgid "Tests: remove legacy `tests/utils/configuration.py` [[#5500]](https://github.com/aiidateam/aiida-core/pull/5500)"
msgstr ""

#: ../../../CHANGELOG.md:1174
msgid "Tests: fix the RPN work chains for the nightly build [[#5529]](https://github.com/aiidateam/aiida-core/pull/5529)"
msgstr ""

#: ../../../CHANGELOG.md:1175
msgid "Tests: Manually stop daemon after `verdi devel revive` test [[#5689]](https://github.com/aiidateam/aiida-core/pull/5689)"
msgstr ""

#: ../../../CHANGELOG.md:1176
msgid "Tests: Add verbose info if `submit_and_wait` times out [[#5689]](https://github.com/aiidateam/aiida-core/pull/5689)"
msgstr ""

#: ../../../CHANGELOG.md:1177
msgid "Tests: Do not set default memory for `localhost` fixture [[#5689]](https://github.com/aiidateam/aiida-core/pull/5689)"
msgstr ""

#: ../../../CHANGELOG.md:1178
msgid "Tests: Suppress RabbitMQ and developer version warnings [[#5689]](https://github.com/aiidateam/aiida-core/pull/5689)"
msgstr ""

#: ../../../CHANGELOG.md:1179
msgid "Tests: Add the `EntryPointManager` exposed as `entry_points` fixture [[#5656]](https://github.com/aiidateam/aiida-core/pull/5656)"
msgstr ""

#: ../../../CHANGELOG.md:1180
msgid "Tests: Only reset database connection at end of suite [[#5641]](https://github.com/aiidateam/aiida-core/pull/5641)"
msgstr ""

#: ../../../CHANGELOG.md:1181
msgid "Tests: Suppress logging and warnings from temporary profile fixture [[#5702]](https://github.com/aiidateam/aiida-core/pull/5702)"
msgstr ""

#: ../../../CHANGELOG.md:1184
msgid "v2.0.4 - 2022-09-22"
msgstr ""

#: ../../../CHANGELOG.md:1186
msgid "[Full changelog](https://github.com/aiidateam/aiida-core/compare/v2.0.3...v2.0.4)"
msgstr ""

#: ../../../CHANGELOG.md:1189
msgid "Engine: Fix bug that allowed non-storable inputs to be passed to process [[#5532]](https://github.com/aiidateam/aiida-core/pull/5532)"
msgstr ""

#: ../../../CHANGELOG.md:1190
msgid "Engine: Fix bug when caching from process with nested outputs [[#5538]](https://github.com/aiidateam/aiida-core/pull/5538)"
msgstr ""

#: ../../../CHANGELOG.md:1191
msgid "Archive: Fix bug in archive creation after packing of file repository [[#5570]](https://github.com/aiidateam/aiida-core/pull/5570)"
msgstr ""

#: ../../../CHANGELOG.md:1192
msgid "`QueryBuilder`: apply escape `\\` in `like` and `ilike` for a `sqlite` backend, such as export archives [[#5553]](https://github.com/aiidateam/aiida-core/pull/5553)"
msgstr ""

#: ../../../CHANGELOG.md:1193
msgid "`QueryBuilder`: Fix bug in distinct queries always projecting the first entity, even if not projected explicitly [[#5654]](https://github.com/aiidateam/aiida-core/pull/5654)"
msgstr ""

#: ../../../CHANGELOG.md:1194
msgid "`CalcJob`: fix bug in `local_copy_list` provenance exclusion [[#5648]](https://github.com/aiidateam/aiida-core/pull/5648)"
msgstr ""

#: ../../../CHANGELOG.md:1195
msgid "`Repository.copy_tree`: omit subdirectories from `path` when copying [[#5648]](https://github.com/aiidateam/aiida-core/pull/5648)"
msgstr ""

#: ../../../CHANGELOG.md:1196
msgid "Docs: Add intersphinx aliases for `__all__` imports. Now the shortcut imports can also be used in third-party packages (e.g. `aiida.orm.nodes.node.Node` as well as `aiida.orm.Node`) [[#5657]](https://github.com/aiidateam/aiida-core/pull/5657)"
msgstr ""

#: ../../../CHANGELOG.md:1199
msgid "v2.0.3 - 2022-08-09"
msgstr ""

#: ../../../CHANGELOG.md:1201
msgid "[Full changelog](https://github.com/aiidateam/aiida-core/compare/v2.0.2...v2.0.3)"
msgstr ""

#: ../../../CHANGELOG.md:1203
msgid "Update of the Dockerfile base image (`aiidateam/aiida-prerequisites`) to version `0.6.0`."
msgstr ""

#: ../../../CHANGELOG.md:1206
msgid "v2.0.2 - 2022-07-13"
msgstr ""

#: ../../../CHANGELOG.md:1208
msgid "[Full changelog](https://github.com/aiidateam/aiida-core/compare/v2.0.1...v2.0.2)"
msgstr ""

#: ../../../CHANGELOG.md:1211
msgid "REST API: treat `false` as `False` in URL parsing [[#5573]](https://github.com/aiidateam/aiida-core/pull/5573)"
msgstr ""

#: ../../../CHANGELOG.md:1212
msgid "REST API: add support for byte streams through a custom JSON encoder [[#5576]](https://github.com/aiidateam/aiida-core/pull/5576)"
msgstr ""

#: ../../../CHANGELOG.md:1215
msgid "v2.0.1 - 2022-04-28"
msgstr ""

#: ../../../CHANGELOG.md:1217
msgid "[Full changelog](https://github.com/aiidateam/aiida-core/compare/v2.0.0...v2.0.1)"
msgstr ""

#: ../../../CHANGELOG.md:1220
msgid "Fix incompatibility with `click>=8.1` and require `click==8.1` as a minimum by @sphuber in [[#5504]](https://github.com/aiidateam/aiida-core/pull/5504)"
msgstr ""

#: ../../../CHANGELOG.md:1223
msgid "v2.0.0 - 2022-04-27"
msgstr ""

#: ../../../CHANGELOG.md:1225
msgid "[Full changelog](https://github.com/aiidateam/aiida-core/compare/v2.0.0b1...v2.0.0)"
msgstr ""

#: ../../../CHANGELOG.md:1227
msgid "This release finalises the [v2.0.0b1 changes](release/2.0.0b1)."
msgstr ""

#: ../../../CHANGELOG.md:1229
msgid "Node namespace restructuring ♻️"
msgstr ""

#: ../../../CHANGELOG.md:1232
msgid "The restructuring is fully back-compatible, and existing methods/attributes will continue to work, until aiida-core `v3.0`."
msgstr ""

#: ../../../CHANGELOG.md:1234
msgid "Deprecations warnings are also currently turned **off** by default. To identify these deprecations in your code base (for example when running unit tests), activate the `AIIDA_WARN_v3` environmental variable:"
msgstr ""

#: ../../../CHANGELOG.md:1243
msgid "The `Node` class (and thus its subclasses) has many methods and attributes in its public namespace. This has been noted [as being a problem](https://github.com/aiidateam/aiida-core/issues/4976) for those using auto-completion, since it makes it difficult to select suitable methods and attributes."
msgstr ""

#: ../../../CHANGELOG.md:1247
msgid "These methods/attributes have now been partitioned into \"sub-namespaces\" for specific purposes:"
msgstr ""

#: ../../../CHANGELOG.md:1249
msgid "`Node.base.attributes`"
msgstr ""

#: ../../../CHANGELOG.md:1250
#: ../../../src/aiida/orm/nodes/attributes.py:docstring of aiida.orm.nodes.attributes:1
#: ../../../src/aiida/orm/nodes/attributes.py:docstring of aiida.orm.nodes.attributes.NodeAttributes:1
msgid "Interface to the attributes of a node instance."
msgstr ""

#: ../../../CHANGELOG.md:1252
msgid "`Node.base.caching`"
msgstr ""

#: ../../../CHANGELOG.md:1253
#: ../../../src/aiida/orm/nodes/caching.py:docstring of aiida.orm.nodes.caching:1
#: ../../../src/aiida/orm/nodes/caching.py:docstring of aiida.orm.nodes.caching.NodeCaching:1
#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNodeCaching:1
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNodeCaching:1
msgid "Interface to control caching of a node instance."
msgstr ""

#: ../../../CHANGELOG.md:1255
msgid "`Node.base.comments`"
msgstr ""

#: ../../../CHANGELOG.md:1256
#: ../../../src/aiida/orm/nodes/comments.py:docstring of aiida.orm.nodes.comments:1
#: ../../../src/aiida/orm/nodes/comments.py:docstring of aiida.orm.nodes.comments.NodeComments:1
msgid "Interface for comments of a node instance."
msgstr ""

#: ../../../CHANGELOG.md:1258
msgid "`Node.base.extras`"
msgstr ""

#: ../../../CHANGELOG.md:1259
#: ../../../src/aiida/orm/extras.py:docstring of aiida.orm.extras:1
msgid "Interface to the extras of a node instance."
msgstr ""

#: ../../../CHANGELOG.md:1261
msgid "`Node.base.links`"
msgstr ""

#: ../../../CHANGELOG.md:1262
#: ../../../src/aiida/orm/nodes/links.py:docstring of aiida.orm.nodes.links:1
#: ../../../src/aiida/orm/nodes/links.py:docstring of aiida.orm.nodes.links.NodeLinks:1
#: ../../../src/aiida/orm/nodes/process/calculation/calcfunction.py:docstring of aiida.orm.nodes.process.calculation.calcfunction.CalcFunctionNodeLinks:1
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNodeLinks:1
#: ../../../src/aiida/orm/nodes/process/workflow/workflow.py:docstring of aiida.orm.nodes.process.workflow.workflow.WorkflowNodeLinks:1
#: ../../../src/aiida/orm/nodes/process/workflow/workfunction.py:docstring of aiida.orm.nodes.process.workflow.workfunction.WorkFunctionNodeLinks:1
msgid "Interface for links of a node instance."
msgstr ""

#: ../../../CHANGELOG.md:1264
msgid "`Node.base.repository`"
msgstr ""

#: ../../../CHANGELOG.md:1265
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository:1
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository:1
msgid "Interface to the file repository of a node instance."
msgstr ""

#: ../../../CHANGELOG.md:0
msgid "Full list of re-naming"
msgstr ""

#: ../../../CHANGELOG.md:1337
msgid "IPython integration improvements 👌"
msgstr ""

#: ../../../CHANGELOG.md:1339
msgid "The `aiida` [IPython magic commands](https://ipython.readthedocs.io/en/stable/interactive/magics.html) are now available to load via:"
msgstr ""

#: ../../../CHANGELOG.md:1345
msgid "As well as the previous `%aiida` magic command, to load a profile, one can also use the `%verdi` magic command. This command runs the `verdi` CLI using the currently loaded profile of the IPython/Jupyter session."
msgstr ""

#: ../../../CHANGELOG.md:1353
#: ../../../CHANGELOG.md:1378
msgid "See the [Basic Tutorial](docs/source/intro/tutorial.md) for example usage."
msgstr ""

#: ../../../CHANGELOG.md:1355
msgid "New `SqliteTempBackend` ✨"
msgstr ""

#: ../../../CHANGELOG.md:1357
msgid "The `SqliteTempBackend` utilises an in-memory SQLite database to store data, allowing it to be transiently created/destroyed within a single Python session, without the need for Postgresql."
msgstr ""

#: ../../../CHANGELOG.md:1359
msgid "As such, it is useful for demonstrations and testing purposes, whereby no persistent storage is required."
msgstr ""

#: ../../../CHANGELOG.md:1361
msgid "To load a temporary profile, you can use the following code:"
msgstr ""

#: ../../../CHANGELOG.md:1380
#: ../../../CHANGELOG.md:1737
msgid "Key Pull Requests"
msgstr ""

#: ../../../CHANGELOG.md:1382
msgid "Below is a list of some key pull requests that have been merged into version 2.0.0:"
msgstr ""

#: ../../../CHANGELOG.md:1384
msgid "Node namespace re-structuring:"
msgstr ""

#: ../../../CHANGELOG.md:1385
msgid "🔧 MAINTAIN: Add `warn_deprecation` function, `Node.base`, and move `NodeRepositoryMixin -> NodeRepository` by @chrisjsewell in [#5472](https://github.com/aiidateam/aiida-core/pull/5472)"
msgstr ""

#: ../../../CHANGELOG.md:1386
msgid "♻️ REFACTOR: `EntityAttributesMixin` -> `NodeAttributes` by @chrisjsewell in [#5442](https://github.com/aiidateam/aiida-core/pull/5442)"
msgstr ""

#: ../../../CHANGELOG.md:1387
msgid "♻️ REFACTOR: Move methods to `Node.comments` by @chrisjsewell in [#5446](https://github.com/aiidateam/aiida-core/pull/5446)"
msgstr ""

#: ../../../CHANGELOG.md:1388
msgid "♻️ REFACTOR: `EntityExtrasMixin` -> `EntityExtras` by @chrisjsewell in [#5445](https://github.com/aiidateam/aiida-core/pull/5445)"
msgstr ""

#: ../../../CHANGELOG.md:1389
msgid "♻️ REFACTOR: Move link related methods to `Node.base.links` by @sphuber in [#5480](https://github.com/aiidateam/aiida-core/pull/5480)"
msgstr ""

#: ../../../CHANGELOG.md:1390
msgid "♻️ REFACTOR: Move caching related methods to `Node.base.caching` by @sphuber in [#5483](https://github.com/aiidateam/aiida-core/pull/5483)"
msgstr ""

#: ../../../CHANGELOG.md:1392
msgid "Storage:"
msgstr ""

#: ../../../CHANGELOG.md:1393
msgid "✨ NEW: Add SqliteTempBackend by @chrisjsewell in [#5448](https://github.com/aiidateam/aiida-core/pull/5448)"
msgstr ""

#: ../../../CHANGELOG.md:1394
msgid "👌 IMPROVE: Move default user caching to `StorageBackend` by @chrisjsewell in [#5460](https://github.com/aiidateam/aiida-core/pull/5460)"
msgstr ""

#: ../../../CHANGELOG.md:1395
msgid "👌 IMPROVE: Add JSON filtering for SQLite backends by @chrisjsewell in [#5448](https://github.com/aiidateam/aiida-core/pull/5448)"
msgstr ""

#: ../../../CHANGELOG.md:1397
msgid "ORM:"
msgstr ""

#: ../../../CHANGELOG.md:1398
msgid "👌 IMPROVE: `StructureData`: allow to be initialised without a specified cell by @ltalirz in [#5341](https://github.com/aiidateam/aiida-core/pull/5341)"
msgstr ""

#: ../../../CHANGELOG.md:1400
#: ../../../CHANGELOG.md:1783
msgid "Processing:"
msgstr ""

#: ../../../CHANGELOG.md:1401
msgid "👌 IMPROVE: Allow `engine.run` to work without RabbitMQ by @chrisjsewell in [#5448](https://github.com/aiidateam/aiida-core/pull/5448)"
msgstr ""

#: ../../../CHANGELOG.md:1402
msgid "👌 IMPROVE: `JobTemplate`: change `CodeInfo` to `JobTemplateCodeInfo` in `codes_info` by @unkcpz in [#5350](https://github.com/aiidateam/aiida-core/pull/5350)"
msgstr ""

#: ../../../CHANGELOG.md:1403
msgid "This is required for a containerized code implementation"
msgstr ""

#: ../../../CHANGELOG.md:1404
msgid "👌 IMPROVE: Add option to use double quotes for `Code` and `Computer` CLI arguments by @unkcpz in [#5478](https://github.com/aiidateam/aiida-core/pull/5478)"
msgstr ""

#: ../../../CHANGELOG.md:1406
msgid "Transport and Scheduler:"
msgstr ""

#: ../../../CHANGELOG.md:1407
msgid "👌 IMPROVE: `SlurmScheduler`: Parse out-of-walltime and out-of-memory errors from `stderr` by @sphuber in [#5458](https://github.com/aiidateam/aiida-core/pull/5458)"
msgstr ""

#: ../../../CHANGELOG.md:1408
msgid "👌 IMPROVE: `CalcJob`: always call `Scheduler.parse_output` by @sphuber in [#5458](https://github.com/aiidateam/aiida-core/pull/5458)"
msgstr ""

#: ../../../CHANGELOG.md:1409
msgid "👌 IMPROVE: `Computer`: fallback on transport for `get_minimum_job_poll_interval` default by @sphuber in [#5457](https://github.com/aiidateam/aiida-core/pull/5457)"
msgstr ""

#: ../../../CHANGELOG.md:1411
msgid "IPython:"
msgstr ""

#: ../../../CHANGELOG.md:1412
msgid "✨ NEW: Add `%verdi` IPython magic by @chrisjsewell in [#5448](https://github.com/aiidateam/aiida-core/pull/5448)"
msgstr ""

#: ../../../CHANGELOG.md:1414
msgid "Dependencies:"
msgstr ""

#: ../../../CHANGELOG.md:1415
msgid "♻️ REFACTOR: drop the `python-dateutil` library by @sphuber"
msgstr ""

#: ../../../CHANGELOG.md:1418
msgid "v2.0.0b1 - 2022-03-15"
msgstr ""

#: ../../../CHANGELOG.md:1420
msgid "[Full changelog](https://github.com/aiidateam/aiida-core/compare/v1.6.7...v2.0.0b1)"
msgstr ""

#: ../../../CHANGELOG.md:1422
msgid "The version 2 release of `aiida-core` largely focusses on major improvements to the design of data storage within AiiDA, as well as updates to core dependencies and removal of deprecated APIs."
msgstr ""

#: ../../../CHANGELOG.md:1424
msgid "Assuming users have already addressed deprecation warnings from `aiida-core` v1.6.x, there should be limited impact on existing code. For plugin developers, the [AiiDA 2.0 plugin migration guide](https://github.com/aiidateam/aiida-core/wiki/AiiDA-2.0-plugin-migration-guide) provides a step-by-step guide on how to update their plugins."
msgstr ""

#: ../../../CHANGELOG.md:1427
msgid "For existing profiles and archives, a migration will be required, before they are compatible with the new version."
msgstr ""

#: ../../../CHANGELOG.md:1430
msgid "Before updating your `aiida-core` installation, it is advisable to make sure you create a full backup of your profiles, using the current version of `aiida-core` you have installed. For backup instructions, using aiida-core v1.6.7, see [this documentation](https://aiida.readthedocs.io/projects/aiida-core/en/v1.6.7/howto/installation.html#backing-up-your-installation)."
msgstr ""

#: ../../../CHANGELOG.md:1435
msgid "Python support updated to 3.8 - 3.10 ⬆️"
msgstr ""

#: ../../../CHANGELOG.md:1437
msgid "Following the [NEP 029](https://numpy.org/neps/nep-0029-deprecation_policy.html) timeline, support for Python 3.7 is dropped as of December 26 2021, and support for Python 3.10 is added."
msgstr ""

#: ../../../CHANGELOG.md:1439
msgid "Plugin entry point updates 🧩"
msgstr ""

#: ../../../CHANGELOG.md:1441
msgid "AiiDA's use of entry points, to allow plugins to extend the functionality of AiiDA, is described in the [plugins topic section](docs/source/topics/plugins.rst)."
msgstr ""

#: ../../../CHANGELOG.md:1443
msgid "The use of `reentry scan`, for loading plugin entry points, is no longer necessary."
msgstr ""

#: ../../../CHANGELOG.md:1445
msgid "Use of the [reentry](https://pypi.org/project/reentry/) dependency has been replaced by the built-in [importlib.metadata](https://docs.python.org/3/library/importlib.metadata.html) library. This library requires no additional loading step."
msgstr ""

#: ../../../CHANGELOG.md:1448
msgid "All entry points provided by `aiida-core` now start with a `core.` prefix, to make their origin more explicit and respect the naming guidelines of entry points in the AiiDA ecosystem. The old names are still supported so as to not suddenly break existing code based on them, but they have now been deprecated. For example:"
msgstr ""

#: ../../../CHANGELOG.md:1458
msgid "Note that entry point names are also used on the command line. For example:"
msgstr ""

#: ../../../CHANGELOG.md:1466
msgid "Improvements to the AiiDA storage architecture ♻️"
msgstr ""

#: ../../../CHANGELOG.md:1468
msgid "Full details on the AiiDA storage architecture are available in the [storage architecture section](docs/source/internals/storage/architecture.rst)."
msgstr ""

#: ../../../CHANGELOG.md:1470
msgid "The storage refactor incorporates four major changes:"
msgstr ""

#: ../../../CHANGELOG.md:1472
msgid "The `django` and `sqlalchemy` storage backends have been merged into a single `psql_dos` backend (PostgreSQL + Disk-Objectstore)."
msgstr ""

#: ../../../CHANGELOG.md:1473
msgid "See the [`psql_dos` storage format](docs/source/internals/storage/psql_dos.rst) for details."
msgstr ""

#: ../../../CHANGELOG.md:1474
msgid "This has allowed for the `django` dependency to be dropped."
msgstr ""

#: ../../../CHANGELOG.md:1476
msgid "The file system node repository has been replaced with an object store implementation."
msgstr ""

#: ../../../CHANGELOG.md:1477
msgid "The object store automatically deduplicates files, and allows for the compression of many objects into a single file, thus significantly reducing the number of files on the file system and memory utilisation (by orders of magnitude)."
msgstr ""

#: ../../../CHANGELOG.md:1478
msgid "Note, to make full use of object compression, one should periodically run `verdi storage maintain`."
msgstr ""

#: ../../../CHANGELOG.md:1479
msgid "See the [repository design section](docs/source/internals/storage/repository.rst) for details."
msgstr ""

#: ../../../CHANGELOG.md:1481
msgid "Command-line interaction with a profile's storage has been moved from `verdi database` to `verdi storage`."
msgstr ""

#: ../../../CHANGELOG.md:1483
msgid "The AiiDA archive format has been redesigned as the `sqlite_zip` storage backend."
msgstr ""

#: ../../../CHANGELOG.md:1484
msgid "See the [`sqlite_zip` storage format](docs/source/internals/storage/sqlite_zip.rst) for details."
msgstr ""

#: ../../../CHANGELOG.md:1485
msgid "The new format allows for streaming of data during exports and imports, significantly reducing both the time and memory utilisation of these actions."
msgstr ""

#: ../../../CHANGELOG.md:1486
msgid "The archive can now be loaded directly as a (read-only) profile, without the need to import it first, see [this Jupyter Notebook tutorial](docs/source/howto/archive_profile.md)."
msgstr ""

#: ../../../CHANGELOG.md:1488
msgid "The storage redesign also allows for profile switching, within the same Python process, and profile access within a context manager. For example:"
msgstr ""

#: ../../../CHANGELOG.md:1508
msgid "See [How to interact with AiiDA](docs/source/howto/interact.rst) for more details."
msgstr ""

#: ../../../CHANGELOG.md:1510
msgid "On first using `aiida-core` v2.0, your AiiDA configuration will be automatically migrated to the new version (this can be reverted by `verdi config downgrade`). To update existing profiles and archives to the new storage formats, simply use `verdi storage migrate` and `verdi archive migrate`, respectively."
msgstr ""

#: ../../../CHANGELOG.md:1514
msgid "The migration of large storage repositories is a potentially time-consuming process. It may take several hours to complete, depending on the size of the repository. It is also advisable to make a full manual backup of any AiiDA setup with important data: see [the installation management section](docs/source/howto/installation.rst) for more information."
msgstr ""

#: ../../../CHANGELOG.md:1518
msgid "See also this [testing of profile migrations](https://github.com/aiidateam/aiida-core/discussions/5379), for some indicative timings."
msgstr ""

#: ../../../CHANGELOG.md:1521
msgid "Improvements to the AiiDA ORM 👌"
msgstr ""

#: ../../../CHANGELOG.md:1523
msgid "Node repository"
msgstr ""

#: ../../../CHANGELOG.md:1525
msgid "Inline with the storage improvements, {class}`~aiida.orm.Node` methods associated with the repository have some backwards incompatible changes:"
msgstr ""

#: ../../../CHANGELOG.md:0
msgid "`Node` repository method changes"
msgstr ""

#: ../../../CHANGELOG.md:1529
msgid "Altered:"
msgstr ""

#: ../../../CHANGELOG.md:1531
msgid "`FileType`: moved from `aiida.orm.utils.repository` to `aiida.repository.common`"
msgstr ""

#: ../../../CHANGELOG.md:1532
msgid "`File`: moved from `aiida.orm.utils.repository` to `aiida.repository.common`"
msgstr ""

#: ../../../CHANGELOG.md:1533
msgid "`File`: changed from namedtuple to class"
msgstr ""

#: ../../../CHANGELOG.md:1534
msgid "`File`: can no longer be iterated over"
msgstr ""

#: ../../../CHANGELOG.md:1535
msgid "`File`: `type` attribute was renamed to `file_type`"
msgstr ""

#: ../../../CHANGELOG.md:1536
msgid "`Node.put_object_from_tree`: `path` argument was renamed to `filepath`"
msgstr ""

#: ../../../CHANGELOG.md:1537
msgid "`Node.put_object_from_file`: `path` argument was renamed to `filepath`"
msgstr ""

#: ../../../CHANGELOG.md:1538
msgid "`Node.put_object_from_tree`: `key` argument was renamed to `path`"
msgstr ""

#: ../../../CHANGELOG.md:1539
msgid "`Node.put_object_from_file`: `key` argument was renamed to `path`"
msgstr ""

#: ../../../CHANGELOG.md:1540
msgid "`Node.put_object_from_filelike`: `key` argument was renamed to `path`"
msgstr ""

#: ../../../CHANGELOG.md:1541
msgid "`Node.get_object`: `key` argument was renamed to `path`"
msgstr ""

#: ../../../CHANGELOG.md:1542
msgid "`Node.get_object_content`: `key` argument was renamed to `path`"
msgstr ""

#: ../../../CHANGELOG.md:1543
msgid "`Node.open`: `key` argument was renamed to `path`"
msgstr ""

#: ../../../CHANGELOG.md:1544
msgid "`Node.list_objects`: `key` argument was renamed to `path`"
msgstr ""

#: ../../../CHANGELOG.md:1545
msgid "`Node.list_object_names`: `key` argument was renamed to `path`"
msgstr ""

#: ../../../CHANGELOG.md:1546
msgid "`SinglefileData.open`: `key` argument was renamed to `path`"
msgstr ""

#: ../../../CHANGELOG.md:1547
msgid "`Node.open`: can no longer be called without context manager"
msgstr ""

#: ../../../CHANGELOG.md:1548
msgid "`Node.open`: only mode `r` and `rb` are supported, [use `put_object_from_` methods instead](https://github.com/aiidateam/aiida-core/issues/4721#issuecomment-920100415)"
msgstr ""

#: ../../../CHANGELOG.md:1549
msgid "`Node.get_object_content`: only mode `r` and `rb` are supported"
msgstr ""

#: ../../../CHANGELOG.md:1550
msgid "`Node.put_object_from_tree`: argument `contents_only` was removed"
msgstr ""

#: ../../../CHANGELOG.md:1551
msgid "`Node.put_object_from_tree`: argument `force` was removed"
msgstr ""

#: ../../../CHANGELOG.md:1552
msgid "`Node.put_object_from_file`: argument `force` was removed"
msgstr ""

#: ../../../CHANGELOG.md:1553
msgid "`Node.put_object_from_filelike`: argument `force` was removed"
msgstr ""

#: ../../../CHANGELOG.md:1554
msgid "`Node.delete_object`: argument `force` was removed"
msgstr ""

#: ../../../CHANGELOG.md:1556
msgid "Added:"
msgstr ""

#: ../../../CHANGELOG.md:1558
msgid "`Node.walk`"
msgstr ""

#: ../../../CHANGELOG.md:1559
msgid "`Node.copy_tree`"
msgstr ""

#: ../../../CHANGELOG.md:1560
msgid "`Node.is_valid_cache` setter"
msgstr ""

#: ../../../CHANGELOG.md:1561
msgid "`Node.objects.iter_repo_keys`"
msgstr ""

#: ../../../CHANGELOG.md:1563
msgid "Additionally, `Node.open` should always be used as a context manager, for example:"
msgstr ""

#: ../../../CHANGELOG.md:1572
msgid "QueryBuilder"
msgstr ""

#: ../../../CHANGELOG.md:1574
msgid "When using the {class}`~aiida.orm.QueryBuilder` to query the database, the following changes have been made:"
msgstr ""

#: ../../../CHANGELOG.md:1576
msgid "The `Computer`'s `name` field is now replaced with `label` (as previously deprecated in v1.6)"
msgstr ""

#: ../../../CHANGELOG.md:1577
msgid "The `QueryBuilder.queryhelp` attribute is deprecated, for the `as_dict` (and `from_dict`) methods"
msgstr ""

#: ../../../CHANGELOG.md:1578
msgid "The `QueryBuilder.first` method now allows the `flat` argument, which will return a single item, instead of a list of one item, if only a single projection is defined."
msgstr ""

#: ../../../CHANGELOG.md:1580
#: ../../../CHANGELOG.md:1599
#: ../../source/reference/api/public.rst:15
msgid "For example:"
msgstr ""

#: ../../../CHANGELOG.md:1588
msgid "For further information, see [How to find and query for data](docs/source/howto/query.rst)."
msgstr ""

#: ../../../CHANGELOG.md:1590
msgid "Dict usage"
msgstr ""

#: ../../../CHANGELOG.md:1592
msgid "The {class}`~aiida.orm.Dict` class has been updated to support more native `dict` behaviour:"
msgstr ""

#: ../../../CHANGELOG.md:1594
msgid "Initialisation can now use `Dict({'a': 1})`, instead of `Dict(dict={'a': 1})`. This is also the case for `List([1, 2])`."
msgstr ""

#: ../../../CHANGELOG.md:1595
msgid "Equality (`==`/`!=`) comparisons now compare the dictionaries, rather than the UUIDs"
msgstr ""

#: ../../../CHANGELOG.md:1596
msgid "The contains (`in`) operator now returns `True` if the dictionary contains the key"
msgstr ""

#: ../../../CHANGELOG.md:1597
msgid "The `items` method iterates a list of `(key, value)` pairs"
msgstr ""

#: ../../../CHANGELOG.md:1616
msgid "New data types"
msgstr ""

#: ../../../CHANGELOG.md:1618
msgid "Two new built-in data types have been added:"
msgstr ""

#: ../../../CHANGELOG.md:1620
msgid "{class}`~aiida.orm.EnumData`"
msgstr ""

#: ../../../CHANGELOG.md:1621
msgid "A data plugin that wraps a Python `enum.Enum` instance."
msgstr ""

#: ../../../CHANGELOG.md:1623
msgid "{class}`~aiida.orm.JsonableData`"
msgstr ""

#: ../../../CHANGELOG.md:1624
msgid "A data plugin that allows one to easily wrap existing objects that are JSON-able (via an `as_dict` method)."
msgstr ""

#: ../../../CHANGELOG.md:1626
msgid "See the [data types section](docs/source/topics/data_types.rst) for more information."
msgstr ""

#: ../../../CHANGELOG.md:1628
msgid "Improvements to the AiiDA process engine 👌"
msgstr ""

#: ../../../CHANGELOG.md:1630
msgid "CalcJob API"
msgstr ""

#: ../../../CHANGELOG.md:1632
msgid "A number of minor improvements have been made to the `CalcJob` API:"
msgstr ""

#: ../../../CHANGELOG.md:1634
msgid "Both numpy arrays and `Enum` instances can now be serialized on process checkpoints."
msgstr ""

#: ../../../CHANGELOG.md:1635
msgid "The `Calcjob.spec.metadata.options.rerunnable` option allows to specify whether the calculation can be rerun or requeued (dependent on the scheduler). Note, this should only be applied for idempotent codes."
msgstr ""

#: ../../../CHANGELOG.md:1636
msgid "The `Calcjob.spec.metadata.options.environment_variables_double_quotes` option allows for double-quoting of environment variable declarations. In particular, this allows for use of the `$` character in the environment variable name, e.g. `export MY_FILE=\"$HOME/path/my_file\"`."
msgstr ""

#: ../../../CHANGELOG.md:1637
msgid "`CalcJob.local_copy_list` now allows for specifying entire directories to be copied to the local computer, in addition to individual files. Note that the directory itself won't be copied, just its contents."
msgstr ""

#: ../../../CHANGELOG.md:1638
msgid "`WorkChain.to_context` now allows `.` delimited namespacing, which generate nested dictionaries. See [Nested context keys](docs/source/topics/workflows/usage.rst) for more information."
msgstr ""

#: ../../../CHANGELOG.md:1640
msgid "Importing existing computations"
msgstr ""

#: ../../../CHANGELOG.md:1642
msgid "The new `CalcJobImporter` class has been added, to define importers for computations completed outside of AiiDA. These can help onboard new users to your AiiDA plugin. For more information, see [Writing importers for existing computations](docs/source/howto/plugin_codes.rst)."
msgstr ""

#: ../../../CHANGELOG.md:1646
msgid "Scheduler plugins"
msgstr ""

#: ../../../CHANGELOG.md:1648
msgid "Plugin's implementation of `Scheduler._get_submit_script_header` should now utilise `Scheduler._get_submit_script_environment_variables`, to format environment variable declarations, rather than handling it themselves. See the exemplar changes in [#5283](https://github.com/aiidateam/aiida-core/pull/5283)."
msgstr ""

#: ../../../CHANGELOG.md:1650
msgid "The `Scheduler.get_valid_transports()` method has also been removed, use `get_entry_point_names('aiida.schedulers')` instead (see {func}`~aiida.plugins.entry_point.get_entry_point_names`)."
msgstr ""

#: ../../../CHANGELOG.md:1652
msgid "See [Scheduler plugins](docs/source/topics/schedulers.rst) for more information."
msgstr ""

#: ../../../CHANGELOG.md:1654
msgid "Transport plugins"
msgstr ""

#: ../../../CHANGELOG.md:1656
msgid "The `SshTransport` now supports the SSH `ProxyJump` option, for tunnelling through other SSH hosts. See [How to setup SSH connections](docs/source/howto/ssh.rst) for more information."
msgstr ""

#: ../../../CHANGELOG.md:1659
msgid "Transport plugins now support also transferring bytes (rather than only Unicode strings) in the stdout/stderr of \"remote\" commands (see [#3787](https://github.com/aiidateam/aiida-core/pull/3787)). The required changes for transport plugins:"
msgstr ""

#: ../../../CHANGELOG.md:1662
msgid "rename the `exec_command_wait` function in your plugin implementation with `exec_command_wait_bytes`"
msgstr ""

#: ../../../CHANGELOG.md:1663
msgid "ensure the method signature follows {meth}`~aiida.transports.transport.Transport.exec_command_wait_bytes`, and that `stdin` accepts a `bytes` object."
msgstr ""

#: ../../../CHANGELOG.md:1664
msgid "return bytes for stdout and stderr (most probably internally you are already getting bytes - just do not decode them to strings)"
msgstr ""

#: ../../../CHANGELOG.md:1666
msgid "For an exemplar implementation, see {meth}`~aiida.transports.plugins.local.LocalTransport.exec_command_wait_bytes`, or see [Transport plugins](docs/source/topics/transport.rst) for more information."
msgstr ""

#: ../../../CHANGELOG.md:1669
msgid "The `Transport.get_valid_transports()` method has also been removed, use `get_entry_point_names('aiida.transports')` instead (see {func}`~aiida.plugins.entry_point.get_entry_point_names`)."
msgstr ""

#: ../../../CHANGELOG.md:1671
msgid "Improvements to the AiiDA command-line 👌"
msgstr ""

#: ../../../CHANGELOG.md:1673
msgid "The AiiDA command-line interface (CLI) can now be accessed as both `verdi` and `/path/to/bin/python -m aiida`."
msgstr ""

#: ../../../CHANGELOG.md:1675
msgid "The underlying dependency for this CLI, `click`, has been updated to version 8, which contains built-in tab-completion support, to replace the old `click-completion`. The completion works the same, except that the string that should be put in the activation script to enable it is now shell-dependent. See [Activating tab-completion](docs/source/howto/installation.rst) for more information."
msgstr ""

#: ../../../CHANGELOG.md:1679
msgid "Logging for the CLI has been updated, to standardise its use across all CLI commands. This means that all commands include the option:"
msgstr ""

#: ../../../CHANGELOG.md:1687
msgid "By default the verbosity is set to `REPORT` (see `verdi config list`), which relates to using `Logger.report`, as defined in {func}`~aiida.common.log.report`."
msgstr ""

#: ../../../CHANGELOG.md:1689
msgid "The following specific changes and improvements have been made to the CLI commands:"
msgstr ""

#: ../../../CHANGELOG.md:1691
msgid "`verdi storage` (replaces `verdi database`)"
msgstr ""

#: ../../../CHANGELOG.md:1692
msgid "This command group replaces the `verdi database` command group, which is now deprecated, in order to represent its interaction with the full profile storage (not just database)."
msgstr ""

#: ../../../CHANGELOG.md:1693
msgid "`verdi storage info` provides information about the entities contained for a profile."
msgstr ""

#: ../../../CHANGELOG.md:1694
msgid "`verdi storage maintain` has also been added, to allow for maintenance of the storage, for example, to optimise the storage size."
msgstr ""

#: ../../../CHANGELOG.md:1696
msgid "`verdi archive version` and `verdi archive info` (replace `verdi archive inspect`)"
msgstr ""

#: ../../../CHANGELOG.md:1697
msgid "This change synchronises the commands with the new `verdi storage version` and `verdi storage info` commands."
msgstr ""

#: ../../../CHANGELOG.md:1699
msgid "`verdi group move-nodes`"
msgstr ""

#: ../../../CHANGELOG.md:1700
msgid "This command moves nodes from a source group to a target group (removing them from one and adding them to the other)."
msgstr ""

#: ../../../CHANGELOG.md:1702
msgid "`verdi code setup`"
msgstr ""

#: ../../../CHANGELOG.md:1703
msgid "There is a small change to the order of prompts, in interactive mode."
msgstr ""

#: ../../../CHANGELOG.md:1704
msgid "The uniqueness of labels is now validated, for both remote and local codes."
msgstr ""

#: ../../../CHANGELOG.md:1706
msgid "`verdi code test`"
msgstr ""

#: ../../../CHANGELOG.md:1707
msgid "Run tests for a given code to check whether it is usable, including whether remote executable files are available."
msgstr ""

#: ../../../CHANGELOG.md:1709
msgid "See [AiiDA Command Line](docs/source/reference/command_line.rst) for more information."
msgstr ""

#: ../../../CHANGELOG.md:1711
msgid "Development improvements"
msgstr ""

#: ../../../CHANGELOG.md:1713
msgid "The build tool for `aiida-core` has been changed from `setuptools` to [`flit`](https://github.com/pypa/flit). This allows for the project metadata to be fully specified in the `pyproject.toml` file, using the [PEP 621](https://www.python.org/dev/peps/pep-0621) format. Note, editable installs (using the `-e` flag for `pip install`) of `aiida-core` now require `pip>=21`."
msgstr ""

#: ../../../CHANGELOG.md:1717
msgid "[Type annotations](https://peps.python.org/pep-0526/) have been added to most of the code base. Plugin developers can use [mypy](https://mypy.readthedocs.io) to check their code against the new type annotations."
msgstr ""

#: ../../../CHANGELOG.md:1720
msgid "All module level imports are now defined explicitly in `__all__`. See [Overview of public API](docs/source/reference/api/public.rst) for more information."
msgstr ""

#: ../../../CHANGELOG.md:1723
msgid "The `aiida.common.json` module is now deprecated. Use the `json` standard library instead."
msgstr ""

#: ../../../CHANGELOG.md:1726
msgid "Changes to the plugin test fixtures 🧪"
msgstr ""

#: ../../../CHANGELOG.md:1728
msgid "The deprecated `AiidaTestCase` class has been removed, in favour of the AiiDA pytest fixtures, which can be loaded in your `conftest.py` using:"
msgstr ""

#: ../../../CHANGELOG.md:1734
msgid "The fixtures `clear_database`, `clear_database_after_test`, `clear_database_before_test` are now deprecated, in favour of the `aiida_profile_clean` fixture, which ensures (before the test) the default profile is reset with clean storage, and that all previous resources are closed If you only require the profile to be reset before a class of tests, then you can use `aiida_profile_clean_class`."
msgstr ""

#: ../../../CHANGELOG.md:1739
msgid "Below is a list of some key pull requests that have been merged into version `2.0.0b1`:"
msgstr ""

#: ../../../CHANGELOG.md:1741
msgid "Storage and migrations:"
msgstr ""

#: ../../../CHANGELOG.md:1742
msgid "♻️ REFACTOR: Implement the new file repository by @sphuber in [#4345](https://github.com/aiidateam/aiida-core/pull/4345)"
msgstr ""

#: ../../../CHANGELOG.md:1743
msgid "♻️ REFACTOR: New archive format by @chrisjsewell in [#5145](https://github.com/aiidateam/aiida-core/pull/5145)"
msgstr ""

#: ../../../CHANGELOG.md:1744
msgid "♻️ REFACTOR: Remove `QueryManager` by @chrisjsewell in [#5101](https://github.com/aiidateam/aiida-core/pull/5101)"
msgstr ""

#: ../../../CHANGELOG.md:1745
msgid "♻️ REFACTOR: Fully abstract QueryBuilder by @chrisjsewell in [#5093](https://github.com/aiidateam/aiida-core/pull/5093)"
msgstr ""

#: ../../../CHANGELOG.md:1746
msgid "✨ NEW: Add `Backend` bulk methods by @chrisjsewell in [#5171](https://github.com/aiidateam/aiida-core/pull/5171)"
msgstr ""

#: ../../../CHANGELOG.md:1747
msgid "⬆️ UPDATE: SQLAlchemy v1.4 (v2 API) by @chrisjsewell in [#5103](https://github.com/aiidateam/aiida-core/pull/5103) and [#5122](https://github.com/aiidateam/aiida-core/pull/5122)"
msgstr ""

#: ../../../CHANGELOG.md:1748
msgid "👌 IMPROVE: Configuration migrations by @chrisjsewell in [#5319](https://github.com/aiidateam/aiida-core/pull/5319)"
msgstr ""

#: ../../../CHANGELOG.md:1749
msgid "♻️ REFACTOR: Remove Django storage backend by @chrisjsewell in [#5330](https://github.com/aiidateam/aiida-core/pull/5330)"
msgstr ""

#: ../../../CHANGELOG.md:1750
msgid "♻️ REFACTOR: Move archive backend to `aiida/storage` by @chrisjsewell in [5375](https://github.com/aiidateam/aiida-core/pull/5375)"
msgstr ""

#: ../../../CHANGELOG.md:1751
msgid "👌 IMPROVE: Use `sqlalchemy.func` for JSONB QB filters by @ltalirz in [#5393](https://github.com/aiidateam/aiida-core/pull/5393)"
msgstr ""

#: ../../../CHANGELOG.md:1752
msgid "✨ NEW: Add Mechanism to lock profile access by @ramirezfranciscof in [#5270](https://github.com/aiidateam/aiida-core/pull/5270)"
msgstr ""

#: ../../../CHANGELOG.md:1753
msgid "✨ NEW: Add `verdi storage` CLI by @ramirezfranciscof in [#4965](https://github.com/aiidateam/aiida-core/pull/4965) and [#5156](https://github.com/aiidateam/aiida-core/pull/5156)"
msgstr ""

#: ../../../CHANGELOG.md:1755
msgid "ORM API:"
msgstr ""

#: ../../../CHANGELOG.md:1756
msgid "♻️ REFACTOR: Add the `core.` prefix to all entry points by @sphuber in [#5073](https://github.com/aiidateam/aiida-core/pull/5073)"
msgstr ""

#: ../../../CHANGELOG.md:1757
msgid "👌 IMPROVE: Replace `InputValidationError` with `ValueError` and `TypeError` by @sphuber in [#4888](https://github.com/aiidateam/aiida-core/pull/4888)"
msgstr ""

#: ../../../CHANGELOG.md:1758
msgid "👌 IMPROVE: Add `Node.walk` method to iterate over repository content by @sphuber in [#4935](https://github.com/aiidateam/aiida-core/pull/4935)"
msgstr ""

#: ../../../CHANGELOG.md:1759
msgid "👌 IMPROVE: Add `Node.copy_tree` method  by @sphuber in [#5114](https://github.com/aiidateam/aiida-core/pull/5114)"
msgstr ""

#: ../../../CHANGELOG.md:1760
msgid "👌 IMPROVE: Add `Node.is_valid_cache` setter property  by @sphuber in [#5114](https://github.com/aiidateam/aiida-core/pull/5207)"
msgstr ""

#: ../../../CHANGELOG.md:1761
msgid "👌 IMPROVE: Add `Node.objects.iter_repo_keys` by @chrisjsewell in [#5114](https://github.com/aiidateam/aiida-core/pull/4922)"
msgstr ""

#: ../../../CHANGELOG.md:1762
msgid "👌 IMPROVE: Allow storing `Decimal` in `Node.attributes` by @dev-zero in [#4964](https://github.com/aiidateam/aiida-core/pull/4964)"
msgstr ""

#: ../../../CHANGELOG.md:1763
msgid "🐛 FIX: Initialising a `Node` with a `User` by @chrisjsewell in [#5114](https://github.com/aiidateam/aiida-core/pull/4977)"
msgstr ""

#: ../../../CHANGELOG.md:1764
msgid "🐛 FIX: Deprecate double underscores in `LinkManager` contains by @sphuber in [#5067](https://github.com/aiidateam/aiida-core/pull/5067)"
msgstr ""

#: ../../../CHANGELOG.md:1765
msgid "♻️ REFACTOR: Rename `name` field of `Computer` to `label` by @sphuber in [#4882](https://github.com/aiidateam/aiida-core/pull/4882)"
msgstr ""

#: ../../../CHANGELOG.md:1766
msgid "♻️ REFACTOR: `QueryBuilder.queryhelp` -> `QueryBuilder.as_dict` by @chrisjsewell in [#5081](https://github.com/aiidateam/aiida-core/pull/5081)"
msgstr ""

#: ../../../CHANGELOG.md:1767
msgid "👌 IMPROVE: Add `AuthInfo` joins to `QueryBuilder` by @chrisjsewell in [#5195](https://github.com/aiidateam/aiida-core/pull/5195)"
msgstr ""

#: ../../../CHANGELOG.md:1768
msgid "👌 IMPROVE: `QueryBuilder.first` add `flat` keyword by @sphuber in [#5410](https://github.com/aiidateam/aiida-core/pull/5410)"
msgstr ""

#: ../../../CHANGELOG.md:1769
msgid "👌 IMPROVE: Add `Computer.default_memory_per_machine` attribute by @yakutovicha in [#5260](https://github.com/aiidateam/aiida-core/pull/5260)"
msgstr ""

#: ../../../CHANGELOG.md:1770
msgid "👌 IMPROVE: Add `Code.validate_remote_exec_path` method to check executable by @sphuber in [#5184](https://github.com/aiidateam/aiida-core/pull/5184)"
msgstr ""

#: ../../../CHANGELOG.md:1771
msgid "👌 IMPROVE: Allow `source` to be passed as a keyword to `Data.__init__` by @sphuber in [#5163](https://github.com/aiidateam/aiida-core/pull/5163)"
msgstr ""

#: ../../../CHANGELOG.md:1772
msgid "👌 IMPROVE: `Dict.__init__` and `List.__init__` by @mbercx in [#5165](https://github.com/aiidateam/aiida-core/pull/5165)"
msgstr ""

#: ../../../CHANGELOG.md:1773
msgid "‼️ BREAKING: Compare `Dict` nodes by content by @mbercx in [#5251](https://github.com/aiidateam/aiida-core/pull/5251)"
msgstr ""

#: ../../../CHANGELOG.md:1774
msgid "👌 IMPROVE: Implement the `Dict.__contains__` method by @sphuber in [#5251](https://github.com/aiidateam/aiida-core/pull/5328)"
msgstr ""

#: ../../../CHANGELOG.md:1775
msgid "👌 IMPROVE: Implement `Dict.items()` method by @mbercx in [#5251](https://github.com/aiidateam/aiida-core/pull/5333)"
msgstr ""

#: ../../../CHANGELOG.md:1776
msgid "🐛 FIX: `BandsData.show_mpl` allow NaN values by @PhilippRue in [#5024](https://github.com/aiidateam/aiida-core/pull/5024)"
msgstr ""

#: ../../../CHANGELOG.md:1777
msgid "🐛 FIX: Replace `KeyError` with `AttributeError` in `TrajectoryData` methods by @Crivella in [#5015](https://github.com/aiidateam/aiida-core/pull/5015)"
msgstr ""

#: ../../../CHANGELOG.md:1778
msgid "✨ NEW: `EnumData` data plugin by @sphuber in [#5225](https://github.com/aiidateam/aiida-core/pull/5225)"
msgstr ""

#: ../../../CHANGELOG.md:1779
msgid "✨ NEW: `JsonableData` data plugin by @sphuber in [#5017](https://github.com/aiidateam/aiida-core/pull/5017)"
msgstr ""

#: ../../../CHANGELOG.md:1780
msgid "👌 IMPROVE: Register `List` class with `to_aiida_type` dispatch by @sphuber in [#5142](https://github.com/aiidateam/aiida-core/pull/5142)"
msgstr ""

#: ../../../CHANGELOG.md:1781
msgid "👌 IMPROVE: Register `EnumData` class with `to_aiida_type` dispatch by @sphuber in [#5314](https://github.com/aiidateam/aiida-core/pull/5314)"
msgstr ""

#: ../../../CHANGELOG.md:1784
msgid "✨ NEW: `CalcJob.get_importer()` to import existing calculations, run outside of AiiDA by @sphuber in [#5086](https://github.com/aiidateam/aiida-core/pull/5086)"
msgstr ""

#: ../../../CHANGELOG.md:1785
msgid "✨ NEW: `ProcessBuilder._repr_pretty_` ipython representation by @mbercx in [#4970](https://github.com/aiidateam/aiida-core/pull/4970)"
msgstr ""

#: ../../../CHANGELOG.md:1786
msgid "👌 IMPROVE: Allow `Enum` types to be serialized on `ProcessNode.checkpoint` by @sphuber in [#5218](https://github.com/aiidateam/aiida-core/pull/5218)"
msgstr ""

#: ../../../CHANGELOG.md:1787
msgid "👌 IMPROVE: Allow numpy arrays to be serialized on `ProcessNode.checkpoint` by @greschd in [#4730](https://github.com/aiidateam/aiida-core/pull/4730)"
msgstr ""

#: ../../../CHANGELOG.md:1788
msgid "👌 IMPROVE: Add `Calcjob.spec.metadata.options.rerunnable` to requeue/rerun calculations by @greschd in [#4707](https://github.com/aiidateam/aiida-core/pull/4707)"
msgstr ""

#: ../../../CHANGELOG.md:1789
msgid "👌 IMPROVE: Add `Calcjob.spec.metadata.options.environment_variables_double_quotes` to escape environment variables by @unkcpz in [#5349](https://github.com/aiidateam/aiida-core/pull/5349)"
msgstr ""

#: ../../../CHANGELOG.md:1790
msgid "👌 IMPROVE: Allow directories in `CalcJob.local_copy_list` by @sphuber in [#5115](https://github.com/aiidateam/aiida-core/pull/5115)"
msgstr ""

#: ../../../CHANGELOG.md:1791
msgid "👌 IMPROVE: Add support for `.` namespacing in the keys for `WorkChain.to_context` by @dev-zero in [#4871](https://github.com/aiidateam/aiida-core/pull/4871)"
msgstr ""

#: ../../../CHANGELOG.md:1792
msgid "👌 IMPROVE: Handle namespaced outputs in `BaseRestartWorkChain` by @unkcpz in [#4961](https://github.com/aiidateam/aiida-core/pull/4961)"
msgstr ""

#: ../../../CHANGELOG.md:1793
msgid "🐛 FIX: Nested namespaces in `ProcessBuilderNamespace` by @sphuber in [#4983](https://github.com/aiidateam/aiida-core/pull/4983)"
msgstr ""

#: ../../../CHANGELOG.md:1794
msgid "🐛 FIX: Ensure `ProcessBuilder` instances do not interfere  by @sphuber in [#4984](https://github.com/aiidateam/aiida-core/pull/4984)"
msgstr ""

#: ../../../CHANGELOG.md:1795
msgid "🐛 FIX: Raise when `Process.exposed_outputs` gets non-existing `namespace` by @sphuber in [#5265](https://github.com/aiidateam/aiida-core/pull/5265)"
msgstr ""

#: ../../../CHANGELOG.md:1796
msgid "🐛 FIX: Catch `AttributeError` for unloadable identifier in `ProcessNode.is_valid_cache` by @sphuber in [#5222](https://github.com/aiidateam/aiida-core/pull/5222)"
msgstr ""

#: ../../../CHANGELOG.md:1797
msgid "🐛 FIX: Handle `CalcInfo.codes_run_mode` when `CalcInfo.codes_info` contains multiple codes by @unkcpz in [#4990](https://github.com/aiidateam/aiida-core/pull/4990)"
msgstr ""

#: ../../../CHANGELOG.md:1798
msgid "🐛 FIX: Check for recycled circus PID by @dev-zero in [#5086](https://github.com/aiidateam/aiida-core/pull/4858)"
msgstr ""

#: ../../../CHANGELOG.md:1800
msgid "Scheduler/Transport:"
msgstr ""

#: ../../../CHANGELOG.md:1801
msgid "👌 IMPROVE: Specify abstract methods on `Transport` by @chrisjsewell in [#5242](https://github.com/aiidateam/aiida-core/pull/5242)"
msgstr ""

#: ../../../CHANGELOG.md:1802
msgid "✨ NEW: Add support for SSH proxy_jump by @dev-zero in [#4951](https://github.com/aiidateam/aiida-core/pull/4951)"
msgstr ""

#: ../../../CHANGELOG.md:1803
msgid "🐛 FIX: Daemon hang when passing `None` as `job_id` by @ramirezfranciscof in [#4967](https://github.com/aiidateam/aiida-core/pull/4967)"
msgstr ""

#: ../../../CHANGELOG.md:1804
msgid "🐛 FIX: Avoid deadlocks when retrieving stdout/stderr via SSH by @giovannipizzi in [#3787](https://github.com/aiidateam/aiida-core/pull/3787)"
msgstr ""

#: ../../../CHANGELOG.md:1805
msgid "🐛 FIX: Use sanitised variable name in SGE scheduler job title by @mjclarke94 in [#4994](https://github.com/aiidateam/aiida-core/pull/4994)"
msgstr ""

#: ../../../CHANGELOG.md:1806
msgid "🐛 FIX: `listdir` method with pattern for SSH by @giovannipizzi in [#5252](https://github.com/aiidateam/aiida-core/pull/5252)"
msgstr ""

#: ../../../CHANGELOG.md:1807
msgid "👌 IMPROVE: `DirectScheduler`: use `num_cores_per_mpiproc` if defined in resources by @sphuber in [#5126](https://github.com/aiidateam/aiida-core/pull/5126)"
msgstr ""

#: ../../../CHANGELOG.md:1808
msgid "👌 IMPROVE: Add abstract generation of submit script env variables to `Scheduler` by @sphuber in [#5283](https://github.com/aiidateam/aiida-core/pull/5283)"
msgstr ""

#: ../../../CHANGELOG.md:1810
msgid "CLI:"
msgstr ""

#: ../../../CHANGELOG.md:1811
msgid "✨ NEW: Allow for CLI usage via `python -m aiida` by @chrisjsewell in [#5356](https://github.com/aiidateam/aiida-core/pull/5356)"
msgstr ""

#: ../../../CHANGELOG.md:1812
msgid "⬆️ UPDATE: `click==8.0` and remove `click-completion` by @sphuber in [#5111](https://github.com/aiidateam/aiida-core/pull/5111)"
msgstr ""

#: ../../../CHANGELOG.md:1813
msgid "♻️ REFACTOR: Replace `verdi database` commands with `verdi storage` by @ramirezfranciscof in [#5228](https://github.com/aiidateam/aiida-core/pull/5228)"
msgstr ""

#: ../../../CHANGELOG.md:1814
msgid "✨ NEW: Add verbosity control by @sphuber in [#5085](https://github.com/aiidateam/aiida-core/pull/5085)"
msgstr ""

#: ../../../CHANGELOG.md:1815
msgid "♻️ REFACTOR: Logging verbosity implementation by @sphuber in [#5119](https://github.com/aiidateam/aiida-core/pull/5119)"
msgstr ""

#: ../../../CHANGELOG.md:1816
msgid "✨ NEW: Add `verdi group move-nodes` command by @mbercx in [#4428](https://github.com/aiidateam/aiida-core/pull/4428)"
msgstr ""

#: ../../../CHANGELOG.md:1817
msgid "👌 IMPROVE: `verdi code setup`: validate the uniqueness of label for local codes by @sphuber in [#5215](https://github.com/aiidateam/aiida-core/pull/5215)"
msgstr ""

#: ../../../CHANGELOG.md:1818
msgid "👌 IMPROVE: `GroupParamType`: store group if created by @sphuber in [#5411](https://github.com/aiidateam/aiida-core/pull/5411)"
msgstr ""

#: ../../../CHANGELOG.md:1819
msgid "👌 IMPROVE: Show #procs/machine in `verdi computer show` by @dev-zero in [#4945](https://github.com/aiidateam/aiida-core/pull/4945)"
msgstr ""

#: ../../../CHANGELOG.md:1820
msgid "👌 IMPROVE: Notify users of runner usage in `verdi process list` by @ltalirz in [#4663](https://github.com/aiidateam/aiida-core/pull/4663)"
msgstr ""

#: ../../../CHANGELOG.md:1821
msgid "👌 IMPROVE: Set `localhost` as default for database hostname in `verdi setup` by @sphuber in [#4908](https://github.com/aiidateam/aiida-core/pull/4908)"
msgstr ""

#: ../../../CHANGELOG.md:1822
msgid "👌 IMPROVE: Make `verdi group` messages consistent by @CasperWA in [#4999](https://github.com/aiidateam/aiida-core/pull/4999)"
msgstr ""

#: ../../../CHANGELOG.md:1823
msgid "🐛 FIX: `verdi calcjob cleanworkdir` command by @zhubonan in [#5209](https://github.com/aiidateam/aiida-core/pull/5209)"
msgstr ""

#: ../../../CHANGELOG.md:1824
msgid "🔧 MAINTAIN: Add `verdi devel run-sql` by @chrisjsewell in [#5094](https://github.com/aiidateam/aiida-core/pull/5094)"
msgstr ""

#: ../../../CHANGELOG.md:1826
msgid "REST API:"
msgstr ""

#: ../../../CHANGELOG.md:1827
msgid "⬆️ UPDATE: Update to `flask~=2.0` for `rest` extra by @sphuber in [#5366](https://github.com/aiidateam/aiida-core/pull/5366)"
msgstr ""

#: ../../../CHANGELOG.md:1828
msgid "👌 IMPROVE: Error message when flask not installed by @ltalirz in [#5398](https://github.com/aiidateam/aiida-core/pull/5398)"
msgstr ""

#: ../../../CHANGELOG.md:1829
msgid "👌 IMPROVE: Allow serving of contents of `ArrayData` by @JPchico in [#5425](https://github.com/aiidateam/aiida-core/pull/5425)"
msgstr ""

#: ../../../CHANGELOG.md:1830
msgid "🐛 FIX: REST API date-time query by @NinadBhat in [#4959](https://github.com/aiidateam/aiida-core/pull/4959)"
msgstr ""

#: ../../../CHANGELOG.md:1832
msgid "Developers:"
msgstr ""

#: ../../../CHANGELOG.md:1833
msgid "🔧 MAINTAIN: Move to flit for PEP 621 compliant package build by @chrisjsewell in [#5312](https://github.com/aiidateam/aiida-core/pull/5312)"
msgstr ""

#: ../../../CHANGELOG.md:1834
msgid "🔧 MAINTAIN: Make `__all__` imports explicit by @chrisjsewell in [#5061](https://github.com/aiidateam/aiida-core/pull/5061)"
msgstr ""

#: ../../../CHANGELOG.md:1835
msgid "🔧 MAINTAIN: Add `pre-commit.ci` by @chrisjsewell in [#5062](https://github.com/aiidateam/aiida-core/pull/5062)"
msgstr ""

#: ../../../CHANGELOG.md:1836
msgid "🔧 MAINTAIN: Add isort pre-commit hook by @chrisjsewell in [#5151](https://github.com/aiidateam/aiida-core/pull/5151)"
msgstr ""

#: ../../../CHANGELOG.md:1837
msgid "⬆️ UPDATE: Drop support for Python 3.7 by @sphuber in [#5307](https://github.com/aiidateam/aiida-core/pull/5307)"
msgstr ""

#: ../../../CHANGELOG.md:1838
msgid "⬆️ UPDATE: Support Python 3.10 by @csadorf in [#5188](https://github.com/aiidateam/aiida-core/pull/5188)"
msgstr ""

#: ../../../CHANGELOG.md:1839
msgid "♻️ REFACTOR: Remove `reentry` requirement by @chrisjsewell in [#5058](https://github.com/aiidateam/aiida-core/pull/5058)"
msgstr ""

#: ../../../CHANGELOG.md:1840
msgid "♻️ REFACTOR: Remove `simplejson` by @sphuber in [#5391](https://github.com/aiidateam/aiida-core/pull/5391)"
msgstr ""

#: ../../../CHANGELOG.md:1841
msgid "♻️ REFACTOR: Remove `ete3` dependency by @ltalirz in [#4956](https://github.com/aiidateam/aiida-core/pull/4956)"
msgstr ""

#: ../../../CHANGELOG.md:1842
msgid "👌 IMPROVE: Replace deprecated imp with importlib by @DirectriX01 in [#4848](https://github.com/aiidateam/aiida-core/pull/4848)"
msgstr ""

#: ../../../CHANGELOG.md:1843
msgid "⬆️ UPDATE: `sphinx~=4.1` (+ sphinx extensions) by @chrisjsewell in [#5420](https://github.com/aiidateam/aiida-core/pull/5420)"
msgstr ""

#: ../../../CHANGELOG.md:1844
msgid "🧪 CI: Move time consuming tests to separate nightly workflow by @sphuber in [#5354](https://github.com/aiidateam/aiida-core/pull/5354)"
msgstr ""

#: ../../../CHANGELOG.md:1845
msgid "🧪 TESTS: Entirely remove `AiidaTestCase` by @chrisjsewell in [#5372](https://github.com/aiidateam/aiida-core/pull/5372)"
msgstr ""

#: ../../../CHANGELOG.md:1847
msgid "Contributors 🎉"
msgstr ""

#: ../../../CHANGELOG.md:1849
msgid "Thanks to all contributors: [Contributor Graphs](https://github.com/aiidateam/aiida-core/graphs/contributors?from=2021-01-01&to=2022-15-03&type=c)"
msgstr ""

#: ../../../CHANGELOG.md:1851
msgid "Including first-time contributors:"
msgstr ""

#: ../../../CHANGELOG.md:1853
msgid "@DirectriX01 made their first contribution in [[#4848]](https://github.com/aiidateam/aiida-core/pull/4848)"
msgstr ""

#: ../../../CHANGELOG.md:1854
msgid "@mjclarke94 made their first contribution in [[#4994]](https://github.com/aiidateam/aiida-core/pull/4994)"
msgstr ""

#: ../../../CHANGELOG.md:1855
msgid "@janssenhenning made their first contribution in [[#5064]](https://github.com/aiidateam/aiida-core/pull/5064)"
msgstr ""

#: ../../../CHANGELOG.md:1858
msgid "v1.6.7 - 2022-03-07"
msgstr ""

#: ../../../CHANGELOG.md:1860
msgid "[full changelog](https://github.com/aiidateam/aiida-core/compare/v1.6.6...v1.6.7)"
msgstr ""

#: ../../../CHANGELOG.md:1862
msgid "The `markupsafe` dependency specification was moved to `install_requires`"
msgstr ""

#: ../../../CHANGELOG.md:1865
msgid "v1.6.6 - 2022-03-07"
msgstr ""

#: ../../../CHANGELOG.md:1867
msgid "[full changelog](https://github.com/aiidateam/aiida-core/compare/v1.6.5...v1.6.6)"
msgstr ""

#: ../../../CHANGELOG.md:1869
msgid "Bug fixes 🐛"
msgstr ""

#: ../../../CHANGELOG.md:1871
msgid "`DirectScheduler`: remove the `-e` option for bash invocation [[#5264]](https://github.com/aiidateam/aiida-core/pull/5264)"
msgstr ""

#: ../../../CHANGELOG.md:1872
msgid "Replace deprecated matplotlib config option 'text.latex.preview' [[#5233]](https://github.com/aiidateam/aiida-core/pull/5233)"
msgstr ""

#: ../../../CHANGELOG.md:1876
msgid "Add upper limit `markupsafe<2.1` to fix the documentation build [[#5371]](https://github.com/aiidateam/aiida-core/pull/5371)"
msgstr ""

#: ../../../CHANGELOG.md:1877
msgid "Add upper limit `pytest-asyncio<0.17` [[#5309]](https://github.com/aiidateam/aiida-core/pull/5309)"
msgstr ""

#: ../../../CHANGELOG.md:1879
msgid "Devops 🔧"
msgstr ""

#: ../../../CHANGELOG.md:1881
msgid "CI: move Jenkins workflow to nightly GHA workflow [[#5277]](https://github.com/aiidateam/aiida-core/pull/5277)"
msgstr ""

#: ../../../CHANGELOG.md:1882
msgid "Docs: replace CircleCI build with ReadTheDocs [[#5279]](https://github.com/aiidateam/aiida-core/pull/5279)"
msgstr ""

#: ../../../CHANGELOG.md:1883
msgid "CI: run certain workflows only on main repo, not on forks [[#5091]](https://github.com/aiidateam/aiida-core/pull/5091)"
msgstr ""

#: ../../../CHANGELOG.md:1884
msgid "Revise Docker image build [[#4997]](https://github.com/aiidateam/aiida-core/pull/4997)"
msgstr ""

#: ../../../CHANGELOG.md:1887
msgid "v1.6.5 - 2021-08-13"
msgstr ""

#: ../../../CHANGELOG.md:1889
msgid "[full changelog](https://github.com/aiidateam/aiida-core/compare/v1.6.4...v1.6.5)"
msgstr ""

#: ../../../CHANGELOG.md:1891
msgid "This patch release contains a number of helpful bug fixes and improvements."
msgstr ""

#: ../../../CHANGELOG.md:1893
msgid "Improvements 👌"
msgstr ""

#: ../../../CHANGELOG.md:1895
msgid "Add support for the `ProxyJump` SSH config option for seting up an arbitrary number of proxy jumps without additional processes by creating TCP channels over existing SSH connections. This provides improved control over the lifetime of the different connections. See [SSH configuration](docs/source/howto/ssh.rst) for further details. [[#4951]](https://github.com/aiidateam/aiida-core/pull/4951)"
msgstr ""

#: ../../../CHANGELOG.md:1898
msgid "Allow numpy arrays to be serialized to a process checkpoint. [[#4730)]](https://github.com/aiidateam/aiida-core/pull/4730))"
msgstr ""

#: ../../../CHANGELOG.md:1899
msgid "Add the `_merge` method to `ProcessBuilder`, to update the builder with a nested dictionary. [[#4983)]](https://github.com/aiidateam/aiida-core/pull/4983))"
msgstr ""

#: ../../../CHANGELOG.md:1900
msgid "`verdi setup`: Set the defaut database hostname as `localhost`. [[#4908]](https://github.com/aiidateam/aiida-core/pull/4908)"
msgstr ""

#: ../../../CHANGELOG.md:1901
msgid "Allow `Node.__init__` to be constructed with a specific `User` node. [[#4977]](https://github.com/aiidateam/aiida-core/pull/4977)"
msgstr ""

#: ../../../CHANGELOG.md:1902
msgid "Minimize database logs of failed schema version retrievals. [[#5056]](https://github.com/aiidateam/aiida-core/pull/5056)"
msgstr ""

#: ../../../CHANGELOG.md:1903
msgid "Remove duplicate call of normal `callback` for `InteractiveOption`. [[#5064]](https://github.com/aiidateam/aiida-core/pull/5064)"
msgstr ""

#: ../../../CHANGELOG.md:1904
msgid "Update requirement `pyyaml~=5.4`, which contains critical security fixes. [[#5060]](https://github.com/aiidateam/aiida-core/pull/5060)"
msgstr ""

#: ../../../CHANGELOG.md:1906
msgid "Bug Fixes 🐛"
msgstr ""

#: ../../../CHANGELOG.md:1908
msgid "Fix regression issue with `__contains__` operator in `LinkManager`, when using double underscores, e.g. for `'some__nested__namespace' in calc.inputs`. [#5067](https://github.com/aiidateam/aiida-core/pull/5067)"
msgstr ""

#: ../../../CHANGELOG.md:1909
msgid "Stop deprecation warning being shown when tab-completing incoming and outgoing node links. [[#5011]](https://github.com/aiidateam/aiida-core/pull/5011)"
msgstr ""

#: ../../../CHANGELOG.md:1910
msgid "Stop possible command hints being shown when attempting to tab complete `verdi` commands that do not exist. [[#5012]](https://github.com/aiidateam/aiida-core/pull/5012)"
msgstr ""

#: ../../../CHANGELOG.md:1911
msgid "Do not use `get_detailed_job_info` when retrieving a calculation job, if no job id is set. [[#4967]](https://github.com/aiidateam/aiida-core/pull/4967)"
msgstr ""

#: ../../../CHANGELOG.md:1912
msgid "Race condition when two processes try to create the same `Folder`/`SandboxFolder`, [[#4912]](https://github.com/aiidateam/aiida-core/pull/4912)"
msgstr ""

#: ../../../CHANGELOG.md:1913
msgid "Return the whole nested namespace when using `BaseRestartWorkChain.result`. [[#4961]](https://github.com/aiidateam/aiida-core/pull/4961)"
msgstr ""

#: ../../../CHANGELOG.md:1914
msgid "Use `numpy.nanmin` and `numpy.nanmax` for computing y-limits of `BandsData` matplotlib methods. [[#5024]](https://github.com/aiidateam/aiida-core/pull/5024)"
msgstr ""

#: ../../../CHANGELOG.md:1915
msgid "Use sanitized job title with `SgeScheduler` scheduler. [[#4994]](https://github.com/aiidateam/aiida-core/pull/4994)"
msgstr ""

#: ../../../CHANGELOG.md:1917
msgid "v1.6.4 - 2021-06-23"
msgstr ""

#: ../../../CHANGELOG.md:1919
msgid "[full changelog](https://github.com/aiidateam/aiida-core/compare/v1.6.3...v1.6.4)"
msgstr ""

#: ../../../CHANGELOG.md:1921
msgid "This is a patch release to pin `psycopg2-binary` to version 2.8.x, to avoid an issue with database creation in version 2.9 ([#4989](https://github.com/aiidateam/aiida-core/pull/4989))."
msgstr ""

#: ../../../CHANGELOG.md:1923
msgid "v1.6.3 - 2021-04-28"
msgstr ""

#: ../../../CHANGELOG.md:1925
msgid "[full changelog](https://github.com/aiidateam/aiida-core/compare/v1.6.2...v1.6.3) | [GitHub contributors page for this release](https://github.com/aiidateam/aiida-core/graphs/contributors?from=2021-04-281&to=2021-04-28&type=c)"
msgstr ""

#: ../../../CHANGELOG.md:1927
msgid "This is a patch release to fix a bug that was introduced in `v1.6.2` that would cause a number of `verdi` commands to fail due to a bug in the `with_dbenv` decorator utility."
msgstr ""

#: ../../../CHANGELOG.md:1929
#: ../../../CHANGELOG.md:1937
#: ../../../CHANGELOG.md:2078
#: ../../../CHANGELOG.md:2114
#: ../../../CHANGELOG.md:2153
#: ../../../CHANGELOG.md:2162
#: ../../../CHANGELOG.md:2178
#: ../../../CHANGELOG.md:2203
#: ../../../CHANGELOG.md:2259
#: ../../../CHANGELOG.md:2299
#: ../../../CHANGELOG.md:2323
#: ../../../CHANGELOG.md:2362
#: ../../../CHANGELOG.md:2407
#: ../../../CHANGELOG.md:2447
msgid "Bug fixes"
msgstr ""

#: ../../../CHANGELOG.md:1930
msgid "Fix `aiida.cmdline.utils.decorators.load_backend_if_not_loaded` [[#4878]](https://github.com/aiidateam/aiida-core/pull/4878)"
msgstr ""

#: ../../../CHANGELOG.md:1933
msgid "v1.6.2 - 2021-04-28"
msgstr ""

#: ../../../CHANGELOG.md:1935
msgid "[full changelog](https://github.com/aiidateam/aiida-core/compare/v1.6.1...v1.6.2) | [GitHub contributors page for this release](https://github.com/aiidateam/aiida-core/graphs/contributors?from=2021-03-31&to=2021-04-27&type=c)"
msgstr ""

#: ../../../CHANGELOG.md:1938
msgid "CLI: Use the proper proxy command for `verdi calcjob gotocomputer` if configured as such [[#4761]](https://github.com/aiidateam/aiida-core/pull/4761)"
msgstr ""

#: ../../../CHANGELOG.md:1939
msgid "Respect nested output namespaces in `Process.exposed_outputs` [[#4863]](https://github.com/aiidateam/aiida-core/pull/4863)"
msgstr ""

#: ../../../CHANGELOG.md:1940
msgid "`NodeLinkManager` now properly regenerates original nested namespaces from the flat link labels stored in the database. This means one can now do `node.outputs.some.nested.output` instead of having to do `node.outputs.some__nested__output`. The same goes for `node.inputs` [[#4625]](https://github.com/aiidateam/aiida-core/pull/4625)"
msgstr ""

#: ../../../CHANGELOG.md:1941
msgid "Fix `aiida.cmdline.utils.decorators.with_dbenv` always loading the database. Now it will only load the database if not already loaded, as intended [[#4865]](https://github.com/aiidateam/aiida-core/pull/4865)"
msgstr ""

#: ../../../CHANGELOG.md:1944
msgid "Add the `account` option to the `LsfScheduler` scheduler plugin [[#4832]](https://github.com/aiidateam/aiida-core/pull/4832)"
msgstr ""

#: ../../../CHANGELOG.md:1947
msgid "Update ssh proxycommand section with instructions on how to handle cases where the SSH key needs to be specified for the proxy server [[#4839]](https://github.com/aiidateam/aiida-core/pull/4839)"
msgstr ""

#: ../../../CHANGELOG.md:1948
msgid "Add the [\"How to extend workflows\"](https://aiida-core.readthedocs.io/en/latest/howto/write_workflows.html#extending-workflows) section, explaining the use of the `expose_inputs` and `expose_outputs` features, as well as nested namespaces [[#4562]](https://github.com/aiidateam/aiida-core/pull/4562)"
msgstr ""

#: ../../../CHANGELOG.md:1949
msgid "Add help in intro for when quicksetup fails due to problems autodetecting the PostgreSQL settings [[#4838]](https://github.com/aiidateam/aiida-core/pull/4838)"
msgstr ""

#: ../../../CHANGELOG.md:1952
msgid "v1.6.1 - 2021-03-31"
msgstr ""

#: ../../../CHANGELOG.md:1954
msgid "[full changelog](https://github.com/aiidateam/aiida-core/compare/v1.6.0...v1.6.1) | [GitHub contributors page for this release](https://github.com/aiidateam/aiida-core/graphs/contributors?from=2021-03-15&to=2021-03-31&type=c)"
msgstr ""

#: ../../../CHANGELOG.md:1956
msgid "This patch release is primarily intended to fix a regression in the `aiida_profile` test fixture, used by plugin developers, causing config validation errors ([#4831](https://github.com/aiidateam/aiida-core/pull/4831))."
msgstr ""

#: ../../../CHANGELOG.md:1958
msgid "Other additions:"
msgstr ""

#: ../../../CHANGELOG.md:1960
msgid "✨ NEW: Added `structure.data.import` entry-point, allowing for plugins to define file-format specific sub-commands of `verdi data structure import` ([#4427](https://github.com/aiidateam/aiida-core/pull/4427))."
msgstr ""

#: ../../../CHANGELOG.md:1961
msgid "✨ NEW: Added `--label` and `--group` options to `verdi data structure import`, which apply a label/group to all structures being imported ([#4429](https://github.com/aiidateam/aiida-core/pull/4429))."
msgstr ""

#: ../../../CHANGELOG.md:1962
msgid "⬆️ UPDATE: `psgu` dependency increased to `v0.2.x`. This fixes a bug in `verdi quicksetup`, when used on the Windows Subsystem for Linux (WSL) platform ([#4834](https://github.com/aiidateam/aiida-core/pull/4834))."
msgstr ""

#: ../../../CHANGELOG.md:1964
msgid "🐛 FIX: `metadata.options.max_memory_kb` is now ignored when using the direct scheduler ([#4825](https://github.com/aiidateam/aiida-core/pull/4825)). This was previously imposing a a virtual memory limit with `ulimit -v`, which is very different to the physical memory limit that other scheduler plugins impose. No straightforward way exists to directly limit the physical memory usage for this scheduler."
msgstr ""

#: ../../../CHANGELOG.md:1966
msgid "🐛 FIX: Added `__str__` method to the `Orbital` class, fixing a recursion error ([#4829](https://github.com/aiidateam/aiida-core/pull/4829))."
msgstr ""

#: ../../../CHANGELOG.md:1968
msgid "v1.6.0 - 2021-03-15"
msgstr ""

#: ../../../CHANGELOG.md:1970
msgid "[full changelog](https://github.com/aiidateam/aiida-core/compare/v1.5.2...v1.6.0) | [GitHub contributors page for this release](https://github.com/aiidateam/aiida-core/graphs/contributors?from=2020-12-07&to=2021-03-15&type=c)"
msgstr ""

#: ../../../CHANGELOG.md:1972
msgid "As well as introducing a number of improvements and new features listed below, this release marks the \"under-the-hood\" migration from the `tornado` package to the Python built-in module `asyncio`, for handling asynchronous processing within the AiiDA engine. This removes a number of blocking dependency version clashes with other tools, in particular with the newest Jupyter shell and notebook environments. The migration does not present any backward incompatible changes to AiiDA's public API. A substantial effort has been made to test and debug the new implementation, and ensure it performs at least equivalent to the previous code (or improves it!), but please let us know if you uncover any additional issues."
msgstr ""

#: ../../../CHANGELOG.md:1977
msgid "This release also drops support for Python 3.6 (testing is carried out against `3.7`, `3.8` and `3.9`)."
msgstr ""

#: ../../../CHANGELOG.md:1979
msgid "NOTE: `v1.6` is tentatively intended to be the final minor `v1.x` release before `v2.x`, that will include a new file repository implementation and remove all deprecated code."
msgstr ""

#: ../../../CHANGELOG.md:1981
msgid "New calculation features ✨"
msgstr ""

#: ../../../CHANGELOG.md:1983
msgid "The `additional_retrieve_list` metadata option has been added to `CalcJob` ([#4437](https://github.com/aiidateam/aiida-core/pull/4437)). This new option allows one to specify additional files to be retrieved on a per-instance basis, in addition to the files that are already defined by the plugin to be retrieved."
msgstr ""

#: ../../../CHANGELOG.md:1986
msgid "A **new namespace `stash`** has bee added to the `metadata.options` input namespace of the `CalcJob` process ([#4424](https://github.com/aiidateam/aiida-core/pull/4424)). This option namespace allows a user to specify certain files that are created by the calculation job to be stashed somewhere on the remote. This can be useful if those files need to be stored for a longer time than the scratch space (where the job was run) is available for, but need to be kept on the remote machine and not retrieved. Examples are files that are necessary to restart a calculation but are too big to be retrieved and stored permanently in the local file repository."
msgstr ""

#: ../../../CHANGELOG.md:1991
msgid "See [Stashing files on the remote](https://aiida.readthedocs.io/projects/aiida-core/en/v1.6.0/topics/calculations/usage.html#stashing-files-on-the-remote) for more details."
msgstr ""

#: ../../../CHANGELOG.md:1993
msgid "The **new `TransferCalcjob` plugin** ([#4194](https://github.com/aiidateam/aiida-core/pull/4194)) allows the user to copy files between a remote machine and the local machine running AiiDA. More specifically, it can do any of the following:"
msgstr ""

#: ../../../CHANGELOG.md:1996
msgid "Take any number of files from any number of `RemoteData` folders in a remote machine and copy them in the local repository of a single newly created `FolderData` node."
msgstr ""

#: ../../../CHANGELOG.md:1997
msgid "Take any number of files from any number of `FolderData` nodes in the local machine and copy them in a single newly created `RemoteData` folder in a given remote machine."
msgstr ""

#: ../../../CHANGELOG.md:1999
msgid "See the [Transferring data](https://aiida.readthedocs.io/projects/aiida-core/en/v1.6.0/howto/data.html#transferring-data) how-to for more details."
msgstr ""

#: ../../../CHANGELOG.md:2001
msgid "Profile configuration improvements 👌"
msgstr ""

#: ../../../CHANGELOG.md:2003
msgid "The way the global/profile configuration is accessed has undergone a number of distinct changes ([#4712](https://github.com/aiidateam/aiida-core/pull/4712)):"
msgstr ""

#: ../../../CHANGELOG.md:2005
msgid "When loaded, the `config.json` (found in the `.aiida` folder) is now validated against a [JSON Schema](https://json-schema.org/) that can be found in [`aiida/manage/configuration/schema`](https://github.com/aiidateam/aiida-core/tree/develop/aiida/manage/configuration/schema)."
msgstr ""

#: ../../../CHANGELOG.md:2006
msgid "The schema includes a number of new global/profile options, including: `transport.task_retry_initial_interval`, `transport.task_maximum_attempts`, `rmq.task_timeout` and `logging.aiopika_loglevel` ([#4583](https://github.com/aiidateam/aiida-core/pull/4583))."
msgstr ""

#: ../../../CHANGELOG.md:2007
msgid "The `cache_config.yml` has now also been **deprecated** and merged into the `config.json`, as part of the profile options. This merge will be handled automatically, upon first load of the `config.json` using the new AiiDA version."
msgstr ""

#: ../../../CHANGELOG.md:2010
msgid "In-line with these changes, the `verdi config` command has been refactored into separate commands, including `verdi config list`, `verdi config set`, `verdi config unset` and `verdi config caching`."
msgstr ""

#: ../../../CHANGELOG.md:2012
msgid "See the [Configuring profile options](https://aiida.readthedocs.io/projects/aiida-core/en/v1.6.0/howto/installation.html#configuring-profile-options) and [Configuring caching](https://aiida.readthedocs.io/projects/aiida-core/en/v1.6.0/howto/run_codes.html#how-to-save-compute-time-with-caching) how-tos for more details."
msgstr ""

#: ../../../CHANGELOG.md:2014
msgid "Command-line additions and improvements 👌"
msgstr ""

#: ../../../CHANGELOG.md:2016
msgid "In addition to `verdi config`, numerous other new commands and options have been added to `verdi`:"
msgstr ""

#: ../../../CHANGELOG.md:2018
msgid "**Deprecated** `verdi export` and `verdi import` commands (replaced by new `verdi archive`) ([#4710](https://github.com/aiidateam/aiida-core/pull/4710))"
msgstr ""

#: ../../../CHANGELOG.md:2019
msgid "Added `verdi group delete --delete-nodes`, to also delete the nodes in a group during its removal ([#4578](https://github.com/aiidateam/aiida-core/pull/4578))."
msgstr ""

#: ../../../CHANGELOG.md:2020
msgid "Improved `verdi group remove-nodes` command to warn when requested nodes are not in the specified group ([#4728](https://github.com/aiidateam/aiida-core/pull/4728))."
msgstr ""

#: ../../../CHANGELOG.md:2021
msgid "Added `exception` to the projection mapping of `verdi process list`, for example to use in debugging as: `verdi process list -S excepted -P ctime pk exception` ([#4786](https://github.com/aiidateam/aiida-core/pull/4786))."
msgstr ""

#: ../../../CHANGELOG.md:2022
msgid "Added `verdi database summary` ([#4737](https://github.com/aiidateam/aiida-core/pull/4737)): This prints a summary of the count of each entity and (optionally) the list of unique identifiers for some entities."
msgstr ""

#: ../../../CHANGELOG.md:2024
msgid "Improved `verdi process play` performance, by only querying for active processes with the `--all` flag ([#4671](https://github.com/aiidateam/aiida-core/pull/4671))"
msgstr ""

#: ../../../CHANGELOG.md:2025
msgid "Added the `verdi database version` command ([#4613](https://github.com/aiidateam/aiida-core/pull/4613)): This shows the schema generation and version of the database of the given profile, useful mostly for developers when debugging."
msgstr ""

#: ../../../CHANGELOG.md:2027
msgid "Improved `verdi node delete` performance ([#4575](https://github.com/aiidateam/aiida-core/pull/4575)): The logic has been re-written to greatly reduce the time to delete large amounts of nodes."
msgstr ""

#: ../../../CHANGELOG.md:2029
msgid "Fixed `verdi quicksetup --non-interactive`, to ensure it does not include any user prompts ([#4573](https://github.com/aiidateam/aiida-core/pull/4573))"
msgstr ""

#: ../../../CHANGELOG.md:2030
msgid "Fixed `verdi --version` when used in editable mode ([#4576](https://github.com/aiidateam/aiida-core/pull/4576))"
msgstr ""

#: ../../../CHANGELOG.md:2032
msgid "API additions and improvements 👌"
msgstr ""

#: ../../../CHANGELOG.md:2034
msgid "The base `Node` class now evaluates equality based on the node's UUID ([#4753](https://github.com/aiidateam/aiida-core/pull/4753)). For example, loading the same node twice will always resolve as equivalent: `load_node(1) == load_node(1)`. Note that existing, class specific, equality relationships will still override the base class behaviour, for example: `Int(99) == Int(99)`, even if the nodes have different UUIDs. This behaviour for subclasses is still under discussion at: <https://github.com/aiidateam/aiida-core/issues/1917>"
msgstr ""

#: ../../../CHANGELOG.md:2039
msgid "When hashing nodes for use with the caching features, `-0.` is now converted to `0.`, to reduce issues with differing hashes before/after node storage ([#4648](https://github.com/aiidateam/aiida-core/pull/4648)). Known failure modes for hashing are now also raised with the `HashingError` exception ([#4778](https://github.com/aiidateam/aiida-core/pull/4778))."
msgstr ""

#: ../../../CHANGELOG.md:2042
msgid "Both `aiida.tools.delete_nodes` ([#4578](https://github.com/aiidateam/aiida-core/pull/4578)) and `aiida.orm.to_aiida_type` ([#4672](https://github.com/aiidateam/aiida-core/pull/4672)) have been exposed for use in the public API."
msgstr ""

#: ../../../CHANGELOG.md:2044
msgid "A `pathlib.Path` instance can now be used for the `file` argument of `SinglefileData` ([#3614](https://github.com/aiidateam/aiida-core/pull/3614))"
msgstr ""

#: ../../../CHANGELOG.md:2046
msgid "Type annotations have been added to all inputs/outputs of functions and methods in `aiida.engine` ([#4669](https://github.com/aiidateam/aiida-core/pull/4669)) and `aiida/orm/nodes/processes` ([#4772](https://github.com/aiidateam/aiida-core/pull/4772)). As outlined in [PEP 484](https://www.python.org/dev/peps/pep-0484/), this improves static code analysis and, for example, allows for better auto-completion and type checking in many code editors."
msgstr ""

#: ../../../CHANGELOG.md:2049
msgid "New REST API Query endpoint ✨"
msgstr ""

#: ../../../CHANGELOG.md:2051
msgid "The `/querybuilder` endpoint is the first POST method available for AiiDA's RESTful API ([#4337](https://github.com/aiidateam/aiida-core/pull/4337))"
msgstr ""

#: ../../../CHANGELOG.md:2053
msgid "The POST endpoint returns what the QueryBuilder would return, when providing it with a proper `queryhelp` dictionary ([see the documentation here](https://aiida.readthedocs.io/projects/aiida-core/en/latest/topics/database.html#the-queryhelp)). Furthermore, it returns the entities/results in the \"standard\" REST API format - with the exception of `link_type` and `link_label` keys for links (these particular keys are still present as `type` and `label`, respectively)."
msgstr ""

#: ../../../CHANGELOG.md:2056
msgid "For security, POST methods can be toggled on/off with the `verdi restapi --posting/--no-posting` options (it is on by default). Although note that this option is not yet strictly public, since its naming may be changed in the future!"
msgstr ""

#: ../../../CHANGELOG.md:2059
msgid "See [AiiDA REST API documentation](https://aiida.readthedocs.io/projects/aiida-core/en/latest/reference/rest_api.html) for more details."
msgstr ""

#: ../../../CHANGELOG.md:2061
msgid "Additional Changes"
msgstr ""

#: ../../../CHANGELOG.md:2063
msgid "Fixed the direct scheduler which, in combination with `SshTransport`, was hanging on submit command ([#4735](https://github.com/aiidateam/aiida-core/pull/4735)). In the ssh transport, to emulate 'chdir', the current directory is now kept in memory, and every command prepended with `cd FOLDER_NAME && ACTUALCOMMAND`."
msgstr ""

#: ../../../CHANGELOG.md:2066
msgid "In `aiida.tools.ipython.ipython_magics`, `load_ipython_extension` has been **deprecated** in favour of `register_ipython_extension` ([#4548](https://github.com/aiidateam/aiida-core/pull/4548))."
msgstr ""

#: ../../../CHANGELOG.md:2068
msgid "Refactored `.ci/` folder to make tests more portable and easier to understand ([#4565](https://github.com/aiidateam/aiida-core/pull/4565)) The `ci/` folder had become cluttered, containing configuration and scripts for both the GitHub Actions and Jenkins CI. This change moved the GH actions specific scripts to `.github/system_tests`, and refactored the Jenkins setup/tests to use [molecule](https://molecule.readthedocs.io) in the `.molecule/` folder."
msgstr ""

#: ../../../CHANGELOG.md:2072
msgid "For aiida-core development, the pytest `requires_rmq` marker and `config_with_profile` fixture have been added ([#4739](https://github.com/aiidateam/aiida-core/pull/4739) and [#4764](https://github.com/aiidateam/aiida-core/pull/4764))"
msgstr ""

#: ../../../CHANGELOG.md:2074
msgid "v1.5.2 - 2020-12-07"
msgstr ""

#: ../../../CHANGELOG.md:2076
msgid "Note: release `v1.5.1` was skipped due to a problem with the uploaded files to PyPI."
msgstr ""

#: ../../../CHANGELOG.md:2079
msgid "`Dict`: accessing an inexistent key now raises a `KeyError` (instead of `AttributeError`) [[#4577]](https://github.com/aiidateam/aiida-core/pull/4577)"
msgstr ""

#: ../../../CHANGELOG.md:2080
msgid "Config: make writing to disk as atomic as possible [[#4607]](https://github.com/aiidateam/aiida-core/pull/4607)"
msgstr ""

#: ../../../CHANGELOG.md:2081
msgid "Config: do not overwrite when loaded and not migrated [[#4605]](https://github.com/aiidateam/aiida-core/pull/4605)"
msgstr ""

#: ../../../CHANGELOG.md:2082
msgid "SqlAlchemy: fix bug in `Group` extras migration with revision `0edcdd5a30f0` [[#4602]](https://github.com/aiidateam/aiida-core/pull/4602)"
msgstr ""

#: ../../../CHANGELOG.md:2084
#: ../../../CHANGELOG.md:2122
#: ../../../CHANGELOG.md:2156
#: ../../../CHANGELOG.md:2212
#: ../../../CHANGELOG.md:2279
#: ../../../CHANGELOG.md:2341
#: ../../../CHANGELOG.md:2420
msgid "Developers"
msgstr ""

#: ../../../CHANGELOG.md:2085
msgid "SqlAlchemy: improve the alembic migration code [[#4602]](https://github.com/aiidateam/aiida-core/pull/4602) 4607"
msgstr ""

#: ../../../CHANGELOG.md:2087
#: ../../../CHANGELOG.md:2157
msgid "CI: manually install `numpy` to prevent incompatible releases [[#4615]](https://github.com/aiidateam/aiida-core/pull/4615)"
msgstr ""

#: ../../../CHANGELOG.md:2090
msgid "v1.5.0 - 2020-11-13"
msgstr ""

#: ../../../CHANGELOG.md:2092
msgid "In this minor version release, support for Python 3.9 is added [[#4301]](https://github.com/aiidateam/aiida-core/pull/4301), while support for Python 3.5 is dropped [[#4386]](https://github.com/aiidateam/aiida-core/pull/4386). This version is compatible with all current Python versions that are not end-of-life:"
msgstr ""

#: ../../../CHANGELOG.md:2094
#: ../../../CHANGELOG.md:2379
msgid "3.6"
msgstr ""

#: ../../../CHANGELOG.md:2095
#: ../../../CHANGELOG.md:2380
msgid "3.7"
msgstr ""

#: ../../../CHANGELOG.md:2096
#: ../../../CHANGELOG.md:2381
msgid "3.8"
msgstr ""

#: ../../../CHANGELOG.md:2097
msgid "3.9"
msgstr ""

#: ../../../CHANGELOG.md:2101
msgid "Process functions (`calcfunction` and `workfunction`) can now be submitted to the daemon just like `CalcJob`s and `WorkChain`s [[#4539]](https://github.com/aiidateam/aiida-core/pull/4539)"
msgstr ""

#: ../../../CHANGELOG.md:2102
msgid "REST API: list endpoints at base URL [[#4412]](https://github.com/aiidateam/aiida-core/pull/4412)"
msgstr ""

#: ../../../CHANGELOG.md:2103
msgid "REST API: new `full_types_count` endpoint that counts the number of nodes for each type of node [[#4277]](https://github.com/aiidateam/aiida-core/pull/4277)"
msgstr ""

#: ../../../CHANGELOG.md:2104
msgid "`ProcessBuilder`: allow unsetting of inputs through attribute deletion [[#4419]](https://github.com/aiidateam/aiida-core/pull/4419)"
msgstr ""

#: ../../../CHANGELOG.md:2105
msgid "`verdi migrate`: make `--in-place` work across different file systems [[#4393]](https://github.com/aiidateam/aiida-core/pull/4393)"
msgstr ""

#: ../../../CHANGELOG.md:2107
#: ../../../CHANGELOG.md:2175
#: ../../../CHANGELOG.md:2186
#: ../../../CHANGELOG.md:2240
#: ../../../CHANGELOG.md:2431
#: ../../../CHANGELOG.md:2613
#: ../../../CHANGELOG.md:2629
#: ../../../CHANGELOG.md:2654
#: ../../../CHANGELOG.md:2674
#: ../../../CHANGELOG.md:2687
#: ../../../CHANGELOG.md:2721
#: ../../../CHANGELOG.md:2731
#: ../../../CHANGELOG.md:2757
#: ../../../CHANGELOG.md:2775
#: ../../../CHANGELOG.md:2814
#: ../../../CHANGELOG.md:2842
#: ../../../CHANGELOG.md:2888
msgid "Improvements"
msgstr ""

#: ../../../CHANGELOG.md:2108
msgid "Added remaining original documentation that didn't make it into the first step of the recent major overhaul of v1.3.0"
msgstr ""

#: ../../../CHANGELOG.md:2109
msgid "`verdi process show`: order by ctime and print process label [[#4407]](https://github.com/aiidateam/aiida-core/pull/4407)"
msgstr ""

#: ../../../CHANGELOG.md:2110
msgid "`LinkManager`: fix inaccuracy in exception message for non-existent link [[#4388]](https://github.com/aiidateam/aiida-core/pull/4388)"
msgstr ""

#: ../../../CHANGELOG.md:2111
msgid "Add `reset` method to`ProgressReporterAbstract` [[#4522]](https://github.com/aiidateam/aiida-core/pull/4522)"
msgstr ""

#: ../../../CHANGELOG.md:2112
msgid "Improve the deprecation warning for `Node.open` outside context manager [[#4434]](https://github.com/aiidateam/aiida-core/pull/4434)"
msgstr ""

#: ../../../CHANGELOG.md:2115
msgid "`SlurmScheduler`: fix bug in validation of job resources [[#4555]](https://github.com/aiidateam/aiida-core/pull/4555)"
msgstr ""

#: ../../../CHANGELOG.md:2116
msgid "Fix `ZeroDivisionError` in worker slots check [[#4513]](https://github.com/aiidateam/aiida-core/pull/4513)"
msgstr ""

#: ../../../CHANGELOG.md:2117
msgid "`CalcJob`: only attempt to clean up the retrieve temporary folder after parsing if it is present [[#4379]](https://github.com/aiidateam/aiida-core/pull/4379)"
msgstr ""

#: ../../../CHANGELOG.md:2118
msgid "Add missing entry point groups to the mapping [[#4395]](https://github.com/aiidateam/aiida-core/pull/4395)"
msgstr ""

#: ../../../CHANGELOG.md:2119
msgid "REST API: the `process_type` can now identify pathological empty-stringed or null entries in the database [[#4277]](https://github.com/aiidateam/aiida-core/pull/4277)"
msgstr ""

#: ../../../CHANGELOG.md:2123
msgid "`verdi group delete`: deprecate and ignore the `--clear` option [[#4357]](https://github.com/aiidateam/aiida-core/pull/4357)"
msgstr ""

#: ../../../CHANGELOG.md:2124
msgid "Replace old format string interpolation with f-strings [[#4400]](https://github.com/aiidateam/aiida-core/pull/4400)"
msgstr ""

#: ../../../CHANGELOG.md:2125
msgid "CI: move `pylint` configuration to `pyproject.toml` [[#4411]](https://github.com/aiidateam/aiida-core/pull/4411)"
msgstr ""

#: ../../../CHANGELOG.md:2126
msgid "CI: use `-e` install for tox + add docker-compose for isolated RabbitMQ [[#4375]](https://github.com/aiidateam/aiida-core/pull/4375)"
msgstr ""

#: ../../../CHANGELOG.md:2127
msgid "CI: add coverage patch threshold to prevent false positives [[#4413]](https://github.com/aiidateam/aiida-core/pull/4413)"
msgstr ""

#: ../../../CHANGELOG.md:2128
msgid "CI: Allow for mypy type checking of third-party imports [[#4553]](https://github.com/aiidateam/aiida-core/pull/4553)"
msgstr ""

#: ../../../CHANGELOG.md:2131
msgid "Update requirement `pytest~=6.0` and use `pyproject.toml` [[#4410]](https://github.com/aiidateam/aiida-core/pull/4410)"
msgstr ""

#: ../../../CHANGELOG.md:2133
msgid "Archive (import/export) refactor"
msgstr ""

#: ../../../CHANGELOG.md:2134
msgid "The refactoring goal was to pave the way for the implementation of a new archive format in v2.0.0 ([ aiidateamAEP005](https://github.com/aiidateam/AEP/pull/21))"
msgstr ""

#: ../../../CHANGELOG.md:2135
msgid "Three abstract+concrete interface classes are defined; writer, reader, migrator, which are **independent of theinternal structure of the archive**. These classes are used within the export/import code."
msgstr ""

#: ../../../CHANGELOG.md:2136
msgid "The code in `aiida/tools/importexport` has been largely re-written, in particular adding `aiida/toolsimportexport/archive`, which contains this code for interfacing with an archive, and **does not require connectionto an AiiDA profile**."
msgstr ""

#: ../../../CHANGELOG.md:2137
msgid "The export logic has been re-written; to minimise required queries (faster), and to allow for \"streaming\" datainto the writer (minimise RAM requirement with new format). It is intended that a similiar PR will be made for the import code."
msgstr ""

#: ../../../CHANGELOG.md:2138
msgid "A general progress bar implementation is now available in `aiida/common/progress_reporter.py`. All correspondingCLI commands now also have `--verbosity` option."
msgstr ""

#: ../../../CHANGELOG.md:2139
msgid "Merged PRs:"
msgstr ""

#: ../../../CHANGELOG.md:2140
msgid "Refactor export archive ([#4448](https://github.com/aiidateam/aiida-core/pull/4448) & [#4534](https://github.com/aiidateam/aiida-core/pull/4534))"
msgstr ""

#: ../../../CHANGELOG.md:2141
msgid "Refactor import archive ([#4510](https://github.com/aiidateam/aiida-core/pull/4510))"
msgstr ""

#: ../../../CHANGELOG.md:2142
msgid "Refactor migrate archive ([#4532](https://github.com/aiidateam/aiida-core/pull/4532))"
msgstr ""

#: ../../../CHANGELOG.md:2143
msgid "Add group extras to archive ([#4521](https://github.com/aiidateam/aiida-core/pull/4521))"
msgstr ""

#: ../../../CHANGELOG.md:2144
msgid "Refactor cmdline progress bar ([#4504](https://github.com/aiidateam/aiida-core/pull/4504) & [#4522](https://github.com/aiidateam/aiida-core/pull/4522))"
msgstr ""

#: ../../../CHANGELOG.md:2145
msgid "Updated archive version from `0.9` -> `0.10` ([#4561](https://github.com/aiidateam/aiida-core/pull/4561)"
msgstr ""

#: ../../../CHANGELOG.md:2146
msgid "Deprecations: `export_zip`, `export_tar`, `export_tree`, `extract_zip`, `extract_tar` and `extract_tree`functions. `silent` key-word in the `export` function"
msgstr ""

#: ../../../CHANGELOG.md:2147
msgid "Removed: `ZipFolder` class"
msgstr ""

#: ../../../CHANGELOG.md:2149
msgid "v1.4.4"
msgstr ""

#: ../../../CHANGELOG.md:2151
msgid "This patch is a backport for 2 of the fixes in `v1.5.2`."
msgstr ""

#: ../../../CHANGELOG.md:2154
msgid "`Dict`: accessing an inexistent key now raises a `KeyError` (instead of an `AttributeError`) [[#4616]](https://github.com/aiidateam/aiida-core/pull/4616)"
msgstr ""

#: ../../../CHANGELOG.md:2160
msgid "v1.4.3"
msgstr ""

#: ../../../CHANGELOG.md:2163
msgid "RabbitMQ: update `topika` requirement to fix SSL connections and remove validation of `broker_parameters` from profile [[#4542]](https://github.com/aiidateam/aiida-core/pull/4542)"
msgstr ""

#: ../../../CHANGELOG.md:2164
msgid "Fix `UnboundLocalError` in `aiida.cmdline.utils.edit_multiline_template`, which affected `verdi code/computer setup` [[#4436]](https://github.com/aiidateam/aiida-core/pull/4436)"
msgstr ""

#: ../../../CHANGELOG.md:2167
msgid "v1.4.2"
msgstr ""

#: ../../../CHANGELOG.md:2169
#: ../../../CHANGELOG.md:2696
#: ../../../CHANGELOG.md:2724
#: ../../../CHANGELOG.md:2735
#: ../../../CHANGELOG.md:2751
#: ../../../CHANGELOG.md:2764
#: ../../../CHANGELOG.md:2820
#: ../../../CHANGELOG.md:2854
#: ../../../CHANGELOG.md:2876
msgid "Critical bug fixes"
msgstr ""

#: ../../../CHANGELOG.md:2170
msgid "`CalcJob`: make sure `local_copy_list` files do not end up in the node's repository folder [[#4415]](https://github.com/aiidateam/aiida-core/pull/4415)"
msgstr ""

#: ../../../CHANGELOG.md:2173
msgid "v1.4.1"
msgstr ""

#: ../../../CHANGELOG.md:2176
msgid "`verdi setup`: forward broker defaults to interactive mode [[#4405]](https://github.com/aiidateam/aiida-core/pull/4405)"
msgstr ""

#: ../../../CHANGELOG.md:2179
msgid "`verdi setup`: improve validation and help string of broker virtual host [[#4408]](https://github.com/aiidateam/aiida-core/pull/4408)"
msgstr ""

#: ../../../CHANGELOG.md:2180
msgid "Implement `next` and `iter` for the `Node.open` deprecation wrapper [[#4399]](https://github.com/aiidateam/aiida-core/pull/4399)"
msgstr ""

#: ../../../CHANGELOG.md:2181
msgid "Dependencies: increase minimum version requirement `plumpy~=0.15.1` to suppress noisy warning at end of interpreter that ran processes [[#4398]](https://github.com/aiidateam/aiida-core/pull/4398)"
msgstr ""

#: ../../../CHANGELOG.md:2184
msgid "v1.4.0"
msgstr ""

#: ../../../CHANGELOG.md:2187
msgid "Add defaults for configure options of the `SshTransport` plugin [[#4223]](https://github.com/aiidateam/aiida-core/pull/4223)"
msgstr ""

#: ../../../CHANGELOG.md:2188
msgid "`verdi status`: distinguish database schema version incompatible [[#4319]](https://github.com/aiidateam/aiida-core/pull/4319)"
msgstr ""

#: ../../../CHANGELOG.md:2189
msgid "`SlurmScheduler`: implement `parse_output` to detect OOM and OOW [[#3931]](https://github.com/aiidateam/aiida-core/pull/3931)"
msgstr ""

#: ../../../CHANGELOG.md:2192
msgid "Make the RabbitMQ connection parameters configurable [[#4341]](https://github.com/aiidateam/aiida-core/pull/4341)"
msgstr ""

#: ../../../CHANGELOG.md:2193
msgid "Add infrastructure to parse scheduler output for `CalcJobs` [[#3906]](https://github.com/aiidateam/aiida-core/pull/3906)"
msgstr ""

#: ../../../CHANGELOG.md:2194
msgid "Add support for \"peer\" authentication with PostgreSQL [[#4255]](https://github.com/aiidateam/aiida-core/pull/4255)"
msgstr ""

#: ../../../CHANGELOG.md:2195
msgid "Add the `--paused` flag to `verdi process list` [[#4213]](https://github.com/aiidateam/aiida-core/pull/4213)"
msgstr ""

#: ../../../CHANGELOG.md:2196
msgid "Make the loglevel of the daemonizer configurable [[#4276]](https://github.com/aiidateam/aiida-core/pull/4276)"
msgstr ""

#: ../../../CHANGELOG.md:2197
msgid "`Transport`: add option to not use a login shell for all commands [[#4271]](https://github.com/aiidateam/aiida-core/pull/4271)"
msgstr ""

#: ../../../CHANGELOG.md:2198
msgid "Implement `skip_orm` option for SqlAlchemy `Group.remove_nodes` [[#4214]](https://github.com/aiidateam/aiida-core/pull/4214)"
msgstr ""

#: ../../../CHANGELOG.md:2199
msgid "`Dict`: allow setting attributes through setitem and `AttributeManager` [[#4351]](https://github.com/aiidateam/aiida-core/pull/4351)"
msgstr ""

#: ../../../CHANGELOG.md:2200
msgid "`CalcJob`: allow nested target paths for `local_copy_list` [[#4373]](https://github.com/aiidateam/aiida-core/pull/4373)"
msgstr ""

#: ../../../CHANGELOG.md:2201
msgid "`verdi export migrate`: add `--in-place` flag to migrate archive in place [[#4220]](https://github.com/aiidateam/aiida-core/pull/4220)"
msgstr ""

#: ../../../CHANGELOG.md:2204
msgid "`verdi`: make `--prepend-text` and `--append-text` options properly interactive [[#4318]](https://github.com/aiidateam/aiida-core/pull/4318)"
msgstr ""

#: ../../../CHANGELOG.md:2205
msgid "`verdi computer test`: fix failing result in harmless `stderr` responses [[#4316]](https://github.com/aiidateam/aiida-core/pull/4316)"
msgstr ""

#: ../../../CHANGELOG.md:2206
msgid "`QueryBuilder`: Accept empty string for `entity_type` in `append` method [[#4299]](https://github.com/aiidateam/aiida-core/pull/4299)"
msgstr ""

#: ../../../CHANGELOG.md:2207
msgid "`verdi status`: do not except when no profile is configured [[#4253]](https://github.com/aiidateam/aiida-core/pull/4253)"
msgstr ""

#: ../../../CHANGELOG.md:2208
#: ../../../CHANGELOG.md:2235
msgid "`ArithmeticAddParser`: attach output before checking for negative value [[#4267]](https://github.com/aiidateam/aiida-core/pull/4267)"
msgstr ""

#: ../../../CHANGELOG.md:2209
msgid "`CalcJob`: fix bug in `retrieve_list` affecting entries without wildcards [[#4275]](https://github.com/aiidateam/aiida-core/pull/4275)"
msgstr ""

#: ../../../CHANGELOG.md:2210
msgid "`TemplateReplacerCalculation`: make `files` namespace dynamic [[#4348]](https://github.com/aiidateam/aiida-core/pull/4348)"
msgstr ""

#: ../../../CHANGELOG.md:2213
msgid "Rename folder `test.fixtures` to `test.static` [[#4219]](https://github.com/aiidateam/aiida-core/pull/4219)"
msgstr ""

#: ../../../CHANGELOG.md:2214
msgid "Remove all files from the pre-commit exclude list [[#4196]](https://github.com/aiidateam/aiida-core/pull/4196)"
msgstr ""

#: ../../../CHANGELOG.md:2215
msgid "ORM: move attributes/extras methods of frontend and backend nodes to mixins [[#4376]](https://github.com/aiidateam/aiida-core/pull/4376)"
msgstr ""

#: ../../../CHANGELOG.md:2218
msgid "Dependencies: update minimum requirement `paramiko~=2.7` [[#4222]](https://github.com/aiidateam/aiida-core/pull/4222)"
msgstr ""

#: ../../../CHANGELOG.md:2219
msgid "Depedencies: remove upper limit and allow `numpy~=1.17` [[#4378]](https://github.com/aiidateam/aiida-core/pull/4378)"
msgstr ""

#: ../../../CHANGELOG.md:2222
msgid "Deprecate getter and setter methods of `Computer` properties [[#4252]](https://github.com/aiidateam/aiida-core/pull/4252)"
msgstr ""

#: ../../../CHANGELOG.md:2223
msgid "Deprecate methods that refer to a computer's label as name [[#4309]](https://github.com/aiidateam/aiida-core/pull/4309)"
msgstr ""

#: ../../../CHANGELOG.md:2226
msgid "`BaseRestartWorkChain`: do not run `process_handler` when `exit_codes=[]` [[#4380]](https://github.com/aiidateam/aiida-core/pull/4380)"
msgstr ""

#: ../../../CHANGELOG.md:2227
msgid "`SlurmScheduler`: always raise for non-zero exit code [[#4332]](https://github.com/aiidateam/aiida-core/pull/4332)"
msgstr ""

#: ../../../CHANGELOG.md:2228
msgid "Remove superfluous `ERROR_NO_RETRIEVED_FOLDER` from `CalcJob` subclasses [[#3906]](https://github.com/aiidateam/aiida-core/pull/3906)"
msgstr ""

#: ../../../CHANGELOG.md:2231
msgid "v1.3.1"
msgstr ""

#: ../../../CHANGELOG.md:2233
msgid "Bug fixes:"
msgstr ""

#: ../../../CHANGELOG.md:2234
msgid "Fix a file handle leak due to the `Runner` not closing the event loop if it created it itself [[#4307]](https://github.com/aiidateam/aiida-core/pull/4307)"
msgstr ""

#: ../../../CHANGELOG.md:2238
msgid "v1.3.0"
msgstr ""

#: ../../../CHANGELOG.md:2241
msgid "Comprehensive restructuring and revamp of the online documentation [[#4141]](https://github.com/aiidateam/aiida-core/pull/4141)"
msgstr ""

#: ../../../CHANGELOG.md:2242
msgid "Improve defaults for `verdi computer configure ssh` [[#4055]](https://github.com/aiidateam/aiida-core/pull/4055)"
msgstr ""

#: ../../../CHANGELOG.md:2243
msgid "Provenance graphs: enable highlighting specific node classes (and highlight root node by default) [[#4081]](https://github.com/aiidateam/aiida-core/pull/4081)"
msgstr ""

#: ../../../CHANGELOG.md:2246
msgid "Enable event-based monitoring of work chain child processes (they were being polled every second) [[#4154]](https://github.com/aiidateam/aiida-core/pull/4154)"
msgstr ""

#: ../../../CHANGELOG.md:2247
msgid "Increase the default for `runner.poll.interval` config option from 1 to 60 seconds [[#4150]](https://github.com/aiidateam/aiida-core/pull/4150)"
msgstr ""

#: ../../../CHANGELOG.md:2248
msgid "Increase the efficiency of the `SqlaGroup.nodes` iterator [[#4094]](https://github.com/aiidateam/aiida-core/pull/4094)"
msgstr ""

#: ../../../CHANGELOG.md:2251
msgid "Add a progress bar for export and import related functionality [[#3599]](https://github.com/aiidateam/aiida-core/pull/3599)"
msgstr ""

#: ../../../CHANGELOG.md:2252
msgid "Enable loading config.yml files from URL in `verdi` commands with `--config` option [[#3977]](https://github.com/aiidateam/aiida-core/pull/3977)"
msgstr ""

#: ../../../CHANGELOG.md:2253
msgid "`QueryBuilder`: add the `flat` argument to the `.all()` method [[#3945]](https://github.com/aiidateam/aiida-core/pull/3945)"
msgstr ""

#: ../../../CHANGELOG.md:2254
msgid "`verdi status`: add `--no-rmq` flag to skip the RabbitMQ check [[#4181]](https://github.com/aiidateam/aiida-core/pull/4181)"
msgstr ""

#: ../../../CHANGELOG.md:2255
msgid "Add support for process functions in `verdi plugin list` [[#4117]](https://github.com/aiidateam/aiida-core/pull/4117)"
msgstr ""

#: ../../../CHANGELOG.md:2256
msgid "Allow profile selection in ipython magic `%aiida` [[#4071]](https://github.com/aiidateam/aiida-core/pull/4071)"
msgstr ""

#: ../../../CHANGELOG.md:2257
msgid "Support more complex formula formats in `aiida.orm.data.cif.parse_formula` [[#3954]](https://github.com/aiidateam/aiida-core/pull/3954)"
msgstr ""

#: ../../../CHANGELOG.md:2260
msgid "`BaseRestartWorkChain`: do not assume `metadata` exists in inputs in `run_process` [[#4210]](https://github.com/aiidateam/aiida-core/pull/4210)"
msgstr ""

#: ../../../CHANGELOG.md:2261
msgid "`BaseRestartWorkChain`: fix bug in `inspect_process` [[#4166]](https://github.com/aiidateam/aiida-core/pull/4166)"
msgstr ""

#: ../../../CHANGELOG.md:2262
msgid "`BaseRestartWorkChain`: fix the \"unhandled failure mechanism\" for dealing with failures of subprocesses [[#4155]](https://github.com/aiidateam/aiida-core/pull/4155)"
msgstr ""

#: ../../../CHANGELOG.md:2263
msgid "Fix exception handling in commands calling `list_repository_contents` [[#3968]](https://github.com/aiidateam/aiida-core/pull/3968)"
msgstr ""

#: ../../../CHANGELOG.md:2264
msgid "Fix bug in `Code.get_full_text_info` [[#4083]](https://github.com/aiidateam/aiida-core/pull/4083)"
msgstr ""

#: ../../../CHANGELOG.md:2265
msgid "Fix bug in `verdi daemon restart --reset` [[#3969]](https://github.com/aiidateam/aiida-core/pull/3969)"
msgstr ""

#: ../../../CHANGELOG.md:2266
msgid "Fix tab-completion for `LinkManager` and `AttributeManager` [[#3985]](https://github.com/aiidateam/aiida-core/pull/3985)"
msgstr ""

#: ../../../CHANGELOG.md:2267
msgid "`CalcJobResultManager`: fix bug that broke tab completion [[#4187]](https://github.com/aiidateam/aiida-core/pull/4187)"
msgstr ""

#: ../../../CHANGELOG.md:2268
msgid "`SshTransport.gettree`: allow non-existing nested target directories [[#4175]](https://github.com/aiidateam/aiida-core/pull/4175)"
msgstr ""

#: ../../../CHANGELOG.md:2269
msgid "`CalcJob`: move job resource validation to the `Scheduler` class fixing a problem for the SGE and LSF scheduler plugins [[#4192]](https://github.com/aiidateam/aiida-core/pull/4192)"
msgstr ""

#: ../../../CHANGELOG.md:2270
msgid "`WorkChain`: guarantee to maintain order of appended awaitables [[#4156]](https://github.com/aiidateam/aiida-core/pull/4156)"
msgstr ""

#: ../../../CHANGELOG.md:2271
msgid "Add support for binary files to the various `verdi` cat commands [[#4077]](https://github.com/aiidateam/aiida-core/pull/4077)"
msgstr ""

#: ../../../CHANGELOG.md:2272
msgid "Ensure `verdi group show --limit` respects limit even in raw mode [[#4092]](https://github.com/aiidateam/aiida-core/pull/4092)"
msgstr ""

#: ../../../CHANGELOG.md:2273
msgid "`QueryBuilder`: fix type string filter generation for `Group` subclasses [[#4144]](https://github.com/aiidateam/aiida-core/pull/4144)"
msgstr ""

#: ../../../CHANGELOG.md:2274
msgid "Raise when calling `Node.objects.delete` for node with incoming links [[#4168]](https://github.com/aiidateam/aiida-core/pull/4168)"
msgstr ""

#: ../../../CHANGELOG.md:2275
msgid "Properly handle multiple requests to threaded REST API [[#3974]](https://github.com/aiidateam/aiida-core/pull/3974)"
msgstr ""

#: ../../../CHANGELOG.md:2276
msgid "`NodeTranslator`: do not assume `get_export_formats` exists [[#4188]](https://github.com/aiidateam/aiida-core/pull/4188)"
msgstr ""

#: ../../../CHANGELOG.md:2277
msgid "Only color directories in `verdi node repo ls --color` [[#4195]](https://github.com/aiidateam/aiida-core/pull/4195)"
msgstr ""

#: ../../../CHANGELOG.md:2280
msgid "Add arithmetic workflows and restructure calculation plugins [[#4124]](https://github.com/aiidateam/aiida-core/pull/4124)"
msgstr ""

#: ../../../CHANGELOG.md:2281
msgid "Add minimal `mypy` run to the pre-commit hooks. [[#4176]](https://github.com/aiidateam/aiida-core/pull/4176)"
msgstr ""

#: ../../../CHANGELOG.md:2282
msgid "Fix timeout in `tests.cmdline.commands.test_process:test_pause_play_kill` [[#4052]](https://github.com/aiidateam/aiida-core/pull/4052)"
msgstr ""

#: ../../../CHANGELOG.md:2283
msgid "Revise update-dependency flow to resolve issue #3930 [[#3957]](https://github.com/aiidateam/aiida-core/pull/3957)"
msgstr ""

#: ../../../CHANGELOG.md:2284
msgid "Add GitHub action for transifex upload [[#3958]](https://github.com/aiidateam/aiida-core/pull/3958)"
msgstr ""

#: ../../../CHANGELOG.md:2287
msgid "The `get_valid_schedulers` class method of the `Scheduler` class has been deprecated in favor of `aiida.plugins.entry_point.get_entry_point_names` [[#4192]](https://github.com/aiidateam/aiida-core/pull/4192)"
msgstr ""

#: ../../../CHANGELOG.md:2290
msgid "v1.2.1"
msgstr ""

#: ../../../CHANGELOG.md:2292
msgid "In the fixing of three bugs, three minor features have been added along the way."
msgstr ""

#: ../../../CHANGELOG.md:2295
msgid "Add config option `daemon.worker_process_slots` to configure the maximum number of concurrent tasks each daemon worker can handle [[#3949]](https://github.com/aiidateam/aiida-core/pull/3949)"
msgstr ""

#: ../../../CHANGELOG.md:2296
msgid "Add config option `daemon.default_workers` to set the default number of workers to be started by `verdi daemon start` [[#3949]](https://github.com/aiidateam/aiida-core/pull/3949)"
msgstr ""

#: ../../../CHANGELOG.md:2297
msgid "`CalcJob`: make submit script filename configurable through the `metadata.options` [[#3948]](https://github.com/aiidateam/aiida-core/pull/3948)"
msgstr ""

#: ../../../CHANGELOG.md:2300
msgid "`CalcJob`: fix bug in idempotency check of upload transport task [[#3948]](https://github.com/aiidateam/aiida-core/pull/3948)"
msgstr ""

#: ../../../CHANGELOG.md:2301
msgid "REST API: reintroduce CORS headers, the lack of which was breaking the Materials Cloud provenance explorer [[#3951]](https://github.com/aiidateam/aiida-core/pull/3951)"
msgstr ""

#: ../../../CHANGELOG.md:2302
msgid "Remove the equality operator of `ExitCode` which caused the serialization of workchains to fail if put in the workchain context [[#3940]](https://github.com/aiidateam/aiida-core/pull/3940)"
msgstr ""

#: ../../../CHANGELOG.md:2305
msgid "The `hookup` argument of `aiida.restapi.run_api` and the `--hookup` option of `verdi restapi` are deprecated [[#3951]](https://github.com/aiidateam/aiida-core/pull/3951)"
msgstr ""

#: ../../../CHANGELOG.md:2308
msgid "v1.2.0"
msgstr ""

#: ../../../CHANGELOG.md:2311
msgid "`ExitCode`: make the exit message parameterizable through templates [[#3824]](https://github.com/aiidateam/aiida-core/pull/3824)"
msgstr ""

#: ../../../CHANGELOG.md:2312
msgid "`GroupPath`: a utility to work with virtual `Group` hierarchies [[#3613]](https://github.com/aiidateam/aiida-core/pull/3613)"
msgstr ""

#: ../../../CHANGELOG.md:2313
msgid "Make `Group` sub classable through entry points [[#3882]](https://github.com/aiidateam/aiida-core/pull/3882)[[#3903]](https://github.com/aiidateam/aiida-core/pull/3903)[[#3926]](https://github.com/aiidateam/aiida-core/pull/3926)"
msgstr ""

#: ../../../CHANGELOG.md:2314
msgid "Add auto-complete support for `CodeParamType` and `GroupParamType` [[#3926]](https://github.com/aiidateam/aiida-core/pull/3926)"
msgstr ""

#: ../../../CHANGELOG.md:2315
msgid "Add export archive migration for `Group` type strings [[#3912]](https://github.com/aiidateam/aiida-core/pull/3912)"
msgstr ""

#: ../../../CHANGELOG.md:2316
msgid "Add the `-v/--version` option to `verdi export migrate` [[#3910]](https://github.com/aiidateam/aiida-core/pull/3910)"
msgstr ""

#: ../../../CHANGELOG.md:2317
msgid "Add the `-l/--limit` option to `verdi group show` [[#3857]](https://github.com/aiidateam/aiida-core/pull/3857)"
msgstr ""

#: ../../../CHANGELOG.md:2318
msgid "Add the `--order-by/--order-direction` options to `verdi group list` [[#3858]](https://github.com/aiidateam/aiida-core/pull/3858)"
msgstr ""

#: ../../../CHANGELOG.md:2319
msgid "Add `prepend_text` and `append_text` to `aiida_local_code_factory` pytest fixture [[#3831]](https://github.com/aiidateam/aiida-core/pull/3831)"
msgstr ""

#: ../../../CHANGELOG.md:2320
msgid "REST API: make it easier to call `run_api` in wsgi scripts [[#3875]](https://github.com/aiidateam/aiida-core/pull/3875)"
msgstr ""

#: ../../../CHANGELOG.md:2321
msgid "Plot bands with only one kpoint [[#3798]](https://github.com/aiidateam/aiida-core/pull/3798)"
msgstr ""

#: ../../../CHANGELOG.md:2324
msgid "Improved validation for CLI parameters [[#3894]](https://github.com/aiidateam/aiida-core/pull/3894)"
msgstr ""

#: ../../../CHANGELOG.md:2325
msgid "Ensure unicity when creating instances of `Autogroup` [[#3650]](https://github.com/aiidateam/aiida-core/pull/3650)"
msgstr ""

#: ../../../CHANGELOG.md:2326
msgid "Prevent nodes without registered entry points from being stored [[#3886]](https://github.com/aiidateam/aiida-core/pull/3886)"
msgstr ""

#: ../../../CHANGELOG.md:2327
msgid "Fix the `RotatingFileHandler` configuration of the daemon logger[[#3891]](https://github.com/aiidateam/aiida-core/pull/3891)"
msgstr ""

#: ../../../CHANGELOG.md:2328
msgid "Ensure log messages are not duplicated in daemon log file [[#3890]](https://github.com/aiidateam/aiida-core/pull/3890)"
msgstr ""

#: ../../../CHANGELOG.md:2329
msgid "Convert argument to `str` in `aiida.common.escaping.escape_for_bash` [[#3873]](https://github.com/aiidateam/aiida-core/pull/3873)"
msgstr ""

#: ../../../CHANGELOG.md:2330
msgid "Remove the return statement of `RemoteData.getfile()` [[#3742]](https://github.com/aiidateam/aiida-core/pull/3742)"
msgstr ""

#: ../../../CHANGELOG.md:2331
msgid "Support for `BandsData` nodes without `StructureData` ancestors [[#3817]](https://github.com/aiidateam/aiida-core/pull/3817)"
msgstr ""

#: ../../../CHANGELOG.md:2334
msgid "Deprecate `--group-type` option in favor of `--type-string` for `verdi group list` [[#3926]](https://github.com/aiidateam/aiida-core/pull/3926)"
msgstr ""

#: ../../../CHANGELOG.md:2337
msgid "Docs: link to documentation of other libraries via `intersphinx` mapping [[#3876]](https://github.com/aiidateam/aiida-core/pull/3876)"
msgstr ""

#: ../../../CHANGELOG.md:2338
msgid "Docs: remove extra `advanced_plotting` from install instructions [[#3860]](https://github.com/aiidateam/aiida-core/pull/3860)"
msgstr ""

#: ../../../CHANGELOG.md:2339
msgid "Docs: consistent use of \"plugin\" vs \"plugin package\" terminology [[#3799]](https://github.com/aiidateam/aiida-core/pull/3799)"
msgstr ""

#: ../../../CHANGELOG.md:2342
msgid "Deduplicate code for tests of archive migration code [[#3924]](https://github.com/aiidateam/aiida-core/pull/3924)"
msgstr ""

#: ../../../CHANGELOG.md:2343
msgid "CI: use GitHub Actions services for PostgreSQL and RabbitMQ [[#3901]](https://github.com/aiidateam/aiida-core/pull/3901)"
msgstr ""

#: ../../../CHANGELOG.md:2344
msgid "Move `aiida.manage.external.pgsu` to external package `pgsu` [[#3892]](https://github.com/aiidateam/aiida-core/pull/3892)"
msgstr ""

#: ../../../CHANGELOG.md:2345
msgid "Cleanup the top-level directory of the repository [[#3738]](https://github.com/aiidateam/aiida-core/pull/3738)"
msgstr ""

#: ../../../CHANGELOG.md:2346
msgid "Remove unused `orm.implementation.utils` module [[#3877]](https://github.com/aiidateam/aiida-core/pull/3877)"
msgstr ""

#: ../../../CHANGELOG.md:2347
msgid "Revise dependency management workflow [[#3771]](https://github.com/aiidateam/aiida-core/pull/3771)"
msgstr ""

#: ../../../CHANGELOG.md:2348
msgid "Re-add support for Coverage reports through codecov.io [[#3618]](https://github.com/aiidateam/aiida-core/pull/3618)"
msgstr ""

#: ../../../CHANGELOG.md:2351
msgid "v1.1.1"
msgstr ""

#: ../../../CHANGELOG.md:2354
msgid "Emit a warning when input port specifies a node instance as default [[#3466]](https://github.com/aiidateam/aiida-core/pull/3466)"
msgstr ""

#: ../../../CHANGELOG.md:2355
msgid "`BaseRestartWorkChain`: require process handlers to be instance methods [[#3782]](https://github.com/aiidateam/aiida-core/pull/3782)"
msgstr ""

#: ../../../CHANGELOG.md:2356
msgid "`BaseRestartWorkChain`: add method to enable/disable process handlers [[#3786]](https://github.com/aiidateam/aiida-core/pull/3786)"
msgstr ""

#: ../../../CHANGELOG.md:2357
msgid "Docker container: remove conda activation from configure-aiida.sh script [[#3791]](https://github.com/aiidateam/aiida-core/pull/3791)"
msgstr ""

#: ../../../CHANGELOG.md:2358
msgid "Add fixtures to clear the database before or after tests [[#3783]](https://github.com/aiidateam/aiida-core/pull/3783)"
msgstr ""

#: ../../../CHANGELOG.md:2359
msgid "`verdi status`: add the configuration directory path to the output [[#3587]](https://github.com/aiidateam/aiida-core/pull/3587)"
msgstr ""

#: ../../../CHANGELOG.md:2360
msgid "`QueryBuilder`: add support for `datetime.date` objects in filters [[#3796]](https://github.com/aiidateam/aiida-core/pull/3796)"
msgstr ""

#: ../../../CHANGELOG.md:2363
msgid "Fix bugs in `Node._store_from_cache` and `Node.repository.erase` that could result in calculations not being reused [[#3777]](https://github.com/aiidateam/aiida-core/pull/3777)"
msgstr ""

#: ../../../CHANGELOG.md:2364
msgid "Caching: fix configuration spec and validation [[#3785]](https://github.com/aiidateam/aiida-core/pull/3785)"
msgstr ""

#: ../../../CHANGELOG.md:2365
msgid "Write migrated config to disk in `Config.from_file` [[#3797]](https://github.com/aiidateam/aiida-core/pull/3797)"
msgstr ""

#: ../../../CHANGELOG.md:2366
msgid "Validate label string at code setup stage [[#3793]](https://github.com/aiidateam/aiida-core/pull/3793)"
msgstr ""

#: ../../../CHANGELOG.md:2367
msgid "Reuse `prepend_text` and `append_text` in `verdi computer/code duplicate` [[#3788]](https://github.com/aiidateam/aiida-core/pull/3788)"
msgstr ""

#: ../../../CHANGELOG.md:2368
msgid "Fix broken imports of `urllib` in various locations including `verdi import` [[#3767]](https://github.com/aiidateam/aiida-core/pull/3767)"
msgstr ""

#: ../../../CHANGELOG.md:2369
msgid "Match headers with actual output for `verdi data structure list` [[#3756]](https://github.com/aiidateam/aiida-core/pull/3756)"
msgstr ""

#: ../../../CHANGELOG.md:2370
msgid "Disable caching for the `Data` node subclass (this should not affect usual caching behavior) [[#3807]](https://github.com/aiidateam/aiida-core/pull/3807)"
msgstr ""

#: ../../../CHANGELOG.md:2373
msgid "v1.1.0"
msgstr ""

#: ../../../CHANGELOG.md:2375
msgid "**Nota Bene:** although this is a minor version release, the support for python 2 is dropped [(#3566)](https://github.com/aiidateam/aiida-core/pull/3566) following the reasoning outlined in the corresponding [AEP001](https://github.com/aiidateam/AEP/tree/master/001_drop_python2). Critical bug fixes for python 2 will be supported until July 1 2020 on the `v1.0.*` release series. With the addition of python 3.8 [(#3719)](https://github.com/aiidateam/aiida-core/pull/3719), this version is now compatible with all current python versions that are not end-of-life:"
msgstr ""

#: ../../../CHANGELOG.md:2378
msgid "3.5"
msgstr ""

#: ../../../CHANGELOG.md:2384
msgid "Add the AiiDA Graph Explorer (AGE) a generic tool for traversing provenance graph [[#3686]](https://github.com/aiidateam/aiida-core/pull/3686)"
msgstr ""

#: ../../../CHANGELOG.md:2385
msgid "Add the `BaseRestartWorkChain` which makes it easier to write a simple work chain wrapper around another process with automated error handling [[#3748]](https://github.com/aiidateam/aiida-core/pull/3748)"
msgstr ""

#: ../../../CHANGELOG.md:2386
msgid "Add `provenance_exclude_list` attribute to `CalcInfo` data structure, allowing to prevent calculation input files from being permanently stored in the repository [[#3720]](https://github.com/aiidateam/aiida-core/pull/3720)"
msgstr ""

#: ../../../CHANGELOG.md:2387
msgid "Add the `verdi node repo dump` command [[#3623]](https://github.com/aiidateam/aiida-core/pull/3623)"
msgstr ""

#: ../../../CHANGELOG.md:2388
msgid "Add more methods to control cache invalidation of completed process node [[#3637]](https://github.com/aiidateam/aiida-core/pull/3637)"
msgstr ""

#: ../../../CHANGELOG.md:2389
msgid "Allow documentation to be build without installing and configuring AiiDA [[#3669]](https://github.com/aiidateam/aiida-core/pull/3669)"
msgstr ""

#: ../../../CHANGELOG.md:2390
msgid "Add option to expand namespaces in sphinx directive [[#3631]](https://github.com/aiidateam/aiida-core/pull/3631)"
msgstr ""

#: ../../../CHANGELOG.md:2393
msgid "Add `node_type` to list of immutable model fields, preventing repeated database hits [[#3619]](https://github.com/aiidateam/aiida-core/pull/3619)"
msgstr ""

#: ../../../CHANGELOG.md:2394
msgid "Add cache for entry points in an entry point group [[#3622]](https://github.com/aiidateam/aiida-core/pull/3622)"
msgstr ""

#: ../../../CHANGELOG.md:2395
msgid "Improve the performance when exporting many groups [[#3681]](https://github.com/aiidateam/aiida-core/pull/3681)"
msgstr ""

#: ../../../CHANGELOG.md:2398
msgid "`CalcJob`: move `presubmit` call from `CalcJob.run` to `Waiting.execute` [[#3666]](https://github.com/aiidateam/aiida-core/pull/3666)"
msgstr ""

#: ../../../CHANGELOG.md:2399
msgid "`CalcJob`: do not pause when exception thrown in the `presubmit` [[#3699]](https://github.com/aiidateam/aiida-core/pull/3699)"
msgstr ""

#: ../../../CHANGELOG.md:2400
msgid "Move `CalcJob` spec validator to corresponding namespaces [[#3702]](https://github.com/aiidateam/aiida-core/pull/3702)"
msgstr ""

#: ../../../CHANGELOG.md:2401
msgid "Move getting completed job accounting to `retrieve` transport task [[#3639]](https://github.com/aiidateam/aiida-core/pull/3639)"
msgstr ""

#: ../../../CHANGELOG.md:2402
msgid "Move `last_job_info` from JSON-serialized string to dictionary [[#3651]](https://github.com/aiidateam/aiida-core/pull/3651)"
msgstr ""

#: ../../../CHANGELOG.md:2403
msgid "Improve SqlAlchemy session handling for `QueryBuilder` [[#3708]](https://github.com/aiidateam/aiida-core/pull/3708)"
msgstr ""

#: ../../../CHANGELOG.md:2404
msgid "Use built-in `open` instead of `io.open`, which is possible now that python 2 is no longer supported [[#3615]](https://github.com/aiidateam/aiida-core/pull/3615)"
msgstr ""

#: ../../../CHANGELOG.md:2405
msgid "Add non-zero exit code for `verdi daemon status` [[#3729]](https://github.com/aiidateam/aiida-core/pull/3729)"
msgstr ""

#: ../../../CHANGELOG.md:2408
msgid "Deal with unreachable daemon worker in `get_daemon_status` [[#3683]](https://github.com/aiidateam/aiida-core/pull/3683)"
msgstr ""

#: ../../../CHANGELOG.md:2409
msgid "Django backend: limit batch size for `bulk_create` operations [[#3713]](https://github.com/aiidateam/aiida-core/pull/3713)"
msgstr ""

#: ../../../CHANGELOG.md:2410
msgid "Make sure that datetime conversions ignore `None` [[#3628]](https://github.com/aiidateam/aiida-core/pull/3628)"
msgstr ""

#: ../../../CHANGELOG.md:2411
msgid "Allow empty `key_filename` in `verdi computer configure ssh` and reuse cooldown time when reconfiguring [[#3636]](https://github.com/aiidateam/aiida-core/pull/3636)"
msgstr ""

#: ../../../CHANGELOG.md:2412
msgid "Update `pyyaml` to v5.1.2 to prevent arbitrary code execution [[#3675]](https://github.com/aiidateam/aiida-core/pull/3675)"
msgstr ""

#: ../../../CHANGELOG.md:2413
msgid "`QueryBuilder`: fix validation bug and improve message for `in` operator [[#3682]](https://github.com/aiidateam/aiida-core/pull/3682)"
msgstr ""

#: ../../../CHANGELOG.md:2414
msgid "Consider 'AIIDA_TEST_PROFILE' in 'get_test_backend_name' [[#3685]](https://github.com/aiidateam/aiida-core/pull/3685)"
msgstr ""

#: ../../../CHANGELOG.md:2415
msgid "Ensure correct types for `QueryBuilder().dict()` with multiple projections [[#3695]](https://github.com/aiidateam/aiida-core/pull/3695)"
msgstr ""

#: ../../../CHANGELOG.md:2416
msgid "Make local modules importable when running `verdi run` [[#3700]](https://github.com/aiidateam/aiida-core/pull/3700)"
msgstr ""

#: ../../../CHANGELOG.md:2417
msgid "Fix bug in `upload_calculation` for `CalcJobs` with local codes [[#3707]](https://github.com/aiidateam/aiida-core/pull/3707)"
msgstr ""

#: ../../../CHANGELOG.md:2418
msgid "Add imports from `urllib` to dbimporters [[#3704]](https://github.com/aiidateam/aiida-core/pull/3704)"
msgstr ""

#: ../../../CHANGELOG.md:2421
msgid "Moved continuous integration from Travis to Github actions [[#3571]](https://github.com/aiidateam/aiida-core/pull/3571)"
msgstr ""

#: ../../../CHANGELOG.md:2422
msgid "Replace custom unit test framework for `pytest` and move all tests to `tests` top level directory [[#3653]](https://github.com/aiidateam/aiida-core/pull/3653)[[#3674]](https://github.com/aiidateam/aiida-core/pull/3674)[[#3715]](https://github.com/aiidateam/aiida-core/pull/3715)"
msgstr ""

#: ../../../CHANGELOG.md:2423
msgid "Cleaned up direct dependencies and relaxed requirements where possible [[#3597]](https://github.com/aiidateam/aiida-core/pull/3597)"
msgstr ""

#: ../../../CHANGELOG.md:2424
msgid "Set job poll interval to zero in localhost pytest fixture [[#3605]](https://github.com/aiidateam/aiida-core/pull/3605)"
msgstr ""

#: ../../../CHANGELOG.md:2425
msgid "Make command line deprecation warnings visible with test profile [[#3665]](https://github.com/aiidateam/aiida-core/pull/3665)"
msgstr ""

#: ../../../CHANGELOG.md:2426
msgid "Add docker image with minimal running AiiDA instance [[#3722]](https://github.com/aiidateam/aiida-core/pull/3722)"
msgstr ""

#: ../../../CHANGELOG.md:2429
msgid "v1.0.1"
msgstr ""

#: ../../../CHANGELOG.md:2432
msgid "Improve the backup mechanism of the configuration file: unique backup written at each update [[#3581]](https://github.com/aiidateam/aiida-core/pull/3581)"
msgstr ""

#: ../../../CHANGELOG.md:2433
msgid "Forward `verdi code delete` to `verdi node delete` [[#3546]](https://github.com/aiidateam/aiida-core/pull/3546)"
msgstr ""

#: ../../../CHANGELOG.md:2434
msgid "Homogenize and improve output of `verdi computer test` [[#3544]](https://github.com/aiidateam/aiida-core/pull/3544)"
msgstr ""

#: ../../../CHANGELOG.md:2435
msgid "Scheduler SLURM: support `UNLIMITED` and `NOT_SET` as values for requested walltimes [[#3586]](https://github.com/aiidateam/aiida-core/pull/3586)"
msgstr ""

#: ../../../CHANGELOG.md:2436
msgid "Set default for the `safe_interval` option of `verdi computer configure` [[#3590]](https://github.com/aiidateam/aiida-core/pull/3590)"
msgstr ""

#: ../../../CHANGELOG.md:2437
msgid "Create backup of configuration file before migrating [[#3568]](https://github.com/aiidateam/aiida-core/pull/3568)"
msgstr ""

#: ../../../CHANGELOG.md:2438
msgid "Add `python_requires` to `setup.json` necessary for future dropping of python 2 [[#3574]](https://github.com/aiidateam/aiida-core/pull/3574)"
msgstr ""

#: ../../../CHANGELOG.md:2439
msgid "Remove unused QB methods/functions [[#3526]](https://github.com/aiidateam/aiida-core/pull/3526)"
msgstr ""

#: ../../../CHANGELOG.md:2440
msgid "Move `pgtest` argument of `TemporaryProfileManager` to constructor [[#3486]](https://github.com/aiidateam/aiida-core/pull/3486)"
msgstr ""

#: ../../../CHANGELOG.md:2441
msgid "Add `filename` argument to `SinglefileData` constructor [[#3517]](https://github.com/aiidateam/aiida-core/pull/3517)"
msgstr ""

#: ../../../CHANGELOG.md:2442
msgid "Mention machine in SSH connection exception message [[#3536]](https://github.com/aiidateam/aiida-core/pull/3536)"
msgstr ""

#: ../../../CHANGELOG.md:2443
msgid "Docs: Expand on QB `order_by` information [[#3548]](https://github.com/aiidateam/aiida-core/pull/3548)"
msgstr ""

#: ../../../CHANGELOG.md:2444
msgid "Replace deprecated pymatgen `site.species_and_occu` with `site.species`  [[#3480]](https://github.com/aiidateam/aiida-core/pull/3480)"
msgstr ""

#: ../../../CHANGELOG.md:2445
msgid "`QueryBuilder`: add deepcopy implementation and `queryhelp` property [[#3524]](https://github.com/aiidateam/aiida-core/pull/3524)"
msgstr ""

#: ../../../CHANGELOG.md:2448
msgid "Fix `verdi calcjob gotocomputer` when `key_filename` is missing [[#3593]](https://github.com/aiidateam/aiida-core/pull/3593)"
msgstr ""

#: ../../../CHANGELOG.md:2449
msgid "Fix bug in database migrations where schema generation determination excepts for old databases [[#3582]](https://github.com/aiidateam/aiida-core/pull/3582)"
msgstr ""

#: ../../../CHANGELOG.md:2450
msgid "Fix false positive for `verdi database integrity detect-invalid-links` [[#3591]](https://github.com/aiidateam/aiida-core/pull/3591)"
msgstr ""

#: ../../../CHANGELOG.md:2451
msgid "Config migration: handle edge case where `daemon` key is missing from `daemon_profiles` [[#3585]](https://github.com/aiidateam/aiida-core/pull/3585)"
msgstr ""

#: ../../../CHANGELOG.md:2452
msgid "Raise when unable to detect name of local timezone [[#3576]](https://github.com/aiidateam/aiida-core/pull/3576)"
msgstr ""

#: ../../../CHANGELOG.md:2453
msgid "Fix bug for `CalcJob` dry runs with `store_provenance=False` [[#3513]](https://github.com/aiidateam/aiida-core/pull/3513)"
msgstr ""

#: ../../../CHANGELOG.md:2454
msgid "Migrations for legacy and now illegal default link label `_return`, export version upped to `0.8` [[#3561]](https://github.com/aiidateam/aiida-core/pull/3561)"
msgstr ""

#: ../../../CHANGELOG.md:2455
msgid "Fix REST API `attributes_filter` and `extras_filter` [[#3556]](https://github.com/aiidateam/aiida-core/pull/3556)"
msgstr ""

#: ../../../CHANGELOG.md:2456
msgid "Fix bug in plugin `Factory` classes for python 3.7 [[#3552]](https://github.com/aiidateam/aiida-core/pull/3552)"
msgstr ""

#: ../../../CHANGELOG.md:2457
msgid "Make `PolishWorkChains` checkpointable [[#3532]](https://github.com/aiidateam/aiida-core/pull/3532)"
msgstr ""

#: ../../../CHANGELOG.md:2458
msgid "REST API: fix generator of full node namespace [[#3516]](https://github.com/aiidateam/aiida-core/pull/3516)"
msgstr ""

#: ../../../CHANGELOG.md:2461
msgid "v1.0.0"
msgstr ""

#: ../../../CHANGELOG.md:2463
msgid "Overview of changes"
msgstr ""

#: ../../../CHANGELOG.md:2465
msgid "The following is a summary of the major changes and improvements from `v0.12.*` to `v1.0.0`."
msgstr ""

#: ../../../CHANGELOG.md:2467
msgid "Faster workflow engine: the new message-based engine powered by RabbitMQ supports tens of thousands of processes per hour and greatly speeds up workflow testing. You can now run one daemon per AiiDA profile."
msgstr ""

#: ../../../CHANGELOG.md:2468
msgid "Faster database queries: the switch to JSONB for node attributes and extras greatly improves query speed and reduces storage size by orders of magnitude."
msgstr ""

#: ../../../CHANGELOG.md:2469
msgid "Robust calculations: AiiDA now deals with network connection issues (automatic retries with backoff mechanism, connection pooling, ...) out of the box. Workflows and calculations are all Processes and can be \"paused\" and \"played\" anytime."
msgstr ""

#: ../../../CHANGELOG.md:2470
msgid "Better verdi commands: the move to the `click` framework brings homogenous command line options across all commands (loading nodes, ...). You can easily add new commands through plugins."
msgstr ""

#: ../../../CHANGELOG.md:2471
msgid "Easier workflow development: Input and output namespaces, reusing specs of sub-processes and less boilerplate code simplify writing WorkChains and CalcJobs, while also enabling powerful auto-documentation features."
msgstr ""

#: ../../../CHANGELOG.md:2472
msgid "Mature provenance model: Clear separation between data provenance (Calculations, Data) and logical provenance (Workflows). Old databases can be migrated to the new model automatically."
msgstr ""

#: ../../../CHANGELOG.md:2473
msgid "python3 compatible: AiiDA 1.0 is compatible with both python 2.7 and python 3.6 (and later). Python 2 support will be dropped in the coming months."
msgstr ""

#: ../../../CHANGELOG.md:2475
msgid "Detailed list of changes"
msgstr ""

#: ../../../CHANGELOG.md:2477
msgid "Below a (non-exhaustive) list of changes by category. Changes between 1.0 alpha/beta releases are not included - for those see the changelog of the corresponding releases."
msgstr ""

#: ../../../CHANGELOG.md:2480
msgid "Engine and daemon"
msgstr ""

#: ../../../CHANGELOG.md:2481
msgid "Implement the concept of an \"exit status\" for all calculations, allowing a programmatic definition of success or failure for all processes [[#1189]](https://github.com/aiidateam/aiida-core/pull/1189)"
msgstr ""

#: ../../../CHANGELOG.md:2482
msgid "All calculations now go through the `Process` layer, homogenizing the state of work and job calculations [[#1125]](https://github.com/aiidateam/aiida-core/pull/1125)"
msgstr ""

#: ../../../CHANGELOG.md:2483
msgid "Allow `None` as default for arguments of process functions [[#2582]](https://github.com/aiidateam/aiida-core/pull/2582)"
msgstr ""

#: ../../../CHANGELOG.md:2484
msgid "Implement the new `calcfunction` decorator. [[#2203]](https://github.com/aiidateam/aiida-core/pull/2203)"
msgstr ""

#: ../../../CHANGELOG.md:2485
msgid "Each profile now has its own daemon that can be run completely independently in parallel [[#1217]](https://github.com/aiidateam/aiida-core/pull/1217)"
msgstr ""

#: ../../../CHANGELOG.md:2486
msgid "Polling based daemon has been replaced with a much faster event-based daemon [[#1067]](https://github.com/aiidateam/aiida-core/pull/1067)"
msgstr ""

#: ../../../CHANGELOG.md:2487
msgid "Replaced `Celery` with `Circus` as the daemonizer of the daemon [[#1213]](https://github.com/aiidateam/aiida-core/pull/1213)"
msgstr ""

#: ../../../CHANGELOG.md:2488
msgid "The daemon can now be stopped without loading the database, making it possible to stop it even if the database version does not match the code [[#1231]](https://github.com/aiidateam/aiida-core/pull/1231)"
msgstr ""

#: ../../../CHANGELOG.md:2489
msgid "Implement exponential backoff retry mechanism for transport tasks [[#1837]](https://github.com/aiidateam/aiida-core/pull/1837)"
msgstr ""

#: ../../../CHANGELOG.md:2490
msgid "Pause `CalcJob` when transport task falls through exponential backoff [[#1903]](https://github.com/aiidateam/aiida-core/pull/1903)"
msgstr ""

#: ../../../CHANGELOG.md:2491
msgid "Separate `CalcJob` submit task in folder upload and scheduler submit [[#1946]](https://github.com/aiidateam/aiida-core/pull/1946)"
msgstr ""

#: ../../../CHANGELOG.md:2492
msgid "Each daemon worker now respects an optional minimum scheduler polling interval [[#1929]](https://github.com/aiidateam/aiida-core/pull/1929)"
msgstr ""

#: ../../../CHANGELOG.md:2493
msgid "Make the `execmanager.retrieve_calculation` idempotent'ish [[#3142]](https://github.com/aiidateam/aiida-core/pull/3142)"
msgstr ""

#: ../../../CHANGELOG.md:2494
msgid "Make the `execmanager.upload_calculation` idempotent'ish [[#3146]](https://github.com/aiidateam/aiida-core/pull/3146)"
msgstr ""

#: ../../../CHANGELOG.md:2495
msgid "Make the `execmanager.submit_calculation` idempotent'ish [[#3188]](https://github.com/aiidateam/aiida-core/pull/3188)"
msgstr ""

#: ../../../CHANGELOG.md:2496
msgid "Implement a `PluginVersionProvider` for processes to automatically add versions of `aiida-core` and plugin to process nodes [[#3131]](https://github.com/aiidateam/aiida-core/pull/3131)"
msgstr ""

#: ../../../CHANGELOG.md:2498
#: ../../source/reference/rest_api.rst:618
msgid "Processes"
msgstr ""

#: ../../../CHANGELOG.md:2499
msgid "Implement the `ProcessBuilder` which simplifies the definition of `Process` inputs and the launching of a `Process` [[#1116]](https://github.com/aiidateam/aiida-core/pull/1116)"
msgstr ""

#: ../../../CHANGELOG.md:2500
msgid "Namespaces added to the port containers of the `ProcessSpec` class [[#1099]](https://github.com/aiidateam/aiida-core/pull/1099)"
msgstr ""

#: ../../../CHANGELOG.md:2501
msgid "Convention of leading underscores for non-storable inputs is replaced with a proper `non_db` attribute of the `Port` class [[#1105]](https://github.com/aiidateam/aiida-core/pull/1105)"
msgstr ""

#: ../../../CHANGELOG.md:2502
msgid "Implement a Sphinx extension for the `WorkChain` class to automatically generate documentation from the workchain definition [[#1155]](https://github.com/aiidateam/aiida-core/pull/1155)"
msgstr ""

#: ../../../CHANGELOG.md:2503
msgid "`WorkChain`s can now expose the inputs and outputs of another `WorkChain`, which is great for writing modular workflows [[#1170]](https://github.com/aiidateam/aiida-core/pull/1170)"
msgstr ""

#: ../../../CHANGELOG.md:2504
msgid "Add built-in support and API for exit codes in `WorkChain`s [[#1640]](https://github.com/aiidateam/aiida-core/pull/1640), [[#1704]](https://github.com/aiidateam/aiida-core/pull/1704), [[#1681]](https://github.com/aiidateam/aiida-core/pull/1681)"
msgstr ""

#: ../../../CHANGELOG.md:2505
msgid "Implement method for `CalcJobNode` to create a restart builder  [[#1962]](https://github.com/aiidateam/aiida-core/pull/1962)"
msgstr ""

#: ../../../CHANGELOG.md:2506
msgid "Add `CalculationTools` base and entry point `aiida.tools.calculations` [[#2331]](https://github.com/aiidateam/aiida-core/pull/2331)"
msgstr ""

#: ../../../CHANGELOG.md:2507
msgid "Generalize Sphinx workchain extension to processes [[#3314]](https://github.com/aiidateam/aiida-core/pull/3314)"
msgstr ""

#: ../../../CHANGELOG.md:2508
msgid "Collapsible namespace in sphinxext [[#3441]](https://github.com/aiidateam/aiida-core/pull/3441)"
msgstr ""

#: ../../../CHANGELOG.md:2509
msgid "The `retrieve_singlefile_list` has been deprecated and is replaced by `retrieve_temporary_list` [[#3041]](https://github.com/aiidateam/aiida-core/pull/3041)"
msgstr ""

#: ../../../CHANGELOG.md:2510
msgid "Automatically set `CalcInfo.uuid` in `CalcJob.run` [[#2874]](https://github.com/aiidateam/aiida-core/pull/2874)"
msgstr ""

#: ../../../CHANGELOG.md:2511
msgid "Allow the usage of lambda functions for `InputPort` default values [[#3465]](https://github.com/aiidateam/aiida-core/pull/3465)"
msgstr ""

#: ../../../CHANGELOG.md:2513
msgid "ORM"
msgstr ""

#: ../../../CHANGELOG.md:2514
msgid "Implementat `AuthInfo` class which allows custom configuration per configured computer [[#1184]](https://github.com/aiidateam/aiida-core/pull/1184)"
msgstr ""

#: ../../../CHANGELOG.md:2515
msgid "Add efficient `count` method for `aiida.orm.groups.Group` [[#2567]](https://github.com/aiidateam/aiida-core/pull/2567)"
msgstr ""

#: ../../../CHANGELOG.md:2516
msgid "Speed up creation of Nodes in the AiiDA ORM [[#2214]](https://github.com/aiidateam/aiida-core/pull/2214)"
msgstr ""

#: ../../../CHANGELOG.md:2517
msgid "Enable use of tuple in `QueryBuilder.append` for all ORM classes [[#1608]](https://github.com/aiidateam/aiida-core/pull/1608), [[#1607]](https://github.com/aiidateam/aiida-core/pull/1607)"
msgstr ""

#: ../../../CHANGELOG.md:2518
msgid "Refactor the ORM to have explicit front-end and back-end layers [[#2190]](https://github.com/aiidateam/aiida-core/pull/2190)[[#2210]](https://github.com/aiidateam/aiida-core/pull/2210)[[#2225]](https://github.com/aiidateam/aiida-core/pull/2225)[[#2227]](https://github.com/aiidateam/aiida-core/pull/2227)[[#2481]](https://github.com/aiidateam/aiida-core/pull/2481)"
msgstr ""

#: ../../../CHANGELOG.md:2519
msgid "Add support for indexing and slicing in `orm.Group.nodes` iterator [[#2371]](https://github.com/aiidateam/aiida-core/pull/2371)"
msgstr ""

#: ../../../CHANGELOG.md:2520
msgid "Add support for process classes to QueryBuilder.append [[#2421]](https://github.com/aiidateam/aiida-core/pull/2421)"
msgstr ""

#: ../../../CHANGELOG.md:2521
msgid "Change type of uuids returned by the QueryBuilder to unicode [[#2259]](https://github.com/aiidateam/aiida-core/pull/2259)"
msgstr ""

#: ../../../CHANGELOG.md:2522
msgid "The `AttributeDict` is now constructed recursively for nested dictionaries [[#3005]](https://github.com/aiidateam/aiida-core/pull/3005)"
msgstr ""

#: ../../../CHANGELOG.md:2523
msgid "Ensure immutability of `CalcJobNode` hash before and after storing [[#3130]](https://github.com/aiidateam/aiida-core/pull/3130)"
msgstr ""

#: ../../../CHANGELOG.md:2524
msgid "Fix bug in the `RemoteData._clean` method [[#1847]](https://github.com/aiidateam/aiida-core/pull/1847)"
msgstr ""

#: ../../../CHANGELOG.md:2525
msgid "Fix bug in `QueryBuilder.first()` for multiple projections [[#2824]](https://github.com/aiidateam/aiida-core/pull/2824)"
msgstr ""

#: ../../../CHANGELOG.md:2526
msgid "Fix bug in `delete_nodes` when passing pks of non-existing nodes [[#2440]](https://github.com/aiidateam/aiida-core/pull/2440)"
msgstr ""

#: ../../../CHANGELOG.md:2527
msgid "Remove unserializable data from metadata in `Log` records [[#2469]](https://github.com/aiidateam/aiida-core/pull/2469)"
msgstr ""

#: ../../../CHANGELOG.md:2529
msgid "Data"
msgstr ""

#: ../../../CHANGELOG.md:2530
msgid "Fix bug in `parse_formula` for formulas with leading or trailing whitespace [[#2186]](https://github.com/aiidateam/aiida-core/pull/2186)"
msgstr ""

#: ../../../CHANGELOG.md:2531
msgid "Refactor `Orbital` code and fix some bugs [[#2737]](https://github.com/aiidateam/aiida-core/pull/2737)"
msgstr ""

#: ../../../CHANGELOG.md:2532
msgid "Fix bug in the `store` method of `CifData` which would raise an exception when called more than once [[#1136]](https://github.com/aiidateam/aiida-core/pull/1136)"
msgstr ""

#: ../../../CHANGELOG.md:2533
msgid "Allow passing directory path in `FolderData` constructor [[#3359]](https://github.com/aiidateam/aiida-core/pull/3359)"
msgstr ""

#: ../../../CHANGELOG.md:2534
msgid "Add element `X` to the elements list in order to support unknown species [[#1613]](https://github.com/aiidateam/aiida-core/pull/1613)"
msgstr ""

#: ../../../CHANGELOG.md:2535
msgid "Various bug and consistency fixes for `CifData` and `StructureData` [[#2374]](https://github.com/aiidateam/aiida-core/pull/2374)"
msgstr ""

#: ../../../CHANGELOG.md:2536
msgid "Changes to `Data` class attributes and `TrajectoryData` data storage [[#2310]](https://github.com/aiidateam/aiida-core/pull/2310)[[#2422]](https://github.com/aiidateam/aiida-core/pull/2422)"
msgstr ""

#: ../../../CHANGELOG.md:2537
msgid "Rename `ParameterData` to `Dict` [[#2530]](https://github.com/aiidateam/aiida-core/pull/2530)"
msgstr ""

#: ../../../CHANGELOG.md:2538
msgid "Remove the `FrozenDict` data sub class [[#2532]](https://github.com/aiidateam/aiida-core/pull/2532)"
msgstr ""

#: ../../../CHANGELOG.md:2539
msgid "Remove the `Error` data sub class [[#2529]](https://github.com/aiidateam/aiida-core/pull/2529)"
msgstr ""

#: ../../../CHANGELOG.md:2540
msgid "Make `Code` a real sub class of `Data` [[#2193]](https://github.com/aiidateam/aiida-core/pull/2193)"
msgstr ""

#: ../../../CHANGELOG.md:2541
msgid "Implement the `has_atomic_sites` and `has_unknown_species` properties for the `CifData` class [[#1257]](https://github.com/aiidateam/aiida-core/pull/1257)"
msgstr ""

#: ../../../CHANGELOG.md:2542
msgid "Change default library used in `_get_aiida_structure` (converting `CifData` to `StructureData`) from `ase` to `pymatgen` [[#1257]](https://github.com/aiidateam/aiida-core/pull/1257)"
msgstr ""

#: ../../../CHANGELOG.md:2543
msgid "Add converter for `UpfData` from UPF to JSON format [[#3308]](https://github.com/aiidateam/aiida-core/pull/3308)"
msgstr ""

#: ../../../CHANGELOG.md:2544
msgid "Fix potential inefficiency in `aiida.tools.data.cif` converters [[#3098]](https://github.com/aiidateam/aiida-core/pull/3098)"
msgstr ""

#: ../../../CHANGELOG.md:2545
msgid "Fix bug in `KpointsData.reciprocal_cell()` [[#2779]](https://github.com/aiidateam/aiida-core/pull/2779)"
msgstr ""

#: ../../../CHANGELOG.md:2546
msgid "Improve robustness of parsing versions and element names from UPF files [[#2296]](https://github.com/aiidateam/aiida-core/pull/2296)"
msgstr ""

#: ../../../CHANGELOG.md:2548
msgid "Verdi command line interface"
msgstr ""

#: ../../../CHANGELOG.md:2549
msgid "Migrate `verdi` to the click infrastructure [[#1795]](https://github.com/aiidateam/aiida-core/pull/1795)"
msgstr ""

#: ../../../CHANGELOG.md:2550
msgid "Add a default user to AiiDA configuration, eliminating the need to retype user information for every new profile [[#2734]](https://github.com/aiidateam/aiida-core/pull/2734)"
msgstr ""

#: ../../../CHANGELOG.md:2551
msgid "Implement tab-completion for profile in the `-p` option of `verdi` [[#2345]](https://github.com/aiidateam/aiida-core/pull/2345)"
msgstr ""

#: ../../../CHANGELOG.md:2552
msgid "Homogenize the interface of `verdi quicksetup` and `verdi setup` [[#1797]](https://github.com/aiidateam/aiida-core/pull/1797)"
msgstr ""

#: ../../../CHANGELOG.md:2553
msgid "Add the option `--version` to `verdi` to display current version [[#1811]](https://github.com/aiidateam/aiida-core/pull/1811)"
msgstr ""

#: ../../../CHANGELOG.md:2554
msgid "`verdi computer configure` can now read inputs from a yaml file through the `--config` option [[#2951]](https://github.com/aiidateam/aiida-core/pull/2951)"
msgstr ""

#: ../../../CHANGELOG.md:2556
msgid "External database importers"
msgstr ""

#: ../../../CHANGELOG.md:2557
msgid "Add importer class for the Materials Platform of Data Science API, which hosts the Pauling file data [[#1238]](https://github.com/aiidateam/aiida-core/pull/1238)"
msgstr ""

#: ../../../CHANGELOG.md:2558
msgid "Add an importer class for the Materials Project API [[#2097]](https://github.com/aiidateam/aiida-core/pull/2097)"
msgstr ""

#: ../../../CHANGELOG.md:2560
#: ../../../CHANGELOG.md:2992
msgid "Database"
msgstr ""

#: ../../../CHANGELOG.md:2561
msgid "Add an index to columns of `DbLink` for SqlAlchemy [[#2561]](https://github.com/aiidateam/aiida-core/pull/2561)"
msgstr ""

#: ../../../CHANGELOG.md:2562
msgid "Creating unique constraint and indexes at the `db_dbgroup_dbnodes` table for SqlAlchemy [[#1680]](https://github.com/aiidateam/aiida-core/pull/1680)"
msgstr ""

#: ../../../CHANGELOG.md:2563
msgid "Performance improvement for adding nodes to group [[#1677]](https://github.com/aiidateam/aiida-core/pull/1677)"
msgstr ""

#: ../../../CHANGELOG.md:2564
msgid "Make UUID columns unique in SqlAlchemy [[#2323]](https://github.com/aiidateam/aiida-core/pull/2323)"
msgstr ""

#: ../../../CHANGELOG.md:2565
msgid "Allow PostgreSQL connections via unix sockets [[#1721]](https://github.com/aiidateam/aiida-core/pull/1721)"
msgstr ""

#: ../../../CHANGELOG.md:2566
msgid "Drop the unused `nodeversion` and `public` columns from the node table [[#2937]](https://github.com/aiidateam/aiida-core/pull/2937)"
msgstr ""

#: ../../../CHANGELOG.md:2567
msgid "Drop various unused columns from the user table [[#2944]](https://github.com/aiidateam/aiida-core/pull/2944)"
msgstr ""

#: ../../../CHANGELOG.md:2568
msgid "Drop the unused `transport_params` column from the computer table [[#2946]](https://github.com/aiidateam/aiida-core/pull/2946)"
msgstr ""

#: ../../../CHANGELOG.md:2569
msgid "Drop the `DbCalcState` table [[#2198]](https://github.com/aiidateam/aiida-core/pull/2198)"
msgstr ""

#: ../../../CHANGELOG.md:2570
msgid "[Django]: migrate the node attribute and extra schema to use JSONB, greatly improving storage and querying efficiency [[#3090]](https://github.com/aiidateam/aiida-core/pull/3090)"
msgstr ""

#: ../../../CHANGELOG.md:2571
msgid "[SqlAlchemy]: Improve speed of node attribute and extra deserialization [[#3090]](https://github.com/aiidateam/aiida-core/pull/3090)"
msgstr ""

#: ../../../CHANGELOG.md:2573
msgid "Export and Import"
msgstr ""

#: ../../../CHANGELOG.md:2574
msgid "Implement the exporting and importing of node extras [[#2416]](https://github.com/aiidateam/aiida-core/pull/2416)"
msgstr ""

#: ../../../CHANGELOG.md:2575
msgid "Implement the exporting and importing of comments [[#2413]](https://github.com/aiidateam/aiida-core/pull/2413)"
msgstr ""

#: ../../../CHANGELOG.md:2576
msgid "Implement the exporting and importing of logs [[#2393]](https://github.com/aiidateam/aiida-core/pull/2393)"
msgstr ""

#: ../../../CHANGELOG.md:2577
msgid "Add `export_parameters` to the `metadata.json` in archive files [[#3386]](https://github.com/aiidateam/aiida-core/pull/3386)"
msgstr ""

#: ../../../CHANGELOG.md:2578
msgid "Simplify the data format of export archives, greatly reducing file size [[#3090]](https://github.com/aiidateam/aiida-core/pull/3090)"
msgstr ""

#: ../../../CHANGELOG.md:2579
msgid "`verdi import` automatically migrates archive files of old formats [[#2820]](https://github.com/aiidateam/aiida-core/pull/2820)"
msgstr ""

#: ../../../CHANGELOG.md:2581
#: ../../../CHANGELOG.md:2620
#: ../../../CHANGELOG.md:2645
#: ../../../CHANGELOG.md:2666
#: ../../../CHANGELOG.md:2708
#: ../../../CHANGELOG.md:2745
#: ../../../CHANGELOG.md:2792
#: ../../../CHANGELOG.md:2868
#: ../../../CHANGELOG.md:2946
msgid "Miscellaneous"
msgstr ""

#: ../../../CHANGELOG.md:2582
msgid "Refactor unit test managers and add basic fixtures for `pytest` [[#3319]](https://github.com/aiidateam/aiida-core/pull/3319)"
msgstr ""

#: ../../../CHANGELOG.md:2583
msgid "REST API v4: updates to conform with `aiida-core==1.0.0` [[#3429]](https://github.com/aiidateam/aiida-core/pull/3429)"
msgstr ""

#: ../../../CHANGELOG.md:2584
msgid "Improve decorators using the `wrapt` library such that function signatures are properly maintained [[#2991]](https://github.com/aiidateam/aiida-core/pull/2991)"
msgstr ""

#: ../../../CHANGELOG.md:2585
msgid "Allow empty `enabled` and `disabled` keys in caching configuration [[#3330]](https://github.com/aiidateam/aiida-core/pull/3330)"
msgstr ""

#: ../../../CHANGELOG.md:2586
msgid "AiiDA now enforces UTF-8 encoding for text output in its files and databases. [[#2107]](https://github.com/aiidateam/aiida-core/pull/2107)"
msgstr ""

#: ../../../CHANGELOG.md:2588
msgid "Backwards-incompatible changes (only a sub-set)"
msgstr ""

#: ../../../CHANGELOG.md:2589
msgid "Remove `aiida.tests` and obsolete `aiida.storage.tests.test_parsers` entry point group [[#2778]](https://github.com/aiidateam/aiida-core/pull/2778)"
msgstr ""

#: ../../../CHANGELOG.md:2590
msgid "Implement new link types [[#2220]](https://github.com/aiidateam/aiida-core/pull/2220)"
msgstr ""

#: ../../../CHANGELOG.md:2591
msgid "Rename the type strings of `Groups` and change the attributes `name` and `type` to `label` and `type_string` [[#2329]](https://github.com/aiidateam/aiida-core/pull/2329)"
msgstr ""

#: ../../../CHANGELOG.md:2592
msgid "Make various protected `Node` methods public [[#2544]](https://github.com/aiidateam/aiida-core/pull/2544)"
msgstr ""

#: ../../../CHANGELOG.md:2593
msgid "Rename `DbNode.type` to `DbNode.node_type` [[#2552]](https://github.com/aiidateam/aiida-core/pull/2552)"
msgstr ""

#: ../../../CHANGELOG.md:2594
msgid "Rename the ORM classes for `Node` sub classes `JobCalculation`, `WorkCalculation`, `InlineCalculation` and `FunctionCalculation` [[#2184]](https://github.com/aiidateam/aiida-core/pull/2184)[[#2189]](https://github.com/aiidateam/aiida-core/pull/2189)[[#2192]](https://github.com/aiidateam/aiida-core/pull/2192)[[#2195]](https://github.com/aiidateam/aiida-core/pull/2195)[[#2201]](https://github.com/aiidateam/aiida-core/pull/2201)"
msgstr ""

#: ../../../CHANGELOG.md:2595
msgid "Do not allow the `copy` or `deepcopy` of `Node`, except for `Data` nodes  [[#1705]](https://github.com/aiidateam/aiida-core/pull/1705)"
msgstr ""

#: ../../../CHANGELOG.md:2596
msgid "Remove `aiida.control` and `aiida.utils` top-level modules; reorganize `aiida.common`, `aiida.manage` and `aiida.tools` [[#2357]](https://github.com/aiidateam/aiida-core/pull/2357)"
msgstr ""

#: ../../../CHANGELOG.md:2597
msgid "Make the node repository API backend agnostic [[#2506]](https://github.com/aiidateam/aiida-core/pull/2506)"
msgstr ""

#: ../../../CHANGELOG.md:2598
msgid "Redesign the Parser class [[#2397]](https://github.com/aiidateam/aiida-core/pull/2397)"
msgstr ""

#: ../../../CHANGELOG.md:2599
msgid "[Django]: Remove support for datetime objects from node attributes and extras [[#3090]](https://github.com/aiidateam/aiida-core/pull/3090)"
msgstr ""

#: ../../../CHANGELOG.md:2600
msgid "Enforce specific precision in `clean_value` for floats when computing a node's hash [[#3108]](https://github.com/aiidateam/aiida-core/pull/3108)"
msgstr ""

#: ../../../CHANGELOG.md:2601
msgid "Move physical constants from `aiida.common.constants` to external `qe-tools` package [[#3278]](https://github.com/aiidateam/aiida-core/pull/3278)"
msgstr ""

#: ../../../CHANGELOG.md:2602
msgid "Add type checks to all plugin factories [[#3456]](https://github.com/aiidateam/aiida-core/pull/3456)"
msgstr ""

#: ../../../CHANGELOG.md:2603
msgid "Disallow pickle when storing numpy array in `ArrayData` [[#3434]](https://github.com/aiidateam/aiida-core/pull/3434)"
msgstr ""

#: ../../../CHANGELOG.md:2604
msgid "Remove implementation of legacy workflows [[#2379]](https://github.com/aiidateam/aiida-core/pull/2379)"
msgstr ""

#: ../../../CHANGELOG.md:2605
msgid "Implement `CalcJob` process class that replaces the deprecated `JobCalculation` [[#2389]](https://github.com/aiidateam/aiida-core/pull/2389)"
msgstr ""

#: ../../../CHANGELOG.md:2606
msgid "Change the structure of the `CalcInfo.local_copy_list` [[#2581]](https://github.com/aiidateam/aiida-core/pull/2581)"
msgstr ""

#: ../../../CHANGELOG.md:2607
msgid "QueryBuilder: Change 'ancestor_of'/'descendant_of' to 'with_descendants'/'with_ancestors' [[#2278]](https://github.com/aiidateam/aiida-core/pull/2278)"
msgstr ""

#: ../../../CHANGELOG.md:2611
msgid "v0.12.4"
msgstr ""

#: ../../../CHANGELOG.md:2614
msgid "Added new endpoint in rest api to get list of distinct node types [[#2745]](https://github.com/aiidateam/aiida-core/pull/2745)"
msgstr ""

#: ../../../CHANGELOG.md:2615
msgid "Travis: port the deploy stage from the development branch [[#2816]](https://github.com/aiidateam/aiida-core/pull/2816)"
msgstr ""

#: ../../../CHANGELOG.md:2617
#: ../../../CHANGELOG.md:2636
#: ../../../CHANGELOG.md:2658
#: ../../../CHANGELOG.md:2680
#: ../../../CHANGELOG.md:2700
#: ../../../CHANGELOG.md:2738
#: ../../../CHANGELOG.md:2768
#: ../../../CHANGELOG.md:2802
#: ../../../CHANGELOG.md:2824
#: ../../../CHANGELOG.md:2859
#: ../../../CHANGELOG.md:2879
msgid "Minor bug fixes"
msgstr ""

#: ../../../CHANGELOG.md:2618
msgid "Corrected the graph export set expansion rules [[#2632]](https://github.com/aiidateam/aiida-core/pull/2632)"
msgstr ""

#: ../../../CHANGELOG.md:2621
msgid "Backport streamlined quick install instructions from `provenance_redesign` [[#2555]](	https://github.com/aiidateam/aiida_core/pull/2555)"
msgstr ""

#: ../../../CHANGELOG.md:2622
msgid "Remove useless chainmap dependency [[#2799]](https://github.com/aiidateam/aiida-core/pull/2799)"
msgstr ""

#: ../../../CHANGELOG.md:2623
msgid "Add aiida-core version to docs home page [[#3058]](https://github.com/aiidateam/aiida-core/pull/3058)"
msgstr ""

#: ../../../CHANGELOG.md:2624
msgid "Docs: add note on increasing work_mem [[#2952]](https://github.com/aiidateam/aiida-core/pull/2952)"
msgstr ""

#: ../../../CHANGELOG.md:2627
msgid "v0.12.3"
msgstr ""

#: ../../../CHANGELOG.md:2630
msgid "Fast addition of nodes to groups with `skip_orm=True` [[#2471]](https://github.com/aiidateam/aiida-core/pull/2471)"
msgstr ""

#: ../../../CHANGELOG.md:2631
msgid "Add `environment.yml` for installing dependencies using conda; release of `aiida-core` on conda-forge channel [[#2081]](https://github.com/aiidateam/aiida-core/pull/2081)"
msgstr ""

#: ../../../CHANGELOG.md:2632
msgid "REST API: io tree response now includes link type and node label [[#2033]](https://github.com/aiidateam/aiida-core/pull/2033) [[#2511]](https://github.com/aiidateam/aiida-core/pull/2511)"
msgstr ""

#: ../../../CHANGELOG.md:2633
msgid "Backport postgres improvements for quicksetup [[#2433]](https://github.com/aiidateam/aiida-core/pull/2433)"
msgstr ""

#: ../../../CHANGELOG.md:2634
msgid "Backport `aiida.get_strict_version` (for plugin development) [[#2099]](https://github.com/aiidateam/aiida-core/pull/2099)"
msgstr ""

#: ../../../CHANGELOG.md:2637
msgid "Fix security vulnerability by upgrading `paramiko` to `2.4.2` [[#2043]](https://github.com/aiidateam/aiida-core/pull/2043)"
msgstr ""

#: ../../../CHANGELOG.md:2638
msgid "Disable caching for inline calculations (broken since move to ``workfunction``-based implementation) [[#1872]](https://github.com/aiidateam/aiida-core/pull/1872)"
msgstr ""

#: ../../../CHANGELOG.md:2639
msgid "Let `verdi help` return exit status 0 [[#2434]](https://github.com/aiidateam/aiida-core/pull/2434)"
msgstr ""

#: ../../../CHANGELOG.md:2640
msgid "Decode dict keys only if strings (backport) [[#2436]](https://github.com/aiidateam/aiida-core/pull/2436)"
msgstr ""

#: ../../../CHANGELOG.md:2641
msgid "Remove broken verdi-plug entry point [[#2356]](https://github.com/aiidateam/aiida-core/pull/2356)"
msgstr ""

#: ../../../CHANGELOG.md:2642
msgid "`verdi node delete` (without arguments) no longer tries to delete all nodes [[#2545]](https://github.com/aiidateam/aiida-core/pull/2545)"
msgstr ""

#: ../../../CHANGELOG.md:2643
msgid "Fix plotting of `BandsData` objects [[#2492]](https://github.com/aiidateam/aiida-core/pull/2492)"
msgstr ""

#: ../../../CHANGELOG.md:2646
msgid "REST API: add tests for random sorting list entries of same type [[#2106]](https://github.com/aiidateam/aiida-core/pull/2106)"
msgstr ""

#: ../../../CHANGELOG.md:2647
msgid "Add various badges to README [[#1969]](https://github.com/aiidateam/aiida-core/pull/1969)"
msgstr ""

#: ../../../CHANGELOG.md:2648
msgid "Minor documentation improvements [[#1955]](https://github.com/aiidateam/aiida-core/pull/1955)"
msgstr ""

#: ../../../CHANGELOG.md:2649
msgid "Add license file to MANIFEST [[#2339]](https://github.com/aiidateam/aiida-core/pull/2339)"
msgstr ""

#: ../../../CHANGELOG.md:2650
msgid "Add instructions when `verdi import` fails [[#2420]](https://github.com/aiidateam/aiida-core/pull/2420)"
msgstr ""

#: ../../../CHANGELOG.md:2652
msgid "v0.12.2"
msgstr ""

#: ../../../CHANGELOG.md:2655
msgid "Support the hashing of `uuid.UUID` types by registering a hashing function  [[#1861]](https://github.com/aiidateam/aiida-core/pull/1861)"
msgstr ""

#: ../../../CHANGELOG.md:2656
msgid "Add documentation on plugin cutter [[#1904]](https://github.com/aiidateam/aiida-core/pull/1904)"
msgstr ""

#: ../../../CHANGELOG.md:2659
msgid "Make exported graphs consistent with the current node and link hierarchy definition [[#1764]](https://github.com/aiidateam/aiida-core/pull/1764)"
msgstr ""

#: ../../../CHANGELOG.md:2660
msgid "Fix link import problem under SQLA [[#1769]](https://github.com/aiidateam/aiida-core/pull/1769)"
msgstr ""

#: ../../../CHANGELOG.md:2661
msgid "Fix cache folder copying [[#1746]](https://github.com/aiidateam/aiida-core/pull/1746) [[1752]](https://github.com/aiidateam/aiida-core/pull/1752)"
msgstr ""

#: ../../../CHANGELOG.md:2662
msgid "Fix bug in mixins.py when copying node [[#1743]](https://github.com/aiidateam/aiida-core/pull/1743)"
msgstr ""

#: ../../../CHANGELOG.md:2663
msgid "Fix pgtest failures (release-branch) on travis [[#1736]](https://github.com/aiidateam/aiida-core/pull/1736)"
msgstr ""

#: ../../../CHANGELOG.md:2664
msgid "Fix plugin: return testrunner result to fail on travis, when tests don't pass [[#1676]](https://github.com/aiidateam/aiida-core/pull/1676)"
msgstr ""

#: ../../../CHANGELOG.md:2667
msgid "Remove pycrypto dependency, as it was found to have sercurity flaws [[#1754]](https://github.com/aiidateam/aiida-core/pull/1754)"
msgstr ""

#: ../../../CHANGELOG.md:2668
msgid "Set xsf as default format for structures visualization [[#1756]](https://github.com/aiidateam/aiida-core/pull/1756)"
msgstr ""

#: ../../../CHANGELOG.md:2669
msgid "Delete unused `utils/create_requirements.py` file [[#1702]](https://github.com/aiidateam/aiida-core/pull/1702)"
msgstr ""

#: ../../../CHANGELOG.md:2672
msgid "v0.12.1"
msgstr ""

#: ../../../CHANGELOG.md:2675
msgid "Always use a bash login shell to execute all remote SSH commands, overriding any system default shell [[#1502]](https://github.com/aiidateam/aiida-core/pull/1502)"
msgstr ""

#: ../../../CHANGELOG.md:2676
msgid "Reduced the size of the distributed package by almost half by removing test fixtures and generating the data on the fly [[#1645]](https://github.com/aiidateam/aiida-core/pull/1645)"
msgstr ""

#: ../../../CHANGELOG.md:2677
msgid "Removed the explicit dependency upper limit for `scipy` [[#1492]](https://github.com/aiidateam/aiida-core/pull/1492)"
msgstr ""

#: ../../../CHANGELOG.md:2678
msgid "Resolved various dependency requirement conflicts [[#1488]](https://github.com/aiidateam/aiida-core/pull/1488)"
msgstr ""

#: ../../../CHANGELOG.md:2681
msgid "Fixed a bug in `verdi node delete` that would throw an exception for certain cases [[#1564]](https://github.com/aiidateam/aiida-core/pull/1564)"
msgstr ""

#: ../../../CHANGELOG.md:2682
msgid "Fixed a bug in the `cif` endpoint of the REST API [[#1490]](https://github.com/aiidateam/aiida-core/pull/1490)"
msgstr ""

#: ../../../CHANGELOG.md:2685
msgid "v0.12.0"
msgstr ""

#: ../../../CHANGELOG.md:2688
msgid "Hashing, caching and fast-forwarding [[#652]](https://github.com/aiidateam/aiida-core/pull/652)"
msgstr ""

#: ../../../CHANGELOG.md:2689
msgid "Calculation no longer stores full source file [[#1082]](https://github.com/aiidateam/aiida-core/pull/1082)"
msgstr ""

#: ../../../CHANGELOG.md:2690
msgid "Delete nodes via `verdi node delete` [[#1083]](https://github.com/aiidateam/aiida-core/pull/1083)"
msgstr ""

#: ../../../CHANGELOG.md:2691
msgid "Import structures using ASE [[#1085]](https://github.com/aiidateam/aiida-core/pull/1085)"
msgstr ""

#: ../../../CHANGELOG.md:2692
msgid "`StructureData` - `pymatgen` - `StructureData` roundtrip works for arbitrary kind names [[#1285]](https://github.com/aiidateam/aiida-core/pull/1285) [[#1306]](https://github.com/aiidateam/aiida-core/pull/1306) [[#1357]](https://github.com/aiidateam/aiida-core/pull/1357)"
msgstr ""

#: ../../../CHANGELOG.md:2693
msgid "Output format of archive file can now be defined for `verdi export migrate` [[#1383]](https://github.com/aiidateam/aiida-core/pull/1383)"
msgstr ""

#: ../../../CHANGELOG.md:2694
msgid "Automatic reporting of code coverage by unit tests has been added [[#1422]](https://github.com/aiidateam/aiida-core/pull/1422)"
msgstr ""

#: ../../../CHANGELOG.md:2697
msgid "Add `parser_name` `JobProcess` options [[#1118]](https://github.com/aiidateam/aiida-core/pull/1118)"
msgstr ""

#: ../../../CHANGELOG.md:2698
msgid "Node attribute reads were not always up to date across interpreters for SqlAlchemy [[#1379]](https://github.com/aiidateam/aiida-core/pull/1379)"
msgstr ""

#: ../../../CHANGELOG.md:2701
msgid "Cell vectors not printed correctly [[#1087]](https://github.com/aiidateam/aiida-core/pull/1087)"
msgstr ""

#: ../../../CHANGELOG.md:2702
msgid "Fix read-the-docs issues [[#1120]](https://github.com/aiidateam/aiida-core/pull/1120) [[#1143]](https://github.com/aiidateam/aiida-core/pull/1143)"
msgstr ""

#: ../../../CHANGELOG.md:2703
msgid "Fix structure/band visualization in REST API [[#1167]](https://github.com/aiidateam/aiida-core/pull/1167) [[#1182]](https://github.com/aiidateam/aiida-core/pull/1182)"
msgstr ""

#: ../../../CHANGELOG.md:2704
msgid "Fix `verdi work list` test [[#1286]](https://github.com/aiidateam/aiida-core/pull/1286)"
msgstr ""

#: ../../../CHANGELOG.md:2705
msgid "Fix `_inline_to_standalone_script` in `TCODExporter` [[#1351]](https://github.com/aiidateam/aiida-core/pull/1351)"
msgstr ""

#: ../../../CHANGELOG.md:2706
msgid "Updated `reentry` to fix various small bugs related to plugin registering [[#1440]](https://github.com/aiidateam/aiida-core/pull/1440)"
msgstr ""

#: ../../../CHANGELOG.md:2709
msgid "Bump `qe-tools` version [[#1090]](https://github.com/aiidateam/aiida-core/pull/1090)"
msgstr ""

#: ../../../CHANGELOG.md:2710
msgid "Document link types [[#1174]](https://github.com/aiidateam/aiida-core/pull/1174)"
msgstr ""

#: ../../../CHANGELOG.md:2711
msgid "Switch to trusty + postgres 9.5 on Travis [[#1180]](https://github.com/aiidateam/aiida-core/pull/1180)"
msgstr ""

#: ../../../CHANGELOG.md:2712
msgid "Use raw SQL in sqlalchemy migration of `Code` [[#1291]](https://github.com/aiidateam/aiida-core/pull/1291)"
msgstr ""

#: ../../../CHANGELOG.md:2713
msgid "Document querying of list attributes [[#1326]](https://github.com/aiidateam/aiida-core/pull/1326)"
msgstr ""

#: ../../../CHANGELOG.md:2714
msgid "Document running `aiida` as a daemon service [[#1445]](https://github.com/aiidateam/aiida-core/pull/1445)"
msgstr ""

#: ../../../CHANGELOG.md:2715
msgid "Document that Torque and LoadLever schedulers are now fully supported [[#1447]](https://github.com/aiidateam/aiida-core/pull/1447)"
msgstr ""

#: ../../../CHANGELOG.md:2716
msgid "Cookbook: how to check the number of queued/running jobs in the scheduler [[#1349]](https://github.com/aiidateam/aiida-core/pull/1349)"
msgstr ""

#: ../../../CHANGELOG.md:2719
msgid "v0.11.4"
msgstr ""

#: ../../../CHANGELOG.md:2722
msgid "PyCifRW upgraded to 4.2.1 [[#1073]](https://github.com/aiidateam/aiida-core/pull/1073)"
msgstr ""

#: ../../../CHANGELOG.md:2725
msgid "Persist and load parsed workchain inputs and do not recreate to avoid creating duplicates for default inputs [[#1362]](https://github.com/aiidateam/aiida-core/pull/1362)"
msgstr ""

#: ../../../CHANGELOG.md:2726
msgid "Serialize `WorkChain` context before persisting [[#1354]](https://github.com/aiidateam/aiida-core/pull/1354)"
msgstr ""

#: ../../../CHANGELOG.md:2729
msgid "v0.11.3"
msgstr ""

#: ../../../CHANGELOG.md:2732
msgid "Documentation: AiiDA now has an automatically generated and complete API documentation (using `sphinx-apidoc`) [[#1330]](https://github.com/aiidateam/aiida-core/pull/1330)"
msgstr ""

#: ../../../CHANGELOG.md:2733
msgid "Add JSON schema for connection of REST API to Materials Cloud Explore interface  [[#1336]](https://github.com/aiidateam/aiida-core/pull/1336)"
msgstr ""

#: ../../../CHANGELOG.md:2736
msgid "`FINISHED_KEY` and `FAILED_KEY` variables were not known to `AbstractCalculation` [[#1314]](https://github.com/aiidateam/aiida-core/pull/1314)"
msgstr ""

#: ../../../CHANGELOG.md:2739
msgid "Make 'REST' extra lowercase, such that one can do `pip install aiida-core[rest]` [[#1328]](https://github.com/aiidateam/aiida-core/pull/1328)"
msgstr ""

#: ../../../CHANGELOG.md:2740
msgid "`CifData` `/visualization` endpoint was not returning data [[#1328]](https://github.com/aiidateam/aiida-core/pull/1328)"
msgstr ""

#: ../../../CHANGELOG.md:2743
msgid "`QueryTool` (was deprecated in favor of `QueryBuilder` since v0.8.0) [[#1330]](https://github.com/aiidateam/aiida-core/pull/1330)"
msgstr ""

#: ../../../CHANGELOG.md:2746
msgid "Add `gource` config for generating a video of development history [[#1337]](https://github.com/aiidateam/aiida-core/pull/1337)"
msgstr ""

#: ../../../CHANGELOG.md:2749
msgid "v0.11.2:"
msgstr ""

#: ../../../CHANGELOG.md:2752
msgid "Link types were not respected in `Node.get_inputs` for SqlAlchemy [[#1271]](https://github.com/aiidateam/aiida-core/pull/1271)"
msgstr ""

#: ../../../CHANGELOG.md:2755
msgid "v0.11.1:"
msgstr ""

#: ../../../CHANGELOG.md:2758
msgid "Support visualization of structures and cif files with VESTA [[#1093]](https://github.com/aiidateam/aiida-core/pull/1093)"
msgstr ""

#: ../../../CHANGELOG.md:2759
msgid "Better fallback when node class is not available [[#1185]](https://github.com/aiidateam/aiida-core/pull/1185)"
msgstr ""

#: ../../../CHANGELOG.md:2760
msgid "`CifData` now supports faster parsing and lazy loading [[#1190]](https://github.com/aiidateam/aiida-core/pull/1190)"
msgstr ""

#: ../../../CHANGELOG.md:2761
msgid "REST endpoint for `CifData`, API reports full list of available endpoints [[#1228]](https://github.com/aiidateam/aiida-core/pull/1228)"
msgstr ""

#: ../../../CHANGELOG.md:2762
msgid "Various smaller improvements [[#1100]](https://github.com/aiidateam/aiida-core/pull/1100) [[#1182]](https://github.com/aiidateam/aiida-core/pull/1182)"
msgstr ""

#: ../../../CHANGELOG.md:2765
msgid "Restore attribute immutability in nodes [[#1111]](https://github.com/aiidateam/aiida-core/pull/1111)"
msgstr ""

#: ../../../CHANGELOG.md:2766
msgid "Fix daemonization issue that could cause aiida daemon to be killed [[#1246]](https://github.com/aiidateam/aiida-core/pull/1246)"
msgstr ""

#: ../../../CHANGELOG.md:2769
msgid "Fix type column in `verdi calculation list` [[#960]](https://github.com/aiidateam/aiida-core/pull/960) [[#1053]](https://github.com/aiidateam/aiida-core/pull/1053)"
msgstr ""

#: ../../../CHANGELOG.md:2770
msgid "Fix `verdi import` from URLs [[#1139]](https://github.com/aiidateam/aiida-core/pull/1139)"
msgstr ""

#: ../../../CHANGELOG.md:2773
msgid "v0.11.0:"
msgstr ""

#: ../../../CHANGELOG.md:2777
msgid "Core entities"
msgstr ""

#: ../../../CHANGELOG.md:2778
msgid "`Computer`: the shebang line is now customizable [[#940]](https://github.com/aiidateam/aiida-core/pull/940)"
msgstr ""

#: ../../../CHANGELOG.md:2779
msgid "`KpointsData`: deprecate buggy legacy implementation of k-point generation in favor of Seekpath [[#1015]](https://github.com/aiidateam/aiida-core/pull/1015)"
msgstr ""

#: ../../../CHANGELOG.md:2780
msgid "`Dict`: `to_aiida_type` used on dictionaries now automatically converted to `Dict` [[#947]](https://github.com/aiidateam/aiida-core/pull/947)"
msgstr ""

#: ../../../CHANGELOG.md:2781
msgid "`JobCalculation`: parsers can now specify files that are retrieved locally for parsing, but only temporarily, as they are deleted after parsing is completed [[#886]](https://github.com/aiidateam/aiida-core/pull/886) [[#894]](https://github.com/aiidateam/aiida-core/pull/894)"
msgstr ""

#: ../../../CHANGELOG.md:2783
#: ../../../CHANGELOG.md:3012
msgid "Plugins"
msgstr ""

#: ../../../CHANGELOG.md:2784
msgid "Plugin data hooks: plugins can now add custom commands to `verdi data` [[#993]](https://github.com/aiidateam/aiida-core/pull/993)"
msgstr ""

#: ../../../CHANGELOG.md:2785
msgid "Plugin fixtures: simple-to-use decorators for writing tests of plugins [[#716]](https://github.com/aiidateam/aiida-core/pull/716) [[#865]](https://github.com/aiidateam/aiida-core/pull/865)"
msgstr ""

#: ../../../CHANGELOG.md:2786
msgid "Plugin development: no longer swallow `ImportError` exception during import of plugins [[#1029]](https://github.com/aiidateam/aiida-core/pull/1029)"
msgstr ""

#: ../../../CHANGELOG.md:2788
msgid "Verdi"
msgstr ""

#: ../../../CHANGELOG.md:2789
msgid "`verdi shell`: improve tab completion of imports in  [[#1008]](https://github.com/aiidateam/aiida-core/pull/1008)"
msgstr ""

#: ../../../CHANGELOG.md:2790
msgid "`verdi work list`: projections for verdi work list [[#847]](https://github.com/aiidateam/aiida-core/pull/847)"
msgstr ""

#: ../../../CHANGELOG.md:2793
msgid "Supervisor removal: dependency on unix-only supervisor package removed [[#790]](https://github.com/aiidateam/aiida-core/pull/790)"
msgstr ""

#: ../../../CHANGELOG.md:2794
msgid "REST API: add server info endpoint, structure endpoint can return different file formats [[#878]](https://github.com/aiidateam/aiida-core/pull/878)"
msgstr ""

#: ../../../CHANGELOG.md:2795
msgid "REST API: update endpoints for structure visualization, calculation (includes retrieved input & output list), add endpoints for `UpfData` and more [[#977]](https://github.com/aiidateam/aiida-core/pull/977) [[#991]](https://github.com/aiidateam/aiida-core/pull/991)"
msgstr ""

#: ../../../CHANGELOG.md:2796
msgid "Tests using daemon run faster [[#870]](https://github.com/aiidateam/aiida-core/pull/870)"
msgstr ""

#: ../../../CHANGELOG.md:2797
msgid "Documentation: updated outdated workflow examples [[#948]](https://github.com/aiidateam/aiida-core/pull/948)"
msgstr ""

#: ../../../CHANGELOG.md:2798
msgid "Documentation: updated import/export [[#994]](https://github.com/aiidateam/aiida-core/pull/994),"
msgstr ""

#: ../../../CHANGELOG.md:2799
msgid "Documentation: plugin quickstart [[#996]](https://github.com/aiidateam/aiida-core/pull/996),"
msgstr ""

#: ../../../CHANGELOG.md:2800
msgid "Documentation: parser example [[#1003]](https://github.com/aiidateam/aiida-core/pull/1003)"
msgstr ""

#: ../../../CHANGELOG.md:2803
msgid "Fix bug with repository on external hard drive [[#982]](https://github.com/aiidateam/aiida-core/pull/982)"
msgstr ""

#: ../../../CHANGELOG.md:2804
msgid "Fix bug in configuration of pre-commit hooks [[#863]](https://github.com/aiidateam/aiida-core/pull/863)"
msgstr ""

#: ../../../CHANGELOG.md:2805
msgid "Fix and improve plugin loader tests [[#1025]](https://github.com/aiidateam/aiida-core/pull/1025)"
msgstr ""

#: ../../../CHANGELOG.md:2806
msgid "Fix broken celery logging [[#1033]](https://github.com/aiidateam/aiida-core/pull/1033)"
msgstr ""

#: ../../../CHANGELOG.md:2809
msgid "async from aiida.work.run has been deprecated because it can lead to race conditions and thereby unexpected behavior [[#1040]](https://github.com/aiidateam/aiida-core/pull/1040)"
msgstr ""

#: ../../../CHANGELOG.md:2812
msgid "v0.10.1:"
msgstr ""

#: ../../../CHANGELOG.md:2815
msgid "Improved exception handling for loading db tests [[#968]](https://github.com/aiidateam/aiida-core/pull/968)"
msgstr ""

#: ../../../CHANGELOG.md:2816
msgid "`verdi work kill` on workchains: skip calculation if it cannot be killed, rather than stopping [[#980]](https://github.com/aiidateam/aiida-core/pull/980)"
msgstr ""

#: ../../../CHANGELOG.md:2817
msgid "Remove unnecessary INFO messages of Alembic for SQLAlchemy backend [[#1012]](https://github.com/aiidateam/aiida-core/pull/1012)"
msgstr ""

#: ../../../CHANGELOG.md:2818
msgid "Add filter to suppress unnecessary log messages during testing [[#1014]](https://github.com/aiidateam/aiida-core/pull/1014)"
msgstr ""

#: ../../../CHANGELOG.md:2821
msgid "Fix bug in `verdi quicksetup` on Ubuntu 16.04 and add regression tests to catch similar problems in the future [[#976]](https://github.com/aiidateam/aiida-core/pull/976)"
msgstr ""

#: ../../../CHANGELOG.md:2822
msgid "Fix bug in `verdi data` list commands for SQLAlchemy backend [[#1007]](https://github.com/aiidateam/aiida-core/pull/1007)"
msgstr ""

#: ../../../CHANGELOG.md:2825
msgid "Various bug fixes related to workflows for the SQLAlchemy backend [[#952]](https://github.com/aiidateam/aiida-core/pull/952) [[#960]](https://github.com/aiidateam/aiida-core/pull/960)"
msgstr ""

#: ../../../CHANGELOG.md:2828
msgid "v0.10.0:"
msgstr ""

#: ../../../CHANGELOG.md:2830
msgid "Major changes"
msgstr ""

#: ../../../CHANGELOG.md:2831
msgid "The `DbPath` table has been removed and replaced with a dynamic transitive closure, because, among others, nested workchains could lead to the `DbPath` table exploding in size"
msgstr ""

#: ../../../CHANGELOG.md:2832
msgid "Code plugins have been removed from `aiida-core` and have been migrated to their own respective plugin repositories and can be found here:"
msgstr ""

#: ../../../CHANGELOG.md:2833
msgid "[Quantum ESPRESSO](https://github.com/aiidateam/aiida-quantumespresso)"
msgstr ""

#: ../../../CHANGELOG.md:2834
msgid "[ASE](https://github.com/aiidateam/aiida-ase)"
msgstr ""

#: ../../../CHANGELOG.md:2835
msgid "[COD tools](https://github.com/aiidateam/aiida-codtools)"
msgstr ""

#: ../../../CHANGELOG.md:2836
msgid "[NWChem](https://github.com/aiidateam/aiida-nwchem)"
msgstr ""

#: ../../../CHANGELOG.md:2838
msgid "Each can be installed from `pip` using e.g. `pip install aiida-quantumespresso`.   Existing installations will require a migration (see [update instructions in the documentation](https://aiida-core.readthedocs.io/en/v0.10.0/installation/updating.html#plugin-migration)).   For a complete overview of available plugins you can visit [the registry](https://aiidateam.github.io/aiida-registry/)."
msgstr ""

#: ../../../CHANGELOG.md:2843
msgid "A new entry `retrieve_temporary_list` in `CalcInfo` allows to retrieve files temporarily for parsing, while not having to store them permanently in the repository [[#903]](https://github.com/aiidateam/aiida-core/pull/903)"
msgstr ""

#: ../../../CHANGELOG.md:2844
msgid "New verdi command: `verdi work kill` to kill running workchains [[#821]](https://github.com/aiidateam/aiida-core/pull/821)"
msgstr ""

#: ../../../CHANGELOG.md:2845
msgid "New verdi command: `verdi data remote [ls,cat,show]` to inspect the contents of `RemoteData` objects [[#743]](https://github.com/aiidateam/aiida-core/pull/743)"
msgstr ""

#: ../../../CHANGELOG.md:2846
msgid "New verdi command: `verdi export migrate` allows the migration of existing export archives to new formats [[#781]](https://github.com/aiidateam/aiida-core/pull/781)"
msgstr ""

#: ../../../CHANGELOG.md:2847
msgid "New verdi command: `verdi profile delete` [[#606]](https://github.com/aiidateam/aiida-core/pull/606)"
msgstr ""

#: ../../../CHANGELOG.md:2848
msgid "Implemented a new option `-m` for the `verdi work report` command to limit the number of nested levels to be printed [[#888]](https://github.com/aiidateam/aiida-core/pull/888)"
msgstr ""

#: ../../../CHANGELOG.md:2849
msgid "Added a `running` field to the output of `verdi work list` to give the current state of the workchains [[#888]](https://github.com/aiidateam/aiida-core/pull/888)"
msgstr ""

#: ../../../CHANGELOG.md:2850
msgid "Implemented faster query to obtain database statistics [[#738]](https://github.com/aiidateam/aiida-core/pull/738)"
msgstr ""

#: ../../../CHANGELOG.md:2851
msgid "Added testing for automatic SqlAlchemy database migrations through alembic [[#834]](https://github.com/aiidateam/aiida-core/pull/834)"
msgstr ""

#: ../../../CHANGELOG.md:2852
msgid "Exceptions that are triggered in steps of a `WorkChain` are now properly logged to the `Node` making them visible through `verdi work report` [[#908]](https://github.com/aiidateam/aiida-core/pull/908)"
msgstr ""

#: ../../../CHANGELOG.md:2855
msgid "Export will now write the link types to the archive and import will properly recreate the link [[#760]](https://github.com/aiidateam/aiida-core/pull/760)"
msgstr ""

#: ../../../CHANGELOG.md:2856
msgid "Fix bug in workchain persistence that would lead to crashed workchains under certain conditions being resubmitted [[#728]](https://github.com/aiidateam/aiida-core/pull/728)"
msgstr ""

#: ../../../CHANGELOG.md:2857
msgid "Fix bug in the pickling of `WorkChain` instances containing an `_if` logical block in the outline [[#904]](https://github.com/aiidateam/aiida-core/pull/904)"
msgstr ""

#: ../../../CHANGELOG.md:2860
msgid "The logger for subclasses of `AbstractNode` is now properly namespaced to `aiida.` such that it works in plugins outside of the `aiida-core` source tree [[#897]](https://github.com/aiidateam/aiida-core/pull/897)"
msgstr ""

#: ../../../CHANGELOG.md:2861
msgid "Fixed a problem with the states of the direct scheduler that was causing the daemon process to hang during submission [[#879]](https://github.com/aiidateam/aiida-core/pull/879)"
msgstr ""

#: ../../../CHANGELOG.md:2862
msgid "Various bug fixes related to the old workflows in combination with the SqlAlchemy backend [[#889]](https://github.com/aiidateam/aiida-core/pull/889) [[#898]](https://github.com/aiidateam/aiida-core/pull/898)"
msgstr ""

#: ../../../CHANGELOG.md:2863
msgid "Fixed bug in `TCODexporter` [[#761]](https://github.com/aiidateam/aiida-core/pull/761)"
msgstr ""

#: ../../../CHANGELOG.md:2864
msgid "`verdi profile delete` now respects the configured `dbport` setting [[#713]](https://github.com/aiidateam/aiida-core/pull/713)"
msgstr ""

#: ../../../CHANGELOG.md:2865
msgid "Restore correct help text for `verdi --help` [[#704]](https://github.com/aiidateam/aiida-core/pull/704)"
msgstr ""

#: ../../../CHANGELOG.md:2866
msgid "Fixed query in the ICSD importer element that caused certain structures to be erroneously skipped [[#690]](https://github.com/aiidateam/aiida-core/pull/690)"
msgstr ""

#: ../../../CHANGELOG.md:2869
msgid "Added a \"quickstart\" to plugin development in the [documentation](http://aiida-core.readthedocs.io/en/v0.10.0/developer_guide/plugins/quickstart.html), structured around the new [plugintemplate](https://github.com/aiidateam/aiida-plugin-template) [[#818]](https://github.com/aiidateam/aiida-core/pull/818)"
msgstr ""

#: ../../../CHANGELOG.md:2871
msgid "Improved and restructured the developer documentation [[#818]](https://github.com/aiidateam/aiida-core/pull/818)"
msgstr ""

#: ../../../CHANGELOG.md:2874
msgid "v0.9.1:"
msgstr ""

#: ../../../CHANGELOG.md:2877
msgid "Workchain steps will no longer be executed multiple times due to process pickles not being locked"
msgstr ""

#: ../../../CHANGELOG.md:2880
msgid "Fix arithmetic operations for basic numeric types"
msgstr ""

#: ../../../CHANGELOG.md:2881
msgid "Fixed `verdi calculation cleanworkdir` after changes in `QueryBuilder` syntax"
msgstr ""

#: ../../../CHANGELOG.md:2882
msgid "Fixed `verdi calculation logshow` exception when called for `WorkCalculation` nodes"
msgstr ""

#: ../../../CHANGELOG.md:2883
msgid "Fixed `verdi import` for SQLAlchemy profiles"
msgstr ""

#: ../../../CHANGELOG.md:2884
msgid "Fixed bug in `reentry` and update dependency requirement to `v1.0.2`"
msgstr ""

#: ../../../CHANGELOG.md:2885
msgid "Made octal literal string compatible with python 3"
msgstr ""

#: ../../../CHANGELOG.md:2886
msgid "Fixed broken import in the ASE plugin"
msgstr ""

#: ../../../CHANGELOG.md:2889
msgid "`verdi calculation show` now properly distinguishes between `WorkCalculation` and `JobCalculation` nodes"
msgstr ""

#: ../../../CHANGELOG.md:2890
msgid "Improved error handling in `verdi setup --non-interactive`"
msgstr ""

#: ../../../CHANGELOG.md:2891
msgid "Disable unnecessary console logging for tests"
msgstr ""

#: ../../../CHANGELOG.md:2894
msgid "v0.9.0"
msgstr ""

#: ../../../CHANGELOG.md:2896
msgid "Data export functionality"
msgstr ""

#: ../../../CHANGELOG.md:2897
msgid "A number of new functionalities have been added to export band structures to a number of formats, including: gnuplot, matplotlib (both to export a python file, and directly PNG or PDF; both with support of LaTeX typesetting and not); JSON; improved agr (xmgrace) output. Also support for two-color bands for collinear magnetic systems. Added also possibility to specify export-format-specific parameters."
msgstr ""

#: ../../../CHANGELOG.md:2898
msgid "Added method get_export_formats() to know available export formats for a given data subclass"
msgstr ""

#: ../../../CHANGELOG.md:2899
msgid "Added label prettifiers to properly typeset high-symmetry k-point labels for different formats (simple/old format, seekpath, ...) into a number of plotting codes (xmgrace, gnuplot, latex, ...)"
msgstr ""

#: ../../../CHANGELOG.md:2900
msgid "Improvement of command-line export functionality (more options, possibility to write directly to file, possibility to pass custom options to exporter, by removing its DbPath dependency)"
msgstr ""

#: ../../../CHANGELOG.md:2902
msgid "Workchains"
msgstr ""

#: ../../../CHANGELOG.md:2903
msgid "Crucial bug fix: workchains can now be run through the daemon, i.e. by using `aiida.work.submit`"
msgstr ""

#: ../../../CHANGELOG.md:2904
msgid "Enhancement: added an `abort` and `abort_nowait` method to `WorkChain` which allows to abort the workchain at the earliest possible moment"
msgstr ""

#: ../../../CHANGELOG.md:2905
msgid "Enhancement: added the `report` method to `WorkChain`, which allows a workchain developer to log messages to the database"
msgstr ""

#: ../../../CHANGELOG.md:2906
msgid "Enhancement: added command `verdi work report` which for a given `pk` returns the messages logged for a `WorkChain` through the `report` method"
msgstr ""

#: ../../../CHANGELOG.md:2907
msgid "Enhancement: workchain inputs ports with a valid default specified no longer require to explicitly set `required=False` but is overriden automatically"
msgstr ""

#: ../../../CHANGELOG.md:2909
msgid "New plugin system"
msgstr ""

#: ../../../CHANGELOG.md:2910
msgid "New plugin system implemented, allowing to load aiida entrypoints, and working in parallel with old system (still experimental, though - command line entry points are not fully implemented yet)"
msgstr ""

#: ../../../CHANGELOG.md:2911
msgid "Support for the plugin registry"
msgstr ""

#: ../../../CHANGELOG.md:2913
msgid "Code refactoring"
msgstr ""

#: ../../../CHANGELOG.md:2914
msgid "Refactoring of `Node` to move as much as possible of the caching code into the abstract class"
msgstr ""

#: ../../../CHANGELOG.md:2915
msgid "Refactoring of `Data` nodes to have the export code in the topmost class, and to make it more general also for formats exporting more than one file"
msgstr ""

#: ../../../CHANGELOG.md:2916
msgid "Refactoring of a number of `Data` subclasses to support the new export API"
msgstr ""

#: ../../../CHANGELOG.md:2917
msgid "Refactoring of `BandsData` to have export code not specific to xmgrace or a given format, and to make it more general"
msgstr ""

#: ../../../CHANGELOG.md:2920
msgid "General improvements to documentation"
msgstr ""

#: ../../../CHANGELOG.md:2921
msgid "Added documentation to upgrade AiiDA from v0.8.0 to v0.9.0"
msgstr ""

#: ../../../CHANGELOG.md:2922
msgid "Added documentation of new plugin system and tutorial"
msgstr ""

#: ../../../CHANGELOG.md:2923
msgid "Added more in-depth documentation on how to export data nodes to various formats"
msgstr ""

#: ../../../CHANGELOG.md:2924
msgid "Added explanation on how to export band structures and available formats"
msgstr ""

#: ../../../CHANGELOG.md:2925
msgid "Added documentation on how to run tests in developer's guide"
msgstr ""

#: ../../../CHANGELOG.md:2926
msgid "Documented Latex requirements"
msgstr ""

#: ../../../CHANGELOG.md:2927
msgid "Updated WorkChain documentation for `WaitingEquationOfState` example"
msgstr ""

#: ../../../CHANGELOG.md:2928
msgid "Updated AiiDA installation documentation for installing virtual environment"
msgstr ""

#: ../../../CHANGELOG.md:2929
msgid "Updated documentation to use Jupyter"
msgstr ""

#: ../../../CHANGELOG.md:2931
msgid "Enhancements"
msgstr ""

#: ../../../CHANGELOG.md:2932
msgid "Speedups the travis builds process by caching pip files between runs"
msgstr ""

#: ../../../CHANGELOG.md:2933
msgid "Node can be loaded by passing the start of its UUID"
msgstr ""

#: ../../../CHANGELOG.md:2934
msgid "Handled invalid verdi command line arguments; added help texts for same"
msgstr ""

#: ../../../CHANGELOG.md:2935
msgid "upgraded `Paramiko` to 2.1.2 and avoided to create empty file when remote connection is failed"
msgstr ""

#: ../../../CHANGELOG.md:2936
msgid "`verdi calculation kill` command is now available for `SGE plugin`"
msgstr ""

#: ../../../CHANGELOG.md:2937
msgid "Updated `Plum` from 0.7.8 to 0.7.9 to create a workchain inputs that had default value and evaluated to false"
msgstr ""

#: ../../../CHANGELOG.md:2938
msgid "Now QueryBuilder will be imported by default for all verdi commands"
msgstr ""

#: ../../../CHANGELOG.md:2940
msgid "Bug Fixes"
msgstr ""

#: ../../../CHANGELOG.md:2941
msgid "Bug fixes in QE input parser"
msgstr ""

#: ../../../CHANGELOG.md:2942
msgid "Code.get() method accepts the pk in integer or string format whereas Code.get_from_string() method accepts pk only in string format"
msgstr ""

#: ../../../CHANGELOG.md:2943
msgid "`verdi code show` command now shows the description of the code"
msgstr ""

#: ../../../CHANGELOG.md:2944
msgid "Bug fix to check if computer is properly configured before submitting the calculation"
msgstr ""

#: ../../../CHANGELOG.md:2947
msgid "Replacing dependency from old unmantained `pyspglib` to new `spglib`"
msgstr ""

#: ../../../CHANGELOG.md:2948
msgid "Accept BaseTypes as attributes/extras, and convert them automatically to their value. In this way, for instance, it is now possible to pass a `Int`, `Float`, `Str`, ... as value of a dictionary, and store all into a `Dict`."
msgstr ""

#: ../../../CHANGELOG.md:2949
msgid "Switch from `pkg_resources` to reentry to allow for much faster loading of modules when possible, and therefore allowing for good speed for bash completion"
msgstr ""

#: ../../../CHANGELOG.md:2950
msgid "Removed obsolete code for Sqlite"
msgstr ""

#: ../../../CHANGELOG.md:2951
msgid "Removed `mayavi2` package from dependencies"
msgstr ""

#: ../../../CHANGELOG.md:2954
msgid "v0.8.1"
msgstr ""

#: ../../../CHANGELOG.md:2956
msgid "Exporters"
msgstr ""

#: ../../../CHANGELOG.md:2957
msgid "Upgraded the TCODExporter to produce CIF files, conforming to the newest (as of 2017-04-26) version of cif_tcod.dic."
msgstr ""

#: ../../../CHANGELOG.md:2959
#: ../../../CHANGELOG.md:2972
#: ../../../CHANGELOG.md:3144
msgid "General"
msgstr ""

#: ../../../CHANGELOG.md:2960
msgid "Added dependency on six to properly re-raise exceptions"
msgstr ""

#: ../../../CHANGELOG.md:2963
msgid "v0.8.0"
msgstr ""

#: ../../../CHANGELOG.md:2965
msgid "Installation and setup"
msgstr ""

#: ../../../CHANGELOG.md:2966
msgid "Simplified installation procedure by adopting standard python package installation method through setuptools and pip"
msgstr ""

#: ../../../CHANGELOG.md:2968
msgid "Verdi install replaced by verdi setup"
msgstr ""

#: ../../../CHANGELOG.md:2969
msgid "New verdi command `quicksetup` to simplify the setup procedure"
msgstr ""

#: ../../../CHANGELOG.md:2970
msgid "Significantly updated and improved the installation documentation"
msgstr ""

#: ../../../CHANGELOG.md:2973
msgid "Significantly increased test coverage and implemented for both backends"
msgstr ""

#: ../../../CHANGELOG.md:2974
msgid "Activated continuous integration through Travis CI"
msgstr ""

#: ../../../CHANGELOG.md:2975
msgid "Application-wide logging is now abstracted and implemented for all backends"
msgstr ""

#: ../../../CHANGELOG.md:2976
msgid "Added a REST API layer with hook through verdi cli: `verdi restapi`"
msgstr ""

#: ../../../CHANGELOG.md:2977
msgid "Improved `QueryBuilder`"
msgstr ""

#: ../../../CHANGELOG.md:2978
msgid "Composition model instead of inheritance removing the requirement of determining the implementation on import"
msgstr ""

#: ../../../CHANGELOG.md:2980
msgid "Added keyword `with_dbpath` that makes `QueryBuilder` switch between using the `DbPath`and not using it."
msgstr ""

#: ../../../CHANGELOG.md:2982
msgid "Updated and improved documentation"
msgstr ""

#: ../../../CHANGELOG.md:2983
msgid "The QueryTool as well as the `class Node.query()` method are now deprecated in favor of the `QueryBuilder`"
msgstr ""

#: ../../../CHANGELOG.md:2985
msgid "Migration of verdi cli to use the `QueryBuilder` in order to support both database backends"
msgstr ""

#: ../../../CHANGELOG.md:2986
msgid "Added option `--project` to `verdi calculation list` to specify which attributes to print"
msgstr ""

#: ../../../CHANGELOG.md:2989
msgid "Documentation is restructured to improve navigability"
msgstr ""

#: ../../../CHANGELOG.md:2990
msgid "Added pseudopotential tutorial"
msgstr ""

#: ../../../CHANGELOG.md:2993
msgid "Dropped support for MySQL and SQLite to fully support efficient features in Postgres like JSONB fields"
msgstr ""

#: ../../../CHANGELOG.md:2995
msgid "Database efficiency improvements with orders of magnitude speedup for large databases [added indices for daemon queries and node UUID queries]"
msgstr ""

#: ../../../CHANGELOG.md:2997
msgid "Replace deprecated `commit_on_success` with atomic for Django transactions"
msgstr ""

#: ../../../CHANGELOG.md:2998
msgid "Change of how SQLAlchemy internally uses the session and the engine to work also with forks (e.g. in celery)"
msgstr ""

#: ../../../CHANGELOG.md:3000
msgid "Workflows"
msgstr ""

#: ../../../CHANGELOG.md:3001
msgid "Finalized the naming for the new workflow system from `workflows2` to `work`"
msgstr ""

#: ../../../CHANGELOG.md:3002
msgid "`FragmentedWorkFunction` is replaced by `WorkChain`"
msgstr ""

#: ../../../CHANGELOG.md:3003
msgid "`InlineCalculation` is replaced by `Workfunction`"
msgstr ""

#: ../../../CHANGELOG.md:3004
msgid "`ProcessCalculation` is replaced by `WorkCalculation`"
msgstr ""

#: ../../../CHANGELOG.md:3005
msgid "Old style Workflows can still be called and run from a new style `WorkChain`"
msgstr ""

#: ../../../CHANGELOG.md:3006
msgid "Major improvements to the `WorkChain` and `Workfunction` implementation"
msgstr ""

#: ../../../CHANGELOG.md:3007
msgid "Improvements to `WorkChain`"
msgstr ""

#: ../../../CHANGELOG.md:3008
msgid "Implemented a `return` statement for `WorkChain` specification"
msgstr ""

#: ../../../CHANGELOG.md:3009
msgid "Logging to the database implemented through `WorkChain.report()` for debugging"
msgstr ""

#: ../../../CHANGELOG.md:3010
msgid "Improved kill command for old-style workflows to avoid steps to remaing in running state"
msgstr ""

#: ../../../CHANGELOG.md:3013
msgid "Added finer granularity for parsing PW timers in output"
msgstr ""

#: ../../../CHANGELOG.md:3014
msgid "New Quantum ESPRESSO and scheduler plugins contributed from EPFL"
msgstr ""

#: ../../../CHANGELOG.md:3015
msgid "ASE/GPAW plugins: Andrea Cepellotti (EPFL and Berkeley)"
msgstr ""

#: ../../../CHANGELOG.md:3016
msgid "Quantum ESPRESSO DOS, Projwfc: Daniel Marchand (EPFL and McGill)"
msgstr ""

#: ../../../CHANGELOG.md:3017
msgid "Quantum ESPRESSO phonon, matdyn, q2r, force constants plugins: Giovanni Pizzi, Nicolas Mounet (EPFL); Andrea Cepellotti (EPFL and Berkeley)"
msgstr ""

#: ../../../CHANGELOG.md:3019
msgid "Quantum ESPRESSO cp.x plugin: Giovanni Pizzi (EPFL)"
msgstr ""

#: ../../../CHANGELOG.md:3020
msgid "Quantum ESPRESSO neb.x plugin: Marco Gibertini (EPFL)"
msgstr ""

#: ../../../CHANGELOG.md:3021
msgid "LSF scheduler: Nicolas Mounet (EPFL)"
msgstr ""

#: ../../../CHANGELOG.md:3022
msgid "Implemented functionality to export and visualize molecular dynamics trajectories (using e.g. matplotlib, mayavi)"
msgstr ""

#: ../../../CHANGELOG.md:3024
msgid "Improved the TCODExporter (some fixes to adapt to changes of external libraries, added some additional TCOD CIF tags, various bugfixes)"
msgstr ""

#: ../../../CHANGELOG.md:3027
msgid "Various fixes and improvements"
msgstr ""

#: ../../../CHANGELOG.md:3028
msgid "Fix for the direct scheduler on Mac OS X"
msgstr ""

#: ../../../CHANGELOG.md:3029
msgid "Fix for the import of computers with name collisions"
msgstr ""

#: ../../../CHANGELOG.md:3030
msgid "Generated backup scripts are now made profile specific and saved as `start_backup_<profile>.py`"
msgstr ""

#: ../../../CHANGELOG.md:3031
msgid "Fix for the vary_rounds warning"
msgstr ""

#: ../../../CHANGELOG.md:3034
msgid "v0.7.1"
msgstr ""

#: ../../../CHANGELOG.md:3036
msgid "Functionalities"
msgstr ""

#: ../../../CHANGELOG.md:3037
msgid "Implemented support for Kerberos authentication in the ssh transport plugin."
msgstr ""

#: ../../../CHANGELOG.md:3038
msgid "Added `_get_submit_script_footer` to scheduler base class."
msgstr ""

#: ../../../CHANGELOG.md:3039
msgid "Improvements of the SLURM scheduler plugin."
msgstr ""

#: ../../../CHANGELOG.md:3040
msgid "Fully functional parsers for Quantumespresso CP and PW."
msgstr ""

#: ../../../CHANGELOG.md:3041
msgid "Better parsing of atomic species from PW output."
msgstr ""

#: ../../../CHANGELOG.md:3042
msgid "Array classes for projection & xy, and changes in kpoints class."
msgstr ""

#: ../../../CHANGELOG.md:3043
msgid "Added codespecific tools for Quantumespresso."
msgstr ""

#: ../../../CHANGELOG.md:3044
msgid "`verdi code list`now shows local codes too."
msgstr ""

#: ../../../CHANGELOG.md:3045
msgid "`verdi export` can now export non user-defined groups (from their pk)."
msgstr ""

#: ../../../CHANGELOG.md:3048
msgid "Fixed bugs in (old) workflow manager and daemon."
msgstr ""

#: ../../../CHANGELOG.md:3049
msgid "Improvements of the efficiency of the (old) workflow manager."
msgstr ""

#: ../../../CHANGELOG.md:3050
msgid "Fixed JobCalculation text prepend with multiple codes."
msgstr ""

#: ../../../CHANGELOG.md:3053
msgid "v0.7.0"
msgstr ""

#: ../../../CHANGELOG.md:3055
msgid "This release introduces a lot and significant changes & enhancements."
msgstr ""

#: ../../../CHANGELOG.md:3057
msgid "We worked on our new backend and now AiiDA can be installed using SQLAlchemy too. Many of the verdi commands and functionalities have been tested and are working with this backend. The full JSON support provided by SQLAlchemy and the latest versions of PostgreSQL enable significant speed increase in attribute related queries. SQLAlchemy backend choice is a beta option since some last functionalities and commands need to be implemented or improved for this backend. Scripts are provided for the transition of databases from Django backend to SQLAlchemy backend."
msgstr ""

#: ../../../CHANGELOG.md:3064
msgid "In this release we have included a new querying tool called `QueryBuilder`. It is a powerfull tool allowing users to write complex graph queries to explore the AiiDA graph database. It provides various features like selection of entity properties, filtering of results, combination of entities on specific properties as well as various ways to obtain the final result. It also provides the users an abstract way to query their data without enforcing them to write backend dependent queries."
msgstr ""

#: ../../../CHANGELOG.md:3070
msgid "Last but not least we have included a new workflow engine (in beta version) which is available through the `verdi workflow2` command. The new workflows are easier to write (it is as close as writing python as possible), there is seamless mixing of short running tasks with long running (remote) tasks and they encourage users to write reusable workflows. Moreover, debugging of workflows has been made easier and it is possible both in-IDE and through logging."
msgstr ""

#: ../../../CHANGELOG.md:3076
#: ../../../CHANGELOG.md:3125
msgid "List of changes:"
msgstr ""

#: ../../../CHANGELOG.md:3077
msgid "Installation procedure works with SQLAlchemy backend too (SQLAlchemy option is still in beta)."
msgstr ""

#: ../../../CHANGELOG.md:3078
msgid "Most of the verdi commands work with SQLAlchemy backend."
msgstr ""

#: ../../../CHANGELOG.md:3079
msgid "Transition script from Django schema of version 0.7.0 to SQLAlchemy schema of version 0.7.0."
msgstr ""

#: ../../../CHANGELOG.md:3080
msgid "AiiDA daemon redesigned and working with both backends (Django & SQLAlchemy)."
msgstr ""

#: ../../../CHANGELOG.md:3081
msgid "Introducing new workflow engine that allows better debugging and easier to write workflows. It is available under the `verdi workflows2` command. Examples are also added."
msgstr ""

#: ../../../CHANGELOG.md:3083
msgid "Old workflows are still supported and available under the \"verdi workflow\" command."
msgstr ""

#: ../../../CHANGELOG.md:3084
msgid "Introducing new querying tool (called `QueryBuilder`). It allows to easily write complex graph queries that will be executed on the AiiDA graph database. Extensive documentation also added."
msgstr ""

#: ../../../CHANGELOG.md:3086
msgid "Unifying behaviour of verdi commands in both backends."
msgstr ""

#: ../../../CHANGELOG.md:3087
msgid "Upped to version 0.4.2 of plum (needed for workflows2)"
msgstr ""

#: ../../../CHANGELOG.md:3088
msgid "Implemented the validator and input helper for Quantum ESPRESSO pw.x."
msgstr ""

#: ../../../CHANGELOG.md:3089
msgid "Improved the documentation for the pw (and cp) input plugins (for all the flags in the Settings node)."
msgstr ""

#: ../../../CHANGELOG.md:3091
msgid "Fixed a wrong behavior in the QE pw/cp plugins when checking for the parser options and checking if there were further unknown flags in the Settings node. However, this does not solve yet completely the problem (see issue #219)."
msgstr ""

#: ../../../CHANGELOG.md:3094
msgid "Implemented validator and input helper for Quantum ESPRESSO pw.x."
msgstr ""

#: ../../../CHANGELOG.md:3095
msgid "Added elements with Z=104-112, 114 and 116, in `aiida.common.constants`."
msgstr ""

#: ../../../CHANGELOG.md:3096
msgid "Added method `set_kpoints_mesh_from_density` in `KpointsData` class."
msgstr ""

#: ../../../CHANGELOG.md:3097
msgid "Improved incremental backup documentation."
msgstr ""

#: ../../../CHANGELOG.md:3098
msgid "Added backup related tests."
msgstr ""

#: ../../../CHANGELOG.md:3099
msgid "Added an option to `test_pw.py` to run also in serial."
msgstr ""

#: ../../../CHANGELOG.md:3100
msgid "SSH transport, to connect to remote computers via SSH/SFTP."
msgstr ""

#: ../../../CHANGELOG.md:3101
msgid "Support for the SGE and SLURM schedulers."
msgstr ""

#: ../../../CHANGELOG.md:3102
msgid "Support for Quantum ESPRESSO Car-Parrinello calculations."
msgstr ""

#: ../../../CHANGELOG.md:3103
msgid "Support for data nodes to store electronic bands, phonon dispersion and generally arrays defined over the Brillouin zone."
msgstr ""

#: ../../../CHANGELOG.md:3107
msgid "v0.6.0"
msgstr ""

#: ../../../CHANGELOG.md:3109
msgid "We performed a lot of changes to introduce in one of our following releases a second object-relational mapper (we will refer to it as back-end) for the management of the used DBMSs and more specifically of PostgreSQL. SQLAlchemy and the latest version of PostgreSQL allows AiiDA to store JSON documents directly to the database and also to query them. Moreover the JSON query optimization is left to the database including also the use of the JSON specific indexes. There was major code restructuring to accommodate the new back-end resulting to abstracting many classes of the orm package of AiiDA."
msgstr ""

#: ../../../CHANGELOG.md:3117
msgid "Even if most of the needed restructuring & code addition has been finished, a bit of more work is needed. Therefore even in this version, Django is the only available back-end for the end user."
msgstr ""

#: ../../../CHANGELOG.md:3120
msgid "However, the users have to update their AiiDA configuration files by executing the migration file that can be found at `YOUR_AIIDA_DIR/aiida/common/additions/migration.py` as the Linux user that installed AiiDA in your system. (e.g. `python YOUR_AIIDA_DIR/aiida/common/additions/migration.py`)"
msgstr ""

#: ../../../CHANGELOG.md:3126
msgid "Back-end selection (Added backend selection). SQLAlchemy selection is disabled for the moment."
msgstr ""

#: ../../../CHANGELOG.md:3127
msgid "Migration scripts for the configuration files of AiiDA (SQLAlchemy support)."
msgstr ""

#: ../../../CHANGELOG.md:3128
msgid "Enriched link description in the database (to enrich the provenance model)."
msgstr ""

#: ../../../CHANGELOG.md:3129
msgid "Corrections for numpy array and cell. List will be used with cell."
msgstr ""

#: ../../../CHANGELOG.md:3130
msgid "Fixed backend import. Verdi commands load as late as possible the needed backend."
msgstr ""

#: ../../../CHANGELOG.md:3131
msgid "Abstraction of the basic AiiDA orm classes (like node, computer, data etc). This is needed to support different backends (e.g. Django and SQLAlchemy)."
msgstr ""

#: ../../../CHANGELOG.md:3133
msgid "Fixes on the structure import from QE-input files."
msgstr ""

#: ../../../CHANGELOG.md:3134
msgid "SQLAlchemy and Django benchmarks."
msgstr ""

#: ../../../CHANGELOG.md:3135
msgid "UltraJSON support."
msgstr ""

#: ../../../CHANGELOG.md:3136
msgid "requirements.txt now also include SQLAlchemy and its dependencies."
msgstr ""

#: ../../../CHANGELOG.md:3137
msgid "Recursive way of loading JSON for SQLAlchemy."
msgstr ""

#: ../../../CHANGELOG.md:3138
msgid "Improved way of accessing calculations and workflows attached to a workflow step."
msgstr ""

#: ../../../CHANGELOG.md:3139
msgid "Added methods to programmatically create new codes and computers."
msgstr ""

#: ../../../CHANGELOG.md:3142
msgid "v0.5.0"
msgstr ""

#: ../../../CHANGELOG.md:3145
msgid "Final paper published, ref: G. Pizzi, A. Cepellotti, R. Sabatini, N. Marzari, and B. Kozinsky, AiiDA: automated interactive infrastructure and database for computational science, Comp. Mat. Sci 111, 218-230 (2016)"
msgstr ""

#: ../../../CHANGELOG.md:3148
msgid "Core, concrete, requirements kept in `requirements.txt` and optionals moved to `optional_requirements.txt`"
msgstr ""

#: ../../../CHANGELOG.md:3150
msgid "Schema change to v1.0.2: got rid of `calc_states.UNDETERMINED`"
msgstr ""

#: ../../../CHANGELOG.md:3152
msgid "Import/export, backup and code interaction"
msgstr ""

#: ../../../CHANGELOG.md:3153
msgid "[non-back-compatible] Now supporting multiple codes execution in the same submission script. Plugin interface changed, requires adaptation of the code plugins."
msgstr ""

#: ../../../CHANGELOG.md:3155
msgid "Added import support for XYZ files"
msgstr ""

#: ../../../CHANGELOG.md:3156
msgid "Added support for van der Waals table in QE input"
msgstr ""

#: ../../../CHANGELOG.md:3157
msgid "Restart QE calculations avoiding using scratch using copy of parent calc"
msgstr ""

#: ../../../CHANGELOG.md:3158
msgid "Adding database importer for NNIN/C Pseudopotential Virtual Vault"
msgstr ""

#: ../../../CHANGELOG.md:3159
msgid "Implemented conversion of pymatgen Molecule lists to AiiDA's TrajectoryData"
msgstr ""

#: ../../../CHANGELOG.md:3160
msgid "Adding a converter from pymatgen Molecule to AiiDA StructureData"
msgstr ""

#: ../../../CHANGELOG.md:3161
msgid "Queries now much faster when exporting"
msgstr ""

#: ../../../CHANGELOG.md:3162
msgid "Added an option to export a zip file"
msgstr ""

#: ../../../CHANGELOG.md:3163
msgid "Added backup scripts for efficient incremental backup of large AiiDA repositories"
msgstr ""

#: ../../../CHANGELOG.md:3165
msgid "API"
msgstr ""

#: ../../../CHANGELOG.md:3166
msgid "Added the possibility to add any kind of Django query in Group.query"
msgstr ""

#: ../../../CHANGELOG.md:3167
msgid "Added TCOD (Theoretical Crystallography Open Database) importer and exporter"
msgstr ""

#: ../../../CHANGELOG.md:3168
msgid "Added option to sort by a field in the query tool"
msgstr ""

#: ../../../CHANGELOG.md:3169
msgid "Implemented selection of data nodes and calculations by group"
msgstr ""

#: ../../../CHANGELOG.md:3170
msgid "Added NWChem plugin"
msgstr ""

#: ../../../CHANGELOG.md:3171
msgid "Change default behaviour of symbolic link copy in the transport plugins: \"put\"/\"get\" methods -> symbolic links are followed before copy; \"copy\" methods -> symbolic links are not followed (copied \"as is\")."
msgstr ""

#: ../../../CHANGELOG.md:3175
msgid "Schedulers"
msgstr ""

#: ../../../CHANGELOG.md:3176
msgid "Explicit Torque support (some slightly different flags)"
msgstr ""

#: ../../../CHANGELOG.md:3177
msgid "Improved PBSPro scheduler"
msgstr ""

#: ../../../CHANGELOG.md:3178
msgid "Added new `num_cores_per_machine` and `num_cores_per_mpiproc fields` for pbs and torque schedulers (giving full support for MPI+OpenMP hybrid codes)"
msgstr ""

#: ../../../CHANGELOG.md:3180
msgid "Direct scheduler added, allowing calculations to be run without batch system (i.e. directly call executable)"
msgstr ""

#: ../../../CHANGELOG.md:3183
msgid "verdi"
msgstr ""

#: ../../../CHANGELOG.md:3184
msgid "Support for profiles added: it allows user to switch between database configurations using the `verdi profile` command"
msgstr ""

#: ../../../CHANGELOG.md:3185
msgid "Added `verdi data structure import --file file.xyz` for importing XYZ"
msgstr ""

#: ../../../CHANGELOG.md:3186
msgid "Added a `verdi data upf exportfamily` command (to export an upf pseudopotential family into a folder)"
msgstr ""

#: ../../../CHANGELOG.md:3187
msgid "Added new functionalities to the `verdi group` command (show list of nodes, add and remove nodes from the command line)"
msgstr ""

#: ../../../CHANGELOG.md:3189
msgid "Allowing verdi export command to take group PKs"
msgstr ""

#: ../../../CHANGELOG.md:3190
msgid "Added ASE as a possible format for visualizing structures from command line"
msgstr ""

#: ../../../CHANGELOG.md:3191
msgid "Added possibility to export trajectory data in xsf format"
msgstr ""

#: ../../../CHANGELOG.md:3192
msgid "Added possibility to show trajectory data with xcrysden"
msgstr ""

#: ../../../CHANGELOG.md:3193
msgid "Added filters on group name in `verdi group list`"
msgstr ""

#: ../../../CHANGELOG.md:3194
msgid "Added possibility to load custom modules in the verdi shell (additional property verdishell.modules created; can be set with `verdi devel setproperty verdishell.modules`)"
msgstr ""

#: ../../../CHANGELOG.md:3196
msgid "Added `verdi data array show` command, using `json_date` serialization to display the contents of `ArrayData`"
msgstr ""

#: ../../../CHANGELOG.md:3197
msgid "Added `verdi data trajectory deposit` command line command"
msgstr ""

#: ../../../CHANGELOG.md:3198
msgid "Added command options `--computer` and `--code` to `verdi data * deposit`"
msgstr ""

#: ../../../CHANGELOG.md:3199
msgid "Added a command line option `--all-users` for `verdi data * list` to list objects, owned by all users"
msgstr ""

#: ../../source/reference/api/index.rst:2
msgid "AiiDA API"
msgstr ""

#: ../../source/reference/api/public.rst:4
msgid "Overview of public API"
msgstr ""

#: ../../source/reference/api/public.rst:6
msgid "The top-level package of the ``aiida-core`` distribution is called ``aiida``. It contains various sub-packages that we refer to as \"second-level packages\"."
msgstr ""

#: ../../source/reference/api/public.rst:9
msgid "Rule"
msgstr ""

#: ../../source/reference/api/public.rst:12
msgid "**Any resource that can be imported directly from the top level or from a second-level package is part of the public python API** and intended for external use. Resources at deeper nesting level are considered internal and are not intended for use outside ``aiida-core``."
msgstr ""

#: ../../source/reference/api/public.rst:25
msgid "The interface and implementation of resources that are *not* considered part of the public API can change between minor AiiDA releases, and can even be moved or fully removed, without a deprecation period whatsoever. Be aware that scripts or AiiDA plugins that rely on such resources, can therefore break unexpectedly in between minor AiiDA releases."
msgstr ""

#: ../../source/reference/api/public.rst:28
msgid "Below we provide a list of the resources per second-level package that are exposed in this way. If a module is mentioned, then all the resources defined in its ``__all__`` are included"
msgstr ""

#: ../../source/reference/api/public.rst:32
msgid "``aiida.cmdline``"
msgstr ""

#: ../../source/reference/api/public.rst:36
msgid "Since some ``click`` argument and option decorators clash, these may be imported at a lower level:"
msgstr ""

#: ../../source/reference/api/public.rst:44
msgid "``aiida.common``"
msgstr ""

#: ../../source/reference/api/public.rst:50
msgid "``aiida.engine``"
msgstr ""

#: ../../source/reference/api/public.rst:55
msgid "``aiida.manage``"
msgstr ""

#: ../../source/reference/api/public.rst:60
msgid "``aiida.orm``"
msgstr ""

#: ../../source/reference/api/public.rst:65
msgid "``aiida.parsers``"
msgstr ""

#: ../../source/reference/api/public.rst:71
msgid "``aiida.plugins``"
msgstr ""

#: ../../source/reference/api/public.rst:77
msgid "``aiida.schedulers``"
msgstr ""

#: ../../source/reference/api/public.rst:83
msgid "``aiida.tools``"
msgstr ""

#: ../../source/reference/api/public.rst:89
msgid "``aiida.transports``"
msgstr ""

#: ../../source/reference/apidoc/aiida.rst:2
msgid "aiida package"
msgstr ""

#: ../../../src/aiida/__init__.py:docstring of aiida:1
msgid "AiiDA is a flexible and scalable informatics' infrastructure to manage, preserve, and disseminate the simulations, data, and workflows of modern-day computational science."
msgstr ""

#: ../../../src/aiida/__init__.py:docstring of aiida:5
msgid "Able to store the full provenance of each object, and based on a tailored database built for efficient data mining of heterogeneous results, AiiDA gives the user the ability to interact seamlessly with any number of remote HPC resources and codes, thanks to its flexible plugin interface and workflow engine for the automation of complex sequences of simulations."
msgstr ""

#: ../../../src/aiida/__init__.py:docstring of aiida:11
msgid "More information at http://www.aiida.net"
msgstr ""

#: ../../../src/aiida/__init__.py:docstring of aiida._get_raw_file_header:1
msgid "Get the default header for source AiiDA source code files. Note: is not preceded by comment character."
msgstr ""

#: ../../../src/aiida/__init__.py:docstring of aiida._get_raw_file_header:0
#: ../../../src/aiida/__init__.py:docstring of aiida.get_file_header:0
#: ../../../src/aiida/__init__.py:docstring of aiida.get_strict_version:0
#: ../../../src/aiida/__init__.py:docstring of aiida.get_version:0
#: ../../../src/aiida/calculations/arithmetic/add.py:docstring of aiida.calculations.arithmetic.add.ArithmeticAddCalculation.prepare_for_submission:0
#: ../../../src/aiida/calculations/importers/arithmetic/add.py:docstring of aiida.calculations.importers.arithmetic.add.ArithmeticAddCalculationImporter.parse_remote_data:0
#: ../../../src/aiida/calculations/monitors/base.py:docstring of aiida.calculations.monitors.base.always_kill:0
#: ../../../src/aiida/calculations/transfer.py:docstring of aiida.calculations.transfer.TransferCalculation.prepare_for_submission:0
#: ../../../src/aiida/cmdline/commands/cmd_archive.py:docstring of aiida.cmdline.commands.cmd_archive._gather_imports:0
#: ../../../src/aiida/cmdline/commands/cmd_calcjob.py:docstring of aiida.cmdline.commands.cmd_calcjob.get_remote_and_path:0
#: ../../../src/aiida/cmdline/commands/cmd_computer.py:docstring of aiida.cmdline.commands.cmd_computer._computer_create_temp_file:0
#: ../../../src/aiida/cmdline/commands/cmd_computer.py:docstring of aiida.cmdline.commands.cmd_computer._computer_get_remote_username:0
#: ../../../src/aiida/cmdline/commands/cmd_computer.py:docstring of aiida.cmdline.commands.cmd_computer._computer_test_get_jobs:0
#: ../../../src/aiida/cmdline/commands/cmd_computer.py:docstring of aiida.cmdline.commands.cmd_computer._computer_test_no_unexpected_output:0
#: ../../../src/aiida/cmdline/commands/cmd_computer.py:docstring of aiida.cmdline.commands.cmd_computer.get_parameter_default:0
#: ../../../src/aiida/cmdline/commands/cmd_computer.py:docstring of aiida.cmdline.commands.cmd_computer.time_use_login_shell:0
#: ../../../src/aiida/cmdline/commands/cmd_data/cmd_show.py:docstring of aiida.cmdline.commands.cmd_data.cmd_show.has_executable:0
#: ../../../src/aiida/cmdline/commands/cmd_devel.py:docstring of aiida.cmdline.commands.cmd_devel.prepare_localhost:0
#: ../../../src/aiida/cmdline/groups/dynamic.py:docstring of aiida.cmdline.groups.dynamic.DynamicEntryPointCommandGroup.get_command:0
#: ../../../src/aiida/cmdline/groups/verdi.py:docstring of aiida.cmdline.groups.verdi.LazyConfigAttributeDict.__getattr__:0
#: ../../../src/aiida/cmdline/params/options/commands/computer.py:docstring of aiida.cmdline.params.options.commands.computer.should_call_default_memory_per_machine:0
#: ../../../src/aiida/cmdline/params/options/commands/computer.py:docstring of aiida.cmdline.params.options.commands.computer.should_call_default_mpiprocs_per_machine:0
#: ../../../src/aiida/cmdline/params/options/commands/setup.py:docstring of aiida.cmdline.params.options.commands.setup.get_profile_attribute_default:0
#: ../../../src/aiida/cmdline/params/options/commands/setup.py:docstring of aiida.cmdline.params.options.commands.setup.get_quicksetup_database_name:0
#: ../../../src/aiida/cmdline/params/options/commands/setup.py:docstring of aiida.cmdline.params.options.commands.setup.get_quicksetup_password:0
#: ../../../src/aiida/cmdline/params/options/commands/setup.py:docstring of aiida.cmdline.params.options.commands.setup.get_quicksetup_repository_uri:0
#: ../../../src/aiida/cmdline/params/options/commands/setup.py:docstring of aiida.cmdline.params.options.commands.setup.get_quicksetup_username:0
#: ../../../src/aiida/cmdline/params/options/commands/setup.py:docstring of aiida.cmdline.params.options.commands.setup.get_repository_uri_default:0
#: ../../../src/aiida/cmdline/params/options/config.py:docstring of aiida.cmdline.params.options.config.ConfigFileOption.__call__:0
#: ../../../src/aiida/cmdline/params/options/interactive.py:docstring of aiida.cmdline.params.options.interactive.InteractiveOption.is_interactive:0
#: ../../../src/aiida/cmdline/params/options/overridable.py:docstring of aiida.cmdline.params.options.overridable.OverridableOption.__call__:0
#: ../../../src/aiida/cmdline/params/options/overridable.py:docstring of aiida.cmdline.params.options.overridable.OverridableOption.clone:0
#: ../../../src/aiida/cmdline/params/types/calculation.py:docstring of aiida.cmdline.params.types.calculation.CalculationParamType.orm_class_loader:0
#: ../../../src/aiida/cmdline/params/types/choice.py:docstring of aiida.cmdline.params.types.choice.LazyChoice._click_choice:0
#: ../../../src/aiida/cmdline/params/types/code.py:docstring of aiida.cmdline.params.types.code.CodeParamType.convert:0
#: ../../../src/aiida/cmdline/params/types/code.py:docstring of aiida.cmdline.params.types.code.CodeParamType.orm_class_loader:0
#: ../../../src/aiida/cmdline/params/types/code.py:docstring of aiida.cmdline.params.types.code.CodeParamType.shell_complete:0
#: ../../../src/aiida/cmdline/params/types/computer.py:docstring of aiida.cmdline.params.types.computer.ComputerParamType.orm_class_loader:0
#: ../../../src/aiida/cmdline/params/types/computer.py:docstring of aiida.cmdline.params.types.computer.ComputerParamType.shell_complete:0
#: ../../../src/aiida/cmdline/params/types/config.py:docstring of aiida.cmdline.params.types.config.ConfigOptionParamType.shell_complete:0
#: ../../../src/aiida/cmdline/params/types/data.py:docstring of aiida.cmdline.params.types.data.DataParamType.orm_class_loader:0
#: ../../../src/aiida/cmdline/params/types/group.py:docstring of aiida.cmdline.params.types.group.GroupParamType.convert:0
#: ../../../src/aiida/cmdline/params/types/group.py:docstring of aiida.cmdline.params.types.group.GroupParamType.orm_class_loader:0
#: ../../../src/aiida/cmdline/params/types/group.py:docstring of aiida.cmdline.params.types.group.GroupParamType.shell_complete:0
#: ../../../src/aiida/cmdline/params/types/identifier.py:docstring of aiida.cmdline.params.types.identifier.IdentifierParamType.convert:0
#: ../../../src/aiida/cmdline/params/types/identifier.py:docstring of aiida.cmdline.params.types.identifier.IdentifierParamType.orm_class_loader:0
#: ../../../src/aiida/cmdline/params/types/node.py:docstring of aiida.cmdline.params.types.node.NodeParamType.orm_class_loader:0
#: ../../../src/aiida/cmdline/params/types/plugin.py:docstring of aiida.cmdline.params.types.plugin.PluginParamType.get_entry_point_from_string:0
#: ../../../src/aiida/cmdline/params/types/plugin.py:docstring of aiida.cmdline.params.types.plugin.PluginParamType.get_valid_arguments:0
#: ../../../src/aiida/cmdline/params/types/plugin.py:docstring of aiida.cmdline.params.types.plugin.PluginParamType.shell_complete:0
#: ../../../src/aiida/cmdline/params/types/process.py:docstring of aiida.cmdline.params.types.process.ProcessParamType.orm_class_loader:0
#: ../../../src/aiida/cmdline/params/types/profile.py:docstring of aiida.cmdline.params.types.profile.ProfileParamType.shell_complete:0
#: ../../../src/aiida/cmdline/params/types/user.py:docstring of aiida.cmdline.params.types.user.UserParamType.shell_complete:0
#: ../../../src/aiida/cmdline/params/types/workflow.py:docstring of aiida.cmdline.params.types.workflow.WorkflowParamType.orm_class_loader:0
#: ../../../src/aiida/cmdline/utils/common.py:docstring of aiida.cmdline.utils.common.format_flat_links:0
#: ../../../src/aiida/cmdline/utils/common.py:docstring of aiida.cmdline.utils.common.format_nested_links:0
#: ../../../src/aiida/cmdline/utils/common.py:docstring of aiida.cmdline.utils.common.get_calcjob_report:0
#: ../../../src/aiida/cmdline/utils/common.py:docstring of aiida.cmdline.utils.common.get_node_info:0
#: ../../../src/aiida/cmdline/utils/common.py:docstring of aiida.cmdline.utils.common.get_node_summary:0
#: ../../../src/aiida/cmdline/utils/common.py:docstring of aiida.cmdline.utils.common.get_process_function_report:0
#: ../../../src/aiida/cmdline/utils/common.py:docstring of aiida.cmdline.utils.common.get_workchain_report:0
#: ../../../src/aiida/cmdline/utils/defaults.py:docstring of aiida.cmdline.utils.defaults.get_default_profile:0
#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.highlight_string:0
#: ../../../src/aiida/cmdline/utils/multi_line_input.py:docstring of aiida.cmdline.utils.multi_line_input.edit_multiline_template:0
#: ../../../src/aiida/common/escaping.py:docstring of aiida.common.escaping.escape_for_bash:0
#: ../../../src/aiida/common/escaping.py:docstring of aiida.common.escaping.get_regex_pattern_from_sql:0
#: ../../../src/aiida/common/escaping.py:docstring of aiida.common.escaping.sql_string_match:0
#: ../../../src/aiida/common/files.py:docstring of aiida.common.files.md5_file:0
#: ../../../src/aiida/common/files.py:docstring of aiida.common.files.md5_from_filelike:0
#: ../../../src/aiida/common/files.py:docstring of aiida.common.files.sha1_file:0
#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder.create_file_from_filelike:0
#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder.get_content_list:0
#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder.get_subfolder:0
#: ../../../src/aiida/common/hashing.py:docstring of aiida.common.hashing.chunked_file_hash:0
#: ../../../src/aiida/common/hashing.py:docstring of aiida.common.hashing.make_hash:0
#: ../../../src/aiida/common/lang.py:docstring of aiida.common.lang.isidentifier:0
#: ../../../src/aiida/common/lang.py:docstring of aiida.common.lang.type_check:0
#: ../../../src/aiida/common/log.py:docstring of aiida.common.log.capture_logging:0
#: ../../../src/aiida/common/log.py:docstring of aiida.common.log.evaluate_logging_configuration:0
#: ../../../src/aiida/common/progress_reporter.py:docstring of aiida.common.progress_reporter.create_callback:0
#: ../../../src/aiida/common/timezone.py:docstring of aiida.common.timezone.delta:0
#: ../../../src/aiida/common/timezone.py:docstring of aiida.common.timezone.localtime:0
#: ../../../src/aiida/common/timezone.py:docstring of aiida.common.timezone.make_aware:0
#: ../../../src/aiida/common/timezone.py:docstring of aiida.common.timezone.now:0
#: ../../../src/aiida/common/timezone.py:docstring of aiida.common.timezone.timezone_from_name:0
#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.Prettifier.get_prettifiers:0
#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.Prettifier.prettify:0
#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.get_unique_filename:0
#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.join_labels:0
#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.prettify_labels:0
#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.strip_prefix:0
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient._is_pid_file_stale:0
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.call_client:0
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.decrease_workers:0
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.get_available_port:0
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.get_circus_port:0
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.get_circus_socket_directory:0
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.get_client:0
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.get_controller_endpoint:0
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.get_daemon_info:0
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.get_daemon_pid:0
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.get_ipc_endpoint:0
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.get_numprocesses:0
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.get_pubsub_endpoint:0
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.get_stats_endpoint:0
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.get_status:0
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.get_tcp_endpoint:0
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.get_worker_info:0
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.increase_workers:0
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.is_daemon_running:0
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.restart_daemon:0
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.stop_daemon:0
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.get_daemon_client:0
#: ../../../src/aiida/engine/daemon/execmanager.py:docstring of aiida.engine.daemon.execmanager._find_data_node:0
#: ../../../src/aiida/engine/daemon/execmanager.py:docstring of aiida.engine.daemon.execmanager.submit_calculation:0
#: ../../../src/aiida/engine/launch.py:docstring of aiida.engine.launch.run:0
#: ../../../src/aiida/engine/launch.py:docstring of aiida.engine.launch.run_get_node:0
#: ../../../src/aiida/engine/launch.py:docstring of aiida.engine.launch.run_get_pk:0
#: ../../../src/aiida/engine/launch.py:docstring of aiida.engine.launch.submit:0
#: ../../../src/aiida/engine/persistence.py:docstring of aiida.engine.persistence.AiiDAPersister.get_checkpoints:0
#: ../../../src/aiida/engine/persistence.py:docstring of aiida.engine.persistence.AiiDAPersister.get_process_checkpoints:0
#: ../../../src/aiida/engine/persistence.py:docstring of aiida.engine.persistence.AiiDAPersister.load_checkpoint:0
#: ../../../src/aiida/engine/persistence.py:docstring of aiida.engine.persistence.ObjectLoader.load_object:0
#: ../../../src/aiida/engine/persistence.py:docstring of aiida.engine.persistence.get_object_loader:0
#: ../../../src/aiida/engine/processes/builder.py:docstring of aiida.engine.processes.builder.ProcessBuilderNamespace._inputs:0
#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.CalcJob.get_importer:0
#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.CalcJob.node:0
#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.CalcJob.options:0
#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.CalcJob.prepare_for_submission:0
#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.CalcJob.run:0
#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.CalcJob.terminate:0
#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.validate_additional_retrieve_list:0
#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.validate_calc_job:0
#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.validate_parser:0
#: ../../../src/aiida/engine/processes/calcjobs/importer.py:docstring of aiida.engine.processes.calcjobs.importer.CalcJobImporter.parse_remote_data:0
#: ../../../src/aiida/engine/processes/calcjobs/manager.py:docstring of aiida.engine.processes.calcjobs.manager.JobManager.get_jobs_list:0
#: ../../../src/aiida/engine/processes/calcjobs/manager.py:docstring of aiida.engine.processes.calcjobs.manager.JobsList._get_jobs_from_scheduler:0
#: ../../../src/aiida/engine/processes/calcjobs/manager.py:docstring of aiida.engine.processes.calcjobs.manager.JobsList._get_jobs_with_scheduler:0
#: ../../../src/aiida/engine/processes/calcjobs/manager.py:docstring of aiida.engine.processes.calcjobs.manager.JobsList._get_next_update_delay:0
#: ../../../src/aiida/engine/processes/calcjobs/manager.py:docstring of aiida.engine.processes.calcjobs.manager.JobsList.get_minimum_update_interval:0
#: ../../../src/aiida/engine/processes/calcjobs/manager.py:docstring of aiida.engine.processes.calcjobs.manager.JobsList.last_updated:0
#: ../../../src/aiida/engine/processes/calcjobs/manager.py:docstring of aiida.engine.processes.calcjobs.manager.JobsList.logger:0
#: ../../../src/aiida/engine/processes/calcjobs/manager.py:docstring of aiida.engine.processes.calcjobs.manager.JobsList.request_job_info_update:0
#: ../../../src/aiida/engine/processes/calcjobs/monitors.py:docstring of aiida.engine.processes.calcjobs.monitors.CalcJobMonitors.monitors:0
#: ../../../src/aiida/engine/processes/calcjobs/monitors.py:docstring of aiida.engine.processes.calcjobs.monitors.CalcJobMonitors.process:0
#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.Waiting.monitors:0
#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.Waiting.process:0
#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.task_monitor_job:0
#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.task_update_job:0
#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control.get_active_processes:0
#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control.get_process_tasks:0
#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control.iterate_process_tasks:0
#: ../../../src/aiida/engine/processes/exit_code.py:docstring of aiida.engine.processes.exit_code.ExitCodesNamespace.__call__:0
#: ../../../src/aiida/engine/processes/functions.py:docstring of aiida.engine.processes.functions.FunctionProcess.build:0
#: ../../../src/aiida/engine/processes/functions.py:docstring of aiida.engine.processes.functions.FunctionProcess.get_or_create_db_record:0
#: ../../../src/aiida/engine/processes/functions.py:docstring of aiida.engine.processes.functions.FunctionProcess.process_class:0
#: ../../../src/aiida/engine/processes/functions.py:docstring of aiida.engine.processes.functions.calcfunction:0
#: ../../../src/aiida/engine/processes/functions.py:docstring of aiida.engine.processes.functions.get_stack_size:0
#: ../../../src/aiida/engine/processes/functions.py:docstring of aiida.engine.processes.functions.infer_valid_type_from_type_annotation:0
#: ../../../src/aiida/engine/processes/functions.py:docstring of aiida.engine.processes.functions.workfunction:0
#: ../../../src/aiida/engine/processes/ports.py:docstring of aiida.engine.processes.ports.InputPort.get_description:0
#: ../../../src/aiida/engine/processes/ports.py:docstring of aiida.engine.processes.ports.PortNamespace.serialize:0
#: ../../../src/aiida/engine/processes/ports.py:docstring of aiida.engine.processes.ports.WithMetadata.is_metadata:0
#: ../../../src/aiida/engine/processes/ports.py:docstring of aiida.engine.processes.ports.WithMetadata.is_metadata_explicitly_set:0
#: ../../../src/aiida/engine/processes/ports.py:docstring of aiida.engine.processes.ports.WithNonDb.non_db:0
#: ../../../src/aiida/engine/processes/ports.py:docstring of aiida.engine.processes.ports.WithNonDb.non_db_explicitly_set:0
#: ../../../src/aiida/engine/processes/ports.py:docstring of aiida.engine.processes.ports.WithSerialize.serialize:0
#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process._build_process_label:0
#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process._create_and_setup_db_record:0
#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process._filter_serializable_metadata:0
#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process._flat_inputs:0
#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process._flat_outputs:0
#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process._flatten_inputs:0
#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process._flatten_outputs:0
#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process._get_namespace_list:0
#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.build_process_type:0
#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.decode_input_args:0
#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.encode_input_args:0
#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.exposed_inputs:0
#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.exposed_outputs:0
#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.get_exit_statuses:0
#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.get_or_create_db_record:0
#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.get_parent_calc:0
#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.metadata:0
#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.node:0
#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.submit:0
#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.uuid:0
#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.get_query_string_from_process_type_string:0
#: ../../../src/aiida/engine/processes/process_spec.py:docstring of aiida.engine.processes.process_spec.ProcessSpec.exit_codes:0
#: ../../../src/aiida/engine/processes/process_spec.py:docstring of aiida.engine.processes.process_spec.ProcessSpec.inputs:0
#: ../../../src/aiida/engine/processes/process_spec.py:docstring of aiida.engine.processes.process_spec.ProcessSpec.outputs:0
#: ../../../src/aiida/engine/processes/utils.py:docstring of aiida.engine.processes.utils.prune_mapping:0
#: ../../../src/aiida/engine/processes/workchains/context.py:docstring of aiida.engine.processes.workchains.context.append_:0
#: ../../../src/aiida/engine/processes/workchains/context.py:docstring of aiida.engine.processes.workchains.context.assign_:0
#: ../../../src/aiida/engine/processes/workchains/restart.py:docstring of aiida.engine.processes.workchains.restart.BaseRestartWorkChain._attach_outputs:0
#: ../../../src/aiida/engine/processes/workchains/restart.py:docstring of aiida.engine.processes.workchains.restart.BaseRestartWorkChain._wrap_bare_dict_inputs:0
#: ../../../src/aiida/engine/processes/workchains/restart.py:docstring of aiida.engine.processes.workchains.restart.BaseRestartWorkChain.is_process_handler:0
#: ../../../src/aiida/engine/processes/workchains/workchain.py:docstring of aiida.engine.processes.workchains.workchain.Protect.__is_final:0
#: ../../../src/aiida/engine/processes/workchains/workchain.py:docstring of aiida.engine.processes.workchains.workchain.WorkChain.node:0
#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner._run:0
#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner.get_process_future:0
#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner.is_daemon_runner:0
#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner.run:0
#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner.run_get_node:0
#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner.run_get_pk:0
#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner.schedule:0
#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner.submit:0
#: ../../../src/aiida/engine/transports.py:docstring of aiida.engine.transports.TransportQueue.request_transport:0
#: ../../../src/aiida/engine/utils.py:docstring of aiida.engine.utils.InterruptableFuture.with_interrupt:0
#: ../../../src/aiida/engine/utils.py:docstring of aiida.engine.utils.ensure_coroutine:0
#: ../../../src/aiida/engine/utils.py:docstring of aiida.engine.utils.exponential_backoff_retry:0
#: ../../../src/aiida/engine/utils.py:docstring of aiida.engine.utils.get_process_state_change_timestamp:0
#: ../../../src/aiida/engine/utils.py:docstring of aiida.engine.utils.interruptable_task:0
#: ../../../src/aiida/engine/utils.py:docstring of aiida.engine.utils.is_process_function:0
#: ../../../src/aiida/engine/utils.py:docstring of aiida.engine.utils.is_process_scoped:0
#: ../../../src/aiida/engine/utils.py:docstring of aiida.engine.utils.prepare_inputs:0
#: ../../../src/aiida/manage/caching.py:docstring of aiida.manage.caching._match_wildcard:0
#: ../../../src/aiida/manage/caching.py:docstring of aiida.manage.caching.get_use_cache:0
#: ../../../src/aiida/manage/configuration/__init__.py:docstring of aiida.manage.configuration.get_config:0
#: ../../../src/aiida/manage/configuration/__init__.py:docstring of aiida.manage.configuration.get_config_option:0
#: ../../../src/aiida/manage/configuration/__init__.py:docstring of aiida.manage.configuration.get_profile:0
#: ../../../src/aiida/manage/configuration/__init__.py:docstring of aiida.manage.configuration.load_config:0
#: ../../../src/aiida/manage/configuration/__init__.py:docstring of aiida.manage.configuration.load_profile:0
#: ../../../src/aiida/manage/configuration/__init__.py:docstring of aiida.manage.configuration.profile_context:0
#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config._backup:0
#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.add_profile:0
#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.create_profile:0
#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.default_profile_name:0
#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.dictionary:0
#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.from_file:0
#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.get_option:0
#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.get_options:0
#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.get_profile:0
#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.profile_names:0
#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.profiles:0
#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.remove_profile:0
#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.set_default_profile:0
#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.set_option:0
#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.store:0
#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.update_profile:0
#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.check_and_migrate_config:0
#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.config_needs_migrating:0
#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.downgrade_config:0
#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.get_current_version:0
#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.get_oldest_compatible_version:0
#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.upgrade_config:0
#: ../../../src/aiida/manage/configuration/options.py:docstring of aiida.manage.configuration.options.Option.validate:0
#: ../../../src/aiida/manage/configuration/options.py:docstring of aiida.manage.configuration.options.parse_option:0
#: ../../../src/aiida/manage/configuration/profile.py:docstring of aiida.manage.configuration.profile.Profile.dictionary:0
#: ../../../src/aiida/manage/configuration/profile.py:docstring of aiida.manage.configuration.profile.Profile.filepaths:0
#: ../../../src/aiida/manage/configuration/profile.py:docstring of aiida.manage.configuration.profile.Profile.is_test_profile:0
#: ../../../src/aiida/manage/configuration/profile.py:docstring of aiida.manage.configuration.profile.Profile.name:0
#: ../../../src/aiida/manage/configuration/profile.py:docstring of aiida.manage.configuration.profile.Profile.repository_path:0
#: ../../../src/aiida/manage/configuration/profile.py:docstring of aiida.manage.configuration.profile.Profile.rmq_prefix:0
#: ../../../src/aiida/manage/configuration/profile.py:docstring of aiida.manage.configuration.profile.Profile.uuid:0
#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres.can_user_authenticate:0
#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres.create_dbuser_db_safe:0
#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres.db_exists:0
#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres.dbuser_exists:0
#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres.find_new_db:0
#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres.find_new_dbuser:0
#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres.from_profile:0
#: ../../../src/aiida/manage/external/rmq/client.py:docstring of aiida.manage.external.rmq.client.RabbitmqManagementClient.format_url:0
#: ../../../src/aiida/manage/external/rmq/client.py:docstring of aiida.manage.external.rmq.client.RabbitmqManagementClient.is_connected:0
#: ../../../src/aiida/manage/external/rmq/client.py:docstring of aiida.manage.external.rmq.client.RabbitmqManagementClient.request:0
#: ../../../src/aiida/manage/external/rmq/utils.py:docstring of aiida.manage.external.rmq.utils.get_launch_queue_name:0
#: ../../../src/aiida/manage/external/rmq/utils.py:docstring of aiida.manage.external.rmq.utils.get_message_exchange_name:0
#: ../../../src/aiida/manage/external/rmq/utils.py:docstring of aiida.manage.external.rmq.utils.get_rmq_url:0
#: ../../../src/aiida/manage/external/rmq/utils.py:docstring of aiida.manage.external.rmq.utils.get_task_exchange_name:0
#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.create_communicator:0
#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.create_daemon_runner:0
#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.create_runner:0
#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.get_communicator:0
#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.get_config:0
#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.get_daemon_client:0
#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.get_option:0
#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.get_persister:0
#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.get_process_controller:0
#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.get_profile:0
#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.get_runner:0
#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.load_profile:0
#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.profile_storage_loaded:0
#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.get_rabbitmq_version:0
#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.is_rabbitmq_version_supported:0
#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.EntryPointManager._validate_entry_point:0
#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.EntryPointManager.add:0
#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.EntryPointManager.remove:0
#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.aiida_instance:0
#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.aiida_local_code_factory:0
#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.aiida_localhost:0
#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.aiida_manager:0
#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.aiida_test_profile:0
#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.postgres_cluster:0
#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.temp_dir:0
#: ../../../src/aiida/orm/authinfos.py:docstring of aiida.orm.authinfos.AuthInfo.enabled:0
#: ../../../src/aiida/orm/authinfos.py:docstring of aiida.orm.authinfos.AuthInfo.get_auth_params:0
#: ../../../src/aiida/orm/authinfos.py:docstring of aiida.orm.authinfos.AuthInfo.get_metadata:0
#: ../../../src/aiida/orm/authinfos.py:docstring of aiida.orm.authinfos.AuthInfo.get_workdir:0
#: ../../../src/aiida/orm/comments.py:docstring of aiida.orm.comments.Comment.__init__:0
#: ../../../src/aiida/orm/comments.py:docstring of aiida.orm.comments.Comment.uuid:0
#: ../../../src/aiida/orm/comments.py:docstring of aiida.orm.comments.CommentCollection.delete_many:0
#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.configure:0
#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.description:0
#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.get_authinfo:0
#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.get_minimum_job_poll_interval:0
#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.get_property:0
#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.get_transport:0
#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.get_use_double_quotes:0
#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.hostname:0
#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.is_configured:0
#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.is_user_configured:0
#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.is_user_enabled:0
#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.label:0
#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.metadata:0
#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.scheduler_type:0
#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.transport_type:0
#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.uuid:0
#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.ComputerCollection.get_or_create:0
#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities.Collection.all:0
#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities.Collection.count:0
#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities.Collection.find:0
#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities.Collection.get:0
#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities.Entity.get_collection:0
#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities.Entity.id:0
#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities.Entity.pk:0
#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities.from_backend_entity:0
#: ../../../src/aiida/orm/extras.py:docstring of aiida.orm.extras.EntityExtras.all:0
#: ../../../src/aiida/orm/extras.py:docstring of aiida.orm.extras.EntityExtras.get:0
#: ../../../src/aiida/orm/extras.py:docstring of aiida.orm.extras.EntityExtras.get_many:0
#: ../../../src/aiida/orm/extras.py:docstring of aiida.orm.extras.EntityExtras.items:0
#: ../../../src/aiida/orm/extras.py:docstring of aiida.orm.extras.EntityExtras.keys:0
#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.Group.count:0
#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.Group.description:0
#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.Group.is_empty:0
#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.Group.is_user_defined:0
#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.Group.label:0
#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.Group.type_string:0
#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.Group.user:0
#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.Group.uuid:0
#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.GroupCollection.get_or_create:0
#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.load_group_class:0
#: ../../../src/aiida/orm/implementation/authinfos.py:docstring of aiida.orm.implementation.authinfos.BackendAuthInfo.enabled:0
#: ../../../src/aiida/orm/implementation/authinfos.py:docstring of aiida.orm.implementation.authinfos.BackendAuthInfo.get_auth_params:0
#: ../../../src/aiida/orm/implementation/authinfos.py:docstring of aiida.orm.implementation.authinfos.BackendAuthInfo.get_metadata:0
#: ../../../src/aiida/orm/implementation/comments.py:docstring of aiida.orm.implementation.comments.BackendCommentCollection.create:0
#: ../../../src/aiida/orm/implementation/comments.py:docstring of aiida.orm.implementation.comments.BackendCommentCollection.delete_many:0
#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendCollection.create:0
#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendEntity.backend:0
#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendEntity.id:0
#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendEntity.is_stored:0
#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendEntity.pk:0
#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendEntityExtrasMixin.extras:0
#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendEntityExtrasMixin.get_extra:0
#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendEntityExtrasMixin.get_extra_many:0
#: ../../../src/aiida/orm/implementation/groups.py:docstring of aiida.orm.implementation.groups.BackendGroup.count:0
#: ../../../src/aiida/orm/implementation/logs.py:docstring of aiida.orm.implementation.logs.BackendLogCollection.delete_many:0
#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.add_incoming:0
#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.attributes:0
#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.attributes_items:0
#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.attributes_keys:0
#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.clone:0
#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.computer:0
#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.ctime:0
#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.description:0
#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.get_attribute:0
#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.get_attribute_many:0
#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.label:0
#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.mtime:0
#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.node_type:0
#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.process_type:0
#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.repository_metadata:0
#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.user:0
#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.uuid:0
#: ../../../src/aiida/orm/implementation/querybuilder.py:docstring of aiida.orm.implementation.querybuilder.BackendQueryBuilder.first:0
#: ../../../src/aiida/orm/implementation/querybuilder.py:docstring of aiida.orm.implementation.querybuilder.BackendQueryBuilder.get_creation_statistics:0
#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.bulk_insert:0
#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.get_info:0
#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.get_orm_entities:0
#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.initialise:0
#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.transaction:0
#: ../../../src/aiida/orm/implementation/users.py:docstring of aiida.orm.implementation.users.BackendUser.email:0
#: ../../../src/aiida/orm/implementation/users.py:docstring of aiida.orm.implementation.users.BackendUser.first_name:0
#: ../../../src/aiida/orm/implementation/users.py:docstring of aiida.orm.implementation.users.BackendUser.institution:0
#: ../../../src/aiida/orm/implementation/users.py:docstring of aiida.orm.implementation.users.BackendUser.last_name:0
#: ../../../src/aiida/orm/implementation/utils.py:docstring of aiida.orm.implementation.utils.clean_value:0
#: ../../../src/aiida/orm/logs.py:docstring of aiida.orm.logs.Log.dbnode_id:0
#: ../../../src/aiida/orm/logs.py:docstring of aiida.orm.logs.Log.levelname:0
#: ../../../src/aiida/orm/logs.py:docstring of aiida.orm.logs.Log.loggername:0
#: ../../../src/aiida/orm/logs.py:docstring of aiida.orm.logs.Log.message:0
#: ../../../src/aiida/orm/logs.py:docstring of aiida.orm.logs.Log.metadata:0
#: ../../../src/aiida/orm/logs.py:docstring of aiida.orm.logs.Log.time:0
#: ../../../src/aiida/orm/logs.py:docstring of aiida.orm.logs.Log.uuid:0
#: ../../../src/aiida/orm/logs.py:docstring of aiida.orm.logs.LogCollection.create_entry_from_record:0
#: ../../../src/aiida/orm/logs.py:docstring of aiida.orm.logs.LogCollection.delete_many:0
#: ../../../src/aiida/orm/logs.py:docstring of aiida.orm.logs.LogCollection.get_logs_for:0
#: ../../../src/aiida/orm/nodes/attributes.py:docstring of aiida.orm.nodes.attributes.NodeAttributes.all:0
#: ../../../src/aiida/orm/nodes/attributes.py:docstring of aiida.orm.nodes.attributes.NodeAttributes.get:0
#: ../../../src/aiida/orm/nodes/attributes.py:docstring of aiida.orm.nodes.attributes.NodeAttributes.get_many:0
#: ../../../src/aiida/orm/nodes/attributes.py:docstring of aiida.orm.nodes.attributes.NodeAttributes.items:0
#: ../../../src/aiida/orm/nodes/attributes.py:docstring of aiida.orm.nodes.attributes.NodeAttributes.keys:0
#: ../../../src/aiida/orm/nodes/caching.py:docstring of aiida.orm.nodes.caching.NodeCaching._get_same_node:0
#: ../../../src/aiida/orm/nodes/caching.py:docstring of aiida.orm.nodes.caching.NodeCaching.get_cache_source:0
#: ../../../src/aiida/orm/nodes/caching.py:docstring of aiida.orm.nodes.caching.NodeCaching.is_created_from_cache:0
#: ../../../src/aiida/orm/nodes/comments.py:docstring of aiida.orm.nodes.comments.NodeComments.add:0
#: ../../../src/aiida/orm/nodes/comments.py:docstring of aiida.orm.nodes.comments.NodeComments.all:0
#: ../../../src/aiida/orm/nodes/comments.py:docstring of aiida.orm.nodes.comments.NodeComments.get:0
#: ../../../src/aiida/orm/nodes/data/array/array.py:docstring of aiida.orm.nodes.data.array.array.clean_array:0
#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData._get_bandplot_data:0
#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands._extract_formula:0
#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.find_bandgap:0
#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.get_bands_and_parents_structure:0
#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.orm.nodes.data.array.kpoints.KpointsData.pbc:0
#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.orm.nodes.data.array.kpoints.KpointsData.reciprocal_cell:0
#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.restapi.translator.nodes.data.kpoints.KpointsDataTranslator.KpointsData.pbc:0
#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.restapi.translator.nodes.data.kpoints.KpointsDataTranslator.KpointsData.reciprocal_cell:0
#: ../../../src/aiida/orm/nodes/data/array/projection.py:docstring of aiida.orm.nodes.data.array.projection.ProjectionData._find_orbitals_and_indices:0
#: ../../../src/aiida/orm/nodes/data/array/projection.py:docstring of aiida.orm.nodes.data.array.projection.ProjectionData.get_pdos:0
#: ../../../src/aiida/orm/nodes/data/array/projection.py:docstring of aiida.orm.nodes.data.array.projection.ProjectionData.get_projections:0
#: ../../../src/aiida/orm/nodes/data/array/projection.py:docstring of aiida.orm.nodes.data.array.projection.ProjectionData.get_reference_bandsdata:0
#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.get_step_data:0
#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.get_step_structure:0
#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.get_structure:0
#: ../../../src/aiida/orm/nodes/data/array/xy.py:docstring of aiida.orm.nodes.data.array.xy.check_convert_single_to_tuple:0
#: ../../../src/aiida/orm/nodes/data/bool.py:docstring of aiida.orm.nodes.data.bool.get_false_node:0
#: ../../../src/aiida/orm/nodes/data/bool.py:docstring of aiida.orm.nodes.data.bool.get_true_node:0
#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData._get_object_ase:0
#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData._get_object_pycifrw:0
#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.get_structure:0
#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.has_atomic_sites:0
#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.has_attached_hydrogens:0
#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.has_partial_occupancies:0
#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.has_undefined_atomic_sites:0
#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.has_unknown_species:0
#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.cif_from_ase:0
#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.has_pycifrw:0
#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.pycifrw_from_cif:0
#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.restapi.translator.nodes.data.cif.CifDataTranslator.CifData.has_atomic_sites:0
#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.restapi.translator.nodes.data.cif.CifDataTranslator.CifData.has_attached_hydrogens:0
#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.restapi.translator.nodes.data.cif.CifDataTranslator.CifData.has_partial_occupancies:0
#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.restapi.translator.nodes.data.cif.CifDataTranslator.CifData.has_undefined_atomic_sites:0
#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.restapi.translator.nodes.data.cif.CifDataTranslator.CifData.has_unknown_species:0
#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.append_text:0
#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.can_run_on_computer:0
#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.default_calc_job_plugin:0
#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.full_label:0
#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.get_builder:0
#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.get_executable:0
#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.get_executable_cmdline_params:0
#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.get_prepend_cmdline_params:0
#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.is_hidden:0
#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.label:0
#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.prepend_text:0
#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.use_double_quotes:0
#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.with_mpi:0
#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.wrap_cmdline_params:0
#: ../../../src/aiida/orm/nodes/data/code/containerized.py:docstring of aiida.orm.nodes.data.code.containerized.ContainerizedCode.engine_command:0
#: ../../../src/aiida/orm/nodes/data/code/containerized.py:docstring of aiida.orm.nodes.data.code.containerized.ContainerizedCode.filepath_executable:0
#: ../../../src/aiida/orm/nodes/data/code/containerized.py:docstring of aiida.orm.nodes.data.code.containerized.ContainerizedCode.get_prepend_cmdline_params:0
#: ../../../src/aiida/orm/nodes/data/code/containerized.py:docstring of aiida.orm.nodes.data.code.containerized.ContainerizedCode.image_name:0
#: ../../../src/aiida/orm/nodes/data/code/installed.py:docstring of aiida.orm.nodes.data.code.installed.InstalledCode.can_run_on_computer:0
#: ../../../src/aiida/orm/nodes/data/code/installed.py:docstring of aiida.orm.nodes.data.code.installed.InstalledCode.filepath_executable:0
#: ../../../src/aiida/orm/nodes/data/code/installed.py:docstring of aiida.orm.nodes.data.code.installed.InstalledCode.full_label:0
#: ../../../src/aiida/orm/nodes/data/code/installed.py:docstring of aiida.orm.nodes.data.code.installed.InstalledCode.get_executable:0
#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.can_run_on_computer:0
#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.get_description:0
#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.get_executable:0
#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.get_use_double_quotes:0
#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.list_for_plugin:0
#: ../../../src/aiida/orm/nodes/data/code/portable.py:docstring of aiida.orm.nodes.data.code.portable.PortableCode.can_run_on_computer:0
#: ../../../src/aiida/orm/nodes/data/code/portable.py:docstring of aiida.orm.nodes.data.code.portable.PortableCode.filepath_executable:0
#: ../../../src/aiida/orm/nodes/data/code/portable.py:docstring of aiida.orm.nodes.data.code.portable.PortableCode.full_label:0
#: ../../../src/aiida/orm/nodes/data/code/portable.py:docstring of aiida.orm.nodes.data.code.portable.PortableCode.get_executable:0
#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.orm.nodes.data.data.Data.__deepcopy__:0
#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.orm.nodes.data.data.Data._exportcontent:0
#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.orm.nodes.data.data.Data.clone:0
#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.orm.nodes.data.data.Data.creator:0
#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.orm.nodes.data.data.Data.export:0
#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.orm.nodes.data.data.Data.get_export_formats:0
#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.orm.nodes.data.data.Data.importstring:0
#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.orm.nodes.data.data.Data.source:0
#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.restapi.translator.nodes.data.DataTranslator.Data.creator:0
#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.restapi.translator.nodes.data.DataTranslator.Data.source:0
#: ../../../src/aiida/orm/nodes/data/dict.py:docstring of aiida.orm.nodes.data.dict.Dict.dict:0
#: ../../../src/aiida/orm/nodes/data/dict.py:docstring of aiida.orm.nodes.data.dict.Dict.get:0
#: ../../../src/aiida/orm/nodes/data/dict.py:docstring of aiida.orm.nodes.data.dict.Dict.get_dict:0
#: ../../../src/aiida/orm/nodes/data/dict.py:docstring of aiida.orm.nodes.data.dict.Dict.keys:0
#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.as_path:0
#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.get_object:0
#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.list_object_names:0
#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.list_objects:0
#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.open:0
#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.walk:0
#: ../../../src/aiida/orm/nodes/data/list.py:docstring of aiida.orm.nodes.data.list.List._using_list_reference:0
#: ../../../src/aiida/orm/nodes/data/list.py:docstring of aiida.orm.nodes.data.list.List.get_list:0
#: ../../../src/aiida/orm/nodes/data/remote/base.py:docstring of aiida.orm.nodes.data.remote.base.RemoteData.listdir:0
#: ../../../src/aiida/orm/nodes/data/remote/base.py:docstring of aiida.orm.nodes.data.remote.base.RemoteData.listdir_withattributes:0
#: ../../../src/aiida/orm/nodes/data/remote/stash/base.py:docstring of aiida.orm.nodes.data.remote.stash.base.RemoteStashData.stash_mode:0
#: ../../../src/aiida/orm/nodes/data/remote/stash/folder.py:docstring of aiida.orm.nodes.data.remote.stash.folder.RemoteStashFolderData.source_list:0
#: ../../../src/aiida/orm/nodes/data/remote/stash/folder.py:docstring of aiida.orm.nodes.data.remote.stash.folder.RemoteStashFolderData.target_basepath:0
#: ../../../src/aiida/orm/nodes/data/singlefile.py:docstring of aiida.orm.nodes.data.singlefile.SinglefileData.as_path:0
#: ../../../src/aiida/orm/nodes/data/singlefile.py:docstring of aiida.orm.nodes.data.singlefile.SinglefileData.filename:0
#: ../../../src/aiida/orm/nodes/data/singlefile.py:docstring of aiida.orm.nodes.data.singlefile.SinglefileData.get_content:0
#: ../../../src/aiida/orm/nodes/data/singlefile.py:docstring of aiida.orm.nodes.data.singlefile.SinglefileData.open:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.Kind.compare_with:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.Kind.get_raw:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.Kind.has_vacancies:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.Kind.is_alloy:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.Kind.mass:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.Kind.name:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.Site.get_raw:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData._get_object_ase:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData._get_object_phonopyatoms:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData._get_object_pymatgen:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData._get_object_pymatgen_molecule:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData._get_object_pymatgen_structure:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.cell:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_ase:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_cell_volume:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_cif:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_composition:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_description:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_dimensionality:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_formula:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_kind:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_kind_names:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_pymatgen_molecule:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_pymatgen_structure:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_site_kindnames:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_symbols_set:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.has_vacancies:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.is_alloy:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.pbc:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure._get_dimensionality:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.calc_cell_volume:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.get_formula:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.get_formula_group:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.get_pymatgen_version:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.has_ase:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.has_pymatgen:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.has_spglib:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.is_ase_atoms:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.is_valid_symbol:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.restapi.translator.nodes.data.structure.StructureDataTranslator.StructureData.cell:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.restapi.translator.nodes.data.structure.StructureDataTranslator.StructureData.has_vacancies:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.restapi.translator.nodes.data.structure.StructureDataTranslator.StructureData.is_alloy:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.restapi.translator.nodes.data.structure.StructureDataTranslator.StructureData.pbc:0
#: ../../../src/aiida/orm/nodes/data/upf.py:docstring of aiida.orm.nodes.data.upf.UpfData.element:0
#: ../../../src/aiida/orm/nodes/data/upf.py:docstring of aiida.orm.nodes.data.upf.UpfData.from_md5:0
#: ../../../src/aiida/orm/nodes/data/upf.py:docstring of aiida.orm.nodes.data.upf.UpfData.get_or_create:0
#: ../../../src/aiida/orm/nodes/data/upf.py:docstring of aiida.orm.nodes.data.upf.UpfData.get_upf_group:0
#: ../../../src/aiida/orm/nodes/data/upf.py:docstring of aiida.orm.nodes.data.upf.UpfData.get_upf_groups:0
#: ../../../src/aiida/orm/nodes/data/upf.py:docstring of aiida.orm.nodes.data.upf.UpfData.md5sum:0
#: ../../../src/aiida/orm/nodes/data/upf.py:docstring of aiida.orm.nodes.data.upf.get_pseudos_from_structure:0
#: ../../../src/aiida/orm/nodes/data/upf.py:docstring of aiida.restapi.translator.nodes.data.upf.UpfDataTranslator.UpfData.element:0
#: ../../../src/aiida/orm/nodes/data/upf.py:docstring of aiida.restapi.translator.nodes.data.upf.UpfDataTranslator.UpfData.md5sum:0
#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node.ctime:0
#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node.description:0
#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node.get_description:0
#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node.label:0
#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node.logger:0
#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node.mtime:0
#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node.node_type:0
#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node.process_type:0
#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node.uuid:0
#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.get_authinfo:0
#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.get_detailed_job_info:0
#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.get_job_id:0
#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.get_last_job_info:0
#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.get_option:0
#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.get_options:0
#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.get_parser_class:0
#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.get_remote_workdir:0
#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.get_retrieve_list:0
#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.get_retrieve_temporary_list:0
#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.get_retrieved_node:0
#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.get_scheduler_lastchecktime:0
#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.get_scheduler_state:0
#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.get_scheduler_stderr:0
#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.get_scheduler_stdout:0
#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.get_state:0
#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.get_transport:0
#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.res:0
#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.tools:0
#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.restapi.resources.CalcJobNode.CalcJobTranslator.CalcJobNode.res:0
#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.restapi.resources.CalcJobNode.CalcJobTranslator.CalcJobNode.tools:0
#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.restapi.translator.nodes.process.calculation.calcjob.CalcJobTranslator.CalcJobNode.res:0
#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.restapi.translator.nodes.process.calculation.calcjob.CalcJobTranslator.CalcJobNode.tools:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.called:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.caller:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.checkpoint:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.exception:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.exit_code:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.exit_message:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.exit_status:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.get_builder_restart:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.is_excepted:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.is_failed:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.is_finished:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.is_finished_ok:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.is_killed:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.is_terminated:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.logger:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.paused:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.process_class:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.process_label:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.process_state:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.process_status:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNodeCaching.is_valid_cache:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.called:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.caller:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.checkpoint:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.exception:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.exit_code:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.exit_message:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.exit_status:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.is_excepted:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.is_failed:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.is_finished:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.is_finished_ok:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.is_killed:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.is_terminated:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.logger:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.paused:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.process_class:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.process_label:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.process_state:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.process_status:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.called:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.caller:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.checkpoint:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.exception:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.exit_code:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.exit_message:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.exit_status:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.is_excepted:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.is_failed:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.is_finished:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.is_finished_ok:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.is_killed:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.is_terminated:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.logger:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.paused:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.process_class:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.process_label:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.process_state:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.process_status:0
#: ../../../src/aiida/orm/nodes/process/workflow/workchain.py:docstring of aiida.orm.nodes.process.workflow.workchain.WorkChainNode.stepper_state_info:0
#: ../../../src/aiida/orm/nodes/process/workflow/workchain.py:docstring of aiida.restapi.translator.nodes.process.workflow.workchain.WorkChainTranslator.WorkChainNode.stepper_state_info:0
#: ../../../src/aiida/orm/nodes/process/workflow/workflow.py:docstring of aiida.orm.nodes.process.workflow.workflow.WorkflowNode.inputs:0
#: ../../../src/aiida/orm/nodes/process/workflow/workflow.py:docstring of aiida.orm.nodes.process.workflow.workflow.WorkflowNode.outputs:0
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository._repository:0
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.as_path:0
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.get_object:0
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.hash:0
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.list_object_names:0
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.list_objects:0
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.metadata:0
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.open:0
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.serialize:0
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.walk:0
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder._get_aiida_entity_res:0
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder._get_unique_tag:0
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.all:0
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.append:0
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.children:0
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.count:0
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.dict:0
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.distinct:0
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.first:0
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.get_used_tags:0
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.inputs:0
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.iterall:0
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.iterdict:0
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.outputs:0
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.parents:0
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder._get_group_type_filter:0
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder._get_node_type_filter:0
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder._get_ormclass:0
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder._get_ormclass_from_cls:0
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder._get_ormclass_from_str:0
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder._get_process_type_filter:0
#: ../../../src/aiida/orm/users.py:docstring of aiida.orm.users.User.get_full_name:0
#: ../../../src/aiida/orm/users.py:docstring of aiida.orm.users.User.get_short_name:0
#: ../../../src/aiida/orm/users.py:docstring of aiida.orm.users.User.is_default:0
#: ../../../src/aiida/orm/users.py:docstring of aiida.orm.users.UserCollection.get_or_create:0
#: ../../../src/aiida/orm/utils/calcjob.py:docstring of aiida.orm.utils.calcjob.CalcJobResultManager.__getattr__:0
#: ../../../src/aiida/orm/utils/calcjob.py:docstring of aiida.orm.utils.calcjob.CalcJobResultManager.__getitem__:0
#: ../../../src/aiida/orm/utils/calcjob.py:docstring of aiida.orm.utils.calcjob.CalcJobResultManager.get_results:0
#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links.LinkManager.__iter__:0
#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links.LinkManager.__next__:0
#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links.LinkManager.all:0
#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links.LinkManager.all_link_labels:0
#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links.LinkManager.all_link_pairs:0
#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links.LinkManager.all_nodes:0
#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links.LinkManager.first:0
#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links.LinkManager.get_node_by_label:0
#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links.LinkManager.nested:0
#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links.LinkManager.next:0
#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links.link_triple_exists:0
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.CalculationEntityLoader._get_query_builder_label_identifier:0
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.CodeEntityLoader._get_query_builder_label_identifier:0
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.ComputerEntityLoader._get_query_builder_label_identifier:0
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.DataEntityLoader._get_query_builder_label_identifier:0
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.GroupEntityLoader._get_query_builder_label_identifier:0
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.NodeEntityLoader._get_query_builder_label_identifier:0
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader._get_query_builder_id_identifier:0
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader._get_query_builder_label_identifier:0
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader._get_query_builder_uuid_identifier:0
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader.get_options:0
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader.get_query_builder:0
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader.get_query_classes:0
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader.infer_identifier_type:0
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader.load_entity:0
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.ProcessEntityLoader._get_query_builder_label_identifier:0
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.WorkflowEntityLoader._get_query_builder_label_identifier:0
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.get_loader:0
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_code:0
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_computer:0
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_entity:0
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_group:0
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_node:0
#: ../../../src/aiida/orm/utils/log.py:docstring of aiida.orm.utils.log.create_logger_adapter:0
#: ../../../src/aiida/orm/utils/mixins.py:docstring of aiida.orm.utils.mixins.FunctionCalculationMixin.function_name:0
#: ../../../src/aiida/orm/utils/mixins.py:docstring of aiida.orm.utils.mixins.FunctionCalculationMixin.function_namespace:0
#: ../../../src/aiida/orm/utils/mixins.py:docstring of aiida.orm.utils.mixins.FunctionCalculationMixin.function_number_of_lines:0
#: ../../../src/aiida/orm/utils/mixins.py:docstring of aiida.orm.utils.mixins.FunctionCalculationMixin.function_starting_line_number:0
#: ../../../src/aiida/orm/utils/mixins.py:docstring of aiida.orm.utils.mixins.FunctionCalculationMixin.get_function_source_code:0
#: ../../../src/aiida/orm/utils/mixins.py:docstring of aiida.orm.utils.mixins.FunctionCalculationMixin.get_source_code_file:0
#: ../../../src/aiida/orm/utils/mixins.py:docstring of aiida.orm.utils.mixins.FunctionCalculationMixin.get_source_code_function:0
#: ../../../src/aiida/orm/utils/node.py:docstring of aiida.orm.utils.node.get_query_type_from_type_string:0
#: ../../../src/aiida/orm/utils/node.py:docstring of aiida.orm.utils.node.is_valid_node_type_string:0
#: ../../../src/aiida/orm/utils/node.py:docstring of aiida.orm.utils.node.load_node_class:0
#: ../../../src/aiida/orm/utils/remote.py:docstring of aiida.orm.utils.remote.get_calcjob_remote_paths:0
#: ../../../src/aiida/orm/utils/serialize.py:docstring of aiida.orm.utils.serialize.deserialize_unsafe:0
#: ../../../src/aiida/orm/utils/serialize.py:docstring of aiida.orm.utils.serialize.serialize:0
#: ../../../src/aiida/parsers/parser.py:docstring of aiida.parsers.parser.Parser.exit_codes:0
#: ../../../src/aiida/parsers/parser.py:docstring of aiida.parsers.parser.Parser.get_outputs_for_parsing:0
#: ../../../src/aiida/parsers/parser.py:docstring of aiida.parsers.parser.Parser.logger:0
#: ../../../src/aiida/parsers/parser.py:docstring of aiida.parsers.parser.Parser.node:0
#: ../../../src/aiida/parsers/parser.py:docstring of aiida.parsers.parser.Parser.outputs:0
#: ../../../src/aiida/parsers/parser.py:docstring of aiida.parsers.parser.Parser.parse:0
#: ../../../src/aiida/parsers/parser.py:docstring of aiida.parsers.parser.Parser.parse_from_node:0
#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.get_entry_point:0
#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.get_entry_point_from_class:0
#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.get_entry_point_from_string:0
#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.get_entry_point_groups:0
#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.get_entry_point_string_format:0
#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.get_entry_point_string_from_class:0
#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.get_entry_points:0
#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.is_registered_entry_point:0
#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.is_valid_entry_point_string:0
#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.load_entry_point:0
#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.load_entry_point_from_string:0
#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.parse_entry_point_string:0
#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.BaseFactory:0
#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.CalcJobImporterFactory:0
#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.CalculationFactory:0
#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.DataFactory:0
#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.DbImporterFactory:0
#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.GroupFactory:0
#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.OrbitalFactory:0
#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.ParserFactory:0
#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.SchedulerFactory:0
#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.StorageFactory:0
#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.WorkflowFactory:0
#: ../../../src/aiida/plugins/utils.py:docstring of aiida.plugins.utils.PluginVersionProvider.get_version_info:0
#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.get_info:0
#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.has_object:0
#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.has_objects:0
#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.iter_object_streams:0
#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.list_objects:0
#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.open:0
#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.put_object_from_file:0
#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.put_object_from_filelike:0
#: ../../../src/aiida/repository/backend/disk_object_store.py:docstring of aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend._put_object_from_filelike:0
#: ../../../src/aiida/repository/backend/disk_object_store.py:docstring of aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend.has_objects:0
#: ../../../src/aiida/repository/backend/disk_object_store.py:docstring of aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend.iter_object_streams:0
#: ../../../src/aiida/repository/backend/disk_object_store.py:docstring of aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend.list_objects:0
#: ../../../src/aiida/repository/backend/disk_object_store.py:docstring of aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend.maintain:0
#: ../../../src/aiida/repository/backend/disk_object_store.py:docstring of aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend.open:0
#: ../../../src/aiida/repository/backend/sandbox.py:docstring of aiida.repository.backend.sandbox.SandboxRepositoryBackend._put_object_from_filelike:0
#: ../../../src/aiida/repository/backend/sandbox.py:docstring of aiida.repository.backend.sandbox.SandboxRepositoryBackend.get_info:0
#: ../../../src/aiida/repository/backend/sandbox.py:docstring of aiida.repository.backend.sandbox.SandboxRepositoryBackend.has_objects:0
#: ../../../src/aiida/repository/backend/sandbox.py:docstring of aiida.repository.backend.sandbox.SandboxRepositoryBackend.iter_object_streams:0
#: ../../../src/aiida/repository/backend/sandbox.py:docstring of aiida.repository.backend.sandbox.SandboxRepositoryBackend.list_objects:0
#: ../../../src/aiida/repository/backend/sandbox.py:docstring of aiida.repository.backend.sandbox.SandboxRepositoryBackend.open:0
#: ../../../src/aiida/repository/common.py:docstring of aiida.repository.common.File.from_serialized:0
#: ../../../src/aiida/repository/common.py:docstring of aiida.repository.common.File.serialize:0
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.backend:0
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.create_directory:0
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.flatten:0
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.get_directory:0
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.get_file:0
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.get_file_keys:0
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.get_object:0
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.has_object:0
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.hash:0
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.is_empty:0
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.list_object_names:0
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.list_objects:0
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.open:0
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.serialize:0
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.walk:0
#: ../../../src/aiida/restapi/common/identifiers.py:docstring of aiida.restapi.common.identifiers.Namespace.create_namespace:0
#: ../../../src/aiida/restapi/common/identifiers.py:docstring of aiida.restapi.common.identifiers.Namespace.get_description:0
#: ../../../src/aiida/restapi/common/identifiers.py:docstring of aiida.restapi.common.identifiers.construct_full_type:0
#: ../../../src/aiida/restapi/common/identifiers.py:docstring of aiida.restapi.common.identifiers.get_full_type_filters:0
#: ../../../src/aiida/restapi/common/identifiers.py:docstring of aiida.restapi.common.identifiers.get_node_namespace:0
#: ../../../src/aiida/restapi/common/utils.py:docstring of aiida.restapi.common.utils.CustomJSONProvider.default:0
#: ../../../src/aiida/restapi/common/utils.py:docstring of aiida.restapi.common.utils.Utils.build_datetime_filter:0
#: ../../../src/aiida/restapi/common/utils.py:docstring of aiida.restapi.common.utils.Utils.build_response:0
#: ../../../src/aiida/restapi/common/utils.py:docstring of aiida.restapi.common.utils.Utils.build_translator_parameters:0
#: ../../../src/aiida/restapi/common/utils.py:docstring of aiida.restapi.common.utils.Utils.parse_path:0
#: ../../../src/aiida/restapi/common/utils.py:docstring of aiida.restapi.common.utils.Utils.split_path:0
#: ../../../src/aiida/restapi/common/utils.py:docstring of aiida.restapi.common.utils.Utils.strip_api_prefix:0
#: ../../../src/aiida/restapi/resources.py:docstring of aiida.restapi.resources.BaseResource.unquote_request:0
#: ../../../src/aiida/restapi/resources.py:docstring of aiida.restapi.resources.CalcJobNode.get:0
#: ../../../src/aiida/restapi/resources.py:docstring of aiida.restapi.resources.Node.get:0
#: ../../../src/aiida/restapi/resources.py:docstring of aiida.restapi.resources.ProcessNode.get:0
#: ../../../src/aiida/restapi/resources.py:docstring of aiida.restapi.resources.QueryBuilder.post:0
#: ../../../src/aiida/restapi/run_api.py:docstring of aiida.restapi.run_api.configure_api:0
#: ../../../src/aiida/restapi/run_api.py:docstring of aiida.restapi.run_api.run_api:0
#: ../../../src/aiida/restapi/translator/base.py:docstring of aiida.restapi.translator.base.BaseTranslator.__repr__:0
#: ../../../src/aiida/restapi/translator/base.py:docstring of aiida.restapi.translator.base.BaseTranslator._check_id_validity:0
#: ../../../src/aiida/restapi/translator/base.py:docstring of aiida.restapi.translator.base.BaseTranslator.get_formatted_result:0
#: ../../../src/aiida/restapi/translator/base.py:docstring of aiida.restapi.translator.base.BaseTranslator.get_query_help:0
#: ../../../src/aiida/restapi/translator/base.py:docstring of aiida.restapi.translator.base.BaseTranslator.get_results:0
#: ../../../src/aiida/restapi/translator/base.py:docstring of aiida.restapi.translator.base.BaseTranslator.get_total_count:0
#: ../../../src/aiida/restapi/translator/base.py:docstring of aiida.restapi.translator.base.BaseTranslator.set_default_projections:0
#: ../../../src/aiida/restapi/translator/base.py:docstring of aiida.restapi.translator.base.BaseTranslator.set_filters:0
#: ../../../src/aiida/restapi/translator/base.py:docstring of aiida.restapi.translator.base.BaseTranslator.set_limit_offset:0
#: ../../../src/aiida/restapi/translator/base.py:docstring of aiida.restapi.translator.base.BaseTranslator.set_projections:0
#: ../../../src/aiida/restapi/translator/nodes/data/__init__.py:docstring of aiida.restapi.translator.nodes.data.DataTranslator.get_downloadable_data:0
#: ../../../src/aiida/restapi/translator/nodes/data/cif.py:docstring of aiida.restapi.translator.nodes.data.cif.CifDataTranslator.get_derived_properties:0
#: ../../../src/aiida/restapi/translator/nodes/data/code.py:docstring of aiida.restapi.translator.nodes.data.code.CodeTranslator.get_derived_properties:0
#: ../../../src/aiida/restapi/translator/nodes/data/upf.py:docstring of aiida.restapi.translator.nodes.data.upf.UpfDataTranslator.get_derived_properties:0
#: ../../../src/aiida/restapi/translator/nodes/node.py:docstring of aiida.restapi.translator.nodes.node.NodeTranslator.get_comments:0
#: ../../../src/aiida/restapi/translator/nodes/node.py:docstring of aiida.restapi.translator.nodes.node.NodeTranslator.get_derived_properties:0
#: ../../../src/aiida/restapi/translator/nodes/node.py:docstring of aiida.restapi.translator.nodes.node.NodeTranslator.get_downloadable_data:0
#: ../../../src/aiida/restapi/translator/nodes/node.py:docstring of aiida.restapi.translator.nodes.node.NodeTranslator.get_file_content:0
#: ../../../src/aiida/restapi/translator/nodes/node.py:docstring of aiida.restapi.translator.nodes.node.NodeTranslator.get_formatted_result:0
#: ../../../src/aiida/restapi/translator/nodes/node.py:docstring of aiida.restapi.translator.nodes.node.NodeTranslator.get_results:0
#: ../../../src/aiida/restapi/translator/nodes/process/calculation/calcfunction.py:docstring of aiida.restapi.translator.nodes.process.calculation.calcfunction.CalcFunctionTranslator.get_derived_properties:0
#: ../../../src/aiida/restapi/translator/nodes/process/calculation/calcjob.py:docstring of aiida.restapi.translator.nodes.process.calculation.calcjob.CalcJobTranslator.get_derived_properties:0
#: ../../../src/aiida/restapi/translator/nodes/process/workflow/workchain.py:docstring of aiida.restapi.translator.nodes.process.workflow.workchain.WorkChainTranslator.get_derived_properties:0
#: ../../../src/aiida/restapi/translator/nodes/process/workflow/workfunction.py:docstring of aiida.restapi.translator.nodes.process.workflow.workfunction.WorkFunctionTranslator.get_derived_properties:0
#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobInfo.get_dict:0
#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobInfo.serialize:0
#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobInfo.serialize_field:0
#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobResource.validate_resources:0
#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.NodeNumberJobResource.validate_resources:0
#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.ParEnvJobResource.validate_resources:0
#: ../../../src/aiida/schedulers/plugins/direct.py:docstring of aiida.schedulers.plugins.direct.DirectScheduler._parse_kill_output:0
#: ../../../src/aiida/schedulers/plugins/lsf.py:docstring of aiida.schedulers.plugins.lsf.LsfJobResource.validate_resources:0
#: ../../../src/aiida/schedulers/plugins/lsf.py:docstring of aiida.schedulers.plugins.lsf.LsfScheduler._parse_kill_output:0
#: ../../../src/aiida/schedulers/plugins/pbsbaseclasses.py:docstring of aiida.schedulers.plugins.pbsbaseclasses.PbsBaseClass._parse_kill_output:0
#: ../../../src/aiida/schedulers/plugins/pbsbaseclasses.py:docstring of aiida.schedulers.plugins.pbsbaseclasses.PbsJobResource.validate_resources:0
#: ../../../src/aiida/schedulers/plugins/sge.py:docstring of aiida.schedulers.plugins.sge.SgeScheduler._parse_joblist_output:0
#: ../../../src/aiida/schedulers/plugins/sge.py:docstring of aiida.schedulers.plugins.sge.SgeScheduler._parse_kill_output:0
#: ../../../src/aiida/schedulers/plugins/slurm.py:docstring of aiida.schedulers.plugins.slurm.SlurmJobResource.validate_resources:0
#: ../../../src/aiida/schedulers/plugins/slurm.py:docstring of aiida.schedulers.plugins.slurm.SlurmScheduler._parse_kill_output:0
#: ../../../src/aiida/schedulers/plugins/slurm.py:docstring of aiida.schedulers.plugins.slurm.SlurmScheduler.parse_output:0
#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler._get_run_line:0
#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler._get_submit_command:0
#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler._get_submit_script_environment_variables:0
#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler._get_submit_script_footer:0
#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler._get_submit_script_header:0
#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler._parse_joblist_output:0
#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler._parse_kill_output:0
#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler._parse_submit_output:0
#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler.get_detailed_job_info:0
#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler.get_jobs:0
#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler.kill:0
#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler.parse_output:0
#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler.submit_from_script:0
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.bulk_insert:0
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.get_backend_entity:0
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.get_info:0
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.get_unreferenced_keyset:0
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.initialise:0
#: ../../../src/aiida/storage/psql_dos/migrations/utils/create_dbattribute.py:docstring of aiida.storage.psql_dos.migrations.utils.create_dbattribute.create_rows:0
#: ../../../src/aiida/storage/psql_dos/migrations/utils/integrity.py:docstring of aiida.storage.psql_dos.migrations.utils.integrity.infer_calculation_entry_point:0
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.NoopRepositoryBackend.get_info:0
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.NoopRepositoryBackend.has_objects:0
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.NoopRepositoryBackend.iter_object_streams:0
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.NoopRepositoryBackend.list_objects:0
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.get_node_repository_dirpaths:0
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.get_node_repository_sub_folder:0
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.get_numpy_array_absolute_path:0
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.load_numpy_array_from_repository:0
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.migrate_legacy_repository:0
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.serialize_repository:0
#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator.connection:0
#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator.get_container:0
#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator.get_repository_uuid:0
#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator.get_schema_versions:0
#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator.initialise:0
#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator.is_database_initialised:0
#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator.is_initialised:0
#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator.is_repository_initialised:0
#: ../../../src/aiida/storage/psql_dos/orm/authinfos.py:docstring of aiida.storage.psql_dos.orm.authinfos.SqlaAuthInfo.__init__:0
#: ../../../src/aiida/storage/psql_dos/orm/authinfos.py:docstring of aiida.storage.psql_dos.orm.authinfos.SqlaAuthInfo.computer:0
#: ../../../src/aiida/storage/psql_dos/orm/authinfos.py:docstring of aiida.storage.psql_dos.orm.authinfos.SqlaAuthInfo.enabled:0
#: ../../../src/aiida/storage/psql_dos/orm/authinfos.py:docstring of aiida.storage.psql_dos.orm.authinfos.SqlaAuthInfo.get_auth_params:0
#: ../../../src/aiida/storage/psql_dos/orm/authinfos.py:docstring of aiida.storage.psql_dos.orm.authinfos.SqlaAuthInfo.get_metadata:0
#: ../../../src/aiida/storage/psql_dos/orm/authinfos.py:docstring of aiida.storage.psql_dos.orm.authinfos.SqlaAuthInfo.id:0
#: ../../../src/aiida/storage/psql_dos/orm/authinfos.py:docstring of aiida.storage.psql_dos.orm.authinfos.SqlaAuthInfo.is_stored:0
#: ../../../src/aiida/storage/psql_dos/orm/authinfos.py:docstring of aiida.storage.psql_dos.orm.authinfos.SqlaAuthInfo.user:0
#: ../../../src/aiida/storage/psql_dos/orm/comments.py:docstring of aiida.storage.psql_dos.orm.comments.SqlaCommentCollection.create:0
#: ../../../src/aiida/storage/psql_dos/orm/comments.py:docstring of aiida.storage.psql_dos.orm.comments.SqlaCommentCollection.delete_many:0
#: ../../../src/aiida/storage/psql_dos/orm/computers.py:docstring of aiida.storage.psql_dos.orm.computers.SqlaComputer.id:0
#: ../../../src/aiida/storage/psql_dos/orm/computers.py:docstring of aiida.storage.psql_dos.orm.computers.SqlaComputer.is_stored:0
#: ../../../src/aiida/storage/psql_dos/orm/computers.py:docstring of aiida.storage.psql_dos.orm.computers.SqlaComputer.pk:0
#: ../../../src/aiida/storage/psql_dos/orm/entities.py:docstring of aiida.storage.psql_dos.orm.entities.SqlaModelEntity.from_dbmodel:0
#: ../../../src/aiida/storage/psql_dos/orm/entities.py:docstring of aiida.storage.psql_dos.orm.entities.SqlaModelEntity.id:0
#: ../../../src/aiida/storage/psql_dos/orm/entities.py:docstring of aiida.storage.psql_dos.orm.entities.SqlaModelEntity.is_stored:0
#: ../../../src/aiida/storage/psql_dos/orm/entities.py:docstring of aiida.storage.psql_dos.orm.entities.SqlaModelEntity.store:0
#: ../../../src/aiida/storage/psql_dos/orm/groups.py:docstring of aiida.storage.psql_dos.orm.groups.SqlaGroup.count:0
#: ../../../src/aiida/storage/psql_dos/orm/groups.py:docstring of aiida.storage.psql_dos.orm.groups.SqlaGroup.is_stored:0
#: ../../../src/aiida/storage/psql_dos/orm/groups.py:docstring of aiida.storage.psql_dos.orm.groups.SqlaGroup.pk:0
#: ../../../src/aiida/storage/psql_dos/orm/groups.py:docstring of aiida.storage.psql_dos.orm.groups.SqlaGroup.store:0
#: ../../../src/aiida/storage/psql_dos/orm/logs.py:docstring of aiida.storage.psql_dos.orm.logs.SqlaLogCollection.delete_many:0
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.add_incoming:0
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.attributes:0
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.attributes_items:0
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.attributes_keys:0
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.clone:0
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.computer:0
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.ctime:0
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.description:0
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.get_attribute:0
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.label:0
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.mtime:0
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.node_type:0
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.process_type:0
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.repository_metadata:0
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.store:0
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.user:0
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.uuid:0
#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder.build_filters:0
#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder.first:0
#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder.get_creation_statistics:0
#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main._get_projection:0
#: ../../../src/aiida/storage/psql_dos/orm/users.py:docstring of aiida.storage.psql_dos.orm.users.SqlaUser.email:0
#: ../../../src/aiida/storage/psql_dos/orm/users.py:docstring of aiida.storage.psql_dos.orm.users.SqlaUser.first_name:0
#: ../../../src/aiida/storage/psql_dos/orm/users.py:docstring of aiida.storage.psql_dos.orm.users.SqlaUser.institution:0
#: ../../../src/aiida/storage/psql_dos/orm/users.py:docstring of aiida.storage.psql_dos.orm.users.SqlaUser.last_name:0
#: ../../../src/aiida/storage/psql_dos/orm/utils.py:docstring of aiida.storage.psql_dos.orm.utils.ModelWrapper.__getattr__:0
#: ../../../src/aiida/storage/psql_dos/orm/utils.py:docstring of aiida.storage.psql_dos.orm.utils.ModelWrapper._in_transaction:0
#: ../../../src/aiida/storage/psql_dos/orm/utils.py:docstring of aiida.storage.psql_dos.orm.utils.ModelWrapper._is_model_field:0
#: ../../../src/aiida/storage/psql_dos/orm/utils.py:docstring of aiida.storage.psql_dos.orm.utils.ModelWrapper._is_mutable_model_field:0
#: ../../../src/aiida/storage/psql_dos/orm/utils.py:docstring of aiida.storage.psql_dos.orm.utils.ModelWrapper.is_saved:0
#: ../../../src/aiida/storage/sqlite_dos/backend.py:docstring of aiida.storage.sqlite_dos.backend.SqliteDosMigrator.get_container:0
#: ../../../src/aiida/storage/sqlite_dos/backend.py:docstring of aiida.storage.sqlite_dos.backend.SqliteDosStorage.initialise:0
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SandboxShaRepositoryBackend._put_object_from_filelike:0
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SandboxShaRepositoryBackend.get_info:0
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.bulk_insert:0
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.get_info:0
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.initialise:0
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.FolderBackendRepository.has_object:0
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.FolderBackendRepository.list_objects:0
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.FolderBackendRepository.open:0
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.bulk_insert:0
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.get_info:0
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.initialise:0
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.transaction:0
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.ZipfileBackendRepository.has_object:0
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.ZipfileBackendRepository.list_objects:0
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.ZipfileBackendRepository.open:0
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend._RoBackendRepository.get_info:0
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend._RoBackendRepository.has_objects:0
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend._RoBackendRepository.iter_object_streams:0
#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy_to_main.py:docstring of aiida.storage.sqlite_zip.migrations.legacy_to_main._create_directory:0
#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy_to_main.py:docstring of aiida.storage.sqlite_zip.migrations.legacy_to_main._create_repo_metadata:0
#: ../../../src/aiida/storage/sqlite_zip/migrator.py:docstring of aiida.storage.sqlite_zip.migrator._perform_legacy_migrations:0
#: ../../../src/aiida/storage/sqlite_zip/orm.py:docstring of aiida.storage.sqlite_zip.orm.SqliteEntityOverride.from_dbmodel:0
#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveWriterAbstract.put_object:0
#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.get_format:0
#: ../../../src/aiida/tools/archive/common.py:docstring of aiida.tools.archive.common.batch_iter:0
#: ../../../src/aiida/tools/archive/create.py:docstring of aiida.tools.archive.create._collect_all_entities:0
#: ../../../src/aiida/tools/archive/create.py:docstring of aiida.tools.archive.create._collect_required_entities:0
#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/writer.py:docstring of aiida.tools.archive.implementations.sqlite_zip.writer.ArchiveWriterSqlZip.put_object:0
#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports._import_authinfos:0
#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports._import_comments:0
#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports._import_computers:0
#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports._import_groups:0
#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports._import_logs:0
#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports._import_nodes:0
#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports._import_users:0
#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports._make_import_group:0
#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports.import_archive:0
#: ../../../src/aiida/tools/data/array/kpoints/legacy.py:docstring of aiida.tools.data.array.kpoints.legacy.find_bravais_info:0
#: ../../../src/aiida/tools/data/array/kpoints/legacy.py:docstring of aiida.tools.data.array.kpoints.legacy.get_explicit_kpoints_path:0
#: ../../../src/aiida/tools/data/array/kpoints/main.py:docstring of aiida.tools.data.array.kpoints.main.get_explicit_kpoints_path:0
#: ../../../src/aiida/tools/data/array/kpoints/main.py:docstring of aiida.tools.data.array.kpoints.main.get_kpoints_path:0
#: ../../../src/aiida/tools/data/array/kpoints/seekpath.py:docstring of aiida.tools.data.array.kpoints.seekpath.get_explicit_kpoints_path:0
#: ../../../src/aiida/tools/data/array/kpoints/seekpath.py:docstring of aiida.tools.data.array.kpoints.seekpath.get_kpoints_path:0
#: ../../../src/aiida/tools/data/cif.py:docstring of aiida.tools.data.cif.refine_inline:0
#: ../../../src/aiida/tools/data/cif.py:docstring of aiida.tools.data.cif.symop_string_from_symop_matrix_tr:0
#: ../../../src/aiida/tools/data/orbital/orbital.py:docstring of aiida.tools.data.orbital.orbital.Orbital._validate_keys:0
#: ../../../src/aiida/tools/data/structure.py:docstring of aiida.tools.data.structure.structure_to_spglib_tuple:0
#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.CifEntry.get_aiida_structure:0
#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.CifEntry.get_cif_node:0
#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.CifEntry.get_parsed_cif:0
#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.CifEntry.get_raw_cif:0
#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbImporter.get_supported_keywords:0
#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.UpfEntry.get_upf_node:0
#: ../../../src/aiida/tools/dbimporters/plugins/cod.py:docstring of aiida.tools.dbimporters.plugins.cod.CodDbImporter.get_supported_keywords:0
#: ../../../src/aiida/tools/dbimporters/plugins/cod.py:docstring of aiida.tools.dbimporters.plugins.cod.CodDbImporter.query:0
#: ../../../src/aiida/tools/dbimporters/plugins/cod.py:docstring of aiida.tools.dbimporters.plugins.cod.CodDbImporter.query_sql:0
#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.IcsdDbImporter.get_supported_keywords:0
#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.IcsdEntry.get_ase_structure:0
#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.correct_cif:0
#: ../../../src/aiida/tools/dbimporters/plugins/materialsproject.py:docstring of aiida.tools.dbimporters.plugins.materialsproject.MaterialsProjectImporter.get_supported_keywords:0
#: ../../../src/aiida/tools/dbimporters/plugins/mpds.py:docstring of aiida.tools.dbimporters.plugins.mpds.MpdsDbImporter.get_id_from_cif:0
#: ../../../src/aiida/tools/dbimporters/plugins/mpds.py:docstring of aiida.tools.dbimporters.plugins.mpds.MpdsDbImporter.get_supported_keywords:0
#: ../../../src/aiida/tools/dbimporters/plugins/mpod.py:docstring of aiida.tools.dbimporters.plugins.mpod.MpodDbImporter.get_supported_keywords:0
#: ../../../src/aiida/tools/dbimporters/plugins/mpod.py:docstring of aiida.tools.dbimporters.plugins.mpod.MpodDbImporter.query:0
#: ../../../src/aiida/tools/dbimporters/plugins/mpod.py:docstring of aiida.tools.dbimporters.plugins.mpod.MpodDbImporter.query_get:0
#: ../../../src/aiida/tools/dbimporters/plugins/nninc.py:docstring of aiida.tools.dbimporters.plugins.nninc.NnincDbImporter.get_supported_keywords:0
#: ../../../src/aiida/tools/dbimporters/plugins/nninc.py:docstring of aiida.tools.dbimporters.plugins.nninc.NnincDbImporter.query:0
#: ../../../src/aiida/tools/dbimporters/plugins/nninc.py:docstring of aiida.tools.dbimporters.plugins.nninc.NnincDbImporter.query_get:0
#: ../../../src/aiida/tools/dbimporters/plugins/oqmd.py:docstring of aiida.tools.dbimporters.plugins.oqmd.OqmdDbImporter.get_supported_keywords:0
#: ../../../src/aiida/tools/dbimporters/plugins/oqmd.py:docstring of aiida.tools.dbimporters.plugins.oqmd.OqmdDbImporter.query:0
#: ../../../src/aiida/tools/dbimporters/plugins/oqmd.py:docstring of aiida.tools.dbimporters.plugins.oqmd.OqmdDbImporter.query_get:0
#: ../../../src/aiida/tools/dbimporters/plugins/pcod.py:docstring of aiida.tools.dbimporters.plugins.pcod.PcodDbImporter.query:0
#: ../../../src/aiida/tools/dbimporters/plugins/pcod.py:docstring of aiida.tools.dbimporters.plugins.pcod.PcodDbImporter.query_sql:0
#: ../../../src/aiida/tools/dbimporters/plugins/tcod.py:docstring of aiida.tools.dbimporters.plugins.tcod.TcodDbImporter.query:0
#: ../../../src/aiida/tools/graph/deletions.py:docstring of aiida.tools.graph.deletions.delete_group_nodes:0
#: ../../../src/aiida/tools/graph/deletions.py:docstring of aiida.tools.graph.deletions.delete_nodes:0
#: ../../../src/aiida/tools/groups/paths.py:docstring of aiida.tools.groups.paths.GroupPath.group_ids:0
#: ../../../src/aiida/tools/query/calculation.py:docstring of aiida.tools.query.calculation.CalculationQueryBuilder.get_filters:0
#: ../../../src/aiida/tools/query/calculation.py:docstring of aiida.tools.query.calculation.CalculationQueryBuilder.get_query_set:0
#: ../../../src/aiida/tools/query/formatting.py:docstring of aiida.tools.query.formatting.format_process_state:0
#: ../../../src/aiida/tools/query/formatting.py:docstring of aiida.tools.query.formatting.format_relative_time:0
#: ../../../src/aiida/tools/query/formatting.py:docstring of aiida.tools.query.formatting.format_sealed:0
#: ../../../src/aiida/tools/query/formatting.py:docstring of aiida.tools.query.formatting.format_state:0
#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.add_incoming:0
#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.add_outgoing:0
#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport._exec_command_internal:0
#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.exec_command_wait_bytes:0
#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.listdir:0
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport._exec_command_internal:0
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.exec_command_wait_bytes:0
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.lstat:0
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.stat:0
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.convert_to_bool:0
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport._exec_command_internal:0
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.exec_command_wait:0
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.exec_command_wait_bytes:0
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.get_attribute:0
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.get_mode:0
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.get_safe_open_interval:0
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.getcwd:0
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.isdir:0
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.isfile:0
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.listdir:0
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.listdir_withattributes:0
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.whoami:0
msgid "Returns"
msgstr ""

#: ../../../src/aiida/__init__.py:docstring of aiida._get_raw_file_header:4
#: ../../../src/aiida/__init__.py:docstring of aiida.get_file_header:9
msgid "default AiiDA source file header"
msgstr ""

#: ../../../src/aiida/__init__.py:docstring of aiida.get_file_header:1
msgid "Get the default header for source AiiDA source code files."
msgstr ""

#: ../../../src/aiida/__init__.py:docstring of aiida.get_file_header:5
msgid "Prepend by comment character."
msgstr ""

#: ../../../src/aiida/__init__.py:docstring of aiida.get_file_header:0
#: ../../../src/aiida/calculations/arithmetic/add.py:docstring of aiida.calculations.arithmetic.add.ArithmeticAddCalculation.define:0
#: ../../../src/aiida/calculations/arithmetic/add.py:docstring of aiida.calculations.arithmetic.add.ArithmeticAddCalculation.prepare_for_submission:0
#: ../../../src/aiida/calculations/importers/arithmetic/add.py:docstring of aiida.calculations.importers.arithmetic.add.ArithmeticAddCalculationImporter.parse_remote_data:0
#: ../../../src/aiida/calculations/monitors/base.py:docstring of aiida.calculations.monitors.base.always_kill:0
#: ../../../src/aiida/calculations/templatereplacer.py:docstring of aiida.calculations.templatereplacer.TemplatereplacerCalculation.define:0
#: ../../../src/aiida/calculations/templatereplacer.py:docstring of aiida.calculations.templatereplacer.TemplatereplacerCalculation.prepare_for_submission:0
#: ../../../src/aiida/calculations/transfer.py:docstring of aiida.calculations.transfer.TransferCalculation.define:0
#: ../../../src/aiida/calculations/transfer.py:docstring of aiida.calculations.transfer.TransferCalculation.prepare_for_submission:0
#: ../../../src/aiida/cmdline/commands/cmd_archive.py:docstring of aiida.cmdline.commands.cmd_archive._echo_exception:0
#: ../../../src/aiida/cmdline/commands/cmd_archive.py:docstring of aiida.cmdline.commands.cmd_archive._import_archive_and_migrate:0
#: ../../../src/aiida/cmdline/commands/cmd_calcjob.py:docstring of aiida.cmdline.commands.cmd_calcjob.get_remote_and_path:0
#: ../../../src/aiida/cmdline/commands/cmd_computer.py:docstring of aiida.cmdline.commands.cmd_computer._computer_create_temp_file:0
#: ../../../src/aiida/cmdline/commands/cmd_computer.py:docstring of aiida.cmdline.commands.cmd_computer._computer_get_remote_username:0
#: ../../../src/aiida/cmdline/commands/cmd_computer.py:docstring of aiida.cmdline.commands.cmd_computer._computer_test_get_jobs:0
#: ../../../src/aiida/cmdline/commands/cmd_computer.py:docstring of aiida.cmdline.commands.cmd_computer._computer_test_no_unexpected_output:0
#: ../../../src/aiida/cmdline/commands/cmd_computer.py:docstring of aiida.cmdline.commands.cmd_computer.get_parameter_default:0
#: ../../../src/aiida/cmdline/commands/cmd_computer.py:docstring of aiida.cmdline.commands.cmd_computer.time_use_login_shell:0
#: ../../../src/aiida/cmdline/commands/cmd_daemon.py:docstring of aiida.cmdline.commands.cmd_daemon.execute_client_command:0
#: ../../../src/aiida/cmdline/commands/cmd_data/cmd_export.py:docstring of aiida.cmdline.commands.cmd_data.cmd_export.data_export:0
#: ../../../src/aiida/cmdline/commands/cmd_data/cmd_structure.py:docstring of aiida.cmdline.commands.cmd_data.cmd_structure._store_structure:0
#: ../../../src/aiida/cmdline/commands/cmd_profile.py:docstring of aiida.cmdline.commands.cmd_profile.command_create_profile:0
#: ../../../src/aiida/cmdline/commands/cmd_rabbitmq.py:docstring of aiida.cmdline.commands.cmd_rabbitmq.echo_response:0
#: ../../../src/aiida/cmdline/commands/cmd_status.py:docstring of aiida.cmdline.commands.cmd_status.print_status:0
#: ../../../src/aiida/cmdline/groups/dynamic.py:docstring of aiida.cmdline.groups.dynamic.DynamicEntryPointCommandGroup.create_options:0
#: ../../../src/aiida/cmdline/groups/dynamic.py:docstring of aiida.cmdline.groups.dynamic.DynamicEntryPointCommandGroup.get_command:0
#: ../../../src/aiida/cmdline/groups/dynamic.py:docstring of aiida.cmdline.groups.dynamic.DynamicEntryPointCommandGroup.list_commands:0
#: ../../../src/aiida/cmdline/groups/dynamic.py:docstring of aiida.cmdline.groups.dynamic.DynamicEntryPointCommandGroup.list_options:0
#: ../../../src/aiida/cmdline/groups/verdi.py:docstring of aiida.cmdline.groups.verdi.LazyConfigAttributeDict.__getattr__:0
#: ../../../src/aiida/cmdline/params/options/commands/setup.py:docstring of aiida.cmdline.params.options.commands.setup.get_profile_attribute_default:0
#: ../../../src/aiida/cmdline/params/options/commands/setup.py:docstring of aiida.cmdline.params.options.commands.setup.get_quicksetup_database_name:0
#: ../../../src/aiida/cmdline/params/options/commands/setup.py:docstring of aiida.cmdline.params.options.commands.setup.get_quicksetup_password:0
#: ../../../src/aiida/cmdline/params/options/commands/setup.py:docstring of aiida.cmdline.params.options.commands.setup.get_quicksetup_repository_uri:0
#: ../../../src/aiida/cmdline/params/options/commands/setup.py:docstring of aiida.cmdline.params.options.commands.setup.get_quicksetup_username:0
#: ../../../src/aiida/cmdline/params/options/commands/setup.py:docstring of aiida.cmdline.params.options.commands.setup.get_repository_uri_default:0
#: ../../../src/aiida/cmdline/params/options/commands/setup.py:docstring of aiida.cmdline.params.options.commands.setup.validate_profile_parameter:0
#: ../../../src/aiida/cmdline/params/options/conditional.py:docstring of aiida.cmdline.params.options.conditional.ConditionalOption:0
#: ../../../src/aiida/cmdline/params/options/config.py:docstring of aiida.cmdline.params.options.config.ConfigFileOption.__call__:0
#: ../../../src/aiida/cmdline/params/options/config.py:docstring of aiida.cmdline.params.options.config.ConfigFileOption.__init__:0
#: ../../../src/aiida/cmdline/params/options/config.py:docstring of aiida.cmdline.params.options.config.configuration_callback:0
#: ../../../src/aiida/cmdline/params/options/config.py:docstring of aiida.cmdline.params.options.config.configuration_option:0
#: ../../../src/aiida/cmdline/params/options/interactive.py:docstring of aiida.cmdline.params.options.interactive.InteractiveOption.__init__:0
#: ../../../src/aiida/cmdline/params/options/interactive.py:docstring of aiida.cmdline.params.options.interactive.TemplateInteractiveOption.__init__:0
#: ../../../src/aiida/cmdline/params/options/overridable.py:docstring of aiida.cmdline.params.options.overridable.OverridableOption.__call__:0
#: ../../../src/aiida/cmdline/params/options/overridable.py:docstring of aiida.cmdline.params.options.overridable.OverridableOption.__init__:0
#: ../../../src/aiida/cmdline/params/options/overridable.py:docstring of aiida.cmdline.params.options.overridable.OverridableOption.clone:0
#: ../../../src/aiida/cmdline/params/types/choice.py:docstring of aiida.cmdline.params.types.choice.LazyChoice.convert:0
#: ../../../src/aiida/cmdline/params/types/code.py:docstring of aiida.cmdline.params.types.code.CodeParamType.__init__:0
#: ../../../src/aiida/cmdline/params/types/computer.py:docstring of aiida.cmdline.params.types.computer.MpirunCommandParamType.convert:0
#: ../../../src/aiida/cmdline/params/types/computer.py:docstring of aiida.cmdline.params.types.computer.ShebangParamType.convert:0
#: ../../../src/aiida/cmdline/params/types/config.py:docstring of aiida.cmdline.params.types.config.ConfigOptionParamType.convert:0
#: ../../../src/aiida/cmdline/params/types/group.py:docstring of aiida.cmdline.params.types.group.GroupParamType.__init__:0
#: ../../../src/aiida/cmdline/params/types/identifier.py:docstring of aiida.cmdline.params.types.identifier.IdentifierParamType.__init__:0
#: ../../../src/aiida/cmdline/params/types/multiple.py:docstring of aiida.cmdline.params.types.multiple.MultipleValueParamType.convert:0
#: ../../../src/aiida/cmdline/params/types/path.py:docstring of aiida.cmdline.params.types.path.AbsolutePathOrEmptyParamType.convert:0
#: ../../../src/aiida/cmdline/params/types/path.py:docstring of aiida.cmdline.params.types.path.AbsolutePathParamType.convert:0
#: ../../../src/aiida/cmdline/params/types/path.py:docstring of aiida.cmdline.params.types.path.FileOrUrl:0
#: ../../../src/aiida/cmdline/params/types/path.py:docstring of aiida.cmdline.params.types.path.PathOrUrl:0
#: ../../../src/aiida/cmdline/params/types/plugin.py:docstring of aiida.cmdline.params.types.plugin.PluginParamType:0
#: ../../../src/aiida/cmdline/params/types/strings.py:docstring of aiida.cmdline.params.types.strings.EmailType.convert:0
#: ../../../src/aiida/cmdline/params/types/strings.py:docstring of aiida.cmdline.params.types.strings.EntryPointType.convert:0
#: ../../../src/aiida/cmdline/params/types/strings.py:docstring of aiida.cmdline.params.types.strings.HostnameType.convert:0
#: ../../../src/aiida/cmdline/params/types/strings.py:docstring of aiida.cmdline.params.types.strings.LabelStringType.convert:0
#: ../../../src/aiida/cmdline/params/types/strings.py:docstring of aiida.cmdline.params.types.strings.NonEmptyStringParamType.convert:0
#: ../../../src/aiida/cmdline/params/types/user.py:docstring of aiida.cmdline.params.types.user.UserParamType.__init__:0
#: ../../../src/aiida/cmdline/params/types/user.py:docstring of aiida.cmdline.params.types.user.UserParamType.convert:0
#: ../../../src/aiida/cmdline/utils/ascii_vis.py:docstring of aiida.cmdline.utils.ascii_vis.build_call_graph:0
#: ../../../src/aiida/cmdline/utils/ascii_vis.py:docstring of aiida.cmdline.utils.ascii_vis.calc_info:0
#: ../../../src/aiida/cmdline/utils/ascii_vis.py:docstring of aiida.cmdline.utils.ascii_vis.format_call_graph:0
#: ../../../src/aiida/cmdline/utils/common.py:docstring of aiida.cmdline.utils.common.format_flat_links:0
#: ../../../src/aiida/cmdline/utils/common.py:docstring of aiida.cmdline.utils.common.format_local_time:0
#: ../../../src/aiida/cmdline/utils/common.py:docstring of aiida.cmdline.utils.common.format_nested_links:0
#: ../../../src/aiida/cmdline/utils/common.py:docstring of aiida.cmdline.utils.common.get_calcjob_report:0
#: ../../../src/aiida/cmdline/utils/common.py:docstring of aiida.cmdline.utils.common.get_node_info:0
#: ../../../src/aiida/cmdline/utils/common.py:docstring of aiida.cmdline.utils.common.get_node_summary:0
#: ../../../src/aiida/cmdline/utils/common.py:docstring of aiida.cmdline.utils.common.get_process_function_report:0
#: ../../../src/aiida/cmdline/utils/common.py:docstring of aiida.cmdline.utils.common.get_workchain_report:0
#: ../../../src/aiida/cmdline/utils/common.py:docstring of aiida.cmdline.utils.common.print_last_process_state_change:0
#: ../../../src/aiida/cmdline/utils/common.py:docstring of aiida.cmdline.utils.common.print_process_info:0
#: ../../../src/aiida/cmdline/utils/common.py:docstring of aiida.cmdline.utils.common.print_process_spec:0
#: ../../../src/aiida/cmdline/utils/decorators.py:docstring of aiida.cmdline.utils.decorators.only_if_daemon_not_running:0
#: ../../../src/aiida/cmdline/utils/decorators.py:docstring of aiida.cmdline.utils.decorators.only_if_daemon_running:0
#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo:0
#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_critical:0
#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_debug:0
#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_deprecated:0
#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_dictionary:0
#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_error:0
#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_formatted_list:0
#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_info:0
#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_report:0
#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_success:0
#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_tabulate:0
#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_warning:0
#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.highlight_string:0
#: ../../../src/aiida/cmdline/utils/multi_line_input.py:docstring of aiida.cmdline.utils.multi_line_input.edit_multiline_template:0
#: ../../../src/aiida/cmdline/utils/pluginable.py:docstring of aiida.cmdline.utils.pluginable.Pluginable.set_exclude_external_plugins:0
#: ../../../src/aiida/cmdline/utils/repository.py:docstring of aiida.cmdline.utils.repository.list_repository_contents:0
#: ../../../src/aiida/common/escaping.py:docstring of aiida.common.escaping.escape_for_bash:0
#: ../../../src/aiida/common/escaping.py:docstring of aiida.common.escaping.get_regex_pattern_from_sql:0
#: ../../../src/aiida/common/escaping.py:docstring of aiida.common.escaping.sql_string_match:0
#: ../../../src/aiida/common/files.py:docstring of aiida.common.files.md5_file:0
#: ../../../src/aiida/common/files.py:docstring of aiida.common.files.md5_from_filelike:0
#: ../../../src/aiida/common/files.py:docstring of aiida.common.files.sha1_file:0
#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder.create_file_from_filelike:0
#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder.create_symlink:0
#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder.erase:0
#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder.get_abs_path:0
#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder.get_content_list:0
#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder.get_subfolder:0
#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder.insert_path:0
#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder.open:0
#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder.remove_path:0
#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder.replace_with_folder:0
#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.SandboxFolder.__init__:0
#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.SubmitTestFolder.__init__:0
#: ../../../src/aiida/common/hashing.py:docstring of aiida.common.hashing.chunked_file_hash:0
#: ../../../src/aiida/common/hashing.py:docstring of aiida.common.hashing.float_to_text:0
#: ../../../src/aiida/common/hashing.py:docstring of aiida.common.hashing.get_random_string:0
#: ../../../src/aiida/common/hashing.py:docstring of aiida.common.hashing.make_hash:0
#: ../../../src/aiida/common/lang.py:docstring of aiida.common.lang.type_check:0
#: ../../../src/aiida/common/links.py:docstring of aiida.common.links.GraphTraversalRule:0
#: ../../../src/aiida/common/log.py:docstring of aiida.common.log.capture_logging:0
#: ../../../src/aiida/common/log.py:docstring of aiida.common.log.configure_logging:0
#: ../../../src/aiida/common/progress_reporter.py:docstring of aiida.common.progress_reporter.ProgressReporterAbstract.__init__:0
#: ../../../src/aiida/common/progress_reporter.py:docstring of aiida.common.progress_reporter.ProgressReporterAbstract.reset:0
#: ../../../src/aiida/common/progress_reporter.py:docstring of aiida.common.progress_reporter.ProgressReporterAbstract.set_description_str:0
#: ../../../src/aiida/common/progress_reporter.py:docstring of aiida.common.progress_reporter.ProgressReporterAbstract.update:0
#: ../../../src/aiida/common/progress_reporter.py:docstring of aiida.common.progress_reporter.set_progress_bar_tqdm:0
#: ../../../src/aiida/common/progress_reporter.py:docstring of aiida.common.progress_reporter.set_progress_reporter:0
#: ../../../src/aiida/common/timezone.py:docstring of aiida.common.timezone.delta:0
#: ../../../src/aiida/common/timezone.py:docstring of aiida.common.timezone.localtime:0
#: ../../../src/aiida/common/timezone.py:docstring of aiida.common.timezone.make_aware:0
#: ../../../src/aiida/common/timezone.py:docstring of aiida.common.timezone.timezone_from_name:0
#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.Capturing:0
#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.Prettifier.__init__:0
#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.Prettifier._prettify_label_agr:0
#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.Prettifier._prettify_label_agr_simple:0
#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.Prettifier._prettify_label_gnuplot:0
#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.Prettifier._prettify_label_gnuplot_simple:0
#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.Prettifier._prettify_label_latex:0
#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.Prettifier._prettify_label_latex_simple:0
#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.Prettifier._prettify_label_pass:0
#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.Prettifier.prettify:0
#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.get_unique_filename:0
#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.grouper:0
#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.join_labels:0
#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.prettify_labels:0
#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.str_timedelta:0
#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.strip_prefix:0
#: ../../../src/aiida/common/warnings.py:docstring of aiida.common.warnings.warn_deprecation:0
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.__init__:0
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient._await_condition:0
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient._start_daemon:0
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.call_client:0
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.cmd_start_daemon:0
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.decrease_workers:0
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.get_client:0
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.get_daemon_info:0
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.get_ipc_endpoint:0
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.get_numprocesses:0
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.get_status:0
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.get_tcp_endpoint:0
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.get_worker_info:0
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.increase_workers:0
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.restart_daemon:0
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.start_daemon:0
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.stop_daemon:0
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.get_daemon_client:0
#: ../../../src/aiida/engine/daemon/execmanager.py:docstring of aiida.engine.daemon.execmanager._find_data_node:0
#: ../../../src/aiida/engine/daemon/execmanager.py:docstring of aiida.engine.daemon.execmanager.kill_calculation:0
#: ../../../src/aiida/engine/daemon/execmanager.py:docstring of aiida.engine.daemon.execmanager.retrieve_calculation:0
#: ../../../src/aiida/engine/daemon/execmanager.py:docstring of aiida.engine.daemon.execmanager.retrieve_files_from_list:0
#: ../../../src/aiida/engine/daemon/execmanager.py:docstring of aiida.engine.daemon.execmanager.stash_calculation:0
#: ../../../src/aiida/engine/daemon/execmanager.py:docstring of aiida.engine.daemon.execmanager.submit_calculation:0
#: ../../../src/aiida/engine/daemon/execmanager.py:docstring of aiida.engine.daemon.execmanager.upload_calculation:0
#: ../../../src/aiida/engine/launch.py:docstring of aiida.engine.launch.await_processes:0
#: ../../../src/aiida/engine/launch.py:docstring of aiida.engine.launch.run:0
#: ../../../src/aiida/engine/launch.py:docstring of aiida.engine.launch.run_get_node:0
#: ../../../src/aiida/engine/launch.py:docstring of aiida.engine.launch.run_get_pk:0
#: ../../../src/aiida/engine/launch.py:docstring of aiida.engine.launch.submit:0
#: ../../../src/aiida/engine/persistence.py:docstring of aiida.engine.persistence.AiiDAPersister.delete_checkpoint:0
#: ../../../src/aiida/engine/persistence.py:docstring of aiida.engine.persistence.AiiDAPersister.delete_process_checkpoints:0
#: ../../../src/aiida/engine/persistence.py:docstring of aiida.engine.persistence.AiiDAPersister.get_process_checkpoints:0
#: ../../../src/aiida/engine/persistence.py:docstring of aiida.engine.persistence.AiiDAPersister.load_checkpoint:0
#: ../../../src/aiida/engine/persistence.py:docstring of aiida.engine.persistence.AiiDAPersister.save_checkpoint:0
#: ../../../src/aiida/engine/persistence.py:docstring of aiida.engine.persistence.ObjectLoader.load_object:0
#: ../../../src/aiida/engine/processes/builder.py:docstring of aiida.engine.processes.builder.ProcessBuilder.__init__:0
#: ../../../src/aiida/engine/processes/builder.py:docstring of aiida.engine.processes.builder.ProcessBuilderNamespace.__init__:0
#: ../../../src/aiida/engine/processes/builder.py:docstring of aiida.engine.processes.builder.ProcessBuilderNamespace._inputs:0
#: ../../../src/aiida/engine/processes/builder.py:docstring of aiida.engine.processes.builder.ProcessBuilderNamespace._merge:0
#: ../../../src/aiida/engine/processes/builder.py:docstring of aiida.engine.processes.builder.ProcessBuilderNamespace._update:0
#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.CalcJob.define:0
#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.CalcJob.get_importer:0
#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.CalcJob.parse:0
#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.CalcJob.prepare_for_submission:0
#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.CalcJob.presubmit:0
#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.CalcJob.terminate:0
#: ../../../src/aiida/engine/processes/calcjobs/importer.py:docstring of aiida.engine.processes.calcjobs.importer.CalcJobImporter.parse_remote_data:0
#: ../../../src/aiida/engine/processes/calcjobs/manager.py:docstring of aiida.engine.processes.calcjobs.manager.JobManager.get_jobs_list:0
#: ../../../src/aiida/engine/processes/calcjobs/manager.py:docstring of aiida.engine.processes.calcjobs.manager.JobsList.__init__:0
#: ../../../src/aiida/engine/processes/calcjobs/manager.py:docstring of aiida.engine.processes.calcjobs.manager.JobsList.request_job_info_update:0
#: ../../../src/aiida/engine/processes/calcjobs/monitors.py:docstring of aiida.engine.processes.calcjobs.monitors.CalcJobMonitors.process:0
#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.Waiting.__init__:0
#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.Waiting.parse:0
#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.task_kill_job:0
#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.task_monitor_job:0
#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.task_retrieve_job:0
#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.task_stash_job:0
#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.task_submit_job:0
#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.task_update_job:0
#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.task_upload_job:0
#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control._perform_actions:0
#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control._resolve_futures:0
#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control.get_active_processes:0
#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control.kill_processes:0
#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control.pause_processes:0
#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control.play_processes:0
#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control.revive_processes:0
#: ../../../src/aiida/engine/processes/exit_code.py:docstring of aiida.engine.processes.exit_code.ExitCode:0
#: ../../../src/aiida/engine/processes/exit_code.py:docstring of aiida.engine.processes.exit_code.ExitCode.format:0
#: ../../../src/aiida/engine/processes/exit_code.py:docstring of aiida.engine.processes.exit_code.ExitCodesNamespace.__call__:0
#: ../../../src/aiida/engine/processes/functions.py:docstring of aiida.engine.processes.functions.FunctionProcess.__init__:0
#: ../../../src/aiida/engine/processes/functions.py:docstring of aiida.engine.processes.functions.FunctionProcess.build:0
#: ../../../src/aiida/engine/processes/functions.py:docstring of aiida.engine.processes.functions.calcfunction:0
#: ../../../src/aiida/engine/processes/functions.py:docstring of aiida.engine.processes.functions.get_stack_size:0
#: ../../../src/aiida/engine/processes/functions.py:docstring of aiida.engine.processes.functions.infer_valid_type_from_type_annotation:0
#: ../../../src/aiida/engine/processes/functions.py:docstring of aiida.engine.processes.functions.process_function:0
#: ../../../src/aiida/engine/processes/functions.py:docstring of aiida.engine.processes.functions.workfunction:0
#: ../../../src/aiida/engine/processes/futures.py:docstring of aiida.engine.processes.futures.ProcessFuture.__init__:0
#: ../../../src/aiida/engine/processes/ports.py:docstring of aiida.engine.processes.ports.PortNamespace.serialize:0
#: ../../../src/aiida/engine/processes/ports.py:docstring of aiida.engine.processes.ports.PortNamespace.validate_port_name:0
#: ../../../src/aiida/engine/processes/ports.py:docstring of aiida.engine.processes.ports.WithSerialize.serialize:0
#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.__init__:0
#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process._filter_serializable_metadata:0
#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process._flatten_inputs:0
#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process._flatten_outputs:0
#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process._get_namespace_list:0
#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.decode_input_args:0
#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.encode_input_args:0
#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.exposed_inputs:0
#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.exposed_outputs:0
#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.get_exit_statuses:0
#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.kill:0
#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.load_instance_state:0
#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.on_except:0
#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.on_finish:0
#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.on_output_emitting:0
#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.on_paused:0
#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.out:0
#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.out_many:0
#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.report:0
#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.set_status:0
#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.submit:0
#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.get_query_string_from_process_type_string:0
#: ../../../src/aiida/engine/processes/process_spec.py:docstring of aiida.engine.processes.process_spec.ProcessSpec.exit_code:0
#: ../../../src/aiida/engine/processes/utils.py:docstring of aiida.engine.processes.utils.prune_mapping:0
#: ../../../src/aiida/engine/processes/workchains/context.py:docstring of aiida.engine.processes.workchains.context.append_:0
#: ../../../src/aiida/engine/processes/workchains/context.py:docstring of aiida.engine.processes.workchains.context.assign_:0
#: ../../../src/aiida/engine/processes/workchains/restart.py:docstring of aiida.engine.processes.workchains.restart.BaseRestartWorkChain._attach_outputs:0
#: ../../../src/aiida/engine/processes/workchains/restart.py:docstring of aiida.engine.processes.workchains.restart.BaseRestartWorkChain._wrap_bare_dict_inputs:0
#: ../../../src/aiida/engine/processes/workchains/restart.py:docstring of aiida.engine.processes.workchains.restart.BaseRestartWorkChain.is_process_handler:0
#: ../../../src/aiida/engine/processes/workchains/restart.py:docstring of aiida.engine.processes.workchains.restart.validate_handler_overrides:0
#: ../../../src/aiida/engine/processes/workchains/utils.py:docstring of aiida.engine.processes.workchains.utils.ProcessHandlerReport:0
#: ../../../src/aiida/engine/processes/workchains/utils.py:docstring of aiida.engine.processes.workchains.utils.process_handler:0
#: ../../../src/aiida/engine/processes/workchains/workchain.py:docstring of aiida.engine.processes.workchains.workchain.WorkChain.__init__:0
#: ../../../src/aiida/engine/processes/workchains/workchain.py:docstring of aiida.engine.processes.workchains.workchain.WorkChain._insert_awaitable:0
#: ../../../src/aiida/engine/processes/workchains/workchain.py:docstring of aiida.engine.processes.workchains.workchain.WorkChain._on_awaitable_finished:0
#: ../../../src/aiida/engine/processes/workchains/workchain.py:docstring of aiida.engine.processes.workchains.workchain.WorkChain._resolve_awaitable:0
#: ../../../src/aiida/engine/processes/workchains/workchain.py:docstring of aiida.engine.processes.workchains.workchain.WorkChain._resolve_nested_context:0
#: ../../../src/aiida/engine/processes/workchains/workchain.py:docstring of aiida.engine.processes.workchains.workchain.WorkChain._store_nodes:0
#: ../../../src/aiida/engine/processes/workchains/workchain.py:docstring of aiida.engine.processes.workchains.workchain.WorkChain.load_instance_state:0
#: ../../../src/aiida/engine/processes/workchains/workchain.py:docstring of aiida.engine.processes.workchains.workchain.WorkChain.save_instance_state:0
#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner.__init__:0
#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner._poll_process:0
#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner._run:0
#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner.call_on_process_finish:0
#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner.run:0
#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner.run_get_node:0
#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner.run_get_pk:0
#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner.schedule:0
#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner.submit:0
#: ../../../src/aiida/engine/transports.py:docstring of aiida.engine.transports.TransportQueue.__init__:0
#: ../../../src/aiida/engine/transports.py:docstring of aiida.engine.transports.TransportQueue.request_transport:0
#: ../../../src/aiida/engine/utils.py:docstring of aiida.engine.utils.InterruptableFuture.with_interrupt:0
#: ../../../src/aiida/engine/utils.py:docstring of aiida.engine.utils.ensure_coroutine:0
#: ../../../src/aiida/engine/utils.py:docstring of aiida.engine.utils.exponential_backoff_retry:0
#: ../../../src/aiida/engine/utils.py:docstring of aiida.engine.utils.get_process_state_change_timestamp:0
#: ../../../src/aiida/engine/utils.py:docstring of aiida.engine.utils.instantiate_process:0
#: ../../../src/aiida/engine/utils.py:docstring of aiida.engine.utils.interruptable_task:0
#: ../../../src/aiida/engine/utils.py:docstring of aiida.engine.utils.is_process_function:0
#: ../../../src/aiida/engine/utils.py:docstring of aiida.engine.utils.loop_scope:0
#: ../../../src/aiida/engine/utils.py:docstring of aiida.engine.utils.prepare_inputs:0
#: ../../../src/aiida/engine/utils.py:docstring of aiida.engine.utils.set_process_state_change_timestamp:0
#: ../../../src/aiida/manage/caching.py:docstring of aiida.manage.caching._ContextCache.get_options:0
#: ../../../src/aiida/manage/caching.py:docstring of aiida.manage.caching._match_wildcard:0
#: ../../../src/aiida/manage/caching.py:docstring of aiida.manage.caching._validate_identifier_pattern:0
#: ../../../src/aiida/manage/caching.py:docstring of aiida.manage.caching.disable_caching:0
#: ../../../src/aiida/manage/caching.py:docstring of aiida.manage.caching.enable_caching:0
#: ../../../src/aiida/manage/caching.py:docstring of aiida.manage.caching.get_use_cache:0
#: ../../../src/aiida/manage/configuration/__init__.py:docstring of aiida.manage.configuration.create_profile:0
#: ../../../src/aiida/manage/configuration/__init__.py:docstring of aiida.manage.configuration.get_config:0
#: ../../../src/aiida/manage/configuration/__init__.py:docstring of aiida.manage.configuration.get_config_option:0
#: ../../../src/aiida/manage/configuration/__init__.py:docstring of aiida.manage.configuration.load_config:0
#: ../../../src/aiida/manage/configuration/__init__.py:docstring of aiida.manage.configuration.load_profile:0
#: ../../../src/aiida/manage/configuration/__init__.py:docstring of aiida.manage.configuration.profile_context:0
#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.__init__:0
#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config._atomic_write:0
#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config._backup:0
#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.add_profile:0
#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.create_profile:0
#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.delete_profile:0
#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.from_file:0
#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.get_option:0
#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.get_options:0
#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.handle_invalid:0
#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.remove_profile:0
#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.set_default_profile:0
#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.set_default_user_email:0
#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.set_option:0
#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.unset_option:0
#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.update_profile:0
#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.validate_profile:0
#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.check_and_migrate_config:0
#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.config_needs_migrating:0
#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.downgrade_config:0
#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.upgrade_config:0
#: ../../../src/aiida/manage/configuration/options.py:docstring of aiida.manage.configuration.options.Option.validate:0
#: ../../../src/aiida/manage/configuration/options.py:docstring of aiida.manage.configuration.options.parse_option:0
#: ../../../src/aiida/manage/configuration/profile.py:docstring of aiida.manage.configuration.profile.Profile.set_option:0
#: ../../../src/aiida/manage/configuration/profile.py:docstring of aiida.manage.configuration.profile.Profile.set_process_controller:0
#: ../../../src/aiida/manage/configuration/profile.py:docstring of aiida.manage.configuration.profile.Profile.set_storage:0
#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres.can_user_authenticate:0
#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres.create_db:0
#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres.create_dbuser:0
#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres.create_dbuser_db_safe:0
#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres.db_exists:0
#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres.dbuser_exists:0
#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres.drop_db:0
#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres.drop_dbuser:0
#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres.find_new_db:0
#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres.find_new_dbuser:0
#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres.from_profile:0
#: ../../../src/aiida/manage/external/rmq/client.py:docstring of aiida.manage.external.rmq.client.RabbitmqManagementClient.__init__:0
#: ../../../src/aiida/manage/external/rmq/client.py:docstring of aiida.manage.external.rmq.client.RabbitmqManagementClient.format_url:0
#: ../../../src/aiida/manage/external/rmq/client.py:docstring of aiida.manage.external.rmq.client.RabbitmqManagementClient.request:0
#: ../../../src/aiida/manage/external/rmq/launcher.py:docstring of aiida.manage.external.rmq.launcher.ProcessLauncher._continue:0
#: ../../../src/aiida/manage/external/rmq/launcher.py:docstring of aiida.manage.external.rmq.launcher.ProcessLauncher.handle_continue_exception:0
#: ../../../src/aiida/manage/external/rmq/utils.py:docstring of aiida.manage.external.rmq.utils.get_rmq_url:0
#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.create_communicator:0
#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.create_daemon_runner:0
#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.create_runner:0
#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.get_option:0
#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.load_profile:0
#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.set_default_user_email:0
#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.set_runner:0
#: ../../../src/aiida/manage/profile_access.py:docstring of aiida.manage.profile_access.ProfileAccessManager.__init__:0
#: ../../../src/aiida/manage/profile_access.py:docstring of aiida.manage.profile_access.ProfileAccessManager._get_tracking_files:0
#: ../../../src/aiida/manage/profile_access.py:docstring of aiida.manage.profile_access.ProfileAccessManager._raise_if_active:0
#: ../../../src/aiida/manage/profile_access.py:docstring of aiida.manage.profile_access.ProfileAccessManager._raise_if_locked:0
#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.EntryPointManager._validate_entry_point:0
#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.EntryPointManager.add:0
#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.EntryPointManager.remove:0
#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.postgres_cluster:0
#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.recursive_merge:0
#: ../../../src/aiida/orm/authinfos.py:docstring of aiida.orm.authinfos.AuthInfo.__init__:0
#: ../../../src/aiida/orm/authinfos.py:docstring of aiida.orm.authinfos.AuthInfo.set_auth_params:0
#: ../../../src/aiida/orm/authinfos.py:docstring of aiida.orm.authinfos.AuthInfo.set_metadata:0
#: ../../../src/aiida/orm/authinfos.py:docstring of aiida.orm.authinfos.AuthInfoCollection.delete:0
#: ../../../src/aiida/orm/autogroup.py:docstring of aiida.orm.autogroup.AutogroupManager._matches:0
#: ../../../src/aiida/orm/autogroup.py:docstring of aiida.orm.autogroup.AutogroupManager.set_exclude:0
#: ../../../src/aiida/orm/autogroup.py:docstring of aiida.orm.autogroup.AutogroupManager.set_include:0
#: ../../../src/aiida/orm/comments.py:docstring of aiida.orm.comments.Comment.__init__:0
#: ../../../src/aiida/orm/comments.py:docstring of aiida.orm.comments.CommentCollection.delete:0
#: ../../../src/aiida/orm/comments.py:docstring of aiida.orm.comments.CommentCollection.delete_many:0
#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.configure:0
#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.delete_property:0
#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.get_authinfo:0
#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.get_configuration:0
#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.get_property:0
#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.get_transport:0
#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.is_user_configured:0
#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.is_user_enabled:0
#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.set_minimum_job_poll_interval:0
#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.set_property:0
#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.set_shebang:0
#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.set_use_double_quotes:0
#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.ComputerCollection.get_or_create:0
#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities.Collection.__init__:0
#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities.Collection.count:0
#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities.Collection.find:0
#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities.Collection.get:0
#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities.Collection.get_cached:0
#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities.Collection.query:0
#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities.Entity.__init__:0
#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities.Entity.get_collection:0
#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities.from_backend_entity:0
#: ../../../src/aiida/orm/extras.py:docstring of aiida.orm.extras.EntityExtras.delete:0
#: ../../../src/aiida/orm/extras.py:docstring of aiida.orm.extras.EntityExtras.delete_many:0
#: ../../../src/aiida/orm/extras.py:docstring of aiida.orm.extras.EntityExtras.get:0
#: ../../../src/aiida/orm/extras.py:docstring of aiida.orm.extras.EntityExtras.get_many:0
#: ../../../src/aiida/orm/extras.py:docstring of aiida.orm.extras.EntityExtras.reset:0
#: ../../../src/aiida/orm/extras.py:docstring of aiida.orm.extras.EntityExtras.set:0
#: ../../../src/aiida/orm/extras.py:docstring of aiida.orm.extras.EntityExtras.set_many:0
#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.Group.__init__:0
#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.Group.add_nodes:0
#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.Group.remove_nodes:0
#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.GroupCollection.delete:0
#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.GroupCollection.get_or_create:0
#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.load_group_class:0
#: ../../../src/aiida/orm/implementation/authinfos.py:docstring of aiida.orm.implementation.authinfos.BackendAuthInfo.set_auth_params:0
#: ../../../src/aiida/orm/implementation/authinfos.py:docstring of aiida.orm.implementation.authinfos.BackendAuthInfo.set_metadata:0
#: ../../../src/aiida/orm/implementation/authinfos.py:docstring of aiida.orm.implementation.authinfos.BackendAuthInfoCollection.delete:0
#: ../../../src/aiida/orm/implementation/comments.py:docstring of aiida.orm.implementation.comments.BackendCommentCollection.create:0
#: ../../../src/aiida/orm/implementation/comments.py:docstring of aiida.orm.implementation.comments.BackendCommentCollection.delete:0
#: ../../../src/aiida/orm/implementation/comments.py:docstring of aiida.orm.implementation.comments.BackendCommentCollection.delete_many:0
#: ../../../src/aiida/orm/implementation/computers.py:docstring of aiida.orm.implementation.computers.BackendComputerCollection.delete:0
#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendCollection.__init__:0
#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendEntityExtrasMixin.delete_extra:0
#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendEntityExtrasMixin.delete_extra_many:0
#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendEntityExtrasMixin.get_extra:0
#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendEntityExtrasMixin.get_extra_many:0
#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendEntityExtrasMixin.reset_extras:0
#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendEntityExtrasMixin.set_extra:0
#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendEntityExtrasMixin.set_extra_many:0
#: ../../../src/aiida/orm/implementation/groups.py:docstring of aiida.orm.implementation.groups.BackendGroup.add_nodes:0
#: ../../../src/aiida/orm/implementation/groups.py:docstring of aiida.orm.implementation.groups.BackendGroup.remove_nodes:0
#: ../../../src/aiida/orm/implementation/groups.py:docstring of aiida.orm.implementation.groups.BackendGroupCollection.delete:0
#: ../../../src/aiida/orm/implementation/logs.py:docstring of aiida.orm.implementation.logs.BackendLogCollection.delete:0
#: ../../../src/aiida/orm/implementation/logs.py:docstring of aiida.orm.implementation.logs.BackendLogCollection.delete_many:0
#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.add_incoming:0
#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.delete_attribute:0
#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.delete_attribute_many:0
#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.get_attribute:0
#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.get_attribute_many:0
#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.reset_attributes:0
#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.set_attribute:0
#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.set_attribute_many:0
#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.store:0
#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNodeCollection.delete:0
#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNodeCollection.get:0
#: ../../../src/aiida/orm/implementation/querybuilder.py:docstring of aiida.orm.implementation.querybuilder.BackendQueryBuilder.__init__:0
#: ../../../src/aiida/orm/implementation/querybuilder.py:docstring of aiida.orm.implementation.querybuilder.BackendQueryBuilder.get_creation_statistics:0
#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.bulk_insert:0
#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.bulk_update:0
#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.delete_nodes_and_connections:0
#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.get_global_variable:0
#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.get_info:0
#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.get_orm_entities:0
#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.initialise:0
#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.maintain:0
#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.set_global_variable:0
#: ../../../src/aiida/orm/implementation/utils.py:docstring of aiida.orm.implementation.utils.clean_value:0
#: ../../../src/aiida/orm/logs.py:docstring of aiida.orm.logs.Log.__init__:0
#: ../../../src/aiida/orm/logs.py:docstring of aiida.orm.logs.LogCollection.create_entry_from_record:0
#: ../../../src/aiida/orm/logs.py:docstring of aiida.orm.logs.LogCollection.delete:0
#: ../../../src/aiida/orm/logs.py:docstring of aiida.orm.logs.LogCollection.delete_many:0
#: ../../../src/aiida/orm/logs.py:docstring of aiida.orm.logs.LogCollection.get_logs_for:0
#: ../../../src/aiida/orm/nodes/attributes.py:docstring of aiida.orm.nodes.attributes.NodeAttributes.delete:0
#: ../../../src/aiida/orm/nodes/attributes.py:docstring of aiida.orm.nodes.attributes.NodeAttributes.delete_many:0
#: ../../../src/aiida/orm/nodes/attributes.py:docstring of aiida.orm.nodes.attributes.NodeAttributes.get:0
#: ../../../src/aiida/orm/nodes/attributes.py:docstring of aiida.orm.nodes.attributes.NodeAttributes.get_many:0
#: ../../../src/aiida/orm/nodes/attributes.py:docstring of aiida.orm.nodes.attributes.NodeAttributes.reset:0
#: ../../../src/aiida/orm/nodes/attributes.py:docstring of aiida.orm.nodes.attributes.NodeAttributes.set:0
#: ../../../src/aiida/orm/nodes/attributes.py:docstring of aiida.orm.nodes.attributes.NodeAttributes.set_many:0
#: ../../../src/aiida/orm/nodes/caching.py:docstring of aiida.orm.nodes.caching.NodeCaching._get_hash:0
#: ../../../src/aiida/orm/nodes/caching.py:docstring of aiida.orm.nodes.caching.NodeCaching.get_hash:0
#: ../../../src/aiida/orm/nodes/comments.py:docstring of aiida.orm.nodes.comments.NodeComments.add:0
#: ../../../src/aiida/orm/nodes/comments.py:docstring of aiida.orm.nodes.comments.NodeComments.get:0
#: ../../../src/aiida/orm/nodes/comments.py:docstring of aiida.orm.nodes.comments.NodeComments.remove:0
#: ../../../src/aiida/orm/nodes/comments.py:docstring of aiida.orm.nodes.comments.NodeComments.update:0
#: ../../../src/aiida/orm/nodes/data/array/array.py:docstring of aiida.orm.nodes.data.array.array.ArrayData.__init__:0
#: ../../../src/aiida/orm/nodes/data/array/array.py:docstring of aiida.orm.nodes.data.array.array.ArrayData._prepare_json:0
#: ../../../src/aiida/orm/nodes/data/array/array.py:docstring of aiida.orm.nodes.data.array.array.ArrayData.delete_array:0
#: ../../../src/aiida/orm/nodes/data/array/array.py:docstring of aiida.orm.nodes.data.array.array.ArrayData.get_array:0
#: ../../../src/aiida/orm/nodes/data/array/array.py:docstring of aiida.orm.nodes.data.array.array.ArrayData.get_shape:0
#: ../../../src/aiida/orm/nodes/data/array/array.py:docstring of aiida.orm.nodes.data.array.array.ArrayData.set_array:0
#: ../../../src/aiida/orm/nodes/data/array/array.py:docstring of aiida.orm.nodes.data.array.array.clean_array:0
#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData._get_bandplot_data:0
#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData._get_mpl_body_template:0
#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData._matplotlib_get_dict:0
#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData._prepare_agr:0
#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData._prepare_agr_batch:0
#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData._prepare_dat_blocks:0
#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData._prepare_dat_multicolumn:0
#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData._prepare_gnuplot:0
#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData._prepare_json:0
#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands._extract_formula:0
#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.find_bandgap:0
#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.orm.nodes.data.array.kpoints.KpointsData.get_kpoints:0
#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.orm.nodes.data.array.kpoints.KpointsData.get_kpoints_mesh:0
#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.orm.nodes.data.array.kpoints.KpointsData.set_cell:0
#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.orm.nodes.data.array.kpoints.KpointsData.set_cell_from_structure:0
#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.orm.nodes.data.array.kpoints.KpointsData.set_kpoints:0
#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.orm.nodes.data.array.kpoints.KpointsData.set_kpoints_mesh:0
#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.orm.nodes.data.array.kpoints.KpointsData.set_kpoints_mesh_from_density:0
#: ../../../src/aiida/orm/nodes/data/array/projection.py:docstring of aiida.orm.nodes.data.array.projection.ProjectionData._check_projections_bands:0
#: ../../../src/aiida/orm/nodes/data/array/projection.py:docstring of aiida.orm.nodes.data.array.projection.ProjectionData._find_orbitals_and_indices:0
#: ../../../src/aiida/orm/nodes/data/array/projection.py:docstring of aiida.orm.nodes.data.array.projection.ProjectionData.get_pdos:0
#: ../../../src/aiida/orm/nodes/data/array/projection.py:docstring of aiida.orm.nodes.data.array.projection.ProjectionData.get_projections:0
#: ../../../src/aiida/orm/nodes/data/array/projection.py:docstring of aiida.orm.nodes.data.array.projection.ProjectionData.set_projectiondata:0
#: ../../../src/aiida/orm/nodes/data/array/projection.py:docstring of aiida.orm.nodes.data.array.projection.ProjectionData.set_reference_bandsdata:0
#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.__init__:0
#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.get_step_data:0
#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.get_step_structure:0
#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.get_structure:0
#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.set_structurelist:0
#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.set_trajectory:0
#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.show_mpl_pos:0
#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.plot_positions_XYZ:0
#: ../../../src/aiida/orm/nodes/data/array/xy.py:docstring of aiida.orm.nodes.data.array.xy.XyData.__init__:0
#: ../../../src/aiida/orm/nodes/data/array/xy.py:docstring of aiida.orm.nodes.data.array.xy.XyData.set_x:0
#: ../../../src/aiida/orm/nodes/data/array/xy.py:docstring of aiida.orm.nodes.data.array.xy.check_convert_single_to_tuple:0
#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.__init__:0
#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.get_or_create:0
#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.get_structure:0
#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.parse:0
#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.set_ase:0
#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.set_file:0
#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.set_parse_policy:0
#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.set_scan_type:0
#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.set_values:0
#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.cif_from_ase:0
#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.pycifrw_from_cif:0
#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.__init__:0
#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.can_run_on_computer:0
#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.get_executable_cmdline_params:0
#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.get_prepend_cmdline_params:0
#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.validate_working_directory:0
#: ../../../src/aiida/orm/nodes/data/code/containerized.py:docstring of aiida.orm.nodes.data.code.containerized.ContainerizedCode.__init__:0
#: ../../../src/aiida/orm/nodes/data/code/installed.py:docstring of aiida.orm.nodes.data.code.installed.InstalledCode.__init__:0
#: ../../../src/aiida/orm/nodes/data/code/installed.py:docstring of aiida.orm.nodes.data.code.installed.InstalledCode.can_run_on_computer:0
#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.__init__:0
#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.can_run_on_computer:0
#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.get:0
#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.get_code_helper:0
#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.get_from_string:0
#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.list_for_plugin:0
#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.relabel:0
#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.set_remote_computer_exec:0
#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.set_use_double_quotes:0
#: ../../../src/aiida/orm/nodes/data/code/portable.py:docstring of aiida.orm.nodes.data.code.portable.PortableCode.__init__:0
#: ../../../src/aiida/orm/nodes/data/code/portable.py:docstring of aiida.orm.nodes.data.code.portable.PortableCode.can_run_on_computer:0
#: ../../../src/aiida/orm/nodes/data/code/portable.py:docstring of aiida.orm.nodes.data.code.portable.PortableCode.validate_working_directory:0
#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.orm.nodes.data.data.Data._exportcontent:0
#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.orm.nodes.data.data.Data.convert:0
#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.orm.nodes.data.data.Data.export:0
#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.orm.nodes.data.data.Data.importfile:0
#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.orm.nodes.data.data.Data.importstring:0
#: ../../../src/aiida/orm/nodes/data/dict.py:docstring of aiida.orm.nodes.data.dict.Dict.__init__:0
#: ../../../src/aiida/orm/nodes/data/dict.py:docstring of aiida.orm.nodes.data.dict.Dict.get:0
#: ../../../src/aiida/orm/nodes/data/dict.py:docstring of aiida.orm.nodes.data.dict.Dict.set_dict:0
#: ../../../src/aiida/orm/nodes/data/dict.py:docstring of aiida.orm.nodes.data.dict.Dict.update_dict:0
#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.__init__:0
#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.as_path:0
#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.copy_tree:0
#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.delete_object:0
#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.get_object:0
#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.get_object_content:0
#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.list_object_names:0
#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.list_objects:0
#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.open:0
#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.put_object_from_bytes:0
#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.put_object_from_file:0
#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.put_object_from_filelike:0
#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.put_object_from_tree:0
#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.walk:0
#: ../../../src/aiida/orm/nodes/data/list.py:docstring of aiida.orm.nodes.data.list.List.__init__:0
#: ../../../src/aiida/orm/nodes/data/list.py:docstring of aiida.orm.nodes.data.list.List.set_list:0
#: ../../../src/aiida/orm/nodes/data/orbital.py:docstring of aiida.orm.nodes.data.orbital.OrbitalData.get_orbitals:0
#: ../../../src/aiida/orm/nodes/data/orbital.py:docstring of aiida.orm.nodes.data.orbital.OrbitalData.set_orbitals:0
#: ../../../src/aiida/orm/nodes/data/remote/base.py:docstring of aiida.orm.nodes.data.remote.base.RemoteData._clean:0
#: ../../../src/aiida/orm/nodes/data/remote/base.py:docstring of aiida.orm.nodes.data.remote.base.RemoteData.getfile:0
#: ../../../src/aiida/orm/nodes/data/remote/base.py:docstring of aiida.orm.nodes.data.remote.base.RemoteData.listdir:0
#: ../../../src/aiida/orm/nodes/data/remote/base.py:docstring of aiida.orm.nodes.data.remote.base.RemoteData.listdir_withattributes:0
#: ../../../src/aiida/orm/nodes/data/remote/stash/base.py:docstring of aiida.orm.nodes.data.remote.stash.base.RemoteStashData.__init__:0
#: ../../../src/aiida/orm/nodes/data/remote/stash/folder.py:docstring of aiida.orm.nodes.data.remote.stash.folder.RemoteStashFolderData.__init__:0
#: ../../../src/aiida/orm/nodes/data/singlefile.py:docstring of aiida.orm.nodes.data.singlefile.SinglefileData.__init__:0
#: ../../../src/aiida/orm/nodes/data/singlefile.py:docstring of aiida.orm.nodes.data.singlefile.SinglefileData.as_path:0
#: ../../../src/aiida/orm/nodes/data/singlefile.py:docstring of aiida.orm.nodes.data.singlefile.SinglefileData.from_string:0
#: ../../../src/aiida/orm/nodes/data/singlefile.py:docstring of aiida.orm.nodes.data.singlefile.SinglefileData.get_content:0
#: ../../../src/aiida/orm/nodes/data/singlefile.py:docstring of aiida.orm.nodes.data.singlefile.SinglefileData.open:0
#: ../../../src/aiida/orm/nodes/data/singlefile.py:docstring of aiida.orm.nodes.data.singlefile.SinglefileData.set_file:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.Kind.__init__:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.Site.__init__:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.Site.get_ase:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.append_atom:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.append_kind:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.append_site:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_cif:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_composition:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_description:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_formula:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_kind:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.reset_cell:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.reset_sites_positions:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.set_pymatgen_molecule:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.ase_refine_cell:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.calc_cell_volume:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.get_formula:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.get_formula_group:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.get_symbols_string:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.is_ase_atoms:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.symop_fract_from_ortho:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.symop_ortho_from_fract:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.validate_symbols_tuple:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.validate_weights_tuple:0
#: ../../../src/aiida/orm/nodes/data/upf.py:docstring of aiida.orm.nodes.data.upf.UpfData.__init__:0
#: ../../../src/aiida/orm/nodes/data/upf.py:docstring of aiida.orm.nodes.data.upf.UpfData.from_md5:0
#: ../../../src/aiida/orm/nodes/data/upf.py:docstring of aiida.orm.nodes.data.upf.UpfData.get_or_create:0
#: ../../../src/aiida/orm/nodes/data/upf.py:docstring of aiida.orm.nodes.data.upf.UpfData.get_upf_group:0
#: ../../../src/aiida/orm/nodes/data/upf.py:docstring of aiida.orm.nodes.data.upf.UpfData.get_upf_groups:0
#: ../../../src/aiida/orm/nodes/data/upf.py:docstring of aiida.orm.nodes.data.upf.UpfData.set_file:0
#: ../../../src/aiida/orm/nodes/data/upf.py:docstring of aiida.orm.nodes.data.upf.get_pseudos_from_structure:0
#: ../../../src/aiida/orm/nodes/data/upf.py:docstring of aiida.orm.nodes.data.upf.upload_upf_family:0
#: ../../../src/aiida/orm/nodes/links.py:docstring of aiida.orm.nodes.links.NodeLinks._add_incoming_cache:0
#: ../../../src/aiida/orm/nodes/links.py:docstring of aiida.orm.nodes.links.NodeLinks.add_incoming:0
#: ../../../src/aiida/orm/nodes/links.py:docstring of aiida.orm.nodes.links.NodeLinks.get_incoming:0
#: ../../../src/aiida/orm/nodes/links.py:docstring of aiida.orm.nodes.links.NodeLinks.get_outgoing:0
#: ../../../src/aiida/orm/nodes/links.py:docstring of aiida.orm.nodes.links.NodeLinks.get_stored_link_triples:0
#: ../../../src/aiida/orm/nodes/links.py:docstring of aiida.orm.nodes.links.NodeLinks.validate_incoming:0
#: ../../../src/aiida/orm/nodes/links.py:docstring of aiida.orm.nodes.links.NodeLinks.validate_outgoing:0
#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node.__init__:0
#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node._check_mutability_attributes:0
#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node._store:0
#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.NodeCollection.delete:0
#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.NodeCollection.iter_repo_keys:0
#: ../../../src/aiida/orm/nodes/process/calculation/calcfunction.py:docstring of aiida.orm.nodes.process.calculation.calcfunction.CalcFunctionNodeLinks.validate_outgoing:0
#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode._validate_retrieval_directive:0
#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.get_option:0
#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.set_detailed_job_info:0
#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.set_job_id:0
#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.set_last_job_info:0
#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.set_option:0
#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.set_options:0
#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.set_remote_workdir:0
#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.set_retrieve_list:0
#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.set_retrieve_temporary_list:0
#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.set_scheduler_state:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.set_checkpoint:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.set_exception:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.set_exit_message:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.set_exit_status:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.set_process_label:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.set_process_state:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.set_process_status:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.set_process_type:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNodeLinks.validate_incoming:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNodeLinks.validate_outgoing:0
#: ../../../src/aiida/orm/nodes/process/workflow/workchain.py:docstring of aiida.orm.nodes.process.workflow.workchain.WorkChainNode.set_stepper_state_info:0
#: ../../../src/aiida/orm/nodes/process/workflow/workflow.py:docstring of aiida.orm.nodes.process.workflow.workflow.WorkflowNodeLinks.validate_outgoing:0
#: ../../../src/aiida/orm/nodes/process/workflow/workfunction.py:docstring of aiida.orm.nodes.process.workflow.workfunction.WorkFunctionNodeLinks.validate_outgoing:0
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository._clone:0
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository._copy:0
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.as_path:0
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.copy_tree:0
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.delete_object:0
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.get_object:0
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.get_object_content:0
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.list_object_names:0
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.list_objects:0
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.open:0
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.put_object_from_bytes:0
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.put_object_from_file:0
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.put_object_from_filelike:0
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.put_object_from_tree:0
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.walk:0
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.__init__:0
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder._add_group_type_filter:0
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder._add_node_type_filter:0
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder._add_process_type_filter:0
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder._get_aiida_entity_res:0
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder._get_unique_tag:0
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.add_filter:0
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.add_projection:0
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.all:0
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.append:0
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.dict:0
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.first:0
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.get_used_tags:0
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.iterall:0
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.iterdict:0
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.limit:0
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.offset:0
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.order_by:0
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.set_debug:0
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder._get_group_type_filter:0
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder._get_node_type_filter:0
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder._get_ormclass:0
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder._get_ormclass_from_cls:0
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder._get_ormclass_from_str:0
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder._get_process_type_filter:0
#: ../../../src/aiida/orm/users.py:docstring of aiida.orm.users.UserCollection.get_or_create:0
#: ../../../src/aiida/orm/utils/builders/code.py:docstring of aiida.orm.utils.builders.code.CodeBuilder._get:0
#: ../../../src/aiida/orm/utils/builders/code.py:docstring of aiida.orm.utils.builders.code.CodeBuilder._get_and_count:0
#: ../../../src/aiida/orm/utils/builders/computer.py:docstring of aiida.orm.utils.builders.computer.ComputerBuilder._get:0
#: ../../../src/aiida/orm/utils/builders/computer.py:docstring of aiida.orm.utils.builders.computer.ComputerBuilder._get_and_count:0
#: ../../../src/aiida/orm/utils/calcjob.py:docstring of aiida.orm.utils.calcjob.CalcJobResultManager.__getattr__:0
#: ../../../src/aiida/orm/utils/calcjob.py:docstring of aiida.orm.utils.calcjob.CalcJobResultManager.__getitem__:0
#: ../../../src/aiida/orm/utils/calcjob.py:docstring of aiida.orm.utils.calcjob.CalcJobResultManager.__init__:0
#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links.link_triple_exists:0
#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links.validate_link:0
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.CalculationEntityLoader._get_query_builder_label_identifier:0
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.CodeEntityLoader._get_query_builder_label_identifier:0
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.ComputerEntityLoader._get_query_builder_label_identifier:0
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.DataEntityLoader._get_query_builder_label_identifier:0
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.GroupEntityLoader._get_query_builder_label_identifier:0
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.NodeEntityLoader._get_query_builder_label_identifier:0
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader._get_query_builder_id_identifier:0
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader._get_query_builder_label_identifier:0
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader._get_query_builder_uuid_identifier:0
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader.get_options:0
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader.get_query_builder:0
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader.get_query_classes:0
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader.infer_identifier_type:0
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader.load_entity:0
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.ProcessEntityLoader._get_query_builder_label_identifier:0
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.WorkflowEntityLoader._get_query_builder_label_identifier:0
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.get_loader:0
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_code:0
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_computer:0
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_entity:0
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_group:0
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_node:0
#: ../../../src/aiida/orm/utils/log.py:docstring of aiida.orm.utils.log.create_logger_adapter:0
#: ../../../src/aiida/orm/utils/log.py:docstring of aiida.orm.utils.log.get_dblogger_extra:0
#: ../../../src/aiida/orm/utils/managers.py:docstring of aiida.orm.utils.managers.AttributeManager.__getattr__:0
#: ../../../src/aiida/orm/utils/managers.py:docstring of aiida.orm.utils.managers.AttributeManager.__getitem__:0
#: ../../../src/aiida/orm/utils/managers.py:docstring of aiida.orm.utils.managers.AttributeManager.__init__:0
#: ../../../src/aiida/orm/utils/managers.py:docstring of aiida.orm.utils.managers.NodeLinksManager.__getattr__:0
#: ../../../src/aiida/orm/utils/managers.py:docstring of aiida.orm.utils.managers.NodeLinksManager.__getitem__:0
#: ../../../src/aiida/orm/utils/managers.py:docstring of aiida.orm.utils.managers.NodeLinksManager.__init__:0
#: ../../../src/aiida/orm/utils/managers.py:docstring of aiida.orm.utils.managers.NodeLinksManager._construct_attribute_dict:0
#: ../../../src/aiida/orm/utils/managers.py:docstring of aiida.orm.utils.managers.NodeLinksManager._get_node_by_link_label:0
#: ../../../src/aiida/orm/utils/mixins.py:docstring of aiida.orm.utils.mixins.FunctionCalculationMixin._set_function_name:0
#: ../../../src/aiida/orm/utils/mixins.py:docstring of aiida.orm.utils.mixins.FunctionCalculationMixin._set_function_namespace:0
#: ../../../src/aiida/orm/utils/mixins.py:docstring of aiida.orm.utils.mixins.FunctionCalculationMixin._set_function_number_of_lines:0
#: ../../../src/aiida/orm/utils/mixins.py:docstring of aiida.orm.utils.mixins.FunctionCalculationMixin._set_function_starting_line_number:0
#: ../../../src/aiida/orm/utils/mixins.py:docstring of aiida.orm.utils.mixins.FunctionCalculationMixin.store_source_info:0
#: ../../../src/aiida/orm/utils/mixins.py:docstring of aiida.orm.utils.mixins.Sealable._check_mutability_attributes:0
#: ../../../src/aiida/orm/utils/node.py:docstring of aiida.orm.utils.node.get_query_type_from_type_string:0
#: ../../../src/aiida/orm/utils/node.py:docstring of aiida.orm.utils.node.get_type_string_from_class:0
#: ../../../src/aiida/orm/utils/node.py:docstring of aiida.orm.utils.node.is_valid_node_type_string:0
#: ../../../src/aiida/orm/utils/node.py:docstring of aiida.orm.utils.node.load_node_class:0
#: ../../../src/aiida/orm/utils/remote.py:docstring of aiida.orm.utils.remote.clean_remote:0
#: ../../../src/aiida/orm/utils/remote.py:docstring of aiida.orm.utils.remote.get_calcjob_remote_paths:0
#: ../../../src/aiida/orm/utils/serialize.py:docstring of aiida.orm.utils.serialize.deserialize_unsafe:0
#: ../../../src/aiida/orm/utils/serialize.py:docstring of aiida.orm.utils.serialize.serialize:0
#: ../../../src/aiida/parsers/parser.py:docstring of aiida.parsers.parser.Parser.__init__:0
#: ../../../src/aiida/parsers/parser.py:docstring of aiida.parsers.parser.Parser.out:0
#: ../../../src/aiida/parsers/parser.py:docstring of aiida.parsers.parser.Parser.parse:0
#: ../../../src/aiida/parsers/parser.py:docstring of aiida.parsers.parser.Parser.parse_from_node:0
#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.format_entry_point_string:0
#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.get_entry_point:0
#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.get_entry_point_from_class:0
#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.get_entry_point_from_string:0
#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.get_entry_point_string_format:0
#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.get_entry_point_string_from_class:0
#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.get_entry_points:0
#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.is_registered_entry_point:0
#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.is_valid_entry_point_string:0
#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.load_entry_point:0
#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.load_entry_point_from_string:0
#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.parse_entry_point_string:0
#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.BaseFactory:0
#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.CalcJobImporterFactory:0
#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.CalculationFactory:0
#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.DataFactory:0
#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.DbImporterFactory:0
#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.GroupFactory:0
#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.OrbitalFactory:0
#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.ParserFactory:0
#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.SchedulerFactory:0
#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.StorageFactory:0
#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.TransportFactory:0
#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.WorkflowFactory:0
#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.raise_invalid_type_error:0
#: ../../../src/aiida/plugins/utils.py:docstring of aiida.plugins.utils.PluginVersionProvider.get_version_info:0
#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.delete_object:0
#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.delete_objects:0
#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.get_info:0
#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.get_object_content:0
#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.get_object_hash:0
#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.has_object:0
#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.has_objects:0
#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.initialise:0
#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.iter_object_streams:0
#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.maintain:0
#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.open:0
#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.put_object_from_file:0
#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.put_object_from_filelike:0
#: ../../../src/aiida/repository/backend/disk_object_store.py:docstring of aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend._put_object_from_filelike:0
#: ../../../src/aiida/repository/backend/disk_object_store.py:docstring of aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend.delete_objects:0
#: ../../../src/aiida/repository/backend/disk_object_store.py:docstring of aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend.get_object_hash:0
#: ../../../src/aiida/repository/backend/disk_object_store.py:docstring of aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend.has_objects:0
#: ../../../src/aiida/repository/backend/disk_object_store.py:docstring of aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend.initialise:0
#: ../../../src/aiida/repository/backend/disk_object_store.py:docstring of aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend.iter_object_streams:0
#: ../../../src/aiida/repository/backend/disk_object_store.py:docstring of aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend.maintain:0
#: ../../../src/aiida/repository/backend/disk_object_store.py:docstring of aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend.open:0
#: ../../../src/aiida/repository/backend/sandbox.py:docstring of aiida.repository.backend.sandbox.SandboxRepositoryBackend.__init__:0
#: ../../../src/aiida/repository/backend/sandbox.py:docstring of aiida.repository.backend.sandbox.SandboxRepositoryBackend._put_object_from_filelike:0
#: ../../../src/aiida/repository/backend/sandbox.py:docstring of aiida.repository.backend.sandbox.SandboxRepositoryBackend.delete_objects:0
#: ../../../src/aiida/repository/backend/sandbox.py:docstring of aiida.repository.backend.sandbox.SandboxRepositoryBackend.get_info:0
#: ../../../src/aiida/repository/backend/sandbox.py:docstring of aiida.repository.backend.sandbox.SandboxRepositoryBackend.has_objects:0
#: ../../../src/aiida/repository/backend/sandbox.py:docstring of aiida.repository.backend.sandbox.SandboxRepositoryBackend.initialise:0
#: ../../../src/aiida/repository/backend/sandbox.py:docstring of aiida.repository.backend.sandbox.SandboxRepositoryBackend.iter_object_streams:0
#: ../../../src/aiida/repository/backend/sandbox.py:docstring of aiida.repository.backend.sandbox.SandboxRepositoryBackend.maintain:0
#: ../../../src/aiida/repository/backend/sandbox.py:docstring of aiida.repository.backend.sandbox.SandboxRepositoryBackend.open:0
#: ../../../src/aiida/repository/common.py:docstring of aiida.repository.common.File.__init__:0
#: ../../../src/aiida/repository/common.py:docstring of aiida.repository.common.File.from_serialized:0
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.__init__:0
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository._insert_file:0
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository._pre_process_path:0
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.copy_tree:0
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.create_directory:0
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.delete_object:0
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.flatten:0
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.from_serialized:0
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.get_directory:0
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.get_file:0
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.get_object:0
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.get_object_content:0
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.has_object:0
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.initialise:0
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.list_object_names:0
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.list_objects:0
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.open:0
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.put_object_from_file:0
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.put_object_from_filelike:0
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.put_object_from_tree:0
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.set_backend:0
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.walk:0
#: ../../../src/aiida/restapi/api.py:docstring of aiida.restapi.api.AiidaApi.__init__:0
#: ../../../src/aiida/restapi/common/identifiers.py:docstring of aiida.restapi.common.identifiers.Namespace.create_namespace:0
#: ../../../src/aiida/restapi/common/identifiers.py:docstring of aiida.restapi.common.identifiers.construct_full_type:0
#: ../../../src/aiida/restapi/common/identifiers.py:docstring of aiida.restapi.common.identifiers.get_full_type_filters:0
#: ../../../src/aiida/restapi/common/identifiers.py:docstring of aiida.restapi.common.identifiers.load_entry_point_from_full_type:0
#: ../../../src/aiida/restapi/common/identifiers.py:docstring of aiida.restapi.common.identifiers.validate_full_type:0
#: ../../../src/aiida/restapi/common/utils.py:docstring of aiida.restapi.common.utils.CustomJSONProvider.default:0
#: ../../../src/aiida/restapi/common/utils.py:docstring of aiida.restapi.common.utils.Utils.build_headers:0
#: ../../../src/aiida/restapi/common/utils.py:docstring of aiida.restapi.common.utils.Utils.build_response:0
#: ../../../src/aiida/restapi/common/utils.py:docstring of aiida.restapi.common.utils.Utils.build_translator_parameters:0
#: ../../../src/aiida/restapi/common/utils.py:docstring of aiida.restapi.common.utils.Utils.parse_path:0
#: ../../../src/aiida/restapi/common/utils.py:docstring of aiida.restapi.common.utils.Utils.split_path:0
#: ../../../src/aiida/restapi/common/utils.py:docstring of aiida.restapi.common.utils.Utils.strip_api_prefix:0
#: ../../../src/aiida/restapi/resources.py:docstring of aiida.restapi.resources.CalcJobNode.get:0
#: ../../../src/aiida/restapi/resources.py:docstring of aiida.restapi.resources.Node.get:0
#: ../../../src/aiida/restapi/resources.py:docstring of aiida.restapi.resources.ProcessNode.get:0
#: ../../../src/aiida/restapi/run_api.py:docstring of aiida.restapi.run_api.configure_api:0
#: ../../../src/aiida/restapi/run_api.py:docstring of aiida.restapi.run_api.run_api:0
#: ../../../src/aiida/restapi/translator/base.py:docstring of aiida.restapi.translator.base.BaseTranslator._check_id_validity:0
#: ../../../src/aiida/restapi/translator/base.py:docstring of aiida.restapi.translator.base.BaseTranslator.get_formatted_result:0
#: ../../../src/aiida/restapi/translator/base.py:docstring of aiida.restapi.translator.base.BaseTranslator.set_filters:0
#: ../../../src/aiida/restapi/translator/base.py:docstring of aiida.restapi.translator.base.BaseTranslator.set_limit_offset:0
#: ../../../src/aiida/restapi/translator/base.py:docstring of aiida.restapi.translator.base.BaseTranslator.set_projections:0
#: ../../../src/aiida/restapi/translator/base.py:docstring of aiida.restapi.translator.base.BaseTranslator.set_query:0
#: ../../../src/aiida/restapi/translator/nodes/data/__init__.py:docstring of aiida.restapi.translator.nodes.data.DataTranslator.get_downloadable_data:0
#: ../../../src/aiida/restapi/translator/nodes/data/cif.py:docstring of aiida.restapi.translator.nodes.data.cif.CifDataTranslator.get_derived_properties:0
#: ../../../src/aiida/restapi/translator/nodes/data/code.py:docstring of aiida.restapi.translator.nodes.data.code.CodeTranslator.get_derived_properties:0
#: ../../../src/aiida/restapi/translator/nodes/data/upf.py:docstring of aiida.restapi.translator.nodes.data.upf.UpfDataTranslator.get_derived_properties:0
#: ../../../src/aiida/restapi/translator/nodes/node.py:docstring of aiida.restapi.translator.nodes.node.NodeTranslator._get_subclasses:0
#: ../../../src/aiida/restapi/translator/nodes/node.py:docstring of aiida.restapi.translator.nodes.node.NodeTranslator.get_comments:0
#: ../../../src/aiida/restapi/translator/nodes/node.py:docstring of aiida.restapi.translator.nodes.node.NodeTranslator.get_derived_properties:0
#: ../../../src/aiida/restapi/translator/nodes/node.py:docstring of aiida.restapi.translator.nodes.node.NodeTranslator.get_downloadable_data:0
#: ../../../src/aiida/restapi/translator/nodes/node.py:docstring of aiida.restapi.translator.nodes.node.NodeTranslator.get_file_content:0
#: ../../../src/aiida/restapi/translator/nodes/node.py:docstring of aiida.restapi.translator.nodes.node.NodeTranslator.get_formatted_result:0
#: ../../../src/aiida/restapi/translator/nodes/node.py:docstring of aiida.restapi.translator.nodes.node.NodeTranslator.set_query:0
#: ../../../src/aiida/restapi/translator/nodes/process/calculation/calcfunction.py:docstring of aiida.restapi.translator.nodes.process.calculation.calcfunction.CalcFunctionTranslator.get_derived_properties:0
#: ../../../src/aiida/restapi/translator/nodes/process/calculation/calcjob.py:docstring of aiida.restapi.translator.nodes.process.calculation.calcjob.CalcJobTranslator.get_derived_properties:0
#: ../../../src/aiida/restapi/translator/nodes/process/workflow/workchain.py:docstring of aiida.restapi.translator.nodes.process.workflow.workchain.WorkChainTranslator.get_derived_properties:0
#: ../../../src/aiida/restapi/translator/nodes/process/workflow/workfunction.py:docstring of aiida.restapi.translator.nodes.process.workflow.workfunction.WorkFunctionTranslator.get_derived_properties:0
#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobInfo.load_from_dict:0
#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobInfo.load_from_serialized:0
#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobInfo.serialize_field:0
#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobResource.validate_resources:0
#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobTemplateCodeInfo:0
#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.NodeNumberJobResource.validate_resources:0
#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.ParEnvJobResource.validate_resources:0
#: ../../../src/aiida/schedulers/plugins/direct.py:docstring of aiida.schedulers.plugins.direct.DirectScheduler._get_submit_command:0
#: ../../../src/aiida/schedulers/plugins/lsf.py:docstring of aiida.schedulers.plugins.lsf.LsfJobResource.validate_resources:0
#: ../../../src/aiida/schedulers/plugins/lsf.py:docstring of aiida.schedulers.plugins.lsf.LsfScheduler._get_submit_command:0
#: ../../../src/aiida/schedulers/plugins/lsf.py:docstring of aiida.schedulers.plugins.lsf.LsfScheduler._get_submit_script_footer:0
#: ../../../src/aiida/schedulers/plugins/lsf.py:docstring of aiida.schedulers.plugins.lsf.LsfScheduler._get_submit_script_header:0
#: ../../../src/aiida/schedulers/plugins/pbsbaseclasses.py:docstring of aiida.schedulers.plugins.pbsbaseclasses.PbsJobResource.validate_resources:0
#: ../../../src/aiida/schedulers/plugins/slurm.py:docstring of aiida.schedulers.plugins.slurm.SlurmJobResource.validate_resources:0
#: ../../../src/aiida/schedulers/plugins/slurm.py:docstring of aiida.schedulers.plugins.slurm.SlurmScheduler.parse_output:0
#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler._get_joblist_command:0
#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler._get_run_line:0
#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler._get_submit_command:0
#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler._get_submit_script_environment_variables:0
#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler._get_submit_script_footer:0
#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler._get_submit_script_header:0
#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler.get_detailed_job_info:0
#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler.get_jobs:0
#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler.get_submit_script:0
#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler.kill:0
#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler.parse_output:0
#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler.validate_resources:0
#: ../../../src/aiida/storage/psql_dos/alembic_cli.py:docstring of aiida.storage.psql_dos.alembic_cli.AlembicRunner.execute_alembic_command:0
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend._get_mapper_from_entity:0
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.bulk_insert:0
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.bulk_update:0
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.delete:0
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.delete_nodes_and_connections:0
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.get_backend_entity:0
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.get_global_variable:0
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.get_info:0
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.get_unreferenced_keyset:0
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.initialise:0
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.maintain:0
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.set_global_variable:0
#: ../../../src/aiida/storage/psql_dos/migrations/utils/create_dbattribute.py:docstring of aiida.storage.psql_dos.migrations.utils.create_dbattribute.create_rows:0
#: ../../../src/aiida/storage/psql_dos/migrations/utils/integrity.py:docstring of aiida.storage.psql_dos.migrations.utils.integrity.drop_hashes:0
#: ../../../src/aiida/storage/psql_dos/migrations/utils/integrity.py:docstring of aiida.storage.psql_dos.migrations.utils.integrity.infer_calculation_entry_point:0
#: ../../../src/aiida/storage/psql_dos/migrations/utils/integrity.py:docstring of aiida.storage.psql_dos.migrations.utils.integrity.write_database_integrity_violation:0
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.LazyFile.__init__:0
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.NoopRepositoryBackend.delete_objects:0
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.NoopRepositoryBackend.get_info:0
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.NoopRepositoryBackend.has_objects:0
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.NoopRepositoryBackend.initialise:0
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.NoopRepositoryBackend.iter_object_streams:0
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.NoopRepositoryBackend.maintain:0
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.delete_numpy_array_from_repository:0
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.ensure_repository_folder_created:0
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.get_node_repository_dirpaths:0
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.get_node_repository_sub_folder:0
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.get_numpy_array_absolute_path:0
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.load_numpy_array_from_repository:0
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.put_object_from_string:0
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.recursive_datetime_to_isoformat:0
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.store_numpy_array_in_repository:0
#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator.delete_all_tables:0
#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator.initialise:0
#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator.migrate_down:0
#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator.migrate_up:0
#: ../../../src/aiida/storage/psql_dos/models/node.py:docstring of aiida.storage.psql_dos.models.node.DbNode.get_simple_name:0
#: ../../../src/aiida/storage/psql_dos/orm/authinfos.py:docstring of aiida.storage.psql_dos.orm.authinfos.SqlaAuthInfo.__init__:0
#: ../../../src/aiida/storage/psql_dos/orm/authinfos.py:docstring of aiida.storage.psql_dos.orm.authinfos.SqlaAuthInfo.set_auth_params:0
#: ../../../src/aiida/storage/psql_dos/orm/authinfos.py:docstring of aiida.storage.psql_dos.orm.authinfos.SqlaAuthInfo.set_metadata:0
#: ../../../src/aiida/storage/psql_dos/orm/authinfos.py:docstring of aiida.storage.psql_dos.orm.authinfos.SqlaAuthInfoCollection.delete:0
#: ../../../src/aiida/storage/psql_dos/orm/comments.py:docstring of aiida.storage.psql_dos.orm.comments.SqlaComment.__init__:0
#: ../../../src/aiida/storage/psql_dos/orm/comments.py:docstring of aiida.storage.psql_dos.orm.comments.SqlaCommentCollection.create:0
#: ../../../src/aiida/storage/psql_dos/orm/comments.py:docstring of aiida.storage.psql_dos.orm.comments.SqlaCommentCollection.delete:0
#: ../../../src/aiida/storage/psql_dos/orm/comments.py:docstring of aiida.storage.psql_dos.orm.comments.SqlaCommentCollection.delete_many:0
#: ../../../src/aiida/storage/psql_dos/orm/computers.py:docstring of aiida.storage.psql_dos.orm.computers.SqlaComputerCollection.delete:0
#: ../../../src/aiida/storage/psql_dos/orm/entities.py:docstring of aiida.storage.psql_dos.orm.entities.SqlaModelEntity.from_dbmodel:0
#: ../../../src/aiida/storage/psql_dos/orm/groups.py:docstring of aiida.storage.psql_dos.orm.groups.SqlaGroup.__init__:0
#: ../../../src/aiida/storage/psql_dos/orm/groups.py:docstring of aiida.storage.psql_dos.orm.groups.SqlaGroup.add_nodes:0
#: ../../../src/aiida/storage/psql_dos/orm/groups.py:docstring of aiida.storage.psql_dos.orm.groups.SqlaGroup.remove_nodes:0
#: ../../../src/aiida/storage/psql_dos/orm/groups.py:docstring of aiida.storage.psql_dos.orm.groups.SqlaGroupCollection.delete:0
#: ../../../src/aiida/storage/psql_dos/orm/logs.py:docstring of aiida.storage.psql_dos.orm.logs.SqlaLogCollection.delete:0
#: ../../../src/aiida/storage/psql_dos/orm/logs.py:docstring of aiida.storage.psql_dos.orm.logs.SqlaLogCollection.delete_many:0
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.__init__:0
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.add_incoming:0
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.delete_attribute:0
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.delete_attribute_many:0
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.get_attribute:0
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.reset_attributes:0
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.set_attribute:0
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.set_attribute_many:0
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNodeCollection.delete:0
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNodeCollection.get:0
#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.SqlaJoiner._join_authinfo_user:0
#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.SqlaJoiner._join_comment_node:0
#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.SqlaJoiner._join_comment_user:0
#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.SqlaJoiner._join_computer_authinfo:0
#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.SqlaJoiner._join_computer_node:0
#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.SqlaJoiner._join_group_node:0
#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.SqlaJoiner._join_group_user:0
#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.SqlaJoiner._join_log_node:0
#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.SqlaJoiner._join_node_comment:0
#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.SqlaJoiner._join_node_computer:0
#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.SqlaJoiner._join_node_group:0
#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.SqlaJoiner._join_node_inputs:0
#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.SqlaJoiner._join_node_log:0
#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.SqlaJoiner._join_node_outputs:0
#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.SqlaJoiner._join_node_user:0
#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.SqlaJoiner._join_user_authinfo:0
#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.SqlaJoiner._join_user_comment:0
#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.SqlaJoiner._join_user_group:0
#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.SqlaJoiner._join_user_node:0
#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner._check_dbentities:0
#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder.__init__:0
#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder.build_filters:0
#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder.get_creation_statistics:0
#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder.get_filter_expr:0
#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder.get_filter_expr_from_column:0
#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder.to_backend:0
#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main._create_projections:0
#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main._get_projection:0
#: ../../../src/aiida/storage/psql_dos/orm/utils.py:docstring of aiida.storage.psql_dos.orm.utils.ModelWrapper.__getattr__:0
#: ../../../src/aiida/storage/psql_dos/orm/utils.py:docstring of aiida.storage.psql_dos.orm.utils.ModelWrapper.__init__:0
#: ../../../src/aiida/storage/psql_dos/orm/utils.py:docstring of aiida.storage.psql_dos.orm.utils.ModelWrapper.__setattr__:0
#: ../../../src/aiida/storage/psql_dos/orm/utils.py:docstring of aiida.storage.psql_dos.orm.utils.ModelWrapper._ensure_model_uptodate:0
#: ../../../src/aiida/storage/psql_dos/orm/utils.py:docstring of aiida.storage.psql_dos.orm.utils.ModelWrapper._flush:0
#: ../../../src/aiida/storage/psql_dos/orm/utils.py:docstring of aiida.storage.psql_dos.orm.utils.disable_expire_on_commit:0
#: ../../../src/aiida/storage/psql_dos/utils.py:docstring of aiida.storage.psql_dos.utils.create_sqlalchemy_engine:0
#: ../../../src/aiida/storage/sqlite_dos/backend.py:docstring of aiida.storage.sqlite_dos.backend.SqliteDosStorage.initialise:0
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SandboxShaRepositoryBackend._put_object_from_filelike:0
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SandboxShaRepositoryBackend.get_info:0
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SandboxShaRepositoryBackend.get_object_hash:0
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SandboxShaRepositoryBackend.maintain:0
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend._get_mapper_from_entity:0
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.bulk_insert:0
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.bulk_update:0
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.delete_nodes_and_connections:0
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.get_global_variable:0
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.get_info:0
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.initialise:0
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.maintain:0
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.set_global_variable:0
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.FolderBackendRepository.has_object:0
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.FolderBackendRepository.open:0
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.bulk_insert:0
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.bulk_update:0
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.delete_nodes_and_connections:0
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.get_global_variable:0
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.get_info:0
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.initialise:0
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.maintain:0
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.set_global_variable:0
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.ZipfileBackendRepository.__init__:0
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.ZipfileBackendRepository.has_object:0
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.ZipfileBackendRepository.open:0
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend._RoBackendRepository.__init__:0
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend._RoBackendRepository.delete_objects:0
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend._RoBackendRepository.get_info:0
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend._RoBackendRepository.get_object_hash:0
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend._RoBackendRepository.has_objects:0
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend._RoBackendRepository.initialise:0
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend._RoBackendRepository.iter_object_streams:0
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend._RoBackendRepository.maintain:0
#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v04_to_v05.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v04_to_v05.remove_fields:0
#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy_to_main.py:docstring of aiida.storage.sqlite_zip.migrations.legacy_to_main._create_directory:0
#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy_to_main.py:docstring of aiida.storage.sqlite_zip.migrations.legacy_to_main._create_repo_metadata:0
#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy_to_main.py:docstring of aiida.storage.sqlite_zip.migrations.legacy_to_main.perform_v1_migration:0
#: ../../../src/aiida/storage/sqlite_zip/migrations/utils.py:docstring of aiida.storage.sqlite_zip.migrations.utils.copy_tar_to_zip:0
#: ../../../src/aiida/storage/sqlite_zip/migrations/utils.py:docstring of aiida.storage.sqlite_zip.migrations.utils.copy_zip_to_zip:0
#: ../../../src/aiida/storage/sqlite_zip/migrations/utils.py:docstring of aiida.storage.sqlite_zip.migrations.utils.update_metadata:0
#: ../../../src/aiida/storage/sqlite_zip/migrations/utils.py:docstring of aiida.storage.sqlite_zip.migrations.utils.verify_metadata_version:0
#: ../../../src/aiida/storage/sqlite_zip/migrator.py:docstring of aiida.storage.sqlite_zip.migrator._perform_legacy_migrations:0
#: ../../../src/aiida/storage/sqlite_zip/migrator.py:docstring of aiida.storage.sqlite_zip.migrator.migrate:0
#: ../../../src/aiida/storage/sqlite_zip/orm.py:docstring of aiida.storage.sqlite_zip.orm.SqliteEntityOverride.from_dbmodel:0
#: ../../../src/aiida/storage/sqlite_zip/orm.py:docstring of aiida.storage.sqlite_zip.orm.SqliteQueryBuilder.get_filter_expr_from_column:0
#: ../../../src/aiida/storage/sqlite_zip/utils.py:docstring of aiida.storage.sqlite_zip.utils.extract_metadata:0
#: ../../../src/aiida/storage/sqlite_zip/utils.py:docstring of aiida.storage.sqlite_zip.utils.read_version:0
#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveFormatAbstract.migrate:0
#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveFormatAbstract.open:0
#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveFormatAbstract.read_version:0
#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveReaderAbstract.__init__:0
#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveReaderAbstract.get:0
#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveWriterAbstract.__init__:0
#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveWriterAbstract.bulk_insert:0
#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveWriterAbstract.delete_object:0
#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveWriterAbstract.put_object:0
#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.get_format:0
#: ../../../src/aiida/tools/archive/common.py:docstring of aiida.tools.archive.common.batch_iter:0
#: ../../../src/aiida/tools/archive/create.py:docstring of aiida.tools.archive.create.create_archive:0
#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/main.py:docstring of aiida.tools.archive.implementations.sqlite_zip.main.ArchiveFormatSqlZip.migrate:0
#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/main.py:docstring of aiida.tools.archive.implementations.sqlite_zip.main.ArchiveFormatSqlZip.open:0
#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/main.py:docstring of aiida.tools.archive.implementations.sqlite_zip.main.ArchiveFormatSqlZip.read_version:0
#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/reader.py:docstring of aiida.tools.archive.implementations.sqlite_zip.reader.ArchiveReaderSqlZip.__init__:0
#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/writer.py:docstring of aiida.tools.archive.implementations.sqlite_zip.writer.ArchiveAppenderSqlZip.delete_object:0
#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/writer.py:docstring of aiida.tools.archive.implementations.sqlite_zip.writer.ArchiveWriterSqlZip.__init__:0
#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/writer.py:docstring of aiida.tools.archive.implementations.sqlite_zip.writer.ArchiveWriterSqlZip._stream_binary:0
#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/writer.py:docstring of aiida.tools.archive.implementations.sqlite_zip.writer.ArchiveWriterSqlZip.bulk_insert:0
#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/writer.py:docstring of aiida.tools.archive.implementations.sqlite_zip.writer.ArchiveWriterSqlZip.delete_object:0
#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/writer.py:docstring of aiida.tools.archive.implementations.sqlite_zip.writer.ArchiveWriterSqlZip.put_object:0
#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports._make_import_group:0
#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports._merge_node_extras:0
#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports.import_archive:0
#: ../../../src/aiida/tools/data/array/kpoints/legacy.py:docstring of aiida.tools.data.array.kpoints.legacy.change_reference:0
#: ../../../src/aiida/tools/data/array/kpoints/legacy.py:docstring of aiida.tools.data.array.kpoints.legacy.find_bravais_info:0
#: ../../../src/aiida/tools/data/array/kpoints/legacy.py:docstring of aiida.tools.data.array.kpoints.legacy.get_explicit_kpoints_path:0
#: ../../../src/aiida/tools/data/array/kpoints/legacy.py:docstring of aiida.tools.data.array.kpoints.legacy.get_kpoints_path:0
#: ../../../src/aiida/tools/data/array/kpoints/main.py:docstring of aiida.tools.data.array.kpoints.main._legacy_get_explicit_kpoints_path:0
#: ../../../src/aiida/tools/data/array/kpoints/main.py:docstring of aiida.tools.data.array.kpoints.main._legacy_get_kpoints_path:0
#: ../../../src/aiida/tools/data/array/kpoints/main.py:docstring of aiida.tools.data.array.kpoints.main._seekpath_get_explicit_kpoints_path:0
#: ../../../src/aiida/tools/data/array/kpoints/main.py:docstring of aiida.tools.data.array.kpoints.main._seekpath_get_kpoints_path:0
#: ../../../src/aiida/tools/data/array/kpoints/main.py:docstring of aiida.tools.data.array.kpoints.main.get_explicit_kpoints_path:0
#: ../../../src/aiida/tools/data/array/kpoints/main.py:docstring of aiida.tools.data.array.kpoints.main.get_kpoints_path:0
#: ../../../src/aiida/tools/data/array/kpoints/seekpath.py:docstring of aiida.tools.data.array.kpoints.seekpath.get_explicit_kpoints_path:0
#: ../../../src/aiida/tools/data/array/kpoints/seekpath.py:docstring of aiida.tools.data.array.kpoints.seekpath.get_kpoints_path:0
#: ../../../src/aiida/tools/data/array/trajectory.py:docstring of aiida.tools.data.array.trajectory._get_aiida_structure_inline:0
#: ../../../src/aiida/tools/data/cif.py:docstring of aiida.tools.data.cif._get_aiida_structure_pymatgen_inline:0
#: ../../../src/aiida/tools/data/cif.py:docstring of aiida.tools.data.cif.refine_inline:0
#: ../../../src/aiida/tools/data/cif.py:docstring of aiida.tools.data.cif.symop_string_from_symop_matrix_tr:0
#: ../../../src/aiida/tools/data/orbital/orbital.py:docstring of aiida.tools.data.orbital.orbital.Orbital:0
#: ../../../src/aiida/tools/data/orbital/orbital.py:docstring of aiida.tools.data.orbital.orbital.Orbital._validate_keys:0
#: ../../../src/aiida/tools/data/orbital/orbital.py:docstring of aiida.tools.data.orbital.orbital.Orbital.set_orbital_dict:0
#: ../../../src/aiida/tools/data/orbital/realhydrogen.py:docstring of aiida.tools.data.orbital.realhydrogen.RealhydrogenOrbital:0
#: ../../../src/aiida/tools/data/orbital/realhydrogen.py:docstring of aiida.tools.data.orbital.realhydrogen.RealhydrogenOrbital._validate_keys:0
#: ../../../src/aiida/tools/data/structure.py:docstring of aiida.tools.data.structure.spglib_tuple_to_structure:0
#: ../../../src/aiida/tools/data/structure.py:docstring of aiida.tools.data.structure.structure_to_spglib_tuple:0
#: ../../../src/aiida/tools/data/structure.py:docstring of aiida.tools.data.structure.xyz_parser_iterator:0
#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbEntry.__init__:0
#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbImporter.query:0
#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbSearchResults._get_source_dict:0
#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbSearchResults._get_url:0
#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbSearchResults.at:0
#: ../../../src/aiida/tools/dbimporters/plugins/cod.py:docstring of aiida.tools.dbimporters.plugins.cod.CodSearchResults._get_source_dict:0
#: ../../../src/aiida/tools/dbimporters/plugins/cod.py:docstring of aiida.tools.dbimporters.plugins.cod.CodSearchResults._get_url:0
#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.IcsdDbImporter:0
#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.IcsdDbImporter.query:0
#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.IcsdDbImporter.setup_db:0
#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.IcsdSearchResults:0
#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.correct_cif:0
#: ../../../src/aiida/tools/dbimporters/plugins/materialsproject.py:docstring of aiida.tools.dbimporters.plugins.materialsproject.MaterialsProjectImporter._find:0
#: ../../../src/aiida/tools/dbimporters/plugins/materialsproject.py:docstring of aiida.tools.dbimporters.plugins.materialsproject.MaterialsProjectImporter.query:0
#: ../../../src/aiida/tools/dbimporters/plugins/materialsproject.py:docstring of aiida.tools.dbimporters.plugins.materialsproject.MaterialsProjectSearchResults:0
#: ../../../src/aiida/tools/dbimporters/plugins/materialsproject.py:docstring of aiida.tools.dbimporters.plugins.materialsproject.MaterialsProjectSearchResults._get_source_dict:0
#: ../../../src/aiida/tools/dbimporters/plugins/materialsproject.py:docstring of aiida.tools.dbimporters.plugins.materialsproject.MaterialsProjectSearchResults._get_url:0
#: ../../../src/aiida/tools/dbimporters/plugins/mpds.py:docstring of aiida.tools.dbimporters.plugins.mpds.MpdsDbImporter.__init__:0
#: ../../../src/aiida/tools/dbimporters/plugins/mpds.py:docstring of aiida.tools.dbimporters.plugins.mpds.MpdsDbImporter.find:0
#: ../../../src/aiida/tools/dbimporters/plugins/mpds.py:docstring of aiida.tools.dbimporters.plugins.mpds.MpdsDbImporter.get:0
#: ../../../src/aiida/tools/dbimporters/plugins/mpds.py:docstring of aiida.tools.dbimporters.plugins.mpds.MpdsDbImporter.get_id_from_cif:0
#: ../../../src/aiida/tools/dbimporters/plugins/mpds.py:docstring of aiida.tools.dbimporters.plugins.mpds.MpdsDbImporter.get_response_content:0
#: ../../../src/aiida/tools/dbimporters/plugins/mpds.py:docstring of aiida.tools.dbimporters.plugins.mpds.MpdsDbImporter.query:0
#: ../../../src/aiida/tools/dbimporters/plugins/mpds.py:docstring of aiida.tools.dbimporters.plugins.mpds.MpdsDbImporter.setup_db:0
#: ../../../src/aiida/tools/dbimporters/plugins/mpds.py:docstring of aiida.tools.dbimporters.plugins.mpds.MpdsSearchResults._get_source_dict:0
#: ../../../src/aiida/tools/dbimporters/plugins/mpds.py:docstring of aiida.tools.dbimporters.plugins.mpds.MpdsSearchResults._get_url:0
#: ../../../src/aiida/tools/dbimporters/plugins/mpds.py:docstring of aiida.tools.dbimporters.plugins.mpds.StructuresCollection.find:0
#: ../../../src/aiida/tools/dbimporters/plugins/mpod.py:docstring of aiida.tools.dbimporters.plugins.mpod.MpodSearchResults._get_source_dict:0
#: ../../../src/aiida/tools/dbimporters/plugins/mpod.py:docstring of aiida.tools.dbimporters.plugins.mpod.MpodSearchResults._get_url:0
#: ../../../src/aiida/tools/dbimporters/plugins/nninc.py:docstring of aiida.tools.dbimporters.plugins.nninc.NnincSearchResults._get_source_dict:0
#: ../../../src/aiida/tools/dbimporters/plugins/nninc.py:docstring of aiida.tools.dbimporters.plugins.nninc.NnincSearchResults._get_url:0
#: ../../../src/aiida/tools/dbimporters/plugins/oqmd.py:docstring of aiida.tools.dbimporters.plugins.oqmd.OqmdSearchResults._get_source_dict:0
#: ../../../src/aiida/tools/dbimporters/plugins/oqmd.py:docstring of aiida.tools.dbimporters.plugins.oqmd.OqmdSearchResults._get_url:0
#: ../../../src/aiida/tools/dbimporters/plugins/pcod.py:docstring of aiida.tools.dbimporters.plugins.pcod.PcodSearchResults._get_url:0
#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.AbstractSetContainer._check_input_for_set:0
#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.AbstractSetContainer._check_self_and_other:0
#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.AbstractSetContainer.add_entities:0
#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.AbstractSetContainer.set_entities:0
#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.AiidaEntitySet.__init__:0
#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.AiidaEntitySet._check_input_for_set:0
#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.AiidaEntitySet._check_self_and_other:0
#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.Basket.__init__:0
#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.DirectedEdgeSet.__init__:0
#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.DirectedEdgeSet._check_input_for_set:0
#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.DirectedEdgeSet._check_self_and_other:0
#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.Operation.__init__:0
#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.Operation.run:0
#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.QueryRule.__init__:0
#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.QueryRule._init_run:0
#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.QueryRule._load_results:0
#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.QueryRule.run:0
#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.QueryRule.set_edge_keys:0
#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.ReplaceRule.__init__:0
#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.ReplaceRule.run:0
#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.RuleSaveWalkers.__init__:0
#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.RuleSaveWalkers.run:0
#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.RuleSequence.__init__:0
#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.RuleSequence.run:0
#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.RuleSetWalkers.__init__:0
#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.RuleSetWalkers.run:0
#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.UpdateRule.run:0
#: ../../../src/aiida/tools/graph/deletions.py:docstring of aiida.tools.graph.deletions.delete_group_nodes:0
#: ../../../src/aiida/tools/graph/deletions.py:docstring of aiida.tools.graph.deletions.delete_nodes:0
#: ../../../src/aiida/tools/graph/graph_traversers.py:docstring of aiida.tools.graph.graph_traversers.get_nodes_delete:0
#: ../../../src/aiida/tools/graph/graph_traversers.py:docstring of aiida.tools.graph.graph_traversers.get_nodes_export:0
#: ../../../src/aiida/tools/graph/graph_traversers.py:docstring of aiida.tools.graph.graph_traversers.traverse_graph:0
#: ../../../src/aiida/tools/graph/graph_traversers.py:docstring of aiida.tools.graph.graph_traversers.validate_traversal_rules:0
#: ../../../src/aiida/tools/groups/paths.py:docstring of aiida.tools.groups.paths.GroupPath.__init__:0
#: ../../../src/aiida/tools/groups/paths.py:docstring of aiida.tools.groups.paths.GroupPath.walk_nodes:0
#: ../../../src/aiida/tools/ipython/ipython_magics.py:docstring of aiida.tools.ipython.ipython_magics.register_ipython_extension:0
#: ../../../src/aiida/tools/query/calculation.py:docstring of aiida.tools.query.calculation.CalculationQueryBuilder.get_filters:0
#: ../../../src/aiida/tools/query/calculation.py:docstring of aiida.tools.query.calculation.CalculationQueryBuilder.get_query_set:0
#: ../../../src/aiida/tools/query/formatting.py:docstring of aiida.tools.query.formatting.format_process_state:0
#: ../../../src/aiida/tools/query/formatting.py:docstring of aiida.tools.query.formatting.format_relative_time:0
#: ../../../src/aiida/tools/query/formatting.py:docstring of aiida.tools.query.formatting.format_sealed:0
#: ../../../src/aiida/tools/query/formatting.py:docstring of aiida.tools.query.formatting.format_state:0
#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.__init__:0
#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph._load_node:0
#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.add_edge:0
#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.add_incoming:0
#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.add_node:0
#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.add_origin_to_targets:0
#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.add_origins_to_targets:0
#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.add_outgoing:0
#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.recurse_ancestors:0
#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.recurse_descendants:0
#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph._add_graphviz_edge:0
#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph._add_graphviz_node:0
#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.default_link_styles:0
#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.default_node_styles:0
#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.default_node_sublabels:0
#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.pstate_node_styles:0
#: ../../../src/aiida/transports/cli.py:docstring of aiida.transports.cli.interactive_default:0
#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.__init__:0
#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport._exec_command_internal:0
#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.chown:0
#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.copy:0
#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.copyfile:0
#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.copytree:0
#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.exec_command_wait_bytes:0
#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.get:0
#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.getfile:0
#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.gettree:0
#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.gotocomputer_command:0
#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.listdir:0
#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.makedirs:0
#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.mkdir:0
#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.put:0
#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.putfile:0
#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.puttree:0
#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.rename:0
#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.rmtree:0
#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.symlink:0
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.__init__:0
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport._exec_command_internal:0
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport._symlink:0
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.chmod:0
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.copy:0
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.copyfile:0
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.copytree:0
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.exec_command_wait_bytes:0
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.get:0
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.getfile:0
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.gettree:0
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.listdir:0
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.lstat:0
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.makedirs:0
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.mkdir:0
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.put:0
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.putfile:0
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.puttree:0
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.rename:0
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.rmtree:0
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.stat:0
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.symlink:0
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.parse_sshconfig:0
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.__init__:0
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport._exec_command_internal:0
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.chdir:0
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.chmod:0
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.chown:0
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.copy:0
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.copy_from_remote_to_remote:0
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.copyfile:0
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.copytree:0
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.exec_command_wait:0
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.exec_command_wait_bytes:0
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.get:0
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.get_attribute:0
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.get_mode:0
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.getfile:0
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.gettree:0
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.gotocomputer_command:0
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.isdir:0
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.isfile:0
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.listdir:0
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.listdir_withattributes:0
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.makedirs:0
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.mkdir:0
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.normalize:0
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.put:0
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.putfile:0
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.puttree:0
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.remove:0
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.rename:0
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.rmdir:0
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.rmtree:0
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.set_logger_extra:0
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.symlink:0
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.validate_positive_number:0
#: ../../../src/aiida/transports/util.py:docstring of aiida.transports.util._DetachedProxyCommand.__init__:0
#: ../../../src/aiida/transports/util.py:docstring of aiida.transports.util.copy_from_remote_to_remote:0
msgid "Parameters"
msgstr ""

#: ../../../src/aiida/__init__.py:docstring of aiida.get_file_header:7
msgid "string put in front of each line"
msgstr ""

#: ../../../src/aiida/__init__.py:docstring of aiida.get_strict_version:1
msgid "Return a distutils StrictVersion instance with the current distribution version"
msgstr ""

#: ../../../src/aiida/__init__.py:docstring of aiida.get_strict_version:3
msgid "StrictVersion instance with the current version"
msgstr ""

#: ../../../src/aiida/__init__.py:docstring of aiida.get_strict_version:0
#: ../../../src/aiida/cmdline/params/types/choice.py:docstring of aiida.cmdline.params.types.choice.LazyChoice._click_choice:0
#: ../../../src/aiida/engine/persistence.py:docstring of aiida.engine.persistence.AiiDAPersister.load_checkpoint:0
#: ../../../src/aiida/engine/processes/calcjobs/manager.py:docstring of aiida.engine.processes.calcjobs.manager.JobsList._get_jobs_with_scheduler:0
#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.get_provenance_inputs_iterator:0
#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.get_query_string_from_process_type_string:0
#: ../../../src/aiida/manage/configuration/__init__.py:docstring of aiida.manage.configuration.get_config:0
#: ../../../src/aiida/manage/configuration/__init__.py:docstring of aiida.manage.configuration.load_config:0
#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.profiles:0
#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.aiida_local_code_factory:0
#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.temp_dir:0
#: ../../../src/aiida/orm/nodes/data/array/array.py:docstring of aiida.orm.nodes.data.array.array.clean_array:0
#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.orm.nodes.data.data.Data._exportcontent:0
#: ../../../src/aiida/orm/nodes/data/list.py:docstring of aiida.orm.nodes.data.list.List._using_list_reference:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.is_excepted:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.is_failed:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.is_finished:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.is_finished_ok:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.is_killed:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.is_terminated:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.is_excepted:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.is_failed:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.is_finished:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.is_finished_ok:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.is_killed:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.is_terminated:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.is_excepted:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.is_failed:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.is_finished:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.is_finished_ok:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.is_killed:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.is_terminated:0
#: ../../../src/aiida/orm/utils/log.py:docstring of aiida.orm.utils.log.create_logger_adapter:0
#: ../../../src/aiida/restapi/run_api.py:docstring of aiida.restapi.run_api.configure_api:0
#: ../../../src/aiida/storage/psql_dos/orm/comments.py:docstring of aiida.storage.psql_dos.orm.comments.SqlaCommentCollection.delete_many:0
#: ../../../src/aiida/storage/psql_dos/orm/logs.py:docstring of aiida.storage.psql_dos.orm.logs.SqlaLogCollection.delete_many:0
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.chdir:0
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.get_safe_open_interval:0
msgid "Return type"
msgstr ""

#: ../../../src/aiida/__init__.py:docstring of aiida.get_strict_version:4
msgid ":class:`!distutils.version.StrictVersion`"
msgstr ""

#: ../../../src/aiida/__init__.py:docstring of aiida.get_version:1
msgid "Return the current AiiDA distribution version"
msgstr ""

#: ../../../src/aiida/__init__.py:docstring of aiida.get_version:3
msgid "the current version"
msgstr ""

#: ../../../src/aiida/__init__.py:docstring of aiida.load_ipython_extension:1
msgid "Load the AiiDA IPython extension, using ``%load_ext aiida``."
msgstr ""

#: ../../source/reference/apidoc/aiida.calculations.importers.rst:13
#: ../../source/reference/apidoc/aiida.calculations.rst:13
#: ../../source/reference/apidoc/aiida.cmdline.commands.rst:13
#: ../../source/reference/apidoc/aiida.cmdline.params.options.rst:13
#: ../../source/reference/apidoc/aiida.cmdline.params.rst:13
#: ../../source/reference/apidoc/aiida.cmdline.rst:13
#: ../../source/reference/apidoc/aiida.cmdline.utils.rst:13
#: ../../source/reference/apidoc/aiida.engine.processes.rst:13
#: ../../source/reference/apidoc/aiida.engine.rst:13
#: ../../source/reference/apidoc/aiida.manage.configuration.rst:13
#: ../../source/reference/apidoc/aiida.manage.external.rst:13
#: ../../source/reference/apidoc/aiida.manage.rst:13
#: ../../source/reference/apidoc/aiida.orm.nodes.data.remote.rst:13
#: ../../source/reference/apidoc/aiida.orm.nodes.data.rst:13
#: ../../source/reference/apidoc/aiida.orm.nodes.process.rst:13
#: ../../source/reference/apidoc/aiida.orm.nodes.rst:13
#: ../../source/reference/apidoc/aiida.orm.rst:13
#: ../../source/reference/apidoc/aiida.orm.utils.rst:13
#: ../../source/reference/apidoc/aiida.parsers.plugins.rst:13
#: ../../source/reference/apidoc/aiida.parsers.rst:13
#: ../../source/reference/apidoc/aiida.repository.rst:13
#: ../../source/reference/apidoc/aiida.restapi.rst:13
#: ../../source/reference/apidoc/aiida.restapi.translator.nodes.data.rst:13
#: ../../source/reference/apidoc/aiida.restapi.translator.nodes.process.rst:13
#: ../../source/reference/apidoc/aiida.restapi.translator.nodes.rst:13
#: ../../source/reference/apidoc/aiida.restapi.translator.rst:13
#: ../../source/reference/apidoc/aiida.rst:13
#: ../../source/reference/apidoc/aiida.schedulers.rst:13
#: ../../source/reference/apidoc/aiida.storage.psql_dos.migrations.rst:13
#: ../../source/reference/apidoc/aiida.storage.psql_dos.orm.rst:13
#: ../../source/reference/apidoc/aiida.storage.psql_dos.rst:13
#: ../../source/reference/apidoc/aiida.storage.rst:13
#: ../../source/reference/apidoc/aiida.storage.sqlite_zip.migrations.rst:13
#: ../../source/reference/apidoc/aiida.storage.sqlite_zip.rst:13
#: ../../source/reference/apidoc/aiida.tools.archive.implementations.rst:13
#: ../../source/reference/apidoc/aiida.tools.archive.rst:13
#: ../../source/reference/apidoc/aiida.tools.data.array.rst:13
#: ../../source/reference/apidoc/aiida.tools.data.rst:13
#: ../../source/reference/apidoc/aiida.tools.dbimporters.rst:13
#: ../../source/reference/apidoc/aiida.tools.rst:13
#: ../../source/reference/apidoc/aiida.transports.rst:13
#: ../../source/reference/apidoc/aiida.workflows.rst:13
msgid "Subpackages"
msgstr ""

#: ../../source/reference/apidoc/aiida.calculations.arithmetic.rst:13
#: ../../source/reference/apidoc/aiida.calculations.importers.arithmetic.rst:13
#: ../../source/reference/apidoc/aiida.calculations.monitors.rst:13
#: ../../source/reference/apidoc/aiida.calculations.rst:23
#: ../../source/reference/apidoc/aiida.cmdline.commands.cmd_data.rst:13
#: ../../source/reference/apidoc/aiida.cmdline.commands.rst:21
#: ../../source/reference/apidoc/aiida.cmdline.groups.rst:13
#: ../../source/reference/apidoc/aiida.cmdline.params.arguments.rst:13
#: ../../source/reference/apidoc/aiida.cmdline.params.options.commands.rst:13
#: ../../source/reference/apidoc/aiida.cmdline.params.options.rst:21
#: ../../source/reference/apidoc/aiida.cmdline.params.types.rst:13
#: ../../source/reference/apidoc/aiida.cmdline.utils.query.rst:13
#: ../../source/reference/apidoc/aiida.cmdline.utils.rst:21
#: ../../source/reference/apidoc/aiida.common.rst:13
#: ../../source/reference/apidoc/aiida.engine.daemon.rst:13
#: ../../source/reference/apidoc/aiida.engine.processes.calcjobs.rst:13
#: ../../source/reference/apidoc/aiida.engine.processes.rst:22
#: ../../source/reference/apidoc/aiida.engine.processes.workchains.rst:13
#: ../../source/reference/apidoc/aiida.engine.rst:22
#: ../../source/reference/apidoc/aiida.manage.configuration.migrations.rst:13
#: ../../source/reference/apidoc/aiida.manage.configuration.rst:22
#: ../../source/reference/apidoc/aiida.manage.external.rmq.rst:13
#: ../../source/reference/apidoc/aiida.manage.external.rst:21
#: ../../source/reference/apidoc/aiida.manage.rst:23
#: ../../source/reference/apidoc/aiida.manage.tests.rst:13
#: ../../source/reference/apidoc/aiida.orm.implementation.rst:13
#: ../../source/reference/apidoc/aiida.orm.nodes.data.array.rst:13
#: ../../source/reference/apidoc/aiida.orm.nodes.data.code.rst:13
#: ../../source/reference/apidoc/aiida.orm.nodes.data.remote.rst:21
#: ../../source/reference/apidoc/aiida.orm.nodes.data.remote.stash.rst:13
#: ../../source/reference/apidoc/aiida.orm.nodes.data.rst:23
#: ../../source/reference/apidoc/aiida.orm.nodes.process.calculation.rst:13
#: ../../source/reference/apidoc/aiida.orm.nodes.process.rst:22
#: ../../source/reference/apidoc/aiida.orm.nodes.process.workflow.rst:13
#: ../../source/reference/apidoc/aiida.orm.nodes.rst:22
#: ../../source/reference/apidoc/aiida.orm.rst:23
#: ../../source/reference/apidoc/aiida.orm.utils.builders.rst:13
#: ../../source/reference/apidoc/aiida.orm.utils.rst:21
#: ../../source/reference/apidoc/aiida.parsers.plugins.arithmetic.rst:13
#: ../../source/reference/apidoc/aiida.parsers.plugins.templatereplacer.rst:13
#: ../../source/reference/apidoc/aiida.parsers.rst:21
#: ../../source/reference/apidoc/aiida.plugins.rst:13
#: ../../source/reference/apidoc/aiida.repository.backend.rst:13
#: ../../source/reference/apidoc/aiida.repository.rst:21
#: ../../source/reference/apidoc/aiida.restapi.common.rst:13
#: ../../source/reference/apidoc/aiida.restapi.rst:22
#: ../../source/reference/apidoc/aiida.restapi.translator.nodes.data.array.rst:13
#: ../../source/reference/apidoc/aiida.restapi.translator.nodes.data.rst:21
#: ../../source/reference/apidoc/aiida.restapi.translator.nodes.process.calculation.rst:13
#: ../../source/reference/apidoc/aiida.restapi.translator.nodes.process.rst:22
#: ../../source/reference/apidoc/aiida.restapi.translator.nodes.process.workflow.rst:13
#: ../../source/reference/apidoc/aiida.restapi.translator.nodes.rst:22
#: ../../source/reference/apidoc/aiida.restapi.translator.rst:21
#: ../../source/reference/apidoc/aiida.rst:36
#: ../../source/reference/apidoc/aiida.schedulers.plugins.rst:13
#: ../../source/reference/apidoc/aiida.schedulers.rst:21
#: ../../source/reference/apidoc/aiida.sphinxext.rst:13
#: ../../source/reference/apidoc/aiida.storage.psql_dos.migrations.rst:21
#: ../../source/reference/apidoc/aiida.storage.psql_dos.migrations.utils.rst:13
#: ../../source/reference/apidoc/aiida.storage.psql_dos.models.rst:13
#: ../../source/reference/apidoc/aiida.storage.psql_dos.orm.querybuilder.rst:13
#: ../../source/reference/apidoc/aiida.storage.psql_dos.orm.rst:21
#: ../../source/reference/apidoc/aiida.storage.psql_dos.rst:23
#: ../../source/reference/apidoc/aiida.storage.rst:24
#: ../../source/reference/apidoc/aiida.storage.sqlite_dos.rst:13
#: ../../source/reference/apidoc/aiida.storage.sqlite_temp.rst:13
#: ../../source/reference/apidoc/aiida.storage.sqlite_zip.migrations.legacy.rst:13
#: ../../source/reference/apidoc/aiida.storage.sqlite_zip.migrations.rst:22
#: ../../source/reference/apidoc/aiida.storage.sqlite_zip.migrations.versions.rst:13
#: ../../source/reference/apidoc/aiida.storage.sqlite_zip.rst:21
#: ../../source/reference/apidoc/aiida.tools.archive.implementations.sqlite_zip.rst:13
#: ../../source/reference/apidoc/aiida.tools.archive.rst:21
#: ../../source/reference/apidoc/aiida.tools.calculations.rst:13
#: ../../source/reference/apidoc/aiida.tools.data.array.kpoints.rst:13
#: ../../source/reference/apidoc/aiida.tools.data.array.rst:21
#: ../../source/reference/apidoc/aiida.tools.data.orbital.rst:13
#: ../../source/reference/apidoc/aiida.tools.data.rst:22
#: ../../source/reference/apidoc/aiida.tools.dbimporters.plugins.rst:13
#: ../../source/reference/apidoc/aiida.tools.dbimporters.rst:21
#: ../../source/reference/apidoc/aiida.tools.graph.rst:13
#: ../../source/reference/apidoc/aiida.tools.groups.rst:13
#: ../../source/reference/apidoc/aiida.tools.ipython.rst:13
#: ../../source/reference/apidoc/aiida.tools.query.rst:13
#: ../../source/reference/apidoc/aiida.tools.visualization.rst:13
#: ../../source/reference/apidoc/aiida.transports.plugins.rst:13
#: ../../source/reference/apidoc/aiida.transports.rst:21
#: ../../source/reference/apidoc/aiida.workflows.arithmetic.rst:13
msgid "Submodules"
msgstr ""

#: ../../../src/aiida/__main__.py:docstring of aiida.__main__:1
msgid "Expose the AiiDA CLI, for usage as `python -m aiida`"
msgstr ""

#: ../../source/reference/apidoc/aiida.calculations.rst:2
msgid "aiida.calculations package"
msgstr ""

#: ../../../src/aiida/calculations/templatereplacer.py:docstring of aiida.calculations.templatereplacer:1
msgid "Generic `CalcJob` implementation where input file is a parametrized template file."
msgstr ""

#: ../../../src/aiida/calculations/arithmetic/add.py:docstring of aiida.calculations.arithmetic.add.ArithmeticAddCalculation:1
#: ../../../src/aiida/calculations/templatereplacer.py:docstring of aiida.calculations.templatereplacer.TemplatereplacerCalculation:1
#: ../../../src/aiida/calculations/transfer.py:docstring of aiida.calculations.transfer.TransferCalculation:1
msgid "Bases: :py:class:`~aiida.engine.processes.calcjobs.calcjob.CalcJob`"
msgstr ""

#: ../../../src/aiida/calculations/templatereplacer.py:docstring of aiida.calculations.templatereplacer.TemplatereplacerCalculation:1
msgid "Simple stub of a plugin that can be used to replace some text in a given template. Can be used for many different codes, or as a starting point to develop a new plugin."
msgstr ""

#: ../../../src/aiida/calculations/templatereplacer.py:docstring of aiida.calculations.templatereplacer.TemplatereplacerCalculation:4
msgid "This simple plugin takes two node inputs, both of type Dict, with the labels 'parameters' and 'template'"
msgstr ""

#: ../../../src/aiida/calculations/templatereplacer.py:docstring of aiida.calculations.templatereplacer.TemplatereplacerCalculation:7
msgid "You can also add other SinglefileData nodes as input, that will be copied according to what is written in 'template' (see below)."
msgstr ""

#: ../../../src/aiida/calculations/templatereplacer.py:docstring of aiida.calculations.templatereplacer.TemplatereplacerCalculation:10
msgid "parameters: a set of parameters that will be used for substitution."
msgstr ""

#: ../../../src/aiida/calculations/templatereplacer.py:docstring of aiida.calculations.templatereplacer.TemplatereplacerCalculation:12
msgid "template: can contain the following parameters:"
msgstr ""

#: ../../../src/aiida/calculations/templatereplacer.py:docstring of aiida.calculations.templatereplacer.TemplatereplacerCalculation:14
msgid "input_file_template: a string with substitutions to be managed with the format() function of python, i.e. if you want to substitute a variable called 'varname', you write {varname} in the text. See http://www.python.org/dev/peps/pep-3101/ for more details. The replaced file will be the input file."
msgstr ""

#: ../../../src/aiida/calculations/templatereplacer.py:docstring of aiida.calculations.templatereplacer.TemplatereplacerCalculation:19
msgid "input_file_name: a string with the file name for the input. If it is not provided, no file will be created."
msgstr ""

#: ../../../src/aiida/calculations/templatereplacer.py:docstring of aiida.calculations.templatereplacer.TemplatereplacerCalculation:22
msgid "output_file_name: a string with the file name for the output. If it is not provided, no redirection will be done and the output will go in the scheduler output file."
msgstr ""

#: ../../../src/aiida/calculations/templatereplacer.py:docstring of aiida.calculations.templatereplacer.TemplatereplacerCalculation:25
msgid "cmdline_params: a list of strings, to be passed as command line parameters. Each one is substituted with the same rule of input_file_template. Optional"
msgstr ""

#: ../../../src/aiida/calculations/templatereplacer.py:docstring of aiida.calculations.templatereplacer.TemplatereplacerCalculation:28
msgid "input_through_stdin: if True, the input file name is passed via stdin. Default is False if missing."
msgstr ""

#: ../../../src/aiida/calculations/templatereplacer.py:docstring of aiida.calculations.templatereplacer.TemplatereplacerCalculation:34
msgid "files_to_copy: if defined, a list of tuple pairs, with format ('link_name', 'dest_rel_path');"
msgstr ""

#: ../../../src/aiida/calculations/templatereplacer.py:docstring of aiida.calculations.templatereplacer.TemplatereplacerCalculation:31
msgid "for each tuple, an input link to this calculation is looked for, with link labeled 'link_label', and with file type 'Singlefile', and the content is copied to a remote file named 'dest_rel_path' Errors are raised in the input links are non-existent, or of the wrong type, or if there are unused input files."
msgstr ""

#: ../../../src/aiida/calculations/templatereplacer.py:docstring of aiida.calculations.templatereplacer.TemplatereplacerCalculation:40
msgid "retrieve_temporary_files: a list of relative filepaths, that if defined, will be retrieved and"
msgstr ""

#: ../../../src/aiida/calculations/templatereplacer.py:docstring of aiida.calculations.templatereplacer.TemplatereplacerCalculation:37
msgid "temporarily stored in an unstored FolderData node that will be available during the Parser.parser_with_retrieved call under the key specified by the Parser.retrieved_temporary_folder key"
msgstr ""

#: ../../../src/aiida/calculations/arithmetic/add.py:docstring of aiida.calculations.arithmetic.add.ArithmeticAddCalculation.define:1
#: ../../../src/aiida/calculations/templatereplacer.py:docstring of aiida.calculations.templatereplacer.TemplatereplacerCalculation.define:1
#: ../../../src/aiida/calculations/transfer.py:docstring of aiida.calculations.transfer.TransferCalculation.define:1
#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.CalcJob.define:1
msgid "Define the process specification, including its inputs, outputs and known exit codes."
msgstr ""

#: ../../../src/aiida/calculations/templatereplacer.py:docstring of aiida.calculations.templatereplacer.TemplatereplacerCalculation.define:3
#: ../../../src/aiida/calculations/transfer.py:docstring of aiida.calculations.transfer.TransferCalculation.define:3
#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.CalcJob.define:3
msgid "Ports are added to the `metadata` input namespace (inherited from the base Process), and a `code` input Port, a `remote_folder` output Port and retrieved folder output Port are added."
msgstr ""

#: ../../../src/aiida/calculations/arithmetic/add.py:docstring of aiida.calculations.arithmetic.add.ArithmeticAddCalculation.define:3
#: ../../../src/aiida/calculations/templatereplacer.py:docstring of aiida.calculations.templatereplacer.TemplatereplacerCalculation.define:7
#: ../../../src/aiida/calculations/transfer.py:docstring of aiida.calculations.transfer.TransferCalculation.define:7
#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.CalcJob.define:7
msgid "the calculation job process spec to define."
msgstr ""

#: ../../../src/aiida/calculations/templatereplacer.py:docstring of aiida.calculations.templatereplacer.TemplatereplacerCalculation.prepare_for_submission:1
msgid "This is the routine to be called when you want to create the input files and related stuff with a plugin."
msgstr ""

#: ../../../src/aiida/calculations/templatereplacer.py:docstring of aiida.calculations.templatereplacer.TemplatereplacerCalculation.prepare_for_submission:3
msgid "a aiida.common.folders.Folder subclass where the plugin should put all its files."
msgstr ""

#: ../../../src/aiida/calculations/transfer.py:docstring of aiida.calculations.transfer:1
msgid "Implementation of Transfer CalcJob."
msgstr ""

#: ../../../src/aiida/calculations/transfer.py:docstring of aiida.calculations.transfer.TransferCalculation:1
msgid "Utility to copy files from different FolderData and RemoteData nodes into a single place."
msgstr ""

#: ../../../src/aiida/calculations/transfer.py:docstring of aiida.calculations.transfer.TransferCalculation:3
msgid "The final destination for these files can be either the local repository (by creating a new FolderData node to store them) or in the remote computer (by leaving the files in a new remote folder saved in a RemoteData node)."
msgstr ""

#: ../../../src/aiida/calculations/transfer.py:docstring of aiida.calculations.transfer.TransferCalculation:7
msgid "Only files from the local computer and from remote folders in the same external computer can be moved at the same time with a single instance of this CalcJob."
msgstr ""

#: ../../../src/aiida/calculations/transfer.py:docstring of aiida.calculations.transfer.TransferCalculation:10
msgid "The user needs to provide three inputs:"
msgstr ""

#: ../../../src/aiida/calculations/transfer.py:docstring of aiida.calculations.transfer.TransferCalculation:12
msgid "``instructions``: a dict node specifying which files to copy from which nodes."
msgstr ""

#: ../../../src/aiida/calculations/transfer.py:docstring of aiida.calculations.transfer.TransferCalculation:13
msgid "``source_nodes``: a dict of nodes, each with a unique identifier label as its key."
msgstr ""

#: ../../../src/aiida/calculations/transfer.py:docstring of aiida.calculations.transfer.TransferCalculation:14
msgid "``metadata.computer``: the computer that contains the remote files and will contain the final RemoteData node."
msgstr ""

#: ../../../src/aiida/calculations/transfer.py:docstring of aiida.calculations.transfer.TransferCalculation:17
msgid "The ``instructions`` dict must have the ``retrieve_files`` flag. The CalcJob will create a new folder in the remote machine (``RemoteData``) and put all the files there and will either:"
msgstr ""

#: ../../../src/aiida/calculations/transfer.py:docstring of aiida.calculations.transfer.TransferCalculation:20
msgid "leave them there (``retrieve_files = False``) or ..."
msgstr ""

#: ../../../src/aiida/calculations/transfer.py:docstring of aiida.calculations.transfer.TransferCalculation:21
msgid "retrieve all the files and store them locally in a ``FolderData``  (``retrieve_files = True``)"
msgstr ""

#: ../../../src/aiida/calculations/transfer.py:docstring of aiida.calculations.transfer.TransferCalculation:23
msgid "The `instructions` dict must also contain at least one list with specifications of which files to copy and from where. All these lists take tuples of 3 that have the following format:"
msgstr ""

#: ../../../src/aiida/calculations/transfer.py:docstring of aiida.calculations.transfer.TransferCalculation:30
msgid "where the ``source_node_key`` has to be the respective one used when providing the node in the ``source_nodes`` input nodes dictionary."
msgstr ""

#: ../../../src/aiida/calculations/transfer.py:docstring of aiida.calculations.transfer.TransferCalculation:34
msgid "The two main lists to include are ``local_files`` (for files to be taken from FolderData nodes) and ``remote_files`` (for files to be taken from RemoteData nodes). Alternatively, files inside of RemoteData nodes can instead be put in the ``symlink_files`` list: the only difference is that files from the first list will be fully copied in the target RemoteData folder, whereas for the files in second list only a symlink to the original file will be created there. This will only affect the content of the final RemoteData target folder, but in both cases the full file will be copied back in the local target FolderData (if ``retrieve_files = True``)."
msgstr ""

#: ../../../src/aiida/calculations/arithmetic/add.py:docstring of aiida.calculations.arithmetic.add.ArithmeticAddCalculation.prepare_for_submission:1
#: ../../../src/aiida/calculations/transfer.py:docstring of aiida.calculations.transfer.TransferCalculation.prepare_for_submission:1
#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.CalcJob.prepare_for_submission:1
msgid "Prepare the calculation for submission."
msgstr ""

#: ../../../src/aiida/calculations/transfer.py:docstring of aiida.calculations.transfer.TransferCalculation.prepare_for_submission:3
#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.CalcJob.prepare_for_submission:3
msgid "Convert the input nodes into the corresponding input files in the format that the code will expect. In addition, define and return a `CalcInfo` instance, which is a simple data structure that contains  information for the engine, for example, on what files to copy to the remote machine, what files to retrieve once it has completed, specific scheduler settings and more."
msgstr ""

#: ../../../src/aiida/calculations/arithmetic/add.py:docstring of aiida.calculations.arithmetic.add.ArithmeticAddCalculation.prepare_for_submission:8
#: ../../../src/aiida/calculations/transfer.py:docstring of aiida.calculations.transfer.TransferCalculation.prepare_for_submission:8
#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.CalcJob.prepare_for_submission:8
msgid "a temporary folder on the local file system."
msgstr ""

#: ../../../src/aiida/calculations/arithmetic/add.py:docstring of aiida.calculations.arithmetic.add.ArithmeticAddCalculation.prepare_for_submission:9
#: ../../../src/aiida/calculations/transfer.py:docstring of aiida.calculations.transfer.TransferCalculation.prepare_for_submission:9
#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.CalcJob.prepare_for_submission:9
msgid "the `CalcInfo` instance"
msgstr ""

#: ../../../src/aiida/calculations/transfer.py:docstring of aiida.calculations.transfer.check_node_type:1
msgid "Common utility function to check the type of a node"
msgstr ""

#: ../../../src/aiida/calculations/transfer.py:docstring of aiida.calculations.transfer.validate_instructions:1
msgid "Check that the instructions dict contains the necessary keywords"
msgstr ""

#: ../../../src/aiida/calculations/transfer.py:docstring of aiida.calculations.transfer.validate_transfer_inputs:1
msgid "Check that the instructions dict and the source nodes are consistent"
msgstr ""

#: ../../source/reference/apidoc/aiida.calculations.arithmetic.rst:2
msgid "aiida.calculations.arithmetic package"
msgstr ""

#: ../../../src/aiida/calculations/arithmetic/add.py:docstring of aiida.calculations.arithmetic.add:1
#: ../../../src/aiida/calculations/arithmetic/add.py:docstring of aiida.calculations.arithmetic.add.ArithmeticAddCalculation:1
msgid "`CalcJob` implementation to add two numbers using bash for testing and demonstration purposes."
msgstr ""

#: ../../../src/aiida/calculations/arithmetic/add.py:docstring of aiida.calculations.arithmetic.add.ArithmeticAddCalculation.prepare_for_submission:3
msgid "Convert the input nodes into the corresponding input files in the format that the code will expect. In addition, define and return a `CalcInfo` instance, which is a simple data structure that contains information for the engine, for example, on what files to copy to the remote machine, what files to retrieve once it has completed, specific scheduler settings and more."
msgstr ""

#: ../../source/reference/apidoc/aiida.calculations.importers.rst:2
msgid "aiida.calculations.importers package"
msgstr ""

#: ../../source/reference/apidoc/aiida.calculations.importers.arithmetic.rst:2
msgid "aiida.calculations.importers.arithmetic package"
msgstr ""

#: ../../../src/aiida/calculations/importers/arithmetic/add.py:docstring of aiida.calculations.importers.arithmetic.add:1
#: ../../../src/aiida/calculations/importers/arithmetic/add.py:docstring of aiida.calculations.importers.arithmetic.add.ArithmeticAddCalculationImporter:1
msgid "Importer for the :class:`aiida.calculations.arithmetic.add.ArithmeticAddCalculation` plugin."
msgstr ""

#: ../../../src/aiida/calculations/importers/arithmetic/add.py:docstring of aiida.calculations.importers.arithmetic.add.ArithmeticAddCalculationImporter:1
msgid "Bases: :py:class:`~aiida.engine.processes.calcjobs.importer.CalcJobImporter`"
msgstr ""

#: ../../../src/aiida/calculations/importers/arithmetic/add.py:docstring of aiida.calculations.importers.arithmetic.add.ArithmeticAddCalculationImporter.parse_remote_data:1
#: ../../../src/aiida/engine/processes/calcjobs/importer.py:docstring of aiida.engine.processes.calcjobs.importer.CalcJobImporter.parse_remote_data:1
msgid "Parse the input nodes from the files in the provided ``RemoteData``."
msgstr ""

#: ../../../src/aiida/calculations/importers/arithmetic/add.py:docstring of aiida.calculations.importers.arithmetic.add.ArithmeticAddCalculationImporter.parse_remote_data:3
#: ../../../src/aiida/engine/processes/calcjobs/importer.py:docstring of aiida.engine.processes.calcjobs.importer.CalcJobImporter.parse_remote_data:3
msgid "the remote data node containing the raw input files."
msgstr ""

#: ../../../src/aiida/calculations/importers/arithmetic/add.py:docstring of aiida.calculations.importers.arithmetic.add.ArithmeticAddCalculationImporter.parse_remote_data:4
#: ../../../src/aiida/engine/processes/calcjobs/importer.py:docstring of aiida.engine.processes.calcjobs.importer.CalcJobImporter.parse_remote_data:4
msgid "additional keyword arguments to control the parsing process."
msgstr ""

#: ../../../src/aiida/calculations/importers/arithmetic/add.py:docstring of aiida.calculations.importers.arithmetic.add.ArithmeticAddCalculationImporter.parse_remote_data:5
#: ../../../src/aiida/engine/processes/calcjobs/importer.py:docstring of aiida.engine.processes.calcjobs.importer.CalcJobImporter.parse_remote_data:5
msgid "a dictionary with the parsed inputs nodes that match the input spec of the associated ``CalcJob``."
msgstr ""

#: ../../source/reference/apidoc/aiida.calculations.monitors.rst:2
msgid "aiida.calculations.monitors package"
msgstr ""

#: ../../../src/aiida/calculations/monitors/base.py:docstring of aiida.calculations.monitors.base:1
msgid "Monitors for the :class:`aiida.calculations.arithmetic.add.ArithmeticAddCalculation` plugin."
msgstr ""

#: ../../../src/aiida/calculations/monitors/base.py:docstring of aiida.calculations.monitors.base.always_kill:1
msgid "Retrieve and inspect files in working directory of job to determine whether the job should be killed."
msgstr ""

#: ../../../src/aiida/calculations/monitors/base.py:docstring of aiida.calculations.monitors.base.always_kill:3
msgid "This particular implementation is just for demonstration purposes and will kill the job as long as there is a submission script that contains some content, which should always be the case."
msgstr ""

#: ../../../src/aiida/calculations/monitors/base.py:docstring of aiida.calculations.monitors.base.always_kill:6
msgid "The node representing the calculation job."
msgstr ""

#: ../../../src/aiida/calculations/monitors/base.py:docstring of aiida.calculations.monitors.base.always_kill:7
msgid "The transport that can be used to retrieve files from remote working directory."
msgstr ""

#: ../../../src/aiida/calculations/monitors/base.py:docstring of aiida.calculations.monitors.base.always_kill:8
msgid "A string if the job should be killed, `None` otherwise."
msgstr ""

#: ../../source/reference/apidoc/aiida.cmdline.rst:2
msgid "aiida.cmdline package"
msgstr ""

#: ../../../src/aiida/cmdline/__init__.py:docstring of aiida.cmdline:1
msgid "The command line interface of AiiDA."
msgstr ""

#: ../../source/reference/apidoc/aiida.cmdline.commands.rst:2
msgid "aiida.cmdline.commands package"
msgstr ""

#: ../../../src/aiida/cmdline/commands/__init__.py:docstring of aiida.cmdline.commands:1
msgid "Sub commands of the ``verdi`` command line interface."
msgstr ""

#: ../../../src/aiida/cmdline/commands/__init__.py:docstring of aiida.cmdline.commands:3
msgid "The commands need to be imported here for them to be registered with the top-level command group."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_archive.py:docstring of aiida.cmdline.commands.cmd_archive:1
msgid "`verdi archive` command."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_archive.py:docstring of aiida.cmdline.commands.cmd_archive.ExtrasImportCode:1
#: ../../../src/aiida/common/datastructures.py:docstring of aiida.common.datastructures.CalcJobState:1
#: ../../../src/aiida/common/datastructures.py:docstring of aiida.common.datastructures.StashMode:1
#: ../../../src/aiida/common/links.py:docstring of aiida.common.links.GraphTraversalRules:1
#: ../../../src/aiida/common/links.py:docstring of aiida.common.links.LinkType:1
#: ../../../src/aiida/common/log.py:docstring of aiida.common.log.LogLevels:1
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.ControllerProtocol:1
#: ../../../src/aiida/engine/processes/calcjobs/monitors.py:docstring of aiida.engine.processes.calcjobs.monitors.CalcJobMonitorAction:1
#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.SaveKeys:1
#: ../../../src/aiida/engine/processes/workchains/awaitable.py:docstring of aiida.engine.processes.workchains.awaitable.AwaitableAction:1
#: ../../../src/aiida/engine/processes/workchains/awaitable.py:docstring of aiida.engine.processes.workchains.awaitable.AwaitableTarget:1
#: ../../../src/aiida/manage/caching.py:docstring of aiida.manage.caching.ConfigKeys:1
#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities.EntityTypes:1
#: ../../../src/aiida/orm/utils/builders/code.py:docstring of aiida.orm.utils.builders.code.CodeBuilder.CodeType:1
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.IdentifierType:1
#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.EntryPointFormat:1
#: ../../../src/aiida/repository/common.py:docstring of aiida.repository.common.FileType:1
#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobState:1
#: ../../../src/aiida/tools/dbimporters/plugins/mpds.py:docstring of aiida.tools.dbimporters.plugins.mpds.ApiFormat:1
msgid "Bases: :py:class:`~enum.Enum`"
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_archive.py:docstring of aiida.cmdline.commands.cmd_archive.ExtrasImportCode:1
#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.ExitCode:1
msgid "Exit codes for the verdi command line."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_archive.py:docstring of aiida.cmdline.commands.cmd_archive._echo_exception:1
msgid "Correctly report and exception."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_archive.py:docstring of aiida.cmdline.commands.cmd_archive._echo_exception:3
msgid "The message prefix"
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_archive.py:docstring of aiida.cmdline.commands.cmd_archive._echo_exception:4
msgid "the exception raised"
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_archive.py:docstring of aiida.cmdline.commands.cmd_archive._echo_exception:5
msgid "If True only print a warning, otherwise calls sys.exit with a non-zero exit status"
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_archive.py:docstring of aiida.cmdline.commands.cmd_archive._gather_imports:1
msgid "Gather archives to import and sort into local files and URLs."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_archive.py:docstring of aiida.cmdline.commands.cmd_archive._gather_imports:3
msgid "list of (archive path, whether it is web based)"
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_archive.py:docstring of aiida.cmdline.commands.cmd_archive._import_archive_and_migrate:1
msgid "Perform the archive import."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_archive.py:docstring of aiida.cmdline.commands.cmd_archive._import_archive_and_migrate:3
msgid "the path or URL to the archive"
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_archive.py:docstring of aiida.cmdline.commands.cmd_archive._import_archive_and_migrate:4
msgid "If the archive needs to be downloaded first"
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_archive.py:docstring of aiida.cmdline.commands.cmd_archive._import_archive_and_migrate:5
msgid "keyword arguments to pass to the import function"
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_archive.py:docstring of aiida.cmdline.commands.cmd_archive._import_archive_and_migrate:6
msgid "whether to try a migration if the import raises `IncompatibleStorageSchema`"
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_calcjob.py:docstring of aiida.cmdline.commands.cmd_calcjob:1
msgid "`verdi calcjob` commands."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_calcjob.py:docstring of aiida.cmdline.commands.cmd_calcjob.get_remote_and_path:1
msgid "Return the remote folder output node and process the path argument."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_calcjob.py:docstring of aiida.cmdline.commands.cmd_calcjob.get_remote_and_path:3
msgid "The ``CalcJobNode`` whose remote_folder to be returned."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_calcjob.py:docstring of aiida.cmdline.commands.cmd_calcjob.get_remote_and_path:4
msgid "The relative path of file. If not defined, it is attempted to determine the default output file from the node options or otherwise from the associated process class. If neither are defined, a ``ValueError`` is raised."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_calcjob.py:docstring of aiida.cmdline.commands.cmd_calcjob.get_remote_and_path:7
msgid "A tuple of the ``RemoteData`` and the path of the output file to be used."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_calcjob.py:docstring of aiida.cmdline.commands.cmd_calcjob.get_remote_and_path:0
#: ../../../src/aiida/cmdline/groups/verdi.py:docstring of aiida.cmdline.groups.verdi.LazyConfigAttributeDict.__getattr__:0
#: ../../../src/aiida/cmdline/params/types/code.py:docstring of aiida.cmdline.params.types.code.CodeParamType.convert:0
#: ../../../src/aiida/cmdline/params/types/group.py:docstring of aiida.cmdline.params.types.group.GroupParamType.convert:0
#: ../../../src/aiida/cmdline/params/types/identifier.py:docstring of aiida.cmdline.params.types.identifier.IdentifierParamType.convert:0
#: ../../../src/aiida/cmdline/utils/defaults.py:docstring of aiida.cmdline.utils.defaults.get_default_profile:0
#: ../../../src/aiida/cmdline/utils/repository.py:docstring of aiida.cmdline.utils.repository.list_repository_contents:0
#: ../../../src/aiida/common/extendeddicts.py:docstring of aiida.common.extendeddicts.AttributeDict.__delattr__:0
#: ../../../src/aiida/common/extendeddicts.py:docstring of aiida.common.extendeddicts.AttributeDict.__getattr__:0
#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder.replace_with_folder:0
#: ../../../src/aiida/common/json.py:docstring of aiida.common.json.load:0
#: ../../../src/aiida/common/json.py:docstring of aiida.common.json.loads:0
#: ../../../src/aiida/common/lang.py:docstring of aiida.common.lang.isidentifier:0
#: ../../../src/aiida/common/links.py:docstring of aiida.common.links.validate_link_label:0
#: ../../../src/aiida/common/timezone.py:docstring of aiida.common.timezone.timezone_from_name:0
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient._check_pid_file:0
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient._verdi_bin:0
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.call_client:0
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.restart_daemon:0
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.start_daemon:0
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.stop_daemon:0
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.get_daemon_client:0
#: ../../../src/aiida/engine/persistence.py:docstring of aiida.engine.persistence.ObjectLoader.load_object:0
#: ../../../src/aiida/engine/processes/calcjobs/monitors.py:docstring of aiida.engine.processes.calcjobs.monitors.CalcJobMonitor.load_entry_point:0
#: ../../../src/aiida/engine/processes/calcjobs/monitors.py:docstring of aiida.engine.processes.calcjobs.monitors.CalcJobMonitor.validate:0
#: ../../../src/aiida/engine/processes/calcjobs/monitors.py:docstring of aiida.engine.processes.calcjobs.monitors.CalcJobMonitorResult.validate:0
#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control._perform_actions:0
#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control.kill_processes:0
#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control.pause_processes:0
#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control.play_processes:0
#: ../../../src/aiida/engine/processes/exit_code.py:docstring of aiida.engine.processes.exit_code.ExitCodesNamespace.__call__:0
#: ../../../src/aiida/engine/processes/functions.py:docstring of aiida.engine.processes.functions.FunctionProcess.validate_inputs:0
#: ../../../src/aiida/engine/processes/ports.py:docstring of aiida.engine.processes.ports.PortNamespace.validate_port_name:0
#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.get_exit_statuses:0
#: ../../../src/aiida/engine/processes/workchains/workchain.py:docstring of aiida.engine.processes.workchains.workchain.Protect.__new__:0
#: ../../../src/aiida/engine/utils.py:docstring of aiida.engine.utils.prepare_inputs:0
#: ../../../src/aiida/manage/caching.py:docstring of aiida.manage.caching._validate_identifier_pattern:0
#: ../../../src/aiida/manage/configuration/__init__.py:docstring of aiida.manage.configuration.get_config:0
#: ../../../src/aiida/manage/configuration/__init__.py:docstring of aiida.manage.configuration.get_config_option:0
#: ../../../src/aiida/manage/configuration/__init__.py:docstring of aiida.manage.configuration.load_config:0
#: ../../../src/aiida/manage/configuration/__init__.py:docstring of aiida.manage.configuration.load_profile:0
#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.create_profile:0
#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.get_profile:0
#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.remove_profile:0
#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.set_default_profile:0
#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.validate_profile:0
#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.config_needs_migrating:0
#: ../../../src/aiida/manage/external/rmq/client.py:docstring of aiida.manage.external.rmq.client.RabbitmqManagementClient.request:0
#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.get_config:0
#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.get_daemon_client:0
#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.get_option:0
#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.load_profile:0
#: ../../../src/aiida/manage/profile_access.py:docstring of aiida.manage.profile_access.ProfileAccessManager._raise_if_active:0
#: ../../../src/aiida/manage/profile_access.py:docstring of aiida.manage.profile_access.ProfileAccessManager._raise_if_locked:0
#: ../../../src/aiida/manage/profile_access.py:docstring of aiida.manage.profile_access.ProfileAccessManager.lock:0
#: ../../../src/aiida/manage/profile_access.py:docstring of aiida.manage.profile_access.ProfileAccessManager.request_access:0
#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.EntryPointManager._validate_entry_point:0
#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.EntryPointManager.add:0
#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.EntryPointManager.remove:0
#: ../../../src/aiida/orm/comments.py:docstring of aiida.orm.comments.CommentCollection.delete:0
#: ../../../src/aiida/orm/comments.py:docstring of aiida.orm.comments.CommentCollection.delete_all:0
#: ../../../src/aiida/orm/comments.py:docstring of aiida.orm.comments.CommentCollection.delete_many:0
#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.get_authinfo:0
#: ../../../src/aiida/orm/extras.py:docstring of aiida.orm.extras.EntityExtras.delete:0
#: ../../../src/aiida/orm/extras.py:docstring of aiida.orm.extras.EntityExtras.delete_many:0
#: ../../../src/aiida/orm/extras.py:docstring of aiida.orm.extras.EntityExtras.get:0
#: ../../../src/aiida/orm/extras.py:docstring of aiida.orm.extras.EntityExtras.get_many:0
#: ../../../src/aiida/orm/extras.py:docstring of aiida.orm.extras.EntityExtras.reset:0
#: ../../../src/aiida/orm/extras.py:docstring of aiida.orm.extras.EntityExtras.set:0
#: ../../../src/aiida/orm/extras.py:docstring of aiida.orm.extras.EntityExtras.set_many:0
#: ../../../src/aiida/orm/implementation/comments.py:docstring of aiida.orm.implementation.comments.BackendCommentCollection.delete:0
#: ../../../src/aiida/orm/implementation/comments.py:docstring of aiida.orm.implementation.comments.BackendCommentCollection.delete_all:0
#: ../../../src/aiida/orm/implementation/comments.py:docstring of aiida.orm.implementation.comments.BackendCommentCollection.delete_many:0
#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendEntityExtrasMixin.delete_extra:0
#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendEntityExtrasMixin.delete_extra_many:0
#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendEntityExtrasMixin.get_extra:0
#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendEntityExtrasMixin.get_extra_many:0
#: ../../../src/aiida/orm/implementation/logs.py:docstring of aiida.orm.implementation.logs.BackendLogCollection.delete:0
#: ../../../src/aiida/orm/implementation/logs.py:docstring of aiida.orm.implementation.logs.BackendLogCollection.delete_all:0
#: ../../../src/aiida/orm/implementation/logs.py:docstring of aiida.orm.implementation.logs.BackendLogCollection.delete_many:0
#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.add_incoming:0
#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.delete_attribute:0
#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.delete_attribute_many:0
#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.get_attribute:0
#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.get_attribute_many:0
#: ../../../src/aiida/orm/implementation/utils.py:docstring of aiida.orm.implementation.utils.validate_attribute_extra_key:0
#: ../../../src/aiida/orm/logs.py:docstring of aiida.orm.logs.LogCollection.delete:0
#: ../../../src/aiida/orm/logs.py:docstring of aiida.orm.logs.LogCollection.delete_all:0
#: ../../../src/aiida/orm/logs.py:docstring of aiida.orm.logs.LogCollection.delete_many:0
#: ../../../src/aiida/orm/nodes/attributes.py:docstring of aiida.orm.nodes.attributes.NodeAttributes.delete:0
#: ../../../src/aiida/orm/nodes/attributes.py:docstring of aiida.orm.nodes.attributes.NodeAttributes.delete_many:0
#: ../../../src/aiida/orm/nodes/attributes.py:docstring of aiida.orm.nodes.attributes.NodeAttributes.get:0
#: ../../../src/aiida/orm/nodes/attributes.py:docstring of aiida.orm.nodes.attributes.NodeAttributes.get_many:0
#: ../../../src/aiida/orm/nodes/attributes.py:docstring of aiida.orm.nodes.attributes.NodeAttributes.reset:0
#: ../../../src/aiida/orm/nodes/attributes.py:docstring of aiida.orm.nodes.attributes.NodeAttributes.set:0
#: ../../../src/aiida/orm/nodes/attributes.py:docstring of aiida.orm.nodes.attributes.NodeAttributes.set_many:0
#: ../../../src/aiida/orm/nodes/comments.py:docstring of aiida.orm.nodes.comments.NodeComments.get:0
#: ../../../src/aiida/orm/nodes/comments.py:docstring of aiida.orm.nodes.comments.NodeComments.update:0
#: ../../../src/aiida/orm/nodes/data/array/array.py:docstring of aiida.orm.nodes.data.array.array.ArrayData.get_array:0
#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.orm.nodes.data.array.kpoints.KpointsData.get_kpoints_mesh:0
#: ../../../src/aiida/orm/nodes/data/array/projection.py:docstring of aiida.orm.nodes.data.array.projection.ProjectionData.get_reference_bandsdata:0
#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.get_cells:0
#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.get_index_from_stepid:0
#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.get_positions:0
#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.get_step_data:0
#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.get_stepids:0
#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.get_times:0
#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.set_structurelist:0
#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.symbols:0
#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.get_builder:0
#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.validate_working_directory:0
#: ../../../src/aiida/orm/nodes/data/code/installed.py:docstring of aiida.orm.nodes.data.code.installed.InstalledCode.validate_filepath_executable:0
#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.get:0
#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.get_code_helper:0
#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.get_from_string:0
#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.validate_remote_exec_path:0
#: ../../../src/aiida/orm/nodes/data/code/portable.py:docstring of aiida.orm.nodes.data.code.portable.PortableCode.validate_working_directory:0
#: ../../../src/aiida/orm/nodes/data/enum.py:docstring of aiida.orm.nodes.data.enum.EnumData.get_enum:0
#: ../../../src/aiida/orm/nodes/data/enum.py:docstring of aiida.orm.nodes.data.enum.EnumData.get_member:0
#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.as_path:0
#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.delete_object:0
#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.erase:0
#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.get_object:0
#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.get_object_content:0
#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.list_object_names:0
#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.list_objects:0
#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.open:0
#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.put_object_from_bytes:0
#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.put_object_from_file:0
#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.put_object_from_filelike:0
#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.put_object_from_tree:0
#: ../../../src/aiida/orm/nodes/data/remote/base.py:docstring of aiida.orm.nodes.data.remote.base.RemoteData._clean:0
#: ../../../src/aiida/orm/nodes/data/singlefile.py:docstring of aiida.orm.nodes.data.singlefile.SinglefileData.as_path:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData._get_object_pymatgen_structure:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_pymatgen_structure:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.reset_sites_positions:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.set_pymatgen_structure:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure._get_valid_cell:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.get_valid_pbc:0
#: ../../../src/aiida/orm/nodes/data/upf.py:docstring of aiida.orm.nodes.data.upf.get_pseudos_from_structure:0
#: ../../../src/aiida/orm/nodes/links.py:docstring of aiida.orm.nodes.links.NodeLinks._add_incoming_cache:0
#: ../../../src/aiida/orm/nodes/links.py:docstring of aiida.orm.nodes.links.NodeLinks.add_incoming:0
#: ../../../src/aiida/orm/nodes/links.py:docstring of aiida.orm.nodes.links.NodeLinks.validate_incoming:0
#: ../../../src/aiida/orm/nodes/links.py:docstring of aiida.orm.nodes.links.NodeLinks.validate_outgoing:0
#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node._validate_storability:0
#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node._verify_are_parents_stored:0
#: ../../../src/aiida/orm/nodes/process/calculation/calcfunction.py:docstring of aiida.orm.nodes.process.calculation.calcfunction.CalcFunctionNodeLinks.validate_outgoing:0
#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode._validate_retrieval_directive:0
#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.get_parser_class:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.process_class:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNodeLinks.validate_incoming:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNodeLinks.validate_outgoing:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.process_class:0
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.process_class:0
#: ../../../src/aiida/orm/nodes/process/workflow/workflow.py:docstring of aiida.orm.nodes.process.workflow.workflow.WorkflowNodeLinks.validate_outgoing:0
#: ../../../src/aiida/orm/nodes/process/workflow/workfunction.py:docstring of aiida.orm.nodes.process.workflow.workfunction.WorkFunctionNodeLinks.validate_outgoing:0
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository._check_mutability:0
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.as_path:0
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.delete_object:0
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.erase:0
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.get_object:0
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.get_object_content:0
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.list_object_names:0
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.list_objects:0
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.open:0
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.put_object_from_bytes:0
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.put_object_from_file:0
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.put_object_from_filelike:0
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.put_object_from_tree:0
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder._QueryTagMap.get:0
#: ../../../src/aiida/orm/utils/calcjob.py:docstring of aiida.orm.utils.calcjob.CalcJobResultManager.__getattr__:0
#: ../../../src/aiida/orm/utils/calcjob.py:docstring of aiida.orm.utils.calcjob.CalcJobResultManager.__getitem__:0
#: ../../../src/aiida/orm/utils/calcjob.py:docstring of aiida.orm.utils.calcjob.CalcJobResultManager._load_results:0
#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links.LinkManager.get_node_by_label:0
#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links.LinkManager.nested:0
#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links.validate_link:0
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.CalculationEntityLoader._get_query_builder_label_identifier:0
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.CodeEntityLoader._get_query_builder_label_identifier:0
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.ComputerEntityLoader._get_query_builder_label_identifier:0
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.DataEntityLoader._get_query_builder_label_identifier:0
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.GroupEntityLoader._get_query_builder_label_identifier:0
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.NodeEntityLoader._get_query_builder_label_identifier:0
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader._get_query_builder_label_identifier:0
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader.get_query_classes:0
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader.infer_identifier_type:0
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader.load_entity:0
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.ProcessEntityLoader._get_query_builder_label_identifier:0
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.WorkflowEntityLoader._get_query_builder_label_identifier:0
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.get_loader:0
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_code:0
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_computer:0
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_entity:0
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_group:0
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_node:0
#: ../../../src/aiida/parsers/parser.py:docstring of aiida.parsers.parser.Parser.out:0
#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.format_entry_point_string:0
#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.get_entry_point:0
#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.get_entry_point_from_string:0
#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.load_entry_point:0
#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.load_entry_point_from_string:0
#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.parse_entry_point_string:0
#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.validate_registered_entry_points:0
#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.BaseFactory:0
#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.CalcJobImporterFactory:0
#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.CalculationFactory:0
#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.DataFactory:0
#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.DbImporterFactory:0
#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.GroupFactory:0
#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.OrbitalFactory:0
#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.ParserFactory:0
#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.SchedulerFactory:0
#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.StorageFactory:0
#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.TransportFactory:0
#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.WorkflowFactory:0
#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.raise_invalid_type_error:0
#: ../../../src/aiida/plugins/utils.py:docstring of aiida.plugins.utils.PluginVersionProvider.get_version_info:0
#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.delete_object:0
#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.delete_objects:0
#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.get_object_content:0
#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.get_object_hash:0
#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.iter_object_streams:0
#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.open:0
#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.put_object_from_file:0
#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.put_object_from_filelike:0
#: ../../../src/aiida/repository/backend/disk_object_store.py:docstring of aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend._put_object_from_filelike:0
#: ../../../src/aiida/repository/backend/disk_object_store.py:docstring of aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend.delete_objects:0
#: ../../../src/aiida/repository/backend/disk_object_store.py:docstring of aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend.get_object_hash:0
#: ../../../src/aiida/repository/backend/disk_object_store.py:docstring of aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend.iter_object_streams:0
#: ../../../src/aiida/repository/backend/disk_object_store.py:docstring of aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend.open:0
#: ../../../src/aiida/repository/backend/sandbox.py:docstring of aiida.repository.backend.sandbox.SandboxRepositoryBackend._put_object_from_filelike:0
#: ../../../src/aiida/repository/backend/sandbox.py:docstring of aiida.repository.backend.sandbox.SandboxRepositoryBackend.delete_objects:0
#: ../../../src/aiida/repository/backend/sandbox.py:docstring of aiida.repository.backend.sandbox.SandboxRepositoryBackend.iter_object_streams:0
#: ../../../src/aiida/repository/backend/sandbox.py:docstring of aiida.repository.backend.sandbox.SandboxRepositoryBackend.open:0
#: ../../../src/aiida/repository/common.py:docstring of aiida.repository.common.File.__init__:0
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository._pre_process_path:0
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.copy_tree:0
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.create_directory:0
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.delete_object:0
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.get_directory:0
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.get_file:0
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.get_object:0
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.get_object_content:0
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.has_object:0
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.list_object_names:0
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.list_objects:0
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.open:0
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.put_object_from_file:0
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.put_object_from_filelike:0
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.put_object_from_tree:0
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.set_backend:0
#: ../../../src/aiida/restapi/common/identifiers.py:docstring of aiida.restapi.common.identifiers.get_full_type_filters:0
#: ../../../src/aiida/restapi/common/identifiers.py:docstring of aiida.restapi.common.identifiers.load_entry_point_from_full_type:0
#: ../../../src/aiida/restapi/common/identifiers.py:docstring of aiida.restapi.common.identifiers.validate_full_type:0
#: ../../../src/aiida/restapi/translator/base.py:docstring of aiida.restapi.translator.base.BaseTranslator._check_id_validity:0
#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobResource.validate_resources:0
#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.NodeNumberJobResource.__init__:0
#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.NodeNumberJobResource.validate_resources:0
#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.ParEnvJobResource.__init__:0
#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.ParEnvJobResource.validate_resources:0
#: ../../../src/aiida/schedulers/plugins/lsf.py:docstring of aiida.schedulers.plugins.lsf.LsfJobResource.__init__:0
#: ../../../src/aiida/schedulers/plugins/lsf.py:docstring of aiida.schedulers.plugins.lsf.LsfJobResource.validate_resources:0
#: ../../../src/aiida/schedulers/plugins/pbsbaseclasses.py:docstring of aiida.schedulers.plugins.pbsbaseclasses.PbsJobResource.validate_resources:0
#: ../../../src/aiida/schedulers/plugins/slurm.py:docstring of aiida.schedulers.plugins.slurm.SlurmJobResource.validate_resources:0
#: ../../../src/aiida/schedulers/plugins/slurm.py:docstring of aiida.schedulers.plugins.slurm.SlurmScheduler.parse_output:0
#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler.validate_resources:0
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.LazyFile.__init__:0
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.NoopRepositoryBackend.delete_objects:0
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.NoopRepositoryBackend.iter_object_streams:0
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.get_node_repository_dirpaths:0
#: ../../../src/aiida/storage/psql_dos/orm/comments.py:docstring of aiida.storage.psql_dos.orm.comments.SqlaCommentCollection.delete:0
#: ../../../src/aiida/storage/psql_dos/orm/comments.py:docstring of aiida.storage.psql_dos.orm.comments.SqlaCommentCollection.delete_all:0
#: ../../../src/aiida/storage/psql_dos/orm/comments.py:docstring of aiida.storage.psql_dos.orm.comments.SqlaCommentCollection.delete_many:0
#: ../../../src/aiida/storage/psql_dos/orm/logs.py:docstring of aiida.storage.psql_dos.orm.logs.SqlaLogCollection.delete:0
#: ../../../src/aiida/storage/psql_dos/orm/logs.py:docstring of aiida.storage.psql_dos.orm.logs.SqlaLogCollection.delete_all:0
#: ../../../src/aiida/storage/psql_dos/orm/logs.py:docstring of aiida.storage.psql_dos.orm.logs.SqlaLogCollection.delete_many:0
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.add_incoming:0
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.delete_attribute:0
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.delete_attribute_many:0
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.get_attribute:0
#: ../../../src/aiida/storage/psql_dos/orm/utils.py:docstring of aiida.storage.psql_dos.orm.utils.ModelWrapper.save:0
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SandboxShaRepositoryBackend._put_object_from_filelike:0
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SandboxShaRepositoryBackend.get_object_hash:0
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.FolderBackendRepository.open:0
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.ZipfileBackendRepository.open:0
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend._RoBackendRepository.delete_objects:0
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend._RoBackendRepository.get_object_hash:0
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend._RoBackendRepository.iter_object_streams:0
#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v06_to_v07.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v06_to_v07.data_migration_legacy_process_attributes:0
#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveWriterAbstract.delete_object:0
#: ../../../src/aiida/tools/archive/create.py:docstring of aiida.tools.archive.create.create_archive:0
#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/writer.py:docstring of aiida.tools.archive.implementations.sqlite_zip.writer.ArchiveAppenderSqlZip.delete_object:0
#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/writer.py:docstring of aiida.tools.archive.implementations.sqlite_zip.writer.ArchiveWriterSqlZip.delete_object:0
#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports.import_archive:0
#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbImporter.query:0
#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbSearchResults.at:0
#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbSearchResults.next:0
#: ../../../src/aiida/tools/dbimporters/plugins/mpds.py:docstring of aiida.tools.dbimporters.plugins.mpds.MpdsDbImporter.get_response_content:0
#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.chmod:0
#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.close:0
#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.copy:0
#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.copyfile:0
#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.copytree:0
#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.get:0
#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.gettree:0
#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.makedirs:0
#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.mkdir:0
#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.open:0
#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.put:0
#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.putfile:0
#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.puttree:0
#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.rename:0
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.close:0
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.copy:0
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.copyfile:0
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.copytree:0
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.get:0
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.getfile:0
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.gettree:0
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.makedirs:0
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.mkdir:0
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.open:0
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.put:0
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.putfile:0
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.puttree:0
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.rename:0
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.rmtree:0
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.convert_to_bool:0
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.copyfile:0
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.copytree:0
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.normalize:0
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.remove:0
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.rename:0
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.validate_positive_number:0
msgid "Raises"
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_calcjob.py:docstring of aiida.cmdline.commands.cmd_calcjob.get_remote_and_path:8
msgid "If path is not defined and no default output file is defined on the node nor its associated process class."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_code.py:docstring of aiida.cmdline.commands.cmd_code:1
msgid "`verdi code` command."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_code.py:docstring of aiida.cmdline.commands.cmd_code.create_code:1
msgid "Create a new `Code` instance."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_code.py:docstring of aiida.cmdline.commands.cmd_code.get_default:1
msgid "Get the default argument using a user instance property :param value: The name of the property to use :param ctx: The click context (which will be used to get the user) :return: The default value, or None"
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_code.py:docstring of aiida.cmdline.commands.cmd_code.set_code_builder:1
msgid "Set the code spec for defaults of following options."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_computer.py:docstring of aiida.cmdline.commands.cmd_computer:1
msgid "`verdi computer` command."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_computer.py:docstring of aiida.cmdline.commands.cmd_computer.LazyConfigureGroup:1
#: ../../../src/aiida/cmdline/groups/dynamic.py:docstring of aiida.cmdline.groups.dynamic.DynamicEntryPointCommandGroup:1
#: ../../../src/aiida/cmdline/utils/pluginable.py:docstring of aiida.cmdline.utils.pluginable.Pluginable:1
msgid "Bases: :py:class:`~aiida.cmdline.groups.verdi.VerdiCommandGroup`"
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_computer.py:docstring of aiida.cmdline.commands.cmd_computer.LazyConfigureGroup:1
msgid "A click group that will lazily load the subcommands for each transport plugin."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_computer.py:docstring of aiida.cmdline.commands.cmd_computer.LazyConfigureGroup.get_command:1
#: ../../../src/aiida/cmdline/groups/verdi.py:docstring of aiida.cmdline.groups.verdi.VerdiCommandGroup.get_command:1
msgid "Return the command that corresponds to the requested ``cmd_name``."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_computer.py:docstring of aiida.cmdline.commands.cmd_computer.LazyConfigureGroup.get_command:3
#: ../../../src/aiida/cmdline/groups/verdi.py:docstring of aiida.cmdline.groups.verdi.VerdiCommandGroup.get_command:3
msgid "This method is overridden from the base class in order to two functionalities:"
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_computer.py:docstring of aiida.cmdline.commands.cmd_computer.LazyConfigureGroup.get_command:5
#: ../../../src/aiida/cmdline/groups/verdi.py:docstring of aiida.cmdline.groups.verdi.VerdiCommandGroup.get_command:5
msgid "If the command is found, automatically add the verbosity option."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_computer.py:docstring of aiida.cmdline.commands.cmd_computer.LazyConfigureGroup.get_command:6
#: ../../../src/aiida/cmdline/groups/verdi.py:docstring of aiida.cmdline.groups.verdi.VerdiCommandGroup.get_command:6
msgid "If the command is not found, attempt to provide a list of suggestions with existing commands that resemble the requested command name."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_computer.py:docstring of aiida.cmdline.commands.cmd_computer.LazyConfigureGroup.get_command:9
#: ../../../src/aiida/cmdline/groups/verdi.py:docstring of aiida.cmdline.groups.verdi.VerdiCommandGroup.get_command:9
msgid "Note that if the command is not found and ``resilient_parsing`` is set to True on the context, then the latter feature is disabled because most likely we are operating in tab-completion mode."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_computer.py:docstring of aiida.cmdline.commands.cmd_computer.LazyConfigureGroup.list_commands:1
msgid "Returns a list of subcommand names in the order they should appear."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_computer.py:docstring of aiida.cmdline.commands.cmd_computer._computer_create_temp_file:1
msgid "Internal test to check if it is possible to create a temporary file and then delete it in the work directory"
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_computer.py:docstring of aiida.cmdline.commands.cmd_computer._computer_create_temp_file:0
#: ../../../src/aiida/cmdline/commands/cmd_data/cmd_export.py:docstring of aiida.cmdline.commands.cmd_data.cmd_export.data_export:0
#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.Prettifier._prettify_label_gnuplot:0
#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.Prettifier._prettify_label_gnuplot_simple:0
#: ../../../src/aiida/manage/configuration/profile.py:docstring of aiida.manage.configuration.profile.Profile.repository_path:0
#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.Group.add_nodes:0
#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.Group.remove_nodes:0
#: ../../../src/aiida/orm/implementation/groups.py:docstring of aiida.orm.implementation.groups.BackendGroup.add_nodes:0
#: ../../../src/aiida/orm/implementation/groups.py:docstring of aiida.orm.implementation.groups.BackendGroup.remove_nodes:0
#: ../../../src/aiida/orm/implementation/querybuilder.py:docstring of aiida.orm.implementation.querybuilder.BackendQueryBuilder.get_creation_statistics:0
#: ../../../src/aiida/orm/nodes/data/array/array.py:docstring of aiida.orm.nodes.data.array.array.ArrayData:0
#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.find_bandgap:0
#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.orm.nodes.data.array.kpoints.KpointsData.set_kpoints_mesh_from_density:0
#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node.store:0
#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.res:0
#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.restapi.resources.CalcJobNode.CalcJobTranslator.CalcJobNode.res:0
#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.restapi.translator.nodes.process.calculation.calcjob.CalcJobTranslator.CalcJobNode.res:0
#: ../../../src/aiida/orm/utils/managers.py:docstring of aiida.orm.utils.managers.AttributeManager:0
#: ../../../src/aiida/orm/utils/managers.py:docstring of aiida.orm.utils.managers.AttributeManager.__getattr__:0
#: ../../../src/aiida/storage/psql_dos/migrations/utils/create_dbattribute.py:docstring of aiida.storage.psql_dos.migrations.utils.create_dbattribute.create_rows:0
#: ../../../src/aiida/storage/psql_dos/orm/groups.py:docstring of aiida.storage.psql_dos.orm.groups.SqlaGroup.add_nodes:0
#: ../../../src/aiida/storage/psql_dos/orm/groups.py:docstring of aiida.storage.psql_dos.orm.groups.SqlaGroup.remove_nodes:0
#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder.get_creation_statistics:0
#: ../../../src/aiida/tools/data/array/kpoints/legacy.py:docstring of aiida.tools.data.array.kpoints.legacy.get_kpoints_path:0
#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.IcsdEntry:0
#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.IcsdSearchResults.query_page:0
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.exec_command_wait:0
msgid "note"
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_computer.py:docstring of aiida.cmdline.commands.cmd_computer._computer_create_temp_file:4
msgid "exceptions could be raised"
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_computer.py:docstring of aiida.cmdline.commands.cmd_computer._computer_create_temp_file:6
#: ../../../src/aiida/cmdline/commands/cmd_computer.py:docstring of aiida.cmdline.commands.cmd_computer._computer_get_remote_username:3
#: ../../../src/aiida/cmdline/commands/cmd_computer.py:docstring of aiida.cmdline.commands.cmd_computer._computer_test_get_jobs:3
#: ../../../src/aiida/cmdline/commands/cmd_computer.py:docstring of aiida.cmdline.commands.cmd_computer._computer_test_no_unexpected_output:7
msgid "an open transport"
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_computer.py:docstring of aiida.cmdline.commands.cmd_computer._computer_create_temp_file:7
#: ../../../src/aiida/cmdline/commands/cmd_computer.py:docstring of aiida.cmdline.commands.cmd_computer._computer_get_remote_username:4
#: ../../../src/aiida/cmdline/commands/cmd_computer.py:docstring of aiida.cmdline.commands.cmd_computer._computer_test_get_jobs:4
#: ../../../src/aiida/cmdline/commands/cmd_computer.py:docstring of aiida.cmdline.commands.cmd_computer._computer_test_no_unexpected_output:8
msgid "the corresponding scheduler class"
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_computer.py:docstring of aiida.cmdline.commands.cmd_computer._computer_create_temp_file:8
#: ../../../src/aiida/cmdline/commands/cmd_computer.py:docstring of aiida.cmdline.commands.cmd_computer._computer_test_get_jobs:5
#: ../../../src/aiida/cmdline/commands/cmd_computer.py:docstring of aiida.cmdline.commands.cmd_computer._computer_test_no_unexpected_output:9
msgid "the AuthInfo object (from which one can get computer and aiidauser)"
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_computer.py:docstring of aiida.cmdline.commands.cmd_computer._computer_create_temp_file:9
#: ../../../src/aiida/cmdline/commands/cmd_computer.py:docstring of aiida.cmdline.commands.cmd_computer._computer_get_remote_username:6
#: ../../../src/aiida/cmdline/commands/cmd_computer.py:docstring of aiida.cmdline.commands.cmd_computer._computer_test_get_jobs:6
#: ../../../src/aiida/cmdline/commands/cmd_computer.py:docstring of aiida.cmdline.commands.cmd_computer._computer_test_no_unexpected_output:10
msgid "tuple of boolean indicating success or failure and an optional string message"
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_computer.py:docstring of aiida.cmdline.commands.cmd_computer._computer_get_remote_username:1
msgid "Internal test to check if it is possible to determine the username on the remote."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_computer.py:docstring of aiida.cmdline.commands.cmd_computer._computer_get_remote_username:5
msgid "the AuthInfo object"
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_computer.py:docstring of aiida.cmdline.commands.cmd_computer._computer_test_get_jobs:1
msgid "Internal test to check if it is possible to check the queue state."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_computer.py:docstring of aiida.cmdline.commands.cmd_computer._computer_test_no_unexpected_output:1
msgid "Test that there is no unexpected output from the connection."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_computer.py:docstring of aiida.cmdline.commands.cmd_computer._computer_test_no_unexpected_output:3
msgid "This can happen if e.g. there is some spurious command in the .bashrc or .bash_profile that is not guarded in case of non-interactive shells."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_computer.py:docstring of aiida.cmdline.commands.cmd_computer._computer_use_login_shell_performance:1
msgid "Execute a command over the transport with and without the ``use_login_shell`` option enabled."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_computer.py:docstring of aiida.cmdline.commands.cmd_computer._computer_use_login_shell_performance:3
msgid "By default, AiiDA uses a login shell when connecting to a computer in order to operate in the same environment as a user connecting to the computer. However, loading the login scripts of the shell can take time, which can significantly slow down all commands executed by AiiDA and impact the throughput of calculation jobs. This test executes a simple command both with and without using a login shell and emits a warning if the login shell is slower by at least 100 ms. If the computer is already configured to avoid using a login shell, the test is skipped and the function returns a successful test result."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_computer.py:docstring of aiida.cmdline.commands.cmd_computer.get_computer_names:1
msgid "Retrieve the list of computers in the DB."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_computer.py:docstring of aiida.cmdline.commands.cmd_computer.get_parameter_default:1
msgid "Get the value for a specific parameter from the computer_builder or the default value of that option"
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_computer.py:docstring of aiida.cmdline.commands.cmd_computer.get_parameter_default:3
msgid "parameter name"
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_computer.py:docstring of aiida.cmdline.commands.cmd_computer.get_parameter_default:4
msgid "click context of the command"
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_computer.py:docstring of aiida.cmdline.commands.cmd_computer.get_parameter_default:5
msgid "parameter default value, or None"
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_computer.py:docstring of aiida.cmdline.commands.cmd_computer.set_computer_builder:1
msgid "Set the computer spec for defaults of following options."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_computer.py:docstring of aiida.cmdline.commands.cmd_computer.time_use_login_shell:1
msgid "Execute the ``whoami`` over the transport for the given ``use_login_shell`` and report the time taken."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_computer.py:docstring of aiida.cmdline.commands.cmd_computer.time_use_login_shell:3
msgid "The ``AuthInfo`` instance to use."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_computer.py:docstring of aiida.cmdline.commands.cmd_computer.time_use_login_shell:4
msgid "The base authentication parameters."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_computer.py:docstring of aiida.cmdline.commands.cmd_computer.time_use_login_shell:5
msgid "Whether to use a login shell or not."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_computer.py:docstring of aiida.cmdline.commands.cmd_computer.time_use_login_shell:6
msgid "The number of iterations of the command to call. Command will return the average call time."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_computer.py:docstring of aiida.cmdline.commands.cmd_computer.time_use_login_shell:7
msgid "The average call time of the ``Transport.whoami`` command."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_config.py:docstring of aiida.cmdline.commands.cmd_config:1
msgid "`verdi config` command."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_daemon.py:docstring of aiida.cmdline.commands.cmd_daemon:1
msgid "`verdi daemon` commands."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_daemon.py:docstring of aiida.cmdline.commands.cmd_daemon.execute_client_command:1
msgid "Execute a command of the :class:`aiida.engine.daemon.client.DaemonClient` and echo whether it failed or not."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_daemon.py:docstring of aiida.cmdline.commands.cmd_daemon.execute_client_command:3
msgid "The name of hte method."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_daemon.py:docstring of aiida.cmdline.commands.cmd_daemon.execute_client_command:4
msgid "If ``True``, the command raising an exception because the daemon was not running is not treated as a failure."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_daemon.py:docstring of aiida.cmdline.commands.cmd_daemon.execute_client_command:6
msgid "Keyword arguments that are passed to the client method."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_daemon.py:docstring of aiida.cmdline.commands.cmd_daemon.validate_daemon_workers:1
msgid "Validate the value for the number of daemon workers to start with default set by config."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_database.py:docstring of aiida.cmdline.commands.cmd_database:1
msgid "`verdi database` commands."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_devel.py:docstring of aiida.cmdline.commands.cmd_devel:1
msgid "`verdi devel` commands."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_devel.py:docstring of aiida.cmdline.commands.cmd_devel.prepare_localhost:1
msgid "Prepare and return the localhost as ``Computer``."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_devel.py:docstring of aiida.cmdline.commands.cmd_devel.prepare_localhost:3
msgid "If it doesn't already exist, the computer will be created, using ``core.local`` and ``core.direct`` as the entry points for the transport and scheduler type, respectively. In that case, the safe transport interval and the minimum job poll interval will both be set to 0 seconds in order to guarantee a throughput that is as fast as possible."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_devel.py:docstring of aiida.cmdline.commands.cmd_devel.prepare_localhost:7
msgid "The localhost configured as a ``Computer``."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_group.py:docstring of aiida.cmdline.commands.cmd_group:1
msgid "`verdi group` commands"
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_help.py:docstring of aiida.cmdline.commands.cmd_help:1
msgid "Command for `verdi help`."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_node.py:docstring of aiida.cmdline.commands.cmd_node:1
msgid "`verdi node` command."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_node.py:docstring of aiida.cmdline.commands.cmd_node.echo_node_dict:1
msgid "Show the attributes or extras of one or more nodes."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_plugin.py:docstring of aiida.cmdline.commands.cmd_plugin:1
msgid "Command for `verdi plugins`."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_process.py:docstring of aiida.cmdline.commands.cmd_process:1
msgid "`verdi process` command."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_process.py:docstring of aiida.cmdline.commands.cmd_process.default_projections:1
msgid "Return list of default projections for the ``--project`` option of ``verdi process list``."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_process.py:docstring of aiida.cmdline.commands.cmd_process.default_projections:3
#: ../../../src/aiida/cmdline/commands/cmd_process.py:docstring of aiida.cmdline.commands.cmd_process.valid_projections:3
msgid "This indirection is necessary to prevent loading the imported module which slows down tab-completion."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_process.py:docstring of aiida.cmdline.commands.cmd_process.valid_projections:1
msgid "Return list of valid projections for the ``--project`` option of ``verdi process list``."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_profile.py:docstring of aiida.cmdline.commands.cmd_profile:1
msgid "`verdi profile` command."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_profile.py:docstring of aiida.cmdline.commands.cmd_profile._strip_private_keys:1
msgid "Remove private keys (starting `_`) from the dictionary."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_profile.py:docstring of aiida.cmdline.commands.cmd_profile.command_create_profile:1
#: ../../../src/aiida/manage/configuration/__init__.py:docstring of aiida.manage.configuration.create_profile:1
msgid "Create a new profile, initialise its storage and create a default user."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_profile.py:docstring of aiida.cmdline.commands.cmd_profile.command_create_profile:3
msgid "The context of the CLI command."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_profile.py:docstring of aiida.cmdline.commands.cmd_profile.command_create_profile:4
#: ../../../src/aiida/manage/configuration/__init__.py:docstring of aiida.manage.configuration.create_profile:4
msgid "The storage class obtained through loading the entry point from ``aiida.storage`` group."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_profile.py:docstring of aiida.cmdline.commands.cmd_profile.command_create_profile:5
msgid "Whether the command was invoked interactively or not."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_profile.py:docstring of aiida.cmdline.commands.cmd_profile.command_create_profile:6
msgid "The profile instance. This is an empty ``Profile`` instance created by the command line argument which currently only contains the selected profile name for the profile that is to be created."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_profile.py:docstring of aiida.cmdline.commands.cmd_profile.command_create_profile:8
msgid "Whether to set the created profile as the new default."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_profile.py:docstring of aiida.cmdline.commands.cmd_profile.command_create_profile:9
#: ../../../src/aiida/manage/configuration/__init__.py:docstring of aiida.manage.configuration.create_profile:10
msgid "Arguments to initialise instance of the selected storage implementation."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_rabbitmq.py:docstring of aiida.cmdline.commands.cmd_rabbitmq:1
msgid "`verdi devel rabbitmq` commands."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_rabbitmq.py:docstring of aiida.cmdline.commands.cmd_rabbitmq.echo_response:1
msgid "Echo the response of a request."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_rabbitmq.py:docstring of aiida.cmdline.commands.cmd_rabbitmq.echo_response:3
msgid "The response to the request."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_rabbitmq.py:docstring of aiida.cmdline.commands.cmd_rabbitmq.echo_response:4
msgid "Boolean, if ``True``, call ``sys.exit`` with the status code of the response."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_rabbitmq.py:docstring of aiida.cmdline.commands.cmd_rabbitmq.with_client:1
msgid "Decorate a function injecting a :class:`aiida.manage.external.rmq.client.RabbitmqManagementClient`."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_restapi.py:docstring of aiida.cmdline.commands.cmd_restapi:1
msgid "This allows to hook-up the AiiDA built-in RESTful API. Main advantage of doing this by means of a verdi command is that different profiles can be selected at hook-up (-p flag)."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_run.py:docstring of aiida.cmdline.commands.cmd_run:1
msgid "`verdi run` command."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_run.py:docstring of aiida.cmdline.commands.cmd_run.update_environment:1
msgid "Context manager that temporarily replaces `sys.argv` with `argv` and adds current working dir to the path."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_run.py:docstring of aiida.cmdline.commands.cmd_run.validate_entry_point_strings:1
msgid "Validate that `value` is a valid entrypoint string."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_setup.py:docstring of aiida.cmdline.commands.cmd_setup:1
msgid "The `verdi setup` and `verdi quicksetup` commands."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_setup.py:docstring of aiida.cmdline.commands.cmd_setup._store_default_user_settings:1
msgid "Store the default user settings if not already present."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_shell.py:docstring of aiida.cmdline.commands.cmd_shell:1
msgid "The verdi shell command"
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_status.py:docstring of aiida.cmdline.commands.cmd_status:1
msgid "`verdi status` command."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_status.py:docstring of aiida.cmdline.commands.cmd_status.ServiceStatus:1
#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.ExitCode:1
#: ../../../src/aiida/common/datastructures.py:docstring of aiida.common.datastructures.CodeRunMode:1
msgid "Bases: :py:class:`~enum.IntEnum`"
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_status.py:docstring of aiida.cmdline.commands.cmd_status.ServiceStatus:1
msgid "Describe status of services for 'verdi status' command."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_status.py:docstring of aiida.cmdline.commands.cmd_status.ServiceStatus.__format__:1
#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.ExitCode.__format__:1
#: ../../../src/aiida/common/datastructures.py:docstring of aiida.common.datastructures.CodeRunMode.__format__:1
msgid "Default object formatter."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_status.py:docstring of aiida.cmdline.commands.cmd_status.print_status:1
msgid "Print status message."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_status.py:docstring of aiida.cmdline.commands.cmd_status.print_status:3
msgid "Includes colored indicator."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_status.py:docstring of aiida.cmdline.commands.cmd_status.print_status:5
msgid "a ServiceStatus code"
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_status.py:docstring of aiida.cmdline.commands.cmd_status.print_status:6
msgid "string for service name"
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_status.py:docstring of aiida.cmdline.commands.cmd_status.print_status:7
msgid "message string"
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_storage.py:docstring of aiida.cmdline.commands.cmd_storage:1
msgid "`verdi storage` commands."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_user.py:docstring of aiida.cmdline.commands.cmd_user:1
msgid "`verdi user` command."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_verdi.py:docstring of aiida.cmdline.commands.cmd_verdi:1
msgid "The main `verdi` click group."
msgstr ""

#: ../../source/reference/apidoc/aiida.cmdline.commands.cmd_data.rst:2
msgid "aiida.cmdline.commands.cmd\\_data package"
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_data/__init__.py:docstring of aiida.cmdline.commands.cmd_data:1
msgid "The `verdi data` command line interface."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_data/cmd_array.py:docstring of aiida.cmdline.commands.cmd_data.cmd_array:1
msgid "`verdi data core.array` command."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_data/cmd_bands.py:docstring of aiida.cmdline.commands.cmd_data.cmd_bands:1
msgid "`verdi data core.bands` command."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_data/cmd_cif.py:docstring of aiida.cmdline.commands.cmd_data.cmd_cif:1
msgid "`verdi data core.cif` command."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_data/cmd_dict.py:docstring of aiida.cmdline.commands.cmd_data.cmd_dict:1
msgid "`verdi data core.dict` command."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_data/cmd_export.py:docstring of aiida.cmdline.commands.cmd_data.cmd_export:1
msgid "This module provides export functionality to all data types"
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_data/cmd_export.py:docstring of aiida.cmdline.commands.cmd_data.cmd_export.data_export:1
msgid "Depending on the parameters, either print the (single) output file on screen, or store the file(s) on disk."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_data/cmd_export.py:docstring of aiida.cmdline.commands.cmd_data.cmd_export.data_export:4
msgid "the Data node to print or store on disk"
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_data/cmd_export.py:docstring of aiida.cmdline.commands.cmd_data.cmd_export.data_export:5
msgid "The filename to store the main file. If empty or None, print instead"
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_data/cmd_export.py:docstring of aiida.cmdline.commands.cmd_data.cmd_export.data_export:7
msgid "a string to pass to the _exportcontent method"
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_data/cmd_export.py:docstring of aiida.cmdline.commands.cmd_data.cmd_export.data_export:8
msgid "a dictionary with additional kwargs to pass to _exportcontent"
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_data/cmd_export.py:docstring of aiida.cmdline.commands.cmd_data.cmd_export.data_export:9
msgid "if False, stops if any file already exists (when output_fname is not empty"
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_data/cmd_export.py:docstring of aiida.cmdline.commands.cmd_data.cmd_export.data_export:12
msgid "this function calls directly sys.exit(1) when an error occurs (or e.g. if check_overwrite is True and a file already exists)."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_data/cmd_list.py:docstring of aiida.cmdline.commands.cmd_data.cmd_list:1
msgid "This module provides list functionality to all data types."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_data/cmd_list.py:docstring of aiida.cmdline.commands.cmd_data.cmd_list.data_list:1
msgid "List stored objects"
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_data/cmd_list.py:docstring of aiida.cmdline.commands.cmd_data.cmd_list.list_options:1
msgid "Creates a decorator with all the options."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_data/cmd_list.py:docstring of aiida.cmdline.commands.cmd_data.cmd_list.query:1
msgid "Perform the query"
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_data/cmd_remote.py:docstring of aiida.cmdline.commands.cmd_data.cmd_remote:1
msgid "`verdi data core.remote` command."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_data/cmd_show.py:docstring of aiida.cmdline.commands.cmd_data.cmd_show:1
msgid "This allows to manage showfunctionality to all data types."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_data/cmd_show.py:docstring of aiida.cmdline.commands.cmd_data.cmd_show._show_ase:1
msgid "Plugin to show the structure with the ASE visualizer"
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_data/cmd_show.py:docstring of aiida.cmdline.commands.cmd_data.cmd_show._show_jmol:1
msgid "Plugin for jmol"
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_data/cmd_show.py:docstring of aiida.cmdline.commands.cmd_data.cmd_show._show_mpl_heatmap:1
#: ../../../src/aiida/cmdline/commands/cmd_data/cmd_show.py:docstring of aiida.cmdline.commands.cmd_data.cmd_show._show_mpl_pos:1
msgid "Produces a matplotlib plot of the trajectory"
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_data/cmd_show.py:docstring of aiida.cmdline.commands.cmd_data.cmd_show._show_vesta:1
msgid "Plugin for VESTA This VESTA plugin was added by Yue-Wen FANG and Abel Carreras at Kyoto University in the group of Prof. Isao Tanaka's lab"
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_data/cmd_show.py:docstring of aiida.cmdline.commands.cmd_data.cmd_show._show_vmd:1
msgid "Plugin for vmd"
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_data/cmd_show.py:docstring of aiida.cmdline.commands.cmd_data.cmd_show._show_xcrysden:1
msgid "Plugin for xcrysden"
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_data/cmd_show.py:docstring of aiida.cmdline.commands.cmd_data.cmd_show._show_xmgrace:1
msgid "Plugin for showing the bands with the XMGrace plotting software."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_data/cmd_show.py:docstring of aiida.cmdline.commands.cmd_data.cmd_show.has_executable:1
msgid "True if executable can be found in PATH, False otherwise."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_data/cmd_singlefile.py:docstring of aiida.cmdline.commands.cmd_data.cmd_singlefile:1
msgid "`verdi data singlefile` command."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_data/cmd_structure.py:docstring of aiida.cmdline.commands.cmd_data.cmd_structure:1
msgid "`verdi data core.structure` command."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_data/cmd_structure.py:docstring of aiida.cmdline.commands.cmd_data.cmd_structure._store_structure:1
msgid "Store a structure and print a message (or don't store it if it's a dry_run)"
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_data/cmd_structure.py:docstring of aiida.cmdline.commands.cmd_data.cmd_structure._store_structure:3
msgid "This is a utility function to avoid code duplication."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_data/cmd_structure.py:docstring of aiida.cmdline.commands.cmd_data.cmd_structure._store_structure:5
msgid "an unstored StructureData"
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_data/cmd_structure.py:docstring of aiida.cmdline.commands.cmd_data.cmd_structure._store_structure:6
msgid "if True, do not store but print a different message"
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_data/cmd_trajectory.py:docstring of aiida.cmdline.commands.cmd_data.cmd_trajectory:1
msgid "`verdi data core.trajectory` command."
msgstr ""

#: ../../../src/aiida/cmdline/commands/cmd_data/cmd_upf.py:docstring of aiida.cmdline.commands.cmd_data.cmd_upf:1
msgid "`verdi data core.upf` command."
msgstr ""

#: ../../source/reference/apidoc/aiida.cmdline.groups.rst:2
msgid "aiida.cmdline.groups package"
msgstr ""

#: ../../../src/aiida/cmdline/groups/__init__.py:docstring of aiida.cmdline.groups:1
msgid "Module with custom implementations of :class:`click.Group`."
msgstr ""

#: ../../../src/aiida/cmdline/groups/dynamic.py:docstring of aiida.cmdline.groups.dynamic:1
#: ../../../src/aiida/cmdline/groups/dynamic.py:docstring of aiida.cmdline.groups.dynamic.DynamicEntryPointCommandGroup:1
msgid "Subclass of :class:`click.Group` that loads subcommands dynamically from entry points."
msgstr ""

#: ../../../src/aiida/cmdline/groups/dynamic.py:docstring of aiida.cmdline.groups.dynamic.DynamicEntryPointCommandGroup:3
msgid "A command group using this class will automatically generate the sub commands from the entry points registered in the given ``entry_point_group``. The entry points can be additionally filtered using a regex defined for the ``entry_point_name_filter`` keyword. The actual command for each entry point is defined by ``command``, which should take as a first argument the class that corresponds to the entry point. In addition, it should accept ``kwargs`` which will be the values for the options passed when the command is invoked. The help string of the command will be provided by the docstring of the class registered at the respective entry point. Example usage:"
msgstr ""

#: ../../../src/aiida/cmdline/groups/dynamic.py:docstring of aiida.cmdline.groups.dynamic.DynamicEntryPointCommandGroup.create_command:1
msgid "Create a subcommand for the given ``entry_point``."
msgstr ""

#: ../../../src/aiida/cmdline/groups/dynamic.py:docstring of aiida.cmdline.groups.dynamic.DynamicEntryPointCommandGroup.create_option:1
msgid "Create a click option from a name and a specification."
msgstr ""

#: ../../../src/aiida/cmdline/groups/dynamic.py:docstring of aiida.cmdline.groups.dynamic.DynamicEntryPointCommandGroup.create_options:1
msgid "Create the option decorators for the command function for the given entry point."
msgstr ""

#: ../../../src/aiida/cmdline/groups/dynamic.py:docstring of aiida.cmdline.groups.dynamic.DynamicEntryPointCommandGroup.create_options:3
#: ../../../src/aiida/cmdline/groups/dynamic.py:docstring of aiida.cmdline.groups.dynamic.DynamicEntryPointCommandGroup.list_options:3
msgid "The entry point."
msgstr ""

#: ../../../src/aiida/cmdline/groups/dynamic.py:docstring of aiida.cmdline.groups.dynamic.DynamicEntryPointCommandGroup.get_command:1
msgid "Return the command with the given name."
msgstr ""

#: ../../../src/aiida/cmdline/groups/dynamic.py:docstring of aiida.cmdline.groups.dynamic.DynamicEntryPointCommandGroup.get_command:3
#: ../../../src/aiida/cmdline/groups/dynamic.py:docstring of aiida.cmdline.groups.dynamic.DynamicEntryPointCommandGroup.list_commands:3
msgid "The :class:`click.Context`."
msgstr ""

#: ../../../src/aiida/cmdline/groups/dynamic.py:docstring of aiida.cmdline.groups.dynamic.DynamicEntryPointCommandGroup.get_command:4
msgid "The name of the command."
msgstr ""

#: ../../../src/aiida/cmdline/groups/dynamic.py:docstring of aiida.cmdline.groups.dynamic.DynamicEntryPointCommandGroup.get_command:5
msgid "The :class:`click.Command`."
msgstr ""

#: ../../../src/aiida/cmdline/groups/dynamic.py:docstring of aiida.cmdline.groups.dynamic.DynamicEntryPointCommandGroup.list_commands:1
msgid "Return the sorted list of subcommands for this group."
msgstr ""

#: ../../../src/aiida/cmdline/groups/dynamic.py:docstring of aiida.cmdline.groups.dynamic.DynamicEntryPointCommandGroup.list_options:1
msgid "Return the list of options that should be applied to the command for the given entry point."
msgstr ""

#: ../../../src/aiida/cmdline/groups/verdi.py:docstring of aiida.cmdline.groups.verdi:1
#: ../../../src/aiida/cmdline/groups/verdi.py:docstring of aiida.cmdline.groups.verdi.VerdiCommandGroup:1
msgid "Subclass of :class:`click.Group` for the ``verdi`` CLI."
msgstr ""

#: ../../../src/aiida/cmdline/groups/verdi.py:docstring of aiida.cmdline.groups.verdi.LazyConfigAttributeDict:1
#: ../../../src/aiida/common/extendeddicts.py:docstring of aiida.common.extendeddicts.DefaultFieldsAttributeDict:1
#: ../../../src/aiida/common/extendeddicts.py:docstring of aiida.common.extendeddicts.FixedFieldsAttributeDict:1
#: ../../../src/aiida/engine/processes/exit_code.py:docstring of aiida.engine.processes.exit_code.ExitCodesNamespace:1
msgid "Bases: :py:class:`~aiida.common.extendeddicts.AttributeDict`"
msgstr ""

#: ../../../src/aiida/cmdline/groups/verdi.py:docstring of aiida.cmdline.groups.verdi.LazyConfigAttributeDict:1
msgid "Subclass of ``AttributeDict`` that lazily calls :meth:`aiida.manage.configuration.get_config`."
msgstr ""

#: ../../../src/aiida/cmdline/groups/verdi.py:docstring of aiida.cmdline.groups.verdi.LazyConfigAttributeDict.__getattr__:1
msgid "Override of ``AttributeDict.__getattr__`` for lazily loading the config key."
msgstr ""

#: ../../../src/aiida/cmdline/groups/verdi.py:docstring of aiida.cmdline.groups.verdi.LazyConfigAttributeDict.__getattr__:3
msgid "The attribute to return."
msgstr ""

#: ../../../src/aiida/cmdline/groups/verdi.py:docstring of aiida.cmdline.groups.verdi.LazyConfigAttributeDict.__getattr__:4
msgid "The value of the attribute."
msgstr ""

#: ../../../src/aiida/cmdline/groups/verdi.py:docstring of aiida.cmdline.groups.verdi.LazyConfigAttributeDict.__getattr__:5
msgid "If the attribute does not correspond to an existing key."
msgstr ""

#: ../../../src/aiida/cmdline/groups/verdi.py:docstring of aiida.cmdline.groups.verdi.LazyConfigAttributeDict.__getattr__:6
msgid "If loading of the configuration fails."
msgstr ""

#: ../../../src/aiida/cmdline/groups/verdi.py:docstring of aiida.cmdline.groups.verdi.LazyConfigAttributeDict.__init__:1
#: ../../../src/aiida/common/extendeddicts.py:docstring of aiida.common.extendeddicts.AttributeDict.__init__:1
#: ../../../src/aiida/common/extendeddicts.py:docstring of aiida.common.extendeddicts.FixedFieldsAttributeDict.__init__:1
msgid "Recursively turn the `dict` and all its nested dictionaries into `AttributeDict` instance."
msgstr ""

#: ../../../src/aiida/cmdline/groups/verdi.py:docstring of aiida.cmdline.groups.verdi.VerdiCommandGroup:1
msgid "Bases: :py:class:`~click.core.Group`"
msgstr ""

#: ../../../src/aiida/cmdline/groups/verdi.py:docstring of aiida.cmdline.groups.verdi.VerdiCommandGroup:3
msgid "The class automatically adds the verbosity option to all commands in the interface. It also adds some functionality to provide suggestions of commands in case the user provided command name does not exist."
msgstr ""

#: ../../../src/aiida/cmdline/groups/verdi.py:docstring of aiida.cmdline.groups.verdi.VerdiCommandGroup.add_verbosity_option:1
msgid "Apply the ``verbosity`` option to the command, which is common to all ``verdi`` commands."
msgstr ""

#: ../../../src/aiida/cmdline/groups/verdi.py:docstring of aiida.cmdline.groups.verdi.VerdiCommandGroup.fail_with_suggestions:1
msgid "Fail the command while trying to suggest commands to resemble the requested ``cmd_name``."
msgstr ""

#: ../../../src/aiida/cmdline/groups/verdi.py:docstring of aiida.cmdline.groups.verdi.VerdiCommandGroup.group:1
msgid "Ensure that sub command groups use the same class but do not override an explicitly set value."
msgstr ""

#: ../../../src/aiida/cmdline/groups/verdi.py:docstring of aiida.cmdline.groups.verdi.VerdiContext:1
msgid "Bases: :py:class:`~click.core.Context`"
msgstr ""

#: ../../../src/aiida/cmdline/groups/verdi.py:docstring of aiida.cmdline.groups.verdi.VerdiContext:1
msgid "Custom context implementation that defines the ``obj`` user object and adds the ``Config`` instance."
msgstr ""

#: ../../source/reference/apidoc/aiida.cmdline.params.rst:2
msgid "aiida.cmdline.params package"
msgstr ""

#: ../../../src/aiida/cmdline/params/__init__.py:docstring of aiida.cmdline.params:1
msgid "Commandline parameters."
msgstr ""

#: ../../source/reference/apidoc/aiida.cmdline.params.arguments.rst:2
msgid "aiida.cmdline.params.arguments package"
msgstr ""

#: ../../../src/aiida/cmdline/params/arguments/main.py:docstring of aiida.cmdline.params.arguments.main:1
msgid "Module with pre-defined reusable commandline arguments that can be used as `click` decorators."
msgstr ""

#: ../../../src/aiida/cmdline/params/arguments/overridable.py:docstring of aiida.cmdline.params.arguments.overridable:1
msgid "Convenience class which can be used to defined a set of commonly used arguments that can be easily reused."
msgstr ""

#: ../../../src/aiida/cmdline/params/arguments/overridable.py:docstring of aiida.cmdline.params.arguments.overridable.OverridableArgument:1
#: ../../../src/aiida/cmdline/params/options/overridable.py:docstring of aiida.cmdline.params.options.overridable.OverridableOption:1
#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder:1
#: ../../../src/aiida/common/progress_reporter.py:docstring of aiida.common.progress_reporter.ProgressReporterAbstract:1
#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.ArrayCounter:1
#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.Capturing:1
#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.DatetimePrecision:1
#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.ErrorAccumulator:1
#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.Prettifier:1
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient:1
#: ../../../src/aiida/engine/processes/calcjobs/manager.py:docstring of aiida.engine.processes.calcjobs.manager.JobManager:1
#: ../../../src/aiida/engine/processes/calcjobs/manager.py:docstring of aiida.engine.processes.calcjobs.manager.JobsList:1
#: ../../../src/aiida/engine/processes/calcjobs/monitors.py:docstring of aiida.engine.processes.calcjobs.monitors.CalcJobMonitor:1
#: ../../../src/aiida/engine/processes/calcjobs/monitors.py:docstring of aiida.engine.processes.calcjobs.monitors.CalcJobMonitorResult:1
#: ../../../src/aiida/engine/processes/calcjobs/monitors.py:docstring of aiida.engine.processes.calcjobs.monitors.CalcJobMonitors:1
#: ../../../src/aiida/engine/processes/ports.py:docstring of aiida.engine.processes.ports.WithMetadata:1
#: ../../../src/aiida/engine/processes/ports.py:docstring of aiida.engine.processes.ports.WithNonDb:1
#: ../../../src/aiida/engine/processes/ports.py:docstring of aiida.engine.processes.ports.WithSerialize:1
#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner:1
#: ../../../src/aiida/engine/transports.py:docstring of aiida.engine.transports.TransportQueue:1
#: ../../../src/aiida/engine/transports.py:docstring of aiida.engine.transports.TransportRequest:1
#: ../../../src/aiida/manage/caching.py:docstring of aiida.manage.caching._ContextCache:1
#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config:1
#: ../../../src/aiida/manage/configuration/options.py:docstring of aiida.manage.configuration.options.Option:1
#: ../../../src/aiida/manage/configuration/profile.py:docstring of aiida.manage.configuration.profile.Profile:1
#: ../../../src/aiida/manage/external/rmq/client.py:docstring of aiida.manage.external.rmq.client.RabbitmqManagementClient:1
#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager:1
#: ../../../src/aiida/manage/profile_access.py:docstring of aiida.manage.profile_access.ProfileAccessManager:1
#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.EntryPointManager:1
#: ../../../src/aiida/orm/autogroup.py:docstring of aiida.orm.autogroup.AutogroupManager:1
#: ../../../src/aiida/orm/extras.py:docstring of aiida.orm.extras.EntityExtras:1
#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.GroupBase:1
#: ../../../src/aiida/orm/nodes/attributes.py:docstring of aiida.orm.nodes.attributes.NodeAttributes:1
#: ../../../src/aiida/orm/nodes/caching.py:docstring of aiida.orm.nodes.caching.NodeCaching:1
#: ../../../src/aiida/orm/nodes/comments.py:docstring of aiida.orm.nodes.comments.NodeComments:1
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.Kind:1
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.Site:1
#: ../../../src/aiida/orm/nodes/links.py:docstring of aiida.orm.nodes.links.NodeLinks:1
#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.NodeBase:1
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository:1
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder:1
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder._QueryTagMap:1
#: ../../../src/aiida/orm/utils/builders/code.py:docstring of aiida.orm.utils.builders.code.CodeBuilder:1
#: ../../../src/aiida/orm/utils/builders/computer.py:docstring of aiida.orm.utils.builders.computer.ComputerBuilder:1
#: ../../../src/aiida/orm/utils/calcjob.py:docstring of aiida.orm.utils.calcjob.CalcJobResultManager:1
#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links.LinkManager:1
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader:1
#: ../../../src/aiida/orm/utils/managers.py:docstring of aiida.orm.utils.managers.AttributeManager:1
#: ../../../src/aiida/orm/utils/managers.py:docstring of aiida.orm.utils.managers.NodeLinksManager:1
#: ../../../src/aiida/orm/utils/mixins.py:docstring of aiida.orm.utils.mixins.FunctionCalculationMixin:1
#: ../../../src/aiida/orm/utils/mixins.py:docstring of aiida.orm.utils.mixins.Sealable:1
#: ../../../src/aiida/plugins/utils.py:docstring of aiida.plugins.utils.PluginVersionProvider:1
#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend:1
#: ../../../src/aiida/repository/common.py:docstring of aiida.repository.common.File:1
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository:1
#: ../../../src/aiida/restapi/common/utils.py:docstring of aiida.restapi.common.utils.Utils:1
#: ../../../src/aiida/restapi/translator/base.py:docstring of aiida.restapi.translator.base.BaseTranslator:1
#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobTemplateCodeInfo:1
#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler:1
#: ../../../src/aiida/storage/psql_dos/alembic_cli.py:docstring of aiida.storage.psql_dos.alembic_cli.AlembicRunner:1
#: ../../../src/aiida/storage/psql_dos/migrations/utils/reflect.py:docstring of aiida.storage.psql_dos.migrations.utils.reflect.ReflectMigrations:1
#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator:1
#: ../../../src/aiida/storage/psql_dos/models/base.py:docstring of aiida.storage.psql_dos.models.base.Model:1
#: ../../../src/aiida/storage/psql_dos/orm/extras_mixin.py:docstring of aiida.storage.psql_dos.orm.extras_mixin.ExtrasMixin:1
#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.JoinReturn:1
#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.SqlaJoiner:1
#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.BuiltQuery:1
#: ../../../src/aiida/storage/psql_dos/orm/utils.py:docstring of aiida.storage.psql_dos.orm.utils.ModelWrapper:1
#: ../../../src/aiida/storage/sqlite_zip/models.py:docstring of aiida.storage.sqlite_zip.models.SqliteModel:1
#: ../../../src/aiida/storage/sqlite_zip/orm.py:docstring of aiida.storage.sqlite_zip.orm.SqliteEntityOverride:1
#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports.CommentTransform:1
#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports.GroupTransform:1
#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports.NodeTransform:1
#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports.QueryParams:1
#: ../../../src/aiida/tools/calculations/base.py:docstring of aiida.tools.calculations.base.CalculationTools:1
#: ../../../src/aiida/tools/data/orbital/orbital.py:docstring of aiida.tools.data.orbital.orbital.Orbital:1
#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbEntry:1
#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbImporter:1
#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbSearchResults:1
#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbSearchResults.DbSearchResultsIterator:1
#: ../../../src/aiida/tools/dbimporters/plugins/mpds.py:docstring of aiida.tools.dbimporters.plugins.mpds.StructuresCollection:1
#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.AbstractSetContainer:1
#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.Basket:1
#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.Operation:1
#: ../../../src/aiida/tools/groups/paths.py:docstring of aiida.tools.groups.paths.GroupAttr:1
#: ../../../src/aiida/tools/groups/paths.py:docstring of aiida.tools.groups.paths.GroupPath:1
#: ../../../src/aiida/tools/query/calculation.py:docstring of aiida.tools.query.calculation.CalculationQueryBuilder:1
#: ../../../src/aiida/tools/query/mapping.py:docstring of aiida.tools.query.mapping.ProjectionMapper:1
#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph:1
msgid "Bases: :py:class:`object`"
msgstr ""

#: ../../../src/aiida/cmdline/params/arguments/overridable.py:docstring of aiida.cmdline.params.arguments.overridable.OverridableArgument:1
msgid "Wrapper around click.argument that increases reusability."
msgstr ""

#: ../../../src/aiida/cmdline/params/arguments/overridable.py:docstring of aiida.cmdline.params.arguments.overridable.OverridableArgument:3
msgid "Once defined, the argument can be reused with a consistent name and sensible defaults while other details can be customized on a per-command basis."
msgstr ""

#: ../../../src/aiida/cmdline/params/arguments/overridable.py:docstring of aiida.cmdline.params.arguments.overridable.OverridableArgument:6
#: ../../../src/aiida/cmdline/params/options/config.py:docstring of aiida.cmdline.params.options.config.ConfigFileOption:3
#: ../../../src/aiida/cmdline/params/options/overridable.py:docstring of aiida.cmdline.params.options.overridable.OverridableOption:10
#: ../../../src/aiida/cmdline/utils/decorators.py:docstring of aiida.cmdline.utils.decorators.check_circus_zmq_version:3
#: ../../../src/aiida/cmdline/utils/decorators.py:docstring of aiida.cmdline.utils.decorators.deprecated_command:3
#: ../../../src/aiida/cmdline/utils/decorators.py:docstring of aiida.cmdline.utils.decorators.only_if_daemon_not_running:8
#: ../../../src/aiida/cmdline/utils/decorators.py:docstring of aiida.cmdline.utils.decorators.only_if_daemon_running:8
#: ../../../src/aiida/cmdline/utils/decorators.py:docstring of aiida.cmdline.utils.decorators.requires_loaded_profile:3
#: ../../../src/aiida/cmdline/utils/decorators.py:docstring of aiida.cmdline.utils.decorators.with_dbenv:5
#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres:9
#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveReaderAbstract.get:3
#: ../../../src/aiida/tools/ipython/ipython_magics.py:docstring of aiida.tools.ipython.ipython_magics.add_to_ns:7
msgid "Example::"
msgstr ""

#: ../../../src/aiida/cmdline/params/arguments/overridable.py:docstring of aiida.cmdline.params.arguments.overridable.OverridableArgument:18
msgid "Notice that the arguments, which are used to define the name of the argument and based on which the function argument name is determined, can be overridden."
msgstr ""

#: ../../../src/aiida/cmdline/params/arguments/overridable.py:docstring of aiida.cmdline.params.arguments.overridable.OverridableArgument.__call__:1
msgid "Override the stored kwargs with the passed kwargs and return the argument."
msgstr ""

#: ../../../src/aiida/cmdline/params/arguments/overridable.py:docstring of aiida.cmdline.params.arguments.overridable.OverridableArgument.__call__:3
msgid "The stored args are used only if they are not provided. This allows the user to override the variable name, which is useful if for example they want to allow multiple value with ``nargs=-1`` and want to pluralize the function argument for consistency."
msgstr ""

#: ../../../src/aiida/cmdline/params/arguments/overridable.py:docstring of aiida.cmdline.params.arguments.overridable.OverridableArgument.__init__:1
msgid "Store the default args and kwargs"
msgstr ""

#: ../../docstring of aiida.cmdline.params.arguments.overridable.OverridableArgument.__weakref__:1
#: ../../docstring of aiida.cmdline.params.options.overridable.OverridableOption.__weakref__:1
#: ../../docstring of aiida.common.exceptions.AiidaException.__weakref__:1
#: ../../docstring of aiida.common.exceptions.NotExistentAttributeError.__weakref__:1
#: ../../docstring of aiida.common.exceptions.NotExistentKeyError.__weakref__:1
#: ../../docstring of aiida.common.exceptions.UnsupportedSpeciesError.__weakref__:1
#: ../../docstring of aiida.common.extendeddicts.AttributeDict.__weakref__:1
#: ../../docstring of aiida.common.folders.Folder.__weakref__:1
#: ../../docstring of aiida.common.lang.classproperty.__weakref__:1
#: ../../docstring of aiida.common.progress_reporter.ProgressReporterAbstract.__weakref__:1
#: ../../docstring of aiida.common.utils.ArrayCounter.__weakref__:1
#: ../../docstring of aiida.common.utils.Capturing.__weakref__:1
#: ../../docstring of aiida.common.utils.DatetimePrecision.__weakref__:1
#: ../../docstring of aiida.common.utils.ErrorAccumulator.__weakref__:1
#: ../../docstring of aiida.common.utils.Prettifier.__weakref__:1
#: ../../docstring of aiida.common.warnings.AiidaDeprecationWarning.__weakref__:1
#: ../../docstring of aiida.common.warnings.AiidaEntryPointWarning.__weakref__:1
#: ../../docstring of aiida.common.warnings.AiidaTestWarning.__weakref__:1
#: ../../docstring of aiida.engine.daemon.client.DaemonClient.__weakref__:1
#: ../../docstring of aiida.engine.processes.builder.ProcessBuilderNamespace.__weakref__:1
#: ../../docstring of aiida.engine.processes.calcjobs.importer.CalcJobImporter.__weakref__:1
#: ../../docstring of aiida.engine.processes.calcjobs.manager.JobManager.__weakref__:1
#: ../../docstring of aiida.engine.processes.calcjobs.manager.JobsList.__weakref__:1
#: ../../docstring of aiida.engine.processes.calcjobs.monitors.CalcJobMonitor.__weakref__:1
#: ../../docstring of aiida.engine.processes.calcjobs.monitors.CalcJobMonitorResult.__weakref__:1
#: ../../docstring of aiida.engine.processes.calcjobs.monitors.CalcJobMonitors.__weakref__:1
#: ../../docstring of aiida.engine.processes.calcjobs.tasks.PreSubmitException.__weakref__:1
#: ../../docstring of aiida.engine.processes.functions.ProcessFunctionType.__weakref__:1
#: ../../docstring of aiida.engine.processes.ports.WithMetadata.__weakref__:1
#: ../../docstring of aiida.engine.processes.ports.WithNonDb.__weakref__:1
#: ../../docstring of aiida.engine.processes.ports.WithSerialize.__weakref__:1
#: ../../docstring of aiida.engine.runners.Runner.__weakref__:1
#: ../../docstring of aiida.engine.transports.TransportQueue.__weakref__:1
#: ../../docstring of aiida.engine.transports.TransportRequest.__weakref__:1
#: ../../docstring of aiida.manage.caching._ContextCache.__weakref__:1
#: ../../docstring of aiida.manage.configuration.config.Config.__weakref__:1
#: ../../docstring of aiida.manage.configuration.config.ConfigSchema.__weakref__:1
#: ../../docstring of aiida.manage.configuration.config.ConfigVersionSchema.__weakref__:1
#: ../../docstring of aiida.manage.configuration.config.ProcessControlConfig.__weakref__:1
#: ../../docstring of aiida.manage.configuration.config.ProfileOptionsSchema.__weakref__:1
#: ../../docstring of aiida.manage.configuration.config.ProfileSchema.__weakref__:1
#: ../../docstring of aiida.manage.configuration.config.ProfileStorageConfig.__weakref__:1
#: ../../docstring of aiida.manage.configuration.migrations.migrations.SingleMigration.__weakref__:1
#: ../../docstring of aiida.manage.configuration.options.Option.__weakref__:1
#: ../../docstring of aiida.manage.configuration.profile.Profile.__weakref__:1
#: ../../docstring of aiida.manage.external.rmq.client.RabbitmqManagementClient.__weakref__:1
#: ../../docstring of aiida.manage.manager.Manager.__weakref__:1
#: ../../docstring of aiida.manage.profile_access.ProfileAccessManager.__weakref__:1
#: ../../docstring of aiida.manage.tests.pytest_fixtures.EntryPointManager.__weakref__:1
#: ../../docstring of aiida.orm.autogroup.AutogroupManager.__weakref__:1
#: ../../docstring of aiida.orm.convert.ConvertIterator.__weakref__:1
#: ../../docstring of aiida.orm.entities.Collection.__weakref__:1
#: ../../docstring of aiida.orm.entities.Entity.__weakref__:1
#: ../../docstring of aiida.orm.extras.EntityExtras.__weakref__:1
#: ../../docstring of aiida.orm.groups.GroupBase.__weakref__:1
#: ../../docstring of aiida.orm.implementation.entities.BackendCollection.__weakref__:1
#: ../../docstring of aiida.orm.implementation.entities.BackendEntity.__weakref__:1
#: ../../docstring of aiida.orm.implementation.entities.BackendEntityExtrasMixin.__weakref__:1
#: ../../docstring of aiida.orm.implementation.groups.NodeIterator.__weakref__:1
#: ../../docstring of aiida.orm.implementation.querybuilder.BackendQueryBuilder.__weakref__:1
#: ../../docstring of aiida.orm.implementation.querybuilder.PathItemType.__weakref__:1
#: ../../docstring of aiida.orm.implementation.querybuilder.QueryDictType.__weakref__:1
#: ../../docstring of aiida.orm.implementation.storage_backend.StorageBackend.__weakref__:1
#: ../../docstring of aiida.orm.nodes.attributes.NodeAttributes.__weakref__:1
#: ../../docstring of aiida.orm.nodes.caching.NodeCaching.__weakref__:1
#: ../../docstring of aiida.orm.nodes.comments.NodeComments.__weakref__:1
#: ../../docstring of aiida.orm.nodes.data.jsonable.JsonSerializableProtocol.__weakref__:1
#: ../../docstring of aiida.orm.nodes.data.structure.Kind.__weakref__:1
#: ../../docstring of aiida.orm.nodes.data.structure.Site.__weakref__:1
#: ../../docstring of aiida.orm.nodes.links.NodeLinks.__weakref__:1
#: ../../docstring of aiida.orm.nodes.node.NodeBase.__weakref__:1
#: ../../docstring of aiida.orm.nodes.repository.NodeRepository.__weakref__:1
#: ../../docstring of aiida.orm.querybuilder.QueryBuilder.__weakref__:1
#: ../../docstring of aiida.orm.querybuilder._QueryTagMap.__weakref__:1
#: ../../docstring of aiida.orm.utils.builders.code.CodeBuilder.CodeValidationError.__weakref__:1
#: ../../docstring of aiida.orm.utils.builders.code.CodeBuilder.__weakref__:1
#: ../../docstring of aiida.orm.utils.builders.computer.ComputerBuilder.ComputerValidationError.__weakref__:1
#: ../../docstring of aiida.orm.utils.builders.computer.ComputerBuilder.__weakref__:1
#: ../../docstring of aiida.orm.utils.calcjob.CalcJobResultManager.__weakref__:1
#: ../../docstring of aiida.orm.utils.links.LinkManager.__weakref__:1
#: ../../docstring of aiida.orm.utils.loaders.OrmEntityLoader.__weakref__:1
#: ../../docstring of aiida.orm.utils.managers.AttributeManager.__weakref__:1
#: ../../docstring of aiida.orm.utils.managers.NodeLinksManager.__weakref__:1
#: ../../docstring of aiida.orm.utils.mixins.FunctionCalculationMixin.__weakref__:1
#: ../../docstring of aiida.orm.utils.mixins.Sealable.__weakref__:1
#: ../../docstring of aiida.orm.utils.serialize._MappingType.__weakref__:1
#: ../../docstring of aiida.parsers.parser.Parser.__weakref__:1
#: ../../docstring of aiida.plugins.utils.PluginVersionProvider.__weakref__:1
#: ../../docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.__weakref__:1
#: ../../docstring of aiida.repository.common.File.__weakref__:1
#: ../../docstring of aiida.repository.repository.Repository.__weakref__:1
#: ../../docstring of aiida.restapi.common.identifiers.Namespace.__weakref__:1
#: ../../docstring of aiida.restapi.common.utils.Utils.__weakref__:1
#: ../../docstring of aiida.restapi.resources.BaseResource.BaseTranslator.__weakref__:1
#: ../../docstring of aiida.restapi.translator.base.BaseTranslator.__weakref__:1
#: ../../docstring of aiida.schedulers.datastructures.JobTemplateCodeInfo.__weakref__:1
#: ../../docstring of aiida.schedulers.scheduler.Scheduler.__weakref__:1
#: ../../docstring of aiida.storage.psql_dos.alembic_cli.AlembicRunner.__weakref__:1
#: ../../docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.Configuration.__weakref__:1
#: ../../docstring of aiida.storage.psql_dos.migrations.utils.reflect.ReflectMigrations.__weakref__:1
#: ../../docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator.__weakref__:1
#: ../../docstring of aiida.storage.psql_dos.models.base.Model.__weakref__:1
#: ../../docstring of aiida.storage.psql_dos.orm.entities.SqlaModelEntity.__weakref__:1
#: ../../docstring of aiida.storage.psql_dos.orm.extras_mixin.ExtrasMixin.__weakref__:1
#: ../../docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.JoinReturn.__weakref__:1
#: ../../docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.SqlaJoiner.__weakref__:1
#: ../../docstring of aiida.storage.psql_dos.orm.querybuilder.joiner._EntityMapper.__weakref__:1
#: ../../docstring of aiida.storage.psql_dos.orm.querybuilder.main.BuiltQuery.__weakref__:1
#: ../../docstring of aiida.storage.psql_dos.orm.utils.ModelWrapper.__weakref__:1
#: ../../docstring of aiida.storage.psql_dos.utils.PsqlConfig.__weakref__:1
#: ../../docstring of aiida.storage.sqlite_dos.backend.SqliteDosStorage.Configuration.__weakref__:1
#: ../../docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.Configuration.__weakref__:1
#: ../../docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.Configuration.__weakref__:1
#: ../../docstring of aiida.storage.sqlite_zip.models.SqliteModel.__weakref__:1
#: ../../docstring of aiida.storage.sqlite_zip.orm.SqliteEntityOverride.__weakref__:1
#: ../../docstring of aiida.tools.archive.abstract.ArchiveFormatAbstract.__weakref__:1
#: ../../docstring of aiida.tools.archive.abstract.ArchiveReaderAbstract.__weakref__:1
#: ../../docstring of aiida.tools.archive.abstract.ArchiveWriterAbstract.__weakref__:1
#: ../../docstring of aiida.tools.archive.imports.CommentTransform.__weakref__:1
#: ../../docstring of aiida.tools.archive.imports.GroupTransform.__weakref__:1
#: ../../docstring of aiida.tools.archive.imports.NodeTransform.__weakref__:1
#: ../../docstring of aiida.tools.archive.imports.QueryParams.__weakref__:1
#: ../../docstring of aiida.tools.calculations.base.CalculationTools.__weakref__:1
#: ../../docstring of aiida.tools.data.cif.InvalidOccupationsError.__weakref__:1
#: ../../docstring of aiida.tools.data.orbital.orbital.Orbital.__weakref__:1
#: ../../docstring of aiida.tools.dbimporters.baseclasses.DbEntry.__weakref__:1
#: ../../docstring of aiida.tools.dbimporters.baseclasses.DbImporter.__weakref__:1
#: ../../docstring of aiida.tools.dbimporters.baseclasses.DbSearchResults.DbSearchResultsIterator.__weakref__:1
#: ../../docstring of aiida.tools.dbimporters.baseclasses.DbSearchResults.__weakref__:1
#: ../../docstring of aiida.tools.dbimporters.plugins.icsd.IcsdImporterExp.__weakref__:1
#: ../../docstring of aiida.tools.dbimporters.plugins.mpds.StructuresCollection.__weakref__:1
#: ../../docstring of aiida.tools.graph.age_entities.AbstractSetContainer.__weakref__:1
#: ../../docstring of aiida.tools.graph.age_entities.Basket.__weakref__:1
#: ../../docstring of aiida.tools.graph.age_rules.Operation.__weakref__:1
#: ../../docstring of aiida.tools.graph.graph_traversers.TraverseGraphOutput.__weakref__:1
#: ../../docstring of aiida.tools.groups.paths.GroupAttr.__weakref__:1
#: ../../docstring of aiida.tools.groups.paths.GroupNotFoundError.__weakref__:1
#: ../../docstring of aiida.tools.groups.paths.GroupNotUniqueError.__weakref__:1
#: ../../docstring of aiida.tools.groups.paths.GroupPath.__weakref__:1
#: ../../docstring of aiida.tools.groups.paths.InvalidPath.__weakref__:1
#: ../../docstring of aiida.tools.groups.paths.NoGroupsInPathError.__weakref__:1
#: ../../docstring of aiida.tools.query.calculation.CalculationQueryBuilder.__weakref__:1
#: ../../docstring of aiida.tools.query.mapping.ProjectionMapper.__weakref__:1
#: ../../docstring of aiida.tools.visualization.graph.Graph.__weakref__:1
#: ../../docstring of aiida.tools.visualization.graph.LinkStyleFunc.__weakref__:1
#: ../../docstring of aiida.transports.transport.Transport.__weakref__:1
msgid "list of weak references to the object"
msgstr ""

#: ../../source/reference/apidoc/aiida.cmdline.params.options.rst:2
msgid "aiida.cmdline.params.options package"
msgstr ""

#: ../../../src/aiida/cmdline/params/options/__init__.py:docstring of aiida.cmdline.params.options:1
#: ../../../src/aiida/cmdline/params/options/main.py:docstring of aiida.cmdline.params.options.main:1
msgid "Module with pre-defined reusable commandline options that can be used as `click` decorators."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/callable.py:docstring of aiida.cmdline.params.options.callable:1
msgid "A monkey-patched subclass of click.Option that does not evaluate callable default during tab completion."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/callable.py:docstring of aiida.cmdline.params.options.callable.CallableDefaultOption:1
#: ../../../src/aiida/cmdline/params/options/conditional.py:docstring of aiida.cmdline.params.options.conditional.ConditionalOption:1
#: ../../../src/aiida/cmdline/params/options/multivalue.py:docstring of aiida.cmdline.params.options.multivalue.MultipleValueOption:1
msgid "Bases: :py:class:`~click.core.Option`"
msgstr ""

#: ../../../src/aiida/cmdline/params/options/callable.py:docstring of aiida.cmdline.params.options.callable.CallableDefaultOption:1
msgid "A monkeypatch for click.Option that does not evaluate default callbacks during tab completion"
msgstr ""

#: ../../../src/aiida/cmdline/params/options/callable.py:docstring of aiida.cmdline.params.options.callable.CallableDefaultOption:3
msgid "This is a temporary solution until a proper fix is implemented in click, see: https://github.com/pallets/click/issues/2614"
msgstr ""

#: ../../../src/aiida/cmdline/params/options/callable.py:docstring of aiida.cmdline.params.options.callable.CallableDefaultOption.get_default:1
msgid "Return default unless in tab-completion context."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/conditional.py:docstring of aiida.cmdline.params.options.conditional:1
#: ../../../src/aiida/cmdline/params/options/conditional.py:docstring of aiida.cmdline.params.options.conditional.ConditionalOption:1
msgid "Option whose requiredness is determined by a callback function."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/conditional.py:docstring of aiida.cmdline.params.options.conditional.ConditionalOption:3
msgid "This option takes an additional callable parameter ``required_fn`` and uses that to determine whether a ``MissingParameter`` exception should be raised if no value is specified for the parameters."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/conditional.py:docstring of aiida.cmdline.params.options.conditional.ConditionalOption:6
msgid "The callable should take the context as an argument which it can use to inspect the value of other parameters that have been passed to the command invocation."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/conditional.py:docstring of aiida.cmdline.params.options.conditional.ConditionalOption:9
msgid "callable(ctx) -> True | False, returns True if the parameter is required to have a value. This is typically used when the condition depends on other parameters specified on the command line."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/conditional.py:docstring of aiida.cmdline.params.options.conditional.ConditionalOption.is_required:1
msgid "Runs the given check on the context to determine requiredness"
msgstr ""

#: ../../../src/aiida/cmdline/params/options/config.py:docstring of aiida.cmdline.params.options.config:4
msgid "The functions :func:`configuration_callback` and :func:`configuration_option` were directly taken from the repository https://github.com/phha/click_config_file/blob/7b93a20b4c79458987fac116418859f30a16d82a/click_config_file.py with a minor modification to ``configuration_callback`` to add a check for unknown parameters in the configuration file and the default provider is changed to :func:`yaml_config_file_provider`."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/config.py:docstring of aiida.cmdline.params.options.config.ConfigFileOption:1
msgid "Bases: :py:class:`~aiida.cmdline.params.options.overridable.OverridableOption`"
msgstr ""

#: ../../../src/aiida/cmdline/params/options/config.py:docstring of aiida.cmdline.params.options.config.ConfigFileOption:1
msgid "Reusable option that reads a configuration file containing values for other command parameters."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/config.py:docstring of aiida.cmdline.params.options.config.ConfigFileOption:15
msgid "with config.yml::"
msgstr ""

#: ../../../src/aiida/cmdline/params/options/config.py:docstring of aiida.cmdline.params.options.config.ConfigFileOption.__call__:1
#: ../../../src/aiida/cmdline/params/options/overridable.py:docstring of aiida.cmdline.params.options.overridable.OverridableOption.__call__:1
msgid "Override the stored kwargs, (ignoring args as we do not allow option name changes) and return the option."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/config.py:docstring of aiida.cmdline.params.options.config.ConfigFileOption.__call__:3
#: ../../../src/aiida/cmdline/params/options/overridable.py:docstring of aiida.cmdline.params.options.overridable.OverridableOption.__call__:3
msgid "keyword arguments that will override those set in the construction"
msgstr ""

#: ../../../src/aiida/cmdline/params/options/config.py:docstring of aiida.cmdline.params.options.config.ConfigFileOption.__call__:4
msgid "click_config_file.configuration_option constructed with args and kwargs defined during construction and call of this instance"
msgstr ""

#: ../../../src/aiida/cmdline/params/options/config.py:docstring of aiida.cmdline.params.options.config.ConfigFileOption.__init__:1
#: ../../../src/aiida/cmdline/params/options/overridable.py:docstring of aiida.cmdline.params.options.overridable.OverridableOption.__init__:1
msgid "Store the default args and kwargs."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/config.py:docstring of aiida.cmdline.params.options.config.ConfigFileOption.__init__:3
msgid "default arguments to be used for the option"
msgstr ""

#: ../../../src/aiida/cmdline/params/options/config.py:docstring of aiida.cmdline.params.options.config.ConfigFileOption.__init__:4
#: ../../../src/aiida/cmdline/params/options/overridable.py:docstring of aiida.cmdline.params.options.overridable.OverridableOption.__init__:4
msgid "default keyword arguments to be used that can be overridden in the call"
msgstr ""

#: ../../../src/aiida/cmdline/params/options/config.py:docstring of aiida.cmdline.params.options.config.configuration_callback:1
msgid "Callback for reading the config file."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/config.py:docstring of aiida.cmdline.params.options.config.configuration_callback:3
msgid "Also takes care of calling user specified custom callback afterwards."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/config.py:docstring of aiida.cmdline.params.options.config.configuration_callback:5
msgid "The command name. This is used to determine the configuration directory."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/config.py:docstring of aiida.cmdline.params.options.config.configuration_callback:6
msgid "The name of the option. This is used for error messages."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/config.py:docstring of aiida.cmdline.params.options.config.configuration_callback:7
msgid "The name of the configuration file."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/config.py:docstring of aiida.cmdline.params.options.config.configuration_callback:8
msgid "User-specified callback to be called later."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/config.py:docstring of aiida.cmdline.params.options.config.configuration_callback:9
msgid "A callable that parses the configuration file and returns a dictionary of the configuration parameters. Will be called as ``provider(file_path, cmd_name)``. Default: ``yaml_config_file_provider``."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/config.py:docstring of aiida.cmdline.params.options.config.configuration_callback:11
msgid "Whether a implicit value should be applied if no configuration option value was provided."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/config.py:docstring of aiida.cmdline.params.options.config.configuration_callback:12
msgid "``click`` context."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/config.py:docstring of aiida.cmdline.params.options.config.configuration_callback:13
msgid "``click`` parameters."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/config.py:docstring of aiida.cmdline.params.options.config.configuration_callback:14
msgid "Value passed to the parameter."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/config.py:docstring of aiida.cmdline.params.options.config.configuration_option:1
msgid "Adds configuration file support to a click application."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/config.py:docstring of aiida.cmdline.params.options.config.configuration_option:3
msgid "This will create an option of type ``click.File`` expecting the path to a configuration file. When specified, it overwrites the default values for all other click arguments or options with the corresponding value from the configuration file. The default name of the option is ``--config``. By default, the configuration will be read from a configuration directory as determined by ``click.get_app_dir``. This decorator accepts the same arguments as ``click.option`` and ``click.Path``. In addition, the following keyword arguments are available:"
msgstr ""

#: ../../../src/aiida/cmdline/params/options/config.py:docstring of aiida.cmdline.params.options.config.configuration_option:9
msgid "str The command name. This is used to determine the configuration directory. Default: ``ctx.info_name``."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/config.py:docstring of aiida.cmdline.params.options.config.configuration_option:11
msgid "str The name of the configuration file. Default: ``config``."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/config.py:docstring of aiida.cmdline.params.options.config.configuration_option:13
msgid "bool If ``True`` then implicitly create a value for the configuration option using the above parameters. If a configuration file exists in this path it will be applied even if no configuration option was suppplied as a CLI argument or environment variable. If ``False`` only apply a configuration file that has been explicitely specified. Default: ``False``."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/config.py:docstring of aiida.cmdline.params.options.config.configuration_option:18
msgid "callable A callable that parses the configuration file and returns a dictionary of the configuration parameters. Will be called as ``provider(file_path, cmd_name)``. Default: ``yaml_config_file_provider``."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/config.py:docstring of aiida.cmdline.params.options.config.yaml_config_file_provider:1
msgid "Read yaml config file from file handle."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/interactive.py:docstring of aiida.cmdline.params.options.interactive:1
msgid "Tools and an option class for interactive parameter entry with additional features such as help lookup."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/interactive.py:docstring of aiida.cmdline.params.options.interactive.InteractiveOption:1
msgid "Bases: :py:class:`~aiida.cmdline.params.options.conditional.ConditionalOption`"
msgstr ""

#: ../../../src/aiida/cmdline/params/options/interactive.py:docstring of aiida.cmdline.params.options.interactive.InteractiveOption:1
msgid "Prompts for input, intercepting certain keyword arguments to provide more feature-rich behavior."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/interactive.py:docstring of aiida.cmdline.params.options.interactive.InteractiveOption:3
msgid "This class has a parameter ``required_fn`` that can be passed to its ``__init__`` (inherited from the superclass :py:class:`~aiida.cmdline.params.options.conditional.ConditionalOption`) and a ``prompt_fn``."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/interactive.py:docstring of aiida.cmdline.params.options.interactive.InteractiveOption:7
msgid "``required_fn`` is about \"is this parameter required\" depending on the value of other params."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/interactive.py:docstring of aiida.cmdline.params.options.interactive.InteractiveOption:8
msgid "``prompt_fn`` is about \"should I prompt for this value if in interactive mode\" and only makes sense in this class and not in :py:class:`~aiida.cmdline.params.options.conditional.ConditionalOption`."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/interactive.py:docstring of aiida.cmdline.params.options.interactive.InteractiveOption:11
msgid "In most usecases, if I have a ``prompt_fn``, then I would like to have also (the same) ``required_fn``. The implementation still makes them independent for usecases where they might be different functions (e.g. if the variable is anyway not required, but you want to decide whether to prompt for it or not)."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/interactive.py:docstring of aiida.cmdline.params.options.interactive.InteractiveOption:15
#: ../../../src/aiida/cmdline/params/types/plugin.py:docstring of aiida.cmdline.params.types.plugin.PluginParamType:7
#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.aiida_local_code_factory:5
#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.aiida_localhost:3
#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData._parse_xyz_pos:11
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder:3
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.add_filter:6
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.add_projection:17
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.dict:12
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.order_by:10
#: ../../../src/aiida/tools/ipython/ipython_magics.py:docstring of aiida.tools.ipython.ipython_magics.AiiDALoaderMagics.aiida:5
msgid "Usage::"
msgstr ""

#: ../../../src/aiida/cmdline/params/options/interactive.py:docstring of aiida.cmdline.params.options.interactive.InteractiveOption.__init__:1
#: ../../../src/aiida/cmdline/params/types/choice.py:docstring of aiida.cmdline.params.types.choice.LazyChoice.__init__:1
#: ../../../src/aiida/cmdline/params/types/multiple.py:docstring of aiida.cmdline.params.types.multiple.MultipleValueParamType.__init__:1
#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder.__init__:1
#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.Capturing.__init__:1
#: ../../../src/aiida/engine/processes/calcjobs/monitors.py:docstring of aiida.engine.processes.calcjobs.monitors.CalcJobMonitors.__init__:1
#: ../../../src/aiida/manage/external/rmq/client.py:docstring of aiida.manage.external.rmq.client.RabbitmqManagementClient.__init__:1
#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.__init__:1
#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.__init__:1
#: ../../../src/aiida/orm/nodes/data/code/containerized.py:docstring of aiida.orm.nodes.data.code.containerized.ContainerizedCode.__init__:1
#: ../../../src/aiida/orm/nodes/data/code/installed.py:docstring of aiida.orm.nodes.data.code.installed.InstalledCode.__init__:1
#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.__init__:1
#: ../../../src/aiida/orm/nodes/data/code/portable.py:docstring of aiida.orm.nodes.data.code.portable.PortableCode.__init__:1
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder._QueryTagMap.__init__:1
#: ../../../src/aiida/orm/utils/builders/code.py:docstring of aiida.orm.utils.builders.code.CodeBuilder.__init__:1
#: ../../../src/aiida/orm/utils/builders/computer.py:docstring of aiida.orm.utils.builders.computer.ComputerBuilder.__init__:1
#: ../../../src/aiida/repository/backend/sandbox.py:docstring of aiida.repository.backend.sandbox.SandboxRepositoryBackend.__init__:1
#: ../../../src/aiida/repository/common.py:docstring of aiida.repository.common.File.__init__:1
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.LazyFile.__init__:1
#: ../../../src/aiida/storage/psql_dos/orm/authinfos.py:docstring of aiida.storage.psql_dos.orm.authinfos.SqlaAuthInfo.__init__:1
#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports.CommentTransform.__init__:1
#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports.NodeTransform.__init__:1
#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.IcsdDbImporter.__init__:1
msgid "Construct a new instance."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/interactive.py:docstring of aiida.cmdline.params.options.interactive.InteractiveOption.__init__:3
msgid "relayed to :class:`click.Option`"
msgstr ""

#: ../../../src/aiida/cmdline/params/options/interactive.py:docstring of aiida.cmdline.params.options.interactive.InteractiveOption.__init__:4
msgid "callable(ctx) -> Bool, returns True if the option should be prompted for in interactive mode."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/interactive.py:docstring of aiida.cmdline.params.options.interactive.InteractiveOption.__init__:5
msgid "An optional callback function to get a default which is passed the click context."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/interactive.py:docstring of aiida.cmdline.params.options.interactive.InteractiveOption.get_default:1
msgid "Provides the functionality of :meth:`click.Option.get_default`"
msgstr ""

#: ../../../src/aiida/cmdline/params/options/interactive.py:docstring of aiida.cmdline.params.options.interactive.InteractiveOption.get_help_message:1
msgid "Return a message to be displayed for in-prompt help."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/interactive.py:docstring of aiida.cmdline.params.options.interactive.InteractiveOption.is_interactive:1
msgid "Return whether the command is being run non-interactively."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/interactive.py:docstring of aiida.cmdline.params.options.interactive.InteractiveOption.is_interactive:3
msgid "This is the case if the ``non_interactive`` parameter in the context is set to ``True``."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/interactive.py:docstring of aiida.cmdline.params.options.interactive.InteractiveOption.is_interactive:5
msgid "``True`` if being run non-interactively, ``False`` otherwise."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/interactive.py:docstring of aiida.cmdline.params.options.interactive.InteractiveOption.process_value:1
msgid "Intercept any special characters before calling parent class if in interactive mode."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/interactive.py:docstring of aiida.cmdline.params.options.interactive.InteractiveOption.process_value:3
msgid "If the value matches ``CHARACTER_PROMPT_HELP``, echo ``get_help_message`` and reprompt."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/interactive.py:docstring of aiida.cmdline.params.options.interactive.InteractiveOption.process_value:4
msgid "If the value matches ``CHARACTER_IGNORE_DEFAULT``, ignore the value and return ``None``."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/interactive.py:docstring of aiida.cmdline.params.options.interactive.InteractiveOption.process_value:6
msgid "Note that this logic only applies if the value is specified at the prompt, if it is provided from the command line, the value is actually taken as the value and processed as normal. To determine how the parameter was specified the ``click.Context.get_parameter_source`` method is used. The ``click.Parameter.handle_parse_result`` method will set this after ``Parameter.consume_value``` is called but before ``Parameter.process_value`` is."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/interactive.py:docstring of aiida.cmdline.params.options.interactive.InteractiveOption.prompt:1
msgid "Return a colorized version of the prompt text."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/interactive.py:docstring of aiida.cmdline.params.options.interactive.InteractiveOption.prompt_for_value:1
msgid "Prompt for a value printing a generic help message if this is the first invocation of the command."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/interactive.py:docstring of aiida.cmdline.params.options.interactive.InteractiveOption.prompt_for_value:3
msgid "If the command is invoked in non-interactive mode, meaning one should never prompt for a value, the default is returned instead of prompting."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/interactive.py:docstring of aiida.cmdline.params.options.interactive.InteractiveOption.prompt_for_value:6
msgid "If the help message is printed, the ``prompt_loop_info_printed`` variable is set in the context which is used to check whether the message has already been printed as to only print it once at the first prompt."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/interactive.py:docstring of aiida.cmdline.params.options.interactive.TemplateInteractiveOption:1
msgid "Bases: :py:class:`~aiida.cmdline.params.options.interactive.InteractiveOption`"
msgstr ""

#: ../../../src/aiida/cmdline/params/options/interactive.py:docstring of aiida.cmdline.params.options.interactive.TemplateInteractiveOption:1
msgid "Sub class of ``InteractiveOption`` that uses template file for input instead of simple inline prompt."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/interactive.py:docstring of aiida.cmdline.params.options.interactive.TemplateInteractiveOption:3
msgid "This is useful for options that need to be able to specify multiline string values."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/interactive.py:docstring of aiida.cmdline.params.options.interactive.TemplateInteractiveOption.__init__:1
msgid "Define the configuration for the multiline template in the keyword arguments."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/interactive.py:docstring of aiida.cmdline.params.options.interactive.TemplateInteractiveOption.__init__:3
msgid "name of the template to use from the ``aiida.cmdline.templates`` directory. Default is the 'multiline.tpl' template."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/interactive.py:docstring of aiida.cmdline.params.options.interactive.TemplateInteractiveOption.__init__:5
msgid "string to put in the header of the template."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/interactive.py:docstring of aiida.cmdline.params.options.interactive.TemplateInteractiveOption.__init__:6
msgid "string to put in the footer of the template."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/interactive.py:docstring of aiida.cmdline.params.options.interactive.TemplateInteractiveOption.__init__:7
msgid "file extension to give to the template file."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/interactive.py:docstring of aiida.cmdline.params.options.interactive.TemplateInteractiveOption.prompt_for_value:1
msgid "Replace the basic prompt with a method that opens a template file in an editor."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/main.py:docstring of aiida.cmdline.params.options.main.active_process_states:1
msgid "Return a list of process states that are considered active."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/main.py:docstring of aiida.cmdline.params.options.main.graph_traversal_rules:1
msgid "Apply the graph traversal rule options to the command."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/main.py:docstring of aiida.cmdline.params.options.main.set_log_level:1
msgid "Configure the logging for the CLI command being executed."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/main.py:docstring of aiida.cmdline.params.options.main.set_log_level:3
msgid "Note that we cannot use the most obvious approach of directly setting the level on the various loggers. The reason is that after this callback is finished, the :meth:`aiida.common.log.configure_logging` method can be called again, for example when the database backend is loaded, and this will undo this change. So instead, we set to globals in the :mod:`aiida.common.log` module: ``CLI_ACTIVE`` and ``CLI_LOG_LEVEL``. The ``CLI_ACTIVE`` global is always set to ``True``. The ``configure_logging`` function will interpret this as the code being executed through a ``verdi`` call. The ``CLI_LOG_LEVEL`` global is only set if an explicit value is set for the ``--verbosity`` option. In this case, it is set to the specified log level and ``configure_logging`` will then set this log level for all loggers."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/main.py:docstring of aiida.cmdline.params.options.main.set_log_level:11
msgid "This approach tightly couples the generic :mod:`aiida.common.log` module to the :mod:`aiida.cmdline` module, which is not the cleanest, but given that other module code can undo the logging configuration by calling that method, there seems no easy way around this approach."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/main.py:docstring of aiida.cmdline.params.options.main.valid_calc_job_states:1
msgid "Return a list of valid values for the CalcState enum."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/main.py:docstring of aiida.cmdline.params.options.main.valid_process_states:1
msgid "Return a list of valid values for the ProcessState enum."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/multivalue.py:docstring of aiida.cmdline.params.options.multivalue:1
msgid "Module to define multi value options for click."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/multivalue.py:docstring of aiida.cmdline.params.options.multivalue.MultipleValueOption:1
msgid "An option that can handle multiple values with a single flag. For example::"
msgstr ""

#: ../../../src/aiida/cmdline/params/options/multivalue.py:docstring of aiida.cmdline.params.options.multivalue.MultipleValueOption:5
msgid "Will be able to parse the following::"
msgstr ""

#: ../../../src/aiida/cmdline/params/options/multivalue.py:docstring of aiida.cmdline.params.options.multivalue.MultipleValueOption:9
msgid "This is better than the builtin ``multiple=True`` keyword for click's option which forces the user to specify the option flag for each value, which gets impractical for long lists of values"
msgstr ""

#: ../../../src/aiida/cmdline/params/options/multivalue.py:docstring of aiida.cmdline.params.options.multivalue.MultipleValueOption.add_to_parser:1
msgid "Override built in click method that allows us to specify a custom parser to eat up parameters until the following flag or 'endopt' (i.e. --)"
msgstr ""

#: ../../../src/aiida/cmdline/params/options/multivalue.py:docstring of aiida.cmdline.params.options.multivalue.collect_usage_pieces:1
msgid "Returns all the pieces that go into the usage line and returns it as a list of strings."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/overridable.py:docstring of aiida.cmdline.params.options.overridable:1
msgid "Convenience class which can be used to defined a set of commonly used options that can be easily reused."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/overridable.py:docstring of aiida.cmdline.params.options.overridable.OverridableOption:1
msgid "Wrapper around click option that increases reusability"
msgstr ""

#: ../../../src/aiida/cmdline/params/options/overridable.py:docstring of aiida.cmdline.params.options.overridable.OverridableOption:3
msgid "Click options are reusable already but sometimes it can improve the user interface to for example customize a help message for an option on a per-command basis. Sometimes the option should be prompted for if it is not given On some commands an option might take any folder path, while on another the path only has to exist."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/overridable.py:docstring of aiida.cmdline.params.options.overridable.OverridableOption:7
msgid "Overridable options store the arguments to click.option and only instantiate the click.Option on call, kwargs given to ``__call__`` override the stored ones."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/overridable.py:docstring of aiida.cmdline.params.options.overridable.OverridableOption.__call__:4
msgid "click option constructed with args and kwargs defined during construction and call of this instance"
msgstr ""

#: ../../../src/aiida/cmdline/params/options/overridable.py:docstring of aiida.cmdline.params.options.overridable.OverridableOption.__init__:3
msgid "default arguments to be used for the click option"
msgstr ""

#: ../../../src/aiida/cmdline/params/options/overridable.py:docstring of aiida.cmdline.params.options.overridable.OverridableOption.clone:1
msgid "Create a new instance of by cloning the current instance and updating the stored kwargs with those passed."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/overridable.py:docstring of aiida.cmdline.params.options.overridable.OverridableOption.clone:3
msgid "This can be useful when an already predefined OverridableOption needs to be further specified and reused by a set of sub commands. Example::"
msgstr ""

#: ../../../src/aiida/cmdline/params/options/overridable.py:docstring of aiida.cmdline.params.options.overridable.OverridableOption.clone:9
msgid "If multiple computer related sub commands need the LABEL option, but the default help string and required attribute need to be different, the `clone` method allows to override these and create a new OverridableOption instance that can then be used as a decorator."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/overridable.py:docstring of aiida.cmdline.params.options.overridable.OverridableOption.clone:13
msgid "keyword arguments to update"
msgstr ""

#: ../../../src/aiida/cmdline/params/options/overridable.py:docstring of aiida.cmdline.params.options.overridable.OverridableOption.clone:14
msgid "OverridableOption instance with stored keyword arguments updated"
msgstr ""

#: ../../source/reference/apidoc/aiida.cmdline.params.options.commands.rst:2
msgid "aiida.cmdline.params.options.commands package"
msgstr ""

#: ../../../src/aiida/cmdline/params/options/commands/__init__.py:docstring of aiida.cmdline.params.options.commands:1
msgid "Module containing predefined command specific CLI options."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/commands/code.py:docstring of aiida.cmdline.params.options.commands.code:1
msgid "Reusable command line interface options for Code commands."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/commands/code.py:docstring of aiida.cmdline.params.options.commands.code.validate_label_uniqueness:1
#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.cli_validate_label_uniqueness:1
#: ../../../src/aiida/orm/nodes/data/code/installed.py:docstring of aiida.orm.nodes.data.code.installed.InstalledCode.cli_validate_label_uniqueness:1
msgid "Validate the uniqueness of the label of the code."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/commands/code.py:docstring of aiida.cmdline.params.options.commands.code.validate_label_uniqueness:3
msgid "The exact uniqueness criterion depends on the type of the code, whether it is \"local\" or \"remote\". For the former, the `label` itself should be unique, whereas for the latter it is the full label, i.e., `label@computer.label`."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/commands/code.py:docstring of aiida.cmdline.params.options.commands.code.validate_label_uniqueness:6
msgid "For this to work in the case of the remote code, the computer parameter already needs to have been parsed In interactive mode, this means that the computer parameter needs to be defined after the label parameter in the command definition. For non-interactive mode, the parsing order will always be determined by the order the parameters are specified by the caller and so this validator may get called before the computer is parsed. For that reason, this validator should also be called in the command itself, to ensure it has both the label and computer parameter available."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/commands/computer.py:docstring of aiida.cmdline.params.options.commands.computer:1
msgid "Reusable command line interface options for Computer commands."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/commands/computer.py:docstring of aiida.cmdline.params.options.commands.computer.get_job_resource_cls:1
msgid "Return job resource cls from ctx."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/commands/computer.py:docstring of aiida.cmdline.params.options.commands.computer.should_call_default_memory_per_machine:1
msgid "Return whether the selected scheduler type accepts `default_memory_per_machine`."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/commands/computer.py:docstring of aiida.cmdline.params.options.commands.computer.should_call_default_memory_per_machine:3
msgid "`True` if the scheduler type accepts `default_memory_per_machine`, `False` otherwise. If the scheduler class could not be loaded `False` is returned by default."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/commands/computer.py:docstring of aiida.cmdline.params.options.commands.computer.should_call_default_mpiprocs_per_machine:1
msgid "Return whether the selected scheduler type accepts `default_mpiprocs_per_machine`."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/commands/computer.py:docstring of aiida.cmdline.params.options.commands.computer.should_call_default_mpiprocs_per_machine:3
msgid "`True` if the scheduler type accepts `default_mpiprocs_per_machine`, `False` otherwise. If the scheduler class could not be loaded `False` is returned by default."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/commands/setup.py:docstring of aiida.cmdline.params.options.commands.setup:1
msgid "Reusable command line interface options for the setup commands."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/commands/setup.py:docstring of aiida.cmdline.params.options.commands.setup.get_profile_attribute_default:1
msgid "Return the default value for the given attribute of the profile passed in the context."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/commands/setup.py:docstring of aiida.cmdline.params.options.commands.setup.get_profile_attribute_default:3
msgid "attribute for which to get the current value"
msgstr ""

#: ../../../src/aiida/cmdline/params/options/commands/setup.py:docstring of aiida.cmdline.params.options.commands.setup.get_profile_attribute_default:4
#: ../../../src/aiida/cmdline/params/options/commands/setup.py:docstring of aiida.cmdline.params.options.commands.setup.get_repository_uri_default:3
#: ../../../src/aiida/cmdline/params/options/commands/setup.py:docstring of aiida.cmdline.params.options.commands.setup.validate_profile_parameter:3
msgid "click context which should contain the selected profile"
msgstr ""

#: ../../../src/aiida/cmdline/params/options/commands/setup.py:docstring of aiida.cmdline.params.options.commands.setup.get_profile_attribute_default:5
msgid "profile attribute default value if set, or None"
msgstr ""

#: ../../../src/aiida/cmdline/params/options/commands/setup.py:docstring of aiida.cmdline.params.options.commands.setup.get_quicksetup_database_name:1
msgid "Determine the database name to be used as default for the Postgres connection in `verdi quicksetup`"
msgstr ""

#: ../../../src/aiida/cmdline/params/options/commands/setup.py:docstring of aiida.cmdline.params.options.commands.setup.get_quicksetup_database_name:3
msgid "If a value is explicitly passed, that value is returned unchanged."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/commands/setup.py:docstring of aiida.cmdline.params.options.commands.setup.get_quicksetup_database_name:5
msgid "If no value is passed, the name will be <profile_name>_<os_user>_<hash>, where <os_user> is the name of the current operating system user and <hash> is a hash of the path of the configuration directory."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/commands/setup.py:docstring of aiida.cmdline.params.options.commands.setup.get_quicksetup_database_name:8
msgid "Note: This ensures that profiles named ``test_...`` will have databases named ``test_...`` ."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/commands/setup.py:docstring of aiida.cmdline.params.options.commands.setup.get_quicksetup_database_name:10
#: ../../../src/aiida/cmdline/params/options/commands/setup.py:docstring of aiida.cmdline.params.options.commands.setup.get_quicksetup_password:7
#: ../../../src/aiida/cmdline/params/options/commands/setup.py:docstring of aiida.cmdline.params.options.commands.setup.get_quicksetup_repository_uri:3
#: ../../../src/aiida/cmdline/params/options/commands/setup.py:docstring of aiida.cmdline.params.options.commands.setup.get_quicksetup_username:6
msgid "click context which should contain the contextual parameters"
msgstr ""

#: ../../../src/aiida/cmdline/params/options/commands/setup.py:docstring of aiida.cmdline.params.options.commands.setup.get_quicksetup_database_name:11
msgid "the database name"
msgstr ""

#: ../../../src/aiida/cmdline/params/options/commands/setup.py:docstring of aiida.cmdline.params.options.commands.setup.get_quicksetup_password:1
msgid "Determine the password to be used as default for the Postgres connection in `verdi quicksetup`"
msgstr ""

#: ../../../src/aiida/cmdline/params/options/commands/setup.py:docstring of aiida.cmdline.params.options.commands.setup.get_quicksetup_password:3
msgid "If a value is explicitly passed, that value is returned. If there is no value, the current username in the context will be scanned for in currently existing profiles. If it does, the corresponding password will be used. If no such user already exists, a random password will be generated."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/commands/setup.py:docstring of aiida.cmdline.params.options.commands.setup.get_quicksetup_password:8
msgid "the password"
msgstr ""

#: ../../../src/aiida/cmdline/params/options/commands/setup.py:docstring of aiida.cmdline.params.options.commands.setup.get_quicksetup_repository_uri:1
msgid "Return the repository URI to be used as default in `verdi quicksetup`"
msgstr ""

#: ../../../src/aiida/cmdline/params/options/commands/setup.py:docstring of aiida.cmdline.params.options.commands.setup.get_quicksetup_repository_uri:4
msgid "the repository URI"
msgstr ""

#: ../../../src/aiida/cmdline/params/options/commands/setup.py:docstring of aiida.cmdline.params.options.commands.setup.get_quicksetup_username:1
msgid "Determine the username to be used as default for the Postgres connection in `verdi quicksetup`"
msgstr ""

#: ../../../src/aiida/cmdline/params/options/commands/setup.py:docstring of aiida.cmdline.params.options.commands.setup.get_quicksetup_username:3
msgid "If a value is explicitly passed, that value is returned. If there is no value, the name will be based on the name of the current operating system user and the hash of the path of the configuration directory."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/commands/setup.py:docstring of aiida.cmdline.params.options.commands.setup.get_quicksetup_username:7
msgid "the username"
msgstr ""

#: ../../../src/aiida/cmdline/params/options/commands/setup.py:docstring of aiida.cmdline.params.options.commands.setup.get_repository_uri_default:1
msgid "Return the default value for the repository URI for the current profile in the click context."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/commands/setup.py:docstring of aiida.cmdline.params.options.commands.setup.get_repository_uri_default:4
msgid "default repository URI"
msgstr ""

#: ../../../src/aiida/cmdline/params/options/commands/setup.py:docstring of aiida.cmdline.params.options.commands.setup.validate_profile_parameter:1
msgid "Validate that the context contains the option `profile` and it contains a `Profile` instance."
msgstr ""

#: ../../../src/aiida/cmdline/params/options/commands/setup.py:docstring of aiida.cmdline.params.options.commands.setup.validate_profile_parameter:0
#: ../../../src/aiida/cmdline/params/types/plugin.py:docstring of aiida.cmdline.params.types.plugin.PluginParamType.get_entry_point_from_string:0
#: ../../../src/aiida/common/files.py:docstring of aiida.common.files.md5_file:0
#: ../../../src/aiida/common/files.py:docstring of aiida.common.files.md5_from_filelike:0
#: ../../../src/aiida/common/files.py:docstring of aiida.common.files.sha1_file:0
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient._await_condition:0
#: ../../../src/aiida/engine/persistence.py:docstring of aiida.engine.persistence.AiiDAPersister.load_checkpoint:0
#: ../../../src/aiida/engine/persistence.py:docstring of aiida.engine.persistence.AiiDAPersister.save_checkpoint:0
#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.CalcJob.get_importer:0
#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.task_kill_job:0
#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.task_retrieve_job:0
#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.task_stash_job:0
#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.task_submit_job:0
#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.task_upload_job:0
#: ../../../src/aiida/manage/caching.py:docstring of aiida.manage.caching.get_use_cache:0
#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres.create_dbuser:0
#: ../../../src/aiida/orm/implementation/computers.py:docstring of aiida.orm.implementation.computers.BackendComputer.copy:0
#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.__init__:0
#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.bulk_insert:0
#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.bulk_update:0
#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.delete_nodes_and_connections:0
#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.get_global_variable:0
#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.migrate:0
#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.set_global_variable:0
#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.version_profile:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.reset_cell:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.validate_symbols_tuple:0
#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.get_option:0
#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.set_option:0
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.one:0
#: ../../../src/aiida/orm/users.py:docstring of aiida.orm.users.UserCollection.get_or_create:0
#: ../../../src/aiida/restapi/common/identifiers.py:docstring of aiida.restapi.common.identifiers.Namespace.create_namespace:0
#: ../../../src/aiida/schedulers/plugins/sge.py:docstring of aiida.schedulers.plugins.sge.SgeScheduler._get_detailed_job_info_command:0
#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler._get_detailed_job_info_command:0
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.__init__:0
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.bulk_insert:0
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.bulk_update:0
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.delete_nodes_and_connections:0
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.get_global_variable:0
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.migrate:0
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.set_global_variable:0
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.version_profile:0
#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator.connection:0
#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator.get_repository_uuid:0
#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator.migrate:0
#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator.validate_storage:0
#: ../../../src/aiida/storage/sqlite_dos/backend.py:docstring of aiida.storage.sqlite_dos.backend.SqliteDosStorage.version_profile:0
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.__init__:0
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.bulk_insert:0
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.bulk_update:0
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.delete_nodes_and_connections:0
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.get_global_variable:0
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.migrate:0
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.set_global_variable:0
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.version_profile:0
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.__init__:0
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.bulk_insert:0
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.bulk_update:0
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.delete_nodes_and_connections:0
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.get_global_variable:0
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.migrate:0
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.set_global_variable:0
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.version_profile:0
#: ../../../src/aiida/storage/sqlite_zip/migrator.py:docstring of aiida.storage.sqlite_zip.migrator.validate_storage:0
#: ../../../src/aiida/storage/sqlite_zip/utils.py:docstring of aiida.storage.sqlite_zip.utils.read_version:0
#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveFormatAbstract.read_version:0
#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveReaderAbstract.get_metadata:0
#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveWriterAbstract.bulk_insert:0
#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/main.py:docstring of aiida.tools.archive.implementations.sqlite_zip.main.ArchiveFormatSqlZip.read_version:0
#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/reader.py:docstring of aiida.tools.archive.implementations.sqlite_zip.reader.ArchiveReaderSqlZip.get_metadata:0
#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/writer.py:docstring of aiida.tools.archive.implementations.sqlite_zip.writer.ArchiveWriterSqlZip.bulk_insert:0
#: ../../../src/aiida/tools/groups/paths.py:docstring of aiida.tools.groups.paths.GroupPath.delete_group:0
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.chdir:0
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.copy:0
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.makedirs:0
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.mkdir:0
msgid "raises"
msgstr ""

#: ../../../src/aiida/cmdline/params/options/commands/setup.py:docstring of aiida.cmdline.params.options.commands.setup.validate_profile_parameter:4
msgid "BadParameter if the context does not contain a `Profile` instance for option `profile`"
msgstr ""

#: ../../source/reference/apidoc/aiida.cmdline.params.types.rst:2
msgid "aiida.cmdline.params.types package"
msgstr ""

#: ../../../src/aiida/cmdline/params/types/__init__.py:docstring of aiida.cmdline.params.types:1
msgid "Provides all parameter types."
msgstr ""

#: ../../../src/aiida/cmdline/params/types/calculation.py:docstring of aiida.cmdline.params.types.calculation:1
msgid "Module for the calculation parameter type"
msgstr ""

#: ../../../src/aiida/cmdline/params/types/calculation.py:docstring of aiida.cmdline.params.types.calculation.CalculationParamType:1
#: ../../../src/aiida/cmdline/params/types/code.py:docstring of aiida.cmdline.params.types.code.CodeParamType:1
#: ../../../src/aiida/cmdline/params/types/computer.py:docstring of aiida.cmdline.params.types.computer.ComputerParamType:1
#: ../../../src/aiida/cmdline/params/types/data.py:docstring of aiida.cmdline.params.types.data.DataParamType:1
#: ../../../src/aiida/cmdline/params/types/group.py:docstring of aiida.cmdline.params.types.group.GroupParamType:1
#: ../../../src/aiida/cmdline/params/types/node.py:docstring of aiida.cmdline.params.types.node.NodeParamType:1
#: ../../../src/aiida/cmdline/params/types/process.py:docstring of aiida.cmdline.params.types.process.ProcessParamType:1
#: ../../../src/aiida/cmdline/params/types/workflow.py:docstring of aiida.cmdline.params.types.workflow.WorkflowParamType:1
msgid "Bases: :py:class:`~aiida.cmdline.params.types.identifier.IdentifierParamType`"
msgstr ""

#: ../../../src/aiida/cmdline/params/types/calculation.py:docstring of aiida.cmdline.params.types.calculation.CalculationParamType:1
msgid "The ParamType for identifying Calculation entities or its subclasses"
msgstr ""

#: ../../docstring of aiida.cmdline.params.types.calculation.CalculationParamType.name:1
#: ../../docstring of aiida.cmdline.params.types.choice.LazyChoice.name:1
#: ../../docstring of aiida.cmdline.params.types.code.CodeParamType.name:1
#: ../../docstring of aiida.cmdline.params.types.computer.ComputerParamType.name:1
#: ../../docstring of aiida.cmdline.params.types.computer.MpirunCommandParamType.name:1
#: ../../docstring of aiida.cmdline.params.types.computer.ShebangParamType.name:1
#: ../../docstring of aiida.cmdline.params.types.config.ConfigOptionParamType.name:1
#: ../../docstring of aiida.cmdline.params.types.data.DataParamType.name:1
#: ../../docstring of aiida.cmdline.params.types.group.GroupParamType.name:1
#: ../../docstring of aiida.cmdline.params.types.node.NodeParamType.name:1
#: ../../docstring of aiida.cmdline.params.types.path.AbsolutePathOrEmptyParamType.name:1
#: ../../docstring of aiida.cmdline.params.types.path.AbsolutePathParamType.name:1
#: ../../docstring of aiida.cmdline.params.types.path.FileOrUrl.name:1
#: ../../docstring of aiida.cmdline.params.types.path.PathOrUrl.name:1
#: ../../docstring of aiida.cmdline.params.types.plugin.PluginParamType.name:1
#: ../../docstring of aiida.cmdline.params.types.process.ProcessParamType.name:1
#: ../../docstring of aiida.cmdline.params.types.profile.ProfileParamType.name:1
#: ../../docstring of aiida.cmdline.params.types.strings.EmailType.name:1
#: ../../docstring of aiida.cmdline.params.types.strings.EntryPointType.name:1
#: ../../docstring of aiida.cmdline.params.types.strings.HostnameType.name:1
#: ../../docstring of aiida.cmdline.params.types.strings.LabelStringType.name:1
#: ../../docstring of aiida.cmdline.params.types.strings.NonEmptyStringParamType.name:1
#: ../../docstring of aiida.cmdline.params.types.user.UserParamType.name:1
#: ../../docstring of aiida.cmdline.params.types.workflow.WorkflowParamType.name:1
msgid "the descriptive name of this type"
msgstr ""

#: ../../../src/aiida/cmdline/params/types/calculation.py:docstring of aiida.cmdline.params.types.calculation.CalculationParamType.orm_class_loader:1
#: ../../../src/aiida/cmdline/params/types/code.py:docstring of aiida.cmdline.params.types.code.CodeParamType.orm_class_loader:1
#: ../../../src/aiida/cmdline/params/types/computer.py:docstring of aiida.cmdline.params.types.computer.ComputerParamType.orm_class_loader:1
#: ../../../src/aiida/cmdline/params/types/data.py:docstring of aiida.cmdline.params.types.data.DataParamType.orm_class_loader:1
#: ../../../src/aiida/cmdline/params/types/identifier.py:docstring of aiida.cmdline.params.types.identifier.IdentifierParamType.orm_class_loader:1
#: ../../../src/aiida/cmdline/params/types/node.py:docstring of aiida.cmdline.params.types.node.NodeParamType.orm_class_loader:1
#: ../../../src/aiida/cmdline/params/types/process.py:docstring of aiida.cmdline.params.types.process.ProcessParamType.orm_class_loader:1
#: ../../../src/aiida/cmdline/params/types/workflow.py:docstring of aiida.cmdline.params.types.workflow.WorkflowParamType.orm_class_loader:1
msgid "Return the orm entity loader class, which should be a subclass of OrmEntityLoader. This class is supposed to be used to load the entity for a given identifier"
msgstr ""

#: ../../../src/aiida/cmdline/params/types/calculation.py:docstring of aiida.cmdline.params.types.calculation.CalculationParamType.orm_class_loader:4
#: ../../../src/aiida/cmdline/params/types/code.py:docstring of aiida.cmdline.params.types.code.CodeParamType.orm_class_loader:4
#: ../../../src/aiida/cmdline/params/types/computer.py:docstring of aiida.cmdline.params.types.computer.ComputerParamType.orm_class_loader:4
#: ../../../src/aiida/cmdline/params/types/data.py:docstring of aiida.cmdline.params.types.data.DataParamType.orm_class_loader:4
#: ../../../src/aiida/cmdline/params/types/identifier.py:docstring of aiida.cmdline.params.types.identifier.IdentifierParamType.orm_class_loader:4
#: ../../../src/aiida/cmdline/params/types/node.py:docstring of aiida.cmdline.params.types.node.NodeParamType.orm_class_loader:4
#: ../../../src/aiida/cmdline/params/types/process.py:docstring of aiida.cmdline.params.types.process.ProcessParamType.orm_class_loader:4
#: ../../../src/aiida/cmdline/params/types/workflow.py:docstring of aiida.cmdline.params.types.workflow.WorkflowParamType.orm_class_loader:4
msgid "the orm entity loader class for this ParamType"
msgstr ""

#: ../../../src/aiida/cmdline/params/types/choice.py:docstring of aiida.cmdline.params.types.choice:1
msgid "A custom click type that defines a lazy choice"
msgstr ""

#: ../../../src/aiida/cmdline/params/types/choice.py:docstring of aiida.cmdline.params.types.choice.LazyChoice:1
#: ../../../src/aiida/cmdline/params/types/multiple.py:docstring of aiida.cmdline.params.types.multiple.MultipleValueParamType:1
#: ../../../src/aiida/cmdline/params/types/user.py:docstring of aiida.cmdline.params.types.user.UserParamType:1
msgid "Bases: :py:class:`~click.types.ParamType`"
msgstr ""

#: ../../../src/aiida/cmdline/params/types/choice.py:docstring of aiida.cmdline.params.types.choice.LazyChoice:1
msgid "This is a delegate of click's Choice ParamType that evaluates the set of choices lazily. This is useful if the choices set requires an import that is slow. Using the vanilla click.Choice will call this on import which will slow down verdi and its autocomplete. This type will generate the choices set lazily through the choices property"
msgstr ""

#: ../../../src/aiida/cmdline/params/types/choice.py:docstring of aiida.cmdline.params.types.choice.LazyChoice.__repr__:1
#: ../../../src/aiida/cmdline/params/types/computer.py:docstring of aiida.cmdline.params.types.computer.MpirunCommandParamType.__repr__:1
#: ../../../src/aiida/cmdline/params/types/computer.py:docstring of aiida.cmdline.params.types.computer.ShebangParamType.__repr__:1
#: ../../../src/aiida/cmdline/params/types/path.py:docstring of aiida.cmdline.params.types.path.AbsolutePathOrEmptyParamType.__repr__:1
#: ../../../src/aiida/cmdline/params/types/path.py:docstring of aiida.cmdline.params.types.path.AbsolutePathParamType.__repr__:1
#: ../../../src/aiida/cmdline/params/types/strings.py:docstring of aiida.cmdline.params.types.strings.EmailType.__repr__:1
#: ../../../src/aiida/cmdline/params/types/strings.py:docstring of aiida.cmdline.params.types.strings.EntryPointType.__repr__:1
#: ../../../src/aiida/cmdline/params/types/strings.py:docstring of aiida.cmdline.params.types.strings.HostnameType.__repr__:1
#: ../../../src/aiida/cmdline/params/types/strings.py:docstring of aiida.cmdline.params.types.strings.LabelStringType.__repr__:1
#: ../../../src/aiida/cmdline/params/types/strings.py:docstring of aiida.cmdline.params.types.strings.NonEmptyStringParamType.__repr__:1
#: ../../../src/aiida/engine/processes/builder.py:docstring of aiida.engine.processes.builder.ProcessBuilderNamespace.__repr__:1
#: ../../../src/aiida/engine/processes/calcjobs/monitors.py:docstring of aiida.engine.processes.calcjobs.monitors.CalcJobMonitor.__repr__:1
#: ../../../src/aiida/engine/processes/calcjobs/monitors.py:docstring of aiida.engine.processes.calcjobs.monitors.CalcJobMonitorResult.__repr__:1
#: ../../../src/aiida/manage/configuration/profile.py:docstring of aiida.manage.configuration.profile.Profile.__repr__:1
#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.__repr__:1
#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.Group.__repr__:1
#: ../../../src/aiida/orm/implementation/groups.py:docstring of aiida.orm.implementation.groups.BackendGroup.__repr__:1
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.Kind.__repr__:1
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.Site.__repr__:1
#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node.__repr__:1
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder._QueryTagMap.__repr__:1
#: ../../../src/aiida/orm/utils/builders/code.py:docstring of aiida.orm.utils.builders.code.CodeBuilder.CodeValidationError.__repr__:1
#: ../../../src/aiida/orm/utils/builders/computer.py:docstring of aiida.orm.utils.builders.computer.ComputerBuilder.ComputerValidationError.__repr__:1
#: ../../../src/aiida/orm/utils/managers.py:docstring of aiida.orm.utils.managers.NodeLinksManager.__repr__:1
#: ../../../src/aiida/repository/common.py:docstring of aiida.repository.common.File.__repr__:1
#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobTemplateCodeInfo.__repr__:1
#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.JoinReturn.__repr__:1
#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.BuiltQuery.__repr__:1
#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports.QueryParams.__repr__:1
#: ../../../src/aiida/tools/data/orbital/orbital.py:docstring of aiida.tools.data.orbital.orbital.Orbital.__repr__:1
#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbEntry.__repr__:1
#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.AbstractSetContainer.__repr__:1
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.__repr__:1
msgid "Return repr(self)."
msgstr ""

#: ../../../src/aiida/cmdline/params/types/choice.py:docstring of aiida.cmdline.params.types.choice.LazyChoice._click_choice:1
msgid "Get the internal click Choice object that we delegate functionality to. Will construct it lazily if necessary."
msgstr ""

#: ../../../src/aiida/cmdline/params/types/choice.py:docstring of aiida.cmdline.params.types.choice.LazyChoice._click_choice:4
msgid "The click Choice"
msgstr ""

#: ../../../src/aiida/cmdline/params/types/choice.py:docstring of aiida.cmdline.params.types.choice.LazyChoice._click_choice:5
msgid ":class:`click.Choice`"
msgstr ""

#: ../../../src/aiida/cmdline/params/types/choice.py:docstring of aiida.cmdline.params.types.choice.LazyChoice.convert:1
#: ../../../src/aiida/cmdline/params/types/computer.py:docstring of aiida.cmdline.params.types.computer.MpirunCommandParamType.convert:1
#: ../../../src/aiida/cmdline/params/types/computer.py:docstring of aiida.cmdline.params.types.computer.ShebangParamType.convert:1
#: ../../../src/aiida/cmdline/params/types/config.py:docstring of aiida.cmdline.params.types.config.ConfigOptionParamType.convert:1
#: ../../../src/aiida/cmdline/params/types/multiple.py:docstring of aiida.cmdline.params.types.multiple.MultipleValueParamType.convert:1
#: ../../../src/aiida/cmdline/params/types/path.py:docstring of aiida.cmdline.params.types.path.AbsolutePathOrEmptyParamType.convert:1
#: ../../../src/aiida/cmdline/params/types/path.py:docstring of aiida.cmdline.params.types.path.AbsolutePathParamType.convert:1
#: ../../../src/aiida/cmdline/params/types/strings.py:docstring of aiida.cmdline.params.types.strings.EmailType.convert:1
#: ../../../src/aiida/cmdline/params/types/strings.py:docstring of aiida.cmdline.params.types.strings.EntryPointType.convert:1
#: ../../../src/aiida/cmdline/params/types/strings.py:docstring of aiida.cmdline.params.types.strings.HostnameType.convert:1
#: ../../../src/aiida/cmdline/params/types/strings.py:docstring of aiida.cmdline.params.types.strings.LabelStringType.convert:1
#: ../../../src/aiida/cmdline/params/types/strings.py:docstring of aiida.cmdline.params.types.strings.NonEmptyStringParamType.convert:1
#: ../../../src/aiida/cmdline/params/types/user.py:docstring of aiida.cmdline.params.types.user.UserParamType.convert:1
msgid "Convert the value to the correct type. This is not called if the value is ``None`` (the missing value)."
msgstr ""

#: ../../../src/aiida/cmdline/params/types/choice.py:docstring of aiida.cmdline.params.types.choice.LazyChoice.convert:4
#: ../../../src/aiida/cmdline/params/types/computer.py:docstring of aiida.cmdline.params.types.computer.MpirunCommandParamType.convert:4
#: ../../../src/aiida/cmdline/params/types/computer.py:docstring of aiida.cmdline.params.types.computer.ShebangParamType.convert:4
#: ../../../src/aiida/cmdline/params/types/config.py:docstring of aiida.cmdline.params.types.config.ConfigOptionParamType.convert:4
#: ../../../src/aiida/cmdline/params/types/multiple.py:docstring of aiida.cmdline.params.types.multiple.MultipleValueParamType.convert:4
#: ../../../src/aiida/cmdline/params/types/path.py:docstring of aiida.cmdline.params.types.path.AbsolutePathOrEmptyParamType.convert:4
#: ../../../src/aiida/cmdline/params/types/path.py:docstring of aiida.cmdline.params.types.path.AbsolutePathParamType.convert:4
#: ../../../src/aiida/cmdline/params/types/strings.py:docstring of aiida.cmdline.params.types.strings.EmailType.convert:4
#: ../../../src/aiida/cmdline/params/types/strings.py:docstring of aiida.cmdline.params.types.strings.EntryPointType.convert:4
#: ../../../src/aiida/cmdline/params/types/strings.py:docstring of aiida.cmdline.params.types.strings.HostnameType.convert:4
#: ../../../src/aiida/cmdline/params/types/strings.py:docstring of aiida.cmdline.params.types.strings.LabelStringType.convert:4
#: ../../../src/aiida/cmdline/params/types/strings.py:docstring of aiida.cmdline.params.types.strings.NonEmptyStringParamType.convert:4
#: ../../../src/aiida/cmdline/params/types/user.py:docstring of aiida.cmdline.params.types.user.UserParamType.convert:4
msgid "This must accept string values from the command line, as well as values that are already the correct type. It may also convert other compatible types."
msgstr ""

#: ../../../src/aiida/cmdline/params/types/choice.py:docstring of aiida.cmdline.params.types.choice.LazyChoice.convert:8
#: ../../../src/aiida/cmdline/params/types/computer.py:docstring of aiida.cmdline.params.types.computer.MpirunCommandParamType.convert:8
#: ../../../src/aiida/cmdline/params/types/computer.py:docstring of aiida.cmdline.params.types.computer.ShebangParamType.convert:8
#: ../../../src/aiida/cmdline/params/types/config.py:docstring of aiida.cmdline.params.types.config.ConfigOptionParamType.convert:8
#: ../../../src/aiida/cmdline/params/types/multiple.py:docstring of aiida.cmdline.params.types.multiple.MultipleValueParamType.convert:8
#: ../../../src/aiida/cmdline/params/types/path.py:docstring of aiida.cmdline.params.types.path.AbsolutePathOrEmptyParamType.convert:8
#: ../../../src/aiida/cmdline/params/types/path.py:docstring of aiida.cmdline.params.types.path.AbsolutePathParamType.convert:8
#: ../../../src/aiida/cmdline/params/types/strings.py:docstring of aiida.cmdline.params.types.strings.EmailType.convert:8
#: ../../../src/aiida/cmdline/params/types/strings.py:docstring of aiida.cmdline.params.types.strings.EntryPointType.convert:8
#: ../../../src/aiida/cmdline/params/types/strings.py:docstring of aiida.cmdline.params.types.strings.HostnameType.convert:8
#: ../../../src/aiida/cmdline/params/types/strings.py:docstring of aiida.cmdline.params.types.strings.LabelStringType.convert:8
#: ../../../src/aiida/cmdline/params/types/strings.py:docstring of aiida.cmdline.params.types.strings.NonEmptyStringParamType.convert:8
#: ../../../src/aiida/cmdline/params/types/user.py:docstring of aiida.cmdline.params.types.user.UserParamType.convert:8
msgid "The ``param`` and ``ctx`` arguments may be ``None`` in certain situations, such as when converting prompt input."
msgstr ""

#: ../../../src/aiida/cmdline/params/types/choice.py:docstring of aiida.cmdline.params.types.choice.LazyChoice.convert:11
#: ../../../src/aiida/cmdline/params/types/computer.py:docstring of aiida.cmdline.params.types.computer.MpirunCommandParamType.convert:11
#: ../../../src/aiida/cmdline/params/types/computer.py:docstring of aiida.cmdline.params.types.computer.ShebangParamType.convert:11
#: ../../../src/aiida/cmdline/params/types/config.py:docstring of aiida.cmdline.params.types.config.ConfigOptionParamType.convert:11
#: ../../../src/aiida/cmdline/params/types/multiple.py:docstring of aiida.cmdline.params.types.multiple.MultipleValueParamType.convert:11
#: ../../../src/aiida/cmdline/params/types/path.py:docstring of aiida.cmdline.params.types.path.AbsolutePathOrEmptyParamType.convert:11
#: ../../../src/aiida/cmdline/params/types/path.py:docstring of aiida.cmdline.params.types.path.AbsolutePathParamType.convert:11
#: ../../../src/aiida/cmdline/params/types/strings.py:docstring of aiida.cmdline.params.types.strings.EmailType.convert:11
#: ../../../src/aiida/cmdline/params/types/strings.py:docstring of aiida.cmdline.params.types.strings.EntryPointType.convert:11
#: ../../../src/aiida/cmdline/params/types/strings.py:docstring of aiida.cmdline.params.types.strings.HostnameType.convert:11
#: ../../../src/aiida/cmdline/params/types/strings.py:docstring of aiida.cmdline.params.types.strings.LabelStringType.convert:11
#: ../../../src/aiida/cmdline/params/types/strings.py:docstring of aiida.cmdline.params.types.strings.NonEmptyStringParamType.convert:11
#: ../../../src/aiida/cmdline/params/types/user.py:docstring of aiida.cmdline.params.types.user.UserParamType.convert:11
msgid "If the value cannot be converted, call :meth:`fail` with a descriptive message."
msgstr ""

#: ../../../src/aiida/cmdline/params/types/choice.py:docstring of aiida.cmdline.params.types.choice.LazyChoice.convert:14
#: ../../../src/aiida/cmdline/params/types/computer.py:docstring of aiida.cmdline.params.types.computer.MpirunCommandParamType.convert:14
#: ../../../src/aiida/cmdline/params/types/computer.py:docstring of aiida.cmdline.params.types.computer.ShebangParamType.convert:14
#: ../../../src/aiida/cmdline/params/types/config.py:docstring of aiida.cmdline.params.types.config.ConfigOptionParamType.convert:14
#: ../../../src/aiida/cmdline/params/types/multiple.py:docstring of aiida.cmdline.params.types.multiple.MultipleValueParamType.convert:14
#: ../../../src/aiida/cmdline/params/types/path.py:docstring of aiida.cmdline.params.types.path.AbsolutePathOrEmptyParamType.convert:14
#: ../../../src/aiida/cmdline/params/types/path.py:docstring of aiida.cmdline.params.types.path.AbsolutePathParamType.convert:14
#: ../../../src/aiida/cmdline/params/types/strings.py:docstring of aiida.cmdline.params.types.strings.EmailType.convert:14
#: ../../../src/aiida/cmdline/params/types/strings.py:docstring of aiida.cmdline.params.types.strings.EntryPointType.convert:14
#: ../../../src/aiida/cmdline/params/types/strings.py:docstring of aiida.cmdline.params.types.strings.HostnameType.convert:14
#: ../../../src/aiida/cmdline/params/types/strings.py:docstring of aiida.cmdline.params.types.strings.LabelStringType.convert:14
#: ../../../src/aiida/cmdline/params/types/strings.py:docstring of aiida.cmdline.params.types.strings.NonEmptyStringParamType.convert:14
#: ../../../src/aiida/cmdline/params/types/user.py:docstring of aiida.cmdline.params.types.user.UserParamType.convert:14
msgid "The value to convert."
msgstr ""

#: ../../../src/aiida/cmdline/params/types/choice.py:docstring of aiida.cmdline.params.types.choice.LazyChoice.convert:15
#: ../../../src/aiida/cmdline/params/types/computer.py:docstring of aiida.cmdline.params.types.computer.MpirunCommandParamType.convert:15
#: ../../../src/aiida/cmdline/params/types/computer.py:docstring of aiida.cmdline.params.types.computer.ShebangParamType.convert:15
#: ../../../src/aiida/cmdline/params/types/config.py:docstring of aiida.cmdline.params.types.config.ConfigOptionParamType.convert:15
#: ../../../src/aiida/cmdline/params/types/multiple.py:docstring of aiida.cmdline.params.types.multiple.MultipleValueParamType.convert:15
#: ../../../src/aiida/cmdline/params/types/path.py:docstring of aiida.cmdline.params.types.path.AbsolutePathOrEmptyParamType.convert:15
#: ../../../src/aiida/cmdline/params/types/path.py:docstring of aiida.cmdline.params.types.path.AbsolutePathParamType.convert:15
#: ../../../src/aiida/cmdline/params/types/strings.py:docstring of aiida.cmdline.params.types.strings.EmailType.convert:15
#: ../../../src/aiida/cmdline/params/types/strings.py:docstring of aiida.cmdline.params.types.strings.EntryPointType.convert:15
#: ../../../src/aiida/cmdline/params/types/strings.py:docstring of aiida.cmdline.params.types.strings.HostnameType.convert:15
#: ../../../src/aiida/cmdline/params/types/strings.py:docstring of aiida.cmdline.params.types.strings.LabelStringType.convert:15
#: ../../../src/aiida/cmdline/params/types/strings.py:docstring of aiida.cmdline.params.types.strings.NonEmptyStringParamType.convert:15
#: ../../../src/aiida/cmdline/params/types/user.py:docstring of aiida.cmdline.params.types.user.UserParamType.convert:15
msgid "The parameter that is using this type to convert its value. May be ``None``."
msgstr ""

#: ../../../src/aiida/cmdline/params/types/choice.py:docstring of aiida.cmdline.params.types.choice.LazyChoice.convert:17
#: ../../../src/aiida/cmdline/params/types/computer.py:docstring of aiida.cmdline.params.types.computer.MpirunCommandParamType.convert:17
#: ../../../src/aiida/cmdline/params/types/computer.py:docstring of aiida.cmdline.params.types.computer.ShebangParamType.convert:17
#: ../../../src/aiida/cmdline/params/types/config.py:docstring of aiida.cmdline.params.types.config.ConfigOptionParamType.convert:17
#: ../../../src/aiida/cmdline/params/types/multiple.py:docstring of aiida.cmdline.params.types.multiple.MultipleValueParamType.convert:17
#: ../../../src/aiida/cmdline/params/types/path.py:docstring of aiida.cmdline.params.types.path.AbsolutePathOrEmptyParamType.convert:17
#: ../../../src/aiida/cmdline/params/types/path.py:docstring of aiida.cmdline.params.types.path.AbsolutePathParamType.convert:17
#: ../../../src/aiida/cmdline/params/types/strings.py:docstring of aiida.cmdline.params.types.strings.EmailType.convert:17
#: ../../../src/aiida/cmdline/params/types/strings.py:docstring of aiida.cmdline.params.types.strings.EntryPointType.convert:17
#: ../../../src/aiida/cmdline/params/types/strings.py:docstring of aiida.cmdline.params.types.strings.HostnameType.convert:17
#: ../../../src/aiida/cmdline/params/types/strings.py:docstring of aiida.cmdline.params.types.strings.LabelStringType.convert:17
#: ../../../src/aiida/cmdline/params/types/strings.py:docstring of aiida.cmdline.params.types.strings.NonEmptyStringParamType.convert:17
#: ../../../src/aiida/cmdline/params/types/user.py:docstring of aiida.cmdline.params.types.user.UserParamType.convert:17
msgid "The current context that arrived at this value. May be ``None``."
msgstr ""

#: ../../../src/aiida/cmdline/params/types/choice.py:docstring of aiida.cmdline.params.types.choice.LazyChoice.get_metavar:1
#: ../../../src/aiida/cmdline/params/types/multiple.py:docstring of aiida.cmdline.params.types.multiple.MultipleValueParamType.get_metavar:1
msgid "Returns the metavar default for this param if it provides one."
msgstr ""

#: ../../../src/aiida/cmdline/params/types/choice.py:docstring of aiida.cmdline.params.types.choice.LazyChoice.get_missing_message:1
#: ../../../src/aiida/cmdline/params/types/plugin.py:docstring of aiida.cmdline.params.types.plugin.PluginParamType.get_missing_message:1
msgid "Optionally might return extra information about a missing parameter."
msgstr ""

#: ../../../src/aiida/cmdline/params/types/code.py:docstring of aiida.cmdline.params.types.code:1
#: ../../../src/aiida/cmdline/params/types/config.py:docstring of aiida.cmdline.params.types.config:1
msgid "Module to define the custom click type for code."
msgstr ""

#: ../../../src/aiida/cmdline/params/types/code.py:docstring of aiida.cmdline.params.types.code.CodeParamType:1
msgid "The ParamType for identifying Code entities or its subclasses"
msgstr ""

#: ../../../src/aiida/cmdline/params/types/code.py:docstring of aiida.cmdline.params.types.code.CodeParamType.__init__:1
msgid "Construct the param type"
msgstr ""

#: ../../../src/aiida/cmdline/params/types/code.py:docstring of aiida.cmdline.params.types.code.CodeParamType.__init__:3
msgid "specify a tuple of Code sub classes to narrow the query set"
msgstr ""

#: ../../../src/aiida/cmdline/params/types/code.py:docstring of aiida.cmdline.params.types.code.CodeParamType.__init__:4
msgid "specify an optional calculation entry point that the Code's input plugin should match"
msgstr ""

#: ../../../src/aiida/cmdline/params/types/code.py:docstring of aiida.cmdline.params.types.code.CodeParamType.convert:1
#: ../../../src/aiida/cmdline/params/types/group.py:docstring of aiida.cmdline.params.types.group.GroupParamType.convert:1
#: ../../../src/aiida/cmdline/params/types/identifier.py:docstring of aiida.cmdline.params.types.identifier.IdentifierParamType.convert:1
msgid "Attempt to convert the given value to an instance of the orm class using the orm class loader."
msgstr ""

#: ../../../src/aiida/cmdline/params/types/code.py:docstring of aiida.cmdline.params.types.code.CodeParamType.convert:3
#: ../../../src/aiida/cmdline/params/types/group.py:docstring of aiida.cmdline.params.types.group.GroupParamType.convert:3
#: ../../../src/aiida/cmdline/params/types/identifier.py:docstring of aiida.cmdline.params.types.identifier.IdentifierParamType.convert:3
msgid "the loaded orm entity"
msgstr ""

#: ../../../src/aiida/cmdline/params/types/code.py:docstring of aiida.cmdline.params.types.code.CodeParamType.convert:4
#: ../../../src/aiida/cmdline/params/types/group.py:docstring of aiida.cmdline.params.types.group.GroupParamType.convert:4
#: ../../../src/aiida/cmdline/params/types/identifier.py:docstring of aiida.cmdline.params.types.identifier.IdentifierParamType.convert:4
msgid "if the value is ambiguous and leads to multiple entities"
msgstr ""

#: ../../../src/aiida/cmdline/params/types/code.py:docstring of aiida.cmdline.params.types.code.CodeParamType.convert:5
#: ../../../src/aiida/cmdline/params/types/group.py:docstring of aiida.cmdline.params.types.group.GroupParamType.convert:5
#: ../../../src/aiida/cmdline/params/types/identifier.py:docstring of aiida.cmdline.params.types.identifier.IdentifierParamType.convert:5
msgid "if the value cannot be mapped onto any existing instance"
msgstr ""

#: ../../../src/aiida/cmdline/params/types/code.py:docstring of aiida.cmdline.params.types.code.CodeParamType.convert:6
#: ../../../src/aiida/cmdline/params/types/group.py:docstring of aiida.cmdline.params.types.group.GroupParamType.convert:6
#: ../../../src/aiida/cmdline/params/types/identifier.py:docstring of aiida.cmdline.params.types.identifier.IdentifierParamType.convert:6
msgid "if the defined orm class loader is not a subclass of the OrmEntityLoader class"
msgstr ""

#: ../../../src/aiida/cmdline/params/types/code.py:docstring of aiida.cmdline.params.types.code.CodeParamType.shell_complete:1
#: ../../../src/aiida/cmdline/params/types/computer.py:docstring of aiida.cmdline.params.types.computer.ComputerParamType.shell_complete:1
#: ../../../src/aiida/cmdline/params/types/group.py:docstring of aiida.cmdline.params.types.group.GroupParamType.shell_complete:1
msgid "Return possible completions based on an incomplete value."
msgstr ""

#: ../../../src/aiida/cmdline/params/types/code.py:docstring of aiida.cmdline.params.types.code.CodeParamType.shell_complete:3
#: ../../../src/aiida/cmdline/params/types/computer.py:docstring of aiida.cmdline.params.types.computer.ComputerParamType.shell_complete:3
#: ../../../src/aiida/cmdline/params/types/config.py:docstring of aiida.cmdline.params.types.config.ConfigOptionParamType.shell_complete:3
#: ../../../src/aiida/cmdline/params/types/group.py:docstring of aiida.cmdline.params.types.group.GroupParamType.shell_complete:3
#: ../../../src/aiida/cmdline/params/types/plugin.py:docstring of aiida.cmdline.params.types.plugin.PluginParamType.shell_complete:3
#: ../../../src/aiida/cmdline/params/types/profile.py:docstring of aiida.cmdline.params.types.profile.ProfileParamType.shell_complete:3
#: ../../../src/aiida/cmdline/params/types/user.py:docstring of aiida.cmdline.params.types.user.UserParamType.shell_complete:3
msgid "list of tuples of valid entry points (matching incomplete) and a description"
msgstr ""

#: ../../../src/aiida/cmdline/params/types/computer.py:docstring of aiida.cmdline.params.types.computer:1
msgid "Module for the custom click param type computer"
msgstr ""

#: ../../../src/aiida/cmdline/params/types/computer.py:docstring of aiida.cmdline.params.types.computer.ComputerParamType:1
msgid "The ParamType for identifying Computer entities or its subclasses"
msgstr ""

#: ../../../src/aiida/cmdline/params/types/computer.py:docstring of aiida.cmdline.params.types.computer.MpirunCommandParamType:1
#: ../../../src/aiida/cmdline/params/types/computer.py:docstring of aiida.cmdline.params.types.computer.ShebangParamType:1
#: ../../../src/aiida/cmdline/params/types/config.py:docstring of aiida.cmdline.params.types.config.ConfigOptionParamType:1
#: ../../../src/aiida/cmdline/params/types/strings.py:docstring of aiida.cmdline.params.types.strings.EmailType:1
#: ../../../src/aiida/cmdline/params/types/strings.py:docstring of aiida.cmdline.params.types.strings.HostnameType:1
#: ../../../src/aiida/cmdline/params/types/strings.py:docstring of aiida.cmdline.params.types.strings.NonEmptyStringParamType:1
msgid "Bases: :py:class:`~click.types.StringParamType`"
msgstr ""

#: ../../../src/aiida/cmdline/params/types/computer.py:docstring of aiida.cmdline.params.types.computer.MpirunCommandParamType:1
msgid "Custom click param type for mpirun-command"
msgstr ""

#: ../../../src/aiida/cmdline/params/types/computer.py:docstring of aiida.cmdline.params.types.computer.MpirunCommandParamType:3
msgid "requires also a scheduler to be provided, and the scheduler must be called first!"
msgstr ""

#: ../../../src/aiida/cmdline/params/types/computer.py:docstring of aiida.cmdline.params.types.computer.MpirunCommandParamType:6
msgid "Validate that the provided 'mpirun' command only contains replacement fields (e.g. ``{tot_num_mpiprocs}``) that are known."
msgstr ""

#: ../../../src/aiida/cmdline/params/types/computer.py:docstring of aiida.cmdline.params.types.computer.MpirunCommandParamType:9
msgid "Return a list of arguments (by using 'value.strip().split(\" \") on the input string)"
msgstr ""

#: ../../../src/aiida/cmdline/params/types/computer.py:docstring of aiida.cmdline.params.types.computer.ShebangParamType:1
msgid "Custom click param type for shebang line"
msgstr ""

#: ../../../src/aiida/cmdline/params/types/config.py:docstring of aiida.cmdline.params.types.config.ConfigOptionParamType:1
msgid "ParamType for configuration options."
msgstr ""

#: ../../../src/aiida/cmdline/params/types/config.py:docstring of aiida.cmdline.params.types.config.ConfigOptionParamType.shell_complete:1
#: ../../../src/aiida/cmdline/params/types/plugin.py:docstring of aiida.cmdline.params.types.plugin.PluginParamType.shell_complete:1
#: ../../../src/aiida/cmdline/params/types/profile.py:docstring of aiida.cmdline.params.types.profile.ProfileParamType.shell_complete:1
#: ../../../src/aiida/cmdline/params/types/user.py:docstring of aiida.cmdline.params.types.user.UserParamType.shell_complete:1
msgid "Return possible completions based on an incomplete value"
msgstr ""

#: ../../../src/aiida/cmdline/params/types/data.py:docstring of aiida.cmdline.params.types.data:1
msgid "Module for the custom click param type for data"
msgstr ""

#: ../../../src/aiida/cmdline/params/types/data.py:docstring of aiida.cmdline.params.types.data.DataParamType:1
msgid "The ParamType for identifying Data entities or its subclasses"
msgstr ""

#: ../../../src/aiida/cmdline/params/types/group.py:docstring of aiida.cmdline.params.types.group:1
msgid "Module for custom click param type group."
msgstr ""

#: ../../../src/aiida/cmdline/params/types/group.py:docstring of aiida.cmdline.params.types.group.GroupParamType:1
msgid "The ParamType for identifying Group entities or its subclasses."
msgstr ""

#: ../../../src/aiida/cmdline/params/types/group.py:docstring of aiida.cmdline.params.types.group.GroupParamType.__init__:1
msgid "Construct the parameter type."
msgstr ""

#: ../../../src/aiida/cmdline/params/types/group.py:docstring of aiida.cmdline.params.types.group.GroupParamType.__init__:3
msgid "The `sub_classes` argument can be used to narrow the set of subclasses of `Group` that should be matched. By default all subclasses of `Group` will be matched, otherwise it is restricted to the subclasses that correspond to the entry point names in the tuple of `sub_classes`."
msgstr ""

#: ../../../src/aiida/cmdline/params/types/group.py:docstring of aiida.cmdline.params.types.group.GroupParamType.__init__:7
msgid "To prevent having to load the database environment at import time, the actual loading of the entry points is deferred until the call to `convert` is made. This is to keep the command line autocompletion light and responsive. The entry point strings will be validated, however, to see if they correspond to known entry points."
msgstr ""

#: ../../../src/aiida/cmdline/params/types/group.py:docstring of aiida.cmdline.params.types.group.GroupParamType.__init__:11
msgid "boolean, if True, will create the group if it does not yet exist. By default the group created will be of class `Group`, unless another subclass is specified through `sub_classes`. Note that in this case, only a single entry point name can be specified"
msgstr ""

#: ../../../src/aiida/cmdline/params/types/group.py:docstring of aiida.cmdline.params.types.group.GroupParamType.__init__:14
msgid "a tuple of entry point strings from the `aiida.groups` entry point group."
msgstr ""

#: ../../../src/aiida/cmdline/params/types/group.py:docstring of aiida.cmdline.params.types.group.GroupParamType.orm_class_loader:1
msgid "Return the orm entity loader class, which should be a subclass of `OrmEntityLoader`."
msgstr ""

#: ../../../src/aiida/cmdline/params/types/group.py:docstring of aiida.cmdline.params.types.group.GroupParamType.orm_class_loader:3
msgid "This class is supposed to be used to load the entity for a given identifier."
msgstr ""

#: ../../../src/aiida/cmdline/params/types/group.py:docstring of aiida.cmdline.params.types.group.GroupParamType.orm_class_loader:5
msgid "the orm entity loader class for this `ParamType`"
msgstr ""

#: ../../../src/aiida/cmdline/params/types/identifier.py:docstring of aiida.cmdline.params.types.identifier:1
msgid "Module for custom click param type identifier"
msgstr ""

#: ../../../src/aiida/cmdline/params/types/identifier.py:docstring of aiida.cmdline.params.types.identifier.IdentifierParamType:1
msgid "Bases: :py:class:`~click.types.ParamType`, :py:class:`~abc.ABC`"
msgstr ""

#: ../../../src/aiida/cmdline/params/types/identifier.py:docstring of aiida.cmdline.params.types.identifier.IdentifierParamType:1
msgid "An extension of click.ParamType for a generic identifier parameter. In AiiDA, orm entities can often be identified by either their ID, UUID or optionally some LABEL identifier. This parameter type implements the convert method, which attempts to convert a value passed to the command for a parameter with this type, to an orm entity. The actual loading of the entity is delegated to the orm class loader. Subclasses of this parameter type should implement the `orm_class_loader` method to return the appropriate orm class loader, which should be a subclass of `aiida.orm.utils.loaders.OrmEntityLoader` for the corresponding orm class."
msgstr ""

#: ../../../src/aiida/cmdline/params/types/identifier.py:docstring of aiida.cmdline.params.types.identifier.IdentifierParamType.__init__:1
msgid "Construct the parameter type, optionally specifying a tuple of entry points that reference classes that should be a sub class of the base orm class of the orm class loader. The classes pointed to by these entry points will be passed to the OrmEntityLoader when converting an identifier and they will restrict the query set by demanding that the class of the corresponding entity matches these sub classes."
msgstr ""

#: ../../../src/aiida/cmdline/params/types/identifier.py:docstring of aiida.cmdline.params.types.identifier.IdentifierParamType.__init__:6
msgid "To prevent having to load the database environment at import time, the actual loading of the entry points is deferred until the call to `convert` is made. This is to keep the command line autocompletion light and responsive. The validation of entry point strings is also postponed for the same reason."
msgstr ""

#: ../../../src/aiida/cmdline/params/types/identifier.py:docstring of aiida.cmdline.params.types.identifier.IdentifierParamType.__init__:10
msgid "a tuple of entry point strings that can narrow the set of orm classes that values will be mapped upon. These classes have to be strict sub classes of the base orm class defined by the orm class loader"
msgstr ""

#: ../../../src/aiida/cmdline/params/types/identifier.py:docstring of aiida.cmdline.params.types.identifier.IdentifierParamType._entry_points:1
msgid "Allowed entry points, loaded on demand"
msgstr ""

#: ../../../src/aiida/cmdline/params/types/multiple.py:docstring of aiida.cmdline.params.types.multiple:1
msgid "Module to define custom click param type for multiple values"
msgstr ""

#: ../../../src/aiida/cmdline/params/types/multiple.py:docstring of aiida.cmdline.params.types.multiple.MultipleValueParamType:1
msgid "An extension of click.ParamType that can parse multiple values for a given ParamType"
msgstr ""

#: ../../../src/aiida/cmdline/params/types/node.py:docstring of aiida.cmdline.params.types.node:1
msgid "Module to define the custom click param type for node"
msgstr ""

#: ../../../src/aiida/cmdline/params/types/node.py:docstring of aiida.cmdline.params.types.node.NodeParamType:1
msgid "The ParamType for identifying Node entities or its subclasses"
msgstr ""

#: ../../../src/aiida/cmdline/params/types/path.py:docstring of aiida.cmdline.params.types.path:1
msgid "Click parameter types for paths."
msgstr ""

#: ../../../src/aiida/cmdline/params/types/path.py:docstring of aiida.cmdline.params.types.path.AbsolutePathOrEmptyParamType:1
msgid "Bases: :py:class:`~aiida.cmdline.params.types.path.AbsolutePathParamType`"
msgstr ""

#: ../../../src/aiida/cmdline/params/types/path.py:docstring of aiida.cmdline.params.types.path.AbsolutePathOrEmptyParamType:1
msgid "The ParamType for identifying absolute Paths, accepting also empty paths."
msgstr ""

#: ../../../src/aiida/cmdline/params/types/path.py:docstring of aiida.cmdline.params.types.path.AbsolutePathParamType:1
#: ../../../src/aiida/cmdline/params/types/path.py:docstring of aiida.cmdline.params.types.path.PathOrUrl:1
msgid "Bases: :py:class:`~click.types.Path`"
msgstr ""

#: ../../../src/aiida/cmdline/params/types/path.py:docstring of aiida.cmdline.params.types.path.AbsolutePathParamType:1
msgid "The ParamType for identifying absolute Paths (derived from click.Path)."
msgstr ""

#: ../../../src/aiida/cmdline/params/types/path.py:docstring of aiida.cmdline.params.types.path.FileOrUrl:1
msgid "Bases: :py:class:`~click.types.File`"
msgstr ""

#: ../../../src/aiida/cmdline/params/types/path.py:docstring of aiida.cmdline.params.types.path.FileOrUrl:1
msgid "Extension of click's File-type to include URLs."
msgstr ""

#: ../../../src/aiida/cmdline/params/types/path.py:docstring of aiida.cmdline.params.types.path.FileOrUrl:3
msgid "Returns handle either to local file or to remote file fetched from URL."
msgstr ""

#: ../../../src/aiida/cmdline/params/types/path.py:docstring of aiida.cmdline.params.types.path.FileOrUrl:5
#: ../../../src/aiida/cmdline/params/types/path.py:docstring of aiida.cmdline.params.types.path.PathOrUrl:5
msgid "Maximum timeout accepted for URL response. Must be an integer in the range [0;60]."
msgstr ""

#: ../../../src/aiida/cmdline/params/types/path.py:docstring of aiida.cmdline.params.types.path.FileOrUrl.convert:1
msgid "Return file handle."
msgstr ""

#: ../../../src/aiida/cmdline/params/types/path.py:docstring of aiida.cmdline.params.types.path.FileOrUrl.get_url:1
msgid "Retrieve file from URL."
msgstr ""

#: ../../../src/aiida/cmdline/params/types/path.py:docstring of aiida.cmdline.params.types.path.PathOrUrl:1
msgid "Extension of click's Path-type to include URLs."
msgstr ""

#: ../../../src/aiida/cmdline/params/types/path.py:docstring of aiida.cmdline.params.types.path.PathOrUrl:3
msgid "A PathOrUrl can either be a `click.Path`-type or a URL."
msgstr ""

#: ../../../src/aiida/cmdline/params/types/path.py:docstring of aiida.cmdline.params.types.path.PathOrUrl.checks_url:1
msgid "Check whether URL is reachable within timeout."
msgstr ""

#: ../../../src/aiida/cmdline/params/types/path.py:docstring of aiida.cmdline.params.types.path.PathOrUrl.convert:1
msgid "Overwrite `convert` Check first if `click.Path`-type, then check if URL."
msgstr ""

#: ../../../src/aiida/cmdline/params/types/path.py:docstring of aiida.cmdline.params.types.path.check_timeout_seconds:1
msgid "Raise if timeout is not within range [0;60]"
msgstr ""

#: ../../../src/aiida/cmdline/params/types/plugin.py:docstring of aiida.cmdline.params.types.plugin:1
msgid "Click parameter type for AiiDA Plugins."
msgstr ""

#: ../../../src/aiida/cmdline/params/types/plugin.py:docstring of aiida.cmdline.params.types.plugin.PluginParamType:1
msgid "Bases: :py:class:`~aiida.cmdline.params.types.strings.EntryPointType`"
msgstr ""

#: ../../../src/aiida/cmdline/params/types/plugin.py:docstring of aiida.cmdline.params.types.plugin.PluginParamType:1
msgid "AiiDA Plugin name parameter type."
msgstr ""

#: ../../../src/aiida/cmdline/params/types/plugin.py:docstring of aiida.cmdline.params.types.plugin.PluginParamType:3
msgid "string or tuple of strings, where each is a valid entry point group. Adding the `aiida.` prefix is optional. If it is not detected it will be prepended internally."
msgstr ""

#: ../../../src/aiida/cmdline/params/types/plugin.py:docstring of aiida.cmdline.params.types.plugin.PluginParamType:5
msgid "when set to True, convert will not return the entry point, but the loaded entry point"
msgstr ""

#: ../../../src/aiida/cmdline/params/types/plugin.py:docstring of aiida.cmdline.params.types.plugin.PluginParamType:11
#: ../../../src/aiida/tools/data/array/kpoints/legacy.py:docstring of aiida.tools.data.array.kpoints.legacy.get_explicit_kpoints_path:8
msgid "or::"
msgstr ""

#: ../../../src/aiida/cmdline/params/types/plugin.py:docstring of aiida.cmdline.params.types.plugin.PluginParamType.__init__:1
msgid "Group should be either a string or a tuple of valid entry point groups. If it is not specified we use the tuple of all recognized entry point groups."
msgstr ""

#: ../../../src/aiida/cmdline/params/types/plugin.py:docstring of aiida.cmdline.params.types.plugin.PluginParamType.convert:1
msgid "Convert the string value to an entry point instance, if the value can be successfully parsed into an actual entry point. Will raise click.BadParameter if validation fails."
msgstr ""

#: ../../../src/aiida/cmdline/params/types/plugin.py:docstring of aiida.cmdline.params.types.plugin.PluginParamType.get_entry_point_from_string:1
msgid "Validate a given entry point string, which means that it should have a valid entry point string format and that the entry point unambiguously corresponds to an entry point in the groups configured for this instance of PluginParameterType."
msgstr ""

#: ../../../src/aiida/cmdline/params/types/plugin.py:docstring of aiida.cmdline.params.types.plugin.PluginParamType.get_entry_point_from_string:5
msgid "the entry point if valid"
msgstr ""

#: ../../../src/aiida/cmdline/params/types/plugin.py:docstring of aiida.cmdline.params.types.plugin.PluginParamType.get_entry_point_from_string:6
msgid "ValueError if the entry point string is invalid"
msgstr ""

#: ../../../src/aiida/cmdline/params/types/plugin.py:docstring of aiida.cmdline.params.types.plugin.PluginParamType.get_possibilities:1
msgid "Return a list of plugins starting with incomplete"
msgstr ""

#: ../../../src/aiida/cmdline/params/types/plugin.py:docstring of aiida.cmdline.params.types.plugin.PluginParamType.get_valid_arguments:1
msgid "Return a list of all available plugin names for the groups configured for this PluginParamType instance. If the entry point names are not unique, because there are multiple groups that contain an entry point that has an identical name, we need to prefix the names with the full group name"
msgstr ""

#: ../../../src/aiida/cmdline/params/types/plugin.py:docstring of aiida.cmdline.params.types.plugin.PluginParamType.get_valid_arguments:5
msgid "list of valid entry point strings"
msgstr ""

#: ../../../src/aiida/cmdline/params/types/plugin.py:docstring of aiida.cmdline.params.types.plugin.PluginParamType.groups:1
msgid "Returns a tuple of valid groups for this instance"
msgstr ""

#: ../../../src/aiida/cmdline/params/types/plugin.py:docstring of aiida.cmdline.params.types.plugin.PluginParamType.has_potential_ambiguity:1
msgid "Returns whether the set of supported entry point groups can lead to ambiguity when only an entry point name is specified. This will happen if one ore more groups share an entry point with a common name"
msgstr ""

#: ../../../src/aiida/cmdline/params/types/process.py:docstring of aiida.cmdline.params.types.process:1
msgid "Module for the process node parameter type"
msgstr ""

#: ../../../src/aiida/cmdline/params/types/process.py:docstring of aiida.cmdline.params.types.process.ProcessParamType:1
msgid "The ParamType for identifying ProcessNode entities or its subclasses"
msgstr ""

#: ../../../src/aiida/cmdline/params/types/profile.py:docstring of aiida.cmdline.params.types.profile:1
msgid "Profile param type for click."
msgstr ""

#: ../../../src/aiida/cmdline/params/types/profile.py:docstring of aiida.cmdline.params.types.profile.ProfileParamType:1
msgid "Bases: :py:class:`~aiida.cmdline.params.types.strings.LabelStringType`"
msgstr ""

#: ../../../src/aiida/cmdline/params/types/profile.py:docstring of aiida.cmdline.params.types.profile.ProfileParamType:1
msgid "The profile parameter type for click."
msgstr ""

#: ../../../src/aiida/cmdline/params/types/profile.py:docstring of aiida.cmdline.params.types.profile.ProfileParamType:3
msgid "This parameter type requires the command that uses it to define the ``context_class`` class attribute to be the :class:`aiida.cmdline.groups.verdi.VerdiContext` class, as that is responsible for creating the user defined object ``obj`` on the context and loads the instance config."
msgstr ""

#: ../../../src/aiida/cmdline/params/types/profile.py:docstring of aiida.cmdline.params.types.profile.ProfileParamType.convert:1
msgid "Attempt to match the given value to a valid profile."
msgstr ""

#: ../../../src/aiida/cmdline/params/types/strings.py:docstring of aiida.cmdline.params.types.strings:1
msgid "Module for various text-based string validation."
msgstr ""

#: ../../../src/aiida/cmdline/params/types/strings.py:docstring of aiida.cmdline.params.types.strings.EmailType:1
msgid "Parameter whose values have to correspond to a valid email address format."
msgstr ""

#: ../../../src/aiida/cmdline/params/types/strings.py:docstring of aiida.cmdline.params.types.strings.EmailType:3
msgid "For the moment, we do not require the domain suffix, i.e. 'aiida@localhost' is still valid."
msgstr ""

#: ../../../src/aiida/cmdline/params/types/strings.py:docstring of aiida.cmdline.params.types.strings.EntryPointType:1
#: ../../../src/aiida/cmdline/params/types/strings.py:docstring of aiida.cmdline.params.types.strings.LabelStringType:1
msgid "Bases: :py:class:`~aiida.cmdline.params.types.strings.NonEmptyStringParamType`"
msgstr ""

#: ../../../src/aiida/cmdline/params/types/strings.py:docstring of aiida.cmdline.params.types.strings.EntryPointType:1
msgid "Parameter whose values have to be valid Python entry point strings."
msgstr ""

#: ../../../src/aiida/cmdline/params/types/strings.py:docstring of aiida.cmdline.params.types.strings.EntryPointType:3
msgid "See https://packaging.python.org/en/latest/specifications/entry-points/"
msgstr ""

#: ../../../src/aiida/cmdline/params/types/strings.py:docstring of aiida.cmdline.params.types.strings.HostnameType:1
msgid "Parameter corresponding to a valid hostname (or empty) string."
msgstr ""

#: ../../../src/aiida/cmdline/params/types/strings.py:docstring of aiida.cmdline.params.types.strings.HostnameType:3
msgid "Regex according to https://stackoverflow.com/a/3824105/1069467"
msgstr ""

#: ../../../src/aiida/cmdline/params/types/strings.py:docstring of aiida.cmdline.params.types.strings.LabelStringType:1
msgid "Parameter accepting valid label strings."
msgstr ""

#: ../../../src/aiida/cmdline/params/types/strings.py:docstring of aiida.cmdline.params.types.strings.LabelStringType:3
msgid "Non-empty string, made up of word characters (includes underscores [1]), dashes, and dots."
msgstr ""

#: ../../../src/aiida/cmdline/params/types/strings.py:docstring of aiida.cmdline.params.types.strings.LabelStringType:5
msgid "[1] See https://docs.python.org/3/library/re.html"
msgstr ""

#: ../../../src/aiida/cmdline/params/types/strings.py:docstring of aiida.cmdline.params.types.strings.NonEmptyStringParamType:1
msgid "Parameter whose values have to be string and non-empty."
msgstr ""

#: ../../../src/aiida/cmdline/params/types/user.py:docstring of aiida.cmdline.params.types.user:1
msgid "User param type for click."
msgstr ""

#: ../../../src/aiida/cmdline/params/types/user.py:docstring of aiida.cmdline.params.types.user.UserParamType:1
msgid "The user parameter type for click.   Can get or create a user."
msgstr ""

#: ../../../src/aiida/cmdline/params/types/user.py:docstring of aiida.cmdline.params.types.user.UserParamType.__init__:1
msgid "If the user does not exist, create a new instance (unstored)."
msgstr ""

#: ../../../src/aiida/cmdline/params/types/workflow.py:docstring of aiida.cmdline.params.types.workflow:1
msgid "Module for the workflow parameter type"
msgstr ""

#: ../../../src/aiida/cmdline/params/types/workflow.py:docstring of aiida.cmdline.params.types.workflow.WorkflowParamType:1
msgid "The ParamType for identifying WorkflowNode entities or its subclasses"
msgstr ""

#: ../../source/reference/apidoc/aiida.cmdline.utils.rst:2
msgid "aiida.cmdline.utils package"
msgstr ""

#: ../../../src/aiida/cmdline/utils/__init__.py:docstring of aiida.cmdline.utils:1
msgid "Commandline utility functions."
msgstr ""

#: ../../../src/aiida/cmdline/utils/ascii_vis.py:docstring of aiida.cmdline.utils.ascii_vis:1
msgid "Utility functions to draw ASCII diagrams to the command line."
msgstr ""

#: ../../../src/aiida/cmdline/utils/ascii_vis.py:docstring of aiida.cmdline.utils.ascii_vis.build_call_graph:1
msgid "Build the call graph of a given node."
msgstr ""

#: ../../../src/aiida/cmdline/utils/ascii_vis.py:docstring of aiida.cmdline.utils.ascii_vis.build_call_graph:3
#: ../../../src/aiida/cmdline/utils/ascii_vis.py:docstring of aiida.cmdline.utils.ascii_vis.calc_info:3
#: ../../../src/aiida/cmdline/utils/ascii_vis.py:docstring of aiida.cmdline.utils.ascii_vis.format_call_graph:3
msgid "The calculation node"
msgstr ""

#: ../../../src/aiida/cmdline/utils/ascii_vis.py:docstring of aiida.cmdline.utils.ascii_vis.build_call_graph:4
msgid "Maximum depth of the call graph to build. Use `None` for unlimited."
msgstr ""

#: ../../../src/aiida/cmdline/utils/ascii_vis.py:docstring of aiida.cmdline.utils.ascii_vis.build_call_graph:5
#: ../../../src/aiida/cmdline/utils/ascii_vis.py:docstring of aiida.cmdline.utils.ascii_vis.calc_info:4
#: ../../../src/aiida/cmdline/utils/ascii_vis.py:docstring of aiida.cmdline.utils.ascii_vis.format_call_graph:5
msgid "Include the call link label if other from the default ``CALL``."
msgstr ""

#: ../../../src/aiida/cmdline/utils/ascii_vis.py:docstring of aiida.cmdline.utils.ascii_vis.build_call_graph:6
#: ../../../src/aiida/cmdline/utils/ascii_vis.py:docstring of aiida.cmdline.utils.ascii_vis.format_call_graph:6
msgid "An optional function that takes the node and returns a string of information to be displayed for each node."
msgstr ""

#: ../../../src/aiida/cmdline/utils/ascii_vis.py:docstring of aiida.cmdline.utils.ascii_vis.calc_info:1
msgid "Return a string with the summary of the state of a CalculationNode."
msgstr ""

#: ../../../src/aiida/cmdline/utils/ascii_vis.py:docstring of aiida.cmdline.utils.ascii_vis.format_call_graph:1
msgid "Print a tree like the POSIX tree command for the calculation call graph."
msgstr ""

#: ../../../src/aiida/cmdline/utils/ascii_vis.py:docstring of aiida.cmdline.utils.ascii_vis.format_call_graph:4
msgid "Maximum depth of the call graph to print"
msgstr ""

#: ../../../src/aiida/cmdline/utils/ascii_vis.py:docstring of aiida.cmdline.utils.ascii_vis.format_tree_descending:1
msgid "Format a descending tree."
msgstr ""

#: ../../../src/aiida/cmdline/utils/common.py:docstring of aiida.cmdline.utils.common:1
msgid "Common utility functions for command line commands."
msgstr ""

#: ../../../src/aiida/cmdline/utils/common.py:docstring of aiida.cmdline.utils.common.format_flat_links:1
msgid "Given a flat list of LinkTriples, return a flat string representation."
msgstr ""

#: ../../../src/aiida/cmdline/utils/common.py:docstring of aiida.cmdline.utils.common.format_flat_links:3
msgid "a list of LinkTriples"
msgstr ""

#: ../../../src/aiida/cmdline/utils/common.py:docstring of aiida.cmdline.utils.common.format_flat_links:4
#: ../../../src/aiida/cmdline/utils/common.py:docstring of aiida.cmdline.utils.common.format_nested_links:4
msgid "headers to use"
msgstr ""

#: ../../../src/aiida/cmdline/utils/common.py:docstring of aiida.cmdline.utils.common.format_flat_links:5
msgid "formatted string"
msgstr ""

#: ../../../src/aiida/cmdline/utils/common.py:docstring of aiida.cmdline.utils.common.format_local_time:1
msgid "Format a datetime object or UNIX timestamp in a human readable format"
msgstr ""

#: ../../../src/aiida/cmdline/utils/common.py:docstring of aiida.cmdline.utils.common.format_local_time:3
msgid "a datetime object or a float representing a UNIX timestamp"
msgstr ""

#: ../../../src/aiida/cmdline/utils/common.py:docstring of aiida.cmdline.utils.common.format_local_time:4
msgid "optional string format to pass to strftime"
msgstr ""

#: ../../../src/aiida/cmdline/utils/common.py:docstring of aiida.cmdline.utils.common.format_nested_links:1
msgid "Given a nested dictionary of nodes, return a nested string representation."
msgstr ""

#: ../../../src/aiida/cmdline/utils/common.py:docstring of aiida.cmdline.utils.common.format_nested_links:3
msgid "a nested dictionary of nodes"
msgstr ""

#: ../../../src/aiida/cmdline/utils/common.py:docstring of aiida.cmdline.utils.common.format_nested_links:5
msgid "nested formatted string"
msgstr ""

#: ../../../src/aiida/cmdline/utils/common.py:docstring of aiida.cmdline.utils.common.get_calcjob_report:1
msgid "Return a multi line string representation of the log messages and output of a given calcjob"
msgstr ""

#: ../../../src/aiida/cmdline/utils/common.py:docstring of aiida.cmdline.utils.common.get_calcjob_report:3
msgid "the calcjob node"
msgstr ""

#: ../../../src/aiida/cmdline/utils/common.py:docstring of aiida.cmdline.utils.common.get_calcjob_report:4
msgid "a string representation of the log messages and scheduler output"
msgstr ""

#: ../../../src/aiida/cmdline/utils/common.py:docstring of aiida.cmdline.utils.common.get_env_with_venv_bin:1
msgid "Create a clone of the current running environment with the AIIDA_PATH variable set directory of the config."
msgstr ""

#: ../../../src/aiida/cmdline/utils/common.py:docstring of aiida.cmdline.utils.common.get_node_info:1
msgid "Return a multi line string of information about the given node, such as the incoming and outcoming links."
msgstr ""

#: ../../../src/aiida/cmdline/utils/common.py:docstring of aiida.cmdline.utils.common.get_node_info:3
msgid "boolean, if True, also include a summary of node properties"
msgstr ""

#: ../../../src/aiida/cmdline/utils/common.py:docstring of aiida.cmdline.utils.common.get_node_info:4
msgid "a string summary of the node including a description of all its links and log messages"
msgstr ""

#: ../../../src/aiida/cmdline/utils/common.py:docstring of aiida.cmdline.utils.common.get_node_summary:1
msgid "Return a multi line string with a pretty formatted summary of a Node."
msgstr ""

#: ../../../src/aiida/cmdline/utils/common.py:docstring of aiida.cmdline.utils.common.get_node_summary:3
#: ../../../src/aiida/orm/comments.py:docstring of aiida.orm.comments.Comment.__init__:3
#: ../../../src/aiida/orm/implementation/comments.py:docstring of aiida.orm.implementation.comments.BackendCommentCollection.create:3
#: ../../../src/aiida/orm/utils/log.py:docstring of aiida.orm.utils.log.get_dblogger_extra:3
#: ../../../src/aiida/storage/psql_dos/orm/comments.py:docstring of aiida.storage.psql_dos.orm.comments.SqlaComment.__init__:3
#: ../../../src/aiida/storage/psql_dos/orm/comments.py:docstring of aiida.storage.psql_dos.orm.comments.SqlaCommentCollection.create:3
msgid "a Node instance"
msgstr ""

#: ../../../src/aiida/cmdline/utils/common.py:docstring of aiida.cmdline.utils.common.get_node_summary:4
msgid "a string summary of the node"
msgstr ""

#: ../../../src/aiida/cmdline/utils/common.py:docstring of aiida.cmdline.utils.common.get_process_function_report:1
msgid "Return a multi line string representation of the log messages and output of a given process function node"
msgstr ""

#: ../../../src/aiida/cmdline/utils/common.py:docstring of aiida.cmdline.utils.common.get_process_function_report:3
#: ../../../src/aiida/cmdline/utils/repository.py:docstring of aiida.cmdline.utils.repository.list_repository_contents:3
msgid "the node"
msgstr ""

#: ../../../src/aiida/cmdline/utils/common.py:docstring of aiida.cmdline.utils.common.get_process_function_report:4
msgid "a string representation of the log messages"
msgstr ""

#: ../../../src/aiida/cmdline/utils/common.py:docstring of aiida.cmdline.utils.common.get_workchain_report:1
msgid "Return a multi line string representation of the log messages and output of a given workchain"
msgstr ""

#: ../../../src/aiida/cmdline/utils/common.py:docstring of aiida.cmdline.utils.common.get_workchain_report:3
msgid "the workchain node"
msgstr ""

#: ../../../src/aiida/cmdline/utils/common.py:docstring of aiida.cmdline.utils.common.get_workchain_report:4
msgid "a nested string representation of the log messages"
msgstr ""

#: ../../../src/aiida/cmdline/utils/common.py:docstring of aiida.cmdline.utils.common.is_verbose:1
msgid "Return whether the configured logging verbosity is considered verbose, i.e., equal or lower to ``INFO`` level."
msgstr ""

#: ../../../src/aiida/cmdline/utils/common.py:docstring of aiida.cmdline.utils.common.is_verbose:3
msgid "This checks the effective logging level that is set on the ``CMDLINE_LOGGER``. This means that it will consider the logging level set on the parent ``AIIDA_LOGGER`` if not explicitly set on itself. The level of the main logger can be manipulated from the command line through the ``VERBOSITY`` option that is available for all commands."
msgstr ""

#: ../../../src/aiida/cmdline/utils/common.py:docstring of aiida.cmdline.utils.common.print_last_process_state_change:1
msgid "Print the last time that a process of the specified type has changed its state."
msgstr ""

#: ../../../src/aiida/cmdline/utils/common.py:docstring of aiida.cmdline.utils.common.print_last_process_state_change:3
msgid "optional process type for which to get the latest state change timestamp. Valid process types are either 'calculation' or 'work'."
msgstr ""

#: ../../../src/aiida/cmdline/utils/common.py:docstring of aiida.cmdline.utils.common.print_process_info:1
msgid "Print detailed information about a process class and its process specification."
msgstr ""

#: ../../../src/aiida/cmdline/utils/common.py:docstring of aiida.cmdline.utils.common.print_process_info:3
msgid "a :py:class:`~aiida.engine.processes.process.Process` class"
msgstr ""

#: ../../../src/aiida/cmdline/utils/common.py:docstring of aiida.cmdline.utils.common.print_process_spec:1
msgid "Print the process spec in a human-readable formatted way."
msgstr ""

#: ../../../src/aiida/cmdline/utils/common.py:docstring of aiida.cmdline.utils.common.print_process_spec:3
msgid "a `ProcessSpec` instance"
msgstr ""

#: ../../../src/aiida/cmdline/utils/common.py:docstring of aiida.cmdline.utils.common.tabulate:1
msgid "A dummy wrapper to hide the import cost of tabulate"
msgstr ""

#: ../../../src/aiida/cmdline/utils/decorators.py:docstring of aiida.cmdline.utils.decorators:1
msgid "Various decorators useful for creating verdi commands, for example loading the dbenv lazily."
msgstr ""

#: ../../../src/aiida/cmdline/utils/decorators.py:docstring of aiida.cmdline.utils.decorators:3
msgid "Always avoids trying to load the dbenv twice. When it has to be loaded, a spinner ASCII widget is displayed."
msgstr ""

#: ../../../src/aiida/cmdline/utils/decorators.py:docstring of aiida.cmdline.utils.decorators:8
msgid "Provides:"
msgstr ""

#: ../../../src/aiida/cmdline/utils/decorators.py:docstring of aiida.cmdline.utils.decorators:7
msgid "with_dbenv, a decorator to frontload the dbenv for functions"
msgstr ""

#: ../../../src/aiida/cmdline/utils/decorators.py:docstring of aiida.cmdline.utils.decorators:8
msgid "dbenv, a contextmanager to load the dbenv only if a specific"
msgstr ""

#: ../../../src/aiida/cmdline/utils/decorators.py:docstring of aiida.cmdline.utils.decorators:9
msgid "code branch gets visited and possibly avoiding the overhead if not"
msgstr ""

#: ../../../src/aiida/cmdline/utils/decorators.py:docstring of aiida.cmdline.utils.decorators.check_circus_zmq_version:1
msgid "Function decorator to check for the right ZMQ version before trying to run circus."
msgstr ""

#: ../../../src/aiida/cmdline/utils/decorators.py:docstring of aiida.cmdline.utils.decorators.dbenv:1
msgid "Loads the dbenv for a specific region of code, does not unload afterwards"
msgstr ""

#: ../../../src/aiida/cmdline/utils/decorators.py:docstring of aiida.cmdline.utils.decorators.dbenv:3
msgid "Only use when it makes it possible to avoid loading the dbenv for certain code paths"
msgstr ""

#: ../../../src/aiida/cmdline/utils/decorators.py:docstring of aiida.cmdline.utils.decorators.dbenv:6
msgid "Good Example::"
msgstr ""

#: ../../../src/aiida/cmdline/utils/decorators.py:docstring of aiida.cmdline.utils.decorators.dbenv:21
msgid "This will run very fast without the --with-db flag and slow only if database info is requested"
msgstr ""

#: ../../../src/aiida/cmdline/utils/decorators.py:docstring of aiida.cmdline.utils.decorators.dbenv:23
msgid "Do not use if you will end up loading the dbenv anyway"
msgstr ""

#: ../../../src/aiida/cmdline/utils/decorators.py:docstring of aiida.cmdline.utils.decorators.dbenv:25
msgid "Bad Example::"
msgstr ""

#: ../../../src/aiida/cmdline/utils/decorators.py:docstring of aiida.cmdline.utils.decorators.deprecated_command:1
msgid "Function decorator that will mark a click command as deprecated when invoked."
msgstr ""

#: ../../../src/aiida/cmdline/utils/decorators.py:docstring of aiida.cmdline.utils.decorators.load_backend_if_not_loaded:1
msgid "Load the database backend environment for the currently loaded profile."
msgstr ""

#: ../../../src/aiida/cmdline/utils/decorators.py:docstring of aiida.cmdline.utils.decorators.load_backend_if_not_loaded:3
msgid "If no profile has been loaded yet, the default profile will be loaded first. A spinner will be shown during both actions to indicate that the function is working and has not crashed, since loading can take a second."
msgstr ""

#: ../../../src/aiida/cmdline/utils/decorators.py:docstring of aiida.cmdline.utils.decorators.only_if_daemon_not_running:1
msgid "Function decorator for CLI command to print critical error and exit automatically when daemon is running."
msgstr ""

#: ../../../src/aiida/cmdline/utils/decorators.py:docstring of aiida.cmdline.utils.decorators.only_if_daemon_not_running:3
#: ../../../src/aiida/cmdline/utils/decorators.py:docstring of aiida.cmdline.utils.decorators.only_if_daemon_running:3
msgid "The error printing and exit behavior can be controlled with the decorator keyword arguments. The default message that is printed can be overridden as well as the echo function that is to be used. By default it uses the `aiida.cmdline.utils.echo.echo_critical` function which automatically aborts the command. The function can be substituted by for example `aiida.cmdline.utils.echo.echo_warning` to instead print just a warning and continue."
msgstr ""

#: ../../../src/aiida/cmdline/utils/decorators.py:docstring of aiida.cmdline.utils.decorators.only_if_daemon_not_running:14
#: ../../../src/aiida/cmdline/utils/decorators.py:docstring of aiida.cmdline.utils.decorators.only_if_daemon_running:14
msgid "echo function to issue the message, should be from `aiida.cmdline.utils.echo`"
msgstr ""

#: ../../../src/aiida/cmdline/utils/decorators.py:docstring of aiida.cmdline.utils.decorators.only_if_daemon_not_running:15
#: ../../../src/aiida/cmdline/utils/decorators.py:docstring of aiida.cmdline.utils.decorators.only_if_daemon_running:15
msgid "optional message to override the default message"
msgstr ""

#: ../../../src/aiida/cmdline/utils/decorators.py:docstring of aiida.cmdline.utils.decorators.only_if_daemon_running:1
msgid "Function decorator for CLI command to print critical error and exit automatically when daemon is not running."
msgstr ""

#: ../../../src/aiida/cmdline/utils/decorators.py:docstring of aiida.cmdline.utils.decorators.requires_loaded_profile:1
msgid "Function decorator for CLI command that requires a profile to be loaded."
msgstr ""

#: ../../../src/aiida/cmdline/utils/decorators.py:docstring of aiida.cmdline.utils.decorators.requires_loaded_profile:9
msgid "If no profile has been loaded, the command will exit with a critical error. Most ``verdi`` commands will automatically load the default profile. So if this error is hit, it is most likely that either no profile have been defined at all or the default is unspecified."
msgstr ""

#: ../../../src/aiida/cmdline/utils/decorators.py:docstring of aiida.cmdline.utils.decorators.with_dbenv:1
msgid "Function decorator that will load the database environment for the currently loaded profile."
msgstr ""

#: ../../../src/aiida/cmdline/utils/decorators.py:docstring of aiida.cmdline.utils.decorators.with_dbenv:3
msgid "if no profile has been loaded yet, the default profile will be loaded first."
msgstr ""

#: ../../../src/aiida/cmdline/utils/decorators.py:docstring of aiida.cmdline.utils.decorators.with_manager:1
msgid "Decorate a function injecting a :class:`kiwipy.rmq.communicator.RmqCommunicator`."
msgstr ""

#: ../../../src/aiida/cmdline/utils/defaults.py:docstring of aiida.cmdline.utils.defaults:1
msgid "Default values and lazy default get methods for command line options."
msgstr ""

#: ../../../src/aiida/cmdline/utils/defaults.py:docstring of aiida.cmdline.utils.defaults.get_default_profile:1
msgid "Try to get the name of the default profile."
msgstr ""

#: ../../../src/aiida/cmdline/utils/defaults.py:docstring of aiida.cmdline.utils.defaults.get_default_profile:3
msgid "This utility function should only be used for defaults or callbacks in command line interface parameters. Otherwise, the preference should go to calling `get_config` to load the actual config and using `config.default_profile_name` to get the default profile name."
msgstr ""

#: ../../../src/aiida/cmdline/utils/defaults.py:docstring of aiida.cmdline.utils.defaults.get_default_profile:7
msgid "if the config could not be loaded or no default profile exists"
msgstr ""

#: ../../../src/aiida/cmdline/utils/defaults.py:docstring of aiida.cmdline.utils.defaults.get_default_profile:8
msgid "the default profile name or None if no default is defined in the configuration"
msgstr ""

#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo:1
msgid "Convenience functions for logging output from ``verdi`` commands."
msgstr ""

#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo._format_dictionary_json_date:1
msgid "Return a dictionary formatted as a string using the json format and converting dates to strings."
msgstr ""

#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo._format_yaml:1
msgid "Return a dictionary formatted as a string using the YAML format."
msgstr ""

#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo._format_yaml_expanded:1
msgid "Return a dictionary formatted as a string using the expanded YAML format."
msgstr ""

#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo:1
msgid "Log a message to the cmdline logger."
msgstr ""

#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo:3
msgid "The message will be logged at the ``REPORT`` level but always without the log level prefix."
msgstr ""

#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo:5
#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_critical:6
#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_debug:3
#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_deprecated:5
#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_error:3
#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_info:3
#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_report:3
#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_success:5
#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_warning:3
msgid "the message to log."
msgstr ""

#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo:6
msgid "if provided this will become the foreground color."
msgstr ""

#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo:7
msgid "whether to print the messaformat bold."
msgstr ""

#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo:8
msgid "whether to print a newlineaddhe end of the message."
msgstr ""

#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo:9
#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_critical:9
#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_debug:6
#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_deprecated:8
#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_error:6
#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_info:6
#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_report:6
#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_success:8
#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_warning:6
msgid "whether to log to stderr."
msgstr ""

#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_critical:1
msgid "Log a critical error message to the cmdline logger and exit with ``exit_status``."
msgstr ""

#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_critical:3
msgid "This should be used to print messages for errors that cannot be recovered from and so the script should be directly terminated with a non-zero exit status to indicate that the command failed."
msgstr ""

#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_critical:7
#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_debug:4
#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_deprecated:6
#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_error:4
#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_info:4
#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_report:4
#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_success:6
#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_warning:4
msgid "whether to format the message in bold."
msgstr ""

#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_critical:8
#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_debug:5
#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_deprecated:7
#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_error:5
#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_info:5
#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_report:5
#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_success:7
#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_warning:5
msgid "whether to add a newline at the end of the message."
msgstr ""

#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_critical:10
#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_debug:7
#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_error:7
#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_info:7
#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_report:7
#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_success:9
#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_warning:7
msgid "whether the message should be prefixed with a colored version of the log level."
msgstr ""

#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_debug:1
msgid "Log a debug message to the cmdline logger."
msgstr ""

#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_deprecated:1
msgid "Log an error message to the cmdline logger, prefixed with 'Deprecated:' exiting with the given ``exit_status``."
msgstr ""

#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_deprecated:3
msgid "This should be used to indicate deprecated commands."
msgstr ""

#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_deprecated:9
msgid "whether to exit after printing the message"
msgstr ""

#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_dictionary:1
msgid "Log the given dictionary to stdout in the given format"
msgstr ""

#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_dictionary:3
msgid "the dictionary"
msgstr ""

#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_dictionary:4
msgid "the format to use for printing"
msgstr ""

#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_dictionary:5
msgid "Whether to automatically sort keys"
msgstr ""

#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_error:1
msgid "Log an error message to the cmdline logger."
msgstr ""

#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_formatted_list:1
msgid "Log a collection of entries as a formatted list, one entry per line."
msgstr ""

#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_formatted_list:3
msgid "a list of objects"
msgstr ""

#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_formatted_list:4
msgid "a list of attributes to log for each entry in the collection"
msgstr ""

#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_formatted_list:5
msgid "optional lambda to sort the collection"
msgstr ""

#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_formatted_list:6
msgid "optional lambda to highlight an entry in the collection if it returns True"
msgstr ""

#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_formatted_list:7
msgid "optional lambda to skip an entry if it returns True"
msgstr ""

#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_info:1
msgid "Log an info message to the cmdline logger."
msgstr ""

#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_report:1
msgid "Log an report message to the cmdline logger."
msgstr ""

#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_success:1
msgid "Log a success message to the cmdline logger."
msgstr ""

#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_success:3
msgid "The message will be logged at the ``REPORT`` level and always with the ``Success:`` prefix."
msgstr ""

#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_tabulate:1
msgid "Echo the string generated by passing ``table`` to ``tabulate.tabulate``."
msgstr ""

#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_tabulate:3
msgid "This wrapper is added in order to lazily import the ``tabulate`` package only when invoked. This helps keeping the import time of the :mod:`aiida.cmdline` to a minimum, which is critical for keeping tab-completion snappy."
msgstr ""

#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_tabulate:6
msgid "The table of data to echo."
msgstr ""

#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_tabulate:7
msgid "Additional arguments passed to :meth:`tabulate.tabulate`."
msgstr ""

#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.echo_warning:1
msgid "Log a warning message to the cmdline logger."
msgstr ""

#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.highlight_string:1
msgid "Highlight a string with a certain color."
msgstr ""

#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.highlight_string:3
msgid "Uses ``click.style`` to highlight the string."
msgstr ""

#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.highlight_string:5
msgid "The string to highlight."
msgstr ""

#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.highlight_string:6
msgid "The color to use."
msgstr ""

#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.highlight_string:7
msgid "The highlighted string."
msgstr ""

#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.is_stdout_redirected:1
msgid "Determines if the standard output is redirected."
msgstr ""

#: ../../../src/aiida/cmdline/utils/echo.py:docstring of aiida.cmdline.utils.echo.is_stdout_redirected:3
msgid "For cases where the standard output is redirected and you want to inform the user without messing up the output. Example::"
msgstr ""

#: ../../../src/aiida/cmdline/utils/log.py:docstring of aiida.cmdline.utils.log:1
msgid "Utilities for logging in the command line interface context."
msgstr ""

#: ../../../src/aiida/cmdline/utils/log.py:docstring of aiida.cmdline.utils.log.CliFormatter:1
msgid "Bases: :py:class:`~logging.Formatter`"
msgstr ""

#: ../../../src/aiida/cmdline/utils/log.py:docstring of aiida.cmdline.utils.log.CliFormatter:1
msgid "Formatter that automatically prefixes log messages with a colored version of the log level."
msgstr ""

#: ../../../src/aiida/cmdline/utils/log.py:docstring of aiida.cmdline.utils.log.CliFormatter.format:1
msgid "Format the record using the style required for the command line interface."
msgstr ""

#: ../../../src/aiida/cmdline/utils/log.py:docstring of aiida.cmdline.utils.log.CliHandler:1
#: ../../../src/aiida/orm/utils/log.py:docstring of aiida.orm.utils.log.DBLogHandler:1
msgid "Bases: :py:class:`~logging.Handler`"
msgstr ""

#: ../../../src/aiida/cmdline/utils/log.py:docstring of aiida.cmdline.utils.log.CliHandler:1
msgid "Handler for writing to the console using click."
msgstr ""

#: ../../../src/aiida/cmdline/utils/log.py:docstring of aiida.cmdline.utils.log.CliHandler.emit:1
msgid "Emit log record via click."
msgstr ""

#: ../../../src/aiida/cmdline/utils/log.py:docstring of aiida.cmdline.utils.log.CliHandler.emit:3
msgid "Can make use of special attributes 'nl' (whether to add newline) and 'err' (whether to print to stderr), which can be set via the 'extra' dictionary parameter of the logging methods."
msgstr ""

#: ../../../src/aiida/cmdline/utils/multi_line_input.py:docstring of aiida.cmdline.utils.multi_line_input:1
msgid "Utilities for getting multi line input from the commandline."
msgstr ""

#: ../../../src/aiida/cmdline/utils/multi_line_input.py:docstring of aiida.cmdline.utils.multi_line_input.edit_comment:1
msgid "Call up an editor to edit comments to nodes in the database"
msgstr ""

#: ../../../src/aiida/cmdline/utils/multi_line_input.py:docstring of aiida.cmdline.utils.multi_line_input.edit_multiline_template:1
msgid "Open a template file for editing in a text editor."
msgstr ""

#: ../../../src/aiida/cmdline/utils/multi_line_input.py:docstring of aiida.cmdline.utils.multi_line_input.edit_multiline_template:3
msgid "name of the template to use from the ``aiida.cmdline.templates`` directory."
msgstr ""

#: ../../../src/aiida/cmdline/utils/multi_line_input.py:docstring of aiida.cmdline.utils.multi_line_input.edit_multiline_template:4
msgid "the set of symbols that mark a comment line that should be stripped from the final value"
msgstr ""

#: ../../../src/aiida/cmdline/utils/multi_line_input.py:docstring of aiida.cmdline.utils.multi_line_input.edit_multiline_template:5
msgid "the file extension to give to the rendered template file."
msgstr ""

#: ../../../src/aiida/cmdline/utils/multi_line_input.py:docstring of aiida.cmdline.utils.multi_line_input.edit_multiline_template:6
msgid "keywords that will be passed to the template rendering engine."
msgstr ""

#: ../../../src/aiida/cmdline/utils/multi_line_input.py:docstring of aiida.cmdline.utils.multi_line_input.edit_multiline_template:7
msgid "the final string value entered in the editor with all comment lines stripped or an empty string if the ``click.edit`` returned ``None``."
msgstr ""

#: ../../../src/aiida/cmdline/utils/pluginable.py:docstring of aiida.cmdline.utils.pluginable:1
msgid "Plugin aware click command Group."
msgstr ""

#: ../../../src/aiida/cmdline/utils/pluginable.py:docstring of aiida.cmdline.utils.pluginable.Pluginable:1
msgid "A click command group that finds and loads plugin commands lazily."
msgstr ""

#: ../../../src/aiida/cmdline/utils/pluginable.py:docstring of aiida.cmdline.utils.pluginable.Pluginable.__init__:1
msgid "Initialize with entry point group."
msgstr ""

#: ../../../src/aiida/cmdline/utils/pluginable.py:docstring of aiida.cmdline.utils.pluginable.Pluginable.get_command:1
msgid "Try to load a subcommand from entry points, else defer to super."
msgstr ""

#: ../../../src/aiida/cmdline/utils/pluginable.py:docstring of aiida.cmdline.utils.pluginable.Pluginable.list_commands:1
msgid "Add entry point names of available plugins to the command list."
msgstr ""

#: ../../../src/aiida/cmdline/utils/pluginable.py:docstring of aiida.cmdline.utils.pluginable.Pluginable.set_exclude_external_plugins:1
msgid "Set whether external plugins should be excluded."
msgstr ""

#: ../../../src/aiida/cmdline/utils/pluginable.py:docstring of aiida.cmdline.utils.pluginable.Pluginable.set_exclude_external_plugins:3
msgid "If `exclude_external_plugins` is set to `True`, the plugins that belong to the `entry_point_group` defined for this `click.Group` will not be discoverable. This is useful to limit the available commands to only those provided by `aiida-core` (excluding those provided by plugins)."
msgstr ""

#: ../../../src/aiida/cmdline/utils/pluginable.py:docstring of aiida.cmdline.utils.pluginable.Pluginable.set_exclude_external_plugins:7
msgid "bool, when True, external plugins will not be discoverable"
msgstr ""

#: ../../../src/aiida/cmdline/utils/repository.py:docstring of aiida.cmdline.utils.repository:1
msgid "Utility functions for command line commands operating on the repository."
msgstr ""

#: ../../../src/aiida/cmdline/utils/repository.py:docstring of aiida.cmdline.utils.repository.list_repository_contents:1
msgid "Print the contents of the directory `path` in the repository of the given node to stdout."
msgstr ""

#: ../../../src/aiida/cmdline/utils/repository.py:docstring of aiida.cmdline.utils.repository.list_repository_contents:4
msgid "directory path"
msgstr ""

#: ../../../src/aiida/cmdline/utils/repository.py:docstring of aiida.cmdline.utils.repository.list_repository_contents:5
msgid "if the `path` does not exist in the repository of the given node"
msgstr ""

#: ../../../src/aiida/cmdline/utils/shell.py:docstring of aiida.cmdline.utils.shell:1
msgid "Definition of modules that are to be automatically loaded for `verdi shell`."
msgstr ""

#: ../../../src/aiida/cmdline/utils/shell.py:docstring of aiida.cmdline.utils.shell._ipython:1
msgid "Start IPython >= 1.0"
msgstr ""

#: ../../../src/aiida/cmdline/utils/shell.py:docstring of aiida.cmdline.utils.shell._ipython_pre_011:1
msgid "Start IPython pre-0.11"
msgstr ""

#: ../../../src/aiida/cmdline/utils/shell.py:docstring of aiida.cmdline.utils.shell._ipython_pre_100:1
msgid "Start IPython pre-1.0.0"
msgstr ""

#: ../../../src/aiida/cmdline/utils/shell.py:docstring of aiida.cmdline.utils.shell.bpython:1
msgid "Start a bpython shell."
msgstr ""

#: ../../../src/aiida/cmdline/utils/shell.py:docstring of aiida.cmdline.utils.shell.get_start_namespace:1
msgid "Load all default and custom modules"
msgstr ""

#: ../../../src/aiida/cmdline/utils/shell.py:docstring of aiida.cmdline.utils.shell.ipython:1
msgid "Start any version of IPython"
msgstr ""

#: ../../../src/aiida/cmdline/utils/shell.py:docstring of aiida.cmdline.utils.shell.run_shell:1
msgid "Start the chosen external shell."
msgstr ""

#: ../../../src/aiida/cmdline/utils/templates.py:docstring of aiida.cmdline.utils.templates:1
msgid "Templates for input/output of verdi commands."
msgstr ""

#: ../../source/reference/apidoc/aiida.cmdline.utils.query.rst:2
msgid "aiida.cmdline.utils.query package"
msgstr ""

#: ../../../src/aiida/cmdline/utils/query/calculation.py:docstring of aiida.cmdline.utils.query.calculation:1
msgid "A utility module with a factory of standard QueryBuilder instances for Calculation nodes."
msgstr ""

#: ../../../src/aiida/cmdline/utils/query/formatting.py:docstring of aiida.cmdline.utils.query.formatting:1
msgid "A utility module with simple functions to format variables into strings for cli outputs."
msgstr ""

#: ../../../src/aiida/cmdline/utils/query/mapping.py:docstring of aiida.cmdline.utils.query.mapping:1
msgid "A utility module with mapper objects that map database entities projections on attributes and labels."
msgstr ""

#: ../../source/reference/apidoc/aiida.common.rst:2
msgid "aiida.common package"
msgstr ""

#: ../../../src/aiida/common/__init__.py:docstring of aiida.common:1
msgid "Common data structures, utility classes and functions"
msgstr ""

#: ../../../src/aiida/common/__init__.py:docstring of aiida.common:3
msgid "Modules in this sub package have to run without a loaded database environment"
msgstr ""

#: ../../../src/aiida/common/constants.py:docstring of aiida.common.constants:1
msgid "Module to define the (physical) constants used throughout the code."
msgstr ""

#: ../../../src/aiida/common/datastructures.py:docstring of aiida.common.datastructures:1
msgid "Module to define commonly used data structures."
msgstr ""

#: ../../../src/aiida/common/datastructures.py:docstring of aiida.common.datastructures.CalcInfo:1
#: ../../../src/aiida/common/datastructures.py:docstring of aiida.common.datastructures.CodeInfo:1
#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobInfo:1
#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobResource:1
#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobTemplate:1
#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.MachineInfo:1
msgid "Bases: :py:class:`~aiida.common.extendeddicts.DefaultFieldsAttributeDict`"
msgstr ""

#: ../../../src/aiida/common/datastructures.py:docstring of aiida.common.datastructures.CalcInfo:1
msgid "This object will store the data returned by the calculation plugin and to be passed to the ExecManager."
msgstr ""

#: ../../../src/aiida/common/datastructures.py:docstring of aiida.common.datastructures.CalcInfo:4
msgid "In the following descriptions all paths have to be considered relative"
msgstr ""

#: ../../../src/aiida/common/datastructures.py:docstring of aiida.common.datastructures.CalcInfo:31
msgid "retrieve_list: a list of strings or tuples that indicate files that are to be retrieved from the remote after the"
msgstr ""

#: ../../../src/aiida/common/datastructures.py:docstring of aiida.common.datastructures.CalcInfo:7
msgid "calculation has finished and stored in the ``retrieved_folder`` output node of type ``FolderData``. If the entry in the list is just a string, it is assumed to be the filepath on the remote and it will be copied to the base directory of the retrieved folder, where the name corresponds to the basename of the remote relative path. This means that any remote folder hierarchy is ignored entirely."
msgstr ""

#: ../../../src/aiida/common/datastructures.py:docstring of aiida.common.datastructures.CalcInfo:12
msgid "Remote folder hierarchy can be (partially) maintained by using a tuple instead, with the following format"
msgstr ""

#: ../../../src/aiida/common/datastructures.py:docstring of aiida.common.datastructures.CalcInfo:14
msgid "(source, target, depth)"
msgstr ""

#: ../../../src/aiida/common/datastructures.py:docstring of aiida.common.datastructures.CalcInfo:16
msgid "The ``source`` and ``target`` elements are relative filepaths in the remote and retrieved folder. The contents of ``source`` (whether it is a file or folder) are copied in its entirety to the ``target`` subdirectory in the retrieved folder. If no subdirectory should be created, ``'.'`` should be specified for ``target``."
msgstr ""

#: ../../../src/aiida/common/datastructures.py:docstring of aiida.common.datastructures.CalcInfo:20
msgid "The ``source`` filepaths support glob patterns ``*`` in case the exact name of the files that are to be retrieved are not know a priori."
msgstr ""

#: ../../../src/aiida/common/datastructures.py:docstring of aiida.common.datastructures.CalcInfo:23
msgid "The ``depth`` element can be used to control what level of nesting of the source folder hierarchy should be maintained. If ``depth`` equals ``0`` or ``1`` (they are equivalent), only the basename of the ``source`` filepath is kept. For each additional level, another subdirectory of the remote hierarchy is kept. For example:"
msgstr ""

#: ../../../src/aiida/common/datastructures.py:docstring of aiida.common.datastructures.CalcInfo:27
msgid "('path/sub/file.txt', '.', 2)"
msgstr ""

#: ../../../src/aiida/common/datastructures.py:docstring of aiida.common.datastructures.CalcInfo:29
msgid "will retrieve the ``file.txt`` and store it under the path:"
msgstr ""

#: ../../../src/aiida/common/datastructures.py:docstring of aiida.common.datastructures.CalcInfo:31
msgid "sub/file.txt"
msgstr ""

#: ../../../src/aiida/common/datastructures.py:docstring of aiida.common.datastructures.CalcInfo:35
msgid "retrieve_temporary_list: a list of strings or tuples that indicate files that will be retrieved"
msgstr ""

#: ../../../src/aiida/common/datastructures.py:docstring of aiida.common.datastructures.CalcInfo:34
msgid "and stored temporarily in a FolderData, that will be available only during the parsing call. The format of the list is the same as that of 'retrieve_list'"
msgstr ""

#: ../../../src/aiida/common/datastructures.py:docstring of aiida.common.datastructures.CalcInfo:37
msgid "local_copy_list: a list of tuples with format ('node_uuid', 'filename', relativedestpath')"
msgstr ""

#: ../../../src/aiida/common/datastructures.py:docstring of aiida.common.datastructures.CalcInfo:38
msgid "remote_copy_list: a list of tuples with format ('remotemachinename', 'remoteabspath', 'relativedestpath')"
msgstr ""

#: ../../../src/aiida/common/datastructures.py:docstring of aiida.common.datastructures.CalcInfo:39
msgid "remote_symlink_list: a list of tuples with format ('remotemachinename', 'remoteabspath', 'relativedestpath')"
msgstr ""

#: ../../../src/aiida/common/datastructures.py:docstring of aiida.common.datastructures.CalcInfo:44
msgid "provenance_exclude_list: a sequence of relative paths of files in the sandbox folder of a `CalcJob` instance that"
msgstr ""

#: ../../../src/aiida/common/datastructures.py:docstring of aiida.common.datastructures.CalcInfo:41
msgid "should not be stored permanantly in the repository folder of the corresponding `CalcJobNode` that will be created, but should only be copied to the remote working directory on the target computer. This is useful for input files that should be copied to the working directory but should not be copied as well to the repository either, for example, because they contain proprietary information or because they are big and their content is already indirectly present in the repository through one of the data nodes passed as input to the calculation."
msgstr ""

#: ../../../src/aiida/common/datastructures.py:docstring of aiida.common.datastructures.CalcInfo:46
msgid "codes_info: a list of dictionaries used to pass the info of the execution of a code"
msgstr ""

#: ../../../src/aiida/common/datastructures.py:docstring of aiida.common.datastructures.CalcInfo:47
msgid "codes_run_mode: the mode of execution in which the codes will be run (`CodeRunMode.SERIAL` by default,"
msgstr ""

#: ../../../src/aiida/common/datastructures.py:docstring of aiida.common.datastructures.CalcInfo:48
msgid "but can also be `CodeRunMode.PARALLEL`)"
msgstr ""

#: ../../../src/aiida/common/datastructures.py:docstring of aiida.common.datastructures.CalcInfo:51
msgid "skip_submit: a flag that, when set to True, orders the engine to skip the submit/update steps (so no code will"
msgstr ""

#: ../../../src/aiida/common/datastructures.py:docstring of aiida.common.datastructures.CalcInfo:50
msgid "run, it will only upload the files and then retrieve/parse)."
msgstr ""

#: ../../../src/aiida/common/datastructures.py:docstring of aiida.common.datastructures.CalcJobState:1
msgid "The sub state of a CalcJobNode while its Process is in an active state (i.e. Running or Waiting)."
msgstr ""

#: ../../../src/aiida/common/datastructures.py:docstring of aiida.common.datastructures.CodeInfo:1
msgid "This attribute-dictionary contains the information needed to execute a code. Possible attributes are:"
msgstr ""

#: ../../../src/aiida/common/datastructures.py:docstring of aiida.common.datastructures.CodeInfo:4
msgid "``cmdline_params``: a list of strings, containing parameters to be written on the command line right after the call to the code, as for example::"
msgstr ""

#: ../../../src/aiida/common/datastructures.py:docstring of aiida.common.datastructures.CodeInfo:9
msgid "``stdin_name``: (optional) the name of the standard input file. Note, it is only possible to use the stdin with the syntax::"
msgstr ""

#: ../../../src/aiida/common/datastructures.py:docstring of aiida.common.datastructures.CodeInfo:14
msgid "If no stdin_name is specified, the string \"< stdin_name\" will not be passed to the code. Note: it is not possible to substitute/remove the '<' if stdin_name is specified; if that is needed, avoid stdin_name and use instead the cmdline_params to specify a suitable syntax."
msgstr ""

#: ../../../src/aiida/common/datastructures.py:docstring of aiida.common.datastructures.CodeInfo:19
msgid "``stdout_name``: (optional) the name of the standard output file. Note, it is only possible to pass output to stdout_name with the syntax::"
msgstr ""

#: ../../../src/aiida/common/datastructures.py:docstring of aiida.common.datastructures.CodeInfo:24
msgid "If no stdout_name is specified, the string \"> stdout_name\" will not be passed to the code. Note: it is not possible to substitute/remove the '>' if stdout_name is specified; if that is needed, avoid stdout_name and use instead the cmdline_params to specify a suitable syntax."
msgstr ""

#: ../../../src/aiida/common/datastructures.py:docstring of aiida.common.datastructures.CodeInfo:29
msgid "``stderr_name``: (optional) a string, the name of the error file of the code."
msgstr ""

#: ../../../src/aiida/common/datastructures.py:docstring of aiida.common.datastructures.CodeInfo:30
msgid "``join_files``: (optional) if True, redirects the error to the output file. If join_files=True, the code will be called as::"
msgstr ""

#: ../../../src/aiida/common/datastructures.py:docstring of aiida.common.datastructures.CodeInfo:35
msgid "otherwise, if join_files=False and stderr is passed::"
msgstr ""

#: ../../../src/aiida/common/datastructures.py:docstring of aiida.common.datastructures.CodeInfo:39
msgid "``withmpi``: if True, executes the code with mpirun (or another MPI installed on the remote computer)"
msgstr ""

#: ../../../src/aiida/common/datastructures.py:docstring of aiida.common.datastructures.CodeInfo:41
msgid "``code_uuid``: the uuid of the code associated to the CodeInfo"
msgstr ""

#: ../../../src/aiida/common/datastructures.py:docstring of aiida.common.datastructures.CodeRunMode:1
msgid "Enum to indicate the way the codes of a calculation should be run."
msgstr ""

#: ../../../src/aiida/common/datastructures.py:docstring of aiida.common.datastructures.CodeRunMode:3
msgid "For PARALLEL, the codes for a given calculation will be run in parallel by running them in the background::"
msgstr ""

#: ../../../src/aiida/common/datastructures.py:docstring of aiida.common.datastructures.CodeRunMode:8
msgid "For the SERIAL option, codes will be executed sequentially by running for example the following::"
msgstr ""

#: ../../../src/aiida/common/datastructures.py:docstring of aiida.common.datastructures.StashMode:1
msgid "Mode to use when stashing files from the working directory of a completed calculation job for safekeeping."
msgstr ""

#: ../../../src/aiida/common/escaping.py:docstring of aiida.common.escaping:1
msgid "Miscellaneous functions for escaping strings."
msgstr ""

#: ../../../src/aiida/common/escaping.py:docstring of aiida.common.escaping.escape_for_bash:1
msgid "This function takes any string and escapes it in a way that bash will interpret it as a single string."
msgstr ""

#: ../../../src/aiida/common/escaping.py:docstring of aiida.common.escaping.escape_for_bash:4
msgid "Explanation:"
msgstr ""

#: ../../../src/aiida/common/escaping.py:docstring of aiida.common.escaping.escape_for_bash:6
msgid "At the end, in the return statement, the string is put within single quotes. Therefore, the only thing that I have to escape in bash is the single quote character. To do this, I substitute every single quote ' with '\"'\"' which means:"
msgstr ""

#: ../../../src/aiida/common/escaping.py:docstring of aiida.common.escaping.escape_for_bash:11
msgid "First single quote: exit from the enclosing single quotes"
msgstr ""

#: ../../../src/aiida/common/escaping.py:docstring of aiida.common.escaping.escape_for_bash:13
msgid "Second, third and fourth character: \"'\" is a single quote character, escaped by double quotes"
msgstr ""

#: ../../../src/aiida/common/escaping.py:docstring of aiida.common.escaping.escape_for_bash:16
msgid "Last single quote: reopen the single quote to continue the string"
msgstr ""

#: ../../../src/aiida/common/escaping.py:docstring of aiida.common.escaping.escape_for_bash:18
msgid "Finally, note that for python I have to enclose the string '\"'\"' within triple quotes to make it work, getting finally: the complicated string found below."
msgstr ""

#: ../../../src/aiida/common/escaping.py:docstring of aiida.common.escaping.escape_for_bash:22
msgid "the string to escape."
msgstr ""

#: ../../../src/aiida/common/escaping.py:docstring of aiida.common.escaping.escape_for_bash:23
msgid "boolean, if ``True``, use double quotes instead of single quotes."
msgstr ""

#: ../../../src/aiida/common/escaping.py:docstring of aiida.common.escaping.escape_for_bash:24
msgid "the escaped string."
msgstr ""

#: ../../../src/aiida/common/escaping.py:docstring of aiida.common.escaping.escape_for_sql_like:1
msgid "Function that escapes % or _ symbols provided by user"
msgstr ""

#: ../../../src/aiida/common/escaping.py:docstring of aiida.common.escaping.escape_for_sql_like:3
#: ../../../src/aiida/common/escaping.py:docstring of aiida.common.escaping.get_regex_pattern_from_sql:4
msgid "SQL LIKE syntax summary:"
msgstr ""

#: ../../../src/aiida/common/escaping.py:docstring of aiida.common.escaping.escape_for_sql_like:5
#: ../../../src/aiida/common/escaping.py:docstring of aiida.common.escaping.get_regex_pattern_from_sql:6
msgid "``%`` -> match any number of characters"
msgstr ""

#: ../../../src/aiida/common/escaping.py:docstring of aiida.common.escaping.escape_for_sql_like:6
#: ../../../src/aiida/common/escaping.py:docstring of aiida.common.escaping.get_regex_pattern_from_sql:7
msgid "``_`` -> match exactly one character"
msgstr ""

#: ../../../src/aiida/common/escaping.py:docstring of aiida.common.escaping.get_regex_pattern_from_sql:1
msgid "Convert a string providing a pattern to match in SQL syntax into a string performing the same match as a regex."
msgstr ""

#: ../../../src/aiida/common/escaping.py:docstring of aiida.common.escaping.get_regex_pattern_from_sql:9
msgid "Moreover, ``\\`` is the escape character (by default), so:"
msgstr ""

#: ../../../src/aiida/common/escaping.py:docstring of aiida.common.escaping.get_regex_pattern_from_sql:11
msgid "``\\\\`` -> single backslash"
msgstr ""

#: ../../../src/aiida/common/escaping.py:docstring of aiida.common.escaping.get_regex_pattern_from_sql:12
msgid "``\\%`` -> literal % symbol"
msgstr ""

#: ../../../src/aiida/common/escaping.py:docstring of aiida.common.escaping.get_regex_pattern_from_sql:13
msgid "``\\_`` -> literal _ symbol"
msgstr ""

#: ../../../src/aiida/common/escaping.py:docstring of aiida.common.escaping.get_regex_pattern_from_sql:15
msgid "and moreover the string should begin at the beginning of the line and end at the end of the line."
msgstr ""

#: ../../../src/aiida/common/escaping.py:docstring of aiida.common.escaping.get_regex_pattern_from_sql:18
msgid "the string with the pattern in SQL syntax"
msgstr ""

#: ../../../src/aiida/common/escaping.py:docstring of aiida.common.escaping.get_regex_pattern_from_sql:19
msgid "a string with the pattern in regex syntax"
msgstr ""

#: ../../../src/aiida/common/escaping.py:docstring of aiida.common.escaping.sql_string_match:1
msgid "Check if the string matches the provided pattern, specified using SQL syntax."
msgstr ""

#: ../../../src/aiida/common/escaping.py:docstring of aiida.common.escaping.sql_string_match:4
msgid "See documentation of :py:func:`~aiida.common.escaping.get_regex_pattern_from_sql` for an explanation of the syntax."
msgstr ""

#: ../../../src/aiida/common/escaping.py:docstring of aiida.common.escaping.sql_string_match:7
msgid "the string to check"
msgstr ""

#: ../../../src/aiida/common/escaping.py:docstring of aiida.common.escaping.sql_string_match:8
msgid "the SQL pattern"
msgstr ""

#: ../../../src/aiida/common/escaping.py:docstring of aiida.common.escaping.sql_string_match:9
msgid "True if the string matches, False otherwise"
msgstr ""

#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions:1
msgid "Module that define the exceptions that are thrown by AiiDA's internal code."
msgstr ""

#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.AiidaException:1
#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.PreSubmitException:1
#: ../../../src/aiida/orm/utils/builders/computer.py:docstring of aiida.orm.utils.builders.computer.ComputerBuilder.ComputerValidationError:1
#: ../../../src/aiida/tools/data/cif.py:docstring of aiida.tools.data.cif.InvalidOccupationsError:1
#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.IcsdImporterExp:1
#: ../../../src/aiida/tools/groups/paths.py:docstring of aiida.tools.groups.paths.GroupNotFoundError:1
#: ../../../src/aiida/tools/groups/paths.py:docstring of aiida.tools.groups.paths.GroupNotUniqueError:1
#: ../../../src/aiida/tools/groups/paths.py:docstring of aiida.tools.groups.paths.InvalidPath:1
#: ../../../src/aiida/tools/groups/paths.py:docstring of aiida.tools.groups.paths.NoGroupsInPathError:1
msgid "Bases: :py:class:`Exception`"
msgstr ""

#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.AiidaException:1
msgid "Base class for all AiiDA exceptions."
msgstr ""

#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.AiidaException:3
msgid "Each module will have its own subclass, inherited from this (e.g. ExecManagerException, TransportException, ...)"
msgstr ""

#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.CircusCallError:1
#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.ClosedStorage:1
#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.ConfigurationError:1
#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.DatabaseMigrationError:1
#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.DbContentError:1
#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.EntryPointError:1
#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.FailedError:1
#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.FeatureDisabled:1
#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.FeatureNotAvailable:1
#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.HashingError:1
#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.IntegrityError:1
#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.InternalError:1
#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.InvalidOperation:1
#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.LicensingException:1
#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.LockedProfileError:1
#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.LockingProfileError:1
#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.ModificationNotAllowed:1
#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.MultipleObjectsError:1
#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.NotExistent:1
#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.ParsingError:1
#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.RemoteOperationError:1
#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.StoringNotAllowed:1
#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.TestsNotAllowedError:1
#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.TransportTaskException:1
#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.UniquenessError:1
#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.ValidationError:1
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonException:1
#: ../../../src/aiida/engine/exceptions.py:docstring of aiida.engine.exceptions.PastException:1
#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control.ProcessTimeoutException:1
#: ../../../src/aiida/manage/external/rmq/client.py:docstring of aiida.manage.external.rmq.client.ManagementApiConnectionError:1
#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.SchedulerError:1
#: ../../../src/aiida/storage/sqlite_zip/utils.py:docstring of aiida.storage.sqlite_zip.utils.ReadOnlyError:1
#: ../../../src/aiida/tools/archive/exceptions.py:docstring of aiida.tools.archive.exceptions.ExportImportException:1
msgid "Bases: :py:class:`~aiida.common.exceptions.AiidaException`"
msgstr ""

#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.CircusCallError:1
msgid "Raised when an attempt to contact Circus returns an error in the response"
msgstr ""

#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.ClosedStorage:1
msgid "Raised when trying to access data from a closed storage backend."
msgstr ""

#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.ConfigurationError:1
msgid "Error raised when there is a configuration error in AiiDA."
msgstr ""

#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.ConfigurationVersionError:1
#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.CorruptStorage:1
#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.IncompatibleDatabaseSchema:1
#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.MissingConfigurationError:1
#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.ProfileConfigurationError:1
#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.UnreachableStorage:1
msgid "Bases: :py:class:`~aiida.common.exceptions.ConfigurationError`"
msgstr ""

#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.ConfigurationVersionError:1
msgid "Configuration error raised when the configuration file version is not compatible with the current version."
msgstr ""

#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.ContentNotExistent:1
msgid "Bases: :py:class:`~aiida.common.exceptions.NotExistent`"
msgstr ""

#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.ContentNotExistent:1
msgid "Raised when trying to access an attribute, a key or a file in the result nodes that is not present"
msgstr ""

#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.CorruptStorage:1
msgid "Raised when the storage is not found to be internally consistent on validation."
msgstr ""

#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.DatabaseMigrationError:1
#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.StorageMigrationError:1
msgid "Raised if a critical error is encountered during a storage migration."
msgstr ""

#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.DatabaseMigrationError:3
msgid "Deprecated for ``StorageMigrationError``"
msgstr ""

#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.DbContentError:1
msgid "Raised when the content of the DB is not valid. This should never happen if the user does not play directly with the DB."
msgstr ""

#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.EntryPointError:1
msgid "Raised when an entry point cannot be uniquely resolved and imported."
msgstr ""

#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.FailedError:1
msgid "Raised when accessing a calculation that is in the FAILED status"
msgstr ""

#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.FeatureDisabled:1
msgid "Raised when a feature is requested, but the user has chosen to disable it (e.g., for submissions on disabled computers)."
msgstr ""

#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.FeatureNotAvailable:1
msgid "Raised when a feature is requested from a plugin, that is not available."
msgstr ""

#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.HashingError:1
msgid "Raised when an attempt to hash an object fails via a known failure mode"
msgstr ""

#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.IncompatibleDatabaseSchema:1
#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.IncompatibleStorageSchema:1
msgid "Raised when the storage schema is incompatible with that of the code."
msgstr ""

#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.IncompatibleDatabaseSchema:3
msgid "Deprecated for ``IncompatibleStorageSchema``"
msgstr ""

#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.IncompatibleStorageSchema:1
msgid "Bases: :py:class:`~aiida.common.exceptions.IncompatibleDatabaseSchema`"
msgstr ""

#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.InputValidationError:1
#: ../../../src/aiida/restapi/common/exceptions.py:docstring of aiida.restapi.common.exceptions.RestValidationError:1
msgid "Bases: :py:class:`~aiida.common.exceptions.ValidationError`"
msgstr ""

#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.InputValidationError:1
msgid "The input data for a calculation did not validate (e.g., missing required input data, wrong data, ...)"
msgstr ""

#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.IntegrityError:1
msgid "Raised when there is an underlying data integrity error.  This can be database related or a general data integrity error.  This can happen if, e.g., a foreign key check fails. See PEP 249 for details."
msgstr ""

#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.InternalError:1
msgid "Error raised when there is an internal error of AiiDA."
msgstr ""

#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.InvalidEntryPointTypeError:1
#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.LoadingEntryPointError:1
#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.MissingEntryPointError:1
#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.MultipleEntryPointError:1
msgid "Bases: :py:class:`~aiida.common.exceptions.EntryPointError`"
msgstr ""

#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.InvalidEntryPointTypeError:1
msgid "Raised when a loaded entry point has a type that is not supported by the corresponding entry point group."
msgstr ""

#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.InvalidOperation:1
msgid "The allowed operation is not valid (e.g., when trying to add a non-internal attribute before saving the entry), or deleting an entry that is protected (e.g., because it is referenced by foreign keys)"
msgstr ""

#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.LicensingException:1
msgid "Raised when requirements for data licensing are not met."
msgstr ""

#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.LoadingEntryPointError:1
msgid "Raised when the resource corresponding to requested entry point cannot be imported."
msgstr ""

#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.LockedProfileError:1
msgid "Raised if attempting to access a locked profile"
msgstr ""

#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.LockingProfileError:1
msgid "Raised if the profile can`t be locked"
msgstr ""

#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.MissingConfigurationError:1
msgid "Configuration error raised when the configuration file is missing."
msgstr ""

#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.MissingEntryPointError:1
msgid "Raised when the requested entry point is not registered with the entry point manager."
msgstr ""

#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.ModificationNotAllowed:1
msgid "Raised when the user tries to modify a field, object, property, ... that should not be modified."
msgstr ""

#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.MultipleEntryPointError:1
msgid "Raised when the requested entry point cannot uniquely be resolved by the entry point manager."
msgstr ""

#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.MultipleObjectsError:1
msgid "Raised when more than one entity is found in the DB, but only one was expected."
msgstr ""

#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.NotExistent:1
msgid "Raised when the required entity does not exist."
msgstr ""

#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.NotExistentAttributeError:1
msgid "Bases: :py:class:`AttributeError`, :py:class:`~aiida.common.exceptions.NotExistent`"
msgstr ""

#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.NotExistentAttributeError:1
msgid "Raised when the required entity does not exist, when fetched as an attribute."
msgstr ""

#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.NotExistentKeyError:1
msgid "Bases: :py:class:`KeyError`, :py:class:`~aiida.common.exceptions.NotExistent`"
msgstr ""

#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.NotExistentKeyError:1
msgid "Raised when the required entity does not exist, when fetched as a dictionary key."
msgstr ""

#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.OutputParsingError:1
msgid "Bases: :py:class:`~aiida.common.exceptions.ParsingError`"
msgstr ""

#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.OutputParsingError:1
msgid "Can be raised by a Parser when it fails to parse the output generated by a `CalcJob` process."
msgstr ""

#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.ParsingError:1
msgid "Generic error raised when there is a parsing error"
msgstr ""

#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.PluginInternalError:1
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.TransportInternalError:1
msgid "Bases: :py:class:`~aiida.common.exceptions.InternalError`"
msgstr ""

#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.PluginInternalError:1
msgid "Error raised when there is an internal error which is due to a plugin and not to the AiiDA infrastructure."
msgstr ""

#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.ProfileConfigurationError:1
msgid "Configuration error raised when a wrong/inexistent profile is requested."
msgstr ""

#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.RemoteOperationError:1
msgid "Raised when an error in a remote operation occurs, as in a failed kill() of a scheduler job."
msgstr ""

#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.StorageMigrationError:1
msgid "Bases: :py:class:`~aiida.common.exceptions.DatabaseMigrationError`"
msgstr ""

#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.StoringNotAllowed:1
msgid "Raised when the user tries to store an unstorable node (e.g. a base Node class)"
msgstr ""

#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.TestsNotAllowedError:1
msgid "Raised when tests are required to be run/loaded, but we are not in a testing environment."
msgstr ""

#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.TestsNotAllowedError:3
msgid "This is to prevent data loss."
msgstr ""

#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.TransportTaskException:1
msgid "Raised when a TransportTask, an task to be completed by the engine that requires transport, fails"
msgstr ""

#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.UniquenessError:1
msgid "Raised when the user tries to violate a uniqueness constraint (on the DB, for instance)."
msgstr ""

#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.UnreachableStorage:1
msgid "Raised when a connection to the storage backend fails."
msgstr ""

#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.UnsupportedSpeciesError:1
#: ../../../src/aiida/orm/utils/builders/code.py:docstring of aiida.orm.utils.builders.code.CodeBuilder.CodeValidationError:1
msgid "Bases: :py:class:`ValueError`"
msgstr ""

#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.UnsupportedSpeciesError:1
msgid "Raised when StructureData operations are fed species that are not supported by AiiDA such as Deuterium"
msgstr ""

#: ../../../src/aiida/common/exceptions.py:docstring of aiida.common.exceptions.ValidationError:1
msgid "Error raised when there is an error during the validation phase of a property."
msgstr ""

#: ../../../src/aiida/common/extendeddicts.py:docstring of aiida.common.extendeddicts:1
msgid "Various dictionary types with extended functionality."
msgstr ""

#: ../../../src/aiida/common/extendeddicts.py:docstring of aiida.common.extendeddicts.AttributeDict:1
msgid "Bases: :py:class:`dict`"
msgstr ""

#: ../../../src/aiida/common/extendeddicts.py:docstring of aiida.common.extendeddicts.AttributeDict:1
msgid "This class internally stores values in a dictionary, but exposes the keys also as attributes, i.e. asking for attrdict.key will return the value of attrdict['key'] and so on."
msgstr ""

#: ../../../src/aiida/common/extendeddicts.py:docstring of aiida.common.extendeddicts.AttributeDict:5
msgid "Raises an AttributeError if the key does not exist, when called as an attribute, while the usual KeyError if the key does not exist and the dictionary syntax is used."
msgstr ""

#: ../../../src/aiida/common/extendeddicts.py:docstring of aiida.common.extendeddicts.AttributeDict.__deepcopy__:1
msgid "Deep copy."
msgstr ""

#: ../../../src/aiida/common/extendeddicts.py:docstring of aiida.common.extendeddicts.AttributeDict.__delattr__:1
msgid "Delete a key as an attribute."
msgstr ""

#: ../../../src/aiida/common/extendeddicts.py:docstring of aiida.common.extendeddicts.AttributeDict.__delattr__:3
#: ../../../src/aiida/common/extendeddicts.py:docstring of aiida.common.extendeddicts.AttributeDict.__getattr__:3
msgid "if the attribute does not correspond to an existing key."
msgstr ""

#: ../../../src/aiida/common/extendeddicts.py:docstring of aiida.common.extendeddicts.AttributeDict.__dir__:1
#: ../../../src/aiida/common/extendeddicts.py:docstring of aiida.common.extendeddicts.FixedFieldsAttributeDict.__dir__:1
#: ../../../src/aiida/engine/processes/builder.py:docstring of aiida.engine.processes.builder.ProcessBuilderNamespace.__dir__:1
msgid "Default dir() implementation."
msgstr ""

#: ../../../src/aiida/common/extendeddicts.py:docstring of aiida.common.extendeddicts.AttributeDict.__getattr__:1
msgid "Read a key as an attribute."
msgstr ""

#: ../../../src/aiida/common/extendeddicts.py:docstring of aiida.common.extendeddicts.AttributeDict.__getstate__:1
#: ../../../src/aiida/common/extendeddicts.py:docstring of aiida.common.extendeddicts.AttributeDict.__setstate__:1
msgid "Needed for pickling this class."
msgstr ""

#: ../../../src/aiida/common/extendeddicts.py:docstring of aiida.common.extendeddicts.AttributeDict.__repr__:1
msgid "Representation of the object."
msgstr ""

#: ../../../src/aiida/common/extendeddicts.py:docstring of aiida.common.extendeddicts.AttributeDict.__setattr__:1
#: ../../../src/aiida/common/extendeddicts.py:docstring of aiida.common.extendeddicts.FixedFieldsAttributeDict.__setitem__:1
msgid "Set a key as an attribute."
msgstr ""

#: ../../../src/aiida/common/extendeddicts.py:docstring of aiida.common.extendeddicts.DefaultFieldsAttributeDict:1
msgid "A dictionary with access to the keys as attributes, and with an internal value storing the 'default' keys to be distinguished from extra fields."
msgstr ""

#: ../../../src/aiida/common/extendeddicts.py:docstring of aiida.common.extendeddicts.DefaultFieldsAttributeDict:5
msgid "Extra methods defaultkeys() and extrakeys() divide the set returned by keys() in default keys (i.e. those defined at definition time) and other keys. There is also a method get_default_fields() to return the internal list."
msgstr ""

#: ../../../src/aiida/common/extendeddicts.py:docstring of aiida.common.extendeddicts.DefaultFieldsAttributeDict:10
msgid "Moreover, for undefined default keys, it returns None instead of raising a KeyError/AttributeError exception."
msgstr ""

#: ../../../src/aiida/common/extendeddicts.py:docstring of aiida.common.extendeddicts.DefaultFieldsAttributeDict:13
msgid "Remember to define the _default_fields in a subclass! E.g.::"
msgstr ""

#: ../../../src/aiida/common/extendeddicts.py:docstring of aiida.common.extendeddicts.DefaultFieldsAttributeDict:19
msgid "When the validate() method is called, it calls in turn all validate_KEY methods, where KEY is one of the default keys. If the method is not present, the field is considered to be always valid. Each validate_KEY method should accept a single argument 'value' that will contain the value to be checked."
msgstr ""

#: ../../../src/aiida/common/extendeddicts.py:docstring of aiida.common.extendeddicts.DefaultFieldsAttributeDict:25
msgid "It raises a ValidationError if any of the validate_KEY function raises an exception, otherwise it simply returns. NOTE: the `validate_*` functions are called also for unset fields, so if the field can be empty on validation, you have to start your validation function with something similar to::"
msgstr ""

#: ../../../src/aiida/common/extendeddicts.py:docstring of aiida.common.extendeddicts.DefaultFieldsAttributeDict:34
#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder:4
#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder:10
#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.set_trajectory:49
#: ../../../src/aiida/tools/ipython/ipython_magics.py:docstring of aiida.tools.ipython.ipython_magics.AiiDALoaderMagics.aiida:9
#: ../../../src/aiida/tools/ipython/ipython_magics.py:docstring of aiida.tools.ipython.ipython_magics.add_to_ns:5
msgid "Todo"
msgstr ""

#: ../../../src/aiida/common/extendeddicts.py:docstring of aiida.common.extendeddicts.DefaultFieldsAttributeDict:35
msgid "Decide behavior if I set to None a field. Current behavior, if ``a`` is an instance and 'def_field' one of the default fields, that is undefined, we get:"
msgstr ""

#: ../../../src/aiida/common/extendeddicts.py:docstring of aiida.common.extendeddicts.DefaultFieldsAttributeDict:40
#: ../../../src/aiida/common/extendeddicts.py:docstring of aiida.common.extendeddicts.DefaultFieldsAttributeDict:46
msgid "``a.get('def_field')``: None"
msgstr ""

#: ../../../src/aiida/common/extendeddicts.py:docstring of aiida.common.extendeddicts.DefaultFieldsAttributeDict:41
msgid "``a.get('def_field','whatever')``: 'whatever'"
msgstr ""

#: ../../../src/aiida/common/extendeddicts.py:docstring of aiida.common.extendeddicts.DefaultFieldsAttributeDict:42
msgid "Note that ``a.defaultkeys()`` does NOT contain 'def_field'"
msgstr ""

#: ../../../src/aiida/common/extendeddicts.py:docstring of aiida.common.extendeddicts.DefaultFieldsAttributeDict:44
msgid "if we do ``a.def_field = None``, then the behavior becomes"
msgstr ""

#: ../../../src/aiida/common/extendeddicts.py:docstring of aiida.common.extendeddicts.DefaultFieldsAttributeDict:47
msgid "``a.get('def_field','whatever')``: None"
msgstr ""

#: ../../../src/aiida/common/extendeddicts.py:docstring of aiida.common.extendeddicts.DefaultFieldsAttributeDict:48
msgid "Note that ``a.defaultkeys()`` DOES contain 'def_field'"
msgstr ""

#: ../../../src/aiida/common/extendeddicts.py:docstring of aiida.common.extendeddicts.DefaultFieldsAttributeDict:50
msgid "See if we want that setting a default field to None means deleting it."
msgstr ""

#: ../../../src/aiida/common/extendeddicts.py:docstring of aiida.common.extendeddicts.DefaultFieldsAttributeDict.__getitem__:1
msgid "Return None instead of raising an exception if the key does not exist but is in the list of default fields."
msgstr ""

#: ../../../src/aiida/common/extendeddicts.py:docstring of aiida.common.extendeddicts.DefaultFieldsAttributeDict.__setattr__:1
#: ../../../src/aiida/common/extendeddicts.py:docstring of aiida.common.extendeddicts.FixedFieldsAttributeDict.__setattr__:1
msgid "Overridden to allow direct access to fields with underscore."
msgstr ""

#: ../../../src/aiida/common/extendeddicts.py:docstring of aiida.common.extendeddicts.DefaultFieldsAttributeDict.defaultkeys:1
msgid "Return the default keys defined in the instance."
msgstr ""

#: ../../../src/aiida/common/extendeddicts.py:docstring of aiida.common.extendeddicts.DefaultFieldsAttributeDict.extrakeys:1
msgid "Return the extra keys defined in the instance."
msgstr ""

#: ../../../src/aiida/common/extendeddicts.py:docstring of aiida.common.extendeddicts.DefaultFieldsAttributeDict.get_default_fields:1
msgid "Return the list of default fields, either defined in the instance or not."
msgstr ""

#: ../../../src/aiida/common/extendeddicts.py:docstring of aiida.common.extendeddicts.DefaultFieldsAttributeDict.validate:1
msgid "Validate the keys, if any ``validate_*`` method is available."
msgstr ""

#: ../../../src/aiida/common/extendeddicts.py:docstring of aiida.common.extendeddicts.FixedFieldsAttributeDict:1
msgid "A dictionary with access to the keys as attributes, and with filtering of valid attributes. This is only the base class, without valid attributes; use a derived class to do the actual work. E.g.::"
msgstr ""

#: ../../../src/aiida/common/extendeddicts.py:docstring of aiida.common.extendeddicts.FixedFieldsAttributeDict.get_valid_fields:1
msgid "Return the list of valid fields."
msgstr ""

#: ../../../src/aiida/common/files.py:docstring of aiida.common.files:1
msgid "Utility functions to operate on filesystem files."
msgstr ""

#: ../../../src/aiida/common/files.py:docstring of aiida.common.files.md5_file:1
msgid "Create the hexdigested md5 checksum of the contents from"
msgstr ""

#: ../../../src/aiida/common/files.py:docstring of aiida.common.files.md5_file:3
msgid "the filepath of the file for which we want the md5sum"
msgstr ""

#: ../../../src/aiida/common/files.py:docstring of aiida.common.files.md5_file:4
#: ../../../src/aiida/common/files.py:docstring of aiida.common.files.md5_from_filelike:4
msgid "the file is read at chunks of size ``block_size_factor * md5.block_size``, where ``md5.block_size`` is the block_size used internally by the hashlib module."
msgstr ""

#: ../../../src/aiida/common/files.py:docstring of aiida.common.files.md5_file:6
#: ../../../src/aiida/common/files.py:docstring of aiida.common.files.md5_from_filelike:6
msgid "a string with the hexdigest md5."
msgstr ""

#: ../../../src/aiida/common/files.py:docstring of aiida.common.files.md5_file:7
#: ../../../src/aiida/common/files.py:docstring of aiida.common.files.sha1_file:11
msgid "No checks are done on the file, so if it doesn't exists it may raise IOError."
msgstr ""

#: ../../../src/aiida/common/files.py:docstring of aiida.common.files.md5_from_filelike:1
msgid "Create the hexdigested md5 checksum of the contents from a filelike object."
msgstr ""

#: ../../../src/aiida/common/files.py:docstring of aiida.common.files.md5_from_filelike:3
msgid "the filelike object for whose contents to generate the md5 checksum"
msgstr ""

#: ../../../src/aiida/common/files.py:docstring of aiida.common.files.md5_from_filelike:7
msgid "no checks are done on the filelike object, so it may raise IOError if it cannot be read from."
msgstr ""

#: ../../../src/aiida/common/files.py:docstring of aiida.common.files.sha1_file:1
msgid "Open a file and return its sha1sum (hexdigested)."
msgstr ""

#: ../../../src/aiida/common/files.py:docstring of aiida.common.files.sha1_file:3
msgid "the filename of the file for which we want the sha1sum"
msgstr ""

#: ../../../src/aiida/common/files.py:docstring of aiida.common.files.sha1_file:4
msgid "the file is read at chunks of size ``block_size_factor * sha1.block_size``, where ``sha1.block_size`` is the block_size used internally by the hashlib module."
msgstr ""

#: ../../../src/aiida/common/files.py:docstring of aiida.common.files.sha1_file:9
msgid "a string with the hexdigest sha1."
msgstr ""

#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders:1
msgid "Utility functions to operate on filesystem folders."
msgstr ""

#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder:1
msgid "A class to manage generic folders, avoiding to get out of specific given folder borders."
msgstr ""

#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder:5
msgid "fix this, os.path.commonprefix of /a/b/c and /a/b2/c will give a/b, check if this is wanted or if we want to put trailing slashes. (or if we want to use os.path.relpath and check for a string starting with os.pardir?)"
msgstr ""

#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder:11
msgid "rethink whether the folder_limit option is still useful. If not, remove it alltogether (it was a nice feature, but unfortunately all the calls to os.path.abspath or normpath are quite slow)."
msgstr ""

#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder.abspath:1
msgid "The absolute path of the folder."
msgstr ""

#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder.create:1
msgid "Creates the folder, if it does not exist on the disk yet."
msgstr ""

#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder.create:3
msgid "It will also create top directories, if absent."
msgstr ""

#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder.create:5
msgid "It is always safe to call it, it will do nothing if the folder already exists."
msgstr ""

#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder.create_file_from_filelike:1
msgid "Create a file with the given filename from a filelike object."
msgstr ""

#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder.create_file_from_filelike:3
msgid "a filelike object whose contents to copy"
msgstr ""

#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder.create_file_from_filelike:4
msgid "the filename for the file that is to be created"
msgstr ""

#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder.create_file_from_filelike:5
msgid "the mode with which the target file will be written"
msgstr ""

#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder.create_file_from_filelike:6
msgid "the encoding with which the target file will be written"
msgstr ""

#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder.create_file_from_filelike:7
msgid "the absolute filepath of the created file"
msgstr ""

#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder.create_symlink:1
msgid "Create a symlink inside the folder to the location 'src'."
msgstr ""

#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder.create_symlink:3
msgid "the location to which the symlink must point. Can be either a relative or an absolute path. Should, however, be relative to work properly also when the repository is moved!"
msgstr ""

#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder.create_symlink:7
msgid "the filename of the symlink to be created."
msgstr ""

#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder.erase:1
msgid "Erases the folder. Should be called only in very specific cases, in general folder should not be erased!"
msgstr ""

#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder.erase:4
msgid "Doesn't complain if the folder does not exist."
msgstr ""

#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder.erase:6
msgid "if True, after erasing, creates an empty dir."
msgstr ""

#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder.exists:1
msgid "Return True if the folder exists, False otherwise."
msgstr ""

#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder.folder_limit:1
msgid "The folder limit that cannot be crossed when creating files and folders."
msgstr ""

#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder.get_abs_path:1
msgid "Return an absolute path for a file or folder in this folder."
msgstr ""

#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder.get_abs_path:3
msgid "The advantage of using this method is that it checks that filename is a valid filename within this folder, and not something e.g. containing slashes."
msgstr ""

#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder.get_abs_path:7
msgid "The file or directory."
msgstr ""

#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder.get_abs_path:8
#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder.open:3
msgid "if False, just return the file path. Otherwise, also check if the file or directory actually exists. Raise OSError if it does not."
msgstr ""

#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder.get_content_list:1
msgid "Return a list of files (and subfolders) in the folder, matching a given pattern."
msgstr ""

#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder.get_content_list:3
msgid "Example: If you want to exclude files starting with a dot, you can call this method with ``pattern='[!.]*'``"
msgstr ""

#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder.get_content_list:6
msgid "a pattern for the file/folder names, using Unix filename pattern matching (see Python standard module fnmatch). By default, pattern is '*', matching all files and folders."
msgstr ""

#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder.get_content_list:9
msgid "if False (default), return pairs (name, is_file). if True, return only a flat list."
msgstr ""

#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder.get_content_list:13
msgid "a list of tuples of two elements, the first is the file name and the second is True if the element is a file, False if it is a directory."
msgstr ""

#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder.get_subfolder:1
msgid "Return a Folder object pointing to a subfolder."
msgstr ""

#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder.get_subfolder:3
msgid "a string with the relative path of the subfolder, relative to the absolute path of this object. Note that this may also contain '..' parts, as far as this does not go beyond the folder_limit."
msgstr ""

#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder.get_subfolder:7
msgid "if True, the new subfolder is created, if it does not exist."
msgstr ""

#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder.get_subfolder:8
msgid "when doing ``b = a.get_subfolder('xxx', reset_limit=False)``, the limit of b will be the same limit of a. if True, the limit will be set to the boundaries of folder b."
msgstr ""

#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder.get_subfolder:12
msgid "a Folder object pointing to the subfolder."
msgstr ""

#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder.insert_path:1
msgid "Copy a file to the folder."
msgstr ""

#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder.insert_path:3
msgid "the source filename to copy"
msgstr ""

#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder.insert_path:4
msgid "if None, the same basename of src is used. Otherwise, the destination filename will have this file name."
msgstr ""

#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder.insert_path:6
msgid "if ``False``, raises an error on existing destination; otherwise, delete it first."
msgstr ""

#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder.isdir:1
msgid "Return True if 'relpath' exists inside the folder and is a directory, False otherwise."
msgstr ""

#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder.isfile:1
msgid "Return True if 'relpath' exists inside the folder and is a file, False otherwise."
msgstr ""

#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder.mode_dir:1
msgid "Return the mode with which the folders should be created"
msgstr ""

#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder.mode_file:1
msgid "Return the mode with which the files should be created"
msgstr ""

#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder.open:1
msgid "Open a file in the current folder and return the corresponding file object."
msgstr ""

#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder.remove_path:1
msgid "Remove a file or folder from the folder."
msgstr ""

#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder.remove_path:3
msgid "the relative path name to remove"
msgstr ""

#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder.replace_with_folder:1
msgid "This routine copies or moves the source folder 'srcdir' to the local folder pointed to by this Folder."
msgstr ""

#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder.replace_with_folder:3
msgid "the source folder on the disk; this must be an absolute path"
msgstr ""

#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder.replace_with_folder:5
msgid "if True, the srcdir is moved to the repository. Otherwise, it is only copied."
msgstr ""

#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder.replace_with_folder:7
msgid "if True, the folder will be erased first. if False, an IOError is raised if the folder already exists. Whatever the value of this flag, parent directories will be created, if needed."
msgstr ""

#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder.replace_with_folder:12
msgid "in case of problems accessing or writing the files."
msgstr ""

#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder.replace_with_folder:13
msgid "in case of problems accessing or writing the files (from ``shutil`` module)."
msgstr ""

#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.Folder.replace_with_folder:14
msgid "if the section is not recognized."
msgstr ""

#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.SandboxFolder:1
#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.SubmitTestFolder:1
msgid "Bases: :py:class:`~aiida.common.folders.Folder`"
msgstr ""

#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.SandboxFolder:1
msgid "A class to manage the creation and management of a sandbox folder."
msgstr ""

#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.SandboxFolder:3
msgid "This class should be used with a context manager to guarantee automatic cleanup:"
msgstr ""

#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.SandboxFolder:5
msgid "with SandboxFolder() as folder:"
msgstr ""

#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.SandboxFolder:6
msgid "# Do something with ``folder``"
msgstr ""

#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.SandboxFolder.__enter__:1
msgid "Enter a context and return self."
msgstr ""

#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.SandboxFolder.__exit__:1
msgid "Erase the temporary directory created in the constructor."
msgstr ""

#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.SandboxFolder.__init__:1
msgid "Initialize a ``Folder`` object for an automatically created temporary directory."
msgstr ""

#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.SandboxFolder.__init__:3
msgid "A filepath to a directory to use for the sandbox folder. This path will be actually used as the base path and a random subfolder will be generated inside it. This will guarantee that multiple instances of the class can be created with the same value for ``filepath`` while guaranteeing they are independent."
msgstr ""

#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.SubmitTestFolder:1
msgid "Sandbox folder that can be used for the test submission of `CalcJobs`."
msgstr ""

#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.SubmitTestFolder:3
msgid "The directory will be created in the current working directory with a configurable basename. Then a sub folder will be created within this base folder based on the current date and an index in order to not overwrite already existing created test folders."
msgstr ""

#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.SubmitTestFolder.__enter__:1
msgid "Return the sub folder that should be Called when entering in the with statement."
msgstr ""

#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.SubmitTestFolder.__exit__:1
msgid "When context manager is exited, do not delete the folder."
msgstr ""

#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.SubmitTestFolder.__init__:1
msgid "Construct and create the sandbox folder."
msgstr ""

#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.SubmitTestFolder.__init__:3
msgid "The directory will be created in the current working directory with the name given by `basepath`. Then a sub folder will be created within this base folder based on the current date and an index in order to not overwrite already existing created test folders."
msgstr ""

#: ../../../src/aiida/common/folders.py:docstring of aiida.common.folders.SubmitTestFolder.__init__:7
msgid "name of the base directory that will be created in the current working directory"
msgstr ""

#: ../../../src/aiida/common/hashing.py:docstring of aiida.common.hashing:1
msgid "Common password and hash generation functions."
msgstr ""

#: ../../../src/aiida/common/hashing.py:docstring of aiida.common.hashing._:1
msgid "Hash the content of a Folder object. The name of the folder itself is actually ignored :param ignored_folder_content: list of filenames to be ignored for the hashing"
msgstr ""

#: ../../../src/aiida/common/hashing.py:docstring of aiida.common.hashing._make_hash:1
msgid "Implementation of the ``make_hash`` function. The hash is created as a 28 byte integer, and only later converted to a string."
msgstr ""

#: ../../../src/aiida/common/hashing.py:docstring of aiida.common.hashing.chunked_file_hash:1
msgid "Return the hash for the given file handle"
msgstr ""

#: ../../../src/aiida/common/hashing.py:docstring of aiida.common.hashing.chunked_file_hash:3
msgid "Will read the file in chunks, which should be opened in 'rb' mode."
msgstr ""

#: ../../../src/aiida/common/hashing.py:docstring of aiida.common.hashing.chunked_file_hash:5
msgid "a file handle, opened in 'rb' mode."
msgstr ""

#: ../../../src/aiida/common/hashing.py:docstring of aiida.common.hashing.chunked_file_hash:6
msgid "a class implementing hashlib._Hash"
msgstr ""

#: ../../../src/aiida/common/hashing.py:docstring of aiida.common.hashing.chunked_file_hash:7
msgid "number of bytes to chunk the file read in"
msgstr ""

#: ../../../src/aiida/common/hashing.py:docstring of aiida.common.hashing.chunked_file_hash:8
msgid "arguments to pass to the hasher initialisation"
msgstr ""

#: ../../../src/aiida/common/hashing.py:docstring of aiida.common.hashing.chunked_file_hash:9
msgid "the hash hexdigest (the hash key)"
msgstr ""

#: ../../../src/aiida/common/hashing.py:docstring of aiida.common.hashing.float_to_text:1
msgid "Convert float to text string for computing hash. Preseve up to N significant number given by sig."
msgstr ""

#: ../../../src/aiida/common/hashing.py:docstring of aiida.common.hashing.float_to_text:4
msgid "the float value to convert"
msgstr ""

#: ../../../src/aiida/common/hashing.py:docstring of aiida.common.hashing.float_to_text:5
msgid "choose how many digits after the comma should be output"
msgstr ""

#: ../../../src/aiida/common/hashing.py:docstring of aiida.common.hashing.get_random_string:1
msgid "Return a securely generated random string."
msgstr ""

#: ../../../src/aiida/common/hashing.py:docstring of aiida.common.hashing.get_random_string:3
msgid "The default length of 12 with the all ASCII letters and digits returns a 71-bit value:"
msgstr ""

#: ../../../src/aiida/common/hashing.py:docstring of aiida.common.hashing.get_random_string:5
msgid "log_2((26+26+10)^12) =~ 71 bits"
msgstr ""

#: ../../../src/aiida/common/hashing.py:docstring of aiida.common.hashing.get_random_string:7
msgid "The number of characters to use for the string."
msgstr ""

#: ../../../src/aiida/common/hashing.py:docstring of aiida.common.hashing.make_hash:1
msgid "Makes a hash from a dictionary, list, tuple or set to any level, that contains only other hashable or nonhashable types (including lists, tuples, sets, and dictionaries)."
msgstr ""

#: ../../../src/aiida/common/hashing.py:docstring of aiida.common.hashing.make_hash:5
msgid "the object to hash"
msgstr ""

#: ../../../src/aiida/common/hashing.py:docstring of aiida.common.hashing.make_hash:7
msgid "a unique hash"
msgstr ""

#: ../../../src/aiida/common/hashing.py:docstring of aiida.common.hashing.make_hash:9
msgid "There are a lot of modules providing functionalities to create unique hashes for hashable values. However, getting hashes for nonhashable items like sets or dictionaries is not easily doable because order is not fixed. This leads to the peril of getting different hashes for the same dictionary."
msgstr ""

#: ../../../src/aiida/common/hashing.py:docstring of aiida.common.hashing.make_hash:16
msgid "This function avoids this by recursing through nonhashable items and hashing iteratively. Uses python's sorted function to sort unsorted sets and dictionaries by sorting the hashed keys."
msgstr ""

#: ../../../src/aiida/common/json.py:docstring of aiida.common.json:1
msgid "Abstracts JSON usage to ensure compatibility with Python2 and Python3."
msgstr ""

#: ../../../src/aiida/common/json.py:docstring of aiida.common.json:3
msgid "Use this module prefentially over standard json to ensure compatibility."
msgstr ""

#: ../../../src/aiida/common/json.py:docstring of aiida.common.json:5
msgid "module is deprecated in v2.0.0 and should no longer be used. Python 2 support has long since been dropped and for Python 3, one should simply use the ``json`` module of the standard library directly."
msgstr ""

#: ../../../src/aiida/common/json.py:docstring of aiida.common.json.dump:1
msgid "Serialize ``data`` as a JSON formatted stream to ``handle``."
msgstr ""

#: ../../../src/aiida/common/json.py:docstring of aiida.common.json.dump:3
#: ../../../src/aiida/common/json.py:docstring of aiida.common.json.dumps:3
msgid "We use ``ensure_ascii=False`` to write unicode characters specifically as this improves the readability of the json and reduces the file size."
msgstr ""

#: ../../../src/aiida/common/json.py:docstring of aiida.common.json.dumps:1
msgid "Serialize ``data`` as a JSON formatted string."
msgstr ""

#: ../../../src/aiida/common/json.py:docstring of aiida.common.json.load:1
msgid "Deserialize ``handle`` text or binary file containing a JSON document to a Python object."
msgstr ""

#: ../../../src/aiida/common/json.py:docstring of aiida.common.json.load:3
#: ../../../src/aiida/common/json.py:docstring of aiida.common.json.loads:3
msgid "if no valid JSON object could be decoded."
msgstr ""

#: ../../../src/aiida/common/json.py:docstring of aiida.common.json.loads:1
msgid "Deserialize text or binary ``string`` containing a JSON document to a Python object."
msgstr ""

#: ../../../src/aiida/common/lang.py:docstring of aiida.common.lang:1
msgid "Utilities that extend the basic python language."
msgstr ""

#: ../../../src/aiida/common/lang.py:docstring of aiida.common.lang.classproperty:1
msgid "Bases: :py:class:`~typing.Generic`\\ [:py:obj:`~aiida.common.lang.ReturnType`]"
msgstr ""

#: ../../../src/aiida/common/lang.py:docstring of aiida.common.lang.classproperty:1
#: ../../docstring of aiida.orm.entities.Entity.collection:1
#: ../../docstring of aiida.orm.entities.Entity.objects:1
#: ../../docstring of aiida.orm.utils.loaders.OrmEntityLoader.orm_base_class:1
#: ../../docstring of aiida.schedulers.scheduler.Scheduler.job_resource_class:1
msgid "A class that, when used as a decorator, works as if the two decorators @property and @classmethod where applied together (i.e., the object works as a property, both for the Class and for any of its instance; and is called with the class cls rather than with the instance as its first argument)."
msgstr ""

#: ../../../src/aiida/common/lang.py:docstring of aiida.common.lang.isidentifier:1
msgid "Return whether the given string is a valid python identifier."
msgstr ""

#: ../../../src/aiida/common/lang.py:docstring of aiida.common.lang.isidentifier:3
msgid "boolean, True if identifier is valid, False otherwise"
msgstr ""

#: ../../../src/aiida/common/lang.py:docstring of aiida.common.lang.isidentifier:4
msgid "if identifier is not string type"
msgstr ""

#: ../../../src/aiida/common/lang.py:docstring of aiida.common.lang.override_decorator:1
msgid "Decorator to signal that a method from a base class is being overridden completely."
msgstr ""

#: ../../../src/aiida/common/lang.py:docstring of aiida.common.lang.type_check:1
msgid "Verify that object 'what' is of type 'of_type' and if not the case, raise a TypeError."
msgstr ""

#: ../../../src/aiida/common/lang.py:docstring of aiida.common.lang.type_check:3
msgid "the object to check"
msgstr ""

#: ../../../src/aiida/common/lang.py:docstring of aiida.common.lang.type_check:4
msgid "the type (or tuple of types) to compare to"
msgstr ""

#: ../../../src/aiida/common/lang.py:docstring of aiida.common.lang.type_check:5
msgid "if specified, allows to customize the message that is passed within the TypeError exception"
msgstr ""

#: ../../../src/aiida/common/lang.py:docstring of aiida.common.lang.type_check:6
msgid "boolean, if True will not raise if the passed `what` is `None`"
msgstr ""

#: ../../../src/aiida/common/lang.py:docstring of aiida.common.lang.type_check:8
msgid "`what` or `None`"
msgstr ""

#: ../../../src/aiida/common/links.py:docstring of aiida.common.links:1
msgid "Module with utilities and data structures pertaining to links between nodes in the provenance graph."
msgstr ""

#: ../../../src/aiida/common/links.py:docstring of aiida.common.links.GraphTraversalRule:1
#: ../../../src/aiida/storage/psql_dos/migrations/utils/calc_state.py:docstring of aiida.storage.psql_dos.migrations.utils.calc_state.StateMapping:1
#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.GroupNodeEdge:1
#: ../../../src/aiida/tools/groups/paths.py:docstring of aiida.tools.groups.paths.WalkNodeResult:1
msgid "Bases: :py:class:`tuple`"
msgstr ""

#: ../../../src/aiida/common/links.py:docstring of aiida.common.links.GraphTraversalRule:1
msgid "A namedtuple that defines a graph traversal rule."
msgstr ""

#: ../../../src/aiida/common/links.py:docstring of aiida.common.links.GraphTraversalRule:3
msgid "When starting from a certain sub set of nodes, the graph traversal rules specify which links should be followed to add adjacent nodes to finally arrive at a set of nodes that represent a valid and consistent sub graph."
msgstr ""

#: ../../../src/aiida/common/links.py:docstring of aiida.common.links.GraphTraversalRule:6
msgid "the `LinkType` that the rule applies to"
msgstr ""

#: ../../../src/aiida/common/links.py:docstring of aiida.common.links.GraphTraversalRule:7
msgid "whether the link type should be followed backwards or forwards"
msgstr ""

#: ../../../src/aiida/common/links.py:docstring of aiida.common.links.GraphTraversalRule:8
msgid "boolean to indicate whether the rule can be changed from the default value. If this is `False` it means the default value can never be changed as it will result in an inconsistent graph."
msgstr ""

#: ../../../src/aiida/common/links.py:docstring of aiida.common.links.GraphTraversalRule:10
msgid "boolean, the default value of the rule, if `True` means that the link type for the given direction should be followed."
msgstr ""

#: ../../../src/aiida/common/links.py:docstring of collections.GraphTraversalRule.__getnewargs__:1
#: ../../../src/aiida/engine/processes/exit_code.py:docstring of collections.ExitCode.__getnewargs__:1
#: ../../../src/aiida/engine/processes/workchains/utils.py:docstring of collections.ProcessHandlerReport.__getnewargs__:1
#: ../../../src/aiida/engine/runners.py:docstring of collections.ResultAndNode.__getnewargs__:1
#: ../../../src/aiida/engine/runners.py:docstring of collections.ResultAndPk.__getnewargs__:1
#: ../../../src/aiida/orm/querybuilder.py:docstring of collections.Classifier.__getnewargs__:1
#: ../../../src/aiida/orm/utils/links.py:docstring of collections.LinkPair.__getnewargs__:1
#: ../../../src/aiida/orm/utils/links.py:docstring of collections.LinkQuadruple.__getnewargs__:1
#: ../../../src/aiida/orm/utils/links.py:docstring of collections.LinkTriple.__getnewargs__:1
#: ../../../src/aiida/storage/psql_dos/migrations/utils/calc_state.py:docstring of collections.StateMapping.__getnewargs__:1
#: ../../../src/aiida/tools/graph/age_entities.py:docstring of collections.GroupNodeEdge.__getnewargs__:1
#: ../../../src/aiida/tools/groups/paths.py:docstring of collections.WalkNodeResult.__getnewargs__:1
msgid "Return self as a plain tuple.  Used by copy and pickle."
msgstr ""

#: ../../../src/aiida/common/links.py:docstring of namedtuple_GraphTraversalRule.GraphTraversalRule.__new__:1
msgid "Create new instance of GraphTraversalRule(link_type, direction, toggleable, default)"
msgstr ""

#: ../../../src/aiida/common/links.py:docstring of collections.GraphTraversalRule.__repr__:1
#: ../../../src/aiida/engine/processes/exit_code.py:docstring of collections.ExitCode.__repr__:1
#: ../../../src/aiida/engine/processes/workchains/utils.py:docstring of collections.ProcessHandlerReport.__repr__:1
#: ../../../src/aiida/engine/runners.py:docstring of collections.ResultAndNode.__repr__:1
#: ../../../src/aiida/engine/runners.py:docstring of collections.ResultAndPk.__repr__:1
#: ../../../src/aiida/orm/querybuilder.py:docstring of collections.Classifier.__repr__:1
#: ../../../src/aiida/orm/utils/links.py:docstring of collections.LinkPair.__repr__:1
#: ../../../src/aiida/orm/utils/links.py:docstring of collections.LinkQuadruple.__repr__:1
#: ../../../src/aiida/orm/utils/links.py:docstring of collections.LinkTriple.__repr__:1
#: ../../../src/aiida/storage/psql_dos/migrations/utils/calc_state.py:docstring of collections.StateMapping.__repr__:1
#: ../../../src/aiida/tools/graph/age_entities.py:docstring of collections.GroupNodeEdge.__repr__:1
#: ../../../src/aiida/tools/groups/paths.py:docstring of collections.WalkNodeResult.__repr__:1
msgid "Return a nicely formatted representation string"
msgstr ""

#: ../../../src/aiida/common/links.py:docstring of collections.GraphTraversalRule._asdict:1
#: ../../../src/aiida/engine/processes/exit_code.py:docstring of collections.ExitCode._asdict:1
#: ../../../src/aiida/engine/processes/workchains/utils.py:docstring of collections.ProcessHandlerReport._asdict:1
#: ../../../src/aiida/engine/runners.py:docstring of collections.ResultAndNode._asdict:1
#: ../../../src/aiida/engine/runners.py:docstring of collections.ResultAndPk._asdict:1
#: ../../../src/aiida/orm/querybuilder.py:docstring of collections.Classifier._asdict:1
#: ../../../src/aiida/orm/utils/links.py:docstring of collections.LinkPair._asdict:1
#: ../../../src/aiida/orm/utils/links.py:docstring of collections.LinkQuadruple._asdict:1
#: ../../../src/aiida/orm/utils/links.py:docstring of collections.LinkTriple._asdict:1
#: ../../../src/aiida/storage/psql_dos/migrations/utils/calc_state.py:docstring of collections.StateMapping._asdict:1
#: ../../../src/aiida/tools/graph/age_entities.py:docstring of collections.GroupNodeEdge._asdict:1
#: ../../../src/aiida/tools/groups/paths.py:docstring of collections.WalkNodeResult._asdict:1
msgid "Return a new dict which maps field names to their values."
msgstr ""

#: ../../../src/aiida/common/links.py:docstring of collections.GraphTraversalRule._make:1
msgid "Make a new GraphTraversalRule object from a sequence or iterable"
msgstr ""

#: ../../../src/aiida/common/links.py:docstring of collections.GraphTraversalRule._replace:1
msgid "Return a new GraphTraversalRule object replacing specified fields with new values"
msgstr ""

#: ../../docstring of aiida.common.links.GraphTraversalRule.default:1
#: ../../docstring of aiida.orm.utils.links.LinkQuadruple.link_label:1
#: ../../docstring of aiida.storage.psql_dos.migrations.utils.calc_state.StateMapping.process_status:1
msgid "Alias for field number 3"
msgstr ""

#: ../../docstring of aiida.common.links.GraphTraversalRule.direction:1
#: ../../docstring of aiida.engine.processes.exit_code.ExitCode.message:1
#: ../../docstring of aiida.engine.processes.workchains.utils.ProcessHandlerReport.exit_code:1
#: ../../docstring of aiida.engine.runners.ResultAndNode.node:1
#: ../../docstring of aiida.engine.runners.ResultAndPk.pk:1
#: ../../docstring of aiida.orm.querybuilder.Classifier.process_type_string:1
#: ../../docstring of aiida.orm.utils.links.LinkPair.link_label:1
#: ../../docstring of aiida.orm.utils.links.LinkQuadruple.target_id:1
#: ../../docstring of aiida.orm.utils.links.LinkTriple.link_type:1
#: ../../docstring of aiida.storage.psql_dos.migrations.utils.calc_state.StateMapping.process_state:1
#: ../../docstring of aiida.tools.graph.age_entities.GroupNodeEdge.group_id:1
#: ../../docstring of aiida.tools.groups.paths.WalkNodeResult.node:1
msgid "Alias for field number 1"
msgstr ""

#: ../../docstring of aiida.common.links.GraphTraversalRule.link_type:1
#: ../../docstring of aiida.engine.processes.exit_code.ExitCode.status:1
#: ../../docstring of aiida.engine.processes.workchains.utils.ProcessHandlerReport.do_break:1
#: ../../docstring of aiida.engine.runners.ResultAndNode.result:1
#: ../../docstring of aiida.engine.runners.ResultAndPk.result:1
#: ../../docstring of aiida.orm.querybuilder.Classifier.ormclass_type_string:1
#: ../../docstring of aiida.orm.utils.links.LinkPair.link_type:1
#: ../../docstring of aiida.orm.utils.links.LinkQuadruple.source_id:1
#: ../../docstring of aiida.orm.utils.links.LinkTriple.node:1
#: ../../docstring of aiida.storage.psql_dos.migrations.utils.calc_state.StateMapping.state:1
#: ../../docstring of aiida.tools.graph.age_entities.GroupNodeEdge.node_id:1
#: ../../docstring of aiida.tools.groups.paths.WalkNodeResult.group_path:1
msgid "Alias for field number 0"
msgstr ""

#: ../../docstring of aiida.common.links.GraphTraversalRule.toggleable:1
#: ../../docstring of aiida.engine.processes.exit_code.ExitCode.invalidates_cache:1
#: ../../docstring of aiida.orm.utils.links.LinkQuadruple.link_type:1
#: ../../docstring of aiida.orm.utils.links.LinkTriple.link_label:1
#: ../../docstring of aiida.storage.psql_dos.migrations.utils.calc_state.StateMapping.exit_status:1
msgid "Alias for field number 2"
msgstr ""

#: ../../../src/aiida/common/links.py:docstring of aiida.common.links.GraphTraversalRules:1
msgid "Graph traversal rules when deleting or exporting nodes."
msgstr ""

#: ../../../src/aiida/common/links.py:docstring of aiida.common.links.LinkType:1
msgid "A simple enum of allowed link types."
msgstr ""

#: ../../../src/aiida/common/links.py:docstring of aiida.common.links.validate_link_label:1
msgid "Validate the given link label."
msgstr ""

#: ../../../src/aiida/common/links.py:docstring of aiida.common.links.validate_link_label:3
#: ../../../src/aiida/engine/processes/ports.py:docstring of aiida.engine.processes.ports.PortNamespace.validate_port_name:8
msgid "Valid link labels adhere to the following restrictions:"
msgstr ""

#: ../../../src/aiida/common/links.py:docstring of aiida.common.links.validate_link_label:5
#: ../../../src/aiida/engine/processes/ports.py:docstring of aiida.engine.processes.ports.PortNamespace.validate_port_name:10
msgid "Has to be a valid python identifier"
msgstr ""

#: ../../../src/aiida/common/links.py:docstring of aiida.common.links.validate_link_label:6
#: ../../../src/aiida/engine/processes/ports.py:docstring of aiida.engine.processes.ports.PortNamespace.validate_port_name:11
msgid "Can only contain alphanumeric characters and underscores"
msgstr ""

#: ../../../src/aiida/common/links.py:docstring of aiida.common.links.validate_link_label:7
#: ../../../src/aiida/engine/processes/ports.py:docstring of aiida.engine.processes.ports.PortNamespace.validate_port_name:12
msgid "Can not start or end with an underscore"
msgstr ""

#: ../../../src/aiida/common/links.py:docstring of aiida.common.links.validate_link_label:9
msgid "if the link label is not a string type"
msgstr ""

#: ../../../src/aiida/common/links.py:docstring of aiida.common.links.validate_link_label:10
msgid "if the link label is invalid"
msgstr ""

#: ../../../src/aiida/common/log.py:docstring of aiida.common.log:1
msgid "Module for all logging methods/classes that don't need the ORM."
msgstr ""

#: ../../../src/aiida/common/log.py:docstring of aiida.common.log.AiidaLoggerType:1
msgid "Bases: :py:class:`~logging.Logger`"
msgstr ""

#: ../../../src/aiida/common/log.py:docstring of aiida.common.log.AiidaLoggerType.report:1
#: ../../../src/aiida/common/log.py:docstring of aiida.common.log.report:1
msgid "Log a message at the ``REPORT`` level."
msgstr ""

#: ../../docstring of aiida.common.log.CLI_ACTIVE:1
msgid "Flag that is set to ``True`` if the module is imported by ``verdi`` being called."
msgstr ""

#: ../../docstring of aiida.common.log.CLI_LOG_LEVEL:1
msgid "Set if ``verdi`` is called with ``--verbosity`` flag specified, and is set to corresponding log level."
msgstr ""

#: ../../../src/aiida/common/log.py:docstring of aiida.common.log.capture_logging:1
msgid "Capture logging to a stream in memory."
msgstr ""

#: ../../../src/aiida/common/log.py:docstring of aiida.common.log.capture_logging:3
msgid "Note, this only copies any content that is being logged to a stream in memory. It does not interfere with any other existing stream handlers. In this sense, this context manager is non-destructive."
msgstr ""

#: ../../../src/aiida/common/log.py:docstring of aiida.common.log.capture_logging:6
msgid "The logger whose output to capture."
msgstr ""

#: ../../../src/aiida/common/log.py:docstring of aiida.common.log.capture_logging:7
msgid "A stream to which the logged content is captured."
msgstr ""

#: ../../../src/aiida/common/log.py:docstring of aiida.common.log.configure_logging:1
msgid "Setup the logging by retrieving the LOGGING dictionary from aiida and passing it to the python module logging.config.dictConfig. If the logging needs to be setup for the daemon, set the argument 'daemon' to True and specify the path to the log file. This will cause a 'daemon_handler' to be added to all the configured loggers, that is a RotatingFileHandler that writes to the log file."
msgstr ""

#: ../../../src/aiida/common/log.py:docstring of aiida.common.log.configure_logging:7
msgid "configure logging to the backend storage. We don't configure this by default, since it would load the modules that slow the CLI"
msgstr ""

#: ../../../src/aiida/common/log.py:docstring of aiida.common.log.configure_logging:9
msgid "configure the logging for a daemon task by adding a file handler instead of the default 'console' StreamHandler"
msgstr ""

#: ../../../src/aiida/common/log.py:docstring of aiida.common.log.configure_logging:11
msgid "absolute filepath of the log file for the RotatingFileHandler"
msgstr ""

#: ../../../src/aiida/common/log.py:docstring of aiida.common.log.evaluate_logging_configuration:1
msgid "Recursively evaluate the logging configuration, calling lambdas when encountered."
msgstr ""

#: ../../../src/aiida/common/log.py:docstring of aiida.common.log.evaluate_logging_configuration:3
msgid "This allows the configuration options that are dependent on the active profile to be loaded lazily."
msgstr ""

#: ../../../src/aiida/common/log.py:docstring of aiida.common.log.evaluate_logging_configuration:5
msgid "evaluated logging configuration dictionary"
msgstr ""

#: ../../../src/aiida/common/log.py:docstring of aiida.common.log.override_log_level:1
msgid "Temporarily adjust the log-level of logger."
msgstr ""

#: ../../../src/aiida/common/progress_reporter.py:docstring of aiida.common.progress_reporter:1
msgid "Provide a singleton progress reporter implementation."
msgstr ""

#: ../../../src/aiida/common/progress_reporter.py:docstring of aiida.common.progress_reporter:3
msgid "The interface is inspired by `tqdm <https://github.com/tqdm/tqdm>`, and indeed a valid implementation is::"
msgstr ""

#: ../../../src/aiida/common/progress_reporter.py:docstring of aiida.common.progress_reporter.ProgressReporterAbstract:1
msgid "An abstract class for incrementing a progress reporter."
msgstr ""

#: ../../../src/aiida/common/progress_reporter.py:docstring of aiida.common.progress_reporter.ProgressReporterAbstract:3
msgid "This class provides the base interface for any `ProgressReporter` class."
msgstr ""

#: ../../../src/aiida/common/progress_reporter.py:docstring of aiida.common.progress_reporter.ProgressReporterAbstract:5
#: ../../../src/aiida/common/progress_reporter.py:docstring of aiida.common.progress_reporter.get_progress_reporter:3
#: ../../../src/aiida/common/progress_reporter.py:docstring of aiida.common.progress_reporter.set_progress_reporter:10
msgid "Example Usage::"
msgstr ""

#: ../../../src/aiida/common/progress_reporter.py:docstring of aiida.common.progress_reporter.ProgressReporterAbstract.__enter__:1
msgid "Enter the contextmanager."
msgstr ""

#: ../../../src/aiida/common/progress_reporter.py:docstring of aiida.common.progress_reporter.ProgressReporterAbstract.__exit__:1
msgid "Exit the contextmanager."
msgstr ""

#: ../../../src/aiida/common/progress_reporter.py:docstring of aiida.common.progress_reporter.ProgressReporterAbstract.__init__:1
msgid "Initialise the progress reporting contextmanager."
msgstr ""

#: ../../../src/aiida/common/progress_reporter.py:docstring of aiida.common.progress_reporter.ProgressReporterAbstract.__init__:3
msgid "The number of expected iterations."
msgstr ""

#: ../../../src/aiida/common/progress_reporter.py:docstring of aiida.common.progress_reporter.ProgressReporterAbstract.__init__:4
msgid "A description of the process"
msgstr ""

#: ../../../src/aiida/common/progress_reporter.py:docstring of aiida.common.progress_reporter.ProgressReporterAbstract.desc:1
msgid "Return the description of the process."
msgstr ""

#: ../../../src/aiida/common/progress_reporter.py:docstring of aiida.common.progress_reporter.ProgressReporterAbstract.n:1
msgid "Return the current iteration."
msgstr ""

#: ../../../src/aiida/common/progress_reporter.py:docstring of aiida.common.progress_reporter.ProgressReporterAbstract.reset:1
msgid "Resets current iterations to 0."
msgstr ""

#: ../../../src/aiida/common/progress_reporter.py:docstring of aiida.common.progress_reporter.ProgressReporterAbstract.reset:3
msgid "If not None, update number of expected iterations."
msgstr ""

#: ../../../src/aiida/common/progress_reporter.py:docstring of aiida.common.progress_reporter.ProgressReporterAbstract.set_description_str:1
msgid "Set the text shown by the progress reporter."
msgstr ""

#: ../../../src/aiida/common/progress_reporter.py:docstring of aiida.common.progress_reporter.ProgressReporterAbstract.set_description_str:3
msgid "The text to show"
msgstr ""

#: ../../../src/aiida/common/progress_reporter.py:docstring of aiida.common.progress_reporter.ProgressReporterAbstract.set_description_str:4
msgid "Force refresh of the progress reporter"
msgstr ""

#: ../../../src/aiida/common/progress_reporter.py:docstring of aiida.common.progress_reporter.ProgressReporterAbstract.total:1
msgid "Return the total iterations expected."
msgstr ""

#: ../../../src/aiida/common/progress_reporter.py:docstring of aiida.common.progress_reporter.ProgressReporterAbstract.update:1
msgid "Update the progress counter."
msgstr ""

#: ../../../src/aiida/common/progress_reporter.py:docstring of aiida.common.progress_reporter.ProgressReporterAbstract.update:3
msgid "Increment to add to the internal counter of iterations"
msgstr ""

#: ../../../src/aiida/common/progress_reporter.py:docstring of aiida.common.progress_reporter.ProgressReporterNull:1
msgid "Bases: :py:class:`~aiida.common.progress_reporter.ProgressReporterAbstract`"
msgstr ""

#: ../../../src/aiida/common/progress_reporter.py:docstring of aiida.common.progress_reporter.ProgressReporterNull:1
msgid "A null implementation of the progress reporter."
msgstr ""

#: ../../../src/aiida/common/progress_reporter.py:docstring of aiida.common.progress_reporter.ProgressReporterNull:3
msgid "This implementation does not output anything."
msgstr ""

#: ../../../src/aiida/common/progress_reporter.py:docstring of aiida.common.progress_reporter.create_callback:1
msgid "Create a callback function to update the progress reporter."
msgstr ""

#: ../../../src/aiida/common/progress_reporter.py:docstring of aiida.common.progress_reporter.create_callback:3
msgid "a callback to report on the process, ``callback(action, value)``, with the following callback signatures:  - ``callback('init', {'total': <int>, 'description': <str>})``,     to reset the progress with a new total iterations and description - ``callback('update', <int>)``,     to update the progress by a certain number of iterations"
msgstr ""

#: ../../../src/aiida/common/progress_reporter.py:docstring of aiida.common.progress_reporter.create_callback:3
msgid "a callback to report on the process, ``callback(action, value)``, with the following callback signatures:"
msgstr ""

#: ../../../src/aiida/common/progress_reporter.py:docstring of aiida.common.progress_reporter.create_callback:6
msgid "``callback('init', {'total': <int>, 'description': <str>})``,"
msgstr ""

#: ../../../src/aiida/common/progress_reporter.py:docstring of aiida.common.progress_reporter.create_callback:7
msgid "to reset the progress with a new total iterations and description"
msgstr ""

#: ../../../src/aiida/common/progress_reporter.py:docstring of aiida.common.progress_reporter.create_callback:8
msgid "``callback('update', <int>)``,"
msgstr ""

#: ../../../src/aiida/common/progress_reporter.py:docstring of aiida.common.progress_reporter.create_callback:9
msgid "to update the progress by a certain number of iterations"
msgstr ""

#: ../../../src/aiida/common/progress_reporter.py:docstring of aiida.common.progress_reporter.get_progress_reporter:1
msgid "Return the progress reporter"
msgstr ""

#: ../../../src/aiida/common/progress_reporter.py:docstring of aiida.common.progress_reporter.set_progress_bar_tqdm:1
msgid "Set a `tqdm <https://github.com/tqdm/tqdm>`__ implementation of the progress reporter interface."
msgstr ""

#: ../../../src/aiida/common/progress_reporter.py:docstring of aiida.common.progress_reporter.set_progress_bar_tqdm:3
msgid "See :func:`~aiida.common.progress_reporter.set_progress_reporter` for details."
msgstr ""

#: ../../../src/aiida/common/progress_reporter.py:docstring of aiida.common.progress_reporter.set_progress_bar_tqdm:5
msgid "Specify a custom bar string format."
msgstr ""

#: ../../../src/aiida/common/progress_reporter.py:docstring of aiida.common.progress_reporter.set_progress_bar_tqdm:6
msgid "If True, keeps all traces of the progressbar upon termination of iteration. If `None`, will leave only if `position` is `0`."
msgstr ""

#: ../../../src/aiida/common/progress_reporter.py:docstring of aiida.common.progress_reporter.set_progress_bar_tqdm:8
msgid "pass to the tqdm init"
msgstr ""

#: ../../../src/aiida/common/progress_reporter.py:docstring of aiida.common.progress_reporter.set_progress_reporter:1
msgid "Set the progress reporter implementation"
msgstr ""

#: ../../../src/aiida/common/progress_reporter.py:docstring of aiida.common.progress_reporter.set_progress_reporter:3
msgid "A progress reporter for a process.  If None, reset to ``ProgressReporterNull``."
msgstr ""

#: ../../../src/aiida/common/progress_reporter.py:docstring of aiida.common.progress_reporter.set_progress_reporter:5
msgid "If present, set a partial function with these kwargs"
msgstr ""

#: ../../../src/aiida/common/progress_reporter.py:docstring of aiida.common.progress_reporter.set_progress_reporter:7
msgid "The reporter should be a context manager that implements the :func:`~aiida.common.progress_reporter.ProgressReporterAbstract` interface."
msgstr ""

#: ../../../src/aiida/common/timezone.py:docstring of aiida.common.timezone:1
msgid "Utility functions to operate on datetime objects."
msgstr ""

#: ../../../src/aiida/common/timezone.py:docstring of aiida.common.timezone.delta:1
msgid "Return the datetime object representing the different between two datetime objects."
msgstr ""

#: ../../../src/aiida/common/timezone.py:docstring of aiida.common.timezone.delta:3
msgid "The starting datetime object."
msgstr ""

#: ../../../src/aiida/common/timezone.py:docstring of aiida.common.timezone.delta:4
msgid "The end datetime object. If not specified :func:`aiida.common.timezone.now` is used."
msgstr ""

#: ../../../src/aiida/common/timezone.py:docstring of aiida.common.timezone.delta:5
msgid "The delta datetime object."
msgstr ""

#: ../../../src/aiida/common/timezone.py:docstring of aiida.common.timezone.localtime:1
msgid "Make a :class:`datetime.datetime` object timezone aware with the local timezone."
msgstr ""

#: ../../../src/aiida/common/timezone.py:docstring of aiida.common.timezone.localtime:3
#: ../../../src/aiida/common/timezone.py:docstring of aiida.common.timezone.make_aware:3
msgid "The datetime object to make aware."
msgstr ""

#: ../../../src/aiida/common/timezone.py:docstring of aiida.common.timezone.localtime:4
msgid "A timezone aware datetime object with the timezone set to that of the operating system."
msgstr ""

#: ../../../src/aiida/common/timezone.py:docstring of aiida.common.timezone.make_aware:1
msgid "Make the given datetime object timezone aware."
msgstr ""

#: ../../../src/aiida/common/timezone.py:docstring of aiida.common.timezone.make_aware:4
msgid "The timezone to set. If not defined the system local timezone is assumed for the target timezone."
msgstr ""

#: ../../../src/aiida/common/timezone.py:docstring of aiida.common.timezone.make_aware:5
msgid "A timezone aware datetime object."
msgstr ""

#: ../../../src/aiida/common/timezone.py:docstring of aiida.common.timezone.now:1
msgid "Return the datetime object of the current time."
msgstr ""

#: ../../../src/aiida/common/timezone.py:docstring of aiida.common.timezone.now:3
msgid "datetime object represeting current time"
msgstr ""

#: ../../../src/aiida/common/timezone.py:docstring of aiida.common.timezone.timezone_from_name:1
msgid "Return a :class:`datetime.tzinfo` instance corresponding to the given timezone name."
msgstr ""

#: ../../../src/aiida/common/timezone.py:docstring of aiida.common.timezone.timezone_from_name:3
msgid "The timezone name. Should correspond to a known name in the Olsen database. https://en.wikipedia.org/wiki/Tz_database"
msgstr ""

#: ../../../src/aiida/common/timezone.py:docstring of aiida.common.timezone.timezone_from_name:5
msgid "The corresponding timezone object."
msgstr ""

#: ../../../src/aiida/common/timezone.py:docstring of aiida.common.timezone.timezone_from_name:6
msgid "if the timezone name is unknown."
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils:1
msgid "Miscellaneous generic utility functions and classes."
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.ArrayCounter:1
msgid "A counter & a method that increments it and returns its value. It is used in various tests."
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.Capturing:1
msgid "This class captures stdout and returns it (as a list, split by lines)."
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.Capturing:4
msgid "Note: if you raise a SystemExit, you have to catch it outside. E.g., in our tests, this works::"
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.Capturing:12
msgid "But out of the testing environment, the code instead just exits."
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.Capturing:14
msgid "To use it, access the obj.stdout_lines, or just iterate over the object"
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.Capturing:16
msgid "if True, also captures sys.stderr. To access the lines, use obj.stderr_lines. If False, obj.stderr_lines is None."
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.Capturing.__enter__:1
msgid "Enter the context where all output is captured."
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.Capturing.__exit__:1
msgid "Exit the context where all output is captured."
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.Capturing.__str__:1
#: ../../../src/aiida/manage/configuration/options.py:docstring of aiida.manage.configuration.options.Option.__str__:1
#: ../../../src/aiida/orm/authinfos.py:docstring of aiida.orm.authinfos.AuthInfo.__str__:1
#: ../../../src/aiida/orm/comments.py:docstring of aiida.orm.comments.Comment.__str__:1
#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.__str__:1
#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.Group.__str__:1
#: ../../../src/aiida/orm/implementation/groups.py:docstring of aiida.orm.implementation.groups.BackendGroup.__str__:1
#: ../../../src/aiida/orm/nodes/data/base.py:docstring of aiida.orm.nodes.data.base.BaseType.__str__:1
#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.__str__:1
#: ../../../src/aiida/orm/nodes/data/list.py:docstring of aiida.orm.nodes.data.list.List.__str__:1
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.Kind.__str__:1
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.Site.__str__:1
#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node.__str__:1
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.__str__:1
#: ../../../src/aiida/orm/users.py:docstring of aiida.orm.users.User.__str__:1
#: ../../../src/aiida/orm/utils/builders/code.py:docstring of aiida.orm.utils.builders.code.CodeBuilder.CodeValidationError.__str__:1
#: ../../../src/aiida/orm/utils/builders/computer.py:docstring of aiida.orm.utils.builders.computer.ComputerBuilder.ComputerValidationError.__str__:1
#: ../../../src/aiida/restapi/common/identifiers.py:docstring of aiida.restapi.common.identifiers.Namespace.__str__:1
#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler.__str__:1
#: ../../../src/aiida/storage/psql_dos/models/authinfo.py:docstring of aiida.storage.psql_dos.models.authinfo.DbAuthInfo.__str__:1
#: ../../../src/aiida/storage/psql_dos/models/comment.py:docstring of aiida.storage.psql_dos.models.comment.DbComment.__str__:1
#: ../../../src/aiida/storage/psql_dos/models/computer.py:docstring of aiida.storage.psql_dos.models.computer.DbComputer.__str__:1
#: ../../../src/aiida/storage/psql_dos/models/group.py:docstring of aiida.storage.psql_dos.models.group.DbGroup.__str__:1
#: ../../../src/aiida/storage/psql_dos/models/log.py:docstring of aiida.storage.psql_dos.models.log.DbLog.__str__:1
#: ../../../src/aiida/storage/psql_dos/models/node.py:docstring of aiida.storage.psql_dos.models.node.DbLink.__str__:1
#: ../../../src/aiida/storage/psql_dos/models/settings.py:docstring of aiida.storage.psql_dos.models.settings.DbSetting.__str__:1
#: ../../../src/aiida/storage/psql_dos/models/user.py:docstring of aiida.storage.psql_dos.models.user.DbUser.__str__:1
#: ../../../src/aiida/tools/data/orbital/orbital.py:docstring of aiida.tools.data.orbital.orbital.Orbital.__str__:1
#: ../../../src/aiida/tools/data/orbital/realhydrogen.py:docstring of aiida.tools.data.orbital.realhydrogen.RealhydrogenOrbital.__str__:1
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.__str__:1
msgid "Return str(self)."
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.DatetimePrecision:1
msgid "A simple class which stores a datetime object with its precision. No internal check is done (cause itis not possible)."
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.DatetimePrecision:8
msgid "precision:  1 (only full date)"
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.DatetimePrecision:5
msgid "2 (date plus hour) 3 (date + hour + minute) 4 (dare + hour + minute +second)"
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.DatetimePrecision.__init__:1
msgid "Constructor to check valid datetime object and precision"
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.ErrorAccumulator:1
msgid "Allows to run a number of functions and collect all the errors they raise"
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.ErrorAccumulator:3
msgid "This allows to validate multiple things and tell the user about all the errors encountered at once. Works best if the individual functions do not depend on each other."
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.ErrorAccumulator:6
msgid "Does not allow to trace the stack of each error, therefore do not use for debugging, but for semantical checking with user friendly error messages."
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.Prettifier:1
msgid "Class to manage prettifiers (typically for labels of kpoints in band plots)"
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.Prettifier.__init__:1
msgid "Create a class to pretttify strings of a given format"
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.Prettifier.__init__:3
msgid "a string with the format to use to prettify. Valid formats are obtained from self.prettifiers"
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.Prettifier._prettify_label_agr:1
msgid "Prettifier for XMGrace"
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.Prettifier._prettify_label_agr:3
#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.Prettifier._prettify_label_agr_simple:3
#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.Prettifier._prettify_label_gnuplot:5
#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.Prettifier._prettify_label_gnuplot_simple:5
#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.Prettifier._prettify_label_latex:3
#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.Prettifier._prettify_label_latex_simple:3
#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.Prettifier._prettify_label_pass:3
msgid "a string to prettify"
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.Prettifier._prettify_label_agr_simple:1
msgid "Prettifier for XMGrace (for old label names)"
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.Prettifier._prettify_label_gnuplot:1
msgid "Prettifier for Gnuplot"
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.Prettifier._prettify_label_gnuplot:3
#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.Prettifier._prettify_label_gnuplot_simple:3
msgid "uses unicode, returns unicode strings (potentially, if needed)"
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.Prettifier._prettify_label_gnuplot_simple:1
msgid "Prettifier for Gnuplot (for old label names)"
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.Prettifier._prettify_label_latex:1
msgid "Prettifier for matplotlib, using LaTeX syntax"
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.Prettifier._prettify_label_latex_simple:1
msgid "Prettifier for matplotlib, using LaTeX syntax (for old label names)"
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.Prettifier._prettify_label_pass:1
msgid "No-op prettifier, simply returns  the same label"
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.Prettifier.get_prettifiers:1
msgid "Return a list of valid prettifier strings"
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.Prettifier.get_prettifiers:3
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_site_kindnames:8
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.listdir:8
msgid "a list of strings"
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.Prettifier.prettify:1
msgid "Prettify a label using the format passed in the initializer"
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.Prettifier.prettify:3
msgid "the string to prettify"
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.Prettifier.prettify:4
msgid "a prettified string"
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.are_dir_trees_equal:1
msgid "Compare two directories recursively. Files in each directory are assumed to be equal if their names and contents are equal."
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.are_dir_trees_equal:4
msgid "@param dir1: First directory path @param dir2: Second directory path"
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.are_dir_trees_equal:8
msgid "@return: True if the directory trees are the same and"
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.are_dir_trees_equal:8
msgid "there were no errors while accessing the directories or files, False otherwise."
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.get_class_string:1
msgid "Return the string identifying the class of the object (module + object name, joined by dots)."
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.get_class_string:4
msgid "It works both for classes and for class instances."
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.get_new_uuid:1
msgid "Return a new UUID (typically to be used for new nodes)."
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.get_object_from_string:1
msgid "Given a string identifying an object (as returned by the get_class_string method) load and return the actual object."
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.get_unique_filename:1
msgid "Return a unique filename that can be added to the list_of_filenames."
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.get_unique_filename:3
msgid "If filename is not in list_of_filenames, it simply returns the filename string itself. Otherwise, it appends a integer number to the filename (before the extension) until it finds a unique filename."
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.get_unique_filename:7
msgid "the filename to add"
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.get_unique_filename:8
msgid "the list of filenames to which filename should be added, without name duplicates"
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.get_unique_filename:11
msgid "Either filename or its modification, with a number appended between the name and the extension."
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.grouper:1
msgid "Given an iterable, returns an iterable that returns tuples of groups of elements from iterable of length n, except the last one that has the required length to exaust iterable (i.e., there is no filling applied)."
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.grouper:5
msgid "length of each tuple (except the last one,that will have length <= n"
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.grouper:7
msgid "the iterable to divide in groups"
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.join_labels:1
msgid "Join labels with a joining symbol when they are very close"
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.join_labels:3
#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.prettify_labels:3
msgid "a list of length-2 tuples, in the format(position, label)"
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.join_labels:4
msgid "the string to use to join different paths. By default, a pipe"
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.join_labels:5
msgid "the threshold to decide if two float values are the same and should be joined"
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.join_labels:7
msgid "the same list as labels, but with the second value possibly replaced with strings joined when close enough"
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.prettify_labels:1
msgid "Prettify label for typesetting in various formats"
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.prettify_labels:4
msgid "a string with the format for the prettifier (e.g. 'agr', 'matplotlib', ...)"
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.prettify_labels:6
msgid "the same list as labels, but with the second value possibly replaced with a prettified version that typesets nicely in the selected format"
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.str_timedelta:1
msgid "Given a dt in seconds, return it in a HH:MM:SS format."
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.str_timedelta:3
msgid "a TimeDelta object"
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.str_timedelta:4
msgid "maximum number of non-zero fields to show (for instance if the number of days is non-zero, shows only days, hours and minutes, but not seconds)"
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.str_timedelta:7
msgid "if False, print always ``max_num_fields`` fields, even if they are zero. If True, do not print the first fields, if they are zero."
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.str_timedelta:10
msgid "if True, set dt = 0 if dt < 0."
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.strip_prefix:1
msgid "Strip the prefix from the given string and return it. If the prefix is not present the original string will be returned unaltered"
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.strip_prefix:4
msgid "the string from which to remove the prefix"
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.strip_prefix:5
msgid "the prefix to remove"
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.strip_prefix:6
msgid "the string with prefix removed"
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.validate_list_of_string_tuples:1
msgid "Check that:"
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.validate_list_of_string_tuples:3
msgid "``val`` is a list or tuple"
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.validate_list_of_string_tuples:4
msgid "each element of the list:"
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.validate_list_of_string_tuples:6
msgid "is a list or tuple"
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.validate_list_of_string_tuples:7
msgid "is of length equal to the parameter tuple_length"
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.validate_list_of_string_tuples:8
msgid "each of the two elements is a string"
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.validate_list_of_string_tuples:10
msgid "Return if valid, raise ValidationError if invalid"
msgstr ""

#: ../../../src/aiida/common/utils.py:docstring of aiida.common.utils.validate_uuid:1
msgid "A simple check for the UUID validity."
msgstr ""

#: ../../../src/aiida/common/warnings.py:docstring of aiida.common.warnings:1
msgid "Define warnings that can be thrown by AiiDA."
msgstr ""

#: ../../../src/aiida/common/warnings.py:docstring of aiida.common.warnings.AiidaDeprecationWarning:1
#: ../../../src/aiida/common/warnings.py:docstring of aiida.common.warnings.AiidaEntryPointWarning:1
#: ../../../src/aiida/common/warnings.py:docstring of aiida.common.warnings.AiidaTestWarning:1
msgid "Bases: :py:class:`Warning`"
msgstr ""

#: ../../../src/aiida/common/warnings.py:docstring of aiida.common.warnings.AiidaDeprecationWarning:1
msgid "Class for AiiDA deprecations."
msgstr ""

#: ../../../src/aiida/common/warnings.py:docstring of aiida.common.warnings.AiidaDeprecationWarning:3
msgid "It does *not* inherit, on purpose, from `DeprecationWarning` as this would be filtered out by default. Enabled by default, you can disable it by running in the shell::"
msgstr ""

#: ../../../src/aiida/common/warnings.py:docstring of aiida.common.warnings.AiidaEntryPointWarning:1
msgid "Class for warnings concerning AiiDA entry points."
msgstr ""

#: ../../../src/aiida/common/warnings.py:docstring of aiida.common.warnings.AiidaTestWarning:1
msgid "Class for warnings concerning the AiiDA testing infrastructure."
msgstr ""

#: ../../../src/aiida/common/warnings.py:docstring of aiida.common.warnings.warn_deprecation:1
msgid "Warn about a deprecation for a future aiida-core version."
msgstr ""

#: ../../../src/aiida/common/warnings.py:docstring of aiida.common.warnings.warn_deprecation:3
msgid "Warnings are emitted if the ``warnings.showdeprecations`` config option is set to ``True``. Its value can be overwritten with the ``AIIDA_WARN_v{version}`` environment variable. The exact value for the environment variable is irrelevant. Any value will mean the variable is enabled and warnings will be emitted."
msgstr ""

#: ../../../src/aiida/common/warnings.py:docstring of aiida.common.warnings.warn_deprecation:7
msgid "the message to be printed"
msgstr ""

#: ../../../src/aiida/common/warnings.py:docstring of aiida.common.warnings.warn_deprecation:8
msgid "the major version number of the future version"
msgstr ""

#: ../../../src/aiida/common/warnings.py:docstring of aiida.common.warnings.warn_deprecation:9
msgid "the stack level at which the warning is issued"
msgstr ""

#: ../../source/reference/apidoc/aiida.engine.rst:2
msgid "aiida.engine package"
msgstr ""

#: ../../../src/aiida/engine/__init__.py:docstring of aiida.engine:1
msgid "Module with all the internals that make up the engine of `aiida-core`."
msgstr ""

#: ../../../src/aiida/engine/exceptions.py:docstring of aiida.engine.exceptions:1
msgid "Exceptions that can be thrown by parts of the workflow engine."
msgstr ""

#: ../../../src/aiida/engine/exceptions.py:docstring of aiida.engine.exceptions.PastException:1
msgid "Raised when an attempt is made to continue a Process that has already excepted before."
msgstr ""

#: ../../../src/aiida/engine/launch.py:docstring of aiida.engine.launch:1
msgid "Top level functions that can be used to launch a Process."
msgstr ""

#: ../../../src/aiida/engine/launch.py:docstring of aiida.engine.launch.await_processes:1
msgid "Run a loop until all processes are terminated."
msgstr ""

#: ../../../src/aiida/engine/launch.py:docstring of aiida.engine.launch.await_processes:3
msgid "Sequence of nodes that represent the processes to await."
msgstr ""

#: ../../../src/aiida/engine/launch.py:docstring of aiida.engine.launch.await_processes:4
msgid "The interval between each iteration of checking the status of all processes."
msgstr ""

#: ../../../src/aiida/engine/launch.py:docstring of aiida.engine.launch.run:1
#: ../../../src/aiida/engine/launch.py:docstring of aiida.engine.launch.run_get_node:1
#: ../../../src/aiida/engine/launch.py:docstring of aiida.engine.launch.run_get_pk:1
msgid "Run the process with the supplied inputs in a local runner that will block until the process is completed."
msgstr ""

#: ../../../src/aiida/engine/launch.py:docstring of aiida.engine.launch.run:3
#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner._run:5
#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner.run:5
#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner.run_get_node:5
#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner.run_get_pk:5
msgid "the process class or process function to run"
msgstr ""

#: ../../../src/aiida/engine/launch.py:docstring of aiida.engine.launch.run:4
#: ../../../src/aiida/engine/launch.py:docstring of aiida.engine.launch.run_get_node:4
#: ../../../src/aiida/engine/launch.py:docstring of aiida.engine.launch.run_get_pk:4
#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner._run:6
#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner.run:6
#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner.run_get_node:6
#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner.run_get_pk:6
#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner.schedule:4
#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner.submit:6
msgid "the inputs to be passed to the process"
msgstr ""

#: ../../../src/aiida/engine/launch.py:docstring of aiida.engine.launch.run:5
#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner.run:7
msgid "the outputs of the process"
msgstr ""

#: ../../../src/aiida/engine/launch.py:docstring of aiida.engine.launch.run_get_node:3
#: ../../../src/aiida/engine/launch.py:docstring of aiida.engine.launch.run_get_pk:3
msgid "the process class, instance, builder or function to run"
msgstr ""

#: ../../../src/aiida/engine/launch.py:docstring of aiida.engine.launch.run_get_node:5
msgid "tuple of the outputs of the process and the process node"
msgstr ""

#: ../../../src/aiida/engine/launch.py:docstring of aiida.engine.launch.run_get_pk:5
#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner.run_get_pk:7
msgid "tuple of the outputs of the process and process node pk"
msgstr ""

#: ../../../src/aiida/engine/launch.py:docstring of aiida.engine.launch.submit:1
msgid "Submit the process with the supplied inputs to the daemon immediately returning control to the interpreter."
msgstr ""

#: ../../../src/aiida/engine/launch.py:docstring of aiida.engine.launch.submit:8
msgid "the process class, instance or builder to submit"
msgstr ""

#: ../../../src/aiida/engine/launch.py:docstring of aiida.engine.launch.submit:9
msgid "the input dictionary to be passed to the process"
msgstr ""

#: ../../../src/aiida/engine/launch.py:docstring of aiida.engine.launch.submit:10
msgid "when set to ``True``, the submission will be blocking and wait for the process to complete at which point the function returns the calculation node."
msgstr ""

#: ../../../src/aiida/engine/launch.py:docstring of aiida.engine.launch.submit:12
msgid "the number of seconds to wait between checking the state of the process when ``wait=True``."
msgstr ""

#: ../../../src/aiida/engine/launch.py:docstring of aiida.engine.launch.submit:13
msgid "inputs to be passed to the process. This is deprecated and the inputs should instead be passed as a dictionary to the ``inputs`` argument."
msgstr ""

#: ../../../src/aiida/engine/launch.py:docstring of aiida.engine.launch.submit:15
#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.submit:4
#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner.schedule:5
#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner.submit:7
msgid "the calculation node of the process"
msgstr ""

#: ../../../src/aiida/engine/persistence.py:docstring of aiida.engine.persistence:1
msgid "Definition of AiiDA's process persister and the necessary object loaders."
msgstr ""

#: ../../../src/aiida/engine/persistence.py:docstring of aiida.engine.persistence.AiiDAPersister:1
msgid "Bases: :py:class:`~plumpy.persistence.Persister`"
msgstr ""

#: ../../../src/aiida/engine/persistence.py:docstring of aiida.engine.persistence.AiiDAPersister:1
msgid "Persister to take saved process instance states and persisting them to the database."
msgstr ""

#: ../../../src/aiida/engine/persistence.py:docstring of aiida.engine.persistence.AiiDAPersister.delete_checkpoint:1
msgid "Delete a persisted process checkpoint, where no error will be raised if the checkpoint does not exist."
msgstr ""

#: ../../../src/aiida/engine/persistence.py:docstring of aiida.engine.persistence.AiiDAPersister.delete_checkpoint:3
#: ../../../src/aiida/engine/persistence.py:docstring of aiida.engine.persistence.AiiDAPersister.load_checkpoint:3
msgid "the process id of the :class:`plumpy.Process`"
msgstr ""

#: ../../../src/aiida/engine/persistence.py:docstring of aiida.engine.persistence.AiiDAPersister.delete_checkpoint:4
#: ../../../src/aiida/engine/persistence.py:docstring of aiida.engine.persistence.AiiDAPersister.load_checkpoint:4
msgid "optional checkpoint identifier to allow retrieving a specific sub checkpoint"
msgstr ""

#: ../../../src/aiida/engine/persistence.py:docstring of aiida.engine.persistence.AiiDAPersister.delete_process_checkpoints:1
msgid "Delete all persisted checkpoints related to the given process id."
msgstr ""

#: ../../../src/aiida/engine/persistence.py:docstring of aiida.engine.persistence.AiiDAPersister.delete_process_checkpoints:3
msgid "the process id of the :class:`aiida.engine.processes.process.Process`"
msgstr ""

#: ../../../src/aiida/engine/persistence.py:docstring of aiida.engine.persistence.AiiDAPersister.get_checkpoints:1
msgid "Return a list of all the current persisted process checkpoints"
msgstr ""

#: ../../../src/aiida/engine/persistence.py:docstring of aiida.engine.persistence.AiiDAPersister.get_checkpoints:3
#: ../../../src/aiida/engine/persistence.py:docstring of aiida.engine.persistence.AiiDAPersister.get_process_checkpoints:4
msgid "list of PersistedCheckpoint tuples with element containing the process id and optional checkpoint tag."
msgstr ""

#: ../../../src/aiida/engine/persistence.py:docstring of aiida.engine.persistence.AiiDAPersister.get_process_checkpoints:1
msgid "Return a list of all the current persisted process checkpoints for the specified process."
msgstr ""

#: ../../../src/aiida/engine/persistence.py:docstring of aiida.engine.persistence.AiiDAPersister.get_process_checkpoints:3
msgid "the process pid"
msgstr ""

#: ../../../src/aiida/engine/persistence.py:docstring of aiida.engine.persistence.AiiDAPersister.load_checkpoint:1
msgid "Load a process from a persisted checkpoint by its process id."
msgstr ""

#: ../../../src/aiida/engine/persistence.py:docstring of aiida.engine.persistence.AiiDAPersister.load_checkpoint:5
msgid "a bundle with the process state"
msgstr ""

#: ../../../src/aiida/engine/persistence.py:docstring of aiida.engine.persistence.AiiDAPersister.load_checkpoint:6
msgid ":class:`plumpy.Bundle`"
msgstr ""

#: ../../../src/aiida/engine/persistence.py:docstring of aiida.engine.persistence.AiiDAPersister.load_checkpoint:7
msgid ":class:`PersistenceError` Raised if there was a problem loading the checkpoint"
msgstr ""

#: ../../../src/aiida/engine/persistence.py:docstring of aiida.engine.persistence.AiiDAPersister.save_checkpoint:1
msgid "Persist a Process instance."
msgstr ""

#: ../../../src/aiida/engine/persistence.py:docstring of aiida.engine.persistence.AiiDAPersister.save_checkpoint:3
msgid ":class:`aiida.engine.Process`"
msgstr ""

#: ../../../src/aiida/engine/persistence.py:docstring of aiida.engine.persistence.AiiDAPersister.save_checkpoint:4
msgid "optional checkpoint identifier to allow distinguishing multiple checkpoints for the same process"
msgstr ""

#: ../../../src/aiida/engine/persistence.py:docstring of aiida.engine.persistence.AiiDAPersister.save_checkpoint:5
msgid ":class:`PersistenceError` Raised if there was a problem saving the checkpoint"
msgstr ""

#: ../../../src/aiida/engine/persistence.py:docstring of aiida.engine.persistence.ObjectLoader:1
msgid "Bases: :py:class:`~plumpy.loaders.DefaultObjectLoader`"
msgstr ""

#: ../../../src/aiida/engine/persistence.py:docstring of aiida.engine.persistence.ObjectLoader:1
msgid "Custom object loader for `aiida-core`."
msgstr ""

#: ../../../src/aiida/engine/persistence.py:docstring of aiida.engine.persistence.ObjectLoader.load_object:1
msgid "Attempt to load the object identified by the given `identifier`."
msgstr ""

#: ../../../src/aiida/engine/persistence.py:docstring of aiida.engine.persistence.ObjectLoader.load_object:3
msgid "We override the `plumpy.DefaultObjectLoader` to be able to throw an `ImportError` instead of a `ValueError` which in the context of `aiida-core` is not as apt, since we are loading classes."
msgstr ""

#: ../../../src/aiida/engine/persistence.py:docstring of aiida.engine.persistence.ObjectLoader.load_object:6
msgid "concatenation of module and resource name"
msgstr ""

#: ../../../src/aiida/engine/persistence.py:docstring of aiida.engine.persistence.ObjectLoader.load_object:7
msgid "loaded object"
msgstr ""

#: ../../../src/aiida/engine/persistence.py:docstring of aiida.engine.persistence.ObjectLoader.load_object:8
msgid "if the object cannot be loaded"
msgstr ""

#: ../../../src/aiida/engine/persistence.py:docstring of aiida.engine.persistence.get_object_loader:1
msgid "Return the global AiiDA object loader."
msgstr ""

#: ../../../src/aiida/engine/persistence.py:docstring of aiida.engine.persistence.get_object_loader:3
msgid "The global object loader"
msgstr ""

#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners:1
msgid "Runners that can run and submit processes."
msgstr ""

#: ../../../src/aiida/engine/processes/exit_code.py:docstring of aiida.engine.processes.exit_code.ExitCode:1
#: ../../../src/aiida/engine/processes/workchains/utils.py:docstring of aiida.engine.processes.workchains.utils.ProcessHandlerReport:1
#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.ResultAndNode:1
#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.ResultAndPk:1
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.Classifier:1
#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links.LinkPair:1
#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links.LinkQuadruple:1
#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links.LinkTriple:1
msgid "Bases: :py:class:`~typing.NamedTuple`"
msgstr ""

#: ../../../src/aiida/engine/runners.py:docstring of namedtuple_ResultAndNode.ResultAndNode.__new__:1
msgid "Create new instance of ResultAndNode(result, node)"
msgstr ""

#: ../../../src/aiida/engine/runners.py:docstring of collections.ResultAndNode._make:1
msgid "Make a new ResultAndNode object from a sequence or iterable"
msgstr ""

#: ../../../src/aiida/engine/runners.py:docstring of collections.ResultAndNode._replace:1
msgid "Return a new ResultAndNode object replacing specified fields with new values"
msgstr ""

#: ../../../src/aiida/engine/runners.py:docstring of namedtuple_ResultAndPk.ResultAndPk.__new__:1
msgid "Create new instance of ResultAndPk(result, pk)"
msgstr ""

#: ../../../src/aiida/engine/runners.py:docstring of collections.ResultAndPk._make:1
msgid "Make a new ResultAndPk object from a sequence or iterable"
msgstr ""

#: ../../../src/aiida/engine/runners.py:docstring of collections.ResultAndPk._replace:1
msgid "Return a new ResultAndPk object replacing specified fields with new values"
msgstr ""

#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner:1
msgid "Class that can launch processes by running in the current interpreter or by submitting them to the daemon."
msgstr ""

#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner.__init__:1
msgid "Construct a new runner."
msgstr ""

#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner.__init__:3
msgid "interval in seconds between polling for status of active sub processes"
msgstr ""

#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner.__init__:4
msgid "an asyncio event loop, if none is suppled a new one will be created"
msgstr ""

#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner.__init__:5
msgid "the communicator to use"
msgstr ""

#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner.__init__:6
msgid "if True, processes will be submitted to RabbitMQ, otherwise they will be scheduled here"
msgstr ""

#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner.__init__:7
msgid "the persister to use to persist processes"
msgstr ""

#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner._poll_process:1
msgid "Check whether the process state of the node is terminated and call the callback or reschedule it."
msgstr ""

#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner._poll_process:3
msgid "the process node"
msgstr ""

#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner._poll_process:4
msgid "callback to be called when process is terminated"
msgstr ""

#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner._run:1
#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner.run:1
#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner.run_get_node:1
#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner.run_get_pk:1
msgid "Run the process with the supplied inputs in this runner that will block until the process is completed."
msgstr ""

#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner._run:3
#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner.run:3
#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner.run_get_node:3
#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner.run_get_pk:3
msgid "The return value will be the results of the completed process"
msgstr ""

#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner._run:7
#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner.run_get_node:7
msgid "tuple of the outputs of the process and the calculation node"
msgstr ""

#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner.call_on_process_finish:1
msgid "Schedule a callback when the process of the given pk is terminated."
msgstr ""

#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner.call_on_process_finish:3
msgid "This method will add a broadcast subscriber that will listen for state changes of the target process to be terminated. As a fail-safe, a polling-mechanism is used to check the state of the process, should the broadcast message be missed by the subscriber, in order to prevent the caller to wait indefinitely."
msgstr ""

#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner.call_on_process_finish:7
msgid "pk of the process"
msgstr ""

#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner.call_on_process_finish:8
msgid "function to be called upon process termination"
msgstr ""

#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner.close:1
msgid "Close the runner by stopping the loop."
msgstr ""

#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner.communicator:1
msgid "Get the communicator used by this runner."
msgstr ""

#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner.controller:1
msgid "Get the controller used by this runner."
msgstr ""

#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner.get_process_future:1
msgid "Return a future for a process."
msgstr ""

#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner.get_process_future:3
msgid "The future will have the process node as the result when finished."
msgstr ""

#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner.get_process_future:5
msgid "A future representing the completion of the process node"
msgstr ""

#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner.is_daemon_runner:1
msgid "Return whether the runner is a daemon runner, which means it submits processes over RabbitMQ."
msgstr ""

#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner.is_daemon_runner:3
msgid "True if the runner is a daemon runner"
msgstr ""

#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner.loop:1
msgid "Get the event loop of this runner."
msgstr ""

#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner.persister:1
msgid "Get the persister used by this runner."
msgstr ""

#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner.run_until_complete:1
msgid "Run the loop until the future has finished and return the result."
msgstr ""

#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner.schedule:1
msgid "Schedule a process to be executed by this runner."
msgstr ""

#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner.schedule:3
#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner.submit:5
msgid "the process class to submit"
msgstr ""

#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner.start:1
msgid "Start the internal event loop."
msgstr ""

#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner.stop:1
msgid "Stop the internal event loop."
msgstr ""

#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner.submit:1
msgid "Submit the process with the supplied inputs to this runner immediately returning control to the interpreter."
msgstr ""

#: ../../../src/aiida/engine/runners.py:docstring of aiida.engine.runners.Runner.submit:3
msgid "The return value will be the calculation node of the submitted process"
msgstr ""

#: ../../../src/aiida/engine/transports.py:docstring of aiida.engine.transports:1
msgid "A transport queue to batch process multiple tasks that require a Transport."
msgstr ""

#: ../../../src/aiida/engine/transports.py:docstring of aiida.engine.transports.TransportQueue:1
msgid "A queue to get transport objects from authinfo.  This class allows clients to register their interest in a transport object which will be provided at some point in the future."
msgstr ""

#: ../../../src/aiida/engine/transports.py:docstring of aiida.engine.transports.TransportQueue:5
msgid "Internally the class will wait for a specific interval at the end of which it will open the transport and give it to all the clients that asked for it up to that point.  This way opening of transports (a costly operation) can be minimised."
msgstr ""

#: ../../../src/aiida/engine/transports.py:docstring of aiida.engine.transports.TransportQueue.__init__:1
msgid "An asyncio event, will use `asyncio.get_event_loop()` if not supplied"
msgstr ""

#: ../../../src/aiida/engine/transports.py:docstring of aiida.engine.transports.TransportQueue.loop:1
msgid "Get the loop being used by this transport queue"
msgstr ""

#: ../../../src/aiida/engine/transports.py:docstring of aiida.engine.transports.TransportQueue.request_transport:1
msgid "Request a transport from an authinfo.  Because the client is not allowed to request a transport immediately they will instead be given back a future that can be awaited to get the transport::"
msgstr ""

#: ../../../src/aiida/engine/transports.py:docstring of aiida.engine.transports.TransportQueue.request_transport:10
msgid "The authinfo to be used to get transport"
msgstr ""

#: ../../../src/aiida/engine/transports.py:docstring of aiida.engine.transports.TransportQueue.request_transport:11
msgid "A future that can be yielded to give the transport"
msgstr ""

#: ../../../src/aiida/engine/transports.py:docstring of aiida.engine.transports.TransportRequest:1
msgid "Information kept about request for a transport object"
msgstr ""

#: ../../../src/aiida/engine/utils.py:docstring of aiida.engine.utils:1
msgid "Utilities for the workflow engine."
msgstr ""

#: ../../../src/aiida/engine/processes/futures.py:docstring of aiida.engine.processes.futures.ProcessFuture:1
#: ../../../src/aiida/engine/utils.py:docstring of aiida.engine.utils.InterruptableFuture:1
msgid "Bases: :py:class:`~_asyncio.Future`"
msgstr ""

#: ../../../src/aiida/engine/utils.py:docstring of aiida.engine.utils.InterruptableFuture:1
msgid "A future that can be interrupted by calling `interrupt`."
msgstr ""

#: ../../../src/aiida/engine/utils.py:docstring of aiida.engine.utils.InterruptableFuture.interrupt:1
msgid "This method should be called to interrupt the coroutine represented by this InterruptableFuture."
msgstr ""

#: ../../../src/aiida/engine/utils.py:docstring of aiida.engine.utils.InterruptableFuture.with_interrupt:1
msgid "Return result of a coroutine which will be interrupted if this future is interrupted ::"
msgstr ""

#: ../../../src/aiida/engine/utils.py:docstring of aiida.engine.utils.InterruptableFuture.with_interrupt:12
msgid "The coroutine that can be interrupted"
msgstr ""

#: ../../../src/aiida/engine/utils.py:docstring of aiida.engine.utils.InterruptableFuture.with_interrupt:13
msgid "The result of the coroutine"
msgstr ""

#: ../../../src/aiida/engine/utils.py:docstring of aiida.engine.utils.ensure_coroutine:1
msgid "Ensure that the given function ``fct`` is a coroutine"
msgstr ""

#: ../../../src/aiida/engine/utils.py:docstring of aiida.engine.utils.ensure_coroutine:3
msgid "If the passed function is not already a coroutine, it will be made to be a coroutine"
msgstr ""

#: ../../../src/aiida/engine/utils.py:docstring of aiida.engine.utils.ensure_coroutine:5
msgid "the function"
msgstr ""

#: ../../../src/aiida/engine/utils.py:docstring of aiida.engine.utils.ensure_coroutine:6
msgid "the coroutine"
msgstr ""

#: ../../../src/aiida/engine/utils.py:docstring of aiida.engine.utils.exponential_backoff_retry:1
msgid "Coroutine to call a function, recalling it with an exponential backoff in the case of an exception"
msgstr ""

#: ../../../src/aiida/engine/utils.py:docstring of aiida.engine.utils.exponential_backoff_retry:3
msgid "This coroutine will loop ``max_attempts`` times, calling the ``fct`` function, breaking immediately when the call finished without raising an exception, at which point the result will be returned. If an exception is caught, the function will await a ``asyncio.sleep`` with a time interval equal to the ``initial_interval`` multiplied by ``2 ** (N - 1)`` where ``N`` is the number of excepted calls."
msgstr ""

#: ../../../src/aiida/engine/utils.py:docstring of aiida.engine.utils.exponential_backoff_retry:8
msgid "the function to call, which will be turned into a coroutine first if it is not already"
msgstr ""

#: ../../../src/aiida/engine/utils.py:docstring of aiida.engine.utils.exponential_backoff_retry:9
msgid "the time to wait after the first caught exception before calling the coroutine again"
msgstr ""

#: ../../../src/aiida/engine/utils.py:docstring of aiida.engine.utils.exponential_backoff_retry:10
msgid "the maximum number of times to call the coroutine before re-raising the exception"
msgstr ""

#: ../../../src/aiida/engine/utils.py:docstring of aiida.engine.utils.exponential_backoff_retry:11
msgid "exceptions to ignore, i.e. when caught do nothing and simply re-raise"
msgstr ""

#: ../../../src/aiida/engine/utils.py:docstring of aiida.engine.utils.exponential_backoff_retry:12
msgid "result if the ``coro`` call completes within ``max_attempts`` retries without raising"
msgstr ""

#: ../../../src/aiida/engine/utils.py:docstring of aiida.engine.utils.get_process_state_change_timestamp:1
msgid "Get the global setting that reflects the last time a process of the given process type changed its state. The returned value will be the corresponding timestamp or None if the setting does not exist."
msgstr ""

#: ../../../src/aiida/engine/utils.py:docstring of aiida.engine.utils.get_process_state_change_timestamp:4
msgid "optional process type for which to get the latest state change timestamp. Valid process types are either 'calculation' or 'work'. If not specified, last timestamp for all known process types will be returned."
msgstr ""

#: ../../../src/aiida/engine/utils.py:docstring of aiida.engine.utils.get_process_state_change_timestamp:7
msgid "a timestamp or None"
msgstr ""

#: ../../../src/aiida/engine/utils.py:docstring of aiida.engine.utils.instantiate_process:1
msgid "Return an instance of the process with the given inputs. The function can deal with various types of the `process`:"
msgstr ""

#: ../../../src/aiida/engine/utils.py:docstring of aiida.engine.utils.instantiate_process:4
msgid "Process instance: will simply return the instance"
msgstr ""

#: ../../../src/aiida/engine/utils.py:docstring of aiida.engine.utils.instantiate_process:5
msgid "ProcessBuilder instance: will instantiate the Process from the class and inputs defined within it"
msgstr ""

#: ../../../src/aiida/engine/utils.py:docstring of aiida.engine.utils.instantiate_process:6
msgid "Process class: will instantiate with the specified inputs"
msgstr ""

#: ../../../src/aiida/engine/utils.py:docstring of aiida.engine.utils.instantiate_process:8
msgid "If anything else is passed, a ValueError will be raised"
msgstr ""

#: ../../../src/aiida/engine/utils.py:docstring of aiida.engine.utils.instantiate_process:10
msgid "Process instance or class, CalcJobNode class or ProcessBuilder instance"
msgstr ""

#: ../../../src/aiida/engine/utils.py:docstring of aiida.engine.utils.instantiate_process:11
msgid "the inputs for the process to be instantiated with"
msgstr ""

#: ../../../src/aiida/engine/utils.py:docstring of aiida.engine.utils.interruptable_task:1
msgid "Turn the given coroutine into an interruptable task by turning it into an InterruptableFuture and returning it."
msgstr ""

#: ../../../src/aiida/engine/utils.py:docstring of aiida.engine.utils.interruptable_task:3
msgid "the coroutine that should be made interruptable with object of InterutableFuture as last paramenter"
msgstr ""

#: ../../../src/aiida/engine/utils.py:docstring of aiida.engine.utils.interruptable_task:4
msgid "the event loop in which to run the coroutine, by default uses asyncio.get_event_loop()"
msgstr ""

#: ../../../src/aiida/engine/utils.py:docstring of aiida.engine.utils.interruptable_task:5
msgid "an InterruptableFuture"
msgstr ""

#: ../../../src/aiida/engine/utils.py:docstring of aiida.engine.utils.is_process_function:1
msgid "Return whether the given function is a process function"
msgstr ""

#: ../../../src/aiida/engine/utils.py:docstring of aiida.engine.utils.is_process_function:3
msgid "a function"
msgstr ""

#: ../../../src/aiida/engine/utils.py:docstring of aiida.engine.utils.is_process_function:4
msgid "True if the function is a wrapped process function, False otherwise"
msgstr ""

#: ../../../src/aiida/engine/utils.py:docstring of aiida.engine.utils.is_process_scoped:1
msgid "Return whether the current scope is within a process."
msgstr ""

#: ../../../src/aiida/engine/utils.py:docstring of aiida.engine.utils.is_process_scoped:3
msgid "True if the current scope is within a nested process, False otherwise"
msgstr ""

#: ../../../src/aiida/engine/utils.py:docstring of aiida.engine.utils.loop_scope:1
msgid "Make an event loop current for the scope of the context"
msgstr ""

#: ../../../src/aiida/engine/utils.py:docstring of aiida.engine.utils.loop_scope:3
msgid "The event loop to make current for the duration of the scope"
msgstr ""

#: ../../../src/aiida/engine/utils.py:docstring of aiida.engine.utils.prepare_inputs:1
msgid "Prepare inputs for launch of a process."
msgstr ""

#: ../../../src/aiida/engine/utils.py:docstring of aiida.engine.utils.prepare_inputs:3
msgid "This is a utility function to pre-process inputs for the process that can be specified both through keyword arguments as well as through the explicit ``inputs`` argument. When both are specified, a ``ValueError`` is raised."
msgstr ""

#: ../../../src/aiida/engine/utils.py:docstring of aiida.engine.utils.prepare_inputs:6
msgid "Inputs dictionary."
msgstr ""

#: ../../../src/aiida/engine/utils.py:docstring of aiida.engine.utils.prepare_inputs:7
msgid "Inputs defined as keyword arguments."
msgstr ""

#: ../../../src/aiida/engine/utils.py:docstring of aiida.engine.utils.prepare_inputs:8
msgid "If both ``kwargs`` and ``inputs`` are defined."
msgstr ""

#: ../../../src/aiida/engine/utils.py:docstring of aiida.engine.utils.prepare_inputs:9
msgid "The dictionary of inputs for the process."
msgstr ""

#: ../../../src/aiida/engine/utils.py:docstring of aiida.engine.utils.set_process_state_change_timestamp:1
msgid "Set the global setting that reflects the last time a process changed state, for the process type of the given process, to the current timestamp. The process type will be determined based on the class of the calculation node it has as its database container."
msgstr ""

#: ../../../src/aiida/engine/utils.py:docstring of aiida.engine.utils.set_process_state_change_timestamp:5
msgid "the Process instance that changed its state"
msgstr ""

#: ../../source/reference/apidoc/aiida.engine.daemon.rst:2
msgid "aiida.engine.daemon package"
msgstr ""

#: ../../../src/aiida/engine/daemon/__init__.py:docstring of aiida.engine.daemon:1
msgid "Module with resources for the daemon."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client:1
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient:1
msgid "Client to interact with the daemon."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.ControllerProtocol:1
msgid "The protocol to use for the controller of the Circus daemon."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.__init__:1
msgid "Construct an instance for a given profile."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.__init__:3
msgid "The profile instance."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient._await_condition:1
msgid "Await a condition to evaluate to ``True`` or raise the exception if the timeout is reached."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient._await_condition:3
msgid "A callable that is waited for to return ``True``."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient._await_condition:4
msgid "Raise this exception if ``condition`` does not return ``True`` after ``timeout`` seconds."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient._await_condition:5
msgid "Wait this number of seconds for ``condition`` to return ``True`` before raising."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient._await_condition:6
msgid "The time in seconds to wait between invocations of ``condition``."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient._await_condition:7
msgid "The exception provided by ``exception`` if timeout is reached."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient._check_pid_file:1
msgid "Check that the daemon's PID file is not stale."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient._check_pid_file:3
msgid "Checks if the PID contained in the circus PID file matches a valid running ``verdi`` process. The PID file is considered stale if any of the following conditions are true:"
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient._check_pid_file:6
msgid "The process with the given PID no longer exists"
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient._check_pid_file:7
msgid "The process name does not match the command of the circus daemon"
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient._check_pid_file:8
msgid "The process username does not match the username of this Python interpreter"
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient._check_pid_file:10
msgid "In the latter two cases, the process with the PID of the PID file exists, but it is very likely that it is not the original process that created the PID file, since the command or user is different, indicating the original process died and the PID was recycled for a new process."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient._check_pid_file:14
msgid "The PID file can got stale if a system is shut down suddenly and so the process is killed but the PID file is not deleted in time. When the `get_daemon_pid()` method is called, an incorrect PID is returned. Alternatively, another process or the user may have meddled with the PID file in some way, corrupting it."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient._check_pid_file:18
msgid "If the PID file is likely to be stale."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient._clean_potentially_stale_pid_file:1
msgid "Check the daemon PID file and delete it if it is likely to be stale."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient._is_pid_file_stale:1
msgid "Return whether the daemon PID file is likely to be stale."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient._is_pid_file_stale:3
msgid "``True`` if the PID file is likely to be stale, ``False`` otherwise."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient._start_daemon:1
msgid "Start the daemon."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient._start_daemon:3
msgid "This will daemonize the current process and put it in the background. It is most likely not what you want to call if you want to start the daemon from the Python API. Instead you probably will want to use the :meth:`aiida.engine.daemon.client.DaemonClient.start_daemon` function instead."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient._start_daemon:7
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.cmd_start_daemon:3
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.start_daemon:3
msgid "Number of daemon workers to start."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient._start_daemon:8
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.cmd_start_daemon:4
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.start_daemon:4
msgid "Whether to launch the subprocess in the background or not."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient._verdi_bin:1
msgid "Return the absolute path to the ``verdi`` binary."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient._verdi_bin:3
msgid "If the path to ``verdi`` could not be found"
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.call_client:1
msgid "Call the client with a specific command."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.call_client:3
msgid "Will check whether the daemon is running first by checking for the pid file. When the pid is found yet the call still fails with a timeout, this means the daemon was actually not running and it was terminated unexpectedly causing the pid file to not be cleaned up properly."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.call_client:7
msgid "Command to call the circus client with."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.call_client:8
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.decrease_workers:4
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.get_client:6
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.get_daemon_info:3
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.get_numprocesses:3
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.get_status:3
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.get_worker_info:3
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.increase_workers:4
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.restart_daemon:4
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.stop_daemon:4
msgid "Optional timeout to set for trying to reach the circus daemon. Default is set on the client upon instantiation taken from the ``daemon.timeout`` config option."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.call_client:10
msgid "The result of the circus client call."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.call_client:11
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.restart_daemon:7
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.stop_daemon:7
msgid "If the daemon is not running or cannot be reached."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.call_client:12
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.restart_daemon:8
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.stop_daemon:8
msgid "If the connection to the daemon timed out."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.call_client:13
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.restart_daemon:9
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.stop_daemon:9
msgid "If the connection to the daemon failed for any other reason."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.cmd_start_daemon:1
msgid "Return the command to start the daemon."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.cmd_start_daemon_worker:1
msgid "Return the command to start a daemon worker process."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.daemon_name:1
msgid "Get the daemon name which is tied to the profile name."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.decrease_workers:1
msgid "Decrease the number of workers."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.decrease_workers:3
msgid "The number of workers to remove."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.decrease_workers:6
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.increase_workers:6
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.restart_daemon:6
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.stop_daemon:6
msgid "The client call response."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.delete_circus_socket_directory:1
msgid "Attempt to delete the directory used to store the circus endpoint sockets."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.delete_circus_socket_directory:3
msgid "Will not raise if the directory does not exist."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.get_available_port:1
msgid "Get an available port from the operating system."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.get_available_port:3
msgid "A currently available port."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.get_circus_port:1
msgid "Retrieve the port for the circus controller, which should be written to the circus port file."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.get_circus_port:3
msgid "If the daemon is running, the port file should exist and contain the port to which the controller is connected. If it cannot be read, a RuntimeError will be thrown. If the daemon is not running, an available port will be requested from the operating system, written to the port file and returned."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.get_circus_port:7
msgid "The port for the circus controller."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.get_circus_socket_directory:1
msgid "Retrieve the absolute path of the directory where the circus sockets are stored."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.get_circus_socket_directory:3
msgid "If the daemon is running, the sockets file should exist and contain the absolute path of the directory that contains the sockets of the circus endpoints. If it cannot be read, a ``RuntimeError`` will be thrown. If the daemon is not running, a temporary directory will be created and its path will be written to the sockets file and returned."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.get_circus_socket_directory:8
msgid "A temporary folder needs to be used for the sockets because UNIX limits the filepath length to 107 bytes. Placing the socket files in the AiiDA config folder might seem like the more logical choice but that folder can be placed in an arbitrarily nested directory, the socket filename will exceed the limit. The solution is therefore to always store them in the temporary directory of the operation system whose base path is typically short enough as to not exceed the limit"
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.get_circus_socket_directory:14
msgid "The absolute path of directory to write the sockets to."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.get_client:1
msgid "Return an instance of the CircusClient."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.get_client:3
msgid "The endpoint is defined by the controller endpoint, which used the port that was written to the port file upon starting of the daemon."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.get_client:8
msgid "CircusClient instance"
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.get_controller_endpoint:1
msgid "Get the endpoint string for the circus controller."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.get_controller_endpoint:3
msgid "For the IPC protocol a profile specific socket will be used, whereas for the TCP protocol an available port will be found and saved in the profile specific port file."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.get_controller_endpoint:6
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.get_pubsub_endpoint:6
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.get_stats_endpoint:6
msgid "The endpoint string."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.get_daemon_info:1
msgid "Get statistics about this daemon itself."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.get_daemon_info:5
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.get_worker_info:5
msgid "The client call response. If successful, will contain 'info' key."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.get_daemon_pid:1
msgid "Get the daemon pid which should be written in the daemon pid file specific to the profile."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.get_daemon_pid:3
msgid "The pid of the circus daemon process or None if not found."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.get_env:1
msgid "Return the environment for this current process."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.get_env:3
msgid "This method is used to pass variables from the environment of the current process to a subprocess that is spawned when the daemon or a daemon worker is started."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.get_env:6
msgid "It replicates the ``PATH``, ``PYTHONPATH` and the ``AIIDA_PATH`` environment variables. The ``PYTHONPATH`` variable ensures that all Python modules that can be imported by the parent process, are also importable by the subprocess. The ``AIIDA_PATH`` variable ensures that the subprocess will use the same AiiDA configuration directory as used by the current process."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.get_ipc_endpoint:1
msgid "Get the ipc endpoint string for a circus daemon endpoint for a given socket."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.get_ipc_endpoint:3
msgid "The circus endpoint for which to return a socket."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.get_ipc_endpoint:4
msgid "The ipc endpoint string."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.get_numprocesses:1
msgid "Get the number of running daemon processes."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.get_numprocesses:5
msgid "The client call response. If successful, will contain 'numprocesses' key."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.get_pubsub_endpoint:1
msgid "Get the endpoint string for the circus pubsub endpoint."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.get_pubsub_endpoint:3
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.get_stats_endpoint:3
msgid "For the IPC protocol a profile specific socket will be used, whereas for the TCP protocol any available port will be used."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.get_stats_endpoint:1
msgid "Get the endpoint string for the circus stats endpoint."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.get_status:1
msgid "Return the status of the daemon."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.get_status:5
msgid "The client call response. If successful, will contain 'pid' key."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.get_tcp_endpoint:1
msgid "Get the tcp endpoint string for a circus daemon endpoint."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.get_tcp_endpoint:3
msgid "If the port is unspecified, the operating system will be asked for a currently available port."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.get_tcp_endpoint:5
msgid "A port to use for the endpoint."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.get_tcp_endpoint:6
msgid "The tcp endpoint string."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.get_worker_info:1
msgid "Get workers statistics for this daemon."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.increase_workers:1
msgid "Increase the number of workers."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.increase_workers:3
msgid "The number of workers to add."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.is_daemon_running:1
msgid "Return whether the daemon is running, which is determined by seeing if the daemon pid file is present."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.is_daemon_running:3
msgid "True if daemon is running, False otherwise."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.restart_daemon:1
msgid "Restart the daemon."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.restart_daemon:3
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.start_daemon:5
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.stop_daemon:3
msgid "Boolean to indicate whether to wait for the result of the command."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.start_daemon:1
msgid "Start the daemon in a sub process running in the background."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.start_daemon:6
msgid "Optional timeout to set for trying to reach the circus daemon after the subprocess has started. Default is set on the client upon instantiation taken from the ``daemon.timeout`` config option."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.start_daemon:8
msgid "If the command to start the daemon subprocess excepts."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.start_daemon:9
msgid "If the daemon starts but then is unresponsive or in an unexpected state."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonClient.stop_daemon:1
msgid "Stop the daemon."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonException:1
msgid "Base class for exceptions related to the daemon."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonNotRunningException:1
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonStalePidException:1
#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonTimeoutException:1
msgid "Bases: :py:class:`~aiida.engine.daemon.client.DaemonException`"
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonNotRunningException:1
msgid "Raised when a connection to the daemon is attempted but it is not running."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonStalePidException:1
msgid "Raised when a connection to the daemon is attempted but it fails and the PID file appears to be stale."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.DaemonTimeoutException:1
msgid "Raised when a connection to the daemon is attempted but it times out."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.get_daemon_client:1
msgid "Return the daemon client for the given profile or the current profile if not specified."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.get_daemon_client:3
msgid "Optional profile name to load."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.get_daemon_client:4
msgid "The daemon client."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.get_daemon_client:6
msgid "if the configuration file cannot be found."
msgstr ""

#: ../../../src/aiida/engine/daemon/client.py:docstring of aiida.engine.daemon.client.get_daemon_client:7
msgid "if the given profile does not exist."
msgstr ""

#: ../../../src/aiida/engine/daemon/execmanager.py:docstring of aiida.engine.daemon.execmanager:1
msgid "This file contains the main routines to submit, check and retrieve calculation results. These are general and contain only the main logic; where appropriate, the routines make reference to the suitable plugins for all plugin-specific operations."
msgstr ""

#: ../../../src/aiida/engine/daemon/execmanager.py:docstring of aiida.engine.daemon.execmanager._find_data_node:1
msgid "Find and return the node with the given UUID from a nested mapping of input nodes."
msgstr ""

#: ../../../src/aiida/engine/daemon/execmanager.py:docstring of aiida.engine.daemon.execmanager._find_data_node:3
msgid "(nested) mapping of nodes"
msgstr ""

#: ../../../src/aiida/engine/daemon/execmanager.py:docstring of aiida.engine.daemon.execmanager._find_data_node:4
msgid "UUID of the node to find"
msgstr ""

#: ../../../src/aiida/engine/daemon/execmanager.py:docstring of aiida.engine.daemon.execmanager._find_data_node:5
msgid "instance of `Node` or `None` if not found"
msgstr ""

#: ../../../src/aiida/engine/daemon/execmanager.py:docstring of aiida.engine.daemon.execmanager.kill_calculation:1
msgid "Kill the calculation through the scheduler"
msgstr ""

#: ../../../src/aiida/engine/daemon/execmanager.py:docstring of aiida.engine.daemon.execmanager.kill_calculation:3
msgid "the instance of CalcJobNode to kill."
msgstr ""

#: ../../../src/aiida/engine/daemon/execmanager.py:docstring of aiida.engine.daemon.execmanager.kill_calculation:4
msgid "an already opened transport to use to address the scheduler"
msgstr ""

#: ../../../src/aiida/engine/daemon/execmanager.py:docstring of aiida.engine.daemon.execmanager.retrieve_calculation:1
msgid "Retrieve all the files of a completed job calculation using the given transport."
msgstr ""

#: ../../../src/aiida/engine/daemon/execmanager.py:docstring of aiida.engine.daemon.execmanager.retrieve_calculation:3
msgid "If the job defined anything in the `retrieve_temporary_list`, those entries will be stored in the `retrieved_temporary_folder`. The caller is responsible for creating and destroying this folder."
msgstr ""

#: ../../../src/aiida/engine/daemon/execmanager.py:docstring of aiida.engine.daemon.execmanager.retrieve_calculation:6
msgid "the instance of CalcJobNode to update."
msgstr ""

#: ../../../src/aiida/engine/daemon/execmanager.py:docstring of aiida.engine.daemon.execmanager.retrieve_calculation:7
msgid "an already opened transport to use for the retrieval."
msgstr ""

#: ../../../src/aiida/engine/daemon/execmanager.py:docstring of aiida.engine.daemon.execmanager.retrieve_calculation:8
msgid "the absolute path to a directory in which to store the files listed, if any, in the `retrieved_temporary_folder` of the jobs CalcInfo"
msgstr ""

#: ../../../src/aiida/engine/daemon/execmanager.py:docstring of aiida.engine.daemon.execmanager.retrieve_files_from_list:1
msgid "Retrieve all the files in the retrieve_list from the remote into the local folder instance through the transport. The entries in the retrieve_list can be of two types:"
msgstr ""

#: ../../../src/aiida/engine/daemon/execmanager.py:docstring of aiida.engine.daemon.execmanager.retrieve_files_from_list:5
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.Kind.name:4
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.get_formula_from_symbol_list:12
msgid "a string"
msgstr ""

#: ../../../src/aiida/engine/daemon/execmanager.py:docstring of aiida.engine.daemon.execmanager.retrieve_files_from_list:6
#: ../../../src/aiida/orm/nodes/data/list.py:docstring of aiida.orm.nodes.data.list.List.get_list:3
msgid "a list"
msgstr ""

#: ../../../src/aiida/engine/daemon/execmanager.py:docstring of aiida.engine.daemon.execmanager.retrieve_files_from_list:8
msgid "If it is a string, it represents the remote absolute filepath of the file. If the item is a list, the elements will correspond to the following:"
msgstr ""

#: ../../../src/aiida/engine/daemon/execmanager.py:docstring of aiida.engine.daemon.execmanager.retrieve_files_from_list:11
msgid "remotepath"
msgstr ""

#: ../../../src/aiida/engine/daemon/execmanager.py:docstring of aiida.engine.daemon.execmanager.retrieve_files_from_list:12
msgid "localpath"
msgstr ""

#: ../../../src/aiida/engine/daemon/execmanager.py:docstring of aiida.engine.daemon.execmanager.retrieve_files_from_list:13
msgid "depth"
msgstr ""

#: ../../../src/aiida/engine/daemon/execmanager.py:docstring of aiida.engine.daemon.execmanager.retrieve_files_from_list:15
msgid "If the remotepath contains file patterns with wildcards, the localpath will be treated as the work directory of the folder and the depth integer determines upto what level of the original remotepath nesting the files will be copied."
msgstr ""

#: ../../../src/aiida/engine/daemon/execmanager.py:docstring of aiida.engine.daemon.execmanager.retrieve_files_from_list:19
msgid "the Transport instance."
msgstr ""

#: ../../../src/aiida/engine/daemon/execmanager.py:docstring of aiida.engine.daemon.execmanager.retrieve_files_from_list:20
msgid "an absolute path to a folder that contains the files to copy."
msgstr ""

#: ../../../src/aiida/engine/daemon/execmanager.py:docstring of aiida.engine.daemon.execmanager.retrieve_files_from_list:21
msgid "the list of files to retrieve."
msgstr ""

#: ../../../src/aiida/engine/daemon/execmanager.py:docstring of aiida.engine.daemon.execmanager.stash_calculation:1
msgid "Stash files from the working directory of a completed calculation to a permanent remote folder."
msgstr ""

#: ../../../src/aiida/engine/daemon/execmanager.py:docstring of aiida.engine.daemon.execmanager.stash_calculation:3
msgid "After a calculation has been completed, optionally stash files from the work directory to a storage location on the same remote machine. This is useful if one wants to keep certain files from a completed calculation to be removed from the scratch directory, because they are necessary for restarts, but that are too heavy to retrieve. Instructions of which files to copy where are retrieved from the `stash.source_list` option."
msgstr ""

#: ../../../src/aiida/engine/daemon/execmanager.py:docstring of aiida.engine.daemon.execmanager.stash_calculation:8
msgid "the calculation job node."
msgstr ""

#: ../../../src/aiida/engine/daemon/execmanager.py:docstring of aiida.engine.daemon.execmanager.stash_calculation:9
msgid "an already opened transport."
msgstr ""

#: ../../../src/aiida/engine/daemon/execmanager.py:docstring of aiida.engine.daemon.execmanager.submit_calculation:1
msgid "Submit a previously uploaded `CalcJob` to the scheduler."
msgstr ""

#: ../../../src/aiida/engine/daemon/execmanager.py:docstring of aiida.engine.daemon.execmanager.submit_calculation:3
msgid "the instance of CalcJobNode to submit."
msgstr ""

#: ../../../src/aiida/engine/daemon/execmanager.py:docstring of aiida.engine.daemon.execmanager.submit_calculation:4
#: ../../../src/aiida/engine/daemon/execmanager.py:docstring of aiida.engine.daemon.execmanager.upload_calculation:4
msgid "an already opened transport to use to submit the calculation."
msgstr ""

#: ../../../src/aiida/engine/daemon/execmanager.py:docstring of aiida.engine.daemon.execmanager.submit_calculation:5
msgid "the job id as returned by the scheduler `submit_from_script` call"
msgstr ""

#: ../../../src/aiida/engine/daemon/execmanager.py:docstring of aiida.engine.daemon.execmanager.upload_calculation:1
msgid "Upload a `CalcJob` instance"
msgstr ""

#: ../../../src/aiida/engine/daemon/execmanager.py:docstring of aiida.engine.daemon.execmanager.upload_calculation:3
msgid "the `CalcJobNode`."
msgstr ""

#: ../../../src/aiida/engine/daemon/execmanager.py:docstring of aiida.engine.daemon.execmanager.upload_calculation:5
msgid "the calculation info datastructure returned by `CalcJob.presubmit`"
msgstr ""

#: ../../../src/aiida/engine/daemon/execmanager.py:docstring of aiida.engine.daemon.execmanager.upload_calculation:6
msgid "temporary local file system folder containing the inputs written by `CalcJob.prepare_for_submission`"
msgstr ""

#: ../../../src/aiida/engine/daemon/worker.py:docstring of aiida.engine.daemon.worker:1
msgid "Function that starts a daemon worker."
msgstr ""

#: ../../../src/aiida/engine/daemon/worker.py:docstring of aiida.engine.daemon.worker.shutdown_worker:1
msgid "Cleanup tasks tied to the service's shutdown."
msgstr ""

#: ../../../src/aiida/engine/daemon/worker.py:docstring of aiida.engine.daemon.worker.start_daemon_worker:1
msgid "Start a daemon worker for the currently configured profile."
msgstr ""

#: ../../source/reference/apidoc/aiida.engine.processes.rst:2
msgid "aiida.engine.processes package"
msgstr ""

#: ../../../src/aiida/engine/processes/__init__.py:docstring of aiida.engine.processes:1
msgid "Module for processes and related utilities."
msgstr ""

#: ../../../src/aiida/engine/processes/builder.py:docstring of aiida.engine.processes.builder:1
msgid "Convenience classes to help building the input dictionaries for Processes."
msgstr ""

#: ../../../src/aiida/engine/processes/builder.py:docstring of aiida.engine.processes.builder.PrettyEncoder:1
msgid "Bases: :py:class:`~json.encoder.JSONEncoder`"
msgstr ""

#: ../../../src/aiida/engine/processes/builder.py:docstring of aiida.engine.processes.builder.PrettyEncoder:1
msgid "JSON encoder for returning a pretty representation of an AiiDA ``ProcessBuilder``."
msgstr ""

#: ../../../src/aiida/engine/processes/builder.py:docstring of aiida.engine.processes.builder.PrettyEncoder.default:1
msgid "Implement this method in a subclass such that it returns a serializable object for ``o``, or calls the base implementation (to raise a ``TypeError``)."
msgstr ""

#: ../../../src/aiida/engine/processes/builder.py:docstring of aiida.engine.processes.builder.PrettyEncoder.default:5
msgid "For example, to support arbitrary iterators, you could implement default like this::"
msgstr ""

#: ../../../src/aiida/engine/processes/builder.py:docstring of aiida.engine.processes.builder.ProcessBuilder:1
msgid "Bases: :py:class:`~aiida.engine.processes.builder.ProcessBuilderNamespace`"
msgstr ""

#: ../../../src/aiida/engine/processes/builder.py:docstring of aiida.engine.processes.builder.ProcessBuilder:1
msgid "A process builder that helps setting up the inputs for creating a new process."
msgstr ""

#: ../../../src/aiida/engine/processes/builder.py:docstring of aiida.engine.processes.builder.ProcessBuilder.__init__:1
msgid "Construct a `ProcessBuilder` instance for the given `Process` class."
msgstr ""

#: ../../../src/aiida/engine/processes/builder.py:docstring of aiida.engine.processes.builder.ProcessBuilder.__init__:3
msgid "the `Process` subclass"
msgstr ""

#: ../../../src/aiida/engine/processes/builder.py:docstring of aiida.engine.processes.builder.ProcessBuilder._repr_pretty_:1
msgid "Pretty representation for in the IPython console and notebooks."
msgstr ""

#: ../../../src/aiida/engine/processes/builder.py:docstring of aiida.engine.processes.builder.ProcessBuilder.process_class:1
msgid "Return the process class for which this builder is constructed."
msgstr ""

#: ../../../src/aiida/engine/processes/builder.py:docstring of aiida.engine.processes.builder.ProcessBuilderNamespace:1
#: ../../../src/aiida/restapi/common/identifiers.py:docstring of aiida.restapi.common.identifiers.Namespace:1
msgid "Bases: :py:class:`~collections.abc.MutableMapping`"
msgstr ""

#: ../../../src/aiida/engine/processes/builder.py:docstring of aiida.engine.processes.builder.ProcessBuilderNamespace:1
msgid "Input namespace for the `ProcessBuilder`."
msgstr ""

#: ../../../src/aiida/engine/processes/builder.py:docstring of aiida.engine.processes.builder.ProcessBuilderNamespace:3
msgid "Dynamically generates the getters and setters for the input ports of a given PortNamespace"
msgstr ""

#: ../../../src/aiida/engine/processes/builder.py:docstring of aiida.engine.processes.builder.ProcessBuilderNamespace.__delattr__:1
msgid "Implement delattr(self, name)."
msgstr ""

#: ../../../src/aiida/engine/processes/builder.py:docstring of aiida.engine.processes.builder.ProcessBuilderNamespace.__init__:1
msgid "Dynamically construct the get and set properties for the ports of the given port namespace."
msgstr ""

#: ../../../src/aiida/engine/processes/builder.py:docstring of aiida.engine.processes.builder.ProcessBuilderNamespace.__init__:3
msgid "For each port in the given port namespace a get and set property will be constructed dynamically and added to the ProcessBuilderNamespace. The docstring for these properties will be defined by calling str() on the Port, which should return the description of the Port."
msgstr ""

#: ../../../src/aiida/engine/processes/builder.py:docstring of aiida.engine.processes.builder.ProcessBuilderNamespace.__init__:7
msgid "the inputs PortNamespace for which to construct the builder"
msgstr ""

#: ../../../src/aiida/engine/processes/builder.py:docstring of aiida.engine.processes.builder.ProcessBuilderNamespace.__setattr__:1
msgid "Assign the given value to the port with key `attr`."
msgstr ""

#: ../../../src/aiida/engine/processes/builder.py:docstring of aiida.engine.processes.builder.ProcessBuilderNamespace.__setattr__:3
msgid "Any attributes without a leading underscore being set correspond to inputs and should hence be validated with respect to the corresponding input port from the process spec"
msgstr ""

#: ../../../src/aiida/engine/processes/builder.py:docstring of aiida.engine.processes.builder.ProcessBuilderNamespace._inputs:1
msgid "Return the entire mapping of inputs specified for this builder."
msgstr ""

#: ../../../src/aiida/engine/processes/builder.py:docstring of aiida.engine.processes.builder.ProcessBuilderNamespace._inputs:3
msgid "boolean, when True, will prune nested namespaces that contain no actual values whatsoever"
msgstr ""

#: ../../../src/aiida/engine/processes/builder.py:docstring of aiida.engine.processes.builder.ProcessBuilderNamespace._inputs:4
msgid "mapping of inputs ports and their input values."
msgstr ""

#: ../../../src/aiida/engine/processes/builder.py:docstring of aiida.engine.processes.builder.ProcessBuilderNamespace._merge:1
msgid "Merge the content of a dictionary or keyword arguments in ."
msgstr ""

#: ../../../src/aiida/engine/processes/builder.py:docstring of aiida.engine.processes.builder.ProcessBuilderNamespace._merge:3
msgid "This method differs in behavior from ``_update`` in that ``_merge`` will recursively update the existing dictionary with the one that is specified in the arguments. The ``_update`` method will merge only the keys on the top level, but any lower lying nested namespace will be replaced entirely."
msgstr ""

#: ../../../src/aiida/engine/processes/builder.py:docstring of aiida.engine.processes.builder.ProcessBuilderNamespace._merge:7
msgid "The method is prefixed with an underscore in order to not reserve the name for a potential port."
msgstr ""

#: ../../../src/aiida/engine/processes/builder.py:docstring of aiida.engine.processes.builder.ProcessBuilderNamespace._merge:9
#: ../../../src/aiida/engine/processes/builder.py:docstring of aiida.engine.processes.builder.ProcessBuilderNamespace._update:6
msgid "a single mapping that should be mapped on the namespace."
msgstr ""

#: ../../../src/aiida/engine/processes/builder.py:docstring of aiida.engine.processes.builder.ProcessBuilderNamespace._merge:10
#: ../../../src/aiida/engine/processes/builder.py:docstring of aiida.engine.processes.builder.ProcessBuilderNamespace._update:7
msgid "keyword value pairs that should be mapped onto the ports."
msgstr ""

#: ../../../src/aiida/engine/processes/builder.py:docstring of aiida.engine.processes.builder.ProcessBuilderNamespace._recursive_merge:1
msgid "Recursively merge the contents of ``dictionary`` setting its ``key`` to ``value``."
msgstr ""

#: ../../../src/aiida/engine/processes/builder.py:docstring of aiida.engine.processes.builder.ProcessBuilderNamespace._update:1
msgid "Update the values of the builder namespace passing a mapping as argument or individual keyword value pairs."
msgstr ""

#: ../../../src/aiida/engine/processes/builder.py:docstring of aiida.engine.processes.builder.ProcessBuilderNamespace._update:3
msgid "The method functions just as `collections.abc.MutableMapping.update` and is merely prefixed with an underscore in order to not reserve the name for a potential port."
msgstr ""

#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control:1
msgid "Functions to control and interact with running processes."
msgstr ""

#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control.ProcessTimeoutException:1
msgid "Raised when action to communicate with a process times out."
msgstr ""

#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control._perform_actions:1
msgid "Perform an action on a list of processes."
msgstr ""

#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control._perform_actions:3
msgid "The list of processes to perform the action on."
msgstr ""

#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control._perform_actions:4
msgid "The action to perform."
msgstr ""

#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control._perform_actions:5
msgid "The infinitive of the verb that represents the action."
msgstr ""

#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control._perform_actions:6
msgid "The present tense of the verb that represents the action."
msgstr ""

#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control._perform_actions:7
msgid "The past tense of the verb that represents the action."
msgstr ""

#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control._perform_actions:8
#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control._resolve_futures:11
#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control.kill_processes:7
#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control.pause_processes:7
#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control.play_processes:7
msgid "Raise a ``ProcessTimeoutException`` if the process does not respond within this amount of seconds."
msgstr ""

#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control._perform_actions:9
#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control._resolve_futures:10
#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control.kill_processes:8
#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control.pause_processes:8
#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control.play_processes:8
msgid "Set to ``True`` to wait for process response, for ``False`` the action is fire-and-forget."
msgstr ""

#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control._perform_actions:10
msgid "Keyword arguments that will be passed to the method ``action``."
msgstr ""

#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control._perform_actions:11
#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control.kill_processes:9
#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control.pause_processes:9
#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control.play_processes:9
msgid "If the processes do not respond within the timeout."
msgstr ""

#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control._resolve_futures:1
msgid "Process a mapping of futures representing an action on an active process."
msgstr ""

#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control._resolve_futures:3
msgid "This function will echo the correct information strings based on the outcomes of the futures and the given verb conjugations. You can optionally wait for any pending actions to be completed before the functions returns and use a timeout to put a maximum wait time on the actions."
msgstr ""

#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control._resolve_futures:7
msgid "The map of action futures and the corresponding processes."
msgstr ""

#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control._resolve_futures:8
msgid "The infinitive form of the action verb."
msgstr ""

#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control._resolve_futures:9
msgid "The present tense form of the action verb."
msgstr ""

#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control.get_active_processes:1
msgid "Return all active processes, i.e., those with a process state of created, waiting or running."
msgstr ""

#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control.get_active_processes:3
#: ../../../src/aiida/tools/query/calculation.py:docstring of aiida.tools.query.calculation.CalculationQueryBuilder.get_filters:7
msgid "Boolean, if True, filter for processes that are paused."
msgstr ""

#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control.get_active_processes:4
msgid "Single or list of properties to project. By default projects the entire node."
msgstr ""

#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control.get_active_processes:5
msgid "A list of process nodes of active processes."
msgstr ""

#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control.get_process_tasks:1
#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control.iterate_process_tasks:1
msgid "Return the list of process pks that have a process task in the RabbitMQ process queue."
msgstr ""

#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control.get_process_tasks:3
#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control.iterate_process_tasks:3
msgid "A list of process pks that have a corresponding process task with RabbitMQ."
msgstr ""

#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control.kill_processes:1
msgid "Kill running processes."
msgstr ""

#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control.kill_processes:3
#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control.pause_processes:3
#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control.play_processes:3
msgid "Requires the daemon to be running, or processes will be unresponsive."
msgstr ""

#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control.kill_processes:5
#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control.pause_processes:5
#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control.play_processes:5
msgid "List of processes to play."
msgstr ""

#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control.kill_processes:6
msgid "Kill all active processes."
msgstr ""

#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control.pause_processes:1
msgid "Pause running processes."
msgstr ""

#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control.pause_processes:6
msgid "Pause all playing processes."
msgstr ""

#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control.play_processes:1
msgid "Play (unpause) paused processes."
msgstr ""

#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control.play_processes:6
msgid "Play all paused processes."
msgstr ""

#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control.revive_processes:1
msgid "Revive processes that seem stuck and are no longer reachable."
msgstr ""

#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control.revive_processes:3
msgid "Warning: Use only as a last resort after you've gone through the checklist below."
msgstr ""

#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control.revive_processes:5
msgid "Does ``verdi status`` indicate that both daemon and RabbitMQ are running properly? If not, restart the daemon with ``verdi daemon restart --reset`` and restart RabbitMQ."
msgstr ""

#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control.revive_processes:7
msgid "Try to play the process through ``play_processes``. If a ``ProcessTimeoutException`` is raised use this method to attempt to revive it."
msgstr ""

#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control.revive_processes:10
msgid "Details: When RabbitMQ loses the process task before the process has completed, the process is never picked up by the daemon and will remain \"stuck\". This method recreates the task, which can lead to multiple instances of the task being executed and should thus be used with caution."
msgstr ""

#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control.revive_processes:14
msgid "Requires the daemon to be running."
msgstr ""

#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control.revive_processes:16
msgid "List of processes to revive."
msgstr ""

#: ../../../src/aiida/engine/processes/control.py:docstring of aiida.engine.processes.control.revive_processes:17
msgid "Set to ``True`` to wait for a response, for ``False`` the action is fire-and-forget."
msgstr ""

#: ../../../src/aiida/engine/processes/exit_code.py:docstring of aiida.engine.processes.exit_code:1
msgid "A namedtuple and namespace for ExitCodes that can be used to exit from Processes."
msgstr ""

#: ../../../src/aiida/engine/processes/exit_code.py:docstring of aiida.engine.processes.exit_code.ExitCode:1
msgid "A simple data class to define an exit code for a :class:`~aiida.engine.processes.process.Process`."
msgstr ""

#: ../../../src/aiida/engine/processes/exit_code.py:docstring of aiida.engine.processes.exit_code.ExitCode:3
msgid "When an instance of this class is returned from a `Process._run()` call, it will be interpreted that the `Process` should be terminated and that the exit status and message of the namedtuple should be set to the corresponding attributes of the node."
msgstr ""

#: ../../../src/aiida/engine/processes/exit_code.py:docstring of aiida.engine.processes.exit_code.ExitCode:7
msgid "positive integer exit status, where a non-zero value indicated the process failed, default is `0`"
msgstr ""

#: ../../../src/aiida/engine/processes/exit_code.py:docstring of aiida.engine.processes.exit_code.ExitCode:8
msgid "optional message with more details about the failure mode"
msgstr ""

#: ../../../src/aiida/engine/processes/exit_code.py:docstring of aiida.engine.processes.exit_code.ExitCode:9
msgid "optional flag, indicating that a process should not be used in caching"
msgstr ""

#: ../../../src/aiida/engine/processes/exit_code.py:docstring of namedtuple_ExitCode.ExitCode.__new__:1
msgid "Create new instance of ExitCode(status, message, invalidates_cache)"
msgstr ""

#: ../../../src/aiida/engine/processes/exit_code.py:docstring of collections.ExitCode._make:1
msgid "Make a new ExitCode object from a sequence or iterable"
msgstr ""

#: ../../../src/aiida/engine/processes/exit_code.py:docstring of collections.ExitCode._replace:1
msgid "Return a new ExitCode object replacing specified fields with new values"
msgstr ""

#: ../../../src/aiida/engine/processes/exit_code.py:docstring of aiida.engine.processes.exit_code.ExitCode.format:1
msgid "Create a clone of this exit code where the template message is replaced by the keyword arguments."
msgstr ""

#: ../../../src/aiida/engine/processes/exit_code.py:docstring of aiida.engine.processes.exit_code.ExitCode.format:3
msgid "replacement parameters for the template message"
msgstr ""

#: ../../../src/aiida/engine/processes/exit_code.py:docstring of aiida.engine.processes.exit_code.ExitCodesNamespace:1
msgid "A namespace of `ExitCode` instances that can be accessed through getattr as well as getitem."
msgstr ""

#: ../../../src/aiida/engine/processes/exit_code.py:docstring of aiida.engine.processes.exit_code.ExitCodesNamespace:3
msgid "Additionally, the collection can be called with an identifier, that can either reference the integer `status` of the `ExitCode` that needs to be retrieved or the key in the collection."
msgstr ""

#: ../../../src/aiida/engine/processes/exit_code.py:docstring of aiida.engine.processes.exit_code.ExitCodesNamespace.__call__:1
msgid "Return a specific exit code identified by either its exit status or label."
msgstr ""

#: ../../../src/aiida/engine/processes/exit_code.py:docstring of aiida.engine.processes.exit_code.ExitCodesNamespace.__call__:3
msgid "the identifier of the exit code. If the type is integer, it will be interpreted as the exit code status, otherwise it be interpreted as the exit code label"
msgstr ""

#: ../../../src/aiida/engine/processes/exit_code.py:docstring of aiida.engine.processes.exit_code.ExitCodesNamespace.__call__:6
msgid "an `ExitCode` instance"
msgstr ""

#: ../../../src/aiida/engine/processes/exit_code.py:docstring of aiida.engine.processes.exit_code.ExitCodesNamespace.__call__:8
msgid "if no exit code with the given label is defined for this process"
msgstr ""

#: ../../../src/aiida/engine/processes/functions.py:docstring of aiida.engine.processes.functions:1
msgid "Class and decorators to generate processes out of simple python functions."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.CalcJob:1
#: ../../../src/aiida/engine/processes/functions.py:docstring of aiida.engine.processes.functions.FunctionProcess:1
#: ../../../src/aiida/engine/processes/workchains/workchain.py:docstring of aiida.engine.processes.workchains.workchain.WorkChain:1
msgid "Bases: :py:class:`~aiida.engine.processes.process.Process`"
msgstr ""

#: ../../../src/aiida/engine/processes/functions.py:docstring of aiida.engine.processes.functions.FunctionProcess:1
msgid "Function process class used for turning functions into a Process"
msgstr ""

#: ../../../src/aiida/engine/processes/functions.py:docstring of aiida.engine.processes.functions.FunctionProcess.__init__:1
#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.__init__:1
msgid "Process constructor."
msgstr ""

#: ../../../src/aiida/engine/processes/functions.py:docstring of aiida.engine.processes.functions.FunctionProcess.__init__:3
#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.__init__:3
msgid "process inputs"
msgstr ""

#: ../../../src/aiida/engine/processes/functions.py:docstring of aiida.engine.processes.functions.FunctionProcess.__init__:4
#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.__init__:4
#: ../../../src/aiida/engine/processes/workchains/workchain.py:docstring of aiida.engine.processes.workchains.workchain.WorkChain.__init__:6
msgid "aiida logger"
msgstr ""

#: ../../../src/aiida/engine/processes/functions.py:docstring of aiida.engine.processes.functions.FunctionProcess.__init__:5
#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.__init__:5
msgid "process runner"
msgstr ""

#: ../../../src/aiida/engine/processes/functions.py:docstring of aiida.engine.processes.functions.FunctionProcess.__init__:6
#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.__init__:6
msgid "id of parent process"
msgstr ""

#: ../../../src/aiida/engine/processes/functions.py:docstring of aiida.engine.processes.functions.FunctionProcess.__init__:7
#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.__init__:7
msgid "whether to persist this process"
msgstr ""

#: ../../../src/aiida/engine/processes/functions.py:docstring of aiida.engine.processes.functions.FunctionProcess._func:1
msgid "This is used internally to store the actual function that is being wrapped and will be replaced by the build method."
msgstr ""

#: ../../../src/aiida/engine/processes/functions.py:docstring of aiida.engine.processes.functions.FunctionProcess._setup_db_record:1
msgid "Set up the database record for the process."
msgstr ""

#: ../../../src/aiida/engine/processes/functions.py:docstring of aiida.engine.processes.functions.FunctionProcess.build:1
msgid "Build a Process from the given function."
msgstr ""

#: ../../../src/aiida/engine/processes/functions.py:docstring of aiida.engine.processes.functions.FunctionProcess.build:3
msgid "All function arguments will be assigned as process inputs. If keyword arguments are specified then these will also become inputs."
msgstr ""

#: ../../../src/aiida/engine/processes/functions.py:docstring of aiida.engine.processes.functions.FunctionProcess.build:6
msgid "The function to build a process from"
msgstr ""

#: ../../../src/aiida/engine/processes/functions.py:docstring of aiida.engine.processes.functions.FunctionProcess.build:7
msgid "Provide a custom node class to be used, has to be constructable with no arguments. It has to be a sub class of `ProcessNode` and the mixin :class:`~aiida.orm.utils.mixins.FunctionCalculationMixin`."
msgstr ""

#: ../../../src/aiida/engine/processes/functions.py:docstring of aiida.engine.processes.functions.FunctionProcess.build:10
#: ../../../src/aiida/engine/processes/functions.py:docstring of aiida.engine.processes.functions.FunctionProcess.process_class:7
msgid "A Process class that represents the function"
msgstr ""

#: ../../../src/aiida/engine/processes/functions.py:docstring of aiida.engine.processes.functions.FunctionProcess.create_inputs:1
msgid "Create the input dictionary for the ``FunctionProcess``."
msgstr ""

#: ../../../src/aiida/engine/processes/functions.py:docstring of aiida.engine.processes.functions.FunctionProcess.execute:1
msgid "Execute the process."
msgstr ""

#: ../../../src/aiida/engine/processes/functions.py:docstring of aiida.engine.processes.functions.FunctionProcess.get_or_create_db_record:1
#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.get_or_create_db_record:1
msgid "Create a process node that represents what happened in this process."
msgstr ""

#: ../../../src/aiida/engine/processes/functions.py:docstring of aiida.engine.processes.functions.FunctionProcess.get_or_create_db_record:3
#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.get_or_create_db_record:3
msgid "A process node"
msgstr ""

#: ../../../src/aiida/engine/processes/functions.py:docstring of aiida.engine.processes.functions.FunctionProcess.process_class:1
msgid "Return the class that represents this Process, for the FunctionProcess this is the function itself."
msgstr ""

#: ../../../src/aiida/engine/processes/functions.py:docstring of aiida.engine.processes.functions.FunctionProcess.process_class:3
msgid "For a standard Process or sub class of Process, this is the class itself. However, for legacy reasons, the Process class is a wrapper around another class. This function returns that original class, i.e. the class that really represents what was being executed."
msgstr ""

#: ../../../src/aiida/engine/processes/functions.py:docstring of aiida.engine.processes.functions.FunctionProcess.run:1
msgid "Run the process."
msgstr ""

#: ../../../src/aiida/engine/processes/functions.py:docstring of aiida.engine.processes.functions.FunctionProcess.validate_inputs:1
msgid "Validate the positional and keyword arguments passed in the function call."
msgstr ""

#: ../../../src/aiida/engine/processes/functions.py:docstring of aiida.engine.processes.functions.FunctionProcess.validate_inputs:3
msgid "if more positional arguments are passed than the function defines"
msgstr ""

#: ../../../src/aiida/engine/processes/functions.py:docstring of aiida.engine.processes.functions.ProcessFunctionType:1
msgid "Bases: :py:class:`~typing.Protocol`, :py:class:`~typing.Generic`\\ [:py:obj:`~aiida.engine.processes.functions.P`, :py:obj:`~aiida.engine.processes.functions.R_co`, :py:obj:`~aiida.engine.processes.functions.N`]"
msgstr ""

#: ../../../src/aiida/engine/processes/functions.py:docstring of aiida.engine.processes.functions.ProcessFunctionType:1
msgid "Protocol for a decorated process function."
msgstr ""

#: ../../../src/aiida/engine/processes/functions.py:docstring of aiida.engine.processes.functions.ProcessFunctionType.__call__:1
#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.LinkStyleFunc.__call__:1
msgid "Call self as a function."
msgstr ""

#: ../../../src/aiida/engine/processes/functions.py:docstring of typing.Protocol.__init_subclass__.<locals>._proto_hook:1
#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of typing.Protocol.__init_subclass__.<locals>._proto_hook:1
#: ../../../src/aiida/orm/implementation/groups.py:docstring of typing.Protocol.__init_subclass__.<locals>._proto_hook:1
#: ../../../src/aiida/orm/nodes/data/jsonable.py:docstring of typing.Protocol.__init_subclass__.<locals>._proto_hook:1
#: ../../../src/aiida/orm/utils/serialize.py:docstring of typing.Protocol.__init_subclass__.<locals>._proto_hook:1
#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of typing.Protocol.__init_subclass__.<locals>._proto_hook:1
#: ../../../src/aiida/tools/visualization/graph.py:docstring of typing.Protocol.__init_subclass__.<locals>._proto_hook:1
msgid "Abstract classes can override this to customize issubclass()."
msgstr ""

#: ../../../src/aiida/engine/processes/functions.py:docstring of typing.Protocol.__init_subclass__.<locals>._proto_hook:3
#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of typing.Protocol.__init_subclass__.<locals>._proto_hook:3
#: ../../../src/aiida/orm/implementation/groups.py:docstring of typing.Protocol.__init_subclass__.<locals>._proto_hook:3
#: ../../../src/aiida/orm/nodes/data/jsonable.py:docstring of typing.Protocol.__init_subclass__.<locals>._proto_hook:3
#: ../../../src/aiida/orm/utils/serialize.py:docstring of typing.Protocol.__init_subclass__.<locals>._proto_hook:3
#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of typing.Protocol.__init_subclass__.<locals>._proto_hook:3
#: ../../../src/aiida/tools/visualization/graph.py:docstring of typing.Protocol.__init_subclass__.<locals>._proto_hook:3
msgid "This is invoked early on by abc.ABCMeta.__subclasscheck__(). It should return True, False or NotImplemented.  If it returns NotImplemented, the normal algorithm is used.  Otherwise, it overrides the normal algorithm (and the outcome is cached)."
msgstr ""

#: ../../../src/aiida/engine/processes/functions.py:docstring of aiida.engine.processes.functions.calcfunction:1
msgid "A decorator to turn a standard python function into a calcfunction. Example usage:"
msgstr ""

#: ../../../src/aiida/engine/processes/functions.py:docstring of aiida.engine.processes.functions.calcfunction:20
#: ../../../src/aiida/engine/processes/functions.py:docstring of aiida.engine.processes.functions.workfunction:20
msgid "The function to decorate."
msgstr ""

#: ../../../src/aiida/engine/processes/functions.py:docstring of aiida.engine.processes.functions.calcfunction:21
#: ../../../src/aiida/engine/processes/functions.py:docstring of aiida.engine.processes.functions.workfunction:21
msgid "The decorated function."
msgstr ""

#: ../../../src/aiida/engine/processes/functions.py:docstring of aiida.engine.processes.functions.get_stack_size:1
msgid "Return the stack size for the caller's frame."
msgstr ""

#: ../../../src/aiida/engine/processes/functions.py:docstring of aiida.engine.processes.functions.get_stack_size:3
msgid "This solution is taken from https://stackoverflow.com/questions/34115298/ as a more performant alternative to the naive ``len(inspect.stack())` solution. This implementation is about three orders of magnitude faster compared to the naive solution and it scales especially well for larger stacks, which will be usually the case for the usage of ``aiida-core``. However, it does use the internal ``_getframe`` of the ``sys`` standard library. It this ever were to stop working, simply switch to using ``len(inspect.stack())``."
msgstr ""

#: ../../../src/aiida/engine/processes/functions.py:docstring of aiida.engine.processes.functions.get_stack_size:9
msgid "Hint for the expected stack size."
msgstr ""

#: ../../../src/aiida/engine/processes/functions.py:docstring of aiida.engine.processes.functions.get_stack_size:10
msgid "The stack size for caller's frame."
msgstr ""

#: ../../../src/aiida/engine/processes/functions.py:docstring of aiida.engine.processes.functions.infer_valid_type_from_type_annotation:1
msgid "Infer the value for the ``valid_type`` of an input port from the given function argument annotation."
msgstr ""

#: ../../../src/aiida/engine/processes/functions.py:docstring of aiida.engine.processes.functions.infer_valid_type_from_type_annotation:3
msgid "The annotation of a function argument as returned by ``inspect.get_annotation``."
msgstr ""

#: ../../../src/aiida/engine/processes/functions.py:docstring of aiida.engine.processes.functions.infer_valid_type_from_type_annotation:4
msgid "A tuple of valid types. If no valid types were defined or they could not be successfully parsed, an empty tuple is returned."
msgstr ""

#: ../../../src/aiida/engine/processes/functions.py:docstring of aiida.engine.processes.functions.process_function:1
msgid "The base function decorator to create a FunctionProcess out of a normal python function."
msgstr ""

#: ../../../src/aiida/engine/processes/functions.py:docstring of aiida.engine.processes.functions.process_function:3
msgid "the ORM class to be used as the Node record for the FunctionProcess"
msgstr ""

#: ../../../src/aiida/engine/processes/functions.py:docstring of aiida.engine.processes.functions.workfunction:1
msgid "A decorator to turn a standard python function into a workfunction. Example usage:"
msgstr ""

#: ../../../src/aiida/engine/processes/futures.py:docstring of aiida.engine.processes.futures:1
msgid "Futures that can poll or receive broadcasted messages while waiting for a task to be completed."
msgstr ""

#: ../../../src/aiida/engine/processes/futures.py:docstring of aiida.engine.processes.futures.ProcessFuture:1
msgid "Future that waits for a process to complete using both polling and listening for broadcast events if possible."
msgstr ""

#: ../../../src/aiida/engine/processes/futures.py:docstring of aiida.engine.processes.futures.ProcessFuture.__init__:1
msgid "Construct a future for a process node being finished."
msgstr ""

#: ../../../src/aiida/engine/processes/futures.py:docstring of aiida.engine.processes.futures.ProcessFuture.__init__:3
msgid "If a None poll_interval is supplied polling will not be used. If a communicator is supplied it will be used to listen for broadcast messages."
msgstr ""

#: ../../../src/aiida/engine/processes/futures.py:docstring of aiida.engine.processes.futures.ProcessFuture.__init__:6
msgid "process pk"
msgstr ""

#: ../../../src/aiida/engine/processes/futures.py:docstring of aiida.engine.processes.futures.ProcessFuture.__init__:7
msgid "An event loop"
msgstr ""

#: ../../../src/aiida/engine/processes/futures.py:docstring of aiida.engine.processes.futures.ProcessFuture.__init__:8
msgid "optional polling interval, if None, polling is not activated."
msgstr ""

#: ../../../src/aiida/engine/processes/futures.py:docstring of aiida.engine.processes.futures.ProcessFuture.__init__:9
msgid "optional communicator, if None, will not subscribe to broadcasts."
msgstr ""

#: ../../../src/aiida/engine/processes/futures.py:docstring of aiida.engine.processes.futures.ProcessFuture._poll_process:1
msgid "Poll whether the process node has reached a terminal state."
msgstr ""

#: ../../../src/aiida/engine/processes/futures.py:docstring of aiida.engine.processes.futures.ProcessFuture.cleanup:1
msgid "Clean up the future by removing broadcast subscribers from the communicator if it still exists."
msgstr ""

#: ../../../src/aiida/engine/processes/ports.py:docstring of aiida.engine.processes.ports:1
msgid "AiiDA specific implementation of plumpy Ports and PortNamespaces for the ProcessSpec."
msgstr ""

#: ../../../src/aiida/engine/processes/ports.py:docstring of aiida.engine.processes.ports.CalcJobOutputPort:1
msgid "Bases: :py:class:`~plumpy.ports.OutputPort`"
msgstr ""

#: ../../../src/aiida/engine/processes/ports.py:docstring of aiida.engine.processes.ports.CalcJobOutputPort:1
msgid "Sub class of plumpy.OutputPort which adds the `_pass_to_parser` attribute."
msgstr ""

#: ../../../src/aiida/engine/processes/ports.py:docstring of aiida.engine.processes.ports.InputPort:1
msgid "Bases: :py:class:`~aiida.engine.processes.ports.WithMetadata`, :py:class:`~aiida.engine.processes.ports.WithSerialize`, :py:class:`~aiida.engine.processes.ports.WithNonDb`, :py:class:`~plumpy.ports.InputPort`"
msgstr ""

#: ../../../src/aiida/engine/processes/ports.py:docstring of aiida.engine.processes.ports.InputPort:1
msgid "Sub class of plumpy.InputPort which mixes in the WithSerialize and WithNonDb mixins to support automatic value serialization to database storable types and support non database storable input types as well."
msgstr ""

#: ../../../src/aiida/engine/processes/ports.py:docstring of aiida.engine.processes.ports.InputPort:4
msgid "The mixins have to go before the main port class in the superclass order to make sure they have the chance to process their specific keywords."
msgstr ""

#: ../../../src/aiida/engine/processes/ports.py:docstring of aiida.engine.processes.ports.InputPort.__init__:1
msgid "Override the constructor to check the type of the default if set and warn if not immutable."
msgstr ""

#: ../../../src/aiida/engine/processes/ports.py:docstring of aiida.engine.processes.ports.InputPort.get_description:1
msgid "Return a description of the InputPort, which will be a dictionary of its attributes"
msgstr ""

#: ../../../src/aiida/engine/processes/ports.py:docstring of aiida.engine.processes.ports.InputPort.get_description:3
msgid "a dictionary of the stringified InputPort attributes"
msgstr ""

#: ../../../src/aiida/engine/processes/ports.py:docstring of aiida.engine.processes.ports.PortNamespace:1
msgid "Bases: :py:class:`~aiida.engine.processes.ports.WithMetadata`, :py:class:`~aiida.engine.processes.ports.WithNonDb`, :py:class:`~plumpy.ports.PortNamespace`"
msgstr ""

#: ../../../src/aiida/engine/processes/ports.py:docstring of aiida.engine.processes.ports.PortNamespace:1
msgid "Sub class of plumpy.PortNamespace which implements the serialize method to support automatic recursive serialization of a given mapping onto the ports of the PortNamespace."
msgstr ""

#: ../../../src/aiida/engine/processes/ports.py:docstring of aiida.engine.processes.ports.PortNamespace.__setitem__:1
msgid "Ensure that a `Port` being added inherits the `non_db` attribute if not explicitly defined at construction."
msgstr ""

#: ../../../src/aiida/engine/processes/ports.py:docstring of aiida.engine.processes.ports.PortNamespace.__setitem__:3
msgid "The reasoning is that if a `PortNamespace` has `non_db=True`, which is different from the default value, very often all leaves should be also `non_db=True`. To prevent a user from having to specify it manually everytime we overload the value here, unless it was specifically set during construction."
msgstr ""

#: ../../../src/aiida/engine/processes/ports.py:docstring of aiida.engine.processes.ports.PortNamespace.__setitem__:7
msgid "Note that the `non_db` attribute is not present for all `Port` sub classes so we have to check for it first."
msgstr ""

#: ../../../src/aiida/engine/processes/ports.py:docstring of aiida.engine.processes.ports.PortNamespace.serialize:1
msgid "Serialize the given mapping onto this `Portnamespace`."
msgstr ""

#: ../../../src/aiida/engine/processes/ports.py:docstring of aiida.engine.processes.ports.PortNamespace.serialize:3
msgid "It will recursively call this function on any nested `PortNamespace` or the serialize function on any `Ports`."
msgstr ""

#: ../../../src/aiida/engine/processes/ports.py:docstring of aiida.engine.processes.ports.PortNamespace.serialize:5
msgid "a mapping of values to be serialized"
msgstr ""

#: ../../../src/aiida/engine/processes/ports.py:docstring of aiida.engine.processes.ports.PortNamespace.serialize:6
msgid "a tuple with the namespaces of parent namespaces"
msgstr ""

#: ../../../src/aiida/engine/processes/ports.py:docstring of aiida.engine.processes.ports.PortNamespace.serialize:7
msgid "the serialized mapping"
msgstr ""

#: ../../../src/aiida/engine/processes/ports.py:docstring of aiida.engine.processes.ports.PortNamespace.validate_port_name:1
msgid "Validate the given port name."
msgstr ""

#: ../../../src/aiida/engine/processes/ports.py:docstring of aiida.engine.processes.ports.PortNamespace.validate_port_name:3
msgid "Valid port names adhere to the following restrictions:"
msgstr ""

#: ../../../src/aiida/engine/processes/ports.py:docstring of aiida.engine.processes.ports.PortNamespace.validate_port_name:5
msgid "Is a valid link label (see below)"
msgstr ""

#: ../../../src/aiida/engine/processes/ports.py:docstring of aiida.engine.processes.ports.PortNamespace.validate_port_name:6
msgid "Does not contain two or more consecutive underscores"
msgstr ""

#: ../../../src/aiida/engine/processes/ports.py:docstring of aiida.engine.processes.ports.PortNamespace.validate_port_name:14
msgid "the proposed name of the port to be added"
msgstr ""

#: ../../../src/aiida/engine/processes/ports.py:docstring of aiida.engine.processes.ports.PortNamespace.validate_port_name:15
msgid "if the port name is not a string type"
msgstr ""

#: ../../../src/aiida/engine/processes/ports.py:docstring of aiida.engine.processes.ports.PortNamespace.validate_port_name:16
msgid "if the port name is invalid"
msgstr ""

#: ../../../src/aiida/engine/processes/ports.py:docstring of aiida.engine.processes.ports.WithMetadata:1
msgid "A mixin that allows an input port to be marked as metadata through the keyword ``is_metadata``."
msgstr ""

#: ../../../src/aiida/engine/processes/ports.py:docstring of aiida.engine.processes.ports.WithMetadata:3
msgid "A metadata input differs from a normal input as in that it is not linked to the ``ProcessNode`` as a ``Data`` node but rather is stored on the ``ProcessNode`` itself (as an attribute, for example)."
msgstr ""

#: ../../../src/aiida/engine/processes/ports.py:docstring of aiida.engine.processes.ports.WithMetadata.is_metadata:1
msgid "Return whether the value of this ``InputPort`` should be stored as a ``Node`` in the database."
msgstr ""

#: ../../../src/aiida/engine/processes/ports.py:docstring of aiida.engine.processes.ports.WithMetadata.is_metadata:3
msgid "``True`` if it should be storable as a ``Node``, ``False`` otherwise"
msgstr ""

#: ../../../src/aiida/engine/processes/ports.py:docstring of aiida.engine.processes.ports.WithMetadata.is_metadata_explicitly_set:1
msgid "Return whether the ``is_metadata`` keyword was explicitly passed in the construction of the ``InputPort``."
msgstr ""

#: ../../../src/aiida/engine/processes/ports.py:docstring of aiida.engine.processes.ports.WithMetadata.is_metadata_explicitly_set:3
msgid "``True`` if ``is_metadata`` was explicitly defined during construction, ``False`` otherwise"
msgstr ""

#: ../../../src/aiida/engine/processes/ports.py:docstring of aiida.engine.processes.ports.WithNonDb:1
msgid "A mixin that adds support to a port to flag it should not be stored in the database using the ``non_db`` flag."
msgstr ""

#: ../../../src/aiida/engine/processes/ports.py:docstring of aiida.engine.processes.ports.WithNonDb.non_db:1
msgid "Return whether the value of this ``InputPort`` should be stored in the database."
msgstr ""

#: ../../../src/aiida/engine/processes/ports.py:docstring of aiida.engine.processes.ports.WithNonDb.non_db:3
msgid "``True`` if it should be stored, ``False`` otherwise"
msgstr ""

#: ../../../src/aiida/engine/processes/ports.py:docstring of aiida.engine.processes.ports.WithNonDb.non_db_explicitly_set:1
msgid "Return whether the ``non_db`` keyword was explicitly passed in the construction of the ``InputPort``."
msgstr ""

#: ../../../src/aiida/engine/processes/ports.py:docstring of aiida.engine.processes.ports.WithNonDb.non_db_explicitly_set:3
msgid "``True`` if ``non_db`` was explicitly defined during construction, ``False`` otherwise"
msgstr ""

#: ../../../src/aiida/engine/processes/ports.py:docstring of aiida.engine.processes.ports.WithSerialize:1
msgid "A mixin that adds support for a serialization function which is automatically applied on inputs that are not AiiDA data types."
msgstr ""

#: ../../../src/aiida/engine/processes/ports.py:docstring of aiida.engine.processes.ports.WithSerialize.serialize:1
msgid "Serialize the given value, unless it is ``None``, already a Data type, or no serializer function is defined."
msgstr ""

#: ../../../src/aiida/engine/processes/ports.py:docstring of aiida.engine.processes.ports.WithSerialize.serialize:3
msgid "the value to be serialized"
msgstr ""

#: ../../../src/aiida/engine/processes/ports.py:docstring of aiida.engine.processes.ports.WithSerialize.serialize:4
msgid "a serialized version of the value or the unchanged value"
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process:1
msgid "The AiiDA process class"
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process:1
msgid "Bases: :py:class:`~plumpy.processes.Process`"
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process:1
msgid "This class represents an AiiDA process which can be executed and will have full provenance saved in the database."
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.SaveKeys:1
msgid "Keys used to identify things in the saved instance state bundle."
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process._build_process_label:1
msgid "Construct the process label that should be set on ``ProcessNode`` instances for this process class."
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process._build_process_label:3
msgid "By default this returns the name of the process class itself. It can be overridden by ``Process`` subclasses to provide a more specific label."
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process._build_process_label:6
msgid "The process label to use for ``ProcessNode`` instances."
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process._create_and_setup_db_record:1
msgid "Create and setup the database record for this process"
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process._create_and_setup_db_record:3
msgid "the uuid or pk of the process"
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process._filter_serializable_metadata:1
msgid "Return the inputs that correspond to ports with ``is_metadata=True`` and that are JSON serializable."
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process._filter_serializable_metadata:3
msgid "The function is called recursively for any port namespaces."
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process._filter_serializable_metadata:5
msgid "An ``InputPort`` or ``PortNamespace``. If an ``InputPort`` that specifies ``is_metadata=True`` the ``port_value`` is returned. For a ``PortNamespace`` this method is called recursively for the keys within the namespace and the resulting dictionary is returned, omitting ``None`` values. If either ``port`` or ``port_value`` is ``None``, ``None`` is returned."
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process._filter_serializable_metadata:9
msgid "The ``port_value`` where all inputs that do no correspond to a metadata port or are not JSON serializable, have been filtered out."
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process._flat_inputs:1
msgid "Return a flattened version of the parsed inputs dictionary."
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process._flat_inputs:3
msgid "The eventual keys will be a concatenation of the nested keys. Note that the `metadata` dictionary, if present, is not passed, as those are dealt with separately in `_setup_metadata`."
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process._flat_inputs:6
msgid "flat dictionary of parsed inputs"
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process._flat_outputs:1
msgid "Return a flattened version of the registered outputs dictionary."
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process._flat_outputs:3
msgid "The eventual keys will be a concatenation of the nested keys."
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process._flat_outputs:5
msgid "flat dictionary of parsed outputs"
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process._flatten_inputs:1
msgid "Function that will recursively flatten the inputs dictionary, omitting inputs for ports that are marked as being non database storable"
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process._flatten_inputs:4
msgid "port against which to map the port value, can be InputPort or PortNamespace"
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process._flatten_inputs:5
#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process._flatten_outputs:4
msgid "value for the current port, can be a Mapping"
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process._flatten_inputs:6
#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process._flatten_outputs:5
msgid "the parent key with which to prefix the keys"
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process._flatten_inputs:7
#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process._flatten_outputs:6
msgid "character to use for the concatenation of keys"
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process._flatten_inputs:8
msgid "flat list of inputs"
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process._flatten_outputs:1
msgid "Function that will recursively flatten the outputs dictionary."
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process._flatten_outputs:3
msgid "port against which to map the port value, can be OutputPort or PortNamespace"
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process._flatten_outputs:8
msgid "flat list of outputs"
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process._get_namespace_list:1
msgid "Get the list of namespaces in a given namespace."
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process._get_namespace_list:3
msgid "name space"
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process._get_namespace_list:4
msgid "If set to true, all parent namespaces of the given ``namespace`` will also be searched."
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process._get_namespace_list:7
msgid "namespace list"
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process._save_checkpoint:1
msgid "Save the current state in a chechpoint if persistence is enabled and the process state is not terminal"
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process._save_checkpoint:3
msgid "If the persistence call excepts with a PersistenceError, it will be caught and a warning will be logged."
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process._setup_db_record:1
msgid "Create the database record for this process and the links with respect to its inputs"
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process._setup_db_record:3
msgid "This function will set various attributes on the node that serve as a proxy for attributes of the Process. This is essential as otherwise this information could only be introspected through the Process itself, which is only available to the interpreter that has it in memory. To make this data introspectable from any interpreter, for example for the command line interface, certain Process attributes are proxied through the calculation node."
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process._setup_db_record:9
msgid "In addition, the parent calculation will be setup with a CALL link if applicable and all inputs will be linked up as well."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.CalcJob._setup_inputs:1
#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process._setup_inputs:1
msgid "Create the links between the input nodes and the ProcessNode that represents this process."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.CalcJob._setup_metadata:1
#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process._setup_metadata:1
msgid "Store the metadata on the ProcessNode."
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process._setup_version_info:1
msgid "Store relevant plugin version information."
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.build_process_type:1
msgid "The process type."
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.build_process_type:3
msgid "string of the process type"
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.build_process_type:5
msgid "Note: This could be made into a property 'process_type' but in order to have it be a property of the class it would need to be defined in the metaclass, see https://bugs.python.org/issue20659"
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.decode_input_args:1
msgid "Decode saved input arguments as they came from the saved instance state Bundle"
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.decode_input_args:3
msgid "encoded (serialized) inputs"
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.decode_input_args:4
msgid "The decoded input args"
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.define:1
msgid "Define the specification of the process, including its inputs, outputs and known exit codes."
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.define:3
msgid "A `metadata` input namespace is defined, with optional ports that are not stored in the database."
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.encode_input_args:1
msgid "Encode input arguments such that they may be saved in a Bundle"
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.encode_input_args:3
msgid "A mapping of the inputs as passed to the process"
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.encode_input_args:4
msgid "The encoded (serialized) inputs"
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.exposed_inputs:1
msgid "Gather a dictionary of the inputs that were exposed for a given Process class under an optional namespace."
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.exposed_inputs:3
msgid "Process class whose inputs to try and retrieve"
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.exposed_inputs:4
msgid "PortNamespace in which to look for the inputs"
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.exposed_inputs:5
msgid "If set to true, all parent namespaces of the given ``namespace`` will also be searched for inputs. Inputs in lower-lying namespaces take precedence."
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.exposed_inputs:8
msgid "exposed inputs"
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.exposed_outputs:1
msgid "Return the outputs which were exposed from the ``process_class`` and emitted by the specific ``node``"
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.exposed_outputs:3
msgid "process node whose outputs to try and retrieve"
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.exposed_outputs:4
msgid "Namespace in which to search for exposed outputs."
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.exposed_outputs:5
msgid "If set to true, all parent namespaces of the given ``namespace`` will also be searched for outputs. Outputs in lower-lying namespaces take precedence."
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.exposed_outputs:8
msgid "exposed outputs"
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.get_exit_statuses:1
msgid "Return the exit status (integers) for the given exit code labels."
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.get_exit_statuses:3
msgid "a list of strings that reference exit code labels of this process class"
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.get_exit_statuses:4
msgid "list of exit status integers that correspond to the given exit code labels"
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.get_exit_statuses:5
msgid "if at least one of the labels does not correspond to an existing exit code"
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.get_parent_calc:1
msgid "Get the parent process node"
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.get_parent_calc:3
msgid "the parent process node if there is one"
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.get_provenance_inputs_iterator:1
msgid "Get provenance input iterator."
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.inputs:1
msgid "Return the inputs attribute dictionary or an empty one."
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.inputs:3
msgid "This overrides the property of the base class because that can also return ``None``. This override ensures calling functions that they will always get an instance of ``AttributesFrozenDict``."
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.is_valid_cache:1
msgid "Check if the given node can be cached from."
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.is_valid_cache:3
msgid "Overriding this method allows ``Process`` sub-classes to modify when corresponding process nodes are considered as a cache."
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.is_valid_cache:6
msgid "When overriding this method, make sure to return ``False`` *at least* in all cases when ``super()._node.base.caching.is_valid_cache(node)`` returns ``False``. Otherwise, the ``invalidates_cache`` keyword on exit codes may have no effect."
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.kill:1
msgid "Kill the process and all the children calculations it called"
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.kill:3
#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.on_paused:3
msgid "message"
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.load_instance_state:1
#: ../../../src/aiida/engine/processes/workchains/workchain.py:docstring of aiida.engine.processes.workchains.workchain.WorkChain.load_instance_state:1
msgid "Load instance state."
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.load_instance_state:3
#: ../../../src/aiida/engine/processes/workchains/workchain.py:docstring of aiida.engine.processes.workchains.workchain.WorkChain.load_instance_state:3
msgid "saved instance state"
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.metadata:1
msgid "Return the metadata that were specified when this process instance was launched."
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.metadata:3
msgid "metadata dictionary"
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.CalcJob.node:1
#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.node:1
#: ../../../src/aiida/engine/processes/workchains/workchain.py:docstring of aiida.engine.processes.workchains.workchain.WorkChain.node:1
msgid "Return the ProcessNode used by this process to represent itself in the database."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.CalcJob.node:3
#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.node:3
#: ../../../src/aiida/engine/processes/workchains/workchain.py:docstring of aiida.engine.processes.workchains.workchain.WorkChain.node:3
msgid "instance of sub class of ProcessNode"
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.on_create:1
msgid "Called when a Process is created."
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.on_entered:1
msgid "After entering a new state, save a checkpoint and update the latest process state change timestamp."
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.on_except:1
msgid "Log the exception by calling the report method with formatted stack trace from exception info object and store the exception string as a node attribute"
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.on_except:4
msgid "the sys.exc_info() object (type, value, traceback)"
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.on_finish:1
msgid "Set the finish status on the process node."
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.on_finish:3
msgid "result of the process"
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.on_finish:4
msgid "whether execution was successful"
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.on_output_emitting:1
msgid "The process has emitted a value on the given output port."
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.on_output_emitting:3
msgid "The output port name the value was emitted on"
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.on_output_emitting:4
msgid "The value emitted"
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.on_paused:1
msgid "The Process was paused so set the paused attribute on the process node"
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.on_playing:1
msgid "The Process was unpaused so remove the paused attribute on the process node"
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.on_terminated:1
msgid "Called when a Process enters a terminal state."
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.out:1
msgid "Attach output to output port."
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.out:3
msgid "The name of the port will be used as the link label."
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.out:5
msgid "name of output port"
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.out:6
msgid "value to put inside output port"
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.out_many:1
msgid "Attach outputs to multiple output ports."
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.out_many:3
msgid "Keys of the dictionary will be used as output port names, values as outputs."
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.out_many:5
msgid "output dictionary"
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.report:1
msgid "Log a message to the logger, which should get saved to the database through the attached DbLogHandler."
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.report:3
msgid "The pk, class name and function name of the caller are prepended to the given message"
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.report:5
msgid "message to log"
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.report:6
msgid "args to pass to the log call"
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.report:7
msgid "kwargs to pass to the log call"
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.runner:1
msgid "Get process runner."
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.save_instance_state:1
#: ../../../src/aiida/engine/processes/workchains/workchain.py:docstring of aiida.engine.processes.workchains.workchain.WorkChain.save_instance_state:1
msgid "Save instance state."
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.save_instance_state:3
msgid "See documentation of :meth:`!plumpy.processes.Process.save_instance_state`."
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.set_status:1
msgid "The status of the Process is about to be changed, so we reflect this is in node's attribute proxy."
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.set_status:3
msgid "the status message"
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.submit:1
msgid "Submit process for execution."
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.submit:3
msgid "process"
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.update_outputs:1
msgid "Attach new outputs to the node since the last call."
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.update_outputs:3
msgid "Does nothing, if self.metadata.store_provenance is False."
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.uuid:1
msgid "Return the UUID of the process which corresponds to the UUID of its associated `ProcessNode`."
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.Process.uuid:3
msgid "the UUID associated to this process instance"
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.get_query_string_from_process_type_string:1
msgid "Take the process type string of a Node and create the queryable type string."
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.get_query_string_from_process_type_string:3
msgid "the process type string"
msgstr ""

#: ../../../src/aiida/engine/processes/process.py:docstring of aiida.engine.processes.process.get_query_string_from_process_type_string:6
msgid "string that can be used to query for subclasses of the process type using 'LIKE <string>'"
msgstr ""

#: ../../../src/aiida/engine/processes/process_spec.py:docstring of aiida.engine.processes.process_spec:1
msgid "AiiDA specific implementation of plumpy's ProcessSpec."
msgstr ""

#: ../../../src/aiida/engine/processes/process_spec.py:docstring of aiida.engine.processes.process_spec.CalcJobProcessSpec:1
msgid "Bases: :py:class:`~aiida.engine.processes.process_spec.ProcessSpec`"
msgstr ""

#: ../../../src/aiida/engine/processes/process_spec.py:docstring of aiida.engine.processes.process_spec.CalcJobProcessSpec:1
msgid "Process spec intended for the `CalcJob` process class."
msgstr ""

#: ../../../src/aiida/engine/processes/process_spec.py:docstring of aiida.engine.processes.process_spec.ProcessSpec:1
msgid "Bases: :py:class:`~plumpy.process_spec.ProcessSpec`"
msgstr ""

#: ../../../src/aiida/engine/processes/process_spec.py:docstring of aiida.engine.processes.process_spec.ProcessSpec:1
msgid "Default process spec for process classes defined in `aiida-core`."
msgstr ""

#: ../../../src/aiida/engine/processes/process_spec.py:docstring of aiida.engine.processes.process_spec.ProcessSpec:3
msgid "This sub class defines custom classes for input ports and port namespaces. It also adds support for the definition of exit codes and retrieving them subsequently."
msgstr ""

#: ../../../src/aiida/engine/processes/process_spec.py:docstring of aiida.engine.processes.process_spec.ProcessSpec.exit_code:1
msgid "Add an exit code to the ProcessSpec"
msgstr ""

#: ../../../src/aiida/engine/processes/process_spec.py:docstring of aiida.engine.processes.process_spec.ProcessSpec.exit_code:3
msgid "the exit status integer"
msgstr ""

#: ../../../src/aiida/engine/processes/process_spec.py:docstring of aiida.engine.processes.process_spec.ProcessSpec.exit_code:4
msgid "a label by which the exit code can be addressed"
msgstr ""

#: ../../../src/aiida/engine/processes/process_spec.py:docstring of aiida.engine.processes.process_spec.ProcessSpec.exit_code:5
msgid "a more detailed description of the exit code"
msgstr ""

#: ../../../src/aiida/engine/processes/process_spec.py:docstring of aiida.engine.processes.process_spec.ProcessSpec.exit_code:6
msgid "when set to `True`, a process exiting with this exit code will not be considered for caching"
msgstr ""

#: ../../../src/aiida/engine/processes/process_spec.py:docstring of aiida.engine.processes.process_spec.ProcessSpec.exit_codes:1
msgid "Return the namespace of exit codes defined for this ProcessSpec"
msgstr ""

#: ../../../src/aiida/engine/processes/process_spec.py:docstring of aiida.engine.processes.process_spec.ProcessSpec.exit_codes:3
#: ../../../src/aiida/parsers/parser.py:docstring of aiida.parsers.parser.Parser.exit_codes:3
msgid "ExitCodesNamespace of ExitCode named tuples"
msgstr ""

#: ../../../src/aiida/engine/processes/process_spec.py:docstring of aiida.engine.processes.process_spec.ProcessSpec.inputs:1
msgid "Get the input port namespace of the process specification"
msgstr ""

#: ../../../src/aiida/engine/processes/process_spec.py:docstring of aiida.engine.processes.process_spec.ProcessSpec.inputs:3
msgid "the input PortNamespace"
msgstr ""

#: ../../../src/aiida/engine/processes/process_spec.py:docstring of aiida.engine.processes.process_spec.ProcessSpec.outputs:1
msgid "Get the output port namespace of the process specification"
msgstr ""

#: ../../../src/aiida/engine/processes/process_spec.py:docstring of aiida.engine.processes.process_spec.ProcessSpec.outputs:3
msgid "the outputs PortNamespace"
msgstr ""

#: ../../../src/aiida/engine/processes/utils.py:docstring of aiida.engine.processes.utils:1
msgid "Module with utilities."
msgstr ""

#: ../../../src/aiida/engine/processes/utils.py:docstring of aiida.engine.processes.utils.prune_mapping:1
msgid "Prune a nested mapping from all mappings that are completely empty."
msgstr ""

#: ../../../src/aiida/engine/processes/utils.py:docstring of aiida.engine.processes.utils.prune_mapping:3
msgid "A nested mapping that is completely empty means it contains at most other empty mappings. Other null values, such as `None` or empty lists, should not be pruned."
msgstr ""

#: ../../../src/aiida/engine/processes/utils.py:docstring of aiida.engine.processes.utils.prune_mapping:6
msgid "A nested mapping of port values."
msgstr ""

#: ../../../src/aiida/engine/processes/utils.py:docstring of aiida.engine.processes.utils.prune_mapping:7
msgid "The same mapping but without any nested namespace that is completely empty."
msgstr ""

#: ../../source/reference/apidoc/aiida.engine.processes.calcjobs.rst:2
msgid "aiida.engine.processes.calcjobs package"
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/__init__.py:docstring of aiida.engine.processes.calcjobs:1
msgid "Module for the `CalcJob` process and related utilities."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob:1
#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.CalcJob:1
msgid "Implementation of the CalcJob process."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.CalcJob.__init__:1
msgid "Construct a CalcJob instance."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.CalcJob.__init__:3
msgid "Construct the instance only if it is a sub class of `CalcJob`, otherwise raise `InvalidOperation`."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.CalcJob.__init__:5
msgid "See documentation of :class:`aiida.engine.Process`."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.CalcJob._perform_dry_run:1
msgid "Perform a dry run."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.CalcJob._perform_dry_run:3
msgid "Instead of performing the normal sequence of steps, just the `presubmit` is called, which will call the method `prepare_for_submission` of the plugin to generate the input files based on the inputs. Then the upload action is called, but using a normal local transport that will copy the files to a local sandbox folder. The generated input script and the absolute path to the sandbox folder are stored in the `dry_run_info` attribute of the node of this process."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.CalcJob._perform_import:1
msgid "Perform the import of an already completed calculation."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.CalcJob._perform_import:3
msgid "The inputs contained a `RemoteData` under the key `remote_folder` signalling that this is not supposed to be run as a normal calculation job, but rather the results are already computed outside of AiiDA and merely need to be imported."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.CalcJob.get_importer:1
msgid "Load the `CalcJobImporter` associated with this `CalcJob` if it exists."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.CalcJob.get_importer:3
msgid "By default an importer with the same entry point as the ``CalcJob`` will be loaded, however, this can be overridden using the ``entry_point_name`` argument."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.CalcJob.get_importer:6
msgid "optional entry point name of a ``CalcJobImporter`` to override the default."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.CalcJob.get_importer:7
msgid "the loaded ``CalcJobImporter``."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.CalcJob.get_importer:8
msgid "if no importer class could be loaded."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.CalcJob.get_state_classes:1
msgid "A mapping of the State constants to the corresponding state class."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.CalcJob.get_state_classes:3
msgid "Overrides the waiting state with the Calcjob specific version."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.CalcJob.on_terminated:1
msgid "Cleanup the node by deleting the calulation job state."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.CalcJob.on_terminated:3
msgid "This has to be done before calling the super because that will seal the node after we cannot change it"
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.CalcJob.options:1
msgid "Return the options of the metadata that were specified when this process instance was launched."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.CalcJob.options:3
msgid "options dictionary"
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.CalcJob.parse:1
msgid "Parse a retrieved job calculation."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.CalcJob.parse:3
msgid "This is called once it's finished waiting for the calculation to be finished and the data has been retrieved."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.CalcJob.parse:5
msgid "The path to the temporary folder"
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.CalcJob.parse_retrieved_output:1
msgid "Parse the retrieved data by calling the parser plugin if it was defined in the inputs."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.CalcJob.parse_scheduler_output:1
msgid "Parse the output of the scheduler if that functionality has been implemented for the plugin."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.CalcJob.presubmit:1
msgid "Prepares the calculation folder with all inputs, ready to be copied to the cluster."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.CalcJob.presubmit:3
msgid "a SandboxFolder that can be used to write calculation input files and the scheduling script."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.CalcJob.presubmit:0
msgid "return calcinfo"
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.CalcJob.presubmit:5
msgid "the CalcInfo object containing the information needed by the daemon to handle operations."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.CalcJob.run:1
msgid "Run the calculation job."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.CalcJob.run:3
msgid "This means invoking the `presubmit` and storing the temporary folder in the node's repository. Then we move the process in the `Wait` state, waiting for the `UPLOAD` transport task to be started."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.CalcJob.run:6
msgid "the `Stop` command if a dry run, int if the process has an exit status, `Wait` command if the calcjob is to be uploaded"
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.CalcJob.terminate:1
msgid "Terminate the process immediately and return the given exit code."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.CalcJob.terminate:3
msgid "This method is called by :meth:`aiida.engine.processes.calcjobs.tasks.Waiting.execute` if a monitor triggered the job to be terminated and specified the parsing to be skipped. It will construct the running state and tell this method to be run, which returns the given exit code which will cause the process to be terminated."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.CalcJob.terminate:7
msgid "The exit code to return."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.CalcJob.terminate:8
msgid "The provided exit code."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.validate_additional_retrieve_list:1
msgid "Validate the additional retrieve list."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.validate_additional_retrieve_list:3
msgid "string with error message in case the input is invalid."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.validate_calc_job:1
msgid "Validate the entire set of inputs passed to the `CalcJob` constructor."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.validate_calc_job:3
msgid "Reasons that will cause this validation to raise an `InputValidationError`:"
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.validate_calc_job:5
msgid "No `Computer` has been specified, neither directly in `metadata.computer` nor indirectly through the `Code` input"
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.validate_calc_job:6
msgid "The specified computer is not stored"
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.validate_calc_job:7
msgid "The `Computer` specified in `metadata.computer` is not the same as that of the specified `Code`"
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.validate_calc_job:8
msgid "No `Code` has been specified and no `remote_folder` input has been specified, i.e. this is no import run"
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.validate_calc_job:10
#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.validate_parser:3
msgid "string with error message in case the inputs are invalid"
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.validate_monitors:1
msgid "Validate the ``monitors`` input namespace."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.validate_parser:1
msgid "Validate the parser."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/calcjob.py:docstring of aiida.engine.processes.calcjobs.calcjob.validate_stash_options:1
msgid "Validate the ``stash`` options."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/importer.py:docstring of aiida.engine.processes.calcjobs.importer:1
msgid "Abstract utility class that helps to import calculation jobs completed outside of AiiDA."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/importer.py:docstring of aiida.engine.processes.calcjobs.importer.CalcJobImporter:1
#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendEntity:1
#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendEntityExtrasMixin:1
#: ../../../src/aiida/orm/implementation/querybuilder.py:docstring of aiida.orm.implementation.querybuilder.BackendQueryBuilder:1
#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend:1
#: ../../../src/aiida/parsers/parser.py:docstring of aiida.parsers.parser.Parser:1
#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveFormatAbstract:1
#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveReaderAbstract:1
#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveWriterAbstract:1
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport:1
msgid "Bases: :py:class:`~abc.ABC`"
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/importer.py:docstring of aiida.engine.processes.calcjobs.importer.CalcJobImporter:1
msgid "An abstract class, to define an importer for computations completed outside of AiiDA."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/importer.py:docstring of aiida.engine.processes.calcjobs.importer.CalcJobImporter:3
msgid "This class is used to import the results of a calculation that was completed outside of AiiDA. The importer is responsible for parsing the output files of the calculation and creating the corresponding AiiDA nodes."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/manager.py:docstring of aiida.engine.processes.calcjobs.manager:1
msgid "Module containing utilities and classes relating to job calculations running on systems that require transport."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/manager.py:docstring of aiida.engine.processes.calcjobs.manager.JobManager:1
msgid "A manager for :py:class:`~aiida.engine.processes.calcjobs.calcjob.CalcJob` submitted to ``Computer`` instances."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/manager.py:docstring of aiida.engine.processes.calcjobs.manager.JobManager:3
msgid "When a calculation job is submitted to a :py:class:`~aiida.orm.computers.Computer`, it actually uses a specific :py:class:`~aiida.orm.authinfos.AuthInfo`, which is a computer configured for a :py:class:`~aiida.orm.users.User`. The ``JobManager`` maintains a mapping of :py:class:`~aiida.engine.processes.calcjobs.manager.JobsList` instances for each authinfo that has active calculation jobs. These jobslist instances are then responsible for bundling scheduler updates for all the jobs they maintain (i.e. that all share the same authinfo) and update their status."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/manager.py:docstring of aiida.engine.processes.calcjobs.manager.JobManager:9
msgid "As long as a :py:class:`~aiida.engine.runners.Runner` will create a single ``JobManager`` instance and use that for its lifetime, the guarantees made by the ``JobsList`` about respecting the minimum polling interval of the scheduler will be maintained. Note, however, that since each ``Runner`` will create its own job manager, these guarantees only hold per runner."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/manager.py:docstring of aiida.engine.processes.calcjobs.manager.JobManager.get_jobs_list:1
msgid "Get or create a new `JobLists` instance for the given authinfo."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/manager.py:docstring of aiida.engine.processes.calcjobs.manager.JobManager.get_jobs_list:3
msgid "the `AuthInfo`"
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/manager.py:docstring of aiida.engine.processes.calcjobs.manager.JobManager.get_jobs_list:4
msgid "a `JobsList` instance"
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/manager.py:docstring of aiida.engine.processes.calcjobs.manager.JobManager.request_job_info_update:1
msgid "Get a future that will resolve to information about a given job."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/manager.py:docstring of aiida.engine.processes.calcjobs.manager.JobManager.request_job_info_update:3
msgid "This is a context manager so that if the user leaves the context the request is automatically cancelled."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/manager.py:docstring of aiida.engine.processes.calcjobs.manager.JobsList:1
msgid "Manager of calculation jobs submitted with a specific ``AuthInfo``, i.e. computer configured for a specific user."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/manager.py:docstring of aiida.engine.processes.calcjobs.manager.JobsList:3
msgid "This container of active calculation jobs is used to update their status periodically in batches, ensuring that even when a lot of jobs are running, the scheduler update command is not triggered for each job individually."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/manager.py:docstring of aiida.engine.processes.calcjobs.manager.JobsList:6
msgid "In addition, the :py:class:`~aiida.orm.computers.Computer` for which the :py:class:`~aiida.orm.authinfos.AuthInfo` is configured, can define a minimum polling interval. This class will guarantee that the time between update calls to the scheduler is larger or equal to that minimum interval."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/manager.py:docstring of aiida.engine.processes.calcjobs.manager.JobsList:10
msgid "Note that since each instance operates on a specific authinfo, the guarantees of batching scheduler update calls and the limiting of number of calls per unit time, through the minimum polling interval, is only applicable for jobs launched with that particular authinfo. If multiple authinfo instances with the same computer, have active jobs these limitations are not respected between them, since there is no communication between ``JobsList`` instances. See the :py:class:`~aiida.engine.processes.calcjobs.manager.JobManager` for example usage."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/manager.py:docstring of aiida.engine.processes.calcjobs.manager.JobsList.__init__:1
msgid "Construct an instance for the given authinfo and transport queue."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/manager.py:docstring of aiida.engine.processes.calcjobs.manager.JobsList.__init__:3
msgid "The authinfo used to check the jobs list"
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/manager.py:docstring of aiida.engine.processes.calcjobs.manager.JobsList.__init__:4
msgid "A transport queue"
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/manager.py:docstring of aiida.engine.processes.calcjobs.manager.JobsList.__init__:5
msgid "initialize the last updated timestamp"
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/manager.py:docstring of aiida.engine.processes.calcjobs.manager.JobsList._ensure_updating:1
msgid "Ensure that we are updating the job list from the remote resource."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/manager.py:docstring of aiida.engine.processes.calcjobs.manager.JobsList._ensure_updating:3
msgid "This will automatically stop if there are no outstanding requests."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/manager.py:docstring of aiida.engine.processes.calcjobs.manager.JobsList._get_jobs_from_scheduler:1
msgid "Get the current jobs list from the scheduler."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/manager.py:docstring of aiida.engine.processes.calcjobs.manager.JobsList._get_jobs_from_scheduler:3
msgid "a mapping of job ids to :py:class:`~aiida.schedulers.datastructures.JobInfo` instances"
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/manager.py:docstring of aiida.engine.processes.calcjobs.manager.JobsList._get_jobs_with_scheduler:1
msgid "Get all the jobs that are currently with scheduler."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/manager.py:docstring of aiida.engine.processes.calcjobs.manager.JobsList._get_jobs_with_scheduler:3
msgid "the list of jobs with the scheduler"
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/manager.py:docstring of aiida.engine.processes.calcjobs.manager.JobsList._get_next_update_delay:1
msgid "Calculate when we are next allowed to poll the scheduler."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/manager.py:docstring of aiida.engine.processes.calcjobs.manager.JobsList._get_next_update_delay:3
msgid "This delay is calculated as the minimum polling interval defined by the authentication info for this instance, minus time elapsed since the last update."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/manager.py:docstring of aiida.engine.processes.calcjobs.manager.JobsList._get_next_update_delay:6
msgid "delay (in seconds) after which the scheduler may be polled again"
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/manager.py:docstring of aiida.engine.processes.calcjobs.manager.JobsList._has_job_state_changed:1
msgid "Return whether the states `old` and `new` are different."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/manager.py:docstring of aiida.engine.processes.calcjobs.manager.JobsList._update_job_info:1
msgid "Update all of the job information objects."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/manager.py:docstring of aiida.engine.processes.calcjobs.manager.JobsList._update_job_info:3
msgid "This will set the futures for all pending update requests where the corresponding job has a new status compared to the last update."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/manager.py:docstring of aiida.engine.processes.calcjobs.manager.JobsList.get_minimum_update_interval:1
msgid "Get the minimum interval that should be respected between updates of the list."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/manager.py:docstring of aiida.engine.processes.calcjobs.manager.JobsList.get_minimum_update_interval:3
msgid "the minimum interval"
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/manager.py:docstring of aiida.engine.processes.calcjobs.manager.JobsList.last_updated:1
msgid "Get the timestamp of when the list was last updated as produced by `time.time()`"
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/manager.py:docstring of aiida.engine.processes.calcjobs.manager.JobsList.last_updated:3
msgid "The last update point"
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/manager.py:docstring of aiida.engine.processes.calcjobs.manager.JobsList.logger:1
msgid "Return the logger configured for this instance."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/manager.py:docstring of aiida.engine.processes.calcjobs.manager.JobsList.logger:3
msgid "the logger"
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/manager.py:docstring of aiida.engine.processes.calcjobs.manager.JobsList.request_job_info_update:1
msgid "Request job info about a job when the job next changes state."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/manager.py:docstring of aiida.engine.processes.calcjobs.manager.JobsList.request_job_info_update:3
msgid "If the job is not found in the jobs list at the update, the future will resolve to `None`."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/manager.py:docstring of aiida.engine.processes.calcjobs.manager.JobsList.request_job_info_update:5
msgid "job identifier"
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/manager.py:docstring of aiida.engine.processes.calcjobs.manager.JobsList.request_job_info_update:6
msgid "future that will resolve to a `JobInfo` object when the job changes state"
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/monitors.py:docstring of aiida.engine.processes.calcjobs.monitors:1
msgid "Utilities to define monitor functions for ``CalcJobs``."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/monitors.py:docstring of aiida.engine.processes.calcjobs.monitors.CalcJobMonitor:1
msgid "Data class representing a monitor for a ``CalcJob``."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/monitors.py:docstring of aiida.engine.processes.calcjobs.monitors.CalcJobMonitor.__eq__:1
#: ../../../src/aiida/engine/processes/calcjobs/monitors.py:docstring of aiida.engine.processes.calcjobs.monitors.CalcJobMonitorResult.__eq__:1
#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobTemplateCodeInfo.__eq__:1
#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.JoinReturn.__eq__:1
#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.BuiltQuery.__eq__:1
#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports.QueryParams.__eq__:1
#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.AbstractSetContainer.__eq__:1
#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.Basket.__eq__:1
msgid "Return self==value."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/monitors.py:docstring of aiida.engine.processes.calcjobs.monitors.CalcJobMonitor.__post_init__:1
#: ../../../src/aiida/engine/processes/calcjobs/monitors.py:docstring of aiida.engine.processes.calcjobs.monitors.CalcJobMonitorResult.__post_init__:1
msgid "Validate the attributes."
msgstr ""

#: ../../docstring of aiida.engine.processes.calcjobs.monitors.CalcJobMonitor.call_timestamp:1
msgid "Optional datetime representing the last time this monitor was called."
msgstr ""

#: ../../docstring of aiida.engine.processes.calcjobs.monitors.CalcJobMonitor.disabled:1
msgid "If this attribute is set to ``True`` the monitor should not be called when monitors are processed."
msgstr ""

#: ../../docstring of aiida.engine.processes.calcjobs.monitors.CalcJobMonitor.entry_point:1
msgid "Entry point in the ``aiida.calculations.monitors`` group implementing the monitor interface."
msgstr ""

#: ../../docstring of aiida.engine.processes.calcjobs.monitors.CalcJobMonitor.kwargs:1
msgid "Keyword arguments that will be passed to the monitor when invoked (should be JSON serializable)."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/monitors.py:docstring of aiida.engine.processes.calcjobs.monitors.CalcJobMonitor.load_entry_point:1
msgid "Return the function associated with the entry point of this monitor."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/monitors.py:docstring of aiida.engine.processes.calcjobs.monitors.CalcJobMonitor.load_entry_point:3
#: ../../../src/aiida/engine/processes/calcjobs/monitors.py:docstring of aiida.engine.processes.calcjobs.monitors.CalcJobMonitor.validate:3
msgid "If the entry point does not exist or cannot be loaded."
msgstr ""

#: ../../docstring of aiida.engine.processes.calcjobs.monitors.CalcJobMonitor.minimum_poll_interval:1
msgid "Optional minimum poll interval. If set, subsequent calls should be at least this many seconds apart."
msgstr ""

#: ../../docstring of aiida.engine.processes.calcjobs.monitors.CalcJobMonitor.priority:1
msgid "Determines the order in which monitors should be executed in the case of multiple monitors."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/monitors.py:docstring of aiida.engine.processes.calcjobs.monitors.CalcJobMonitor.validate:1
msgid "Validate the monitor."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/monitors.py:docstring of aiida.engine.processes.calcjobs.monitors.CalcJobMonitor.validate:4
#: ../../../src/aiida/engine/processes/calcjobs/monitors.py:docstring of aiida.engine.processes.calcjobs.monitors.CalcJobMonitorResult.validate:3
msgid "If any of the attributes are of the incorrect type."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/monitors.py:docstring of aiida.engine.processes.calcjobs.monitors.CalcJobMonitor.validate:5
msgid "If the entry point has an incorrect function signature."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/monitors.py:docstring of aiida.engine.processes.calcjobs.monitors.CalcJobMonitor.validate:6
msgid "If the kwargs specified are not recognized by the function associated with the entry point."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/monitors.py:docstring of aiida.engine.processes.calcjobs.monitors.CalcJobMonitorAction:1
msgid "The action a engine should undertake as a result of a monitor."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/monitors.py:docstring of aiida.engine.processes.calcjobs.monitors.CalcJobMonitorResult:1
msgid "Data class representing the result of a monitor."
msgstr ""

#: ../../docstring of aiida.engine.processes.calcjobs.monitors.CalcJobMonitorResult.action:1
msgid "The action the engine should take."
msgstr ""

#: ../../docstring of aiida.engine.processes.calcjobs.monitors.CalcJobMonitorResult.key:1
msgid "Key of the monitor in the ``monitors`` input namespace. Will be set automatically by the engine."
msgstr ""

#: ../../docstring of aiida.engine.processes.calcjobs.monitors.CalcJobMonitorResult.message:1
msgid "Human readable message: could be a warning or an error message."
msgstr ""

#: ../../docstring of aiida.engine.processes.calcjobs.monitors.CalcJobMonitorResult.override_exit_code:1
msgid "If set to ``False``, the engine will keep the exit code returned by the parser."
msgstr ""

#: ../../docstring of aiida.engine.processes.calcjobs.monitors.CalcJobMonitorResult.parse:1
msgid "If set to ``False``, the engine will skip the parsing of the retrieved files, if one was specified in inputs."
msgstr ""

#: ../../docstring of aiida.engine.processes.calcjobs.monitors.CalcJobMonitorResult.retrieve:1
msgid "If set to ``False``, the engine will skip retrieving the output files."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/monitors.py:docstring of aiida.engine.processes.calcjobs.monitors.CalcJobMonitorResult.validate:1
msgid "Validate the instance."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/monitors.py:docstring of aiida.engine.processes.calcjobs.monitors.CalcJobMonitorResult.validate:4
msgid "If ``parse == True`` and ``retrieve == False``."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/monitors.py:docstring of aiida.engine.processes.calcjobs.monitors.CalcJobMonitors:1
msgid "Collection of ``CalcJobMonitor`` instances."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/monitors.py:docstring of aiida.engine.processes.calcjobs.monitors.CalcJobMonitors:3
msgid "The collection is initialized from a dictionary where the values are the parameters for initializing an instance of :class:`~aiida.engine.processes.calcjobs.monitors.CalcJobMonitor`, which are stored as an ordered dictionary. The monitors are sorted according to the priority set for the monitors (reversed, i.e., from high to low) and second alphabetically on their key."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/monitors.py:docstring of aiida.engine.processes.calcjobs.monitors.CalcJobMonitors:8
msgid "The :meth:`~aiida.engine.processes.calcjobs.monitors.CalcJobMonitors.process` method can be called providing an instance of a ``CalcJobNode`` and a ``Transport`` and it will iterate over the collection of monitors, executing each monitor in order, and stopping on the first to return a ``CalcJobMonitorResult`` to pass it up to its caller."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/monitors.py:docstring of aiida.engine.processes.calcjobs.monitors.CalcJobMonitors.monitors:1
msgid "Return an ordered dictionary of the monitor collection."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/monitors.py:docstring of aiida.engine.processes.calcjobs.monitors.CalcJobMonitors.monitors:3
msgid "Monitors are first sorted on their priority (reversed, i.e., from high to low) and second on their key."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/monitors.py:docstring of aiida.engine.processes.calcjobs.monitors.CalcJobMonitors.monitors:5
msgid "Ordered dictionary of monitors.."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/monitors.py:docstring of aiida.engine.processes.calcjobs.monitors.CalcJobMonitors.process:1
msgid "Call all monitors in order and return the result as one returns anything other than ``None``."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/monitors.py:docstring of aiida.engine.processes.calcjobs.monitors.CalcJobMonitors.process:3
msgid "The node to pass to the monitor invocation."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/monitors.py:docstring of aiida.engine.processes.calcjobs.monitors.CalcJobMonitors.process:4
msgid "The transport to pass to the monitor invocation."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/monitors.py:docstring of aiida.engine.processes.calcjobs.monitors.CalcJobMonitors.process:5
msgid "``None`` or a monitor result."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks:1
msgid "Transport tasks for calculation jobs."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.PreSubmitException:1
msgid "Raise in the `do_upload` coroutine when an exception is raised in `CalcJob.presubmit`."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.Waiting:1
msgid "Bases: :py:class:`~plumpy.process_states.Waiting`"
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.Waiting:1
msgid "The waiting state for the `CalcJob` process."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.Waiting.__init__:1
msgid "The process this state belongs to"
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.Waiting._kill_job:1
msgid "Kill the job."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.Waiting._launch_task:1
msgid "Launch a coroutine as a task, making sure to make it interruptable."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.Waiting._monitor_job:1
msgid "Process job monitors if any were specified as inputs."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.Waiting.execute:1
msgid "Override the execute coroutine of the base `Waiting` state."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.Waiting.interrupt:1
msgid "Interrupt the `Waiting` state by calling interrupt on the transport task `InterruptableFuture`."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.Waiting.monitors:1
msgid "Return the collection of monitors if specified in the inputs."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.Waiting.monitors:3
msgid "Instance of ``CalcJobMonitors`` containing monitors if specified in the process' input."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.Waiting.parse:1
msgid "Return the `Running` state that will parse the `CalcJob`."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.Waiting.parse:3
msgid "temporary folder used in retrieving that can be used during parsing."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.Waiting.process:1
msgid "The process"
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.Waiting.retrieve:1
msgid "Return the `Waiting` state that will `retrieve` the `CalcJob`."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.Waiting.stash:1
msgid "Return the `Waiting` state that will `stash` the `CalcJob`."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.Waiting.submit:1
msgid "Return the `Waiting` state that will `submit` the `CalcJob`."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.Waiting.update:1
msgid "Return the `Waiting` state that will `update` the `CalcJob`."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.Waiting.upload:1
msgid "Return the `Waiting` state that will `upload` the `CalcJob`."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.task_kill_job:1
msgid "Transport task that will attempt to kill a job calculation."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.task_kill_job:3
#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.task_monitor_job:3
#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.task_retrieve_job:3
#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.task_stash_job:3
#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.task_submit_job:3
#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.task_update_job:3
#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.task_upload_job:3
msgid "The task will first request a transport from the queue. Once the transport is yielded, the relevant execmanager function is called, wrapped in the exponential_backoff_retry coroutine, which, in case of a caught exception, will retry after an interval that increases exponentially with the number of retries, for a maximum number of retries. If all retries fail, the task will raise a TransportTaskException"
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.task_kill_job:8
#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.task_monitor_job:8
#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.task_retrieve_job:8
#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.task_stash_job:8
#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.task_submit_job:8
#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.task_update_job:8
msgid "the node that represents the job calculation"
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.task_kill_job:9
#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.task_monitor_job:9
#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.task_retrieve_job:9
#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.task_stash_job:9
#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.task_submit_job:9
#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.task_upload_job:9
msgid "the TransportQueue from which to request a Transport"
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.task_kill_job:10
#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.task_retrieve_job:11
#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.task_stash_job:10
#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.task_submit_job:10
#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.task_upload_job:10
msgid "the cancelled flag that will be queried to determine whether the task was cancelled"
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.task_kill_job:12
#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.task_retrieve_job:13
#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.task_stash_job:12
#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.task_submit_job:12
#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.task_upload_job:12
msgid "TransportTaskException if after the maximum number of retries the transport task still excepted"
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.task_monitor_job:1
msgid "Transport task that will monitor the job calculation if any monitors have been defined."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.task_monitor_job:10
#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.task_update_job:10
msgid "A cancel flag"
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.task_monitor_job:11
msgid "An instance of ``CalcJobMonitors`` holding the collection of monitors to process."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.task_monitor_job:12
#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.task_update_job:11
msgid "True if the tasks was successfully completed, False otherwise"
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.task_retrieve_job:1
msgid "Transport task that will attempt to retrieve all files of a completed job calculation."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.task_retrieve_job:10
msgid "the absolute path to a directory to store files"
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.task_stash_job:1
msgid "Transport task that will optionally stash files of a completed job calculation on the remote."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.task_stash_job:11
msgid "Return if the tasks was successfully completed"
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.task_submit_job:1
msgid "Transport task that will attempt to submit a job calculation."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.task_update_job:1
msgid "Transport task that will attempt to update the scheduler status of the job calculation."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.task_update_job:9
msgid "The job manager"
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.task_upload_job:1
msgid "Transport task that will attempt to upload the files of a job calculation to the remote."
msgstr ""

#: ../../../src/aiida/engine/processes/calcjobs/tasks.py:docstring of aiida.engine.processes.calcjobs.tasks.task_upload_job:8
msgid "the job calculation"
msgstr ""

#: ../../source/reference/apidoc/aiida.engine.processes.workchains.rst:2
msgid "aiida.engine.processes.workchains package"
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/__init__.py:docstring of aiida.engine.processes.workchains:1
msgid "Module for the `WorkChain` process and related utilities."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/awaitable.py:docstring of aiida.engine.processes.workchains.awaitable:1
msgid "Enums and function for the awaitables of Processes."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/awaitable.py:docstring of aiida.engine.processes.workchains.awaitable.Awaitable:1
msgid "Bases: :py:class:`~plumpy.utils.AttributesDict`"
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/awaitable.py:docstring of aiida.engine.processes.workchains.awaitable.Awaitable:1
msgid "An attribute dictionary that represents an action that a Process could be waiting for to finish."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/awaitable.py:docstring of aiida.engine.processes.workchains.awaitable.AwaitableAction:1
msgid "Enum that describes the action to be taken for a given awaitable."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/awaitable.py:docstring of aiida.engine.processes.workchains.awaitable.AwaitableTarget:1
msgid "Enum that describes the class of the target a given awaitable."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/awaitable.py:docstring of aiida.engine.processes.workchains.awaitable.construct_awaitable:1
msgid "Construct an instance of the Awaitable class that will contain the information related to the action to be taken with respect to the context once the awaitable object is completed."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/awaitable.py:docstring of aiida.engine.processes.workchains.awaitable.construct_awaitable:5
msgid "The awaitable is a simple dictionary with the following keys"
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/awaitable.py:docstring of aiida.engine.processes.workchains.awaitable.construct_awaitable:7
msgid "pk: the pk of the node that is being waited on"
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/awaitable.py:docstring of aiida.engine.processes.workchains.awaitable.construct_awaitable:8
msgid "action: the context action to be performed upon completion"
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/awaitable.py:docstring of aiida.engine.processes.workchains.awaitable.construct_awaitable:9
msgid "outputs: a boolean that toggles whether the node itself"
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/awaitable.py:docstring of aiida.engine.processes.workchains.awaitable.construct_awaitable:11
msgid "Currently the only awaitable classes are ProcessNode and Workflow The only awaitable actions are the Assign and Append operators"
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/context.py:docstring of aiida.engine.processes.workchains.context:1
msgid "Convenience functions to add awaitables to the Context of a WorkChain."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/context.py:docstring of aiida.engine.processes.workchains.context.append_:1
msgid "Convenience function that will construct an Awaitable for a given class instance with the context action set to APPEND. When the awaitable target is completed it will be appended to a list in the context for a key that is to be defined later"
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/context.py:docstring of aiida.engine.processes.workchains.context.append_:5
#: ../../../src/aiida/engine/processes/workchains/context.py:docstring of aiida.engine.processes.workchains.context.assign_:5
msgid "an instance of a Process or Awaitable"
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/context.py:docstring of aiida.engine.processes.workchains.context.append_:7
#: ../../../src/aiida/engine/processes/workchains/context.py:docstring of aiida.engine.processes.workchains.context.assign_:7
msgid "the awaitable"
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/context.py:docstring of aiida.engine.processes.workchains.context.assign_:1
msgid "Convenience function that will construct an Awaitable for a given class instance with the context action set to ASSIGN. When the awaitable target is completed it will be assigned to the context for a key that is to be defined later"
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/restart.py:docstring of aiida.engine.processes.workchains.restart:1
msgid "Base implementation of `WorkChain` class that implements a simple automated restart mechanism for sub processes."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/restart.py:docstring of aiida.engine.processes.workchains.restart.BaseRestartWorkChain:1
#: ../../../src/aiida/workflows/arithmetic/multiply_add.py:docstring of aiida.workflows.arithmetic.multiply_add.MultiplyAddWorkChain:1
msgid "Bases: :py:class:`~aiida.engine.processes.workchains.workchain.WorkChain`"
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/restart.py:docstring of aiida.engine.processes.workchains.restart.BaseRestartWorkChain:1
msgid "Base restart work chain."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/restart.py:docstring of aiida.engine.processes.workchains.restart.BaseRestartWorkChain:3
msgid "This work chain serves as the starting point for more complex work chains that will be designed to run a sub process that might need multiple restarts to come to a successful end. These restarts may be necessary because a single process run is not sufficient to achieve a fully converged result, or certain errors maybe encountered which are recoverable."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/restart.py:docstring of aiida.engine.processes.workchains.restart.BaseRestartWorkChain:8
msgid "This work chain implements the most basic functionality to achieve this goal. It will launch the sub process, restarting until it is completed successfully or the maximum number of iterations is reached. After completion of the sub process it will be inspected, and a list of process handlers are called successively. These process handlers are defined as class methods that are decorated with :meth:`~aiida.engine.process_handler`."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/restart.py:docstring of aiida.engine.processes.workchains.restart.BaseRestartWorkChain:13
msgid "The idea is to sub class this work chain and leverage the generic error handling that is implemented in the few outline methods. The minimally required outline would look something like the following::"
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/restart.py:docstring of aiida.engine.processes.workchains.restart.BaseRestartWorkChain:22
msgid "Each of these methods can of course be overriden but they should be general enough to fit most process cycles. The `run_process` method will take the inputs for the process from the context under the key `inputs`. The user should, therefore, make sure that before the `run_process` method is called, that the to be used inputs are stored under `self.ctx.inputs`. One can update the inputs based on the results from a prior process by calling an outline method just before the `run_process` step, for example::"
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/restart.py:docstring of aiida.engine.processes.workchains.restart.BaseRestartWorkChain:35
msgid "Where in the `prepare_calculation` method, the inputs dictionary at `self.ctx.inputs` is updated before the next process will be run with those inputs."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/restart.py:docstring of aiida.engine.processes.workchains.restart.BaseRestartWorkChain:38
msgid "The `_process_class` attribute should be set to the `Process` class that should be run in the loop. Finally, to define handlers that will be called during the `inspect_process` simply define a class method with the signature `(self, node)` and decorate it with the `process_handler` decorator, for example::"
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/restart.py:docstring of aiida.engine.processes.workchains.restart.BaseRestartWorkChain:48
msgid "The `process_handler` and `ProcessHandlerReport` support various arguments to control the flow of the logic of the `inspect_process`. Refer to their respective documentation for details."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/restart.py:docstring of aiida.engine.processes.workchains.restart.BaseRestartWorkChain.__init__:1
msgid "Construct the instance."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/restart.py:docstring of aiida.engine.processes.workchains.restart.BaseRestartWorkChain._attach_outputs:1
msgid "Attach the outputs of the given calculation job to the work chain."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/restart.py:docstring of aiida.engine.processes.workchains.restart.BaseRestartWorkChain._attach_outputs:3
msgid "The ``CalcJobNode`` whose outputs to attach."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/restart.py:docstring of aiida.engine.processes.workchains.restart.BaseRestartWorkChain._attach_outputs:4
msgid "The mapping of output nodes that were attached."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/restart.py:docstring of aiida.engine.processes.workchains.restart.BaseRestartWorkChain._wrap_bare_dict_inputs:1
msgid "Wrap bare dictionaries in `inputs` in a `Dict` node if dictated by the corresponding inputs portnamespace."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/restart.py:docstring of aiida.engine.processes.workchains.restart.BaseRestartWorkChain._wrap_bare_dict_inputs:3
msgid "a `PortNamespace`"
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/restart.py:docstring of aiida.engine.processes.workchains.restart.BaseRestartWorkChain._wrap_bare_dict_inputs:4
msgid "a dictionary of inputs intended for submission of the process"
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/restart.py:docstring of aiida.engine.processes.workchains.restart.BaseRestartWorkChain._wrap_bare_dict_inputs:5
msgid "an attribute dictionary with all bare dictionaries wrapped in `Dict` if dictated by the port namespace"
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/restart.py:docstring of aiida.engine.processes.workchains.restart.BaseRestartWorkChain.define:1
msgid "Define the process specification."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/restart.py:docstring of aiida.engine.processes.workchains.restart.BaseRestartWorkChain.get_outputs:1
msgid "Return a mapping of the outputs that should be attached as outputs to the work chain."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/restart.py:docstring of aiida.engine.processes.workchains.restart.BaseRestartWorkChain.get_outputs:3
msgid "By default this method returns the outputs of the last completed calculation job. This method can be overridden if the implementation wants to update those outputs before attaching them. Make sure that if the content of an output node is modified that this is done through a calcfunction in order to not lose the provenance."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/restart.py:docstring of aiida.engine.processes.workchains.restart.BaseRestartWorkChain.get_process_handlers_by_priority:1
msgid "Return list of process handlers where overrides from ``inputs.handler_overrides`` are taken into account."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/restart.py:docstring of aiida.engine.processes.workchains.restart.BaseRestartWorkChain.inspect_process:1
msgid "Analyse the results of the previous process and call the handlers when necessary."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/restart.py:docstring of aiida.engine.processes.workchains.restart.BaseRestartWorkChain.inspect_process:3
msgid "If the process is excepted or killed, the work chain will abort. Otherwise any attached handlers will be called in order of their specified priority. If the process was failed and no handler returns a report indicating that the error was handled, it is considered an unhandled process failure and the process is relaunched. If this happens twice in a row, the work chain is aborted. In the case that at least one handler returned a report the following matrix determines the logic that is followed:"
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/restart.py:docstring of aiida.engine.processes.workchains.restart.BaseRestartWorkChain.inspect_process:9
msgid "Process  Handler    Handler     Action result   report?    exit code ----------------------------------------- Success      yes        == 0     Restart Success      yes        != 0     Abort Failed       yes        == 0     Restart Failed       yes        != 0     Abort"
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/restart.py:docstring of aiida.engine.processes.workchains.restart.BaseRestartWorkChain.inspect_process:17
msgid "If no handler returned a report and the process finished successfully, the work chain's work is considered done and it will move on to the next step that directly follows the `while` conditional, if there is one defined in the outline."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/restart.py:docstring of aiida.engine.processes.workchains.restart.BaseRestartWorkChain.is_process_handler:1
msgid "Return whether the given method name corresponds to a process handler of this class."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/restart.py:docstring of aiida.engine.processes.workchains.restart.BaseRestartWorkChain.is_process_handler:3
msgid "string name of the instance method"
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/restart.py:docstring of aiida.engine.processes.workchains.restart.BaseRestartWorkChain.is_process_handler:4
msgid "boolean, True if corresponds to process handler, False otherwise"
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/restart.py:docstring of aiida.engine.processes.workchains.restart.BaseRestartWorkChain.on_terminated:1
msgid "Clean the working directories of all child calculation jobs if `clean_workdir=True` in the inputs."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/restart.py:docstring of aiida.engine.processes.workchains.restart.BaseRestartWorkChain.process_class:1
msgid "Return the process class to run in the loop."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/restart.py:docstring of aiida.engine.processes.workchains.restart.BaseRestartWorkChain.results:1
msgid "Attach the outputs specified in the output specification from the last completed process."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/restart.py:docstring of aiida.engine.processes.workchains.restart.BaseRestartWorkChain.run_process:1
msgid "Run the next process, taking the input dictionary from the context at `self.ctx.inputs`."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/restart.py:docstring of aiida.engine.processes.workchains.restart.BaseRestartWorkChain.setup:1
msgid "Initialize context variables that are used during the logical flow of the `BaseRestartWorkChain`."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/restart.py:docstring of aiida.engine.processes.workchains.restart.BaseRestartWorkChain.should_run_process:1
msgid "Return whether a new process should be run."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/restart.py:docstring of aiida.engine.processes.workchains.restart.BaseRestartWorkChain.should_run_process:3
msgid "This is the case as long as the last process has not finished successfully and the maximum number of restarts has not yet been exceeded."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/restart.py:docstring of aiida.engine.processes.workchains.restart.validate_handler_overrides:1
msgid "Validator for the ``handler_overrides`` input port of the ``BaseRestartWorkChain``."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/restart.py:docstring of aiida.engine.processes.workchains.restart.validate_handler_overrides:3
msgid "The ``handler_overrides`` should be a dictionary where keys are strings that are the name of a process handler, i.e. an instance method of the ``process_class`` that has been decorated with the ``process_handler`` decorator. The values should be a dictionary that can specify the keys ``enabled`` and ``priority``."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/restart.py:docstring of aiida.engine.processes.workchains.restart.validate_handler_overrides:7
msgid "the normal signature of a port validator is ``(value, ctx)`` but since for the validation here we need a reference to the process class, we add it and the class is bound to the method in the port declaration in the ``define`` method."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/restart.py:docstring of aiida.engine.processes.workchains.restart.validate_handler_overrides:11
msgid "the ``BaseRestartWorkChain`` (sub) class"
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/restart.py:docstring of aiida.engine.processes.workchains.restart.validate_handler_overrides:12
msgid "the input ``Dict`` node"
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/restart.py:docstring of aiida.engine.processes.workchains.restart.validate_handler_overrides:13
msgid "the ``PortNamespace`` in which the port is embedded"
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/utils.py:docstring of aiida.engine.processes.workchains.utils:1
msgid "Utilities for `WorkChain` implementations."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/utils.py:docstring of aiida.engine.processes.workchains.utils.ProcessHandlerReport:1
msgid "A namedtuple to define a process handler report for a :class:`aiida.engine.BaseRestartWorkChain`."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/utils.py:docstring of aiida.engine.processes.workchains.utils.ProcessHandlerReport:3
msgid "This namedtuple should be returned by a process handler of a work chain instance if the condition of the handler was met by the completed process. If no further handling should be performed after this method the `do_break` field should be set to `True`. If the handler encountered a fatal error and the work chain needs to be terminated, an `ExitCode` with non-zero exit status can be set. This exit code is what will be set on the work chain itself. This works because the value of the `exit_code` field returned by the handler, will in turn be returned by the `inspect_process` step and returning a non-zero exit code from any work chain step will instruct the engine to abort the work chain."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/utils.py:docstring of aiida.engine.processes.workchains.utils.ProcessHandlerReport:11
msgid "boolean, set to `True` if no further process handlers should be called, default is `False`"
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/utils.py:docstring of aiida.engine.processes.workchains.utils.ProcessHandlerReport:12
msgid "an instance of the :class:`~aiida.engine.processes.exit_code.ExitCode` tuple. If not explicitly set, the default `ExitCode` will be instantiated, which has status `0` meaning that the work chain step will be considered successful and the work chain will continue to the next step."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/utils.py:docstring of namedtuple_ProcessHandlerReport.ProcessHandlerReport.__new__:1
msgid "Create new instance of ProcessHandlerReport(do_break, exit_code)"
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/utils.py:docstring of collections.ProcessHandlerReport._make:1
msgid "Make a new ProcessHandlerReport object from a sequence or iterable"
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/utils.py:docstring of collections.ProcessHandlerReport._replace:1
msgid "Return a new ProcessHandlerReport object replacing specified fields with new values"
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/utils.py:docstring of aiida.engine.processes.workchains.utils.process_handler:1
msgid "Decorator to register a :class:`~aiida.engine.BaseRestartWorkChain` instance method as a process handler."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/utils.py:docstring of aiida.engine.processes.workchains.utils.process_handler:3
msgid "The decorator will validate the `priority` and `exit_codes` optional keyword arguments and then add itself as an attribute to the `wrapped` instance method. This is used in the `inspect_process` to return all instance methods of the class that have been decorated by this function and therefore are considered to be process handlers."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/utils.py:docstring of aiida.engine.processes.workchains.utils.process_handler:7
msgid "Requirements on the function signature of process handling functions. The function to which the decorator is applied needs to take two arguments:"
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/utils.py:docstring of aiida.engine.processes.workchains.utils.process_handler:10
msgid "`self`: This is the instance of the work chain itself"
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/utils.py:docstring of aiida.engine.processes.workchains.utils.process_handler:11
msgid "`node`: This is the process node that finished and is to be investigated"
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/utils.py:docstring of aiida.engine.processes.workchains.utils.process_handler:13
msgid "The function body typically consists of a conditional that will check for a particular problem that might have occurred for the sub process. If a particular problem is handled, the process handler should return an instance of the :class:`aiida.engine.ProcessHandlerReport` tuple. If no other process handlers should be considered, the set `do_break` attribute should be set to `True`. If the work chain is to be aborted entirely, the `exit_code` of the report can be set to an `ExitCode` instance with a non-zero status."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/utils.py:docstring of aiida.engine.processes.workchains.utils.process_handler:19
msgid "the work chain method to register the process handler with"
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/utils.py:docstring of aiida.engine.processes.workchains.utils.process_handler:20
msgid "optional integer that defines the order in which registered handlers will be called during the handling of a finished process. Higher priorities will be handled first. Default value is `0`. Multiple handlers with the same priority is allowed, but the order of those is not well defined."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/utils.py:docstring of aiida.engine.processes.workchains.utils.process_handler:23
msgid "single or list of `ExitCode` instances. If defined, the handler will return `None` if the exit code set on the `node` does not appear in the `exit_codes`. This is useful to have a handler called only when the process failed with a specific exit code."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/utils.py:docstring of aiida.engine.processes.workchains.utils.process_handler:26
msgid "boolean, by default True, which will cause the handler to be called during `inspect_process`. When set to `False`, the handler will be skipped. This static value can be overridden on a per work chain instance basis through the input `handler_overrides`."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/workchain.py:docstring of aiida.engine.processes.workchains.workchain:1
msgid "Components for the WorkChain concept of the workflow engine."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/workchain.py:docstring of aiida.engine.processes.workchains.workchain.Protect:1
msgid "Bases: :py:class:`~plumpy.processes.ProcessStateMachineMeta`"
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/workchain.py:docstring of aiida.engine.processes.workchains.workchain.Protect:1
msgid "Metaclass that allows protecting class methods from being overridden by subclasses."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/workchain.py:docstring of aiida.engine.processes.workchains.workchain.Protect:3
msgid "Usage as follows::"
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/workchain.py:docstring of aiida.engine.processes.workchains.workchain.Protect:11
msgid "If a subclass is imported that overrides the subclass, a ``RuntimeError`` is raised."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/workchain.py:docstring of aiida.engine.processes.workchains.workchain.Protect.__is_final:1
msgid "Return whether the method has been decorated by the ``final`` classmethod."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/workchain.py:docstring of aiida.engine.processes.workchains.workchain.Protect.__is_final:3
msgid "Boolean, ``True`` if the method is marked as final, ``False`` otherwise."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/workchain.py:docstring of aiida.engine.processes.workchains.workchain.Protect.__new__:1
msgid "Collect all methods that were marked as protected and raise if the subclass defines it."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/workchain.py:docstring of aiida.engine.processes.workchains.workchain.Protect.__new__:3
msgid "If the new class defines (i.e. overrides) a method that was decorated with ``final``."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/workchain.py:docstring of aiida.engine.processes.workchains.workchain.Protect.final:1
msgid "Decorate a method with this method to protect it from being overridden."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/workchain.py:docstring of aiida.engine.processes.workchains.workchain.Protect.final:3
msgid "Adds the ``__SENTINEL`` object as the ``__final`` private attribute to the given ``method`` and wraps it in the ``typing.final`` decorator. The latter indicates to typing systems that it cannot be overridden in subclasses."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/workchain.py:docstring of aiida.engine.processes.workchains.workchain.WorkChain:1
msgid "The `WorkChain` class is the principle component to implement workflows in AiiDA."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/workchain.py:docstring of aiida.engine.processes.workchains.workchain.WorkChain.__init__:1
msgid "Construct a WorkChain instance."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/workchain.py:docstring of aiida.engine.processes.workchains.workchain.WorkChain.__init__:3
msgid "Construct the instance only if it is a sub class of `WorkChain`, otherwise raise `InvalidOperation`."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/workchain.py:docstring of aiida.engine.processes.workchains.workchain.WorkChain.__init__:5
msgid "work chain inputs"
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/workchain.py:docstring of aiida.engine.processes.workchains.workchain.WorkChain.__init__:7
msgid "work chain runner"
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/workchain.py:docstring of aiida.engine.processes.workchains.workchain.WorkChain.__init__:8
msgid "whether to persist this work chain"
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/workchain.py:docstring of aiida.engine.processes.workchains.workchain.WorkChain._action_awaitables:1
msgid "Handle the awaitables that are currently registered with the work chain."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/workchain.py:docstring of aiida.engine.processes.workchains.workchain.WorkChain._action_awaitables:3
msgid "Depending on the class type of the awaitable's target a different callback function will be bound with the awaitable and the runner will be asked to call it when the target is completed"
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/workchain.py:docstring of aiida.engine.processes.workchains.workchain.WorkChain._do_step:1
msgid "Execute the next step in the outline and return the result."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/workchain.py:docstring of aiida.engine.processes.workchains.workchain.WorkChain._do_step:3
msgid "If the stepper returns a non-finished status and the return value is of type ToContext, the contents of the ToContext container will be turned into awaitables if necessary. If any awaitables were created, the process will enter in the Wait state, otherwise it will go to Continue. When the stepper returns that it is done, the stepper result will be converted to None and returned, unless it is an integer or instance of ExitCode."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/workchain.py:docstring of aiida.engine.processes.workchains.workchain.WorkChain._insert_awaitable:1
msgid "Insert an awaitable that should be terminated before before continuing to the next step."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/workchain.py:docstring of aiida.engine.processes.workchains.workchain.WorkChain._insert_awaitable:3
msgid "the thing to await"
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/workchain.py:docstring of aiida.engine.processes.workchains.workchain.WorkChain._on_awaitable_finished:1
msgid "Callback function, for when an awaitable process instance is completed."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/workchain.py:docstring of aiida.engine.processes.workchains.workchain.WorkChain._on_awaitable_finished:3
msgid "The awaitable will be effectuated on the context of the work chain and removed from the internal list. If all awaitables have been dealt with, the work chain process is resumed."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/workchain.py:docstring of aiida.engine.processes.workchains.workchain.WorkChain._on_awaitable_finished:6
msgid "an Awaitable instance"
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/workchain.py:docstring of aiida.engine.processes.workchains.workchain.WorkChain._resolve_awaitable:1
msgid "Resolve an awaitable."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/workchain.py:docstring of aiida.engine.processes.workchains.workchain.WorkChain._resolve_awaitable:3
msgid "Precondition: must be an awaitable that was previously inserted."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/workchain.py:docstring of aiida.engine.processes.workchains.workchain.WorkChain._resolve_awaitable:5
msgid "the awaitable to resolve"
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/workchain.py:docstring of aiida.engine.processes.workchains.workchain.WorkChain._resolve_nested_context:1
msgid "Returns a reference to a sub-dictionary of the context and the last key, after resolving a potentially segmented key where required sub-dictionaries are created as needed."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/workchain.py:docstring of aiida.engine.processes.workchains.workchain.WorkChain._resolve_nested_context:4
msgid "A key into the context, where words before a dot are interpreted as a key for a sub-dictionary"
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/workchain.py:docstring of aiida.engine.processes.workchains.workchain.WorkChain._store_nodes:1
msgid "Recurse through a data structure and store any unstored nodes that are found along the way"
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/workchain.py:docstring of aiida.engine.processes.workchains.workchain.WorkChain._store_nodes:3
msgid "a data structure potentially containing unstored nodes"
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/workchain.py:docstring of aiida.engine.processes.workchains.workchain.WorkChain._update_process_status:1
msgid "Set the process status with a message accounting the current sub processes that we are waiting for."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/workchain.py:docstring of aiida.engine.processes.workchains.workchain.WorkChain.ctx:1
msgid "Get the context."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/workchain.py:docstring of aiida.engine.processes.workchains.workchain.WorkChain.on_exiting:1
msgid "Ensure that any unstored nodes in the context are stored, before the state is exited"
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/workchain.py:docstring of aiida.engine.processes.workchains.workchain.WorkChain.on_exiting:3
msgid "After the state is exited the next state will be entered and if persistence is enabled, a checkpoint will be saved. If the context contains unstored nodes, the serialization necessary for checkpointing will fail."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/workchain.py:docstring of aiida.engine.processes.workchains.workchain.WorkChain.on_wait:1
msgid "Entering the WAITING state."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/workchain.py:docstring of aiida.engine.processes.workchains.workchain.WorkChain.run:1
msgid "This function will be run when the process is triggered. It should be overridden by a subclass."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/workchain.py:docstring of aiida.engine.processes.workchains.workchain.WorkChain.save_instance_state:3
msgid "state to save in"
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/workchain.py:docstring of aiida.engine.processes.workchains.workchain.WorkChain.to_context:1
msgid "Add a dictionary of awaitables to the context."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/workchain.py:docstring of aiida.engine.processes.workchains.workchain.WorkChain.to_context:3
msgid "This is a convenience method that provides syntactic sugar, for a user to add multiple intersteps that will assign a certain value to the corresponding key in the context of the work chain."
msgstr ""

#: ../../../src/aiida/engine/processes/workchains/workchain.py:docstring of aiida.engine.processes.workchains.workchain.WorkChainSpec:1
msgid "Bases: :py:class:`~aiida.engine.processes.process_spec.ProcessSpec`, :py:class:`~plumpy.workchains.WorkChainSpec`"
msgstr ""

#: ../../source/reference/apidoc/aiida.manage.rst:2
msgid "aiida.manage package"
msgstr ""

#: ../../../src/aiida/manage/__init__.py:docstring of aiida.manage:1
msgid "Managing an AiiDA instance:"
msgstr ""

#: ../../../src/aiida/manage/__init__.py:docstring of aiida.manage:3
msgid "configuration file"
msgstr ""

#: ../../../src/aiida/manage/__init__.py:docstring of aiida.manage:4
msgid "profiles"
msgstr ""

#: ../../../src/aiida/manage/__init__.py:docstring of aiida.manage:5
msgid "databases"
msgstr ""

#: ../../../src/aiida/manage/__init__.py:docstring of aiida.manage:6
msgid "repositories"
msgstr ""

#: ../../../src/aiida/manage/__init__.py:docstring of aiida.manage:7
msgid "external components (such as Postgres, RabbitMQ)"
msgstr ""

#: ../../../src/aiida/manage/__init__.py:docstring of aiida.manage:9
#: ../../../src/aiida/tools/__init__.py:docstring of aiida.tools:9
msgid "Modules in this sub package may require the database environment to be loaded"
msgstr ""

#: ../../../src/aiida/manage/caching.py:docstring of aiida.manage.caching:1
msgid "Definition of caching mechanism and configuration for calculations."
msgstr ""

#: ../../../src/aiida/manage/caching.py:docstring of aiida.manage.caching.ConfigKeys:1
msgid "Valid keys for caching configuration."
msgstr ""

#: ../../../src/aiida/manage/caching.py:docstring of aiida.manage.caching._ContextCache:1
msgid "Cache options, accounting for when in enable_caching or disable_caching contexts."
msgstr ""

#: ../../../src/aiida/manage/caching.py:docstring of aiida.manage.caching._ContextCache.clear:1
msgid "Clear caching overrides."
msgstr ""

#: ../../../src/aiida/manage/caching.py:docstring of aiida.manage.caching._ContextCache.get_options:1
msgid "Return the options, applying any context overrides."
msgstr ""

#: ../../../src/aiida/manage/caching.py:docstring of aiida.manage.caching._ContextCache.get_options:3
#: ../../../src/aiida/manage/caching.py:docstring of aiida.manage.caching._validate_identifier_pattern:19
#: ../../../src/aiida/manage/caching.py:docstring of aiida.manage.caching.disable_caching:7
#: ../../../src/aiida/manage/caching.py:docstring of aiida.manage.caching.enable_caching:7
#: ../../../src/aiida/manage/caching.py:docstring of aiida.manage.caching.get_use_cache:4
msgid "When set to ``True``, the function will actually try to resolve the identifier by loading it and if it fails, an exception is raised."
msgstr ""

#: ../../../src/aiida/manage/caching.py:docstring of aiida.manage.caching._match_wildcard:1
msgid "Return whether a given name matches a pattern which can contain '*' wildcards."
msgstr ""

#: ../../../src/aiida/manage/caching.py:docstring of aiida.manage.caching._match_wildcard:3
msgid "The string to check."
msgstr ""

#: ../../../src/aiida/manage/caching.py:docstring of aiida.manage.caching._match_wildcard:4
msgid "The patter to match for."
msgstr ""

#: ../../../src/aiida/manage/caching.py:docstring of aiida.manage.caching._match_wildcard:5
msgid "``True`` if ``string`` matches the ``pattern``, ``False`` otherwise."
msgstr ""

#: ../../../src/aiida/manage/caching.py:docstring of aiida.manage.caching._validate_identifier_pattern:1
msgid "Validate an caching identifier pattern."
msgstr ""

#: ../../../src/aiida/manage/caching.py:docstring of aiida.manage.caching._validate_identifier_pattern:3
msgid "The identifier (without wildcards) can have one of two forms:"
msgstr ""

#: ../../../src/aiida/manage/caching.py:docstring of aiida.manage.caching._validate_identifier_pattern:5
msgid "<group_name><ENTRY_POINT_STRING_SEPARATOR><tail>"
msgstr ""

#: ../../../src/aiida/manage/caching.py:docstring of aiida.manage.caching._validate_identifier_pattern:7
msgid "where `group_name` is one of the keys in `ENTRY_POINT_GROUP_TO_MODULE_PATH_MAP` and `tail` can be anything _except_ `ENTRY_POINT_STRING_SEPARATOR`."
msgstr ""

#: ../../../src/aiida/manage/caching.py:docstring of aiida.manage.caching._validate_identifier_pattern:10
msgid "a fully qualified Python name"
msgstr ""

#: ../../../src/aiida/manage/caching.py:docstring of aiida.manage.caching._validate_identifier_pattern:12
msgid "this is a colon-separated string, where each part satisfies `part.isidentifier() and not keyword.iskeyword(part)`"
msgstr ""

#: ../../../src/aiida/manage/caching.py:docstring of aiida.manage.caching._validate_identifier_pattern:15
msgid "This function checks if an identifier _with_ wildcards can possibly match one of these two forms. If it can not, a ``ValueError`` is raised."
msgstr ""

#: ../../../src/aiida/manage/caching.py:docstring of aiida.manage.caching._validate_identifier_pattern:18
msgid "Process type string, or a pattern with '*' wildcard that matches it."
msgstr ""

#: ../../../src/aiida/manage/caching.py:docstring of aiida.manage.caching._validate_identifier_pattern:21
msgid "If the identifier is an invalid identifier."
msgstr ""

#: ../../../src/aiida/manage/caching.py:docstring of aiida.manage.caching._validate_identifier_pattern:22
msgid "If ``strict=True`` and the identifier cannot be successfully loaded."
msgstr ""

#: ../../../src/aiida/manage/caching.py:docstring of aiida.manage.caching.disable_caching:1
msgid "Context manager to disable caching, either for a specific node class, or globally."
msgstr ""

#: ../../../src/aiida/manage/caching.py:docstring of aiida.manage.caching.disable_caching:3
#: ../../../src/aiida/manage/caching.py:docstring of aiida.manage.caching.enable_caching:3
msgid "this does not affect the behavior of the daemon, only the local Python interpreter."
msgstr ""

#: ../../../src/aiida/manage/caching.py:docstring of aiida.manage.caching.disable_caching:5
msgid "Process type string of the node, or a pattern with '*' wildcard that matches it. If not provided, caching is disabled for all classes."
msgstr ""

#: ../../../src/aiida/manage/caching.py:docstring of aiida.manage.caching.enable_caching:1
msgid "Context manager to enable caching, either for a specific node class, or globally."
msgstr ""

#: ../../../src/aiida/manage/caching.py:docstring of aiida.manage.caching.enable_caching:5
msgid "Process type string of the node, or a pattern with '*' wildcard that matches it. If not provided, caching is enabled for all classes."
msgstr ""

#: ../../../src/aiida/manage/caching.py:docstring of aiida.manage.caching.get_use_cache:1
msgid "Return whether the caching mechanism should be used for the given process type according to the configuration."
msgstr ""

#: ../../../src/aiida/manage/caching.py:docstring of aiida.manage.caching.get_use_cache:3
msgid "Process type string of the node"
msgstr ""

#: ../../../src/aiida/manage/caching.py:docstring of aiida.manage.caching.get_use_cache:6
msgid "boolean, True if caching is enabled, False otherwise"
msgstr ""

#: ../../../src/aiida/manage/caching.py:docstring of aiida.manage.caching.get_use_cache:7
msgid "`~aiida.common.exceptions.ConfigurationError` if the configuration is invalid, either due to a general configuration error, or by defining the class both enabled and disabled"
msgstr ""

#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager:1
msgid "AiiDA manager for global settings"
msgstr ""

#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager:1
msgid "Manager singleton for globally loaded resources."
msgstr ""

#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager:3
msgid "AiiDA can have the following global resources loaded:"
msgstr ""

#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager:5
msgid "A single configuration object that contains:"
msgstr ""

#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager:7
msgid "Global options overrides"
msgstr ""

#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager:8
msgid "The name of a default profile"
msgstr ""

#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager:9
msgid "A mapping of profile names to their configuration and option overrides"
msgstr ""

#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager:11
msgid "A single profile object that contains:"
msgstr ""

#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager:13
msgid "The name of the profile"
msgstr ""

#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager:14
msgid "The UUID of the profile"
msgstr ""

#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager:15
msgid "The configuration of the profile, for connecting to storage and processing resources"
msgstr ""

#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager:16
msgid "The option overrides for the profile"
msgstr ""

#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager:18
msgid "3. A single storage backend object for the profile, to connect to data storage resources 5. A single daemon client object for the profile, to connect to the AiiDA daemon 4. A single communicator object for the profile, to connect to the process control resources 6. A single process controller object for the profile, which uses the communicator to control process tasks 7. A single runner object for the profile, which uses the process controller to start and stop processes 8. A single persister object for the profile, which can persist running processes to the profile storage"
msgstr ""

#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.check_rabbitmq_version:1
msgid "Check the version of RabbitMQ that is being connected to and emit warning if it is not compatible."
msgstr ""

#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.check_version:1
msgid "Check the currently installed version of ``aiida-core`` and warn if it is a post release development version."
msgstr ""

#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.check_version:3
msgid "The ``aiida-core`` package maintains the protocol that the ``main`` branch will use a post release version number. This means it will always append `.post0` to the version of the latest release. This should mean that if this protocol is maintained properly, this method will print a warning if the currently installed version is a post release development branch and not an actual release."
msgstr ""

#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.create_communicator:1
msgid "Create a Communicator."
msgstr ""

#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.create_communicator:3
msgid "optional specify how many tasks this communicator take simultaneously"
msgstr ""

#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.create_communicator:5
msgid "the communicator instance"
msgstr ""

#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.create_daemon_runner:1
msgid "Create and return a new daemon runner."
msgstr ""

#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.create_daemon_runner:3
msgid "This is used by workers when the daemon is running and in testing."
msgstr ""

#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.create_daemon_runner:5
msgid "the (optional) asyncio event loop to use"
msgstr ""

#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.create_daemon_runner:7
msgid "a runner configured to work in the daemon configuration"
msgstr ""

#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.create_runner:1
msgid "Create and return a new runner"
msgstr ""

#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.create_runner:3
msgid "create a runner with persistence enabled"
msgstr ""

#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.create_runner:5
msgid "a new runner instance"
msgstr ""

#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.get_backend:1
#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.get_profile_storage:1
msgid "Return the current profile's storage backend, loading it if necessary."
msgstr ""

#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.get_backend:3
msgid "Deprecated: use `get_profile_storage` instead."
msgstr ""

#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.get_communicator:1
msgid "Return the communicator"
msgstr ""

#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.get_communicator:3
msgid "a global communicator instance"
msgstr ""

#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.get_config:1
msgid "Return the current config."
msgstr ""

#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.get_config:3
msgid "current loaded config instance"
msgstr ""

#: ../../../src/aiida/manage/configuration/__init__.py:docstring of aiida.manage.configuration.get_config:16
#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.get_config:4
msgid "if the configuration file could not be found, read or deserialized"
msgstr ""

#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.get_daemon_client:1
msgid "Return the daemon client for the current profile."
msgstr ""

#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.get_daemon_client:3
msgid "the daemon client"
msgstr ""

#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.get_daemon_client:5
msgid "if the configuration file cannot be found"
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.remove_profile:4
#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.set_default_profile:5
#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.get_daemon_client:6
msgid "if the given profile does not exist"
msgstr ""

#: ../../../src/aiida/manage/configuration/__init__.py:docstring of aiida.manage.configuration.get_config_option:1
#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.get_option:1
msgid "Return the value of a configuration option."
msgstr ""

#: ../../../src/aiida/manage/configuration/__init__.py:docstring of aiida.manage.configuration.get_config_option:3
#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.get_option:3
msgid "In order of priority, the option is returned from:"
msgstr ""

#: ../../../src/aiida/manage/configuration/__init__.py:docstring of aiida.manage.configuration.get_config_option:5
#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.get_option:5
msgid "The current profile, if loaded and the option specified"
msgstr ""

#: ../../../src/aiida/manage/configuration/__init__.py:docstring of aiida.manage.configuration.get_config_option:6
#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.get_option:6
msgid "The current configuration, if loaded and the option specified"
msgstr ""

#: ../../../src/aiida/manage/configuration/__init__.py:docstring of aiida.manage.configuration.get_config_option:7
#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.get_option:7
msgid "The default value for the option"
msgstr ""

#: ../../../src/aiida/manage/configuration/__init__.py:docstring of aiida.manage.configuration.get_config_option:9
#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.get_option:9
msgid "the name of the option to return"
msgstr ""

#: ../../../src/aiida/manage/configuration/__init__.py:docstring of aiida.manage.configuration.get_config_option:10
#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.get_option:10
msgid "the value of the option"
msgstr ""

#: ../../../src/aiida/manage/configuration/__init__.py:docstring of aiida.manage.configuration.get_config_option:11
#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.get_option:11
msgid "if the option is not found"
msgstr ""

#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.get_persister:1
msgid "Return the persister"
msgstr ""

#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.get_persister:3
msgid "the current persister instance"
msgstr ""

#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.get_process_controller:1
msgid "Return the process controller"
msgstr ""

#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.get_process_controller:3
msgid "the process controller instance"
msgstr ""

#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.get_profile:1
msgid "Return the current loaded profile, if any"
msgstr ""

#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.get_profile:3
msgid "current loaded profile instance"
msgstr ""

#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.get_runner:1
msgid "Return a runner that is based on the current profile settings and can be used globally by the code."
msgstr ""

#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.get_runner:3
msgid "the global runner"
msgstr ""

#: ../../../src/aiida/manage/configuration/__init__.py:docstring of aiida.manage.configuration.load_profile:1
#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.load_profile:1
msgid "Load a global profile, unloading any previously loaded profile."
msgstr ""

#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.load_profile:3
msgid "If a profile is already loaded and no explicit profile is specified, nothing will be done."
msgstr ""

#: ../../../src/aiida/manage/configuration/__init__.py:docstring of aiida.manage.configuration.load_profile:5
#: ../../../src/aiida/manage/configuration/__init__.py:docstring of aiida.manage.configuration.profile_context:3
#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.load_profile:5
msgid "the name of the profile to load, by default will use the one marked as default in the config"
msgstr ""

#: ../../../src/aiida/manage/configuration/__init__.py:docstring of aiida.manage.configuration.load_profile:6
#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.load_profile:6
msgid "if True, will allow switching to a different profile when storage is already loaded"
msgstr ""

#: ../../../src/aiida/manage/configuration/__init__.py:docstring of aiida.manage.configuration.load_profile:8
#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.load_profile:8
msgid "the loaded `Profile` instance"
msgstr ""

#: ../../../src/aiida/manage/configuration/__init__.py:docstring of aiida.manage.configuration.load_profile:9
#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.load_profile:9
msgid "if another profile has already been loaded and allow_switch is False"
msgstr ""

#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.profile_storage_loaded:1
msgid "Return whether a storage backend has been loaded."
msgstr ""

#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.profile_storage_loaded:3
msgid "boolean, True if database backend is currently loaded, False otherwise"
msgstr ""

#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.reset_communicator:1
msgid "Reset the communicator."
msgstr ""

#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.reset_profile:1
msgid "Close and reset any associated resources for the current profile."
msgstr ""

#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.reset_profile_storage:1
msgid "Reset the profile storage."
msgstr ""

#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.reset_profile_storage:3
msgid "This will close any connections to the services used by the storage, such as database connections."
msgstr ""

#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.reset_runner:1
msgid "Reset the process runner."
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.set_default_user_email:1
#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.set_default_user_email:1
msgid "Set the default user for the given profile."
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.set_default_user_email:8
#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.set_default_user_email:3
msgid "The profile to update."
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.set_default_user_email:9
#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.set_default_user_email:4
msgid "The email of the user to set as the default user."
msgstr ""

#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.set_runner:1
msgid "Set the currently used runner"
msgstr ""

#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.set_runner:3
msgid "the new runner to use"
msgstr ""

#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.Manager.unload_profile:1
msgid "Unload the current profile, closing any associated resources."
msgstr ""

#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.get_manager:1
msgid "Return the AiiDA global manager instance."
msgstr ""

#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.get_rabbitmq_version:1
msgid "Return the version of the RabbitMQ server that the current profile connects to."
msgstr ""

#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.get_rabbitmq_version:3
msgid ":class:`packaging.version.Version`"
msgstr ""

#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.is_rabbitmq_version_supported:1
msgid "Return whether the version of RabbitMQ configured for the current profile is supported."
msgstr ""

#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.is_rabbitmq_version_supported:3
msgid "Versions 3.5 and below are not supported at all, whereas versions 3.8.15 and above are not compatible with a default configuration of the RabbitMQ server."
msgstr ""

#: ../../../src/aiida/manage/manager.py:docstring of aiida.manage.manager.is_rabbitmq_version_supported:6
msgid "boolean whether the current RabbitMQ version is supported."
msgstr ""

#: ../../../src/aiida/manage/profile_access.py:docstring of aiida.manage.profile_access:1
msgid "Module for the ProfileAccessManager that tracks process access to the profile."
msgstr ""

#: ../../../src/aiida/manage/profile_access.py:docstring of aiida.manage.profile_access.ProfileAccessManager:1
msgid "Class to manage access to a profile."
msgstr ""

#: ../../../src/aiida/manage/profile_access.py:docstring of aiida.manage.profile_access.ProfileAccessManager:3
msgid "Any process that wants to request access for a given profile, should first call:"
msgstr ""

#: ../../../src/aiida/manage/profile_access.py:docstring of aiida.manage.profile_access.ProfileAccessManager:5
msgid "ProfileAccessManager(profile).request_access()"
msgstr ""

#: ../../../src/aiida/manage/profile_access.py:docstring of aiida.manage.profile_access.ProfileAccessManager:7
msgid "If this returns normally, the profile can be used safely. It will raise if it is locked, in which case the profile should not be used. If a process wants to request exclusive access to the profile, it should use ``lock``:"
msgstr ""

#: ../../../src/aiida/manage/profile_access.py:docstring of aiida.manage.profile_access.ProfileAccessManager:11
msgid "with ProfileAccessManager(profile).lock():"
msgstr ""

#: ../../../src/aiida/manage/profile_access.py:docstring of aiida.manage.profile_access.ProfileAccessManager:11
msgid "pass"
msgstr ""

#: ../../../src/aiida/manage/profile_access.py:docstring of aiida.manage.profile_access.ProfileAccessManager:13
msgid "If the profile is already locked or is currently in use, an exception is raised."
msgstr ""

#: ../../../src/aiida/manage/profile_access.py:docstring of aiida.manage.profile_access.ProfileAccessManager:15
msgid "Access and locks of the profile will be recorded in a directory with files with a ``.pid`` and ``.lock`` extension, respectively. In principle then, at any one time, there can either be a number of pid files, or just a single lock file. If there is a mixture or there are more than one lock files, we are in an inconsistent state."
msgstr ""

#: ../../../src/aiida/manage/profile_access.py:docstring of aiida.manage.profile_access.ProfileAccessManager.__init__:1
msgid "Class that manages access and locks to the given profile."
msgstr ""

#: ../../../src/aiida/manage/profile_access.py:docstring of aiida.manage.profile_access.ProfileAccessManager.__init__:3
msgid "the profile whose access to manage."
msgstr ""

#: ../../../src/aiida/manage/profile_access.py:docstring of aiida.manage.profile_access.ProfileAccessManager._clear_stale_pid_files:1
msgid "Clear any stale PID files."
msgstr ""

#: ../../../src/aiida/manage/profile_access.py:docstring of aiida.manage.profile_access.ProfileAccessManager._get_tracking_files:1
msgid "Return a list of all files that track the accessing and locking of the profile."
msgstr ""

#: ../../../src/aiida/manage/profile_access.py:docstring of aiida.manage.profile_access.ProfileAccessManager._get_tracking_files:3
msgid "To get the files that track locking use `.lock`, to get the files that track access use `.pid`."
msgstr ""

#: ../../../src/aiida/manage/profile_access.py:docstring of aiida.manage.profile_access.ProfileAccessManager._get_tracking_files:6
msgid "If true removes from the returned list any tracking to the current process."
msgstr ""

#: ../../../src/aiida/manage/profile_access.py:docstring of aiida.manage.profile_access.ProfileAccessManager._raise_if_active:1
msgid "Raise a ``LockingProfileError`` if the profile is being accessed."
msgstr ""

#: ../../../src/aiida/manage/profile_access.py:docstring of aiida.manage.profile_access.ProfileAccessManager._raise_if_active:3
#: ../../../src/aiida/manage/profile_access.py:docstring of aiida.manage.profile_access.ProfileAccessManager._raise_if_locked:3
msgid "Text to use as the start of the exception message."
msgstr ""

#: ../../../src/aiida/manage/profile_access.py:docstring of aiida.manage.profile_access.ProfileAccessManager._raise_if_active:4
msgid "if the profile is active."
msgstr ""

#: ../../../src/aiida/manage/profile_access.py:docstring of aiida.manage.profile_access.ProfileAccessManager._raise_if_locked:1
msgid "Raise a ``LockedProfileError`` if the profile is locked."
msgstr ""

#: ../../../src/aiida/manage/profile_access.py:docstring of aiida.manage.profile_access.ProfileAccessManager._raise_if_locked:4
#: ../../../src/aiida/manage/profile_access.py:docstring of aiida.manage.profile_access.ProfileAccessManager.request_access:6
msgid "if the profile is locked."
msgstr ""

#: ../../../src/aiida/manage/profile_access.py:docstring of aiida.manage.profile_access.ProfileAccessManager.clear_locks:1
msgid "Clear all locks on this profile."
msgstr ""

#: ../../../src/aiida/manage/profile_access.py:docstring of aiida.manage.profile_access.ProfileAccessManager.clear_locks:3
msgid "This should only be used if the profile is currently still incorrectly locked because the lock was not automatically released after the ``lock`` contextmanager exited its scope."
msgstr ""

#: ../../../src/aiida/manage/profile_access.py:docstring of aiida.manage.profile_access.ProfileAccessManager.is_active:1
msgid "Return whether the profile is currently in use."
msgstr ""

#: ../../../src/aiida/manage/profile_access.py:docstring of aiida.manage.profile_access.ProfileAccessManager.is_locked:1
msgid "Return whether the profile is locked."
msgstr ""

#: ../../../src/aiida/manage/profile_access.py:docstring of aiida.manage.profile_access.ProfileAccessManager.lock:1
msgid "Request a lock on the profile for exclusive access."
msgstr ""

#: ../../../src/aiida/manage/profile_access.py:docstring of aiida.manage.profile_access.ProfileAccessManager.lock:3
msgid "This context manager should be used if exclusive access to the profile is required. Access will be granted if the profile is currently not in use, nor locked by another process. During the context, the profile will be locked, which will be lifted automatically as soon as the context exits."
msgstr ""

#: ../../../src/aiida/manage/profile_access.py:docstring of aiida.manage.profile_access.ProfileAccessManager.lock:7
msgid "if there are currently active processes using the profile."
msgstr ""

#: ../../../src/aiida/manage/profile_access.py:docstring of aiida.manage.profile_access.ProfileAccessManager.lock:8
msgid "if there currently already is a lock on the profile."
msgstr ""

#: ../../../src/aiida/manage/profile_access.py:docstring of aiida.manage.profile_access.ProfileAccessManager.request_access:1
msgid "Request access to the profile."
msgstr ""

#: ../../../src/aiida/manage/profile_access.py:docstring of aiida.manage.profile_access.ProfileAccessManager.request_access:3
msgid "If the profile is locked, a ``LockedProfileError`` is raised. Otherwise a PID file is created for this process and the function returns ``None``. The PID file contains the command of the process."
msgstr ""

#: ../../source/reference/apidoc/aiida.manage.configuration.rst:2
msgid "aiida.manage.configuration package"
msgstr ""

#: ../../../src/aiida/manage/configuration/__init__.py:docstring of aiida.manage.configuration:1
msgid "Modules related to the configuration of an AiiDA instance."
msgstr ""

#: ../../../src/aiida/manage/configuration/__init__.py:docstring of aiida.manage.configuration._merge_deprecated_cache_yaml:1
msgid "Merge the deprecated cache_config.yml into the config."
msgstr ""

#: ../../../src/aiida/manage/configuration/__init__.py:docstring of aiida.manage.configuration.create_profile:3
msgid "The config instance."
msgstr ""

#: ../../../src/aiida/manage/configuration/__init__.py:docstring of aiida.manage.configuration.create_profile:5
msgid "Name of the profile."
msgstr ""

#: ../../../src/aiida/manage/configuration/__init__.py:docstring of aiida.manage.configuration.create_profile:6
msgid "Email for the default user."
msgstr ""

#: ../../../src/aiida/manage/configuration/__init__.py:docstring of aiida.manage.configuration.create_profile:7
msgid "First name for the default user."
msgstr ""

#: ../../../src/aiida/manage/configuration/__init__.py:docstring of aiida.manage.configuration.create_profile:8
msgid "Last name for the default user."
msgstr ""

#: ../../../src/aiida/manage/configuration/__init__.py:docstring of aiida.manage.configuration.create_profile:9
msgid "Institution for the default user."
msgstr ""

#: ../../../src/aiida/manage/configuration/__init__.py:docstring of aiida.manage.configuration.get_config:1
msgid "Return the current configuration."
msgstr ""

#: ../../../src/aiida/manage/configuration/__init__.py:docstring of aiida.manage.configuration.get_config:6
msgid "If the configuration has not been loaded yet"
msgstr ""

#: ../../../src/aiida/manage/configuration/__init__.py:docstring of aiida.manage.configuration.get_config:4
msgid "the configuration is loaded using ``load_config``"
msgstr ""

#: ../../../src/aiida/manage/configuration/__init__.py:docstring of aiida.manage.configuration.get_config:5
msgid "the global `CONFIG` variable is set"
msgstr ""

#: ../../../src/aiida/manage/configuration/__init__.py:docstring of aiida.manage.configuration.get_config:6
msgid "the configuration object is returned"
msgstr ""

#: ../../../src/aiida/manage/configuration/__init__.py:docstring of aiida.manage.configuration.get_config:8
msgid "Note: This function will except if no configuration file can be found. Only call this function, if you need information from the configuration file."
msgstr ""

#: ../../../src/aiida/manage/configuration/__init__.py:docstring of aiida.manage.configuration.get_config:11
#: ../../../src/aiida/manage/configuration/__init__.py:docstring of aiida.manage.configuration.load_config:6
msgid "if True, will create the configuration file if it does not already exist"
msgstr ""

#: ../../../src/aiida/manage/configuration/__init__.py:docstring of aiida.manage.configuration.get_config:14
#: ../../../src/aiida/manage/configuration/__init__.py:docstring of aiida.manage.configuration.load_config:9
msgid "the config"
msgstr ""

#: ../../../src/aiida/manage/configuration/__init__.py:docstring of aiida.manage.configuration.get_config:15
#: ../../../src/aiida/manage/configuration/__init__.py:docstring of aiida.manage.configuration.load_config:10
msgid ":class:`~aiida.manage.configuration.config.Config`"
msgstr ""

#: ../../../src/aiida/manage/configuration/__init__.py:docstring of aiida.manage.configuration.get_config_path:1
msgid "Returns path to .aiida configuration directory."
msgstr ""

#: ../../../src/aiida/manage/configuration/__init__.py:docstring of aiida.manage.configuration.get_profile:1
msgid "Return the currently loaded profile."
msgstr ""

#: ../../../src/aiida/manage/configuration/__init__.py:docstring of aiida.manage.configuration.get_profile:3
msgid "the globally loaded `Profile` instance or `None`"
msgstr ""

#: ../../../src/aiida/manage/configuration/__init__.py:docstring of aiida.manage.configuration.load_config:1
msgid "Instantiate Config object representing an AiiDA configuration file."
msgstr ""

#: ../../../src/aiida/manage/configuration/__init__.py:docstring of aiida.manage.configuration.load_config:3
msgid "Warning: Contrary to :func:`~aiida.manage.configuration.get_config`, this function is uncached and will always create a new Config object. You may want to call :func:`~aiida.manage.configuration.get_config` instead."
msgstr ""

#: ../../../src/aiida/manage/configuration/__init__.py:docstring of aiida.manage.configuration.load_config:11
msgid "if the configuration file could not be found and create=False"
msgstr ""

#: ../../../src/aiida/manage/configuration/__init__.py:docstring of aiida.manage.configuration.load_profile:3
msgid "if a profile is already loaded and no explicit profile is specified, nothing will be done"
msgstr ""

#: ../../../src/aiida/manage/configuration/__init__.py:docstring of aiida.manage.configuration.profile_context:1
msgid "Return a context manager for temporarily loading a profile, and unloading on exit."
msgstr ""

#: ../../../src/aiida/manage/configuration/__init__.py:docstring of aiida.manage.configuration.profile_context:4
msgid "if True, will allow switching to a different profile"
msgstr ""

#: ../../../src/aiida/manage/configuration/__init__.py:docstring of aiida.manage.configuration.profile_context:6
msgid "a context manager for temporarily loading a profile"
msgstr ""

#: ../../../src/aiida/manage/configuration/__init__.py:docstring of aiida.manage.configuration.reset_config:1
msgid "Reset the globally loaded config."
msgstr ""

#: ../../../src/aiida/manage/configuration/__init__.py:docstring of aiida.manage.configuration.reset_config:3
msgid "This is experimental functionality and should for now be used only internally. If the reset is unclean weird unknown side-effects may occur that end up corrupting or destroying data."
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config:1
msgid "Module that defines the configuration file of an AiiDA instance and functions to create and load it."
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config:3
msgid "Despite the import of the annotations backport below which enables postponed type annotation evaluation as implemented with PEP 563 (https://peps.python.org/pep-0563/), this is not compatible with ``pydantic`` for Python 3.9 and older ( See https://github.com/pydantic/pydantic/issues/2678 for details)."
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config:1
msgid "Object that represents the configuration file of an AiiDA instance."
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.__eq__:1
msgid "Two configurations are considered equal, when their dictionaries are equal."
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.__init__:1
msgid "Instantiate a configuration object from a configuration dictionary and its filepath."
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.__init__:3
msgid "If an empty dictionary is passed, the constructor will create the skeleton configuration dictionary."
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.__init__:5
msgid "the absolute filepath of the configuration file"
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.__init__:6
msgid "the content of the configuration file in dictionary form"
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.__init__:7
msgid "validate the dictionary against the schema"
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.__ne__:1
msgid "Two configurations are considered unequal, when their dictionaries are unequal."
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config._atomic_write:1
msgid "Write the config as it is in memory, i.e. the contents of ``self.dictionary``, to disk."
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config._atomic_write:3
msgid "this command will write the config from memory to a temporary file in the same directory as the target file ``filepath``. It will then use ``os.rename`` to move the temporary file to ``filepath`` which will be overwritten if it already exists. The ``os.rename`` is the operation that gives the best guarantee of being atomic within the limitations of the application."
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config._atomic_write:8
msgid "optional filepath to write the contents to, if not specified, the default filename is used."
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config._backup:1
msgid "Create a backup of the configuration file with the given filepath."
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config._backup:3
msgid "absolute path to the configuration file to backup"
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config._backup:4
msgid "the absolute path of the created backup"
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.add_profile:1
msgid "Add a profile to the configuration."
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.add_profile:3
#: ../../../src/aiida/manage/configuration/profile.py:docstring of aiida.manage.configuration.profile.Profile.dictionary:3
msgid "the profile configuration dictionary"
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.add_profile:4
#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.remove_profile:5
#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.set_default_profile:6
#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.store:6
#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.update_profile:4
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.append:60
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.children:3
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.distinct:15
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.inputs:3
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.outputs:3
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.parents:3
msgid "self"
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.create_profile:1
msgid "Create a new profile and initialise its storage."
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.create_profile:3
msgid "The profile name."
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.create_profile:4
msgid "The :class:`aiida.orm.implementation.storage_backend.StorageBackend` implementation to use."
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.create_profile:5
msgid "The configuration necessary to initialise and connect to the storage backend."
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.create_profile:6
msgid "The created profile."
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.create_profile:7
msgid "If the profile already exists."
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.create_profile:8
msgid "If the ``storage_cls`` is not a subclass of :class:`aiida.orm.implementation.storage_backend.StorageBackend`."
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.create_profile:10
msgid "If the ``storage_cls`` does not have an associated entry point."
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.create_profile:11
msgid "If the storage cannot be initialised."
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.default_profile_name:1
msgid "Return the default profile name."
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.default_profile_name:3
msgid "the default profile name or None if not defined"
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.delete_profile:1
msgid "Delete a profile including its storage."
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.delete_profile:3
msgid "Whether to delete the storage with all its data or not."
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.dictionary:1
msgid "Return the dictionary representation of the config as it would be written to file."
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.dictionary:3
msgid "dictionary representation of config as it should be written to file"
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.from_file:1
msgid "Instantiate a configuration object from the contents of a given file."
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.from_file:3
msgid "if the filepath does not exist an empty file will be created with the current default configuration and will be written to disk. If the filepath does already exist but contains a configuration with an outdated schema, the content will be migrated and then written to disk."
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.from_file:7
msgid "the absolute path to the configuration file"
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.from_file:8
msgid "`Config` instance"
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.get_option:1
msgid "Get a configuration option for a certain scope."
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.get_option:3
#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.set_option:3
#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.unset_option:3
#: ../../../src/aiida/manage/configuration/options.py:docstring of aiida.manage.configuration.options.parse_option:3
msgid "the name of the configuration option"
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.get_option:4
msgid "get the option for this profile or globally if not specified"
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.get_option:5
msgid "boolean, If True will return the option default, even if not defined within the given scope"
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.get_option:6
msgid "the option value or None if not set for the given scope"
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.get_options:1
msgid "Return a dictionary of all option values and their source ('profile', 'global', or 'default')."
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.get_options:3
msgid "the profile name or globally if not specified"
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.get_options:4
msgid "(option, source, value)"
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.get_profile:1
msgid "Return the profile for the given name or the default one if not specified."
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.get_profile:3
msgid "the profile instance or None if it does not exist"
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.get_profile:4
#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.validate_profile:4
msgid "if the name is not found in the configuration file"
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.handle_invalid:1
msgid "Handle an incoming invalid configuration dictionary."
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.handle_invalid:3
msgid "The current content of the configuration file will be written to a backup file."
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.handle_invalid:5
msgid "a string message to echo with describing the infraction"
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.profile_names:1
msgid "Return the list of profile names."
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.profile_names:3
msgid "list of profile names"
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.profiles:1
msgid "Return the list of profiles."
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.profiles:3
msgid "the profiles"
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.profiles:4
msgid "list of `Profile` instances"
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.remove_profile:1
msgid "Remove a profile from the configuration."
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.remove_profile:3
msgid "the name of the profile to remove"
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.set_default_profile:1
msgid "Set the given profile as the new default."
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.set_default_profile:3
msgid "name of the profile to set as new default"
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.set_default_profile:4
msgid "when True, set the profile as the new default even if a default profile is already defined"
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.set_default_user_email:5
msgid "This does not update the cached default user on the storage backend associated with the profile. To do so, use :meth:`aiida.manage.manager.Manager.set_default_user_email` instead."
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.set_option:1
#: ../../../src/aiida/manage/configuration/profile.py:docstring of aiida.manage.configuration.profile.Profile.set_option:1
msgid "Set a configuration option for a certain scope."
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.set_option:4
#: ../../../src/aiida/manage/configuration/options.py:docstring of aiida.manage.configuration.options.parse_option:4
#: ../../../src/aiida/manage/configuration/profile.py:docstring of aiida.manage.configuration.profile.Profile.set_option:4
msgid "the option value"
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.set_option:5
msgid "set the option for this profile or globally if not specified"
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.set_option:6
#: ../../../src/aiida/manage/configuration/profile.py:docstring of aiida.manage.configuration.profile.Profile.set_option:5
msgid "boolean, if False, will not override the option if it already exists"
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.set_option:8
msgid "the parsed value (potentially cast to a valid type)"
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.store:1
msgid "Write the current config to file."
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.store:3
msgid "if the configuration file already exists on disk and its contents differ from those in memory, a backup of the original file on disk will be created before overwriting it."
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.unset_option:1
msgid "Unset a configuration option for a certain scope."
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.unset_option:4
msgid "unset the option for this profile or globally if not specified"
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.update_profile:1
msgid "Update a profile in the configuration."
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.update_profile:3
msgid "the profile instance to update"
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.validate:1
msgid "Validate a configuration dictionary."
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.validate_profile:1
msgid "Validate that a profile exists."
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.Config.validate_profile:3
msgid "name of the profile:"
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.ConfigSchema:1
#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.ConfigVersionSchema:1
#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.ProcessControlConfig:1
#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.ProfileOptionsSchema:1
#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.ProfileSchema:1
#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.ProfileStorageConfig:1
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.Configuration:1
#: ../../../src/aiida/storage/sqlite_dos/backend.py:docstring of aiida.storage.sqlite_dos.backend.SqliteDosStorage.Configuration:1
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.Configuration:1
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.Configuration:1
msgid "Bases: :py:class:`~pydantic.main.BaseModel`"
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.ConfigSchema:1
msgid "Schema for the configuration of an AiiDA instance."
msgstr ""

#: ../../docstring of aiida.manage.configuration.config.ConfigSchema.model_config:1
#: ../../docstring of aiida.manage.configuration.config.ConfigVersionSchema.model_config:1
#: ../../docstring of aiida.manage.configuration.config.GlobalOptionsSchema.model_config:1
#: ../../docstring of aiida.manage.configuration.config.ProcessControlConfig.model_config:1
#: ../../docstring of aiida.manage.configuration.config.ProfileOptionsSchema.model_config:1
#: ../../docstring of aiida.manage.configuration.config.ProfileSchema.model_config:1
#: ../../docstring of aiida.manage.configuration.config.ProfileStorageConfig.model_config:1
#: ../../docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.Configuration.model_config:1
#: ../../docstring of aiida.storage.sqlite_dos.backend.SqliteDosStorage.Configuration.model_config:1
#: ../../docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.Configuration.model_config:1
#: ../../docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.Configuration.model_config:1
msgid "Configuration for the model, should be a dictionary conforming to [`ConfigDict`][pydantic.config.ConfigDict]."
msgstr ""

#: ../../docstring of aiida.manage.configuration.config.ConfigSchema.model_fields:1
#: ../../docstring of aiida.manage.configuration.config.ConfigVersionSchema.model_fields:1
#: ../../docstring of aiida.manage.configuration.config.GlobalOptionsSchema.model_fields:1
#: ../../docstring of aiida.manage.configuration.config.ProcessControlConfig.model_fields:1
#: ../../docstring of aiida.manage.configuration.config.ProfileOptionsSchema.model_fields:1
#: ../../docstring of aiida.manage.configuration.config.ProfileSchema.model_fields:1
#: ../../docstring of aiida.manage.configuration.config.ProfileStorageConfig.model_fields:1
#: ../../docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.Configuration.model_fields:1
#: ../../docstring of aiida.storage.sqlite_dos.backend.SqliteDosStorage.Configuration.model_fields:1
#: ../../docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.Configuration.model_fields:1
#: ../../docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.Configuration.model_fields:1
msgid "Metadata about the fields defined on the model, mapping of field names to [`FieldInfo`][pydantic.fields.FieldInfo]."
msgstr ""

#: ../../docstring of aiida.manage.configuration.config.ConfigSchema.model_fields:4
#: ../../docstring of aiida.manage.configuration.config.ConfigVersionSchema.model_fields:4
#: ../../docstring of aiida.manage.configuration.config.GlobalOptionsSchema.model_fields:4
#: ../../docstring of aiida.manage.configuration.config.ProcessControlConfig.model_fields:4
#: ../../docstring of aiida.manage.configuration.config.ProfileOptionsSchema.model_fields:4
#: ../../docstring of aiida.manage.configuration.config.ProfileSchema.model_fields:4
#: ../../docstring of aiida.manage.configuration.config.ProfileStorageConfig.model_fields:4
#: ../../docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.Configuration.model_fields:4
#: ../../docstring of aiida.storage.sqlite_dos.backend.SqliteDosStorage.Configuration.model_fields:4
#: ../../docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.Configuration.model_fields:4
#: ../../docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.Configuration.model_fields:4
msgid "This replaces `Model.__fields__` from Pydantic V1."
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.ConfigVersionSchema:1
msgid "Schema for the version configuration of an AiiDA instance."
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.GlobalOptionsSchema:1
msgid "Bases: :py:class:`~aiida.manage.configuration.config.ProfileOptionsSchema`"
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.GlobalOptionsSchema:1
msgid "Schema for the global options of an AiiDA instance."
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.ProcessControlConfig:1
msgid "Schema for the process control configuration of an AiiDA profile."
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.ProfileOptionsSchema:1
msgid "Schema for the options of an AiiDA profile."
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.ProfileOptionsSchema.validate_caching_identifier_pattern:1
msgid "Validate the caching identifier patterns."
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.ProfileSchema:1
msgid "Schema for the configuration of an AiiDA profile."
msgstr ""

#: ../../../src/aiida/manage/configuration/config.py:docstring of aiida.manage.configuration.config.ProfileStorageConfig:1
msgid "Schema for the storage backend configuration of an AiiDA profile."
msgstr ""

#: ../../../src/aiida/manage/configuration/options.py:docstring of aiida.manage.configuration.options:1
msgid "Definition of known configuration options and methods to parse and get option values."
msgstr ""

#: ../../../src/aiida/manage/configuration/options.py:docstring of aiida.manage.configuration.options.Option:1
msgid "Represent a configuration option schema."
msgstr ""

#: ../../../src/aiida/manage/configuration/options.py:docstring of aiida.manage.configuration.options.Option.validate:1
msgid "Validate a value"
msgstr ""

#: ../../../src/aiida/manage/configuration/options.py:docstring of aiida.manage.configuration.options.Option.validate:3
msgid "The input value"
msgstr ""

#: ../../../src/aiida/manage/configuration/options.py:docstring of aiida.manage.configuration.options.Option.validate:4
msgid "The output value"
msgstr ""

#: ../../../src/aiida/manage/configuration/options.py:docstring of aiida.manage.configuration.options.Option.validate:0
#: ../../../src/aiida/orm/nodes/data/array/projection.py:docstring of aiida.orm.nodes.data.array.projection.ProjectionData._check_projections_bands:0
#: ../../../src/aiida/orm/nodes/data/array/projection.py:docstring of aiida.orm.nodes.data.array.projection.ProjectionData.set_reference_bandsdata:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_kind:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.validate_weights_tuple:0
#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.set_state:0
msgid "raise"
msgstr ""

#: ../../../src/aiida/manage/configuration/options.py:docstring of aiida.manage.configuration.options.Option.validate:5
msgid "ConfigurationError"
msgstr ""

#: ../../../src/aiida/manage/configuration/options.py:docstring of aiida.manage.configuration.options.get_option:1
msgid "Return option."
msgstr ""

#: ../../../src/aiida/manage/configuration/options.py:docstring of aiida.manage.configuration.options.get_option_names:1
msgid "Return a list of available option names."
msgstr ""

#: ../../../src/aiida/manage/configuration/options.py:docstring of aiida.manage.configuration.options.parse_option:1
msgid "Parse and validate a value for a configuration option."
msgstr ""

#: ../../../src/aiida/manage/configuration/options.py:docstring of aiida.manage.configuration.options.parse_option:5
msgid "a tuple of the option and the parsed value"
msgstr ""

#: ../../../src/aiida/manage/configuration/profile.py:docstring of aiida.manage.configuration.profile:1
msgid "AiiDA profile related code"
msgstr ""

#: ../../../src/aiida/manage/configuration/profile.py:docstring of aiida.manage.configuration.profile.Profile:1
msgid "Class that models a profile as it is stored in the configuration file of an AiiDA instance."
msgstr ""

#: ../../../src/aiida/manage/configuration/profile.py:docstring of aiida.manage.configuration.profile.Profile.__init__:1
msgid "Load a profile with the profile configuration."
msgstr ""

#: ../../../src/aiida/manage/configuration/profile.py:docstring of aiida.manage.configuration.profile.Profile.copy:1
msgid "Return a copy of the profile."
msgstr ""

#: ../../../src/aiida/manage/configuration/profile.py:docstring of aiida.manage.configuration.profile.Profile.default_user_email:1
msgid "Return the default user email."
msgstr ""

#: ../../../src/aiida/manage/configuration/profile.py:docstring of aiida.manage.configuration.profile.Profile.dictionary:1
msgid "Return the profile attributes as a dictionary with keys as it is stored in the config"
msgstr ""

#: ../../../src/aiida/manage/configuration/profile.py:docstring of aiida.manage.configuration.profile.Profile.filepaths:1
msgid "Return the filepaths used by this profile."
msgstr ""

#: ../../../src/aiida/manage/configuration/profile.py:docstring of aiida.manage.configuration.profile.Profile.filepaths:3
msgid "a dictionary of filepaths"
msgstr ""

#: ../../../src/aiida/manage/configuration/profile.py:docstring of aiida.manage.configuration.profile.Profile.get_rmq_url:1
msgid "Return the RMQ url for this profile."
msgstr ""

#: ../../../src/aiida/manage/configuration/profile.py:docstring of aiida.manage.configuration.profile.Profile.is_test_profile:1
msgid "Return whether the profile is a test profile"
msgstr ""

#: ../../../src/aiida/manage/configuration/profile.py:docstring of aiida.manage.configuration.profile.Profile.is_test_profile:3
msgid "boolean, True if test profile, False otherwise"
msgstr ""

#: ../../../src/aiida/manage/configuration/profile.py:docstring of aiida.manage.configuration.profile.Profile.name:1
msgid "Return the profile name."
msgstr ""

#: ../../../src/aiida/manage/configuration/profile.py:docstring of aiida.manage.configuration.profile.Profile.name:3
msgid "the profile name"
msgstr ""

#: ../../../src/aiida/manage/configuration/profile.py:docstring of aiida.manage.configuration.profile.Profile.process_control_backend:1
msgid "Return the type of the process control backend."
msgstr ""

#: ../../../src/aiida/manage/configuration/profile.py:docstring of aiida.manage.configuration.profile.Profile.process_control_config:1
msgid "Return the configuration required by the process control backend."
msgstr ""

#: ../../../src/aiida/manage/configuration/profile.py:docstring of aiida.manage.configuration.profile.Profile.repository_path:1
msgid "Return the absolute path of the repository configured for this profile."
msgstr ""

#: ../../../src/aiida/manage/configuration/profile.py:docstring of aiida.manage.configuration.profile.Profile.repository_path:3
msgid "The URI should be in the format `protocol://address`"
msgstr ""

#: ../../../src/aiida/manage/configuration/profile.py:docstring of aiida.manage.configuration.profile.Profile.repository_path:5
msgid "At the moment, only the file protocol is supported."
msgstr ""

#: ../../../src/aiida/manage/configuration/profile.py:docstring of aiida.manage.configuration.profile.Profile.repository_path:7
msgid "absolute filepath of the profile's file repository"
msgstr ""

#: ../../../src/aiida/manage/configuration/profile.py:docstring of aiida.manage.configuration.profile.Profile.rmq_prefix:1
msgid "Return the prefix that should be used for RMQ resources"
msgstr ""

#: ../../../src/aiida/manage/configuration/profile.py:docstring of aiida.manage.configuration.profile.Profile.rmq_prefix:3
msgid "the rmq prefix string"
msgstr ""

#: ../../../src/aiida/manage/configuration/profile.py:docstring of aiida.manage.configuration.profile.Profile.set_option:3
msgid "the key of the configuration option"
msgstr ""

#: ../../../src/aiida/manage/configuration/profile.py:docstring of aiida.manage.configuration.profile.Profile.set_process_controller:1
msgid "Set the process control backend and its configuration."
msgstr ""

#: ../../../src/aiida/manage/configuration/profile.py:docstring of aiida.manage.configuration.profile.Profile.set_process_controller:3
msgid "the name of the process backend"
msgstr ""

#: ../../../src/aiida/manage/configuration/profile.py:docstring of aiida.manage.configuration.profile.Profile.set_process_controller:4
msgid "the configuration of the process backend"
msgstr ""

#: ../../../src/aiida/manage/configuration/profile.py:docstring of aiida.manage.configuration.profile.Profile.set_storage:1
msgid "Set the storage backend and its configuration."
msgstr ""

#: ../../../src/aiida/manage/configuration/profile.py:docstring of aiida.manage.configuration.profile.Profile.set_storage:3
msgid "the name of the storage backend"
msgstr ""

#: ../../../src/aiida/manage/configuration/profile.py:docstring of aiida.manage.configuration.profile.Profile.set_storage:4
msgid "the configuration of the storage backend"
msgstr ""

#: ../../../src/aiida/manage/configuration/profile.py:docstring of aiida.manage.configuration.profile.Profile.storage_backend:1
msgid "Return the type of the storage backend."
msgstr ""

#: ../../../src/aiida/manage/configuration/profile.py:docstring of aiida.manage.configuration.profile.Profile.storage_cls:1
msgid "Return the storage backend class for this profile."
msgstr ""

#: ../../../src/aiida/manage/configuration/profile.py:docstring of aiida.manage.configuration.profile.Profile.storage_config:1
msgid "Return the configuration required by the storage backend."
msgstr ""

#: ../../../src/aiida/manage/configuration/profile.py:docstring of aiida.manage.configuration.profile.Profile.uuid:1
msgid "Return the profile uuid."
msgstr ""

#: ../../../src/aiida/manage/configuration/profile.py:docstring of aiida.manage.configuration.profile.Profile.uuid:3
msgid "string UUID"
msgstr ""

#: ../../../src/aiida/manage/configuration/settings.py:docstring of aiida.manage.configuration.settings:1
msgid "Base settings required for the configuration of an AiiDA instance."
msgstr ""

#: ../../../src/aiida/manage/configuration/settings.py:docstring of aiida.manage.configuration.settings.create_instance_directories:1
msgid "Create the base directories required for a new AiiDA instance."
msgstr ""

#: ../../../src/aiida/manage/configuration/settings.py:docstring of aiida.manage.configuration.settings.create_instance_directories:3
msgid "This will create the base AiiDA directory defined by the AIIDA_CONFIG_FOLDER variable, unless it already exists. Subsequently, it will create the daemon directory within it and the daemon log directory."
msgstr ""

#: ../../../src/aiida/manage/configuration/settings.py:docstring of aiida.manage.configuration.settings.set_configuration_directory:1
msgid "Determine location of configuration directory, set related global variables and create instance directories."
msgstr ""

#: ../../../src/aiida/manage/configuration/settings.py:docstring of aiida.manage.configuration.settings.set_configuration_directory:3
msgid "The location of the configuration folder will be determined and optionally created following these heuristics:"
msgstr ""

#: ../../../src/aiida/manage/configuration/settings.py:docstring of aiida.manage.configuration.settings.set_configuration_directory:5
msgid "If an explicit path is provided by `aiida_config_folder`, that will be set as the configuration folder."
msgstr ""

#: ../../../src/aiida/manage/configuration/settings.py:docstring of aiida.manage.configuration.settings.set_configuration_directory:6
msgid "Otherwise, if the `AIIDA_PATH` variable is set, all the paths will be checked to see if they contain a configuration folder. The first one to be encountered will be set as `AIIDA_CONFIG_FOLDER`. If none of them contain one, a configuration folder will be created in the last path considered."
msgstr ""

#: ../../../src/aiida/manage/configuration/settings.py:docstring of aiida.manage.configuration.settings.set_configuration_directory:9
msgid "If the `AIIDA_PATH` variable is not set the `DEFAULT_AIIDA_PATH` value will be used as base path and if it does not yet contain a configuration folder, one will be created."
msgstr ""

#: ../../../src/aiida/manage/configuration/settings.py:docstring of aiida.manage.configuration.settings.set_configuration_directory:12
msgid "In principle then, a configuration folder should always be found or automatically created."
msgstr ""

#: ../../source/reference/apidoc/aiida.manage.configuration.migrations.rst:2
msgid "aiida.manage.configuration.migrations package"
msgstr ""

#: ../../../src/aiida/manage/configuration/migrations/__init__.py:docstring of aiida.manage.configuration.migrations:1
msgid "Methods and definitions of migrations for the configuration file of an AiiDA instance."
msgstr ""

#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations:1
msgid "Define the current configuration version and migrations."
msgstr ""

#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.AbstractStorageAndProcess:1
#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.AddMessageBroker:1
#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.AddPrefixToStorageBackendTypes:1
#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.AddProfileUuid:1
#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.AddTestProfileKey:1
#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.Initial:1
#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.MergeStorageBackendTypes:1
#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.SimplifyDefaultProfiles:1
#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.SimplifyOptions:1
msgid "Bases: :py:class:`~aiida.manage.configuration.migrations.migrations.SingleMigration`"
msgstr ""

#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.AbstractStorageAndProcess:1
msgid "Move the storage config under a top-level \"storage\" key and rabbitmq config under \"processing\"."
msgstr ""

#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.AbstractStorageAndProcess:3
msgid "This allows for different storage backends to have different configuration."
msgstr ""

#: ../../docstring of aiida.manage.configuration.migrations.migrations.AbstractStorageAndProcess.down_compatible:1
#: ../../docstring of aiida.manage.configuration.migrations.migrations.AddMessageBroker.down_compatible:1
#: ../../docstring of aiida.manage.configuration.migrations.migrations.AddPrefixToStorageBackendTypes.down_compatible:1
#: ../../docstring of aiida.manage.configuration.migrations.migrations.AddProfileUuid.down_compatible:1
#: ../../docstring of aiida.manage.configuration.migrations.migrations.AddTestProfileKey.down_compatible:1
#: ../../docstring of aiida.manage.configuration.migrations.migrations.Initial.down_compatible:1
#: ../../docstring of aiida.manage.configuration.migrations.migrations.MergeStorageBackendTypes.down_compatible:1
#: ../../docstring of aiida.manage.configuration.migrations.migrations.SimplifyDefaultProfiles.down_compatible:1
#: ../../docstring of aiida.manage.configuration.migrations.migrations.SimplifyOptions.down_compatible:1
#: ../../docstring of aiida.manage.configuration.migrations.migrations.SingleMigration.down_compatible:1
msgid "The initial oldest backwards compatible configuration version"
msgstr ""

#: ../../docstring of aiida.manage.configuration.migrations.migrations.AbstractStorageAndProcess.down_revision:1
#: ../../docstring of aiida.manage.configuration.migrations.migrations.AddMessageBroker.down_revision:1
#: ../../docstring of aiida.manage.configuration.migrations.migrations.AddPrefixToStorageBackendTypes.down_revision:1
#: ../../docstring of aiida.manage.configuration.migrations.migrations.AddProfileUuid.down_revision:1
#: ../../docstring of aiida.manage.configuration.migrations.migrations.AddTestProfileKey.down_revision:1
#: ../../docstring of aiida.manage.configuration.migrations.migrations.Initial.down_revision:1
#: ../../docstring of aiida.manage.configuration.migrations.migrations.MergeStorageBackendTypes.down_revision:1
#: ../../docstring of aiida.manage.configuration.migrations.migrations.SimplifyDefaultProfiles.down_revision:1
#: ../../docstring of aiida.manage.configuration.migrations.migrations.SimplifyOptions.down_revision:1
#: ../../docstring of aiida.manage.configuration.migrations.migrations.SingleMigration.down_revision:1
msgid "The initial configuration version."
msgstr ""

#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.AbstractStorageAndProcess.downgrade:1
#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.AddMessageBroker.downgrade:1
#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.AddPrefixToStorageBackendTypes.downgrade:1
#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.AddProfileUuid.downgrade:1
#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.AddTestProfileKey.downgrade:1
#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.Initial.downgrade:1
#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.MergeStorageBackendTypes.downgrade:1
#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.SimplifyDefaultProfiles.downgrade:1
#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.SimplifyOptions.downgrade:1
#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.SingleMigration.downgrade:1
msgid "Downgrade the configuration in-place."
msgstr ""

#: ../../docstring of aiida.manage.configuration.migrations.migrations.AbstractStorageAndProcess.up_compatible:1
#: ../../docstring of aiida.manage.configuration.migrations.migrations.AddMessageBroker.up_compatible:1
#: ../../docstring of aiida.manage.configuration.migrations.migrations.AddPrefixToStorageBackendTypes.up_compatible:1
#: ../../docstring of aiida.manage.configuration.migrations.migrations.AddProfileUuid.up_compatible:1
#: ../../docstring of aiida.manage.configuration.migrations.migrations.AddTestProfileKey.up_compatible:1
#: ../../docstring of aiida.manage.configuration.migrations.migrations.Initial.up_compatible:1
#: ../../docstring of aiida.manage.configuration.migrations.migrations.MergeStorageBackendTypes.up_compatible:1
#: ../../docstring of aiida.manage.configuration.migrations.migrations.SimplifyDefaultProfiles.up_compatible:1
#: ../../docstring of aiida.manage.configuration.migrations.migrations.SimplifyOptions.up_compatible:1
#: ../../docstring of aiida.manage.configuration.migrations.migrations.SingleMigration.up_compatible:1
msgid "The final oldest backwards compatible configuration version"
msgstr ""

#: ../../docstring of aiida.manage.configuration.migrations.migrations.AbstractStorageAndProcess.up_revision:1
#: ../../docstring of aiida.manage.configuration.migrations.migrations.AddMessageBroker.up_revision:1
#: ../../docstring of aiida.manage.configuration.migrations.migrations.AddPrefixToStorageBackendTypes.up_revision:1
#: ../../docstring of aiida.manage.configuration.migrations.migrations.AddProfileUuid.up_revision:1
#: ../../docstring of aiida.manage.configuration.migrations.migrations.AddTestProfileKey.up_revision:1
#: ../../docstring of aiida.manage.configuration.migrations.migrations.Initial.up_revision:1
#: ../../docstring of aiida.manage.configuration.migrations.migrations.MergeStorageBackendTypes.up_revision:1
#: ../../docstring of aiida.manage.configuration.migrations.migrations.SimplifyDefaultProfiles.up_revision:1
#: ../../docstring of aiida.manage.configuration.migrations.migrations.SimplifyOptions.up_revision:1
#: ../../docstring of aiida.manage.configuration.migrations.migrations.SingleMigration.up_revision:1
msgid "The final configuration version."
msgstr ""

#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.AbstractStorageAndProcess.upgrade:1
#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.AddMessageBroker.upgrade:1
#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.AddPrefixToStorageBackendTypes.upgrade:1
#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.AddProfileUuid.upgrade:1
#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.AddTestProfileKey.upgrade:1
#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.Initial.upgrade:1
#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.MergeStorageBackendTypes.upgrade:1
#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.SimplifyDefaultProfiles.upgrade:1
#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.SimplifyOptions.upgrade:1
#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.SingleMigration.upgrade:1
msgid "Migrate the configuration in-place."
msgstr ""

#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.AddMessageBroker:1
msgid "Add the configuration for the message broker, which was not configurable up to now."
msgstr ""

#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.AddPrefixToStorageBackendTypes:1
msgid "The ``storage.backend`` key should be prefixed with ``core.``."
msgstr ""

#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.AddPrefixToStorageBackendTypes:3
msgid "At this point, it should only ever contain ``psql_dos`` which should therefore become ``core.psql_dos``. To cover for cases where people manually added a read only ``sqlite_zip`` profile, we also migrate that."
msgstr ""

#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.AddProfileUuid:1
msgid "Add the required values for a new default profile."
msgstr ""

#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.AddProfileUuid:3
msgid "PROFILE_UUID"
msgstr ""

#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.AddProfileUuid:5
msgid "The profile uuid will be used as a general purpose identifier for the profile, in for example the RabbitMQ message queues and exchanges."
msgstr ""

#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.AddTestProfileKey:1
msgid "Add the ``test_profile`` key."
msgstr ""

#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.Initial:1
msgid "Base migration (no-op)."
msgstr ""

#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.MergeStorageBackendTypes:1
msgid "`django` and `sqlalchemy` are now merged into `psql_dos`."
msgstr ""

#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.MergeStorageBackendTypes:3
msgid "The legacy name is stored under the `_v6_backend` key, to allow for downgrades."
msgstr ""

#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.SimplifyDefaultProfiles:1
msgid "Replace process specific default profiles with single default profile key."
msgstr ""

#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.SimplifyDefaultProfiles:3
msgid "The concept of a different 'process' for a profile has been removed and as such the default profiles key in the configuration no longer needs a value per process ('verdi', 'daemon'). We remove the dictionary 'default_profiles' and replace it with a simple value 'default_profile'."
msgstr ""

#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.SimplifyOptions:1
msgid "Remove unnecessary difference between file/internal representation of options"
msgstr ""

#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.SingleMigration:1
#: ../../../src/aiida/orm/implementation/groups.py:docstring of aiida.orm.implementation.groups.NodeIterator:1
#: ../../../src/aiida/orm/nodes/data/jsonable.py:docstring of aiida.orm.nodes.data.jsonable.JsonSerializableProtocol:1
#: ../../../src/aiida/orm/utils/serialize.py:docstring of aiida.orm.utils.serialize._MappingType:1
#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner._EntityMapper:1
#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.LinkStyleFunc:1
msgid "Bases: :py:class:`~typing.Protocol`"
msgstr ""

#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.SingleMigration:1
msgid "A single migration of the configuration."
msgstr ""

#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.check_and_migrate_config:1
msgid "Checks if the config needs to be migrated, and performs the migration if needed."
msgstr ""

#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.check_and_migrate_config:3
#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.downgrade_config:3
#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.upgrade_config:3
msgid "the configuration dictionary"
msgstr ""

#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.check_and_migrate_config:4
#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.config_needs_migrating:6
msgid "the path to the configuration file (optional, for error reporting)"
msgstr ""

#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.check_and_migrate_config:5
#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.downgrade_config:4
#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.upgrade_config:4
msgid "the migrated configuration dictionary"
msgstr ""

#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.config_needs_migrating:1
msgid "Checks if the config needs to be migrated."
msgstr ""

#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.config_needs_migrating:3
msgid "If the oldest compatible version of the configuration is higher than the current configuration version defined in the code, the config cannot be used and so the function will raise."
msgstr ""

#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.config_needs_migrating:7
msgid "True if the configuration has an older version and needs to be migrated, False otherwise"
msgstr ""

#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.config_needs_migrating:8
msgid "if the config's oldest compatible version is higher than the current"
msgstr ""

#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.downgrade_config:1
msgid "Run the registered configuration migrations down to the target version."
msgstr ""

#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.get_current_version:1
msgid "Return the current version of the config."
msgstr ""

#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.get_current_version:3
msgid "current config version or 0 if not defined"
msgstr ""

#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.get_oldest_compatible_version:1
msgid "Return the current oldest compatible version of the config."
msgstr ""

#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.get_oldest_compatible_version:3
msgid "current oldest compatible config version or 0 if not defined"
msgstr ""

#: ../../../src/aiida/manage/configuration/migrations/migrations.py:docstring of aiida.manage.configuration.migrations.migrations.upgrade_config:1
msgid "Run the registered configuration migrations up to the target version."
msgstr ""

#: ../../source/reference/apidoc/aiida.manage.configuration.schema.rst:2
msgid "aiida.manage.configuration.schema package"
msgstr ""

#: ../../source/reference/apidoc/aiida.manage.external.rst:2
msgid "aiida.manage.external package"
msgstr ""

#: ../../../src/aiida/manage/external/__init__.py:docstring of aiida.manage.external:1
msgid "User facing APIs to control AiiDA from the verdi cli, scripts or plugins"
msgstr ""

#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres:1
msgid "Provides an API for postgres database maintenance tasks."
msgstr ""

#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres:3
msgid "This API creates and drops postgres users and databases used by the ``verdi quicksetup`` commandline tool. It allows convenient access to this functionality from within python without knowing details about how postgres is installed by default on various systems. If the postgres setup is not the default installation, additional information needs to be provided."
msgstr ""

#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres:1
msgid "Bases: :py:class:`~pgsu.PGSU`"
msgstr ""

#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres:1
msgid "Adds convenience functions to :py:class:`pgsu.PGSU`."
msgstr ""

#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres:5
msgid "Provides convenience functions for"
msgstr ""

#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres:4
msgid "creating/dropping users"
msgstr ""

#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres:5
msgid "creating/dropping databases"
msgstr ""

#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres:7
msgid "etc."
msgstr ""

#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres.__init__:1
msgid "See documentation of :py:meth:`pgsu.PGSU.__init__`."
msgstr ""

#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres.can_user_authenticate:1
msgid "Check whether the database user credentials are valid."
msgstr ""

#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres.can_user_authenticate:3
msgid "Checks whether dbuser has access to the `template1` postgres database via psycopg2."
msgstr ""

#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres.can_user_authenticate:6
msgid "the database user"
msgstr ""

#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres.can_user_authenticate:7
msgid "the database password"
msgstr ""

#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres.can_user_authenticate:8
msgid "True if the credentials are valid, False otherwise"
msgstr ""

#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres.create_db:1
msgid "Create a database in postgres"
msgstr ""

#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres.create_db:3
#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres.create_dbuser_db_safe:9
msgid "Name of the user which should own the db."
msgstr ""

#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres.create_db:4
#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres.create_dbuser_db_safe:8
#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres.drop_db:3
#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.postgres_cluster:3
msgid "Name of the database."
msgstr ""

#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres.create_dbuser:1
msgid "Create a database user in postgres"
msgstr ""

#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres.create_dbuser:3
msgid "Name of the user to be created."
msgstr ""

#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres.create_dbuser:4
#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres.create_dbuser_db_safe:10
msgid "Password the user should be given."
msgstr ""

#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres.create_dbuser:5
msgid "psycopg2.errors.DuplicateObject if user already exists and self.connection_mode == PostgresConnectionMode.PSYCOPG"
msgstr ""

#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres.create_dbuser_db_safe:1
msgid "Create DB and user + grant privileges."
msgstr ""

#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres.create_dbuser_db_safe:3
msgid "An existing database user is reused, if it is able to authenticate. If not, a new username is generated on the fly."
msgstr ""

#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres.create_dbuser_db_safe:6
msgid "An existing database is not reused (unsafe), a new database name is generated on the fly."
msgstr ""

#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres.create_dbuser_db_safe:11
msgid "(dbuser, dbname)"
msgstr ""

#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres.db_exists:1
msgid "Check wether a postgres database with dbname exists"
msgstr ""

#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres.db_exists:3
msgid "Name of the database to check for"
msgstr ""

#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres.db_exists:4
msgid "(bool), True if database exists, False otherwise"
msgstr ""

#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres.dbinfo:1
msgid "Alias for Postgres.dsn."
msgstr ""

#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres.dbuser_exists:1
msgid "Find out if postgres user with name dbuser exists"
msgstr ""

#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres.dbuser_exists:3
msgid "database user to check for"
msgstr ""

#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres.dbuser_exists:4
msgid "(bool) True if user exists, False otherwise"
msgstr ""

#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres.drop_db:1
msgid "Drop a database in postgres"
msgstr ""

#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres.drop_dbuser:1
msgid "Drop a database user in postgres"
msgstr ""

#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres.drop_dbuser:3
msgid "Name of the user to be dropped."
msgstr ""

#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres.find_new_db:1
msgid "Find database name that does not yet exist."
msgstr ""

#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres.find_new_db:3
#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres.find_new_dbuser:3
msgid "Generates names of the form \"aiida_1\", \"aiida_2\", etc. until it finds a name that does not yet exist."
msgstr ""

#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres.find_new_db:5
#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres.find_new_dbuser:5
msgid "start from this name"
msgstr ""

#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres.find_new_db:6
msgid "dbname"
msgstr ""

#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres.find_new_dbuser:1
msgid "Find database user that does not yet exist."
msgstr ""

#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres.find_new_dbuser:6
msgid "dbuser"
msgstr ""

#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres.from_profile:1
msgid "Create Postgres instance with dbinfo from AiiDA profile data."
msgstr ""

#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres.from_profile:4
msgid "Note: This only uses host and port from the profile, since the others are not going to be relevant for the"
msgstr ""

#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres.from_profile:4
msgid "database superuser."
msgstr ""

#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres.from_profile:6
msgid "AiiDA profile instance"
msgstr ""

#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres.from_profile:7
msgid "keyword arguments forwarded to PGSU constructor"
msgstr ""

#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres.from_profile:9
msgid "Postgres instance pre-populated with data from AiiDA profile"
msgstr ""

#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres.host_for_psycopg2:1
msgid "Return correct host for psycopg2 connection (as required by regular AiiDA operation)."
msgstr ""

#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.Postgres.port_for_psycopg2:1
msgid "Return port for psycopg2 connection (as required by regular AiiDA operation)."
msgstr ""

#: ../../../src/aiida/manage/external/postgres.py:docstring of aiida.manage.external.postgres.manual_setup_instructions:1
msgid "Create a message with instructions for manually creating a database"
msgstr ""

#: ../../source/reference/apidoc/aiida.manage.external.rmq.rst:2
msgid "aiida.manage.external.rmq package"
msgstr ""

#: ../../../src/aiida/manage/external/rmq/__init__.py:docstring of aiida.manage.external.rmq:1
msgid "Module with utilities to interact with RabbitMQ."
msgstr ""

#: ../../../src/aiida/manage/external/rmq/client.py:docstring of aiida.manage.external.rmq.client:1
#: ../../../src/aiida/manage/external/rmq/client.py:docstring of aiida.manage.external.rmq.client.RabbitmqManagementClient:1
msgid "Client for RabbitMQ Management HTTP API."
msgstr ""

#: ../../../src/aiida/manage/external/rmq/client.py:docstring of aiida.manage.external.rmq.client.ManagementApiConnectionError:1
msgid "Raised when no connection can be made to the management HTTP API."
msgstr ""

#: ../../../src/aiida/manage/external/rmq/client.py:docstring of aiida.manage.external.rmq.client.RabbitmqManagementClient:3
msgid "This requires the ``rabbitmq_management`` plugin (https://www.rabbitmq.com/management.html) to be enabled. Typically this is enabled by running ``rabbitmq-plugins enable rabbitmq_management``."
msgstr ""

#: ../../../src/aiida/manage/external/rmq/client.py:docstring of aiida.manage.external.rmq.client.RabbitmqManagementClient.__init__:3
msgid "The username to authenticate with."
msgstr ""

#: ../../../src/aiida/manage/external/rmq/client.py:docstring of aiida.manage.external.rmq.client.RabbitmqManagementClient.__init__:4
msgid "The password to authenticate with."
msgstr ""

#: ../../../src/aiida/manage/external/rmq/client.py:docstring of aiida.manage.external.rmq.client.RabbitmqManagementClient.__init__:5
msgid "The hostname of the RabbitMQ server."
msgstr ""

#: ../../../src/aiida/manage/external/rmq/client.py:docstring of aiida.manage.external.rmq.client.RabbitmqManagementClient.__init__:6
msgid "The virtual host."
msgstr ""

#: ../../../src/aiida/manage/external/rmq/client.py:docstring of aiida.manage.external.rmq.client.RabbitmqManagementClient.format_url:1
msgid "Format the complete URL from a partial resource path with placeholders."
msgstr ""

#: ../../../src/aiida/manage/external/rmq/client.py:docstring of aiida.manage.external.rmq.client.RabbitmqManagementClient.format_url:3
msgid "The base URL will be automatically prepended."
msgstr ""

#: ../../../src/aiida/manage/external/rmq/client.py:docstring of aiida.manage.external.rmq.client.RabbitmqManagementClient.format_url:5
#: ../../../src/aiida/manage/external/rmq/client.py:docstring of aiida.manage.external.rmq.client.RabbitmqManagementClient.request:3
msgid "The resource path with placeholders, e.g., ``queues/{virtual_host}/{queue}``."
msgstr ""

#: ../../../src/aiida/manage/external/rmq/client.py:docstring of aiida.manage.external.rmq.client.RabbitmqManagementClient.format_url:6
#: ../../../src/aiida/manage/external/rmq/client.py:docstring of aiida.manage.external.rmq.client.RabbitmqManagementClient.request:4
msgid "Dictionary with values for the placeholders in the ``url``. The ``virtual_host`` value is automatically inserted and should not be specified."
msgstr ""

#: ../../../src/aiida/manage/external/rmq/client.py:docstring of aiida.manage.external.rmq.client.RabbitmqManagementClient.format_url:8
msgid "The complete URL."
msgstr ""

#: ../../../src/aiida/manage/external/rmq/client.py:docstring of aiida.manage.external.rmq.client.RabbitmqManagementClient.is_connected:1
msgid "Return whether the API server can be connected to."
msgstr ""

#: ../../../src/aiida/manage/external/rmq/client.py:docstring of aiida.manage.external.rmq.client.RabbitmqManagementClient.is_connected:3
msgid "Tries to reach the server at the ``/api/cluster-name`` end-point."
msgstr ""

#: ../../../src/aiida/manage/external/rmq/client.py:docstring of aiida.manage.external.rmq.client.RabbitmqManagementClient.is_connected:5
msgid "``True`` if the server can be reached, ``False`` otherwise."
msgstr ""

#: ../../../src/aiida/manage/external/rmq/client.py:docstring of aiida.manage.external.rmq.client.RabbitmqManagementClient.request:1
msgid "Make a request."
msgstr ""

#: ../../../src/aiida/manage/external/rmq/client.py:docstring of aiida.manage.external.rmq.client.RabbitmqManagementClient.request:6
msgid "The HTTP method."
msgstr ""

#: ../../../src/aiida/manage/external/rmq/client.py:docstring of aiida.manage.external.rmq.client.RabbitmqManagementClient.request:7
msgid "Query parameters to add to the URL."
msgstr ""

#: ../../../src/aiida/manage/external/rmq/client.py:docstring of aiida.manage.external.rmq.client.RabbitmqManagementClient.request:8
msgid "The response of the request."
msgstr ""

#: ../../../src/aiida/manage/external/rmq/client.py:docstring of aiida.manage.external.rmq.client.RabbitmqManagementClient.request:9
msgid "If connection to the API cannot be made."
msgstr ""

#: ../../../src/aiida/manage/external/rmq/defaults.py:docstring of aiida.manage.external.rmq.defaults:1
msgid "Defaults related to RabbitMQ."
msgstr ""

#: ../../../src/aiida/manage/external/rmq/launcher.py:docstring of aiida.manage.external.rmq.launcher:1
msgid "A sub class of ``plumpy.ProcessLauncher`` to launch a ``Process``."
msgstr ""

#: ../../../src/aiida/manage/external/rmq/launcher.py:docstring of aiida.manage.external.rmq.launcher.ProcessLauncher:1
msgid "Bases: :py:class:`~plumpy.process_comms.ProcessLauncher`"
msgstr ""

#: ../../../src/aiida/manage/external/rmq/launcher.py:docstring of aiida.manage.external.rmq.launcher.ProcessLauncher:1
msgid "A sub class of :class:`plumpy.ProcessLauncher` to launch a ``Process``."
msgstr ""

#: ../../../src/aiida/manage/external/rmq/launcher.py:docstring of aiida.manage.external.rmq.launcher.ProcessLauncher:3
msgid "It overrides the _continue method to make sure the node corresponding to the task can be loaded and that if it is already marked as terminated, it is not continued but the future is reconstructed and returned"
msgstr ""

#: ../../../src/aiida/manage/external/rmq/launcher.py:docstring of aiida.manage.external.rmq.launcher.ProcessLauncher._continue:1
msgid "Continue the task."
msgstr ""

#: ../../../src/aiida/manage/external/rmq/launcher.py:docstring of aiida.manage.external.rmq.launcher.ProcessLauncher._continue:3
msgid "Note that the task may already have been completed, as indicated from the corresponding the node, in which case it is not continued, but the corresponding future is reconstructed and returned. This scenario may occur when the Process was already completed by another worker that however failed to send the acknowledgment."
msgstr ""

#: ../../../src/aiida/manage/external/rmq/launcher.py:docstring of aiida.manage.external.rmq.launcher.ProcessLauncher._continue:7
msgid "the communicator that called this method"
msgstr ""

#: ../../../src/aiida/manage/external/rmq/launcher.py:docstring of aiida.manage.external.rmq.launcher.ProcessLauncher._continue:8
msgid "the pid of the process to continue"
msgstr ""

#: ../../../src/aiida/manage/external/rmq/launcher.py:docstring of aiida.manage.external.rmq.launcher.ProcessLauncher._continue:9
msgid "if True don't wait for the process to finish, just return the pid, otherwise wait and return the results"
msgstr ""

#: ../../../src/aiida/manage/external/rmq/launcher.py:docstring of aiida.manage.external.rmq.launcher.ProcessLauncher._continue:11
msgid "the tag of the checkpoint to continue from"
msgstr ""

#: ../../../src/aiida/manage/external/rmq/launcher.py:docstring of aiida.manage.external.rmq.launcher.ProcessLauncher.handle_continue_exception:1
msgid "Handle exception raised in `_continue` call."
msgstr ""

#: ../../../src/aiida/manage/external/rmq/launcher.py:docstring of aiida.manage.external.rmq.launcher.ProcessLauncher.handle_continue_exception:3
msgid "If the process state of the node has not yet been put to excepted, the exception was raised before the process instance could be reconstructed, for example when the process class could not be loaded, thereby circumventing the exception handling of the state machine. Raising this exception will then acknowledge the process task with RabbitMQ leaving an uncleaned node in the `CREATED` state for ever. Therefore we have to perform the node cleaning manually."
msgstr ""

#: ../../../src/aiida/manage/external/rmq/launcher.py:docstring of aiida.manage.external.rmq.launcher.ProcessLauncher.handle_continue_exception:9
msgid "the exception object"
msgstr ""

#: ../../../src/aiida/manage/external/rmq/launcher.py:docstring of aiida.manage.external.rmq.launcher.ProcessLauncher.handle_continue_exception:10
msgid "string message to use for the log message"
msgstr ""

#: ../../../src/aiida/manage/external/rmq/utils.py:docstring of aiida.manage.external.rmq.utils:1
msgid "Utilites for RabbitMQ."
msgstr ""

#: ../../../src/aiida/manage/external/rmq/utils.py:docstring of aiida.manage.external.rmq.utils.get_launch_queue_name:1
msgid "Return the launch queue name with an optional prefix."
msgstr ""

#: ../../../src/aiida/manage/external/rmq/utils.py:docstring of aiida.manage.external.rmq.utils.get_launch_queue_name:3
msgid "launch queue name"
msgstr ""

#: ../../../src/aiida/manage/external/rmq/utils.py:docstring of aiida.manage.external.rmq.utils.get_message_exchange_name:1
msgid "Return the message exchange name for a given prefix."
msgstr ""

#: ../../../src/aiida/manage/external/rmq/utils.py:docstring of aiida.manage.external.rmq.utils.get_message_exchange_name:3
msgid "message exchange name"
msgstr ""

#: ../../../src/aiida/manage/external/rmq/utils.py:docstring of aiida.manage.external.rmq.utils.get_rmq_url:1
msgid "Return the URL to connect to RabbitMQ."
msgstr ""

#: ../../../src/aiida/manage/external/rmq/utils.py:docstring of aiida.manage.external.rmq.utils.get_rmq_url:5
msgid "The default of the ``host`` is set to ``127.0.0.1`` instead of ``localhost`` because on some computers localhost resolves first to IPv6 with address ::1 and if RMQ is not running on IPv6 one gets an annoying warning. For more info see: https://github.com/aiidateam/aiida-core/issues/1142"
msgstr ""

#: ../../../src/aiida/manage/external/rmq/utils.py:docstring of aiida.manage.external.rmq.utils.get_rmq_url:9
msgid "the protocol to use, `amqp` or `amqps`."
msgstr ""

#: ../../../src/aiida/manage/external/rmq/utils.py:docstring of aiida.manage.external.rmq.utils.get_rmq_url:10
msgid "the username for authentication."
msgstr ""

#: ../../../src/aiida/manage/external/rmq/utils.py:docstring of aiida.manage.external.rmq.utils.get_rmq_url:11
msgid "the password for authentication."
msgstr ""

#: ../../../src/aiida/manage/external/rmq/utils.py:docstring of aiida.manage.external.rmq.utils.get_rmq_url:12
msgid "the hostname of the RabbitMQ server."
msgstr ""

#: ../../../src/aiida/manage/external/rmq/utils.py:docstring of aiida.manage.external.rmq.utils.get_rmq_url:13
msgid "the port of the RabbitMQ server."
msgstr ""

#: ../../../src/aiida/manage/external/rmq/utils.py:docstring of aiida.manage.external.rmq.utils.get_rmq_url:14
msgid "the virtual host to connect to."
msgstr ""

#: ../../../src/aiida/manage/external/rmq/utils.py:docstring of aiida.manage.external.rmq.utils.get_rmq_url:15
msgid "remaining keyword arguments that will be encoded as query parameters."
msgstr ""

#: ../../../src/aiida/manage/external/rmq/utils.py:docstring of aiida.manage.external.rmq.utils.get_rmq_url:16
msgid "the connection URL string."
msgstr ""

#: ../../../src/aiida/manage/external/rmq/utils.py:docstring of aiida.manage.external.rmq.utils.get_task_exchange_name:1
msgid "Return the task exchange name for a given prefix."
msgstr ""

#: ../../../src/aiida/manage/external/rmq/utils.py:docstring of aiida.manage.external.rmq.utils.get_task_exchange_name:3
msgid "task exchange name"
msgstr ""

#: ../../source/reference/apidoc/aiida.manage.tests.rst:2
msgid "aiida.manage.tests package"
msgstr ""

#: ../../../src/aiida/manage/tests/__init__.py:docstring of aiida.manage.tests:1
msgid "Testing infrastructure for easy testing of AiiDA plugins."
msgstr ""

#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures:1
msgid "Collection of ``pytest`` fixtures that are intended for use in plugin packages."
msgstr ""

#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures:3
msgid "To use these fixtures, simply create a ``conftest.py`` in the tests folder and add the following line:"
msgstr ""

#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures:5
msgid "pytest_plugins = ['aiida.manage.tests.pytest_fixtures']"
msgstr ""

#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures:7
msgid "This will make all the fixtures in this file available and ready for use. Simply use them as you would any other ``pytest`` fixture."
msgstr ""

#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.EntryPointManager:1
msgid "Manager to temporarily add or remove entry points."
msgstr ""

#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.EntryPointManager._validate_entry_point:1
msgid "Validate the definition of the entry point."
msgstr ""

#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.EntryPointManager._validate_entry_point:3
#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.EntryPointManager.add:5
#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.EntryPointManager.remove:4
msgid "Fully qualified entry point string."
msgstr ""

#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.EntryPointManager._validate_entry_point:4
#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.EntryPointManager.add:6
#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.EntryPointManager.remove:5
msgid "Entry point name."
msgstr ""

#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.EntryPointManager._validate_entry_point:5
#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.EntryPointManager.add:7
#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.EntryPointManager.remove:6
msgid "Entry point group."
msgstr ""

#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.EntryPointManager._validate_entry_point:6
#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.EntryPointManager.add:8
#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.EntryPointManager.remove:7
msgid "The entry point group and name."
msgstr ""

#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.EntryPointManager._validate_entry_point:7
#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.EntryPointManager.add:9
#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.EntryPointManager.remove:8
msgid "If `entry_point_string`, `group` or `name` are not a string, when defined."
msgstr ""

#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.EntryPointManager._validate_entry_point:8
#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.EntryPointManager.add:10
#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.EntryPointManager.remove:9
msgid "If `entry_point_string` is not defined, nor a `group` and `name`."
msgstr ""

#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.EntryPointManager._validate_entry_point:9
#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.EntryPointManager.add:11
#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.EntryPointManager.remove:10
msgid "If `entry_point_string` is not a complete entry point string with group and name."
msgstr ""

#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.EntryPointManager.add:1
msgid "Add an entry point."
msgstr ""

#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.EntryPointManager.add:3
msgid "The class or function to register as entry point. The resource needs to be importable, so it can't be inlined. Alternatively, the fully qualified name can be passed as a string."
msgstr ""

#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.EntryPointManager.remove:1
msgid "Remove an entry point."
msgstr ""

#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.EntryPointManager.remove:3
msgid "Entry point value, fully qualified import path name."
msgstr ""

#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.aiida_caplog:1
msgid "A copy of pytest's caplog fixture, which allows ``AIIDA_LOGGER`` to propagate."
msgstr ""

#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.aiida_computer:1
msgid "Factory to return a :class:`aiida.orm.computers.Computer` instance."
msgstr ""

#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.aiida_computer_local:1
msgid "Factory to return a :class:`aiida.orm.computers.Computer` instance with ``core.local`` transport."
msgstr ""

#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.aiida_computer_ssh:1
msgid "Factory to return a :class:`aiida.orm.computers.Computer` instance with ``core.ssh`` transport."
msgstr ""

#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.aiida_instance:1
msgid "Return the :class:`~aiida.manage.configuration.config.Config` instance that is used for the test session."
msgstr ""

#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.aiida_instance:3
msgid "If an existing test profile is defined through the ``aiida_test_profile`` fixture, the configuration of the actual AiiDA instance is loaded and returned. If no test profile is defined, a completely independent and temporary AiiDA instance is generated in a temporary directory with a clean `.aiida` folder and basic configuration file. The currently loaded configuration and profile are stored in memory and are automatically restored at the end of the test session. The temporary instance is automatically deleted."
msgstr ""

#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.aiida_instance:9
msgid "The configuration the AiiDA instance loaded for this test session."
msgstr ""

#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.aiida_local_code_factory:1
msgid "Get an AiiDA code on localhost."
msgstr ""

#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.aiida_local_code_factory:3
msgid "Searches in the PATH for a given executable and creates an AiiDA code with provided entry point."
msgstr ""

#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.aiida_local_code_factory:11
msgid "A function get_code(entry_point, executable) that returns the `Code` node."
msgstr ""

#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.aiida_localhost:1
msgid "Return a :class:`aiida.orm.computers.Computer` instance representing localhost with ``core.local`` transport."
msgstr ""

#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.aiida_localhost:8
#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.can_run_on_computer:3
#: ../../../src/aiida/orm/nodes/data/code/installed.py:docstring of aiida.orm.nodes.data.code.installed.InstalledCode.can_run_on_computer:3
#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.can_run_on_computer:3
#: ../../../src/aiida/orm/nodes/data/code/portable.py:docstring of aiida.orm.nodes.data.code.portable.PortableCode.can_run_on_computer:5
msgid "The computer."
msgstr ""

#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.aiida_manager:1
msgid "Return the global instance of the :class:`~aiida.manage.manager.Manager`."
msgstr ""

#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.aiida_manager:3
msgid "The global manager instance."
msgstr ""

#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.aiida_profile:1
msgid "Return a loaded AiiDA test profile."
msgstr ""

#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.aiida_profile:3
msgid "If a test profile has been declared, as returned by the ``aiida_test_profile`` fixture, that is loaded and yielded. Otherwise, a temporary and fully isolated AiiDA instance is created, complete with a loaded test profile, that are all automatically cleaned up at the end of the test session. The storage backend used for the profile is :class:`~aiida.storage.psql_dos.backend.PsqlDosBackend`."
msgstr ""

#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.aiida_profile_clean:1
msgid "Provide an AiiDA test profile, with the storage reset at test function setup."
msgstr ""

#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.aiida_profile_clean_class:1
msgid "Provide an AiiDA test profile, with the storage reset at test class setup."
msgstr ""

#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.aiida_profile_factory:1
msgid "Create a temporary profile, add it to the config of the loaded AiiDA instance and load the profile."
msgstr ""

#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.aiida_profile_factory:3
msgid "The default configuration is complete except for the configuration of the storage, which should be provided through the ``custom_configuration`` argument. The storage will be fully reset and initalised, destroying all data that it contains and recreate the default user, making the profile ready for use."
msgstr ""

#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.aiida_test_profile:1
msgid "Return the name of the AiiDA test profile if defined."
msgstr ""

#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.aiida_test_profile:3
msgid "The name is taken from the ``AIIDA_TEST_PROFILE`` environment variable."
msgstr ""

#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.aiida_test_profile:5
msgid "The name of the profile to you for the test session or ``None`` if not defined."
msgstr ""

#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.clear_database:1
msgid "Alias for 'clear_database_after_test'."
msgstr ""

#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.clear_database:3
msgid "Clears the database after each test. Use of the explicit 'clear_database_after_test' is preferred."
msgstr ""

#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.clear_database_after_test:1
msgid "Clear the database after the test."
msgstr ""

#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.clear_database_before_test:1
msgid "Clear the database before the test."
msgstr ""

#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.clear_database_before_test_class:1
msgid "Clear the database before a test class."
msgstr ""

#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.clear_profile:1
msgid "Clear the currently loaded profile."
msgstr ""

#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.clear_profile:3
msgid "This ensures that the contents of the profile are reset as well as the ``Manager``, which may hold references to data that will be destroyed. The daemon will also be stopped if it was running."
msgstr ""

#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.config_psql_dos:1
msgid "Return a profile configuration for the :class:`~aiida.storage.psql_dos.backend.PsqlDosBackend`."
msgstr ""

#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.daemon_client:1
msgid "Return a daemon client for the configured test profile for the test session."
msgstr ""

#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.daemon_client:3
msgid "The daemon will be automatically stopped at the end of the test session."
msgstr ""

#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.entry_points:1
msgid "Return an instance of the ``EntryPointManager`` which allows to temporarily add or remove entry points."
msgstr ""

#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.entry_points:3
msgid "This fixture monkey patches the entry point caches returned by the :func:`aiida.plugins.entry_point.eps` and :func:`aiida.plugins.entry_point.eps_select` functions to class methods of the ``EntryPointManager`` so that we can dynamically add / remove entry points. Note that we do not need a deepcopy here as ``eps()`` returns an immutable ``EntryPoints`` tuple type."
msgstr ""

#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.postgres_cluster:1
msgid "Create a temporary and isolated PostgreSQL cluster using ``pgtest`` and cleanup after the yield."
msgstr ""

#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.postgres_cluster:4
msgid "Username to use for authentication."
msgstr ""

#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.postgres_cluster:5
msgid "Password to use for authentication."
msgstr ""

#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.postgres_cluster:6
msgid "Dictionary with parameters to connect to the PostgreSQL cluster."
msgstr ""

#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.recursive_merge:1
msgid "Recursively merge the ``right`` dictionary into the ``left`` dictionary."
msgstr ""

#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.recursive_merge:3
msgid "Base dictionary."
msgstr ""

#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.recursive_merge:4
msgid "Dictionary to recurisvely merge on top of ``left`` dictionary."
msgstr ""

#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.ssh_key:1
msgid "Generate a temporary SSH key pair for the test session and return the filepath of the private key."
msgstr ""

#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.ssh_key:3
msgid "The filepath of the public key is the same as the private key, but it adds the ``.pub`` file extension."
msgstr ""

#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.started_daemon_client:1
msgid "Ensure that the daemon is running for the test profile and return the associated client."
msgstr ""

#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.stopped_daemon_client:1
msgid "Ensure that the daemon is not running for the test profile and return the associated client."
msgstr ""

#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.submit_and_await:1
msgid "Submit a process and wait for it to achieve the given state."
msgstr ""

#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.suppress_deprecations:1
msgid "Decorator that suppresses all ``DeprecationWarning``."
msgstr ""

#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.temp_dir:1
msgid "Get a temporary directory."
msgstr ""

#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.temp_dir:3
msgid "E.g. to use as the working directory of an AiiDA computer."
msgstr ""

#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.temp_dir:5
msgid "The path to the directory"
msgstr ""

#: ../../../src/aiida/manage/tests/pytest_fixtures.py:docstring of aiida.manage.tests.pytest_fixtures.temporary_event_loop:1
msgid "Create a temporary loop for independent test case"
msgstr ""

#: ../../source/reference/apidoc/aiida.orm.rst:2
msgid "aiida.orm package"
msgstr ""

#: ../../../src/aiida/orm/__init__.py:docstring of aiida.orm:1
msgid "Main module to expose all orm classes and methods"
msgstr ""

#: ../../../src/aiida/orm/authinfos.py:docstring of aiida.orm.authinfos:1
msgid "Module for the `AuthInfo` ORM class."
msgstr ""

#: ../../../src/aiida/orm/authinfos.py:docstring of aiida.orm.authinfos.AuthInfo:1
msgid "Bases: :py:class:`~aiida.orm.entities.Entity`\\ [:py:class:`BackendAuthInfo`, :py:class:`~aiida.orm.authinfos.AuthInfoCollection`]"
msgstr ""

#: ../../../src/aiida/orm/authinfos.py:docstring of aiida.orm.authinfos.AuthInfo:1
msgid "ORM class that models the authorization information that allows a `User` to connect to a `Computer`."
msgstr ""

#: ../../../src/aiida/orm/authinfos.py:docstring of aiida.orm.authinfos.AuthInfo.__init__:1
msgid "Create an `AuthInfo` instance for the given computer and user."
msgstr ""

#: ../../../src/aiida/orm/authinfos.py:docstring of aiida.orm.authinfos.AuthInfo.__init__:3
msgid "a `Computer` instance"
msgstr ""

#: ../../../src/aiida/orm/authinfos.py:docstring of aiida.orm.authinfos.AuthInfo.__init__:4
msgid "a `User` instance"
msgstr ""

#: ../../../src/aiida/orm/authinfos.py:docstring of aiida.orm.authinfos.AuthInfo.__init__:5
#: ../../../src/aiida/orm/comments.py:docstring of aiida.orm.comments.Comment.__init__:6
msgid "the backend to use for the instance, or use the default backend if None"
msgstr ""

#: ../../../src/aiida/orm/authinfos.py:docstring of aiida.orm.authinfos.AuthInfo.computer:1
#: ../../../src/aiida/orm/implementation/authinfos.py:docstring of aiida.orm.implementation.authinfos.BackendAuthInfo.computer:1
#: ../../../src/aiida/storage/psql_dos/orm/authinfos.py:docstring of aiida.storage.psql_dos.orm.authinfos.SqlaAuthInfo.computer:1
msgid "Return the computer associated with this instance."
msgstr ""

#: ../../../src/aiida/orm/authinfos.py:docstring of aiida.orm.authinfos.AuthInfo.enabled:1
#: ../../../src/aiida/orm/implementation/authinfos.py:docstring of aiida.orm.implementation.authinfos.BackendAuthInfo.enabled:1
#: ../../../src/aiida/storage/psql_dos/orm/authinfos.py:docstring of aiida.storage.psql_dos.orm.authinfos.SqlaAuthInfo.enabled:1
msgid "Return whether this instance is enabled."
msgstr ""

#: ../../../src/aiida/orm/authinfos.py:docstring of aiida.orm.authinfos.AuthInfo.enabled:3
#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.is_user_enabled:4
msgid "True if enabled, False otherwise"
msgstr ""

#: ../../../src/aiida/orm/authinfos.py:docstring of aiida.orm.authinfos.AuthInfo.get_auth_params:1
#: ../../../src/aiida/orm/implementation/authinfos.py:docstring of aiida.orm.implementation.authinfos.BackendAuthInfo.get_auth_params:1
#: ../../../src/aiida/storage/psql_dos/orm/authinfos.py:docstring of aiida.storage.psql_dos.orm.authinfos.SqlaAuthInfo.get_auth_params:1
msgid "Return the dictionary of authentication parameters"
msgstr ""

#: ../../../src/aiida/orm/authinfos.py:docstring of aiida.orm.authinfos.AuthInfo.get_auth_params:3
#: ../../../src/aiida/orm/authinfos.py:docstring of aiida.orm.authinfos.AuthInfo.set_auth_params:3
#: ../../../src/aiida/orm/implementation/authinfos.py:docstring of aiida.orm.implementation.authinfos.BackendAuthInfo.get_auth_params:3
#: ../../../src/aiida/orm/implementation/authinfos.py:docstring of aiida.orm.implementation.authinfos.BackendAuthInfo.set_auth_params:3
#: ../../../src/aiida/storage/psql_dos/orm/authinfos.py:docstring of aiida.storage.psql_dos.orm.authinfos.SqlaAuthInfo.get_auth_params:3
#: ../../../src/aiida/storage/psql_dos/orm/authinfos.py:docstring of aiida.storage.psql_dos.orm.authinfos.SqlaAuthInfo.set_auth_params:3
msgid "a dictionary with authentication parameters"
msgstr ""

#: ../../../src/aiida/orm/authinfos.py:docstring of aiida.orm.authinfos.AuthInfo.get_metadata:1
#: ../../../src/aiida/orm/implementation/authinfos.py:docstring of aiida.orm.implementation.authinfos.BackendAuthInfo.get_metadata:1
#: ../../../src/aiida/storage/psql_dos/orm/authinfos.py:docstring of aiida.storage.psql_dos.orm.authinfos.SqlaAuthInfo.get_metadata:1
msgid "Return the dictionary of metadata"
msgstr ""

#: ../../../src/aiida/orm/authinfos.py:docstring of aiida.orm.authinfos.AuthInfo.get_metadata:3
#: ../../../src/aiida/orm/authinfos.py:docstring of aiida.orm.authinfos.AuthInfo.set_metadata:3
#: ../../../src/aiida/orm/implementation/authinfos.py:docstring of aiida.orm.implementation.authinfos.BackendAuthInfo.get_metadata:3
#: ../../../src/aiida/orm/implementation/authinfos.py:docstring of aiida.orm.implementation.authinfos.BackendAuthInfo.set_metadata:3
#: ../../../src/aiida/storage/psql_dos/orm/authinfos.py:docstring of aiida.storage.psql_dos.orm.authinfos.SqlaAuthInfo.get_metadata:3
#: ../../../src/aiida/storage/psql_dos/orm/authinfos.py:docstring of aiida.storage.psql_dos.orm.authinfos.SqlaAuthInfo.set_metadata:3
msgid "a dictionary with metadata"
msgstr ""

#: ../../../src/aiida/orm/authinfos.py:docstring of aiida.orm.authinfos.AuthInfo.get_transport:1
msgid "Return a fully configured transport that can be used to connect to the computer set for this instance."
msgstr ""

#: ../../../src/aiida/orm/authinfos.py:docstring of aiida.orm.authinfos.AuthInfo.get_workdir:1
msgid "Return the working directory."
msgstr ""

#: ../../../src/aiida/orm/authinfos.py:docstring of aiida.orm.authinfos.AuthInfo.get_workdir:3
msgid "If no explicit work directory is set for this instance, the working directory of the computer will be returned."
msgstr ""

#: ../../../src/aiida/orm/authinfos.py:docstring of aiida.orm.authinfos.AuthInfo.get_workdir:5
msgid "the working directory"
msgstr ""

#: ../../../src/aiida/orm/authinfos.py:docstring of aiida.orm.authinfos.AuthInfo.set_auth_params:1
#: ../../../src/aiida/orm/implementation/authinfos.py:docstring of aiida.orm.implementation.authinfos.BackendAuthInfo.set_auth_params:1
#: ../../../src/aiida/storage/psql_dos/orm/authinfos.py:docstring of aiida.storage.psql_dos.orm.authinfos.SqlaAuthInfo.set_auth_params:1
msgid "Set the dictionary of authentication parameters"
msgstr ""

#: ../../../src/aiida/orm/authinfos.py:docstring of aiida.orm.authinfos.AuthInfo.set_metadata:1
#: ../../../src/aiida/orm/implementation/authinfos.py:docstring of aiida.orm.implementation.authinfos.BackendAuthInfo.set_metadata:1
#: ../../../src/aiida/storage/psql_dos/orm/authinfos.py:docstring of aiida.storage.psql_dos.orm.authinfos.SqlaAuthInfo.set_metadata:1
msgid "Set the dictionary of metadata"
msgstr ""

#: ../../../src/aiida/orm/authinfos.py:docstring of aiida.orm.authinfos.AuthInfo.user:1
#: ../../../src/aiida/orm/implementation/authinfos.py:docstring of aiida.orm.implementation.authinfos.BackendAuthInfo.user:1
#: ../../../src/aiida/storage/psql_dos/orm/authinfos.py:docstring of aiida.storage.psql_dos.orm.authinfos.SqlaAuthInfo.user:1
msgid "Return the user associated with this instance."
msgstr ""

#: ../../../src/aiida/orm/authinfos.py:docstring of aiida.orm.authinfos.AuthInfoCollection:1
msgid "Bases: :py:class:`~aiida.orm.entities.Collection`\\ [:py:class:`AuthInfo`]"
msgstr ""

#: ../../../src/aiida/orm/authinfos.py:docstring of aiida.orm.authinfos.AuthInfoCollection:1
msgid "The collection of `AuthInfo` entries."
msgstr ""

#: ../../../src/aiida/orm/authinfos.py:docstring of aiida.orm.authinfos.AuthInfoCollection._entity_base_cls:1
#: ../../../src/aiida/orm/comments.py:docstring of aiida.orm.comments.CommentCollection._entity_base_cls:1
#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.ComputerCollection._entity_base_cls:1
#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities.Collection._entity_base_cls:1
#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.GroupCollection._entity_base_cls:1
#: ../../../src/aiida/orm/logs.py:docstring of aiida.orm.logs.LogCollection._entity_base_cls:1
#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.NodeCollection._entity_base_cls:1
#: ../../../src/aiida/orm/users.py:docstring of aiida.orm.users.UserCollection._entity_base_cls:1
msgid "The allowed entity class or subclasses thereof."
msgstr ""

#: ../../../src/aiida/orm/authinfos.py:docstring of aiida.orm.authinfos.AuthInfoCollection.delete:1
#: ../../../src/aiida/orm/implementation/authinfos.py:docstring of aiida.orm.implementation.authinfos.BackendAuthInfoCollection.delete:1
#: ../../../src/aiida/storage/psql_dos/orm/authinfos.py:docstring of aiida.storage.psql_dos.orm.authinfos.SqlaAuthInfoCollection.delete:1
msgid "Delete an entry from the collection."
msgstr ""

#: ../../../src/aiida/orm/authinfos.py:docstring of aiida.orm.authinfos.AuthInfoCollection.delete:3
#: ../../../src/aiida/orm/implementation/authinfos.py:docstring of aiida.orm.implementation.authinfos.BackendAuthInfoCollection.delete:3
#: ../../../src/aiida/orm/implementation/computers.py:docstring of aiida.orm.implementation.computers.BackendComputerCollection.delete:3
#: ../../../src/aiida/storage/psql_dos/orm/authinfos.py:docstring of aiida.storage.psql_dos.orm.authinfos.SqlaAuthInfoCollection.delete:3
#: ../../../src/aiida/storage/psql_dos/orm/computers.py:docstring of aiida.storage.psql_dos.orm.computers.SqlaComputerCollection.delete:3
msgid "the pk of the entry to delete"
msgstr ""

#: ../../../src/aiida/orm/autogroup.py:docstring of aiida.orm.autogroup:1
msgid "Module to manage the autogrouping functionality by ``verdi run``."
msgstr ""

#: ../../../src/aiida/orm/autogroup.py:docstring of aiida.orm.autogroup.AutogroupManager:1
msgid "Class to automatically add all newly stored ``Node``s to an ``AutoGroup`` (whilst enabled)."
msgstr ""

#: ../../../src/aiida/orm/autogroup.py:docstring of aiida.orm.autogroup.AutogroupManager:3
msgid "This class should not be instantiated directly, but rather accessed through the backend storage instance."
msgstr ""

#: ../../../src/aiida/orm/autogroup.py:docstring of aiida.orm.autogroup.AutogroupManager:5
msgid "The auto-grouping is checked by the ``Node.store()`` method which, if ``is_to_be_grouped`` is true, will store the node in the associated ``AutoGroup``."
msgstr ""

#: ../../../src/aiida/orm/autogroup.py:docstring of aiida.orm.autogroup.AutogroupManager:8
msgid "The exclude/include lists are lists of strings like: ``aiida.data:core.int``, ``aiida.calculation:quantumespresso.pw``, ``aiida.data:core.array.%``, ... i.e.: a string identifying the base class, followed by a colon and the path to the class as accepted by CalculationFactory/DataFactory. Each string can contain one or more wildcard characters ``%``; in this case this is used in a ``like`` comparison with the QueryBuilder. Note that in this case you have to remember that ``_`` means \"any character\" in the QueryBuilder, and you need to escape it if you mean a literal underscore."
msgstr ""

#: ../../../src/aiida/orm/autogroup.py:docstring of aiida.orm.autogroup.AutogroupManager:18
msgid "Only one of the two (between exclude and include) can be set. If none of the two is set, everything is included."
msgstr ""

#: ../../../src/aiida/orm/autogroup.py:docstring of aiida.orm.autogroup.AutogroupManager.__init__:1
msgid "Initialize the manager for the storage backend."
msgstr ""

#: ../../../src/aiida/orm/autogroup.py:docstring of aiida.orm.autogroup.AutogroupManager._matches:1
msgid "Check if 'string' matches the 'filter_string' (used for include and exclude filters)."
msgstr ""

#: ../../../src/aiida/orm/autogroup.py:docstring of aiida.orm.autogroup.AutogroupManager._matches:3
msgid "If 'filter_string' does not contain any % sign, perform an exact match. Otherwise, match with a SQL-like query, where % means any character sequence, and _ means a single character (these characters can be escaped with a backslash)."
msgstr ""

#: ../../../src/aiida/orm/autogroup.py:docstring of aiida.orm.autogroup.AutogroupManager._matches:7
msgid "the string to match."
msgstr ""

#: ../../../src/aiida/orm/autogroup.py:docstring of aiida.orm.autogroup.AutogroupManager._matches:8
msgid "the filter string."
msgstr ""

#: ../../../src/aiida/orm/autogroup.py:docstring of aiida.orm.autogroup.AutogroupManager.disable:1
msgid "Disable the auto-grouping."
msgstr ""

#: ../../../src/aiida/orm/autogroup.py:docstring of aiida.orm.autogroup.AutogroupManager.enable:1
msgid "Enable the auto-grouping."
msgstr ""

#: ../../../src/aiida/orm/autogroup.py:docstring of aiida.orm.autogroup.AutogroupManager.get_exclude:1
msgid "Return the list of classes to exclude from autogrouping."
msgstr ""

#: ../../../src/aiida/orm/autogroup.py:docstring of aiida.orm.autogroup.AutogroupManager.get_exclude:3
msgid "Returns ``None`` if no exclusion list has been set."
msgstr ""

#: ../../../src/aiida/orm/autogroup.py:docstring of aiida.orm.autogroup.AutogroupManager.get_group_label_prefix:1
msgid "Get the prefix of the label of the group. If no group label prefix was set, it will set a default one by itself."
msgstr ""

#: ../../../src/aiida/orm/autogroup.py:docstring of aiida.orm.autogroup.AutogroupManager.get_include:1
msgid "Return the list of classes to include in the autogrouping."
msgstr ""

#: ../../../src/aiida/orm/autogroup.py:docstring of aiida.orm.autogroup.AutogroupManager.get_include:3
msgid "Returns ``None`` if no inclusion list has been set."
msgstr ""

#: ../../../src/aiida/orm/autogroup.py:docstring of aiida.orm.autogroup.AutogroupManager.get_or_create_group:1
msgid "Return the current `AutoGroup`, or create one if None has been set yet."
msgstr ""

#: ../../../src/aiida/orm/autogroup.py:docstring of aiida.orm.autogroup.AutogroupManager.get_or_create_group:3
msgid "This function implements a somewhat complex logic that is however needed to make sure that, even if `verdi run` is called at the same time multiple times, e.g. in a for loop in bash, there is never the risk that two ``verdi run`` Unix processes try to create the same group, with the same label, ending up in a crash of the code (see PR #3650)."
msgstr ""

#: ../../../src/aiida/orm/autogroup.py:docstring of aiida.orm.autogroup.AutogroupManager.get_or_create_group:9
msgid "Here, instead, we make sure that if this concurrency issue happens, one of the two will get a IntegrityError from the DB, and then recover trying to create a group with a different label (with a numeric suffix appended), until it manages to create it."
msgstr ""

#: ../../../src/aiida/orm/autogroup.py:docstring of aiida.orm.autogroup.AutogroupManager.is_enabled:1
msgid "Return whether auto-grouping is enabled."
msgstr ""

#: ../../../src/aiida/orm/autogroup.py:docstring of aiida.orm.autogroup.AutogroupManager.is_to_be_grouped:1
msgid "Return whether the given node is to be auto-grouped according to enable state and include/exclude lists."
msgstr ""

#: ../../../src/aiida/orm/autogroup.py:docstring of aiida.orm.autogroup.AutogroupManager.set_exclude:1
msgid "Set the list of classes to exclude in the autogrouping."
msgstr ""

#: ../../../src/aiida/orm/autogroup.py:docstring of aiida.orm.autogroup.AutogroupManager.set_exclude:3
#: ../../../src/aiida/orm/autogroup.py:docstring of aiida.orm.autogroup.AutogroupManager.set_include:3
msgid "a list of valid entry point strings (might contain '%' to be used as string to be matched using SQL's ``LIKE`` pattern-making logic), or ``None`` to specify no include list."
msgstr ""

#: ../../../src/aiida/orm/autogroup.py:docstring of aiida.orm.autogroup.AutogroupManager.set_group_label_prefix:1
msgid "Set the label of the group to be created (or use a default)."
msgstr ""

#: ../../../src/aiida/orm/autogroup.py:docstring of aiida.orm.autogroup.AutogroupManager.set_include:1
msgid "Set the list of classes to include in the autogrouping."
msgstr ""

#: ../../../src/aiida/orm/autogroup.py:docstring of aiida.orm.autogroup.AutogroupManager.validate:1
msgid "Validate the list of strings passed to set_include and set_exclude."
msgstr ""

#: ../../../src/aiida/orm/comments.py:docstring of aiida.orm.comments:1
msgid "Comment objects and functions"
msgstr ""

#: ../../../src/aiida/orm/comments.py:docstring of aiida.orm.comments.Comment:1
msgid "Bases: :py:class:`~aiida.orm.entities.Entity`\\ [:py:class:`BackendComment`, :py:class:`~aiida.orm.comments.CommentCollection`]"
msgstr ""

#: ../../../src/aiida/orm/comments.py:docstring of aiida.orm.comments.Comment:1
msgid "Base class to map a DbComment that represents a comment attached to a certain Node."
msgstr ""

#: ../../../src/aiida/orm/comments.py:docstring of aiida.orm.comments.Comment.__init__:1
#: ../../../src/aiida/orm/implementation/comments.py:docstring of aiida.orm.implementation.comments.BackendCommentCollection.create:1
#: ../../../src/aiida/storage/psql_dos/orm/comments.py:docstring of aiida.storage.psql_dos.orm.comments.SqlaCommentCollection.create:1
msgid "Create a Comment for a given node and user"
msgstr ""

#: ../../../src/aiida/orm/comments.py:docstring of aiida.orm.comments.Comment.__init__:4
#: ../../../src/aiida/orm/implementation/comments.py:docstring of aiida.orm.implementation.comments.BackendCommentCollection.create:4
#: ../../../src/aiida/storage/psql_dos/orm/comments.py:docstring of aiida.storage.psql_dos.orm.comments.SqlaComment.__init__:4
#: ../../../src/aiida/storage/psql_dos/orm/comments.py:docstring of aiida.storage.psql_dos.orm.comments.SqlaCommentCollection.create:4
msgid "a User instance"
msgstr ""

#: ../../../src/aiida/orm/comments.py:docstring of aiida.orm.comments.Comment.__init__:5
#: ../../../src/aiida/orm/implementation/comments.py:docstring of aiida.orm.implementation.comments.BackendCommentCollection.create:5
#: ../../../src/aiida/storage/psql_dos/orm/comments.py:docstring of aiida.storage.psql_dos.orm.comments.SqlaComment.__init__:5
#: ../../../src/aiida/storage/psql_dos/orm/comments.py:docstring of aiida.storage.psql_dos.orm.comments.SqlaCommentCollection.create:5
msgid "the comment content"
msgstr ""

#: ../../../src/aiida/orm/comments.py:docstring of aiida.orm.comments.Comment.__init__:8
#: ../../../src/aiida/orm/implementation/comments.py:docstring of aiida.orm.implementation.comments.BackendCommentCollection.create:6
#: ../../../src/aiida/storage/psql_dos/orm/comments.py:docstring of aiida.storage.psql_dos.orm.comments.SqlaCommentCollection.create:6
msgid "a Comment object associated to the given node and user"
msgstr ""

#: ../../../src/aiida/orm/comments.py:docstring of aiida.orm.comments.Comment.uuid:1
msgid "Return the UUID for this comment."
msgstr ""

#: ../../../src/aiida/orm/comments.py:docstring of aiida.orm.comments.Comment.uuid:3
#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.uuid:3
#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.Group.uuid:3
#: ../../../src/aiida/orm/logs.py:docstring of aiida.orm.logs.Log.uuid:3
msgid "This identifier is unique across all entities types and backend instances."
msgstr ""

#: ../../../src/aiida/orm/comments.py:docstring of aiida.orm.comments.Comment.uuid:5
#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.uuid:5
#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.Group.uuid:5
#: ../../../src/aiida/orm/logs.py:docstring of aiida.orm.logs.Log.uuid:5
msgid "the entity uuid"
msgstr ""

#: ../../../src/aiida/orm/comments.py:docstring of aiida.orm.comments.CommentCollection:1
msgid "Bases: :py:class:`~aiida.orm.entities.Collection`\\ [:py:class:`Comment`]"
msgstr ""

#: ../../../src/aiida/orm/comments.py:docstring of aiida.orm.comments.CommentCollection:1
#: ../../../src/aiida/orm/implementation/comments.py:docstring of aiida.orm.implementation.comments.BackendCommentCollection:1
msgid "The collection of Comment entries."
msgstr ""

#: ../../../src/aiida/orm/comments.py:docstring of aiida.orm.comments.CommentCollection.delete:1
#: ../../../src/aiida/orm/implementation/comments.py:docstring of aiida.orm.implementation.comments.BackendCommentCollection.delete:1
#: ../../../src/aiida/storage/psql_dos/orm/comments.py:docstring of aiida.storage.psql_dos.orm.comments.SqlaCommentCollection.delete:1
msgid "Remove a Comment from the collection with the given id"
msgstr ""

#: ../../../src/aiida/orm/comments.py:docstring of aiida.orm.comments.CommentCollection.delete:3
#: ../../../src/aiida/orm/implementation/comments.py:docstring of aiida.orm.implementation.comments.BackendCommentCollection.delete:3
#: ../../../src/aiida/storage/psql_dos/orm/comments.py:docstring of aiida.storage.psql_dos.orm.comments.SqlaCommentCollection.delete:3
msgid "the id of the comment to delete"
msgstr ""

#: ../../../src/aiida/orm/comments.py:docstring of aiida.orm.comments.CommentCollection.delete:5
#: ../../../src/aiida/orm/implementation/comments.py:docstring of aiida.orm.implementation.comments.BackendCommentCollection.delete:5
#: ../../../src/aiida/storage/psql_dos/orm/comments.py:docstring of aiida.storage.psql_dos.orm.comments.SqlaCommentCollection.delete:6
msgid "if ``comment_id`` is not an `int`"
msgstr ""

#: ../../../src/aiida/orm/comments.py:docstring of aiida.orm.comments.CommentCollection.delete:6
#: ../../../src/aiida/orm/implementation/comments.py:docstring of aiida.orm.implementation.comments.BackendCommentCollection.delete:6
#: ../../../src/aiida/storage/psql_dos/orm/comments.py:docstring of aiida.storage.psql_dos.orm.comments.SqlaCommentCollection.delete:7
msgid "if Comment with ID ``comment_id`` is not found"
msgstr ""

#: ../../../src/aiida/orm/comments.py:docstring of aiida.orm.comments.CommentCollection.delete_all:1
msgid "Delete all Comments from the Collection"
msgstr ""

#: ../../../src/aiida/orm/comments.py:docstring of aiida.orm.comments.CommentCollection.delete_all:3
#: ../../../src/aiida/orm/implementation/comments.py:docstring of aiida.orm.implementation.comments.BackendCommentCollection.delete_all:3
#: ../../../src/aiida/storage/psql_dos/orm/comments.py:docstring of aiida.storage.psql_dos.orm.comments.SqlaCommentCollection.delete_all:3
msgid "if all Comments could not be deleted"
msgstr ""

#: ../../../src/aiida/orm/comments.py:docstring of aiida.orm.comments.CommentCollection.delete_many:1
msgid "Delete Comments from the Collection based on ``filters``"
msgstr ""

#: ../../../src/aiida/orm/comments.py:docstring of aiida.orm.comments.CommentCollection.delete_many:3
#: ../../../src/aiida/orm/implementation/comments.py:docstring of aiida.orm.implementation.comments.BackendCommentCollection.delete_many:3
#: ../../../src/aiida/orm/implementation/logs.py:docstring of aiida.orm.implementation.logs.BackendLogCollection.delete_many:3
#: ../../../src/aiida/storage/psql_dos/orm/comments.py:docstring of aiida.storage.psql_dos.orm.comments.SqlaCommentCollection.delete_many:3
#: ../../../src/aiida/storage/psql_dos/orm/logs.py:docstring of aiida.storage.psql_dos.orm.logs.SqlaLogCollection.delete_many:3
msgid "similar to QueryBuilder filter"
msgstr ""

#: ../../../src/aiida/orm/comments.py:docstring of aiida.orm.comments.CommentCollection.delete_many:5
#: ../../../src/aiida/orm/implementation/comments.py:docstring of aiida.orm.implementation.comments.BackendCommentCollection.delete_many:5
#: ../../../src/aiida/storage/psql_dos/orm/comments.py:docstring of aiida.storage.psql_dos.orm.comments.SqlaCommentCollection.delete_many:6
msgid "(former) ``PK`` s of deleted Comments"
msgstr ""

#: ../../../src/aiida/orm/comments.py:docstring of aiida.orm.comments.CommentCollection.delete_many:7
#: ../../../src/aiida/orm/implementation/comments.py:docstring of aiida.orm.implementation.comments.BackendCommentCollection.delete_many:7
#: ../../../src/aiida/orm/implementation/logs.py:docstring of aiida.orm.implementation.logs.BackendLogCollection.delete_many:7
#: ../../../src/aiida/orm/logs.py:docstring of aiida.orm.logs.LogCollection.delete_many:6
#: ../../../src/aiida/storage/psql_dos/orm/comments.py:docstring of aiida.storage.psql_dos.orm.comments.SqlaCommentCollection.delete_many:9
#: ../../../src/aiida/storage/psql_dos/orm/logs.py:docstring of aiida.storage.psql_dos.orm.logs.SqlaLogCollection.delete_many:9
msgid "if ``filters`` is not a `dict`"
msgstr ""

#: ../../../src/aiida/orm/comments.py:docstring of aiida.orm.comments.CommentCollection.delete_many:8
#: ../../../src/aiida/orm/implementation/comments.py:docstring of aiida.orm.implementation.comments.BackendCommentCollection.delete_many:8
#: ../../../src/aiida/orm/implementation/logs.py:docstring of aiida.orm.implementation.logs.BackendLogCollection.delete_many:8
#: ../../../src/aiida/orm/logs.py:docstring of aiida.orm.logs.LogCollection.delete_many:7
#: ../../../src/aiida/storage/psql_dos/orm/comments.py:docstring of aiida.storage.psql_dos.orm.comments.SqlaCommentCollection.delete_many:10
#: ../../../src/aiida/storage/psql_dos/orm/logs.py:docstring of aiida.storage.psql_dos.orm.logs.SqlaLogCollection.delete_many:10
msgid "if ``filters`` is empty"
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers:1
msgid "Module for Computer entities"
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer:1
msgid "Bases: :py:class:`~aiida.orm.entities.Entity`\\ [:py:class:`BackendComputer`, :py:class:`~aiida.orm.computers.ComputerCollection`]"
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer:1
msgid "Computer entity."
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.__init__:1
msgid "Construct a new computer."
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer._append_text_validator:1
msgid "Validates the append text string."
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer._default_mpiprocs_per_machine_validator:1
msgid "Validates the default number of CPUs per machine (node)"
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer._description_validator:1
msgid "Validates the description."
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer._hostname_validator:1
msgid "Validates the hostname."
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer._label_validator:1
msgid "Validates the label."
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer._mpirun_command_validator:1
msgid "Validates the mpirun_command variable. MUST be called after properly checking for a valid scheduler."
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer._prepend_text_validator:1
msgid "Validates the prepend text string."
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer._scheduler_type_validator:1
#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer._transport_type_validator:1
#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer._workdir_validator:1
msgid "Validates the transport string."
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.configure:1
msgid "Configure a computer for a user with valid auth params passed via kwargs"
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.configure:3
msgid "the user to configure the computer for"
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.configure:0
#: ../../../src/aiida/orm/nodes/data/orbital.py:docstring of aiida.orm.nodes.data.orbital.OrbitalData.get_orbitals:0
msgid "kwargs"
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.configure:4
msgid "the configuration keywords with corresponding values"
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.configure:5
msgid "the authinfo object for the configured user"
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.copy:1
msgid "Return a copy of the current object to work with, not stored yet."
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.default_memory_per_machine_validator:1
msgid "Validates the default amount of memory (kB) per machine (node)"
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.delete_property:1
msgid "Delete a property from this computer"
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.delete_property:3
msgid "the name of the property"
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.delete_property:4
msgid "if True raise if the property does not exist, otherwise return None"
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.description:1
msgid "Return the computer computer."
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.description:3
msgid "the description."
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.get_authinfo:1
msgid "Return the aiida.orm.authinfo.AuthInfo instance for the given user on this computer, if the computer is configured for the given user."
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.get_authinfo:5
msgid "a User instance."
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.get_authinfo:6
msgid "a AuthInfo instance"
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.get_authinfo:7
msgid "if the computer is not configured for the given user."
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.get_configuration:1
msgid "Get the configuration of computer for the given user as a dictionary"
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.get_configuration:3
msgid "the user to to get the configuration for, otherwise default user"
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.get_default_memory_per_machine:1
msgid "Return the default amount of memory (kB) per machine (node) for this computer, or None if it was not set."
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.get_default_mpiprocs_per_machine:1
msgid "Return the default number of CPUs per machine (node) for this computer, or None if it was not set."
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.get_minimum_job_poll_interval:1
msgid "Get the minimum interval between subsequent requests to poll the scheduler for job status."
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.get_minimum_job_poll_interval:3
msgid "If no value was ever set for this computer it will fall back on the default provided by the associated transport class in the ``DEFAULT_MINIMUM_JOB_POLL_INTERVAL`` attribute. If the computer doesn't have a transport class, or it cannot be loaded, or it doesn't provide a job poll interval default, then this will fall back on the ``PROPERTY_MINIMUM_SCHEDULER_POLL_INTERVAL__DEFAULT`` attribute of this class."
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.get_minimum_job_poll_interval:8
msgid "The minimum interval (in seconds)."
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.get_mpirun_command:1
msgid "Return the mpirun command. Must be a list of strings, that will be then joined with spaces when submitting."
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.get_mpirun_command:4
msgid "I also provide a sensible default that may be ok in many cases."
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.get_property:1
msgid "Get a property of this computer"
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.get_property:3
#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.set_property:3
msgid "the property name"
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.get_property:4
msgid "additional arguments"
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.get_property:6
msgid "the property value"
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.get_scheduler:1
msgid "Get a scheduler instance for this computer"
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.get_transport:1
msgid "Return a Transport class, configured with all correct parameters. The Transport is closed (meaning that if you want to run any operation with it, you have to open it first (i.e., e.g. for a SSH transport, you have to open a connection). To do this you can call ``transports.open()``, or simply run within a ``with`` statement::"
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.get_transport:11
msgid "if None, try to obtain a transport for the default user. Otherwise, pass a valid User."
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.get_transport:14
msgid "a (closed) Transport, already configured with the connection parameters to the supercomputer, as configured with ``verdi computer configure`` for the user specified as a parameter ``user``."
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.get_transport_class:1
msgid "Get the transport class for this computer.  Can be used to instantiate a transport instance."
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.get_use_double_quotes:1
msgid "Return whether the command line parameters of this computer should be escaped with double quotes."
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.get_use_double_quotes:3
#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.get_use_double_quotes:3
msgid "True if to escape with double quotes, False otherwise which is also the default."
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.get_workdir:1
msgid "Get the working directory for this computer :return: The currently configured working directory"
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.hostname:1
msgid "Return the computer hostname."
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.hostname:3
msgid "the hostname."
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.is_configured:1
msgid "Return whether the computer is configured for the current default user."
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.is_configured:3
msgid "Boolean, ``True`` if the computer is configured for the current default user, ``False`` otherwise."
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.is_user_configured:1
msgid "Is the user configured on this computer?"
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.is_user_configured:3
#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.is_user_enabled:3
msgid "the user to check"
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.is_user_configured:4
msgid "True if configured, False otherwise"
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.is_user_enabled:1
msgid "Is the given user enabled to run on this computer?"
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.label:1
msgid "Return the computer label."
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.label:3
msgid "the label."
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.metadata:1
msgid "Return the computer metadata."
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.metadata:3
msgid "the metadata."
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.scheduler_type:1
msgid "Return the computer scheduler type."
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.scheduler_type:3
msgid "the scheduler type."
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.set_default_memory_per_machine:1
msgid "Set the default amount of memory (kB) per machine (node) for this computer. Accepts None if you do not want to set this value."
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.set_default_mpiprocs_per_machine:1
msgid "Set the default number of CPUs per machine (node) for this computer. Accepts None if you do not want to set this value."
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.set_minimum_job_poll_interval:1
msgid "Set the minimum interval between subsequent requests to update the list of jobs currently running on this computer."
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.set_minimum_job_poll_interval:4
msgid "The minimum interval in seconds"
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.set_mpirun_command:1
msgid "Set the mpirun command. It must be a list of strings (you can use string.split() if you have a single, space-separated string)."
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.set_property:1
msgid "Set a property on this computer"
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.set_property:4
msgid "the new value"
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.set_shebang:1
msgid "A valid shebang line"
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.set_use_double_quotes:1
msgid "Set whether the command line parameters of this computer should be escaped with double quotes."
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.set_use_double_quotes:3
#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.set_use_double_quotes:3
msgid "True if to escape with double quotes, False otherwise."
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.store:1
msgid "Store the computer in the DB."
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.store:3
msgid "Differently from Nodes, a computer can be re-stored if its properties are to be changed (e.g. a new mpirun command, etc.)"
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.transport_type:1
msgid "Return the computer transport type."
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.transport_type:3
msgid "the transport_type."
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.uuid:1
msgid "Return the UUID for this computer."
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.validate:1
msgid "Check if the attributes and files retrieved from the DB are valid. Raise a ValidationError if something is wrong."
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.validate:4
msgid "Must be able to work even before storing: therefore, use the get_attr and similar methods that automatically read either from the DB or from the internal attribute cache."
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.Computer.validate:7
msgid "For the base class, this is always valid. Subclasses will reimplement this. In the subclass, always call the super().validate() method first!"
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.ComputerCollection:1
msgid "Bases: :py:class:`~aiida.orm.entities.Collection`\\ [:py:class:`Computer`]"
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.ComputerCollection:1
#: ../../../src/aiida/orm/implementation/computers.py:docstring of aiida.orm.implementation.computers.BackendComputerCollection:1
msgid "The collection of Computer entries."
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.ComputerCollection.delete:1
msgid "Delete the computer with the given id"
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.ComputerCollection.get_or_create:1
msgid "Try to retrieve a Computer from the DB with the given arguments; create (and store) a new Computer if such a Computer was not present yet."
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.ComputerCollection.get_or_create:4
msgid "computer label"
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.ComputerCollection.get_or_create:6
msgid "(computer, created) where computer is the computer (new or existing, in any case already stored) and created is a boolean saying"
msgstr ""

#: ../../../src/aiida/orm/computers.py:docstring of aiida.orm.computers.ComputerCollection.list_labels:1
msgid "Return a list with all the labels of the computers in the DB."
msgstr ""

#: ../../../src/aiida/orm/convert.py:docstring of aiida.orm.convert:1
msgid "Module for converting backend entities into frontend, ORM, entities"
msgstr ""

#: ../../../src/aiida/orm/convert.py:docstring of aiida.orm.convert.ConvertIterator:1
msgid "Bases: :py:class:`~collections.abc.Iterator`, :py:class:`~collections.abc.Sized`"
msgstr ""

#: ../../../src/aiida/orm/convert.py:docstring of aiida.orm.convert.ConvertIterator:1
msgid "Iterator that converts backend entities into frontend ORM entities as needed"
msgstr ""

#: ../../../src/aiida/orm/convert.py:docstring of aiida.orm.convert.ConvertIterator:3
msgid "See :func:`aiida.orm.Group.nodes` for an example."
msgstr ""

#: ../../../src/aiida/orm/convert.py:docstring of aiida.orm.convert.ConvertIterator.__next__:1
msgid "Return the next item from the iterator. When exhausted, raise StopIteration"
msgstr ""

#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities:1
msgid "Module for all common top level AiiDA entity classes and methods"
msgstr ""

#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities.Collection:1
msgid "Bases: :py:class:`~abc.ABC`, :py:class:`~typing.Generic`\\ [:py:obj:`~aiida.orm.entities.EntityType`]"
msgstr ""

#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities.Collection:1
msgid "Container class that represents the collection of objects of a particular entity type."
msgstr ""

#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities.Collection.__call__:1
msgid "Get or create a cached collection using a new backend."
msgstr ""

#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities.Collection.__init__:1
msgid "Construct a new entity collection."
msgstr ""

#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities.Collection.__init__:3
msgid "the entity type e.g. User, Computer, etc"
msgstr ""

#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities.Collection.__init__:4
msgid "the backend instance to get the collection for, or use the default"
msgstr ""

#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities.Collection.all:1
msgid "Get all entities in this collection."
msgstr ""

#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities.Collection.all:3
msgid "A list of all entities"
msgstr ""

#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities.Collection.backend:1
#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendCollection.backend:1
msgid "Return the backend."
msgstr ""

#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities.Collection.count:1
msgid "Count entities in this collection according to criteria."
msgstr ""

#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities.Collection.count:3
#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities.Collection.find:3
#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities.Collection.query:3
msgid "the keyword value pair filters to match"
msgstr ""

#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities.Collection.count:5
msgid "The number of entities found using the supplied criteria"
msgstr ""

#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities.Collection.entity_type:1
msgid "The entity type for this instance."
msgstr ""

#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities.Collection.find:1
msgid "Find collection entries matching the filter criteria."
msgstr ""

#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities.Collection.find:4
#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities.Collection.query:4
#: ../../../src/aiida/orm/logs.py:docstring of aiida.orm.logs.LogCollection.get_logs_for:4
msgid "a list of (key, direction) pairs specifying the sort order"
msgstr ""

#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities.Collection.find:5
#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities.Collection.query:5
msgid "the maximum number of results to return"
msgstr ""

#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities.Collection.find:7
msgid "a list of resulting matches"
msgstr ""

#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities.Collection.get:1
msgid "Get a single collection entry that matches the filter criteria."
msgstr ""

#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities.Collection.get:3
#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveReaderAbstract.get:8
msgid "the filters identifying the object to get"
msgstr ""

#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities.Collection.get:5
msgid "the entry"
msgstr ""

#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities.Collection.get_cached:1
msgid "Get the cached collection instance for the given entity class and backend."
msgstr ""

#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities.Collection.get_cached:3
msgid "the backend instance to get the collection for"
msgstr ""

#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities.Collection.query:1
msgid "Get a query builder for the objects of this collection."
msgstr ""

#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities.Collection.query:6
msgid "number of initial results to be skipped"
msgstr ""

#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities.Entity:1
msgid "Bases: :py:class:`~abc.ABC`, :py:class:`~typing.Generic`\\ [:py:obj:`~aiida.orm.entities.BackendEntityType`, :py:obj:`~aiida.orm.entities.CollectionType`]"
msgstr ""

#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities.Entity:1
msgid "An AiiDA entity"
msgstr ""

#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities.Entity.__getstate__:1
msgid "Prevent an ORM entity instance from being pickled."
msgstr ""

#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities.Entity.__init__:1
#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node.__init__:1
msgid "the backend model supporting this entity"
msgstr ""

#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities.Entity.backend:1
msgid "Get the backend for this entity"
msgstr ""

#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities.Entity.backend_entity:1
msgid "Get the implementing class for this object"
msgstr ""

#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities.Entity.get:1
msgid "Get an entity of the collection matching the given filters."
msgstr ""

#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities.Entity.get_collection:1
msgid "Get a collection for objects of this type for a given backend."
msgstr ""

#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities.Entity.get_collection:3
msgid "Use the ``collection`` class property instead if the currently loaded backend or backend of the default profile should be used."
msgstr ""

#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities.Entity.get_collection:6
msgid "The backend of the collection to use."
msgstr ""

#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities.Entity.get_collection:7
msgid "A collection object that can be used to access entities of this type."
msgstr ""

#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities.Entity.id:1
#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendEntity.id:1
#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendEntity.pk:1
#: ../../../src/aiida/storage/psql_dos/orm/computers.py:docstring of aiida.storage.psql_dos.orm.computers.SqlaComputer.pk:1
#: ../../../src/aiida/storage/psql_dos/orm/groups.py:docstring of aiida.storage.psql_dos.orm.groups.SqlaGroup.pk:1
msgid "Return the id for this entity."
msgstr ""

#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities.Entity.id:3
#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities.Entity.pk:3
msgid "This identifier is guaranteed to be unique amongst entities of the same type for a single backend instance."
msgstr ""

#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities.Entity.id:7
msgid "the entity's id"
msgstr ""

#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities.Entity.is_stored:1
#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendEntity.is_stored:1
#: ../../../src/aiida/storage/psql_dos/orm/authinfos.py:docstring of aiida.storage.psql_dos.orm.authinfos.SqlaAuthInfo.is_stored:1
msgid "Return whether the entity is stored."
msgstr ""

#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities.Entity.pk:1
msgid "Return the primary key for this entity."
msgstr ""

#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities.Entity.pk:5
msgid "the entity's principal key"
msgstr ""

#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities.Entity.store:1
msgid "Store the entity."
msgstr ""

#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities.EntityTypes:1
msgid "Enum for referring to ORM entities in a backend-agnostic manner."
msgstr ""

#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities.from_backend_entity:1
msgid "Construct an entity from a backend entity instance"
msgstr ""

#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities.from_backend_entity:3
msgid "the backend entity"
msgstr ""

#: ../../../src/aiida/orm/entities.py:docstring of aiida.orm.entities.from_backend_entity:5
msgid "an AiiDA entity instance"
msgstr ""

#: ../../../src/aiida/orm/extras.py:docstring of aiida.orm.extras.EntityExtras:1
msgid "Interface to the extras of a node or group instance."
msgstr ""

#: ../../../src/aiida/orm/extras.py:docstring of aiida.orm.extras.EntityExtras:3
msgid "Extras are a JSONable dictionary, stored on each entity, allowing for arbitrary data to be stored by users."
msgstr ""

#: ../../../src/aiida/orm/extras.py:docstring of aiida.orm.extras.EntityExtras:6
msgid "Extras are mutable, even after storing the entity, and as such are not deemed a core part of the provenance graph."
msgstr ""

#: ../../../src/aiida/orm/extras.py:docstring of aiida.orm.extras.EntityExtras.__contains__:1
msgid "Check if the extras contain the given key."
msgstr ""

#: ../../../src/aiida/orm/extras.py:docstring of aiida.orm.extras.EntityExtras.__init__:1
#: ../../../src/aiida/orm/nodes/attributes.py:docstring of aiida.orm.nodes.attributes.NodeAttributes.__init__:1
msgid "Initialize the interface."
msgstr ""

#: ../../../src/aiida/orm/extras.py:docstring of aiida.orm.extras.EntityExtras.all:1
#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendEntityExtrasMixin.extras:1
msgid "Return the complete extras dictionary."
msgstr ""

#: ../../../src/aiida/orm/extras.py:docstring of aiida.orm.extras.EntityExtras.all:3
#: ../../../src/aiida/orm/extras.py:docstring of aiida.orm.extras.EntityExtras.get_many:3
#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendEntityExtrasMixin.extras:3
#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendEntityExtrasMixin.get_extra_many:3
msgid "While the entity is unstored, this will return references of the extras on the database model, meaning that changes on the returned values (if they are mutable themselves, e.g. a list or dictionary) will automatically be reflected on the database model as well. As soon as the entity is stored, the returned extras will be a deep copy and mutations of the database extras will have to go through the appropriate set methods. Therefore, once stored, retrieving a deep copy can be a heavy operation. If you only need the keys or some values, use the iterators `extras_keys` and `extras_items`, or the getters `get_extra` and `get_extra_many` instead."
msgstr ""

#: ../../../src/aiida/orm/extras.py:docstring of aiida.orm.extras.EntityExtras.all:11
#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendEntityExtrasMixin.extras:11
msgid "the extras as a dictionary"
msgstr ""

#: ../../../src/aiida/orm/extras.py:docstring of aiida.orm.extras.EntityExtras.clear:1
#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendEntityExtrasMixin.clear_extras:1
msgid "Delete all extras."
msgstr ""

#: ../../../src/aiida/orm/extras.py:docstring of aiida.orm.extras.EntityExtras.delete:1
#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendEntityExtrasMixin.delete_extra:1
msgid "Delete an extra."
msgstr ""

#: ../../../src/aiida/orm/extras.py:docstring of aiida.orm.extras.EntityExtras.delete:3
#: ../../../src/aiida/orm/extras.py:docstring of aiida.orm.extras.EntityExtras.get:9
#: ../../../src/aiida/orm/extras.py:docstring of aiida.orm.extras.EntityExtras.set:3
#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendEntityExtrasMixin.delete_extra:3
#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendEntityExtrasMixin.get_extra:9
#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendEntityExtrasMixin.set_extra:3
msgid "name of the extra"
msgstr ""

#: ../../../src/aiida/orm/extras.py:docstring of aiida.orm.extras.EntityExtras.delete:4
#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendEntityExtrasMixin.delete_extra:4
#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendEntityExtrasMixin.get_extra:11
msgid "if the extra does not exist"
msgstr ""

#: ../../../src/aiida/orm/extras.py:docstring of aiida.orm.extras.EntityExtras.delete_many:1
#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendEntityExtrasMixin.delete_extra_many:1
msgid "Delete multiple extras."
msgstr ""

#: ../../../src/aiida/orm/extras.py:docstring of aiida.orm.extras.EntityExtras.delete_many:3
#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendEntityExtrasMixin.delete_extra_many:3
msgid "names of the extras to delete"
msgstr ""

#: ../../../src/aiida/orm/extras.py:docstring of aiida.orm.extras.EntityExtras.delete_many:4
#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendEntityExtrasMixin.delete_extra_many:4
msgid "if at least one of the extra does not exist"
msgstr ""

#: ../../../src/aiida/orm/extras.py:docstring of aiida.orm.extras.EntityExtras.get:1
#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendEntityExtrasMixin.get_extra:1
msgid "Return the value of an extra."
msgstr ""

#: ../../../src/aiida/orm/extras.py:docstring of aiida.orm.extras.EntityExtras.get:3
#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendEntityExtrasMixin.get_extra:3
msgid "While the entity is unstored, this will return a reference of the extra on the database model, meaning that changes on the returned value (if they are mutable themselves, e.g. a list or dictionary) will automatically be reflected on the database model as well. As soon as the entity is stored, the returned extra will be a deep copy and mutations of the database extras will have to go through the appropriate set methods."
msgstr ""

#: ../../../src/aiida/orm/extras.py:docstring of aiida.orm.extras.EntityExtras.get:10
#: ../../../src/aiida/orm/nodes/attributes.py:docstring of aiida.orm.nodes.attributes.NodeAttributes.get:10
msgid "return this value instead of raising if the attribute does not exist"
msgstr ""

#: ../../../src/aiida/orm/extras.py:docstring of aiida.orm.extras.EntityExtras.get:11
#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendEntityExtrasMixin.get_extra:10
msgid "the value of the extra"
msgstr ""

#: ../../../src/aiida/orm/extras.py:docstring of aiida.orm.extras.EntityExtras.get:12
msgid "if the extra does not exist and no default is specified"
msgstr ""

#: ../../../src/aiida/orm/extras.py:docstring of aiida.orm.extras.EntityExtras.get_many:1
#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendEntityExtrasMixin.get_extra_many:1
msgid "Return the values of multiple extras."
msgstr ""

#: ../../../src/aiida/orm/extras.py:docstring of aiida.orm.extras.EntityExtras.get_many:11
#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendEntityExtrasMixin.get_extra_many:11
msgid "a list of extra names"
msgstr ""

#: ../../../src/aiida/orm/extras.py:docstring of aiida.orm.extras.EntityExtras.get_many:12
#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendEntityExtrasMixin.get_extra_many:12
msgid "a list of extra values"
msgstr ""

#: ../../../src/aiida/orm/extras.py:docstring of aiida.orm.extras.EntityExtras.get_many:13
#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendEntityExtrasMixin.get_extra_many:13
msgid "if at least one extra does not exist"
msgstr ""

#: ../../../src/aiida/orm/extras.py:docstring of aiida.orm.extras.EntityExtras.items:1
msgid "Return an iterator over the extras."
msgstr ""

#: ../../../src/aiida/orm/extras.py:docstring of aiida.orm.extras.EntityExtras.items:3
msgid "an iterator with extra key value pairs"
msgstr ""

#: ../../../src/aiida/orm/extras.py:docstring of aiida.orm.extras.EntityExtras.keys:1
#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendEntityExtrasMixin.extras_keys:1
msgid "Return an iterator over the extra keys."
msgstr ""

#: ../../../src/aiida/orm/extras.py:docstring of aiida.orm.extras.EntityExtras.keys:3
msgid "an iterator with extra keys"
msgstr ""

#: ../../../src/aiida/orm/extras.py:docstring of aiida.orm.extras.EntityExtras.reset:1
#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendEntityExtrasMixin.reset_extras:1
msgid "Reset the extras."
msgstr ""

#: ../../../src/aiida/orm/extras.py:docstring of aiida.orm.extras.EntityExtras.reset:3
#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendEntityExtrasMixin.reset_extras:3
msgid "This will completely clear any existing extras and replace them with the new dictionary."
msgstr ""

#: ../../../src/aiida/orm/extras.py:docstring of aiida.orm.extras.EntityExtras.reset:5
#: ../../../src/aiida/orm/extras.py:docstring of aiida.orm.extras.EntityExtras.set_many:5
#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendEntityExtrasMixin.reset_extras:5
#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendEntityExtrasMixin.set_extra_many:5
msgid "a dictionary with the extras to set"
msgstr ""

#: ../../../src/aiida/orm/extras.py:docstring of aiida.orm.extras.EntityExtras.reset:6
#: ../../../src/aiida/orm/extras.py:docstring of aiida.orm.extras.EntityExtras.set_many:6
#: ../../../src/aiida/orm/nodes/attributes.py:docstring of aiida.orm.nodes.attributes.NodeAttributes.reset:6
#: ../../../src/aiida/orm/nodes/attributes.py:docstring of aiida.orm.nodes.attributes.NodeAttributes.set_many:6
msgid "if any of the keys are invalid, i.e. contain periods"
msgstr ""

#: ../../../src/aiida/orm/extras.py:docstring of aiida.orm.extras.EntityExtras.set:1
#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendEntityExtrasMixin.set_extra:1
msgid "Set an extra to the given value."
msgstr ""

#: ../../../src/aiida/orm/extras.py:docstring of aiida.orm.extras.EntityExtras.set:4
#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendEntityExtrasMixin.set_extra:4
msgid "value of the extra"
msgstr ""

#: ../../../src/aiida/orm/extras.py:docstring of aiida.orm.extras.EntityExtras.set:5
#: ../../../src/aiida/orm/nodes/attributes.py:docstring of aiida.orm.nodes.attributes.NodeAttributes.set:5
msgid "if the key is invalid, i.e. contains periods"
msgstr ""

#: ../../../src/aiida/orm/extras.py:docstring of aiida.orm.extras.EntityExtras.set_many:1
#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendEntityExtrasMixin.set_extra_many:1
msgid "Set multiple extras."
msgstr ""

#: ../../../src/aiida/orm/extras.py:docstring of aiida.orm.extras.EntityExtras.set_many:3
#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendEntityExtrasMixin.set_extra_many:3
msgid "This will override any existing extras that are present in the new dictionary."
msgstr ""

#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups:1
msgid "AiiDA Group entites"
msgstr ""

#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.AutoGroup:1
#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.ImportGroup:1
#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.UpfFamily:1
msgid "Bases: :py:class:`~aiida.orm.groups.Group`"
msgstr ""

#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.AutoGroup:1
msgid "Group to be used to contain selected nodes generated, whilst autogrouping is enabled."
msgstr ""

#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.Group:1
msgid "Bases: :py:class:`~aiida.orm.entities.Entity`\\ [:py:class:`BackendGroup`, :py:class:`~aiida.orm.groups.GroupCollection`]"
msgstr ""

#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.Group:1
msgid "An AiiDA ORM implementation of group of nodes."
msgstr ""

#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.Group.__getattr__:1
msgid "This method is called when an extras is not found in the instance."
msgstr ""

#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.Group.__getattr__:3
#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node.__getattr__:3
msgid "It allows for the handling of deprecated mixin methods."
msgstr ""

#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.Group.__init__:1
msgid "Create a new group. Either pass a dbgroup parameter, to reload a group from the DB (and then, no further parameters are allowed), or pass the parameters for the Group creation."
msgstr ""

#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.Group.__init__:5
msgid "The group label, required on creation"
msgstr ""

#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.Group.__init__:6
msgid "The group description (by default, an empty string)"
msgstr ""

#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.Group.__init__:7
msgid "The owner of the group (by default, the automatic user)"
msgstr ""

#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.Group.__init__:8
msgid "a string identifying the type of group (by default, an empty string, indicating an user-defined group."
msgstr ""

#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.Group.add_nodes:1
#: ../../../src/aiida/storage/psql_dos/orm/groups.py:docstring of aiida.storage.psql_dos.orm.groups.SqlaGroup.add_nodes:1
msgid "Add a node or a set of nodes to the group."
msgstr ""

#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.Group.add_nodes:3
#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.Group.remove_nodes:3
#: ../../../src/aiida/orm/implementation/groups.py:docstring of aiida.orm.implementation.groups.BackendGroup.add_nodes:3
#: ../../../src/aiida/orm/implementation/groups.py:docstring of aiida.orm.implementation.groups.BackendGroup.remove_nodes:3
#: ../../../src/aiida/storage/psql_dos/orm/groups.py:docstring of aiida.storage.psql_dos.orm.groups.SqlaGroup.add_nodes:3
#: ../../../src/aiida/storage/psql_dos/orm/groups.py:docstring of aiida.storage.psql_dos.orm.groups.SqlaGroup.remove_nodes:3
msgid "all the nodes *and* the group itself have to be stored."
msgstr ""

#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.Group.add_nodes:5
#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.Group.remove_nodes:5
msgid "a single `Node` or a list of `Nodes`"
msgstr ""

#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.Group.base:1
msgid "Return the group base namespace."
msgstr ""

#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.Group.clear:1
#: ../../../src/aiida/orm/implementation/groups.py:docstring of aiida.orm.implementation.groups.BackendGroup.clear:1
#: ../../../src/aiida/storage/psql_dos/orm/groups.py:docstring of aiida.storage.psql_dos.orm.groups.SqlaGroup.clear:1
msgid "Remove all the nodes from this group."
msgstr ""

#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.Group.count:1
#: ../../../src/aiida/orm/implementation/groups.py:docstring of aiida.orm.implementation.groups.BackendGroup.count:1
#: ../../../src/aiida/storage/psql_dos/orm/groups.py:docstring of aiida.storage.psql_dos.orm.groups.SqlaGroup.count:1
msgid "Return the number of entities in this group."
msgstr ""

#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.Group.count:3
#: ../../../src/aiida/orm/implementation/groups.py:docstring of aiida.orm.implementation.groups.BackendGroup.count:3
#: ../../../src/aiida/storage/psql_dos/orm/groups.py:docstring of aiida.storage.psql_dos.orm.groups.SqlaGroup.count:3
msgid "integer number of entities contained within the group"
msgstr ""

#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.Group.description:1
msgid "the description of the group as a string"
msgstr ""

#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.Group.is_empty:1
msgid "Return whether the group is empty, i.e. it does not contain any nodes."
msgstr ""

#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.Group.is_empty:3
msgid "True if it contains no nodes, False otherwise"
msgstr ""

#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.Group.is_user_defined:1
msgid "True if the group is user defined, False otherwise"
msgstr ""

#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.Group.label:1
msgid "the label of the group as a string"
msgstr ""

#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.Group.nodes:1
#: ../../../src/aiida/orm/implementation/groups.py:docstring of aiida.orm.implementation.groups.BackendGroup.nodes:1
msgid "Return a generator/iterator that iterates over all nodes and returns the respective AiiDA subclasses of Node, and also allows to ask for the number of nodes in the group using len()."
msgstr ""

#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.Group.remove_nodes:1
msgid "Remove a node or a set of nodes to the group."
msgstr ""

#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.Group.store:1
msgid "Verify that the group is allowed to be stored, which is the case along as `type_string` is set."
msgstr ""

#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.Group.type_string:1
msgid "the string defining the type of the group"
msgstr ""

#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.Group.user:1
msgid "the user associated with this group"
msgstr ""

#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.Group.uuid:1
msgid "Return the UUID for this group."
msgstr ""

#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.GroupBase:1
msgid "A namespace for group related functionality, that is not directly related to its user-facing properties."
msgstr ""

#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.GroupBase.__init__:1
#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.NodeBase.__init__:1
msgid "Construct a new instance of the base namespace."
msgstr ""

#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.GroupBase.extras:1
msgid "Return the extras of this group."
msgstr ""

#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.GroupCollection:1
msgid "Bases: :py:class:`~aiida.orm.entities.Collection`\\ [:py:class:`Group`]"
msgstr ""

#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.GroupCollection:1
msgid "Collection of Groups"
msgstr ""

#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.GroupCollection.delete:1
msgid "Delete a group"
msgstr ""

#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.GroupCollection.delete:3
#: ../../../src/aiida/orm/implementation/groups.py:docstring of aiida.orm.implementation.groups.BackendGroupCollection.delete:3
#: ../../../src/aiida/storage/psql_dos/orm/groups.py:docstring of aiida.storage.psql_dos.orm.groups.SqlaGroupCollection.delete:3
msgid "the id of the group to delete"
msgstr ""

#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.GroupCollection.get_or_create:1
msgid "Try to retrieve a group from the DB with the given arguments; create (and store) a new group if such a group was not present yet."
msgstr ""

#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.GroupCollection.get_or_create:4
msgid "group label"
msgstr ""

#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.GroupCollection.get_or_create:6
msgid "(group, created) where group is the group (new or existing, in any case already stored) and created is a boolean saying"
msgstr ""

#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.ImportGroup:1
msgid "Group to be used to contain all nodes from an export archive that has been imported."
msgstr ""

#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.UpfFamily:1
msgid "Group that represents a pseudo potential family containing `UpfData` nodes."
msgstr ""

#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.load_group_class:1
msgid "Load the sub class of `Group` that corresponds to the given `type_string`."
msgstr ""

#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.load_group_class:3
msgid "will fall back on `aiida.orm.groups.Group` if `type_string` cannot be resolved to loadable entry point."
msgstr ""

#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.load_group_class:5
msgid "the entry point name of the `Group` sub class"
msgstr ""

#: ../../../src/aiida/orm/groups.py:docstring of aiida.orm.groups.load_group_class:6
msgid "sub class of `Group` registered through an entry point"
msgstr ""

#: ../../../src/aiida/orm/logs.py:docstring of aiida.orm.logs:1
msgid "Module for orm logging abstract classes"
msgstr ""

#: ../../../src/aiida/orm/logs.py:docstring of aiida.orm.logs.Log:1
msgid "Bases: :py:class:`~aiida.orm.entities.Entity`\\ [:py:class:`BackendLog`, :py:class:`~aiida.orm.logs.LogCollection`]"
msgstr ""

#: ../../../src/aiida/orm/logs.py:docstring of aiida.orm.logs.Log:1
msgid "An AiiDA Log entity.  Corresponds to a logged message against a particular AiiDA node."
msgstr ""

#: ../../../src/aiida/orm/logs.py:docstring of aiida.orm.logs.Log.__init__:1
msgid "Construct a new log"
msgstr ""

#: ../../../src/aiida/orm/logs.py:docstring of aiida.orm.logs.Log.__init__:3
msgid "time"
msgstr ""

#: ../../../src/aiida/orm/logs.py:docstring of aiida.orm.logs.Log.__init__:4
msgid "name of logger"
msgstr ""

#: ../../../src/aiida/orm/logs.py:docstring of aiida.orm.logs.Log.__init__:5
msgid "name of log level"
msgstr ""

#: ../../../src/aiida/orm/logs.py:docstring of aiida.orm.logs.Log.__init__:6
msgid "id of database node"
msgstr ""

#: ../../../src/aiida/orm/logs.py:docstring of aiida.orm.logs.Log.__init__:7
msgid "log message"
msgstr ""

#: ../../../src/aiida/orm/logs.py:docstring of aiida.orm.logs.Log.__init__:8
msgid "metadata"
msgstr ""

#: ../../../src/aiida/orm/logs.py:docstring of aiida.orm.logs.Log.__init__:9
msgid "database backend"
msgstr ""

#: ../../../src/aiida/orm/logs.py:docstring of aiida.orm.logs.Log.dbnode_id:1
#: ../../../src/aiida/storage/psql_dos/orm/logs.py:docstring of aiida.storage.psql_dos.orm.logs.SqlaLog.dbnode_id:1
msgid "Get the id of the object that created the log entry"
msgstr ""

#: ../../../src/aiida/orm/logs.py:docstring of aiida.orm.logs.Log.dbnode_id:3
msgid "The id of the object that created the log entry"
msgstr ""

#: ../../../src/aiida/orm/logs.py:docstring of aiida.orm.logs.Log.levelname:1
#: ../../../src/aiida/storage/psql_dos/orm/logs.py:docstring of aiida.storage.psql_dos.orm.logs.SqlaLog.levelname:1
msgid "The name of the log level"
msgstr ""

#: ../../../src/aiida/orm/logs.py:docstring of aiida.orm.logs.Log.levelname:3
msgid "The entry log level name"
msgstr ""

#: ../../../src/aiida/orm/logs.py:docstring of aiida.orm.logs.Log.loggername:1
#: ../../../src/aiida/storage/psql_dos/orm/logs.py:docstring of aiida.storage.psql_dos.orm.logs.SqlaLog.loggername:1
msgid "The name of the logger that created this entry"
msgstr ""

#: ../../../src/aiida/orm/logs.py:docstring of aiida.orm.logs.Log.loggername:3
msgid "The entry loggername"
msgstr ""

#: ../../../src/aiida/orm/logs.py:docstring of aiida.orm.logs.Log.message:1
#: ../../../src/aiida/storage/psql_dos/orm/logs.py:docstring of aiida.storage.psql_dos.orm.logs.SqlaLog.message:1
msgid "Get the message corresponding to the entry"
msgstr ""

#: ../../../src/aiida/orm/logs.py:docstring of aiida.orm.logs.Log.message:3
msgid "The entry message"
msgstr ""

#: ../../../src/aiida/orm/logs.py:docstring of aiida.orm.logs.Log.metadata:1
#: ../../../src/aiida/storage/psql_dos/orm/logs.py:docstring of aiida.storage.psql_dos.orm.logs.SqlaLog.metadata:1
msgid "Get the metadata corresponding to the entry"
msgstr ""

#: ../../../src/aiida/orm/logs.py:docstring of aiida.orm.logs.Log.metadata:3
msgid "The entry metadata"
msgstr ""

#: ../../../src/aiida/orm/logs.py:docstring of aiida.orm.logs.Log.time:1
#: ../../../src/aiida/storage/psql_dos/orm/logs.py:docstring of aiida.storage.psql_dos.orm.logs.SqlaLog.time:1
msgid "Get the time corresponding to the entry"
msgstr ""

#: ../../../src/aiida/orm/logs.py:docstring of aiida.orm.logs.Log.time:3
msgid "The entry timestamp"
msgstr ""

#: ../../../src/aiida/orm/logs.py:docstring of aiida.orm.logs.Log.uuid:1
msgid "Return the UUID for this log."
msgstr ""

#: ../../../src/aiida/orm/logs.py:docstring of aiida.orm.logs.LogCollection:1
msgid "Bases: :py:class:`~aiida.orm.entities.Collection`\\ [:py:class:`Log`]"
msgstr ""

#: ../../../src/aiida/orm/logs.py:docstring of aiida.orm.logs.LogCollection:1
msgid "This class represents the collection of logs and can be used to create and retrieve logs."
msgstr ""

#: ../../../src/aiida/orm/logs.py:docstring of aiida.orm.logs.LogCollection.create_entry_from_record:1
msgid "Helper function to create a log entry from a record created as by the python logging library"
msgstr ""

#: ../../../src/aiida/orm/logs.py:docstring of aiida.orm.logs.LogCollection.create_entry_from_record:3
msgid "The record created by the logging module"
msgstr ""

#: ../../../src/aiida/orm/logs.py:docstring of aiida.orm.logs.LogCollection.create_entry_from_record:4
msgid "A stored log instance"
msgstr ""

#: ../../../src/aiida/orm/implementation/logs.py:docstring of aiida.orm.implementation.logs.BackendLogCollection.delete:1
#: ../../../src/aiida/orm/logs.py:docstring of aiida.orm.logs.LogCollection.delete:1
#: ../../../src/aiida/storage/psql_dos/orm/logs.py:docstring of aiida.storage.psql_dos.orm.logs.SqlaLogCollection.delete:1
msgid "Remove a Log entry from the collection with the given id"
msgstr ""

#: ../../../src/aiida/orm/implementation/logs.py:docstring of aiida.orm.implementation.logs.BackendLogCollection.delete:3
#: ../../../src/aiida/orm/logs.py:docstring of aiida.orm.logs.LogCollection.delete:3
#: ../../../src/aiida/storage/psql_dos/orm/logs.py:docstring of aiida.storage.psql_dos.orm.logs.SqlaLogCollection.delete:3
msgid "id of the Log to delete"
msgstr ""

#: ../../../src/aiida/orm/logs.py:docstring of aiida.orm.logs.LogCollection.delete:5
msgid "if Log with ID ``pk`` is not found"
msgstr ""

#: ../../../src/aiida/orm/logs.py:docstring of aiida.orm.logs.LogCollection.delete_all:1
msgid "Delete all Logs in the collection"
msgstr ""

#: ../../../src/aiida/orm/implementation/logs.py:docstring of aiida.orm.implementation.logs.BackendLogCollection.delete_all:3
#: ../../../src/aiida/orm/logs.py:docstring of aiida.orm.logs.LogCollection.delete_all:3
#: ../../../src/aiida/storage/psql_dos/orm/logs.py:docstring of aiida.storage.psql_dos.orm.logs.SqlaLogCollection.delete_all:3
msgid "if all Logs could not be deleted"
msgstr ""

#: ../../../src/aiida/orm/implementation/logs.py:docstring of aiida.orm.implementation.logs.BackendLogCollection.delete_many:1
#: ../../../src/aiida/orm/logs.py:docstring of aiida.orm.logs.LogCollection.delete_many:1
#: ../../../src/aiida/storage/psql_dos/orm/logs.py:docstring of aiida.storage.psql_dos.orm.logs.SqlaLogCollection.delete_many:1
msgid "Delete Logs based on ``filters``"
msgstr ""

#: ../../../src/aiida/orm/logs.py:docstring of aiida.orm.logs.LogCollection.delete_many:3
msgid "filters to pass to the QueryBuilder"
msgstr ""

#: ../../../src/aiida/orm/implementation/logs.py:docstring of aiida.orm.implementation.logs.BackendLogCollection.delete_many:5
#: ../../../src/aiida/orm/logs.py:docstring of aiida.orm.logs.LogCollection.delete_many:4
#: ../../../src/aiida/storage/psql_dos/orm/logs.py:docstring of aiida.storage.psql_dos.orm.logs.SqlaLogCollection.delete_many:6
msgid "(former) ``PK`` s of deleted Logs"
msgstr ""

#: ../../../src/aiida/orm/logs.py:docstring of aiida.orm.logs.LogCollection.get_logs_for:1
msgid "Get all the log messages for a given node and optionally sort"
msgstr ""

#: ../../../src/aiida/orm/logs.py:docstring of aiida.orm.logs.LogCollection.get_logs_for:3
msgid "the entity to get logs for"
msgstr ""

#: ../../../src/aiida/orm/logs.py:docstring of aiida.orm.logs.LogCollection.get_logs_for:6
msgid "the list of log entries"
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder:1
msgid "The QueryBuilder: A class that allows you to query the AiiDA database, independent from backend. Note that the backend implementation is enforced and handled with a composition model! :func:`QueryBuilder` is the frontend class that the user can use. It inherits from *object* and contains backend-specific functionality. Backend specific functionality is provided by the implementation classes."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder:6
msgid "These inherit from :func:`aiida.orm.implementation.querybuilder.BackendQueryBuilder`, an interface classes which enforces the implementation of its defined methods. An instance of one of the implementation classes becomes a member of the :func:`QueryBuilder` instance when instantiated by the user."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.Classifier:1
msgid "A classifier for an entity."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of namedtuple_Classifier.Classifier.__new__:1
msgid "Create new instance of Classifier(ormclass_type_string, process_type_string)"
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of collections.Classifier._make:1
msgid "Make a new Classifier object from a sequence or iterable"
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of collections.Classifier._replace:1
msgid "Return a new Classifier object replacing specified fields with new values"
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder:1
msgid "The class to query the AiiDA database."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.__deepcopy__:1
msgid "Create deep copy of the instance."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.__init__:1
msgid "Instantiates a QueryBuilder instance."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.__init__:3
msgid "Which backend is used decided here based on backend-settings (taken from the user profile). This cannot be overridden so far by the user."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.__init__:6
msgid "Turn on debug mode. This feature prints information on the screen about the stages of the QueryBuilder. Does not affect results."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.__init__:9
msgid "A list of the vertices to traverse. Leave empty if you plan on using the method :func:`QueryBuilder.append`."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.__init__:12
msgid "The filters to apply. You can specify the filters here, when appending to the query using :func:`QueryBuilder.append` or even later using :func:`QueryBuilder.add_filter`. Check latter gives API-details."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.__init__:16
msgid "The projections to apply. You can specify the projections here, when appending to the query using :func:`QueryBuilder.append` or even later using :func:`QueryBuilder.add_projection`. Latter gives you API-details."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.__init__:20
msgid "Limit the number of rows to this number. Check :func:`QueryBuilder.limit` for more information."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.__init__:23
msgid "Set an offset for the results returned. Details in :func:`QueryBuilder.offset`."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.__init__:25
msgid "How to order the results. As the 2 above, can be set also at later stage, check :func:`QueryBuilder.order_by` for more information."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.__init__:28
msgid "Whether to return de-duplicated rows"
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.__repr__:1
msgid "Return an unambiguous string representation of the instance."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.__str__:1
msgid "Return a readable string representation of the instance."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder._add_group_type_filter:1
msgid "Add a filter based on group type."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder._add_group_type_filter:3
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder._add_node_type_filter:3
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder._add_process_type_filter:3
msgid "The tag, which has to exist already as a key in self._filters"
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder._add_group_type_filter:4
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder._add_node_type_filter:4
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder._add_process_type_filter:4
msgid "a dictionary with classifiers"
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder._add_group_type_filter:5
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder._add_node_type_filter:5
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder._get_group_type_filter:4
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder._get_node_type_filter:4
msgid "if True, allow for subclasses of the ormclass"
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder._add_node_type_filter:1
msgid "Add a filter based on node type."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder._add_process_type_filter:1
msgid "Add a filter based on process type."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder._add_process_type_filter:5
msgid "if True, allow for subclasses of the process type"
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder._add_process_type_filter:7
msgid "Note: This function handles the case when process_type_string is None."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder._get_aiida_entity_res:1
msgid "Convert a projected query result to front end class if it is an instance of a `BackendEntity`."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder._get_aiida_entity_res:3
msgid "Values that are not an `BackendEntity` instance will be returned unaltered"
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder._get_aiida_entity_res:5
msgid "a projected query result to convert"
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder._get_aiida_entity_res:6
msgid "the converted value"
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder._get_unique_tag:1
msgid "Using the function get_tag_from_type, I get a tag. I increment an index that is appended to that tag until I have an unused tag. This function is called in :func:`QueryBuilder.append` when no tag is given."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder._get_unique_tag:5
msgid "Classifiers, containing the string that defines the type of the AiiDA ORM class. For subclasses of Node, this is the Node._plugin_type_string, for other they are as defined as returned by :func:`QueryBuilder._get_ormclass`.  Can also be a list of dictionaries, when multiple classes are passed to QueryBuilder.append"
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder._get_unique_tag:6
msgid "Classifiers, containing the string that defines the type of the AiiDA ORM class. For subclasses of Node, this is the Node._plugin_type_string, for other they are as defined as returned by :func:`QueryBuilder._get_ormclass`."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder._get_unique_tag:10
msgid "Can also be a list of dictionaries, when multiple classes are passed to QueryBuilder.append"
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder._get_unique_tag:12
msgid "A tag as a string (it is a single string also when passing multiple classes)."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder._process_filters:1
msgid "Process filters."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.add_filter:1
msgid "Adding a filter to my filters."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.add_filter:3
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.add_projection:3
msgid "A tag string or an ORM class which maps to an existing tag"
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.add_filter:4
msgid "The specifications for the filter, has to be a dictionary"
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.add_projection:1
msgid "Adds a projection"
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.add_projection:4
msgid "The specification for the projection. A projection is a list of dictionaries, with each dictionary containing key-value pairs where the key is database entity (e.g. a column / an attribute) and the value is (optional) additional information on how to process this database entity."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.add_projection:11
msgid "If the given *projection_spec* is not a list, it will be expanded to a list. If the listitems are not dictionaries, but strings (No additional processing of the projected results desired), they will be expanded to dictionaries."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.add_projection:25
msgid "The above example will project the uuid and the kinds-attribute of all matching structures. There are 2 (so far) special keys."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.add_projection:28
msgid "The single star *\\** will project the *ORM-instance*::"
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.add_projection:37
msgid "The double star ``**`` projects all possible projections of this entity:"
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.add_projection:39
msgid "QueryBuilder().append(StructureData,tag='s', project='**').limit(1).dict()[0]['s'].keys()"
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.add_projection:41
msgid "# >>> 'user_id, description, ctime, label, extras, mtime, id, attributes, dbcomputer_id, type, uuid'"
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.add_projection:43
msgid "Be aware that the result of ``**`` depends on the backend implementation."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.all:1
msgid "Executes the full query with the order of the rows as returned by the backend."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.all:3
msgid "The order inside each row is given by the order of the vertices in the path and the order of the projections for each vertex in the path."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.all:6
msgid "the size of the batches to ask the backend to batch results in subcollections. You can optimize the speed of the query by tuning this parameter. Leave the default `None` if speed is not critical or if you don't know what you're doing."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.all:9
msgid "return the result as a flat list of projected entities without sub lists."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.all:10
msgid "a list of lists of all projected entities."
msgstr ""

#: ../../../src/aiida/orm/implementation/querybuilder.py:docstring of aiida.orm.implementation.querybuilder.BackendQueryBuilder.analyze_query:1
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.analyze_query:1
msgid "Return the query plan, i.e. a list of SQL statements that will be executed."
msgstr ""

#: ../../../src/aiida/orm/implementation/querybuilder.py:docstring of aiida.orm.implementation.querybuilder.BackendQueryBuilder.analyze_query:3
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.analyze_query:3
msgid "See: https://www.postgresql.org/docs/11/sql-explain.html"
msgstr ""

#: ../../../src/aiida/orm/implementation/querybuilder.py:docstring of aiida.orm.implementation.querybuilder.BackendQueryBuilder.analyze_query:0
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.analyze_query:0
msgid "params execute"
msgstr ""

#: ../../../src/aiida/orm/implementation/querybuilder.py:docstring of aiida.orm.implementation.querybuilder.BackendQueryBuilder.analyze_query:5
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.analyze_query:5
msgid "Carry out the command and show actual run times and other statistics."
msgstr ""

#: ../../../src/aiida/orm/implementation/querybuilder.py:docstring of aiida.orm.implementation.querybuilder.BackendQueryBuilder.analyze_query:0
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.analyze_query:0
msgid "params verbose"
msgstr ""

#: ../../../src/aiida/orm/implementation/querybuilder.py:docstring of aiida.orm.implementation.querybuilder.BackendQueryBuilder.analyze_query:6
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.analyze_query:6
msgid "Display additional information regarding the plan."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.append:1
msgid "Any iterative procedure to build the path for a graph query needs to invoke this method to append to the path."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.append:4
msgid "The Aiida-class (or backend-class) defining the appended vertice. Also supports a tuple/list of classes. This results in an all instances of this class being accepted in a query. However the classes have to have the same orm-class for the joining to work. I.e. both have to subclasses of Node. Valid is::      cls=(StructureData, Dict)  This is invalid:      cls=(Group, Node)"
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.append:5
msgid "The Aiida-class (or backend-class) defining the appended vertice. Also supports a tuple/list of classes. This results in an all instances of this class being accepted in a query. However the classes have to have the same orm-class for the joining to work. I.e. both have to subclasses of Node. Valid is::"
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.append:12
msgid "This is invalid:"
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.append:14
msgid "cls=(Group, Node)"
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.append:16
msgid "The node type of the class, if cls is not given. Also here, a tuple or list is accepted."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.append:17
msgid "A unique tag. If none is given, I will create a unique tag myself."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.append:19
msgid "Filters to apply for this vertex. See :meth:`.add_filter`, the method invoked in the background, or usage examples for details."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.append:22
msgid "Projections to apply. See usage examples for details. More information also in :meth:`.add_projection`."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.append:25
msgid "Whether to include subclasses of the given class (default **True**). E.g. Specifying a ProcessNode as cls will include CalcJobNode, WorkChainNode, CalcFunctionNode, etc.."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.append:28
msgid "The tag that the edge will get. If nothing is specified (and there is a meaningful edge) the default is tag1--tag2 with tag1 being the entity joining from and tag2 being the entity joining to (this entity)."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.append:32
msgid "The filters to apply on the edge. Also here, details in :meth:`.add_filter`."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.append:34
msgid "The project from the edges. API-details in :meth:`.add_projection`."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.append:36
msgid "If True, (default is False), will do a left outerjoin instead of an inner join"
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.append:40
msgid "Joining can be specified in two ways:"
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.append:42
msgid "Specifying the 'joining_keyword' and 'joining_value' arguments"
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.append:43
msgid "Specify a single keyword argument"
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.append:45
msgid "The joining keyword wil be ``with_*`` or ``direction``, depending on the joining entity type. The joining value is the tag name or class of the entity to join to."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.append:48
msgid "A small usage example how this can be invoked::"
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.as_dict:1
msgid "Convert to a JSON serialisable dictionary representation of the query."
msgstr ""

#: ../../../src/aiida/orm/implementation/querybuilder.py:docstring of aiida.orm.implementation.querybuilder.BackendQueryBuilder.as_sql:1
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.as_sql:1
msgid "Convert the query to an SQL string representation."
msgstr ""

#: ../../../src/aiida/orm/implementation/querybuilder.py:docstring of aiida.orm.implementation.querybuilder.BackendQueryBuilder.as_sql:5
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.as_sql:5
msgid "This method should be used for debugging purposes only, since normally sqlalchemy will handle this process internally."
msgstr ""

#: ../../../src/aiida/orm/implementation/querybuilder.py:docstring of aiida.orm.implementation.querybuilder.BackendQueryBuilder.as_sql:0
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.as_sql:0
msgid "params inline"
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.as_sql:8
msgid "Inline bound parameters (this is normally handled by the Python DB-API)."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.backend:1
msgid "Return the backend used by the QueryBuilder."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.children:1
msgid "Join to children/descendants of previous vertice in path."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.count:1
msgid "Counts the number of rows returned by the backend."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.count:3
msgid "the number of rows as an integer"
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.debug:1
msgid "Log debug message."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.debug:3
msgid "objects will passed to the format string, e.g. ``msg % objects``"
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.dict:1
msgid "Executes the full query with the order of the rows as returned by the backend. the order inside each row is given by the order of the vertices in the path and the order of the projections for each vertice in the path."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.dict:5
msgid "The size of the batches to ask the backend to batch results in subcollections. You can optimize the speed of the query by tuning this parameter. Leave the default (*None*) if speed is not critical or if you don't know what you're doing!"
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.dict:10
msgid "A list of dictionaries of all projected entities: tag -> field -> value"
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.dict:32
msgid "results in the following output::"
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.distinct:1
msgid "Asks for distinct rows, which is the same as asking the backend to remove duplicates. Does not execute the query!"
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.distinct:5
msgid "If you want a distinct query::"
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.first:1
msgid "Return the first result of the query."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.first:3
msgid "Calling ``first`` results in an execution of the underlying query."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.first:5
msgid "Note, this may change if several rows are valid for the query, as persistent ordering is not guaranteed unless explicitly specified."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.first:8
msgid "if True, return just the projected quantity if there is just a single projection."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.first:9
msgid "One row of results as a list, or None if no result returned."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.from_dict:1
msgid "Create an instance from a dictionary representation of the query."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.get_used_tags:1
msgid "Returns a list of all the vertices that are being used."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.get_used_tags:3
msgid "If True, adds the tags of vertices to the returned list"
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.get_used_tags:4
msgid "If True, adds the tags of edges to the returnend list."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.get_used_tags:6
msgid "A list of tags"
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.inputs:1
msgid "Join to inputs of previous vertice in path."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.iterall:1
msgid "Same as :meth:`.all`, but returns a generator. Be aware that this is only safe if no commit will take place during this transaction. You might also want to read the SQLAlchemy documentation on https://docs.sqlalchemy.org/en/14/orm/query.html#sqlalchemy.orm.Query.yield_per"
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.iterall:6
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.iterdict:6
msgid "The size of the batches to ask the backend to batch results in subcollections. You can optimize the speed of the query by tuning this parameter."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.iterall:10
msgid "a generator of lists"
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.iterdict:1
msgid "Same as :meth:`.dict`, but returns a generator. Be aware that this is only safe if no commit will take place during this transaction. You might also want to read the SQLAlchemy documentation on https://docs.sqlalchemy.org/en/14/orm/query.html#sqlalchemy.orm.Query.yield_per"
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.iterdict:10
msgid "a generator of dictionaries"
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.limit:1
msgid "Set the limit (nr of rows to return)"
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.limit:3
msgid "integers of number of rows of rows to return"
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.offset:1
msgid "Set the offset. If offset is set, that many rows are skipped before returning. *offset* = 0 is the same as omitting setting the offset. If both offset and limit appear, then *offset* rows are skipped before starting to count the *limit* rows that are returned."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.offset:7
msgid "integers of nr of rows to skip"
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.one:1
msgid "Executes the query asking for exactly one results."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.one:3
msgid "Will raise an exception if this is not the case:"
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.one:5
msgid "MultipleObjectsError if more then one row can be returned"
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.one:6
msgid "NotExistent if no result was found"
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.order_by:1
msgid "Set the entity to order by"
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.order_by:3
msgid "This is a list of items, where each item is a dictionary specifies what to sort for an entity"
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.order_by:7
msgid "In each dictionary in that list, keys represent valid tags of entities (tables), and values are list of columns."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.outputs:1
msgid "Join to outputs of previous vertice in path."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.parents:1
msgid "Join to parents/ancestors of previous vertice in path."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.queryhelp:1
msgid "\"Legacy name for ``as_dict`` method."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.set_debug:1
msgid "Run in debug mode. This does not affect functionality, but prints intermediate stages when creating a query on screen."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder.QueryBuilder.set_debug:4
msgid "Turn debug on or off"
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder._QueryTagMap:1
msgid "Cache of tag mappings for a query."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder._QueryTagMap.add:1
msgid "Add a tag."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder._QueryTagMap.get:1
msgid "Return the tag or, given a class(es), map to a tag."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder._QueryTagMap.get:3
msgid "if the tag is not found, or the class(es) does not map to a single tag"
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder._QueryTagMap.remove:1
msgid "Remove a tag."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder._get_group_type_filter:1
msgid "Return filter dictionaries for `Group.type_string` given a set of classifiers."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder._get_group_type_filter:3
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder._get_node_type_filter:3
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder._get_process_type_filter:3
msgid "a dictionary with classifiers (note: does *not* support lists)"
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder._get_group_type_filter:6
msgid "dictionary in QueryBuilder filter language to pass into {'type_string': ... }"
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder._get_node_type_filter:1
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder._get_process_type_filter:1
msgid "Return filter dictionaries given a set of classifiers."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder._get_node_type_filter:6
msgid "dictionary in QueryBuilder filter language to pass into {\"type\": ... }"
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder._get_ormclass:1
msgid "Get ORM classifiers from either class(es) or ormclass_type_string(s)."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder._get_ormclass:3
msgid "a class or tuple/set/list of classes that are either AiiDA ORM classes or backend ORM classes."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder._get_ormclass:4
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder._get_ormclass_from_str:3
msgid "type string for ORM class"
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder._get_ormclass:6
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder._get_ormclass_from_cls:5
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder._get_ormclass_from_str:5
msgid "the ORM class as well as a dictionary with additional classifier strings"
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder._get_ormclass:8
msgid "Handles the case of lists as well."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder._get_ormclass_from_cls:1
msgid "Return the correct classifiers for the QueryBuilder from an ORM class."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder._get_ormclass_from_cls:3
msgid "an AiiDA ORM class or backend ORM class."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder._get_ormclass_from_cls:4
#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder._get_ormclass_from_str:4
msgid "an instance of the appropriate QueryBuilder backend."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder._get_ormclass_from_cls:7
msgid "Note: the ormclass_type_string is currently hardcoded for group, computer etc. One could instead use something like"
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder._get_ormclass_from_cls:8
msgid "aiida.orm.utils.node.get_type_string_from_class(cls.__module__, cls.__name__)"
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder._get_ormclass_from_str:1
msgid "Return the correct classifiers for the QueryBuilder from an ORM type string."
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder._get_process_type_filter:4
msgid "if True, allow for subclasses of the process type This is activated only, if an entry point can be found for the process type (as well as for a selection of built-in process types)"
msgstr ""

#: ../../../src/aiida/orm/querybuilder.py:docstring of aiida.orm.querybuilder._get_process_type_filter:9
msgid "dictionary in QueryBuilder filter language to pass into {\"process_type\": ... }"
msgstr ""

#: ../../../src/aiida/orm/users.py:docstring of aiida.orm.users:1
msgid "Module for the ORM user class."
msgstr ""

#: ../../../src/aiida/orm/users.py:docstring of aiida.orm.users.User:1
msgid "Bases: :py:class:`~aiida.orm.entities.Entity`\\ [:py:class:`BackendUser`, :py:class:`~aiida.orm.users.UserCollection`]"
msgstr ""

#: ../../../src/aiida/orm/users.py:docstring of aiida.orm.users.User:1
msgid "AiiDA User"
msgstr ""

#: ../../../src/aiida/orm/users.py:docstring of aiida.orm.users.User.__init__:1
msgid "Create a new `User`."
msgstr ""

#: ../../../src/aiida/orm/users.py:docstring of aiida.orm.users.User.get_full_name:1
msgid "Return the user full name"
msgstr ""

#: ../../../src/aiida/orm/users.py:docstring of aiida.orm.users.User.get_full_name:3
msgid "the user full name"
msgstr ""

#: ../../../src/aiida/orm/users.py:docstring of aiida.orm.users.User.get_short_name:1
msgid "Return the user short name (typically, this returns the email)"
msgstr ""

#: ../../../src/aiida/orm/users.py:docstring of aiida.orm.users.User.get_short_name:3
msgid "The short name"
msgstr ""

#: ../../../src/aiida/orm/users.py:docstring of aiida.orm.users.User.is_default:1
msgid "Return whether the user is the default user."
msgstr ""

#: ../../../src/aiida/orm/users.py:docstring of aiida.orm.users.User.is_default:3
msgid "Boolean, ``True`` if the user is the default, ``False`` otherwise."
msgstr ""

#: ../../../src/aiida/orm/users.py:docstring of aiida.orm.users.User.normalize_email:1
msgid "Normalize the address by lowercasing the domain part of the email address (taken from Django)."
msgstr ""

#: ../../../src/aiida/orm/users.py:docstring of aiida.orm.users.User.uuid:1
msgid "For now users do not have UUIDs so always return None"
msgstr ""

#: ../../../src/aiida/orm/users.py:docstring of aiida.orm.users.UserCollection:1
msgid "Bases: :py:class:`~aiida.orm.entities.Collection`\\ [:py:class:`User`]"
msgstr ""

#: ../../../src/aiida/orm/users.py:docstring of aiida.orm.users.UserCollection:1
msgid "The collection of users stored in a backend."
msgstr ""

#: ../../../src/aiida/orm/users.py:docstring of aiida.orm.users.UserCollection.get_default:1
msgid "Get the current default user"
msgstr ""

#: ../../../src/aiida/orm/users.py:docstring of aiida.orm.users.UserCollection.get_or_create:1
msgid "Get the existing user with a given email address or create an unstored one"
msgstr ""

#: ../../../src/aiida/orm/users.py:docstring of aiida.orm.users.UserCollection.get_or_create:3
msgid "The properties of the user to get or create"
msgstr ""

#: ../../../src/aiida/orm/users.py:docstring of aiida.orm.users.UserCollection.get_or_create:4
msgid "The corresponding user object"
msgstr ""

#: ../../../src/aiida/orm/users.py:docstring of aiida.orm.users.UserCollection.get_or_create:5
msgid ":class:`aiida.common.exceptions.MultipleObjectsError`, :class:`aiida.common.exceptions.NotExistent`"
msgstr ""

#: ../../source/reference/apidoc/aiida.orm.implementation.rst:2
msgid "aiida.orm.implementation package"
msgstr ""

#: ../../../src/aiida/orm/implementation/__init__.py:docstring of aiida.orm.implementation:1
msgid "Module containing the backend entity abstracts for storage backends."
msgstr ""

#: ../../../src/aiida/orm/implementation/authinfos.py:docstring of aiida.orm.implementation.authinfos:1
msgid "Module for the backend implementation of the `AuthInfo` ORM class."
msgstr ""

#: ../../../src/aiida/orm/implementation/authinfos.py:docstring of aiida.orm.implementation.authinfos.BackendAuthInfo:1
#: ../../../src/aiida/orm/implementation/comments.py:docstring of aiida.orm.implementation.comments.BackendComment:1
#: ../../../src/aiida/orm/implementation/computers.py:docstring of aiida.orm.implementation.computers.BackendComputer:1
#: ../../../src/aiida/orm/implementation/logs.py:docstring of aiida.orm.implementation.logs.BackendLog:1
#: ../../../src/aiida/orm/implementation/users.py:docstring of aiida.orm.implementation.users.BackendUser:1
msgid "Bases: :py:class:`~aiida.orm.implementation.entities.BackendEntity`"
msgstr ""

#: ../../../src/aiida/orm/implementation/authinfos.py:docstring of aiida.orm.implementation.authinfos.BackendAuthInfo:1
msgid "Backend implementation for the `AuthInfo` ORM class."
msgstr ""

#: ../../../src/aiida/orm/implementation/authinfos.py:docstring of aiida.orm.implementation.authinfos.BackendAuthInfo:3
msgid "An authinfo is a set of credentials that can be used to authenticate to a remote computer."
msgstr ""

#: ../../../src/aiida/orm/implementation/authinfos.py:docstring of aiida.orm.implementation.authinfos.BackendAuthInfo.enabled:3
#: ../../../src/aiida/storage/psql_dos/orm/authinfos.py:docstring of aiida.storage.psql_dos.orm.authinfos.SqlaAuthInfo.enabled:3
msgid "boolean, True if enabled, False otherwise"
msgstr ""

#: ../../../src/aiida/orm/implementation/authinfos.py:docstring of aiida.orm.implementation.authinfos.BackendAuthInfoCollection:1
msgid "Bases: :py:class:`~aiida.orm.implementation.entities.BackendCollection`\\ [:py:class:`~aiida.orm.implementation.authinfos.BackendAuthInfo`]"
msgstr ""

#: ../../../src/aiida/orm/implementation/authinfos.py:docstring of aiida.orm.implementation.authinfos.BackendAuthInfoCollection:1
msgid "The collection of backend `AuthInfo` entries."
msgstr ""

#: ../../../src/aiida/orm/implementation/comments.py:docstring of aiida.orm.implementation.comments:1
msgid "Module for comment backend classes."
msgstr ""

#: ../../../src/aiida/orm/implementation/comments.py:docstring of aiida.orm.implementation.comments.BackendComment:1
msgid "Backend implementation for the `Comment` ORM class."
msgstr ""

#: ../../../src/aiida/orm/implementation/comments.py:docstring of aiida.orm.implementation.comments.BackendComment:3
msgid "A comment is a text that can be attached to a node."
msgstr ""

#: ../../../src/aiida/orm/implementation/comments.py:docstring of aiida.orm.implementation.comments.BackendComment.content:1
#: ../../../src/aiida/storage/psql_dos/orm/comments.py:docstring of aiida.storage.psql_dos.orm.comments.SqlaComment.content:1
msgid "Return the comment content."
msgstr ""

#: ../../../src/aiida/orm/implementation/comments.py:docstring of aiida.orm.implementation.comments.BackendComment.ctime:1
#: ../../../src/aiida/storage/psql_dos/orm/comments.py:docstring of aiida.storage.psql_dos.orm.comments.SqlaComment.ctime:1
msgid "Return the creation time of the comment."
msgstr ""

#: ../../../src/aiida/orm/implementation/comments.py:docstring of aiida.orm.implementation.comments.BackendComment.mtime:1
#: ../../../src/aiida/storage/psql_dos/orm/comments.py:docstring of aiida.storage.psql_dos.orm.comments.SqlaComment.mtime:1
msgid "Return the modified time of the comment."
msgstr ""

#: ../../../src/aiida/orm/implementation/comments.py:docstring of aiida.orm.implementation.comments.BackendComment.node:1
#: ../../../src/aiida/storage/psql_dos/orm/comments.py:docstring of aiida.storage.psql_dos.orm.comments.SqlaComment.node:1
msgid "Return the comment's node."
msgstr ""

#: ../../../src/aiida/orm/implementation/comments.py:docstring of aiida.orm.implementation.comments.BackendComment.set_content:1
#: ../../../src/aiida/storage/psql_dos/orm/comments.py:docstring of aiida.storage.psql_dos.orm.comments.SqlaComment.set_content:1
msgid "Set the comment content."
msgstr ""

#: ../../../src/aiida/orm/implementation/comments.py:docstring of aiida.orm.implementation.comments.BackendComment.set_mtime:1
#: ../../../src/aiida/storage/psql_dos/orm/comments.py:docstring of aiida.storage.psql_dos.orm.comments.SqlaComment.set_mtime:1
msgid "Set the modified time of the comment."
msgstr ""

#: ../../../src/aiida/orm/implementation/comments.py:docstring of aiida.orm.implementation.comments.BackendComment.set_user:1
#: ../../../src/aiida/storage/psql_dos/orm/comments.py:docstring of aiida.storage.psql_dos.orm.comments.SqlaComment.set_user:1
msgid "Set the comment owner."
msgstr ""

#: ../../../src/aiida/orm/implementation/comments.py:docstring of aiida.orm.implementation.comments.BackendComment.user:1
#: ../../../src/aiida/storage/psql_dos/orm/comments.py:docstring of aiida.storage.psql_dos.orm.comments.SqlaComment.user:1
msgid "Return the comment owner."
msgstr ""

#: ../../../src/aiida/orm/implementation/comments.py:docstring of aiida.orm.implementation.comments.BackendComment.uuid:1
#: ../../../src/aiida/storage/psql_dos/orm/comments.py:docstring of aiida.storage.psql_dos.orm.comments.SqlaComment.uuid:1
msgid "Return the UUID of the comment."
msgstr ""

#: ../../../src/aiida/orm/implementation/comments.py:docstring of aiida.orm.implementation.comments.BackendCommentCollection:1
msgid "Bases: :py:class:`~aiida.orm.implementation.entities.BackendCollection`\\ [:py:class:`~aiida.orm.implementation.comments.BackendComment`]"
msgstr ""

#: ../../../src/aiida/orm/implementation/comments.py:docstring of aiida.orm.implementation.comments.BackendCommentCollection.delete_all:1
#: ../../../src/aiida/storage/psql_dos/orm/comments.py:docstring of aiida.storage.psql_dos.orm.comments.SqlaCommentCollection.delete_all:1
msgid "Delete all Comment entries."
msgstr ""

#: ../../../src/aiida/orm/implementation/comments.py:docstring of aiida.orm.implementation.comments.BackendCommentCollection.delete_many:1
#: ../../../src/aiida/storage/psql_dos/orm/comments.py:docstring of aiida.storage.psql_dos.orm.comments.SqlaCommentCollection.delete_many:1
msgid "Delete Comments based on ``filters``"
msgstr ""

#: ../../../src/aiida/orm/implementation/computers.py:docstring of aiida.orm.implementation.computers:1
msgid "Backend specific computer objects and methods"
msgstr ""

#: ../../../src/aiida/orm/implementation/computers.py:docstring of aiida.orm.implementation.computers.BackendComputer:1
msgid "Backend implementation for the `Computer` ORM class."
msgstr ""

#: ../../../src/aiida/orm/implementation/computers.py:docstring of aiida.orm.implementation.computers.BackendComputer:3
msgid "A computer is a resource that can be used to run calculations: It has an associated transport_type, which points to a plugin for connecting to the resource and passing data, and a scheduler_type, which points to a plugin for scheduling calculations."
msgstr ""

#: ../../../src/aiida/orm/implementation/computers.py:docstring of aiida.orm.implementation.computers.BackendComputer.copy:1
msgid "Create an un-stored clone of an already stored `Computer`."
msgstr ""

#: ../../../src/aiida/orm/implementation/computers.py:docstring of aiida.orm.implementation.computers.BackendComputer.copy:3
msgid "``InvalidOperation`` if the computer is not stored."
msgstr ""

#: ../../../src/aiida/orm/implementation/computers.py:docstring of aiida.orm.implementation.computers.BackendComputer.description:1
#: ../../../src/aiida/storage/psql_dos/orm/computers.py:docstring of aiida.storage.psql_dos.orm.computers.SqlaComputer.description:1
msgid "Return the description of the computer."
msgstr ""

#: ../../../src/aiida/orm/implementation/computers.py:docstring of aiida.orm.implementation.computers.BackendComputer.get_metadata:1
#: ../../../src/aiida/storage/psql_dos/orm/computers.py:docstring of aiida.storage.psql_dos.orm.computers.SqlaComputer.get_metadata:1
msgid "Return the metadata for the computer."
msgstr ""

#: ../../../src/aiida/orm/implementation/computers.py:docstring of aiida.orm.implementation.computers.BackendComputer.get_scheduler_type:1
#: ../../../src/aiida/storage/psql_dos/orm/computers.py:docstring of aiida.storage.psql_dos.orm.computers.SqlaComputer.get_scheduler_type:1
msgid "Return the scheduler plugin type."
msgstr ""

#: ../../../src/aiida/orm/implementation/computers.py:docstring of aiida.orm.implementation.computers.BackendComputer.get_transport_type:1
#: ../../../src/aiida/storage/psql_dos/orm/computers.py:docstring of aiida.storage.psql_dos.orm.computers.SqlaComputer.get_transport_type:1
msgid "Return the transport plugin type."
msgstr ""

#: ../../../src/aiida/orm/implementation/computers.py:docstring of aiida.orm.implementation.computers.BackendComputer.hostname:1
#: ../../../src/aiida/storage/psql_dos/orm/computers.py:docstring of aiida.storage.psql_dos.orm.computers.SqlaComputer.hostname:1
msgid "Return the hostname of the computer (used to associate the connected device)."
msgstr ""

#: ../../../src/aiida/orm/implementation/computers.py:docstring of aiida.orm.implementation.computers.BackendComputer.label:1
#: ../../../src/aiida/storage/psql_dos/orm/computers.py:docstring of aiida.storage.psql_dos.orm.computers.SqlaComputer.label:1
msgid "Return the (unique) label of the computer."
msgstr ""

#: ../../../src/aiida/orm/implementation/computers.py:docstring of aiida.orm.implementation.computers.BackendComputer.set_description:1
#: ../../../src/aiida/storage/psql_dos/orm/computers.py:docstring of aiida.storage.psql_dos.orm.computers.SqlaComputer.set_description:1
msgid "Set the description of the computer."
msgstr ""

#: ../../../src/aiida/orm/implementation/computers.py:docstring of aiida.orm.implementation.computers.BackendComputer.set_hostname:1
#: ../../../src/aiida/storage/psql_dos/orm/computers.py:docstring of aiida.storage.psql_dos.orm.computers.SqlaComputer.set_hostname:1
msgid "Set the hostname of this computer :param val: The new hostname"
msgstr ""

#: ../../../src/aiida/orm/implementation/computers.py:docstring of aiida.orm.implementation.computers.BackendComputer.set_label:1
#: ../../../src/aiida/storage/psql_dos/orm/computers.py:docstring of aiida.storage.psql_dos.orm.computers.SqlaComputer.set_label:1
msgid "Set the (unique) label of the computer."
msgstr ""

#: ../../../src/aiida/orm/implementation/computers.py:docstring of aiida.orm.implementation.computers.BackendComputer.set_metadata:1
#: ../../../src/aiida/storage/psql_dos/orm/computers.py:docstring of aiida.storage.psql_dos.orm.computers.SqlaComputer.set_metadata:1
msgid "Set the metadata for the computer."
msgstr ""

#: ../../../src/aiida/orm/implementation/computers.py:docstring of aiida.orm.implementation.computers.BackendComputer.set_scheduler_type:1
#: ../../../src/aiida/storage/psql_dos/orm/computers.py:docstring of aiida.storage.psql_dos.orm.computers.SqlaComputer.set_scheduler_type:1
msgid "Set the scheduler plugin type."
msgstr ""

#: ../../../src/aiida/orm/implementation/computers.py:docstring of aiida.orm.implementation.computers.BackendComputer.set_transport_type:1
#: ../../../src/aiida/storage/psql_dos/orm/computers.py:docstring of aiida.storage.psql_dos.orm.computers.SqlaComputer.set_transport_type:1
msgid "Set the transport plugin type."
msgstr ""

#: ../../../src/aiida/orm/implementation/computers.py:docstring of aiida.orm.implementation.computers.BackendComputer.uuid:1
#: ../../../src/aiida/storage/psql_dos/orm/computers.py:docstring of aiida.storage.psql_dos.orm.computers.SqlaComputer.uuid:1
msgid "Return the UUID of the computer."
msgstr ""

#: ../../../src/aiida/orm/implementation/computers.py:docstring of aiida.orm.implementation.computers.BackendComputerCollection:1
msgid "Bases: :py:class:`~aiida.orm.implementation.entities.BackendCollection`\\ [:py:class:`~aiida.orm.implementation.computers.BackendComputer`]"
msgstr ""

#: ../../../src/aiida/orm/implementation/computers.py:docstring of aiida.orm.implementation.computers.BackendComputerCollection.delete:1
#: ../../../src/aiida/storage/psql_dos/orm/computers.py:docstring of aiida.storage.psql_dos.orm.computers.SqlaComputerCollection.delete:1
msgid "Delete an entry with the given pk"
msgstr ""

#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities:1
msgid "Classes and methods for backend non-specific entities"
msgstr ""

#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendCollection:1
msgid "Bases: :py:class:`~typing.Generic`\\ [:py:obj:`~aiida.orm.implementation.entities.EntityType`]"
msgstr ""

#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendCollection:1
msgid "Container class that represents a collection of entries of a particular backend entity."
msgstr ""

#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendCollection.__init__:1
msgid "the backend this collection belongs to"
msgstr ""

#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendCollection.create:1
msgid "Create new a entry and set the attributes to those specified in the keyword arguments"
msgstr ""

#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendCollection.create:3
msgid "the newly created entry of type ENTITY_CLASS"
msgstr ""

#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendEntity:1
msgid "An first-class entity in the backend"
msgstr ""

#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendEntity.backend:1
msgid "Return the backend this entity belongs to"
msgstr ""

#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendEntity.backend:3
msgid "the backend instance"
msgstr ""

#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendEntity.id:3
#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendEntity.pk:3
#: ../../../src/aiida/storage/psql_dos/orm/computers.py:docstring of aiida.storage.psql_dos.orm.computers.SqlaComputer.pk:3
#: ../../../src/aiida/storage/psql_dos/orm/groups.py:docstring of aiida.storage.psql_dos.orm.groups.SqlaGroup.pk:3
msgid "This is unique only amongst entities of this type for a particular backend."
msgstr ""

#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendEntity.id:5
#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendEntity.pk:5
#: ../../../src/aiida/storage/psql_dos/orm/authinfos.py:docstring of aiida.storage.psql_dos.orm.authinfos.SqlaAuthInfo.id:3
#: ../../../src/aiida/storage/psql_dos/orm/computers.py:docstring of aiida.storage.psql_dos.orm.computers.SqlaComputer.id:3
#: ../../../src/aiida/storage/psql_dos/orm/computers.py:docstring of aiida.storage.psql_dos.orm.computers.SqlaComputer.pk:5
#: ../../../src/aiida/storage/psql_dos/orm/entities.py:docstring of aiida.storage.psql_dos.orm.entities.SqlaModelEntity.id:3
#: ../../../src/aiida/storage/psql_dos/orm/groups.py:docstring of aiida.storage.psql_dos.orm.groups.SqlaGroup.pk:5
msgid "the entity id"
msgstr ""

#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendEntity.is_stored:3
#: ../../../src/aiida/storage/psql_dos/orm/authinfos.py:docstring of aiida.storage.psql_dos.orm.authinfos.SqlaAuthInfo.is_stored:3
#: ../../../src/aiida/storage/psql_dos/orm/computers.py:docstring of aiida.storage.psql_dos.orm.computers.SqlaComputer.is_stored:3
#: ../../../src/aiida/storage/psql_dos/orm/entities.py:docstring of aiida.storage.psql_dos.orm.entities.SqlaModelEntity.is_stored:3
#: ../../../src/aiida/storage/psql_dos/orm/groups.py:docstring of aiida.storage.psql_dos.orm.groups.SqlaGroup.is_stored:3
msgid "True if stored, False otherwise"
msgstr ""

#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendEntity.store:1
msgid "Store this entity in the backend."
msgstr ""

#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendEntity.store:3
msgid "Whether it is possible to call store more than once is delegated to the object itself"
msgstr ""

#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendEntityExtrasMixin:1
msgid "Mixin class that adds all abstract methods for the extras column to a backend entity"
msgstr ""

#: ../../../src/aiida/orm/implementation/entities.py:docstring of aiida.orm.implementation.entities.BackendEntityExtrasMixin.extras_items:1
msgid "Return an iterator over the extras key/value pairs."
msgstr ""

#: ../../../src/aiida/orm/implementation/groups.py:docstring of aiida.orm.implementation.groups:1
#: ../../../src/aiida/orm/implementation/logs.py:docstring of aiida.orm.implementation.logs:1
msgid "Backend group module"
msgstr ""

#: ../../../src/aiida/orm/implementation/groups.py:docstring of aiida.orm.implementation.groups.BackendGroup:1
#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode:1
msgid "Bases: :py:class:`~aiida.orm.implementation.entities.BackendEntity`, :py:class:`~aiida.orm.implementation.entities.BackendEntityExtrasMixin`"
msgstr ""

#: ../../../src/aiida/orm/implementation/groups.py:docstring of aiida.orm.implementation.groups.BackendGroup:1
msgid "Backend implementation for the `Group` ORM class."
msgstr ""

#: ../../../src/aiida/orm/implementation/groups.py:docstring of aiida.orm.implementation.groups.BackendGroup:3
msgid "A group is a collection of nodes."
msgstr ""

#: ../../../src/aiida/orm/implementation/groups.py:docstring of aiida.orm.implementation.groups.BackendGroup.add_nodes:1
msgid "Add a set of nodes to the group."
msgstr ""

#: ../../../src/aiida/orm/implementation/groups.py:docstring of aiida.orm.implementation.groups.BackendGroup.add_nodes:5
msgid "a list of `BackendNode` instances to be added to this group"
msgstr ""

#: ../../../src/aiida/orm/implementation/groups.py:docstring of aiida.orm.implementation.groups.BackendGroup.description:1
#: ../../../src/aiida/storage/psql_dos/orm/groups.py:docstring of aiida.storage.psql_dos.orm.groups.SqlaGroup.description:1
msgid "Return the description of the group as a string."
msgstr ""

#: ../../../src/aiida/orm/implementation/groups.py:docstring of aiida.orm.implementation.groups.BackendGroup.label:1
#: ../../../src/aiida/storage/psql_dos/orm/groups.py:docstring of aiida.storage.psql_dos.orm.groups.SqlaGroup.label:1
msgid "Return the name of the group as a string."
msgstr ""

#: ../../../src/aiida/orm/implementation/groups.py:docstring of aiida.orm.implementation.groups.BackendGroup.remove_nodes:1
msgid "Remove a set of nodes from the group."
msgstr ""

#: ../../../src/aiida/orm/implementation/groups.py:docstring of aiida.orm.implementation.groups.BackendGroup.remove_nodes:5
msgid "a list of `BackendNode` instances to be removed from this group"
msgstr ""

#: ../../../src/aiida/orm/implementation/groups.py:docstring of aiida.orm.implementation.groups.BackendGroup.type_string:1
#: ../../../src/aiida/storage/psql_dos/orm/groups.py:docstring of aiida.storage.psql_dos.orm.groups.SqlaGroup.type_string:1
msgid "Return the string defining the type of the group."
msgstr ""

#: ../../../src/aiida/orm/implementation/groups.py:docstring of aiida.orm.implementation.groups.BackendGroup.user:1
#: ../../../src/aiida/storage/psql_dos/orm/groups.py:docstring of aiida.storage.psql_dos.orm.groups.SqlaGroup.user:1
msgid "Return a backend user object, representing the user associated to this group."
msgstr ""

#: ../../../src/aiida/orm/implementation/groups.py:docstring of aiida.orm.implementation.groups.BackendGroup.uuid:1
#: ../../../src/aiida/storage/psql_dos/orm/groups.py:docstring of aiida.storage.psql_dos.orm.groups.SqlaGroup.uuid:1
msgid "Return the UUID of the group."
msgstr ""

#: ../../../src/aiida/orm/implementation/groups.py:docstring of aiida.orm.implementation.groups.BackendGroupCollection:1
msgid "Bases: :py:class:`~aiida.orm.implementation.entities.BackendCollection`\\ [:py:class:`~aiida.orm.implementation.groups.BackendGroup`]"
msgstr ""

#: ../../../src/aiida/orm/implementation/groups.py:docstring of aiida.orm.implementation.groups.BackendGroupCollection:1
msgid "The collection of Group entries."
msgstr ""

#: ../../../src/aiida/orm/implementation/groups.py:docstring of aiida.orm.implementation.groups.BackendGroupCollection.delete:1
#: ../../../src/aiida/storage/psql_dos/orm/groups.py:docstring of aiida.storage.psql_dos.orm.groups.SqlaGroupCollection.delete:1
msgid "Delete a group with the given id"
msgstr ""

#: ../../../src/aiida/orm/implementation/groups.py:docstring of aiida.orm.implementation.groups.NodeIterator:1
msgid "Protocol for iterating over nodes in a group"
msgstr ""

#: ../../../src/aiida/orm/implementation/groups.py:docstring of aiida.orm.implementation.groups.NodeIterator.__getitem__:1
msgid "Index node(s) from the group."
msgstr ""

#: ../../../src/aiida/orm/implementation/groups.py:docstring of aiida.orm.implementation.groups.NodeIterator.__iter__:1
msgid "Return an iterator over the nodes in the group."
msgstr ""

#: ../../../src/aiida/orm/implementation/groups.py:docstring of aiida.orm.implementation.groups.NodeIterator.__len__:1
msgid "Return the number of nodes in the group."
msgstr ""

#: ../../../src/aiida/orm/implementation/groups.py:docstring of aiida.orm.implementation.groups.NodeIterator.__next__:1
msgid "Return the next node in the group."
msgstr ""

#: ../../../src/aiida/orm/implementation/logs.py:docstring of aiida.orm.implementation.logs.BackendLog:1
msgid "Backend implementation for the `Log` ORM class."
msgstr ""

#: ../../../src/aiida/orm/implementation/logs.py:docstring of aiida.orm.implementation.logs.BackendLog:3
msgid "A log is a record of logging call for a particular node."
msgstr ""

#: ../../../src/aiida/orm/implementation/logs.py:docstring of aiida.orm.implementation.logs.BackendLog.dbnode_id:1
msgid "Return the id of the object that created the log entry."
msgstr ""

#: ../../../src/aiida/orm/implementation/logs.py:docstring of aiida.orm.implementation.logs.BackendLog.levelname:1
msgid "Return the name of the log level."
msgstr ""

#: ../../../src/aiida/orm/implementation/logs.py:docstring of aiida.orm.implementation.logs.BackendLog.loggername:1
msgid "Return the name of the logger that created this entry."
msgstr ""

#: ../../../src/aiida/orm/implementation/logs.py:docstring of aiida.orm.implementation.logs.BackendLog.message:1
msgid "Return the message corresponding to the log entry."
msgstr ""

#: ../../../src/aiida/orm/implementation/logs.py:docstring of aiida.orm.implementation.logs.BackendLog.metadata:1
msgid "Return the metadata corresponding to the log entry."
msgstr ""

#: ../../../src/aiida/orm/implementation/logs.py:docstring of aiida.orm.implementation.logs.BackendLog.time:1
msgid "Return the time corresponding to the log entry."
msgstr ""

#: ../../../src/aiida/orm/implementation/logs.py:docstring of aiida.orm.implementation.logs.BackendLog.uuid:1
msgid "Return the UUID of the log entry."
msgstr ""

#: ../../../src/aiida/orm/implementation/logs.py:docstring of aiida.orm.implementation.logs.BackendLogCollection:1
msgid "Bases: :py:class:`~aiida.orm.implementation.entities.BackendCollection`\\ [:py:class:`~aiida.orm.implementation.logs.BackendLog`]"
msgstr ""

#: ../../../src/aiida/orm/implementation/logs.py:docstring of aiida.orm.implementation.logs.BackendLogCollection:1
msgid "The collection of Log entries."
msgstr ""

#: ../../../src/aiida/orm/implementation/logs.py:docstring of aiida.orm.implementation.logs.BackendLogCollection.delete:5
#: ../../../src/aiida/storage/psql_dos/orm/logs.py:docstring of aiida.storage.psql_dos.orm.logs.SqlaLogCollection.delete:6
msgid "if ``log_id`` is not an `int`"
msgstr ""

#: ../../../src/aiida/orm/implementation/logs.py:docstring of aiida.orm.implementation.logs.BackendLogCollection.delete:6
#: ../../../src/aiida/storage/psql_dos/orm/logs.py:docstring of aiida.storage.psql_dos.orm.logs.SqlaLogCollection.delete:7
msgid "if Log with ID ``log_id`` is not found"
msgstr ""

#: ../../../src/aiida/orm/implementation/logs.py:docstring of aiida.orm.implementation.logs.BackendLogCollection.delete_all:1
#: ../../../src/aiida/storage/psql_dos/orm/logs.py:docstring of aiida.storage.psql_dos.orm.logs.SqlaLogCollection.delete_all:1
msgid "Delete all Log entries."
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes:1
msgid "Abstract BackendNode and BackendNodeCollection implementation."
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode:1
msgid "Backend implementation for the `Node` ORM class."
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode:3
msgid "A node stores data input or output from a computation."
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.add_incoming:1
#: ../../../src/aiida/orm/nodes/links.py:docstring of aiida.orm.nodes.links.NodeLinks.add_incoming:1
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.add_incoming:1
msgid "Add a link of the given type from a given node to ourself."
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.add_incoming:3
#: ../../../src/aiida/orm/nodes/links.py:docstring of aiida.orm.nodes.links.NodeLinks._add_incoming_cache:6
#: ../../../src/aiida/orm/nodes/links.py:docstring of aiida.orm.nodes.links.NodeLinks.add_incoming:3
#: ../../../src/aiida/orm/nodes/links.py:docstring of aiida.orm.nodes.links.NodeLinks.validate_incoming:9
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNodeLinks.validate_incoming:7
#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links.validate_link:54
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.add_incoming:3
msgid "the node from which the link is coming"
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.add_incoming:4
#: ../../../src/aiida/orm/nodes/links.py:docstring of aiida.orm.nodes.links.NodeLinks._add_incoming_cache:7
#: ../../../src/aiida/orm/nodes/links.py:docstring of aiida.orm.nodes.links.NodeLinks.add_incoming:4
#: ../../../src/aiida/orm/nodes/links.py:docstring of aiida.orm.nodes.links.NodeLinks.validate_incoming:10
#: ../../../src/aiida/orm/nodes/links.py:docstring of aiida.orm.nodes.links.NodeLinks.validate_outgoing:8
#: ../../../src/aiida/orm/nodes/process/calculation/calcfunction.py:docstring of aiida.orm.nodes.process.calculation.calcfunction.CalcFunctionNodeLinks.validate_outgoing:8
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNodeLinks.validate_incoming:8
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNodeLinks.validate_outgoing:6
#: ../../../src/aiida/orm/nodes/process/workflow/workflow.py:docstring of aiida.orm.nodes.process.workflow.workflow.WorkflowNodeLinks.validate_outgoing:8
#: ../../../src/aiida/orm/nodes/process/workflow/workfunction.py:docstring of aiida.orm.nodes.process.workflow.workfunction.WorkFunctionNodeLinks.validate_outgoing:8
#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links.link_triple_exists:5
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.add_incoming:4
msgid "the link type"
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.add_incoming:5
#: ../../../src/aiida/orm/nodes/links.py:docstring of aiida.orm.nodes.links.NodeLinks._add_incoming_cache:8
#: ../../../src/aiida/orm/nodes/links.py:docstring of aiida.orm.nodes.links.NodeLinks.add_incoming:5
#: ../../../src/aiida/orm/nodes/links.py:docstring of aiida.orm.nodes.links.NodeLinks.validate_incoming:11
#: ../../../src/aiida/orm/nodes/links.py:docstring of aiida.orm.nodes.links.NodeLinks.validate_outgoing:9
#: ../../../src/aiida/orm/nodes/process/calculation/calcfunction.py:docstring of aiida.orm.nodes.process.calculation.calcfunction.CalcFunctionNodeLinks.validate_outgoing:9
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNodeLinks.validate_incoming:9
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNodeLinks.validate_outgoing:7
#: ../../../src/aiida/orm/nodes/process/workflow/workflow.py:docstring of aiida.orm.nodes.process.workflow.workflow.WorkflowNodeLinks.validate_outgoing:9
#: ../../../src/aiida/orm/nodes/process/workflow/workfunction.py:docstring of aiida.orm.nodes.process.workflow.workfunction.WorkFunctionNodeLinks.validate_outgoing:9
#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links.link_triple_exists:6
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.add_incoming:5
msgid "the link label"
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.add_incoming:6
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.add_incoming:6
msgid "True if the proposed link is allowed, False otherwise"
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.add_incoming:7
#: ../../../src/aiida/orm/nodes/links.py:docstring of aiida.orm.nodes.links.NodeLinks.add_incoming:6
#: ../../../src/aiida/orm/nodes/links.py:docstring of aiida.orm.nodes.links.NodeLinks.validate_incoming:12
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNodeLinks.validate_incoming:10
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.add_incoming:7
msgid "if `source` is not a Node instance or `link_type` is not a `LinkType` enum"
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.add_incoming:8
#: ../../../src/aiida/orm/nodes/links.py:docstring of aiida.orm.nodes.links.NodeLinks.add_incoming:7
#: ../../../src/aiida/orm/nodes/links.py:docstring of aiida.orm.nodes.links.NodeLinks.validate_incoming:13
#: ../../../src/aiida/orm/nodes/links.py:docstring of aiida.orm.nodes.links.NodeLinks.validate_outgoing:11
#: ../../../src/aiida/orm/nodes/process/calculation/calcfunction.py:docstring of aiida.orm.nodes.process.calculation.calcfunction.CalcFunctionNodeLinks.validate_outgoing:11
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNodeLinks.validate_incoming:11
#: ../../../src/aiida/orm/nodes/process/workflow/workflow.py:docstring of aiida.orm.nodes.process.workflow.workflow.WorkflowNodeLinks.validate_outgoing:11
#: ../../../src/aiida/orm/nodes/process/workflow/workfunction.py:docstring of aiida.orm.nodes.process.workflow.workfunction.WorkFunctionNodeLinks.validate_outgoing:11
#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links.validate_link:59
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.add_incoming:8
msgid "if the proposed link is invalid"
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.add_incoming:9
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.add_incoming:9
msgid "if either source or target node is not stored"
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.attributes:1
#: ../../../src/aiida/orm/nodes/attributes.py:docstring of aiida.orm.nodes.attributes.NodeAttributes.all:1
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.attributes:1
msgid "Return the complete attributes dictionary."
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.attributes:3
#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.get_attribute_many:3
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.attributes:3
msgid "While the entity is unstored, this will return references of the attributes on the database model, meaning that changes on the returned values (if they are mutable themselves, e.g. a list or dictionary) will automatically be reflected on the database model as well. As soon as the entity is stored, the returned attributes will be a deep copy and mutations of the database attributes will have to go through the appropriate set methods. Therefore, once stored, retrieving a deep copy can be a heavy operation. If you only need the keys or some values, use the iterators `attributes_keys` and `attributes_items`, or the getters `get_attribute` and `get_attribute_many` instead."
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.attributes:11
#: ../../../src/aiida/orm/nodes/attributes.py:docstring of aiida.orm.nodes.attributes.NodeAttributes.all:11
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.attributes:11
msgid "the attributes as a dictionary"
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.attributes_items:1
#: ../../../src/aiida/orm/nodes/attributes.py:docstring of aiida.orm.nodes.attributes.NodeAttributes.items:1
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.attributes_items:1
msgid "Return an iterator over the attributes."
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.attributes_items:3
#: ../../../src/aiida/orm/nodes/attributes.py:docstring of aiida.orm.nodes.attributes.NodeAttributes.items:3
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.attributes_items:3
msgid "an iterator with attribute key value pairs"
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.attributes_keys:1
#: ../../../src/aiida/orm/nodes/attributes.py:docstring of aiida.orm.nodes.attributes.NodeAttributes.keys:1
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.attributes_keys:1
msgid "Return an iterator over the attribute keys."
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.attributes_keys:3
#: ../../../src/aiida/orm/nodes/attributes.py:docstring of aiida.orm.nodes.attributes.NodeAttributes.keys:3
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.attributes_keys:3
msgid "an iterator with attribute keys"
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.clean_values:1
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.clean_values:1
msgid "Clean the values of the node fields."
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.clean_values:3
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.clean_values:3
msgid "This method is called before storing the node. The purpose of this method is to convert data to a type which can be serialized and deserialized for storage in the DB without its value changing."
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.clear_attributes:1
#: ../../../src/aiida/orm/nodes/attributes.py:docstring of aiida.orm.nodes.attributes.NodeAttributes.clear:1
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.clear_attributes:1
msgid "Delete all attributes."
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.clone:1
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.clone:1
msgid "Return an unstored clone of ourselves."
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.clone:3
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.clone:3
msgid "an unstored `BackendNode` with the exact same attributes and extras as self"
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.computer:1
#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node.computer:1
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.computer:1
msgid "Return the computer of this node."
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.computer:3
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.computer:3
msgid "the computer or None"
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.ctime:1
#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node.ctime:1
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.ctime:1
msgid "Return the node ctime."
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.ctime:3
#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node.ctime:3
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.ctime:3
msgid "the ctime"
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.delete_attribute:1
#: ../../../src/aiida/orm/nodes/attributes.py:docstring of aiida.orm.nodes.attributes.NodeAttributes.delete:1
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.delete_attribute:1
msgid "Delete an attribute."
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.delete_attribute:3
#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.get_attribute:9
#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.set_attribute:3
#: ../../../src/aiida/orm/nodes/attributes.py:docstring of aiida.orm.nodes.attributes.NodeAttributes.delete:3
#: ../../../src/aiida/orm/nodes/attributes.py:docstring of aiida.orm.nodes.attributes.NodeAttributes.get:9
#: ../../../src/aiida/orm/nodes/attributes.py:docstring of aiida.orm.nodes.attributes.NodeAttributes.set:3
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.delete_attribute:3
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.get_attribute:9
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.set_attribute:3
msgid "name of the attribute"
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.delete_attribute:4
#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.get_attribute:11
#: ../../../src/aiida/orm/nodes/attributes.py:docstring of aiida.orm.nodes.attributes.NodeAttributes.delete:4
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.delete_attribute:4
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.get_attribute:11
msgid "if the attribute does not exist"
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.delete_attribute_many:1
#: ../../../src/aiida/orm/nodes/attributes.py:docstring of aiida.orm.nodes.attributes.NodeAttributes.delete_many:1
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.delete_attribute_many:1
msgid "Delete multiple attributes."
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.delete_attribute_many:3
#: ../../../src/aiida/orm/nodes/attributes.py:docstring of aiida.orm.nodes.attributes.NodeAttributes.delete_many:3
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.delete_attribute_many:3
msgid "names of the attributes to delete"
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.delete_attribute_many:4
#: ../../../src/aiida/orm/nodes/attributes.py:docstring of aiida.orm.nodes.attributes.NodeAttributes.delete_many:4
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.delete_attribute_many:4
msgid "if at least one of the attribute does not exist"
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.description:1
#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node.description:1
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.description:1
msgid "Return the node description."
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.description:3
#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node.description:3
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.description:3
msgid "the description"
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.get_attribute:1
#: ../../../src/aiida/orm/nodes/attributes.py:docstring of aiida.orm.nodes.attributes.NodeAttributes.get:1
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.get_attribute:1
msgid "Return the value of an attribute."
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.get_attribute:3
#: ../../../src/aiida/orm/nodes/attributes.py:docstring of aiida.orm.nodes.attributes.NodeAttributes.get:3
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.get_attribute:3
msgid "While the entity is unstored, this will return a reference of the attribute on the database model, meaning that changes on the returned value (if they are mutable themselves, e.g. a list or dictionary) will automatically be reflected on the database model as well. As soon as the entity is stored, the returned attribute will be a deep copy and mutations of the database attributes will have to go through the appropriate set methods."
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.get_attribute:10
#: ../../../src/aiida/orm/nodes/attributes.py:docstring of aiida.orm.nodes.attributes.NodeAttributes.get:11
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.get_attribute:10
msgid "the value of the attribute"
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.get_attribute_many:1
#: ../../../src/aiida/orm/nodes/attributes.py:docstring of aiida.orm.nodes.attributes.NodeAttributes.get_many:1
msgid "Return the values of multiple attributes."
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.get_attribute_many:11
#: ../../../src/aiida/orm/nodes/attributes.py:docstring of aiida.orm.nodes.attributes.NodeAttributes.get_many:11
msgid "a list of attribute names"
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.get_attribute_many:12
#: ../../../src/aiida/orm/nodes/attributes.py:docstring of aiida.orm.nodes.attributes.NodeAttributes.get_many:12
msgid "a list of attribute values"
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.get_attribute_many:13
#: ../../../src/aiida/orm/nodes/attributes.py:docstring of aiida.orm.nodes.attributes.NodeAttributes.get_many:13
msgid "if at least one attribute does not exist"
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.label:1
#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node.label:1
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.label:1
msgid "Return the node label."
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.label:3
#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node.label:3
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.label:3
msgid "the label"
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.mtime:1
#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node.mtime:1
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.mtime:1
msgid "Return the node mtime."
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.mtime:3
#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node.mtime:3
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.mtime:3
msgid "the mtime"
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.node_type:1
#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node.node_type:1
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.node_type:1
msgid "Return the node type."
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.node_type:3
#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node.node_type:3
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.node_type:3
msgid "the node type"
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.process_type:1
#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node.process_type:1
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.process_type:1
msgid "Return the node process type."
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.process_type:3
#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node.process_type:3
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.process_type:3
msgid "the process type"
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.repository_metadata:1
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.repository_metadata:1
msgid "Return the node repository metadata."
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.repository_metadata:3
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.metadata:5
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.repository_metadata:3
#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy_to_main.py:docstring of aiida.storage.sqlite_zip.migrations.legacy_to_main._create_repo_metadata:4
msgid "the repository metadata"
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.reset_attributes:1
#: ../../../src/aiida/orm/nodes/attributes.py:docstring of aiida.orm.nodes.attributes.NodeAttributes.reset:1
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.reset_attributes:1
msgid "Reset the attributes."
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.reset_attributes:3
#: ../../../src/aiida/orm/nodes/attributes.py:docstring of aiida.orm.nodes.attributes.NodeAttributes.reset:3
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.reset_attributes:3
msgid "This will completely clear any existing attributes and replace them with the new dictionary."
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.reset_attributes:5
#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.set_attribute_many:5
#: ../../../src/aiida/orm/nodes/attributes.py:docstring of aiida.orm.nodes.attributes.NodeAttributes.reset:5
#: ../../../src/aiida/orm/nodes/attributes.py:docstring of aiida.orm.nodes.attributes.NodeAttributes.set_many:5
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.reset_attributes:5
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.set_attribute_many:5
msgid "a dictionary with the attributes to set"
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.set_attribute:1
#: ../../../src/aiida/orm/nodes/attributes.py:docstring of aiida.orm.nodes.attributes.NodeAttributes.set:1
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.set_attribute:1
msgid "Set an attribute to the given value."
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.set_attribute:4
#: ../../../src/aiida/orm/nodes/attributes.py:docstring of aiida.orm.nodes.attributes.NodeAttributes.set:4
#: ../../../src/aiida/orm/utils/calcjob.py:docstring of aiida.orm.utils.calcjob.CalcJobResultManager.__getattr__:4
#: ../../../src/aiida/orm/utils/calcjob.py:docstring of aiida.orm.utils.calcjob.CalcJobResultManager.__getitem__:4
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.set_attribute:4
msgid "value of the attribute"
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.set_attribute_many:1
#: ../../../src/aiida/orm/nodes/attributes.py:docstring of aiida.orm.nodes.attributes.NodeAttributes.set_many:1
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.set_attribute_many:1
msgid "Set multiple attributes."
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.set_attribute_many:3
#: ../../../src/aiida/orm/nodes/attributes.py:docstring of aiida.orm.nodes.attributes.NodeAttributes.set_many:3
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.set_attribute_many:3
msgid "This will override any existing attributes that are present in the new dictionary."
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.store:1
msgid "Store the node in the database."
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.store:3
msgid "optional links to add before storing"
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.store:4
#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node._store:3
msgid "boolean, if True, will clean the attributes and extras before attempting to store"
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.user:1
#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node.user:1
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.user:1
msgid "Return the user of this node."
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.user:3
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.user:3
msgid "the user"
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.uuid:1
#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node.uuid:1
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.uuid:1
msgid "Return the node UUID."
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNode.uuid:3
#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node.uuid:3
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.uuid:3
msgid "the string representation of the UUID"
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNodeCollection:1
msgid "Bases: :py:class:`~aiida.orm.implementation.entities.BackendCollection`\\ [:py:class:`~aiida.orm.implementation.nodes.BackendNode`]"
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNodeCollection:1
msgid "The collection of `BackendNode` entries."
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNodeCollection.delete:1
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNodeCollection.delete:1
msgid "Remove a Node entry from the collection with the given id"
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNodeCollection.delete:3
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNodeCollection.delete:3
msgid "id of the node to delete"
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNodeCollection.get:1
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNodeCollection.get:1
msgid "Return a Node entry from the collection with the given id"
msgstr ""

#: ../../../src/aiida/orm/implementation/nodes.py:docstring of aiida.orm.implementation.nodes.BackendNodeCollection.get:3
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNodeCollection.get:3
msgid "id of the node"
msgstr ""

#: ../../../src/aiida/orm/implementation/querybuilder.py:docstring of aiida.orm.implementation.querybuilder:1
msgid "Abstract `QueryBuilder` definition."
msgstr ""

#: ../../../src/aiida/orm/implementation/querybuilder.py:docstring of aiida.orm.implementation.querybuilder.BackendQueryBuilder:1
msgid "Backend query builder interface"
msgstr ""

#: ../../../src/aiida/orm/implementation/querybuilder.py:docstring of aiida.orm.implementation.querybuilder.BackendQueryBuilder.__init__:1
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.__init__:3
#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder.__init__:1
msgid "the backend"
msgstr ""

#: ../../../src/aiida/orm/implementation/querybuilder.py:docstring of aiida.orm.implementation.querybuilder.BackendQueryBuilder.as_sql:8
#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.compile_query:3
msgid "Inline bound parameters (this is normally handled by the Python DBAPI)."
msgstr ""

#: ../../../src/aiida/orm/implementation/querybuilder.py:docstring of aiida.orm.implementation.querybuilder.BackendQueryBuilder.count:1
#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder.count:1
msgid "Return the number of results of the query"
msgstr ""

#: ../../../src/aiida/orm/implementation/querybuilder.py:docstring of aiida.orm.implementation.querybuilder.BackendQueryBuilder.first:1
#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder.first:1
msgid "Executes query, asking for one instance."
msgstr ""

#: ../../../src/aiida/orm/implementation/querybuilder.py:docstring of aiida.orm.implementation.querybuilder.BackendQueryBuilder.first:3
#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder.first:3
msgid "One row of aiida results"
msgstr ""

#: ../../../src/aiida/orm/implementation/querybuilder.py:docstring of aiida.orm.implementation.querybuilder.BackendQueryBuilder.get_creation_statistics:1
#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder.get_creation_statistics:1
msgid "Return a dictionary with the statistics of node creation, summarized by day."
msgstr ""

#: ../../../src/aiida/orm/implementation/querybuilder.py:docstring of aiida.orm.implementation.querybuilder.BackendQueryBuilder.get_creation_statistics:3
#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder.get_creation_statistics:3
msgid "Days when no nodes were created are not present in the returned `ctime_by_day` dictionary."
msgstr ""

#: ../../../src/aiida/orm/implementation/querybuilder.py:docstring of aiida.orm.implementation.querybuilder.BackendQueryBuilder.get_creation_statistics:5
#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder.get_creation_statistics:5
msgid "If None (default), return statistics for all users. If user pk is specified, return only the statistics for the given user."
msgstr ""

#: ../../../src/aiida/orm/implementation/querybuilder.py:docstring of aiida.orm.implementation.querybuilder.BackendQueryBuilder.get_creation_statistics:8
#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder.get_creation_statistics:8
msgid "a dictionary as follows::      {        \"total\": TOTAL_NUM_OF_NODES,        \"types\": {TYPESTRING1: count, TYPESTRING2: count, ...},        \"ctime_by_day\": {'YYYY-MMM-DD': count, ...}     }  where in `ctime_by_day` the key is a string in the format 'YYYY-MM-DD' and the value is an integer with the number of nodes created that day."
msgstr ""

#: ../../../src/aiida/orm/implementation/querybuilder.py:docstring of aiida.orm.implementation.querybuilder.BackendQueryBuilder.get_creation_statistics:8
#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder.get_creation_statistics:8
msgid "a dictionary as follows::"
msgstr ""

#: ../../../src/aiida/orm/implementation/querybuilder.py:docstring of aiida.orm.implementation.querybuilder.BackendQueryBuilder.get_creation_statistics:16
#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder.get_creation_statistics:16
msgid "where in `ctime_by_day` the key is a string in the format 'YYYY-MM-DD' and the value is an integer with the number of nodes created that day."
msgstr ""

#: ../../../src/aiida/orm/implementation/querybuilder.py:docstring of aiida.orm.implementation.querybuilder.BackendQueryBuilder.iterall:1
#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder.iterall:1
msgid "Return an iterator over all the results of a list of lists."
msgstr ""

#: ../../../src/aiida/orm/implementation/querybuilder.py:docstring of aiida.orm.implementation.querybuilder.BackendQueryBuilder.iterdict:1
#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder.iterdict:1
msgid "Return an iterator over all the results of a list of dictionaries."
msgstr ""

#: ../../../src/aiida/orm/implementation/querybuilder.py:docstring of aiida.orm.implementation.querybuilder.PathItemType:1
#: ../../../src/aiida/orm/implementation/querybuilder.py:docstring of aiida.orm.implementation.querybuilder.QueryDictType:1
#: ../../../src/aiida/storage/psql_dos/utils.py:docstring of aiida.storage.psql_dos.utils.PsqlConfig:1
#: ../../../src/aiida/tools/graph/graph_traversers.py:docstring of aiida.tools.graph.graph_traversers.TraverseGraphOutput:1
msgid "Bases: :py:class:`~typing.TypedDict`"
msgstr ""

#: ../../../src/aiida/orm/implementation/querybuilder.py:docstring of aiida.orm.implementation.querybuilder.PathItemType:1
msgid "An item on the query path"
msgstr ""

#: ../../../src/aiida/orm/implementation/querybuilder.py:docstring of aiida.orm.implementation.querybuilder.QueryDictType:1
msgid "A JSON serialisable representation of a ``QueryBuilder`` instance"
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend:1
msgid "Generic backend related objects"
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend:1
msgid "Abstraction for a backend to read/write persistent data for a profile's provenance graph."
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend:3
msgid "AiiDA splits data storage into two sources:"
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend:5
msgid "Searchable data, which is stored in the database and can be queried using the QueryBuilder"
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend:6
msgid "Non-searchable (binary) data, which is stored in the repository and can be loaded using the RepositoryBackend"
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend:8
msgid "The two sources are inter-linked by the ``Node.base.repository.metadata``. Once stored, the leaf values of this dictionary must be valid pointers to object keys in the repository."
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend:11
msgid "For a completely new storage, the ``initialise`` method should be called first. This will automatically initialise the repository and the database with the current schema. The class methods,`version_profile` and `migrate` should be able to be called for existing storage, at any supported schema version. But an instance of this class should be created only for the latest schema version."
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.__init__:1
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.__init__:1
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.__init__:1
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.__init__:1
msgid "Initialize the backend, for this profile."
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.__init__:3
#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.version_profile:3
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.__init__:3
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.version_profile:3
#: ../../../src/aiida/storage/sqlite_dos/backend.py:docstring of aiida.storage.sqlite_dos.backend.SqliteDosStorage.version_profile:3
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.__init__:3
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.version_profile:3
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.__init__:3
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.version_profile:3
msgid "`~aiida.common.exceptions.UnreachableStorage` if the storage cannot be accessed"
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.__init__:4
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.__init__:4
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.__init__:4
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.__init__:4
msgid "`~aiida.common.exceptions.IncompatibleStorageSchema` if the profile's storage schema is not at the latest version (and thus should be migrated)"
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.__init__:6
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.__init__:6
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.__init__:6
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.__init__:6
msgid ":class:`aiida.common.exceptions.CorruptStorage` if the storage is internally inconsistent"
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.__str__:1
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.__str__:1
#: ../../../src/aiida/storage/sqlite_dos/backend.py:docstring of aiida.storage.sqlite_dos.backend.SqliteDosStorage.__str__:1
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.__str__:1
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.__str__:1
msgid "Return a string showing connection details for this instance."
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend._clear:1
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend._clear:1
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend._clear:1
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend._clear:1
msgid "Clear the storage, removing all data."
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend._clear:3
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend._clear:3
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend._clear:3
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend._clear:3
msgid "This is a destructive operation, and should only be used for testing purposes."
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.authinfos:1
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.authinfos:1
#: ../../../src/aiida/storage/sqlite_dos/backend.py:docstring of aiida.storage.sqlite_dos.backend.SqliteDosStorage.authinfos:1
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.authinfos:1
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.authinfos:1
msgid "Return the collection of authorisation information objects"
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.autogroup:1
msgid "Return the autogroup manager for this backend."
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.bulk_insert:1
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.bulk_insert:1
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.bulk_insert:1
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.bulk_insert:1
msgid "Insert a list of entities into the database, directly into a backend transaction."
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.bulk_insert:3
#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.bulk_update:3
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.bulk_insert:3
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.bulk_update:3
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.bulk_insert:3
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.bulk_update:3
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.bulk_insert:3
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.bulk_update:3
#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveWriterAbstract.bulk_insert:3
#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/writer.py:docstring of aiida.tools.archive.implementations.sqlite_zip.writer.ArchiveWriterSqlZip.bulk_insert:3
msgid "The type of the entity"
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.bulk_insert:4
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.bulk_insert:4
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.bulk_insert:4
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.bulk_insert:4
#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveWriterAbstract.bulk_insert:4
#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/writer.py:docstring of aiida.tools.archive.implementations.sqlite_zip.writer.ArchiveWriterSqlZip.bulk_insert:4
msgid "A list of dictionaries, containing all fields of the backend model, except the `id` field (a.k.a primary key), which will be generated dynamically"
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.bulk_insert:6
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.bulk_insert:6
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.bulk_insert:6
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.bulk_insert:6
msgid "If ``False``, assert that each row contains all fields (except primary key(s)), otherwise, allow default values for missing fields."
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.bulk_insert:9
#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.bulk_update:7
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.bulk_insert:9
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.bulk_update:7
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.bulk_insert:9
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.bulk_update:7
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.bulk_insert:9
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.bulk_update:7
#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveWriterAbstract.bulk_insert:9
#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/writer.py:docstring of aiida.tools.archive.implementations.sqlite_zip.writer.ArchiveWriterSqlZip.bulk_insert:9
msgid "``IntegrityError`` if the keys in a row are not a subset of the columns in the table"
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.bulk_insert:11
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.bulk_insert:11
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.bulk_insert:11
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.bulk_insert:11
msgid "The list of generated primary keys for the entities"
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.bulk_update:1
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.bulk_update:1
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.bulk_update:1
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.bulk_update:1
msgid "Update a list of entities in the database, directly with a backend transaction."
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.bulk_update:4
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.bulk_update:4
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.bulk_update:4
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.bulk_update:4
msgid "A list of dictionaries, containing fields of the backend model to update, and the `id` field (a.k.a primary key)"
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.close:1
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.close:1
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.close:1
msgid "Close the storage access."
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.comments:1
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.comments:1
#: ../../../src/aiida/storage/sqlite_dos/backend.py:docstring of aiida.storage.sqlite_dos.backend.SqliteDosStorage.comments:1
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.comments:1
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.comments:1
msgid "Return the collection of comments"
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.computers:1
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.computers:1
#: ../../../src/aiida/storage/sqlite_dos/backend.py:docstring of aiida.storage.sqlite_dos.backend.SqliteDosStorage.computers:1
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.computers:1
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.computers:1
msgid "Return the collection of computers"
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.default_user:1
msgid "Return the default user for the profile, if it has been created."
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.default_user:3
msgid "This is cached, since it is a frequently used operation, for creating other entities."
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.delete:1
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.delete:1
#: ../../../src/aiida/storage/sqlite_dos/backend.py:docstring of aiida.storage.sqlite_dos.backend.SqliteDosStorage.delete:1
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.delete:1
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.delete:1
msgid "Delete the storage and all the data."
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.delete_nodes_and_connections:1
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.delete_nodes_and_connections:1
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.delete_nodes_and_connections:1
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.delete_nodes_and_connections:1
msgid "Delete all nodes corresponding to pks in the input and any links to/from them."
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.delete_nodes_and_connections:3
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.delete_nodes_and_connections:3
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.delete_nodes_and_connections:3
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.delete_nodes_and_connections:3
msgid "This method is intended to be used within a transaction context."
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.delete_nodes_and_connections:5
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.delete_nodes_and_connections:5
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.delete_nodes_and_connections:5
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.delete_nodes_and_connections:5
msgid "a sequence of node pks to delete"
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.delete_nodes_and_connections:7
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.delete_nodes_and_connections:7
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.delete_nodes_and_connections:7
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.delete_nodes_and_connections:7
msgid "``AssertionError`` if a transaction is not active"
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.get_global_variable:1
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.get_global_variable:1
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.get_global_variable:1
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.get_global_variable:1
msgid "Return a global variable from the storage."
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.get_global_variable:3
#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.set_global_variable:3
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.get_global_variable:3
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.set_global_variable:3
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.get_global_variable:3
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.set_global_variable:3
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.get_global_variable:3
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.set_global_variable:3
msgid "the key of the setting"
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.get_global_variable:5
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.get_global_variable:5
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.get_global_variable:5
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.get_global_variable:5
msgid "`KeyError` if the setting does not exist"
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.get_info:1
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.get_info:1
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.get_info:1
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.get_info:1
msgid "Return general information on the storage."
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.get_info:3
#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.get_orm_entities:3
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.get_info:3
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.get_info:3
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.get_info:3
msgid "flag to request more detailed information about the content of the storage."
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.get_info:4
#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.get_orm_entities:4
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.get_info:4
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.get_info:4
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.get_info:4
msgid "a nested dict with the relevant information."
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.get_orm_entities:1
msgid "Return a mapping with an overview of the storage contents regarding ORM entities."
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.get_repository:1
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.get_repository:1
#: ../../../src/aiida/storage/sqlite_dos/backend.py:docstring of aiida.storage.sqlite_dos.backend.SqliteDosStorage.get_repository:1
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.get_repository:1
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.get_repository:1
msgid "Return the object repository configured for this backend."
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.groups:1
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.groups:1
#: ../../../src/aiida/storage/sqlite_dos/backend.py:docstring of aiida.storage.sqlite_dos.backend.SqliteDosStorage.groups:1
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.groups:1
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.groups:1
msgid "Return the collection of groups"
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.in_transaction:1
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.in_transaction:1
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.in_transaction:1
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.in_transaction:1
msgid "Return whether a transaction is currently active."
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.initialise:1
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.initialise:1
#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator.initialise:1
#: ../../../src/aiida/storage/sqlite_dos/backend.py:docstring of aiida.storage.sqlite_dos.backend.SqliteDosStorage.initialise:1
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.initialise:1
msgid "Initialise the storage backend."
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.initialise:3
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.initialise:3
#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator.initialise:3
#: ../../../src/aiida/storage/sqlite_dos/backend.py:docstring of aiida.storage.sqlite_dos.backend.SqliteDosStorage.initialise:3
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.initialise:3
msgid "This is typically used once when a new storage backed is created. If this method returns without exceptions the storage backend is ready for use. If the backend already seems initialised, this method is a no-op."
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.initialise:6
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.initialise:6
#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator.initialise:6
#: ../../../src/aiida/storage/sqlite_dos/backend.py:docstring of aiida.storage.sqlite_dos.backend.SqliteDosStorage.initialise:6
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.initialise:6
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.initialise:3
msgid "If ``true``, destroy the backend if it already exists including all of its data before recreating and initialising it. This is useful for example for test profiles that need to be reset before or after tests having run."
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.initialise:9
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.initialise:9
#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator.initialise:9
#: ../../../src/aiida/storage/sqlite_dos/backend.py:docstring of aiida.storage.sqlite_dos.backend.SqliteDosStorage.initialise:9
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.initialise:9
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.initialise:6
msgid "``True`` if the storage was initialised by the function call, ``False`` if it was already initialised."
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.is_closed:1
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.is_closed:1
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.is_closed:1
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.is_closed:1
msgid "Return whether the storage is closed."
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.logs:1
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.logs:1
#: ../../../src/aiida/storage/sqlite_dos/backend.py:docstring of aiida.storage.sqlite_dos.backend.SqliteDosStorage.logs:1
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.logs:1
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.logs:1
msgid "Return the collection of logs"
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.maintain:1
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.maintain:1
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.maintain:1
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.maintain:1
msgid "Perform maintenance tasks on the storage."
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.maintain:3
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.maintain:3
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.maintain:3
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.maintain:3
msgid "If `full == True`, then this method may attempt to block the profile associated with the storage to guarantee the safety of its procedures. This will not only prevent any other subsequent process from accessing that profile, but will also first check if there is already any process using it and raise if that is the case. The user will have to manually stop any processes that is currently accessing the profile themselves or wait for it to finish on its own."
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.maintain:10
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.maintain:10
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.maintain:10
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.maintain:10
msgid "flag to perform operations that require to stop using the profile to be maintained."
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.maintain:11
#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.maintain:3
#: ../../../src/aiida/repository/backend/sandbox.py:docstring of aiida.repository.backend.sandbox.SandboxRepositoryBackend.maintain:3
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.maintain:11
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.NoopRepositoryBackend.maintain:3
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SandboxShaRepositoryBackend.maintain:3
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.maintain:11
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.maintain:11
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend._RoBackendRepository.maintain:3
msgid "flag to only print the actions that would be taken without actually executing them."
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.migrate:1
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.migrate:1
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.migrate:1
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.migrate:1
msgid "Migrate the storage of a profile to the latest schema version."
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.migrate:3
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.migrate:3
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.migrate:3
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.migrate:3
msgid "If the schema version is already the latest version, this method does nothing. If the storage is uninitialised, this method will raise an exception."
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.migrate:6
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.migrate:6
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.migrate:6
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.migrate:6
msgid ":class`~aiida.common.exceptions.UnreachableStorage` if the storage cannot be accessed."
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.migrate:7
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.migrate:7
#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator.migrate:4
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.migrate:7
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.migrate:7
msgid ":class:`~aiida.common.exceptions.StorageMigrationError` if the storage is not initialised."
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.nodes:1
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.nodes:1
#: ../../../src/aiida/storage/sqlite_dos/backend.py:docstring of aiida.storage.sqlite_dos.backend.SqliteDosStorage.nodes:1
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.nodes:1
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.nodes:1
msgid "Return the collection of nodes"
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.profile:1
msgid "Return the profile for this backend."
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.query:1
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.query:1
#: ../../../src/aiida/storage/sqlite_dos/backend.py:docstring of aiida.storage.sqlite_dos.backend.SqliteDosStorage.query:1
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.query:1
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.query:1
msgid "Return an instance of a query builder implementation for this backend"
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.reset_default_user:1
msgid "Reset the default user."
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.reset_default_user:3
msgid "This should be done when the default user of the storage backend is changed on the corresponding profile because the old default user is cached on this instance."
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.set_global_variable:1
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.set_global_variable:1
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.set_global_variable:1
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.set_global_variable:1
msgid "Set a global variable in the storage."
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.set_global_variable:4
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.set_global_variable:4
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.set_global_variable:4
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.set_global_variable:4
msgid "the value of the setting"
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.set_global_variable:5
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.set_global_variable:5
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.set_global_variable:5
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.set_global_variable:5
msgid "the description of the setting (optional)"
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.set_global_variable:6
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.set_global_variable:6
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.set_global_variable:6
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.set_global_variable:6
msgid "if True, overwrite the setting if it already exists"
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.set_global_variable:8
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.set_global_variable:8
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.set_global_variable:8
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.set_global_variable:8
msgid "`ValueError` if the key already exists and `overwrite` is False"
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.transaction:1
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.transaction:1
msgid "Get a context manager that can be used as a transaction context for a series of backend operations. If there is an exception within the context then the changes will be rolled back and the state will be as before entering.  Transactions can be nested."
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.transaction:5
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.transaction:5
msgid "a context manager to group database operations"
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.users:1
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.users:1
#: ../../../src/aiida/storage/sqlite_dos/backend.py:docstring of aiida.storage.sqlite_dos.backend.SqliteDosStorage.users:1
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.users:1
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.users:1
msgid "Return the collection of users"
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.version:1
msgid "Return the schema version of the profile's storage."
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.version_head:1
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.version_head:1
#: ../../../src/aiida/storage/sqlite_dos/backend.py:docstring of aiida.storage.sqlite_dos.backend.SqliteDosStorage.version_head:1
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.version_head:1
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.version_head:1
msgid "Return the head schema version of this storage backend type."
msgstr ""

#: ../../../src/aiida/orm/implementation/storage_backend.py:docstring of aiida.orm.implementation.storage_backend.StorageBackend.version_profile:1
#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.version_profile:1
#: ../../../src/aiida/storage/sqlite_dos/backend.py:docstring of aiida.storage.sqlite_dos.backend.SqliteDosStorage.version_profile:1
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.version_profile:1
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.version_profile:1
msgid "Return the schema version of the given profile's storage, or None for empty/uninitialised storage."
msgstr ""

#: ../../../src/aiida/orm/implementation/users.py:docstring of aiida.orm.implementation.users:1
msgid "Backend user"
msgstr ""

#: ../../../src/aiida/orm/implementation/users.py:docstring of aiida.orm.implementation.users.BackendUser:1
msgid "Backend implementation for the `User` ORM class."
msgstr ""

#: ../../../src/aiida/orm/implementation/users.py:docstring of aiida.orm.implementation.users.BackendUser:3
msgid "A user can be assigned as the creator of a variety of other entities."
msgstr ""

#: ../../../src/aiida/orm/implementation/users.py:docstring of aiida.orm.implementation.users.BackendUser.email:1
#: ../../../src/aiida/storage/psql_dos/orm/users.py:docstring of aiida.storage.psql_dos.orm.users.SqlaUser.email:1
msgid "Get the email address of the user"
msgstr ""

#: ../../../src/aiida/orm/implementation/users.py:docstring of aiida.orm.implementation.users.BackendUser.email:3
#: ../../../src/aiida/storage/psql_dos/orm/users.py:docstring of aiida.storage.psql_dos.orm.users.SqlaUser.email:3
msgid "the email address"
msgstr ""

#: ../../../src/aiida/orm/implementation/users.py:docstring of aiida.orm.implementation.users.BackendUser.first_name:1
#: ../../../src/aiida/storage/psql_dos/orm/users.py:docstring of aiida.storage.psql_dos.orm.users.SqlaUser.first_name:1
msgid "Get the user's first name"
msgstr ""

#: ../../../src/aiida/orm/implementation/users.py:docstring of aiida.orm.implementation.users.BackendUser.first_name:3
#: ../../../src/aiida/storage/psql_dos/orm/users.py:docstring of aiida.storage.psql_dos.orm.users.SqlaUser.first_name:3
msgid "the first name"
msgstr ""

#: ../../../src/aiida/orm/implementation/users.py:docstring of aiida.orm.implementation.users.BackendUser.institution:1
#: ../../../src/aiida/storage/psql_dos/orm/users.py:docstring of aiida.storage.psql_dos.orm.users.SqlaUser.institution:1
msgid "Get the user's institution"
msgstr ""

#: ../../../src/aiida/orm/implementation/users.py:docstring of aiida.orm.implementation.users.BackendUser.institution:3
#: ../../../src/aiida/storage/psql_dos/orm/users.py:docstring of aiida.storage.psql_dos.orm.users.SqlaUser.institution:3
msgid "the institution"
msgstr ""

#: ../../../src/aiida/orm/implementation/users.py:docstring of aiida.orm.implementation.users.BackendUser.last_name:1
#: ../../../src/aiida/storage/psql_dos/orm/users.py:docstring of aiida.storage.psql_dos.orm.users.SqlaUser.last_name:1
msgid "Get the user's last name"
msgstr ""

#: ../../../src/aiida/orm/implementation/users.py:docstring of aiida.orm.implementation.users.BackendUser.last_name:3
#: ../../../src/aiida/storage/psql_dos/orm/users.py:docstring of aiida.storage.psql_dos.orm.users.SqlaUser.last_name:3
msgid "the last name"
msgstr ""

#: ../../../src/aiida/orm/implementation/users.py:docstring of aiida.orm.implementation.users.BackendUserCollection:1
msgid "Bases: :py:class:`~aiida.orm.implementation.entities.BackendCollection`\\ [:py:class:`~aiida.orm.implementation.users.BackendUser`]"
msgstr ""

#: ../../../src/aiida/orm/implementation/utils.py:docstring of aiida.orm.implementation.utils:1
msgid "Utility methods for backend non-specific implementations."
msgstr ""

#: ../../../src/aiida/orm/implementation/utils.py:docstring of aiida.orm.implementation.utils.clean_value:1
msgid "Get value from input and (recursively) replace, if needed, all occurrences of BaseType AiiDA data nodes with their value, and List with a standard list. It also makes a deep copy of everything The purpose of this function is to convert data to a type which can be serialized and deserialized for storage in the DB without its value changing."
msgstr ""

#: ../../../src/aiida/orm/implementation/utils.py:docstring of aiida.orm.implementation.utils.clean_value:7
msgid "Note however that there is no logic to avoid infinite loops when the user passes some perverse recursive dictionary or list. In any case, however, this would not be storable by AiiDA..."
msgstr ""

#: ../../../src/aiida/orm/implementation/utils.py:docstring of aiida.orm.implementation.utils.clean_value:11
msgid "A value to be set as an attribute or an extra"
msgstr ""

#: ../../../src/aiida/orm/implementation/utils.py:docstring of aiida.orm.implementation.utils.clean_value:12
msgid "a \"cleaned\" value, potentially identical to value, but with values replaced where needed."
msgstr ""

#: ../../../src/aiida/orm/implementation/utils.py:docstring of aiida.orm.implementation.utils.validate_attribute_extra_key:1
msgid "Validate the key for an entity attribute or extra."
msgstr ""

#: ../../../src/aiida/orm/implementation/utils.py:docstring of aiida.orm.implementation.utils.validate_attribute_extra_key:3
msgid "if the key is not a string or contains reserved separator character"
msgstr ""

#: ../../source/reference/apidoc/aiida.orm.nodes.rst:2
msgid "aiida.orm.nodes package"
msgstr ""

#: ../../../src/aiida/orm/nodes/__init__.py:docstring of aiida.orm.nodes:1
msgid "Module with `Node` sub classes for data and processes."
msgstr ""

#: ../../../src/aiida/orm/nodes/attributes.py:docstring of aiida.orm.nodes.attributes.NodeAttributes:3
msgid "Attributes are a JSONable dictionary, stored on each node, allowing for arbitrary data to be stored by node subclasses (and thus data plugins)."
msgstr ""

#: ../../../src/aiida/orm/nodes/attributes.py:docstring of aiida.orm.nodes.attributes.NodeAttributes:6
msgid "Once the node is stored, the attributes are generally deemed immutable (except for some updatable keys on process nodes, which can be mutated whilst the node is not \"sealed\")."
msgstr ""

#: ../../../src/aiida/orm/nodes/attributes.py:docstring of aiida.orm.nodes.attributes.NodeAttributes.__contains__:1
msgid "Check if the node contains an attribute with the given key."
msgstr ""

#: ../../../src/aiida/orm/nodes/attributes.py:docstring of aiida.orm.nodes.attributes.NodeAttributes.all:3
#: ../../../src/aiida/orm/nodes/attributes.py:docstring of aiida.orm.nodes.attributes.NodeAttributes.get_many:3
msgid "While the entity is unstored, this will return references of the attributes on the database model, meaning that changes on the returned values (if they are mutable themselves, e.g. a list or dictionary) will automatically be reflected on the database model as well. As soon as the entity is stored, the returned attributes will be a deep copy and mutations of the database attributes will have to go through the appropriate set methods. Therefore, once stored, retrieving a deep copy can be a heavy operation. If you only need the keys or some values, use the iterators `keys` and `items`, or the getters `get` and `get_many` instead."
msgstr ""

#: ../../../src/aiida/orm/nodes/attributes.py:docstring of aiida.orm.nodes.attributes.NodeAttributes.delete:5
#: ../../../src/aiida/orm/nodes/attributes.py:docstring of aiida.orm.nodes.attributes.NodeAttributes.delete_many:5
#: ../../../src/aiida/orm/nodes/attributes.py:docstring of aiida.orm.nodes.attributes.NodeAttributes.reset:7
#: ../../../src/aiida/orm/nodes/attributes.py:docstring of aiida.orm.nodes.attributes.NodeAttributes.set:6
#: ../../../src/aiida/orm/nodes/attributes.py:docstring of aiida.orm.nodes.attributes.NodeAttributes.set_many:7
msgid "if the entity is stored"
msgstr ""

#: ../../../src/aiida/orm/nodes/attributes.py:docstring of aiida.orm.nodes.attributes.NodeAttributes.get:12
msgid "if the attribute does not exist and no default is specified"
msgstr ""

#: ../../../src/aiida/orm/nodes/caching.py:docstring of aiida.orm.nodes.caching.NodeCaching.__init__:1
msgid "Initialize the caching interface."
msgstr ""

#: ../../../src/aiida/orm/nodes/caching.py:docstring of aiida.orm.nodes.caching.NodeCaching._get_hash:1
#: ../../../src/aiida/orm/nodes/caching.py:docstring of aiida.orm.nodes.caching.NodeCaching.get_hash:1
msgid "Return the hash for this node based on its attributes."
msgstr ""

#: ../../../src/aiida/orm/nodes/caching.py:docstring of aiida.orm.nodes.caching.NodeCaching._get_hash:3
msgid "This will always work, even before storing."
msgstr ""

#: ../../../src/aiida/orm/nodes/caching.py:docstring of aiida.orm.nodes.caching.NodeCaching._get_hash:5
#: ../../../src/aiida/orm/nodes/caching.py:docstring of aiida.orm.nodes.caching.NodeCaching.get_hash:3
msgid "return ``None`` on ``aiida.common.exceptions.HashingError`` (logging the exception)"
msgstr ""

#: ../../../src/aiida/orm/nodes/caching.py:docstring of aiida.orm.nodes.caching.NodeCaching._get_objects_to_hash:1
#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNodeCaching._get_objects_to_hash:1
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNodeCaching._get_objects_to_hash:1
msgid "Return a list of objects which should be included in the hash."
msgstr ""

#: ../../../src/aiida/orm/nodes/caching.py:docstring of aiida.orm.nodes.caching.NodeCaching._get_same_node:1
msgid "Returns a stored node from which the current Node can be cached or None if it does not exist"
msgstr ""

#: ../../../src/aiida/orm/nodes/caching.py:docstring of aiida.orm.nodes.caching.NodeCaching._get_same_node:3
msgid "If a node is returned it is a valid cache, meaning its `_aiida_hash` extra matches `self.get_hash()`. If there are multiple valid matches, the first one is returned. If no matches are found, `None` is returned."
msgstr ""

#: ../../../src/aiida/orm/nodes/caching.py:docstring of aiida.orm.nodes.caching.NodeCaching._get_same_node:7
msgid "a stored `Node` instance with the same hash as this code or None"
msgstr ""

#: ../../../src/aiida/orm/nodes/caching.py:docstring of aiida.orm.nodes.caching.NodeCaching._get_same_node:9
#: ../../../src/aiida/orm/nodes/caching.py:docstring of aiida.orm.nodes.caching.NodeCaching._iter_all_same_nodes:3
msgid "Note: this should be only called on stored nodes, or internally from .store() since it first calls clean_value() on the attributes to normalise them."
msgstr ""

#: ../../../src/aiida/orm/nodes/caching.py:docstring of aiida.orm.nodes.caching.NodeCaching._iter_all_same_nodes:1
msgid "Returns an iterator of all same nodes."
msgstr ""

#: ../../../src/aiida/orm/nodes/caching.py:docstring of aiida.orm.nodes.caching.NodeCaching.clear_hash:1
msgid "Sets the stored hash of the Node to None."
msgstr ""

#: ../../../src/aiida/orm/nodes/caching.py:docstring of aiida.orm.nodes.caching.NodeCaching.get_all_same_nodes:1
msgid "Return a list of stored nodes which match the type and hash of the current node."
msgstr ""

#: ../../../src/aiida/orm/nodes/caching.py:docstring of aiida.orm.nodes.caching.NodeCaching.get_all_same_nodes:3
msgid "All returned nodes are valid caches, meaning their `_aiida_hash` extra matches `self.get_hash()`."
msgstr ""

#: ../../../src/aiida/orm/nodes/caching.py:docstring of aiida.orm.nodes.caching.NodeCaching.get_all_same_nodes:5
msgid "Note: this can be called only after storing a Node (since at store time attributes will be cleaned with `clean_value` and the hash should become idempotent to the action of serialization/deserialization)"
msgstr ""

#: ../../../src/aiida/orm/nodes/caching.py:docstring of aiida.orm.nodes.caching.NodeCaching.get_cache_source:1
msgid "Return the UUID of the node that was used in creating this node from the cache, or None if it was not cached."
msgstr ""

#: ../../../src/aiida/orm/nodes/caching.py:docstring of aiida.orm.nodes.caching.NodeCaching.get_cache_source:3
msgid "source node UUID or None"
msgstr ""

#: ../../../src/aiida/orm/nodes/caching.py:docstring of aiida.orm.nodes.caching.NodeCaching.is_created_from_cache:1
msgid "Return whether this node was created from a cached node."
msgstr ""

#: ../../../src/aiida/orm/nodes/caching.py:docstring of aiida.orm.nodes.caching.NodeCaching.is_created_from_cache:3
msgid "boolean, True if the node was created by cloning a cached node, False otherwise"
msgstr ""

#: ../../../src/aiida/orm/nodes/caching.py:docstring of aiida.orm.nodes.caching.NodeCaching.is_valid_cache:1
#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node.is_valid_cache:1
msgid "Hook to exclude certain ``Node`` classes from being considered a valid cache."
msgstr ""

#: ../../../src/aiida/orm/nodes/caching.py:docstring of aiida.orm.nodes.caching.NodeCaching.is_valid_cache:3
#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node.is_valid_cache:3
msgid "The base class assumes that all node instances are valid to cache from, unless the ``_VALID_CACHE_KEY`` extra has been set to ``False`` explicitly. Subclasses can override this property with more specific logic, but should probably also consider the value returned by this base class."
msgstr ""

#: ../../../src/aiida/orm/nodes/caching.py:docstring of aiida.orm.nodes.caching.NodeCaching.rehash:1
msgid "Regenerate the stored hash of the Node."
msgstr ""

#: ../../../src/aiida/orm/nodes/comments.py:docstring of aiida.orm.nodes.comments.NodeComments.__init__:1
msgid "Initialize the comments interface."
msgstr ""

#: ../../../src/aiida/orm/nodes/comments.py:docstring of aiida.orm.nodes.comments.NodeComments.add:1
msgid "Add a new comment."
msgstr ""

#: ../../../src/aiida/orm/nodes/comments.py:docstring of aiida.orm.nodes.comments.NodeComments.add:3
msgid "string with comment"
msgstr ""

#: ../../../src/aiida/orm/nodes/comments.py:docstring of aiida.orm.nodes.comments.NodeComments.add:4
msgid "the user to associate with the comment, will use default if not supplied"
msgstr ""

#: ../../../src/aiida/orm/nodes/comments.py:docstring of aiida.orm.nodes.comments.NodeComments.add:5
msgid "the newly created comment"
msgstr ""

#: ../../../src/aiida/orm/nodes/comments.py:docstring of aiida.orm.nodes.comments.NodeComments.all:1
msgid "Return a sorted list of comments for this node."
msgstr ""

#: ../../../src/aiida/orm/nodes/comments.py:docstring of aiida.orm.nodes.comments.NodeComments.all:3
msgid "the list of comments, sorted by pk"
msgstr ""

#: ../../../src/aiida/orm/nodes/comments.py:docstring of aiida.orm.nodes.comments.NodeComments.get:1
msgid "Return a comment corresponding to the given identifier."
msgstr ""

#: ../../../src/aiida/orm/nodes/comments.py:docstring of aiida.orm.nodes.comments.NodeComments.get:3
#: ../../../src/aiida/orm/nodes/comments.py:docstring of aiida.orm.nodes.comments.NodeComments.remove:3
#: ../../../src/aiida/orm/nodes/comments.py:docstring of aiida.orm.nodes.comments.NodeComments.update:3
msgid "the comment pk"
msgstr ""

#: ../../../src/aiida/orm/nodes/comments.py:docstring of aiida.orm.nodes.comments.NodeComments.get:4
#: ../../../src/aiida/orm/nodes/comments.py:docstring of aiida.orm.nodes.comments.NodeComments.update:5
msgid "if the comment with the given id does not exist"
msgstr ""

#: ../../../src/aiida/orm/nodes/comments.py:docstring of aiida.orm.nodes.comments.NodeComments.get:5
#: ../../../src/aiida/orm/nodes/comments.py:docstring of aiida.orm.nodes.comments.NodeComments.update:6
msgid "if the id cannot be uniquely resolved to a comment"
msgstr ""

#: ../../../src/aiida/orm/nodes/comments.py:docstring of aiida.orm.nodes.comments.NodeComments.get:6
msgid "the comment"
msgstr ""

#: ../../../src/aiida/orm/nodes/comments.py:docstring of aiida.orm.nodes.comments.NodeComments.remove:1
msgid "Delete an existing comment."
msgstr ""

#: ../../../src/aiida/orm/nodes/comments.py:docstring of aiida.orm.nodes.comments.NodeComments.update:1
msgid "Update the content of an existing comment."
msgstr ""

#: ../../../src/aiida/orm/nodes/comments.py:docstring of aiida.orm.nodes.comments.NodeComments.update:4
msgid "the new comment content"
msgstr ""

#: ../../../src/aiida/orm/nodes/links.py:docstring of aiida.orm.nodes.links.NodeLinks.__init__:1
msgid "Initialize the links interface."
msgstr ""

#: ../../../src/aiida/orm/nodes/links.py:docstring of aiida.orm.nodes.links.NodeLinks._add_incoming_cache:1
msgid "Add an incoming link to the cache."
msgstr ""

#: ../../../src/aiida/orm/nodes/links.py:docstring of aiida.orm.nodes.links.NodeLinks._add_incoming_cache:9
msgid "if the given link triple already exists in the cache"
msgstr ""

#: ../../../src/aiida/orm/nodes/links.py:docstring of aiida.orm.nodes.links.NodeLinks.get_incoming:1
msgid "Return a list of link triples that are (directly) incoming into this node."
msgstr ""

#: ../../../src/aiida/orm/nodes/links.py:docstring of aiida.orm.nodes.links.NodeLinks.get_incoming:3
#: ../../../src/aiida/orm/nodes/links.py:docstring of aiida.orm.nodes.links.NodeLinks.get_outgoing:3
msgid "If specified, should be a class or tuple of classes, and it filters only elements of that specific type (or a subclass of 'type')"
msgstr ""

#: ../../../src/aiida/orm/nodes/links.py:docstring of aiida.orm.nodes.links.NodeLinks.get_incoming:5
msgid "If specified should be a string or tuple to get the inputs of this link type, if None then returns all inputs of all link types."
msgstr ""

#: ../../../src/aiida/orm/nodes/links.py:docstring of aiida.orm.nodes.links.NodeLinks.get_incoming:7
msgid "filters the incoming nodes by its link label. Here wildcards (% and _) can be passed in link label filter as we are using \"like\" in QB."
msgstr ""

#: ../../../src/aiida/orm/nodes/links.py:docstring of aiida.orm.nodes.links.NodeLinks.get_incoming:9
#: ../../../src/aiida/orm/nodes/links.py:docstring of aiida.orm.nodes.links.NodeLinks.get_outgoing:9
#: ../../../src/aiida/orm/nodes/links.py:docstring of aiida.orm.nodes.links.NodeLinks.get_stored_link_triples:10
msgid "project only the node UUID instead of the instance onto the `NodeTriple.node` entries"
msgstr ""

#: ../../../src/aiida/orm/nodes/links.py:docstring of aiida.orm.nodes.links.NodeLinks.get_outgoing:1
msgid "Return a list of link triples that are (directly) outgoing of this node."
msgstr ""

#: ../../../src/aiida/orm/nodes/links.py:docstring of aiida.orm.nodes.links.NodeLinks.get_outgoing:5
msgid "If specified should be a string or tuple to get the inputs of this link type, if None then returns all outputs of all link types."
msgstr ""

#: ../../../src/aiida/orm/nodes/links.py:docstring of aiida.orm.nodes.links.NodeLinks.get_outgoing:7
msgid "filters the outgoing nodes by its link label. Here wildcards (% and _) can be passed in link label filter as we are using \"like\" in QB."
msgstr ""

#: ../../../src/aiida/orm/nodes/links.py:docstring of aiida.orm.nodes.links.NodeLinks.get_stored_link_triples:1
msgid "Return the list of stored link triples directly incoming to or outgoing of this node."
msgstr ""

#: ../../../src/aiida/orm/nodes/links.py:docstring of aiida.orm.nodes.links.NodeLinks.get_stored_link_triples:3
msgid "Note this will only return link triples that are stored in the database. Anything in the cache is ignored."
msgstr ""

#: ../../../src/aiida/orm/nodes/links.py:docstring of aiida.orm.nodes.links.NodeLinks.get_stored_link_triples:5
msgid "If specified, should be a class, and it filters only elements of that (subclass of) type"
msgstr ""

#: ../../../src/aiida/orm/nodes/links.py:docstring of aiida.orm.nodes.links.NodeLinks.get_stored_link_triples:6
msgid "Only get inputs of this link type, if empty tuple then returns all inputs of all link types."
msgstr ""

#: ../../../src/aiida/orm/nodes/links.py:docstring of aiida.orm.nodes.links.NodeLinks.get_stored_link_triples:7
msgid "filters the incoming nodes by its link label. This should be a regex statement as one would pass directly to a QueryBuilder filter statement with the 'like' operation."
msgstr ""

#: ../../../src/aiida/orm/nodes/links.py:docstring of aiida.orm.nodes.links.NodeLinks.get_stored_link_triples:9
msgid "`incoming` or `outgoing` to get the incoming or outgoing links, respectively."
msgstr ""

#: ../../../src/aiida/orm/nodes/links.py:docstring of aiida.orm.nodes.links.NodeLinks.validate_incoming:1
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNodeLinks.validate_incoming:1
msgid "Validate adding a link of the given type from a given node to ourself."
msgstr ""

#: ../../../src/aiida/orm/nodes/links.py:docstring of aiida.orm.nodes.links.NodeLinks.validate_incoming:3
msgid "This function will first validate the types of the inputs, followed by the node and link types and validate whether in principle a link of that type between the nodes of these types is allowed."
msgstr ""

#: ../../../src/aiida/orm/nodes/links.py:docstring of aiida.orm.nodes.links.NodeLinks.validate_incoming:6
msgid "Subsequently, the validity of the \"degree\" of the proposed link is validated, which means validating the number of links of the given type from the given node type is allowed."
msgstr ""

#: ../../../src/aiida/orm/nodes/links.py:docstring of aiida.orm.nodes.links.NodeLinks.validate_outgoing:1
#: ../../../src/aiida/orm/nodes/process/calculation/calcfunction.py:docstring of aiida.orm.nodes.process.calculation.calcfunction.CalcFunctionNodeLinks.validate_outgoing:1
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNodeLinks.validate_outgoing:1
#: ../../../src/aiida/orm/nodes/process/workflow/workflow.py:docstring of aiida.orm.nodes.process.workflow.workflow.WorkflowNodeLinks.validate_outgoing:1
#: ../../../src/aiida/orm/nodes/process/workflow/workfunction.py:docstring of aiida.orm.nodes.process.workflow.workfunction.WorkFunctionNodeLinks.validate_outgoing:1
msgid "Validate adding a link of the given type from ourself to a given node."
msgstr ""

#: ../../../src/aiida/orm/nodes/links.py:docstring of aiida.orm.nodes.links.NodeLinks.validate_outgoing:3
msgid "The validity of the triple (source, link, target) should be validated in the `validate_incoming` call. This method will be called afterwards and can be overriden by subclasses to add additional checks that are specific to that subclass."
msgstr ""

#: ../../../src/aiida/orm/nodes/links.py:docstring of aiida.orm.nodes.links.NodeLinks.validate_outgoing:7
#: ../../../src/aiida/orm/nodes/process/calculation/calcfunction.py:docstring of aiida.orm.nodes.process.calculation.calcfunction.CalcFunctionNodeLinks.validate_outgoing:7
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNodeLinks.validate_outgoing:5
#: ../../../src/aiida/orm/nodes/process/workflow/workflow.py:docstring of aiida.orm.nodes.process.workflow.workflow.WorkflowNodeLinks.validate_outgoing:7
#: ../../../src/aiida/orm/nodes/process/workflow/workfunction.py:docstring of aiida.orm.nodes.process.workflow.workfunction.WorkFunctionNodeLinks.validate_outgoing:7
#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links.validate_link:55
msgid "the node to which the link is going"
msgstr ""

#: ../../../src/aiida/orm/nodes/links.py:docstring of aiida.orm.nodes.links.NodeLinks.validate_outgoing:10
#: ../../../src/aiida/orm/nodes/process/calculation/calcfunction.py:docstring of aiida.orm.nodes.process.calculation.calcfunction.CalcFunctionNodeLinks.validate_outgoing:10
#: ../../../src/aiida/orm/nodes/process/workflow/workflow.py:docstring of aiida.orm.nodes.process.workflow.workflow.WorkflowNodeLinks.validate_outgoing:10
#: ../../../src/aiida/orm/nodes/process/workflow/workfunction.py:docstring of aiida.orm.nodes.process.workflow.workfunction.WorkFunctionNodeLinks.validate_outgoing:10
msgid "if `target` is not a Node instance or `link_type` is not a `LinkType` enum"
msgstr ""

#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node:1
msgid "Package for node ORM classes."
msgstr ""

#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node:1
msgid "Bases: :py:class:`~aiida.orm.entities.Entity`\\ [:py:class:`BackendNode`, :py:class:`~aiida.orm.nodes.node.NodeCollection`]"
msgstr ""

#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node:1
msgid "Base class for all nodes in AiiDA."
msgstr ""

#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node:3
msgid "Stores attributes starting with an underscore."
msgstr ""

#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node:5
msgid "Caches files and attributes before the first save, and saves everything only on store(). After the call to store(), attributes cannot be changed."
msgstr ""

#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node:8
msgid "Only after storing (or upon loading from uuid) extras can be modified and in this case they are directly set on the db."
msgstr ""

#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node:11
msgid "In the plugin, also set the _plugin_type_string, to be set in the DB in the 'type' field."
msgstr ""

#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node.__copy__:1
msgid "Copying a Node is not supported in general, but only for the Data sub class."
msgstr ""

#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node.__deepcopy__:1
msgid "Deep copying a Node is not supported in general, but only for the Data sub class."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/base.py:docstring of aiida.orm.nodes.data.base.BaseType.__eq__:1
#: ../../../src/aiida/orm/nodes/data/dict.py:docstring of aiida.orm.nodes.data.dict.Dict.__eq__:1
#: ../../../src/aiida/orm/nodes/data/list.py:docstring of aiida.orm.nodes.data.list.List.__eq__:1
#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node.__eq__:1
msgid "Fallback equality comparison by uuid (can be overwritten by specific types)"
msgstr ""

#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node.__getattr__:1
msgid "This method is called when an attribute is not found in the instance."
msgstr ""

#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node.__hash__:1
msgid "Python-Hash: Implementation that is compatible with __eq__"
msgstr ""

#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node._add_outputs_from_cache:1
msgid "Replicate the output links and nodes from the cached node onto this node."
msgstr ""

#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node._check_mutability_attributes:1
#: ../../../src/aiida/orm/utils/mixins.py:docstring of aiida.orm.utils.mixins.Sealable._check_mutability_attributes:1
msgid "Check if the entity is mutable and raise an exception if not."
msgstr ""

#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node._check_mutability_attributes:3
#: ../../../src/aiida/orm/utils/mixins.py:docstring of aiida.orm.utils.mixins.Sealable._check_mutability_attributes:3
msgid "This is called from `NodeAttributes` methods that modify the attributes."
msgstr ""

#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node._check_mutability_attributes:5
#: ../../../src/aiida/orm/utils/mixins.py:docstring of aiida.orm.utils.mixins.Sealable._check_mutability_attributes:5
msgid "the keys that will be mutated, or all if None"
msgstr ""

#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node._store:1
#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node.store:1
msgid "Store the node in the database while saving its attributes and repository directory."
msgstr ""

#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node._store_from_cache:1
msgid "Store this node from an existing cache node."
msgstr ""

#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node._store_from_cache:5
msgid "With the current implementation of the backend repository, which automatically deduplicates the content that it contains, we do not have to copy the contents of the source node. Since the content should be exactly equal, the repository will already contain it and there is nothing to copy. We simply replace the current ``repository`` instance with a clone of that of the source node, which does not actually copy any files."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code._validate:1
#: ../../../src/aiida/orm/nodes/data/remote/base.py:docstring of aiida.orm.nodes.data.remote.base.RemoteData._validate:1
#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node._validate:1
msgid "Validate information stored in Node object."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code._validate:3
#: ../../../src/aiida/orm/nodes/data/remote/base.py:docstring of aiida.orm.nodes.data.remote.base.RemoteData._validate:3
#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node._validate:3
msgid "For the :py:class:`~aiida.orm.Node` base class, this check is always valid. Subclasses can override this method to perform additional checks and should usually call ``super()._validate()`` first!"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code._validate:7
#: ../../../src/aiida/orm/nodes/data/remote/base.py:docstring of aiida.orm.nodes.data.remote.base.RemoteData._validate:7
#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node._validate:7
msgid "This method is called automatically before storing the node in the DB. Therefore, use :py:meth:`~aiida.orm.nodes.attributes.NodeAttributes.get()` and similar methods that automatically read either from the DB or from the internal attribute cache."
msgstr ""

#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node._validate_storability:1
msgid "Verify that the current node is allowed to be stored."
msgstr ""

#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node._validate_storability:3
msgid "if the node does not match all requirements for storing"
msgstr ""

#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node._verify_are_parents_stored:1
msgid "Verify that all `parent` nodes are already stored."
msgstr ""

#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node._verify_are_parents_stored:3
msgid "if one of the source nodes of incoming links is not stored."
msgstr ""

#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node.base:1
msgid "Return the node base namespace."
msgstr ""

#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node.get_description:1
msgid "Return a string with a description of the node."
msgstr ""

#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node.get_description:3
msgid "a description string"
msgstr ""

#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node.logger:1
msgid "Return the logger configured for this Node."
msgstr ""

#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node.logger:3
msgid "Logger object"
msgstr ""

#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node.store:3
msgid "After being called attributes cannot be changed anymore! Instead, extras can be changed only AFTER calling this store() function."
msgstr ""

#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node.store:6
msgid "After successful storage, those links that are in the cache, and for which also the parent node is already stored, will be automatically stored. The others will remain unstored."
msgstr ""

#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node.store_all:1
msgid "Store the node, together with all input links."
msgstr ""

#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.Node.store_all:3
msgid "Unstored nodes from cached incoming linkswill also be stored."
msgstr ""

#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.NodeBase:1
msgid "A namespace for node related functionality, that is not directly related to its user-facing properties."
msgstr ""

#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.NodeBase.attributes:1
msgid "Return an interface to interact with the attributes of this node."
msgstr ""

#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.NodeBase.caching:1
msgid "Return an interface to interact with the caching of this node."
msgstr ""

#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.NodeBase.comments:1
msgid "Return an interface to interact with the comments of this node."
msgstr ""

#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.NodeBase.extras:1
msgid "Return an interface to interact with the extras of this node."
msgstr ""

#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.NodeBase.links:1
msgid "Return an interface to interact with the links of this node."
msgstr ""

#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.NodeBase.repository:1
msgid "Return the repository for this node."
msgstr ""

#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.NodeCollection:1
msgid "Bases: :py:class:`~aiida.orm.entities.Collection`\\ [:py:obj:`~aiida.orm.nodes.node.NodeType`], :py:class:`~typing.Generic`\\ [:py:obj:`~aiida.orm.nodes.node.NodeType`]"
msgstr ""

#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.NodeCollection:1
msgid "The collection of nodes."
msgstr ""

#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.NodeCollection.delete:1
msgid "Delete a `Node` from the collection with the given id"
msgstr ""

#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.NodeCollection.delete:3
msgid "the node id"
msgstr ""

#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.NodeCollection.iter_repo_keys:1
msgid "Iterate over all repository object keys for this ``Node`` class"
msgstr ""

#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.NodeCollection.iter_repo_keys:3
msgid "keys will not be deduplicated, wrap in a ``set`` to achieve this"
msgstr ""

#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.NodeCollection.iter_repo_keys:5
msgid "Filters for the node query"
msgstr ""

#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.NodeCollection.iter_repo_keys:6
msgid "Whether to include subclasses of the given class"
msgstr ""

#: ../../../src/aiida/orm/nodes/node.py:docstring of aiida.orm.nodes.node.NodeCollection.iter_repo_keys:7
msgid "The number of nodes to fetch data for at once"
msgstr ""

#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository:3
msgid "This is the compatibility layer between the `Node` class and the `Repository` class. The repository in principle has no concept of immutability, so it is implemented here. Any mutating operations will raise a `ModificationNotAllowed` exception if the node is stored. Otherwise the operation is just forwarded to the repository instance."
msgstr ""

#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository:7
msgid "The repository instance keeps an internal mapping of the file hierarchy that it maintains, starting from an empty hierarchy if the instance was constructed normally, or from a specific hierarchy if reconstructed through the ``Repository.from_serialized`` classmethod. This is only the case for stored nodes, because unstored nodes do not have any files yet when they are constructed. Once the node get's stored, the repository is asked to serialize its metadata contents which is then stored in the ``repository_metadata`` field of the backend node. This layer explicitly does not update the metadata of the node on a mutation action. The reason is that for stored nodes these actions are anyway forbidden and for unstored nodes, the final metadata will be stored in one go, once the node is stored, so there is no need to keep updating the node metadata intermediately. Note that this does mean that ``repository_metadata`` does not give accurate information, as long as the node is not yet stored."
msgstr ""

#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.__init__:1
msgid "Construct a new instance of the repository interface."
msgstr ""

#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository._check_mutability:1
msgid "Check if the node is mutable."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.delete_object:8
#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.erase:3
#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.put_object_from_file:6
#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.put_object_from_filelike:6
#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.put_object_from_tree:6
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository._check_mutability:3
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.delete_object:8
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.erase:3
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.put_object_from_file:6
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.put_object_from_filelike:6
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.put_object_from_tree:6
msgid "when the node is stored and therefore immutable."
msgstr ""

#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository._clone:1
msgid "Clone the repository from another instance."
msgstr ""

#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository._clone:3
msgid "This is used when cloning a node."
msgstr ""

#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository._clone:5
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository._copy:5
msgid "the repository to clone."
msgstr ""

#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository._copy:1
msgid "Copy a repository from another instance."
msgstr ""

#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository._copy:3
msgid "This is used when storing cached nodes."
msgstr ""

#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository._repository:1
msgid "Return the repository instance, lazily constructing it if necessary."
msgstr ""

#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository._repository:3
msgid "this property is protected because a node's repository should not be accessed outside of its scope."
msgstr ""

#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository._repository:5
msgid "the file repository instance."
msgstr ""

#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository._store:1
msgid "Store the repository in the backend."
msgstr ""

#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository._update_repository_metadata:1
msgid "Refresh the repository metadata of the node if it is stored."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.as_path:1
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.as_path:1
msgid "Make the contents of the repository available as a normal filepath on the local file system."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.as_path:3
#: ../../../src/aiida/orm/nodes/data/singlefile.py:docstring of aiida.orm.nodes.data.singlefile.SinglefileData.as_path:3
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.as_path:3
msgid "optional relative path of the object within the repository."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.as_path:4
#: ../../../src/aiida/orm/nodes/data/singlefile.py:docstring of aiida.orm.nodes.data.singlefile.SinglefileData.as_path:4
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.as_path:4
msgid "the filepath of the content of the repository or object if ``path`` is specified."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.as_path:5
#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.get_object:5
#: ../../../src/aiida/orm/nodes/data/singlefile.py:docstring of aiida.orm.nodes.data.singlefile.SinglefileData.as_path:5
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.as_path:5
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.get_object:5
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.create_directory:5
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.delete_object:8
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.get_directory:5
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.get_file:5
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.get_object:5
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.get_object_content:4
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.has_object:5
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.list_object_names:5
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.list_objects:5
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.open:8
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.put_object_from_filelike:5
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.put_object_from_tree:6
msgid "if the path is not a string or ``Path``, or is an absolute path."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.as_path:6
#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.get_object:6
#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.list_object_names:6
#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.list_objects:6
#: ../../../src/aiida/orm/nodes/data/singlefile.py:docstring of aiida.orm.nodes.data.singlefile.SinglefileData.as_path:6
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.as_path:6
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.get_object:6
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.list_object_names:6
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.list_objects:6
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.get_directory:6
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.get_file:6
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.get_object:6
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.list_object_names:6
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.list_objects:6
msgid "if no object exists for the given path."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.copy_tree:1
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.copy_tree:1
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.copy_tree:1
msgid "Copy the contents of the entire node repository to another location on the local file system."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.copy_tree:3
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.copy_tree:3
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.copy_tree:7
msgid "absolute path of the directory where to copy the contents to."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.copy_tree:4
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.copy_tree:4
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.copy_tree:8
msgid "optional relative path whose contents to copy."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.delete_object:1
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.delete_object:1
#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.delete_object:1
msgid "Delete the object from the repository."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.delete_object:3
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.delete_object:3
#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.delete_object:3
#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.get_object_content:3
#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.get_object_hash:7
#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.has_object:3
#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.open:6
#: ../../../src/aiida/repository/backend/disk_object_store.py:docstring of aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend.get_object_hash:7
#: ../../../src/aiida/repository/backend/disk_object_store.py:docstring of aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend.open:6
#: ../../../src/aiida/repository/backend/sandbox.py:docstring of aiida.repository.backend.sandbox.SandboxRepositoryBackend.open:6
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository._insert_file:6
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SandboxShaRepositoryBackend.get_object_hash:7
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.FolderBackendRepository.has_object:3
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.FolderBackendRepository.open:6
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.ZipfileBackendRepository.has_object:3
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.ZipfileBackendRepository.open:6
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend._RoBackendRepository.get_object_hash:7
#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveWriterAbstract.delete_object:3
#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/writer.py:docstring of aiida.tools.archive.implementations.sqlite_zip.writer.ArchiveAppenderSqlZip.delete_object:3
#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/writer.py:docstring of aiida.tools.archive.implementations.sqlite_zip.writer.ArchiveWriterSqlZip.delete_object:3
msgid "fully qualified identifier for the object within the repository."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.delete_object:4
#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.get_object_content:4
#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.list_object_names:5
#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.list_objects:5
#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.open:8
#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.put_object_from_bytes:5
#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.put_object_from_filelike:5
#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.put_object_from_tree:5
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.delete_object:4
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.get_object_content:4
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.list_object_names:5
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.list_objects:5
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.open:8
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.put_object_from_bytes:5
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.put_object_from_filelike:5
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.put_object_from_tree:5
msgid "if the path is not a string and relative path."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.delete_object:5
#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.get_object_content:5
#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.open:9
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.delete_object:5
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.get_object_content:5
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.open:9
#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.delete_object:4
#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.get_object_content:4
#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.get_object_hash:8
#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.iter_object_streams:7
#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.open:8
#: ../../../src/aiida/repository/backend/disk_object_store.py:docstring of aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend.get_object_hash:8
#: ../../../src/aiida/repository/backend/disk_object_store.py:docstring of aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend.iter_object_streams:7
#: ../../../src/aiida/repository/backend/disk_object_store.py:docstring of aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend.open:8
#: ../../../src/aiida/repository/backend/sandbox.py:docstring of aiida.repository.backend.sandbox.SandboxRepositoryBackend.iter_object_streams:7
#: ../../../src/aiida/repository/backend/sandbox.py:docstring of aiida.repository.backend.sandbox.SandboxRepositoryBackend.open:8
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.delete_object:9
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.get_object_content:5
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.open:9
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.NoopRepositoryBackend.iter_object_streams:7
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SandboxShaRepositoryBackend.get_object_hash:8
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.FolderBackendRepository.open:8
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.ZipfileBackendRepository.open:8
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend._RoBackendRepository.get_object_hash:8
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend._RoBackendRepository.iter_object_streams:7
msgid "if the file does not exist."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.delete_object:6
#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.get_object_content:6
#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.open:10
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.delete_object:6
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.get_object_content:6
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.open:10
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.delete_object:10
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.get_object_content:6
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.open:10
msgid "if the object is a directory and not a file."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.delete_object:7
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.delete_object:7
#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.delete_object:5
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.delete_object:11
#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveWriterAbstract.delete_object:4
#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/writer.py:docstring of aiida.tools.archive.implementations.sqlite_zip.writer.ArchiveAppenderSqlZip.delete_object:4
#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/writer.py:docstring of aiida.tools.archive.implementations.sqlite_zip.writer.ArchiveWriterSqlZip.delete_object:4
msgid "if the file could not be deleted."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.erase:1
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.erase:1
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.erase:1
msgid "Delete all objects from the repository."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.get_object:1
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.get_object:1
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.get_object:1
msgid "Return the object at the given path."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.get_object:3
#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.get_object_content:3
#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.open:6
#: ../../../src/aiida/orm/nodes/data/singlefile.py:docstring of aiida.orm.nodes.data.singlefile.SinglefileData.open:3
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.get_object:3
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.get_object_content:3
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.open:6
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.delete_object:5
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.get_object_content:3
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.has_object:3
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.open:6
msgid "the relative path of the object within the repository."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.get_object:4
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.get_object:4
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.get_directory:4
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.get_file:4
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.get_object:4
msgid "the `File` representing the object located at the given relative path."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.get_object_content:1
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.get_object_content:1
#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.get_object_content:1
msgid "Return the content of a object identified by key."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.get_object_content:7
#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.open:11
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.get_object_content:7
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.open:11
#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.get_object_content:5
#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.get_object_hash:9
#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.open:9
#: ../../../src/aiida/repository/backend/disk_object_store.py:docstring of aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend.open:9
#: ../../../src/aiida/repository/backend/sandbox.py:docstring of aiida.repository.backend.sandbox.SandboxRepositoryBackend.open:9
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.get_object_content:7
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.open:11
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SandboxShaRepositoryBackend.get_object_hash:9
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.FolderBackendRepository.open:9
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.ZipfileBackendRepository.open:9
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend._RoBackendRepository.get_object_hash:9
msgid "if the file could not be opened."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.glob:1
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.glob:1
msgid "Yield a recursive list of all paths (files and directories)."
msgstr ""

#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.hash:1
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.hash:1
msgid "Generate a hash of the repository's contents."
msgstr ""

#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.hash:3
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.hash:5
msgid "the hash representing the contents of the repository."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.list_object_names:1
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.list_object_names:1
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.list_object_names:1
msgid "Return a sorted list of the object names contained in this repository, optionally in the given sub directory."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.list_object_names:3
#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.list_objects:3
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.list_object_names:3
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.list_objects:3
msgid "optional relative path inside the repository whose objects to list."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.list_object_names:4
#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.list_objects:4
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.list_object_names:4
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.list_objects:4
msgid "a list of `File` named tuples representing the objects present in directory with the given key."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.list_object_names:7
#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.list_objects:7
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.list_object_names:7
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.list_objects:7
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.get_directory:7
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.get_file:7
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.list_object_names:7
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.list_objects:7
msgid "if the object at the given path is not a directory."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.list_objects:1
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.list_objects:1
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.list_objects:1
msgid "Return a list of the objects contained in this repository sorted by name, optionally in given sub directory."
msgstr ""

#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.metadata:1
msgid "Return the repository metadata, representing the virtual file hierarchy."
msgstr ""

#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.metadata:3
msgid "Note, this is only accurate if the node is stored."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.open:1
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.open:1
#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.open:1
#: ../../../src/aiida/repository/backend/disk_object_store.py:docstring of aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend.open:1
#: ../../../src/aiida/repository/backend/sandbox.py:docstring of aiida.repository.backend.sandbox.SandboxRepositoryBackend.open:1
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.FolderBackendRepository.open:1
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.ZipfileBackendRepository.open:1
msgid "Open a file handle to an object stored under the given key."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.open:3
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.open:3
#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.open:3
#: ../../../src/aiida/repository/backend/disk_object_store.py:docstring of aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend.open:3
#: ../../../src/aiida/repository/backend/sandbox.py:docstring of aiida.repository.backend.sandbox.SandboxRepositoryBackend.open:3
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.open:3
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.FolderBackendRepository.open:3
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.ZipfileBackendRepository.open:3
msgid "this should only be used to open a handle to read an existing file. To write a new file use the method ``put_object_from_filelike`` instead."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.open:7
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.open:7
#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.open:7
#: ../../../src/aiida/repository/backend/disk_object_store.py:docstring of aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend.open:7
#: ../../../src/aiida/repository/backend/sandbox.py:docstring of aiida.repository.backend.sandbox.SandboxRepositoryBackend.open:7
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.open:7
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.FolderBackendRepository.open:7
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.ZipfileBackendRepository.open:7
msgid "yield a byte stream object."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.put_object_from_bytes:1
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.put_object_from_bytes:1
msgid "Store the given content in the repository at the given path."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.put_object_from_bytes:3
#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.put_object_from_file:4
#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.put_object_from_filelike:4
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.put_object_from_bytes:3
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.put_object_from_file:4
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.put_object_from_filelike:4
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository._insert_file:5
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.get_object:3
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.put_object_from_file:4
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.put_object_from_filelike:4
msgid "the relative path where to store the object in the repository."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.put_object_from_bytes:4
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.put_object_from_bytes:4
msgid "the content to store."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.put_object_from_bytes:6
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.put_object_from_bytes:6
msgid "if an object already exists at the given path."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.put_object_from_file:1
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.put_object_from_file:1
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.put_object_from_file:1
msgid "Store a new object under `path` with contents of the file located at `filepath` on the local file system."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.put_object_from_file:3
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.put_object_from_file:3
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.put_object_from_file:3
msgid "absolute path of file whose contents to copy to the repository"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.put_object_from_file:5
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.put_object_from_file:5
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.put_object_from_file:5
msgid "if the path is not a string and relative path, or the handle is not a byte stream."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.put_object_from_filelike:1
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.put_object_from_filelike:1
#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.put_object_from_filelike:1
#: ../../../src/aiida/repository/backend/disk_object_store.py:docstring of aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend._put_object_from_filelike:1
#: ../../../src/aiida/repository/backend/sandbox.py:docstring of aiida.repository.backend.sandbox.SandboxRepositoryBackend._put_object_from_filelike:1
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.put_object_from_filelike:1
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SandboxShaRepositoryBackend._put_object_from_filelike:1
msgid "Store the byte contents of a file in the repository."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.put_object_from_filelike:3
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.put_object_from_filelike:3
#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.put_object_from_filelike:3
#: ../../../src/aiida/repository/backend/disk_object_store.py:docstring of aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend._put_object_from_filelike:3
#: ../../../src/aiida/repository/backend/sandbox.py:docstring of aiida.repository.backend.sandbox.SandboxRepositoryBackend._put_object_from_filelike:3
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.put_object_from_filelike:3
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SandboxShaRepositoryBackend._put_object_from_filelike:3
msgid "filelike object with the byte content to be stored."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.put_object_from_tree:1
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.put_object_from_tree:1
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.put_object_from_tree:1
msgid "Store the entire contents of `filepath` on the local file system in the repository with under given `path`."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.put_object_from_tree:3
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.put_object_from_tree:3
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.put_object_from_tree:3
msgid "absolute path of the directory whose contents to copy to the repository."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.put_object_from_tree:4
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.put_object_from_tree:4
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.put_object_from_tree:4
msgid "the relative path where to store the objects in the repository."
msgstr ""

#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.serialize:1
msgid "Serialize the metadata of the repository content into a JSON-serializable format."
msgstr ""

#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.serialize:3
#: ../../../src/aiida/repository/common.py:docstring of aiida.repository.common.File.serialize:5
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.serialize:3
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.serialize_repository:5
msgid "dictionary with the content metadata."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.walk:1
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.walk:1
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.walk:1
msgid "Walk over the directories and files contained within this repository."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.walk:3
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.walk:3
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.walk:3
msgid "the order of the dirname and filename lists that are returned is not necessarily sorted. This is in line with the ``os.walk`` implementation where the order depends on the underlying file system used."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.walk:6
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.walk:6
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.walk:6
msgid "the relative path of the directory within the repository whose contents to walk."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.walk:7
#: ../../../src/aiida/orm/nodes/repository.py:docstring of aiida.orm.nodes.repository.NodeRepository.walk:7
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.walk:7
msgid "tuples of root, dirnames and filenames just like ``os.walk``, with the exception that the root path is always relative with respect to the repository root, instead of an absolute path and it is an instance of ``pathlib.PurePosixPath`` instead of a normal string"
msgstr ""

#: ../../source/reference/apidoc/aiida.orm.nodes.data.rst:2
msgid "aiida.orm.nodes.data package"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/__init__.py:docstring of aiida.orm.nodes.data:1
msgid "Module with `Node` sub classes for data structures."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/base.py:docstring of aiida.orm.nodes.data.base:1
#: ../../../src/aiida/orm/nodes/data/base.py:docstring of aiida.orm.nodes.data.base.BaseType:1
msgid "`Data` sub class to be used as a base for data containers that represent base python data types."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/array.py:docstring of aiida.orm.nodes.data.array.array.ArrayData:1
#: ../../../src/aiida/orm/nodes/data/base.py:docstring of aiida.orm.nodes.data.base.BaseType:1
#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode:1
#: ../../../src/aiida/orm/nodes/data/dict.py:docstring of aiida.orm.nodes.data.dict.Dict:1
#: ../../../src/aiida/orm/nodes/data/enum.py:docstring of aiida.orm.nodes.data.enum.EnumData:1
#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData:1
#: ../../../src/aiida/orm/nodes/data/jsonable.py:docstring of aiida.orm.nodes.data.jsonable.JsonableData:1
#: ../../../src/aiida/orm/nodes/data/orbital.py:docstring of aiida.orm.nodes.data.orbital.OrbitalData:1
#: ../../../src/aiida/orm/nodes/data/remote/base.py:docstring of aiida.orm.nodes.data.remote.base.RemoteData:1
#: ../../../src/aiida/orm/nodes/data/remote/stash/base.py:docstring of aiida.orm.nodes.data.remote.stash.base.RemoteStashData:1
#: ../../../src/aiida/orm/nodes/data/singlefile.py:docstring of aiida.orm.nodes.data.singlefile.SinglefileData:1
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData:1
msgid "Bases: :py:class:`~aiida.orm.nodes.data.data.Data`"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/base.py:docstring of aiida.orm.nodes.data.base.BaseType.__init__:1
#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.orm.nodes.data.data.Data.__init__:1
#: ../../../src/aiida/orm/nodes/data/remote/base.py:docstring of aiida.orm.nodes.data.remote.base.RemoteData.__init__:1
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.__init__:1
msgid "Construct a new instance, setting the ``source`` attribute if provided as a keyword argument."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/base.py:docstring of aiida.orm.nodes.data.base.to_aiida_type:1
msgid "Turns basic Python types (str, int, float, bool) into the corresponding AiiDA types."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/bool.py:docstring of aiida.orm.nodes.data.bool:1
#: ../../../src/aiida/orm/nodes/data/bool.py:docstring of aiida.orm.nodes.data.bool.Bool:1
msgid "`Data` sub class to represent a boolean value."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/bool.py:docstring of aiida.orm.nodes.data.bool.Bool:1
#: ../../../src/aiida/orm/nodes/data/numeric.py:docstring of aiida.orm.nodes.data.numeric.NumericType:1
#: ../../../src/aiida/orm/nodes/data/str.py:docstring of aiida.orm.nodes.data.str.Str:1
msgid "Bases: :py:class:`~aiida.orm.nodes.data.base.BaseType`"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/bool.py:docstring of aiida.orm.nodes.data.bool.get_false_node:1
msgid "Return a `Bool` node with value `False`"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/bool.py:docstring of aiida.orm.nodes.data.bool.get_false_node:3
#: ../../../src/aiida/orm/nodes/data/bool.py:docstring of aiida.orm.nodes.data.bool.get_true_node:3
msgid "this function serves as a substitute for defining the node as a module singleton, because that would be instantiated at import time, at which time not all required database resources may be defined."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/bool.py:docstring of aiida.orm.nodes.data.bool.get_false_node:6
msgid "a `Bool` instance with the value `False`"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/bool.py:docstring of aiida.orm.nodes.data.bool.get_true_node:1
msgid "Return a `Bool` node with value `True`"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/bool.py:docstring of aiida.orm.nodes.data.bool.get_true_node:6
msgid "a `Bool` instance with the value `True`"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif:1
msgid "Tools for handling Crystallographic Information Files (CIF)"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData:1
#: ../../../src/aiida/orm/nodes/data/upf.py:docstring of aiida.orm.nodes.data.upf.UpfData:1
msgid "Bases: :py:class:`~aiida.orm.nodes.data.singlefile.SinglefileData`"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData:1
msgid "Wrapper for Crystallographic Interchange File (CIF)"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData:3
msgid "the file (physical) is held as the authoritative source of information, so all conversions are done through the physical file: when setting ``ase`` or ``values``, a physical CIF file is generated first, the values are updated from the physical CIF file."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.__init__:1
#: ../../../src/aiida/orm/nodes/data/singlefile.py:docstring of aiida.orm.nodes.data.singlefile.SinglefileData.__init__:1
#: ../../../src/aiida/orm/nodes/data/upf.py:docstring of aiida.orm.nodes.data.upf.UpfData.__init__:1
msgid "Construct a new instance and set the contents to that of the file."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.__init__:3
msgid "an absolute filepath or filelike object for CIF. Hint: Pass io.BytesIO(b\"my string\") to construct the SinglefileData directly from a string."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.__init__:5
#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.set_file:8
#: ../../../src/aiida/orm/nodes/data/singlefile.py:docstring of aiida.orm.nodes.data.singlefile.SinglefileData.__init__:5
#: ../../../src/aiida/orm/nodes/data/singlefile.py:docstring of aiida.orm.nodes.data.singlefile.SinglefileData.set_file:5
#: ../../../src/aiida/orm/nodes/data/upf.py:docstring of aiida.orm.nodes.data.upf.UpfData.__init__:5
#: ../../../src/aiida/orm/nodes/data/upf.py:docstring of aiida.orm.nodes.data.upf.UpfData.set_file:5
msgid "specify filename to use (defaults to name of provided file)."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.__init__:6
msgid "ASE Atoms object to construct the CifData instance from."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.__init__:7
msgid "PyCifRW CifFile object to construct the CifData instance from."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.__init__:8
msgid "scan type string for parsing with PyCIFRW ('standard' or 'flex'). See CifFile.ReadCif"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.__init__:9
msgid "'eager' (parse CIF file on set_file) or 'lazy' (defer parsing until needed)"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData._get_object_ase:1
msgid "Converts CifData to ase.Atoms"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData._get_object_ase:3
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData._get_object_ase:5
msgid "an ase.Atoms object"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData._get_object_pycifrw:1
msgid "Converts CifData to PyCIFRW.CifFile"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData._get_object_pycifrw:3
msgid "a PyCIFRW.CifFile object"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData._prepare_cif:1
msgid "Return CIF string of CifData object."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData._prepare_cif:3
msgid "If parsed values are present, a CIF string is created and written to file. If no parsed values are present, the CIF string is read from file."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData._validate:1
msgid "Validates MD5 hash of CIF file."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.ase:1
#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.restapi.translator.nodes.data.cif.CifDataTranslator.CifData.ase:1
msgid "ASE object, representing the CIF."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.ase:3
#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.get_ase:5
#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.restapi.translator.nodes.data.cif.CifDataTranslator.CifData.ase:3
#: ../../../src/aiida/tools/data/cif.py:docstring of aiida.tools.data.cif._get_aiida_structure_ase_inline:4
#: ../../../src/aiida/tools/data/structure.py:docstring of aiida.tools.data.structure._get_cif_ase_inline:3
msgid "requires ASE module."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.from_md5:1
msgid "Return a list of all CIF files that match a given MD5 hash."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.from_md5:3
msgid "the hash has to be stored in a ``_md5`` attribute, otherwise the CIF file will not be found."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.generate_md5:1
msgid "Computes and returns MD5 hash of the CIF file."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.get_ase:1
msgid "Returns ASE object, representing the CIF. This function differs from the property ``ase`` by the possibility to pass the keyworded arguments (kwargs) to ase.io.cif.read_cif()."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.get_formulae:1
msgid "Return chemical formulae specified in CIF file."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.get_formulae:3
msgid "Note: This does not compute the formula, it only reads it from the appropriate tag. Use refine_inline to compute formulae."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.get_or_create:1
msgid "Pass the same parameter of the init; if a file with the same md5 is found, that CifData is returned."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.get_or_create:4
msgid "an absolute filename on disk"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.get_or_create:5
msgid "if False (default), raise an exception if more than                 one CIF file is found.                If it is True, instead, use the first available CIF file."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.get_or_create:6
msgid "If false, the CifData objects are not stored in the database. default=True."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.get_or_create:0
msgid "return (cif, created)"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.get_or_create:8
msgid "where cif is the CifData object, and create is either            True if the object was created, or False if the object was retrieved            from the DB."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.get_spacegroup_numbers:1
msgid "Get the spacegroup international number."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.get_structure:1
#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.get_structure:1
msgid "Creates :py:class:`aiida.orm.nodes.data.structure.StructureData`."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.get_structure:3
#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.get_structure:3
msgid "Renamed from _get_aiida_structure"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.get_structure:6
msgid "specify the converter. Default 'pymatgen'."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.get_structure:7
msgid "if True, intermediate calculation gets stored in the AiiDA database for record. Default False."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.get_structure:9
msgid "if True, primitive cell is returned, conventional cell if False. Default False."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.get_structure:11
msgid "If total occupancy of a site is between 1 and occupancy_tolerance, the occupancies will be scaled down to 1. (pymatgen only)"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.get_structure:13
msgid "This tolerance is used to determine if two sites are sitting in the same position, in which case they will be combined to a single disordered site. Defaults to 1e-4. (pymatgen only)"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.get_step_structure:22
#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.get_structure:23
#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.get_structure:15
msgid ":py:class:`aiida.orm.nodes.data.structure.StructureData` node."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.has_atomic_sites:1
#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.restapi.translator.nodes.data.cif.CifDataTranslator.CifData.has_atomic_sites:1
msgid "Returns whether there are any atomic sites defined in the cif data. That is to say, it will check all the values for the `_atom_site_fract_*` tags and if they are all equal to `?` that means there are no relevant atomic sites defined and the function will return False. In all other cases the function will return True"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.has_atomic_sites:7
#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.restapi.translator.nodes.data.cif.CifDataTranslator.CifData.has_atomic_sites:7
msgid "False when at least one atomic site fractional coordinate is not equal to `?` and True otherwise"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.has_attached_hydrogens:1
#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.restapi.translator.nodes.data.cif.CifDataTranslator.CifData.has_attached_hydrogens:1
msgid "Check if there are hydrogens without coordinates, specified as attached to the atoms of the structure."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.has_attached_hydrogens:4
#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.restapi.translator.nodes.data.cif.CifDataTranslator.CifData.has_attached_hydrogens:4
msgid "True if there are attached hydrogens, False otherwise."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.has_partial_occupancies:1
#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.restapi.translator.nodes.data.cif.CifDataTranslator.CifData.has_partial_occupancies:1
msgid "Return if the cif data contains partial occupancies"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.has_partial_occupancies:3
#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.restapi.translator.nodes.data.cif.CifDataTranslator.CifData.has_partial_occupancies:3
msgid "A partial occupancy is defined as site with an occupancy that differs from unity, within a precision of 1E-6"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.has_partial_occupancies:7
#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.restapi.translator.nodes.data.cif.CifDataTranslator.CifData.has_partial_occupancies:7
msgid "True if there are partial occupancies, False otherwise"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.has_undefined_atomic_sites:1
#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.restapi.translator.nodes.data.cif.CifDataTranslator.CifData.has_undefined_atomic_sites:1
msgid "Return whether the cif data contains any undefined atomic sites."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.has_undefined_atomic_sites:3
#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.restapi.translator.nodes.data.cif.CifDataTranslator.CifData.has_undefined_atomic_sites:3
msgid "An undefined atomic site is defined as a site where at least one of the fractional coordinates specified in the `_atom_site_fract_*` tags, cannot be successfully interpreted as a float. If the cif data contains any site that matches this description, or it does not contain any atomic site tags at all, the cif data is said to have undefined atomic sites."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.has_undefined_atomic_sites:8
#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.restapi.translator.nodes.data.cif.CifDataTranslator.CifData.has_undefined_atomic_sites:8
msgid "boolean, True if no atomic sites are defined or if any of the defined sites contain undefined positions and False otherwise"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.has_unknown_species:1
#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.restapi.translator.nodes.data.cif.CifDataTranslator.CifData.has_unknown_species:1
msgid "Returns whether the cif contains atomic species that are not recognized by AiiDA."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.has_unknown_species:3
#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.restapi.translator.nodes.data.cif.CifDataTranslator.CifData.has_unknown_species:3
msgid "The known species are taken from the elements dictionary in `aiida.common.constants`, with the exception of the \"unknown\" placeholder element with symbol 'X', as this could not be used to construct a real structure. If any of the formula of the cif data contain species that are not in that elements dictionary, the function will return True and False in all other cases. If there is no formulae to be found, it will return None"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.has_unknown_species:8
#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.restapi.translator.nodes.data.cif.CifDataTranslator.CifData.has_unknown_species:8
msgid "True when there are unknown species in any of the formulae, False if not, None if no formula found"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.parse:1
msgid "Parses CIF file and sets attributes."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.parse:3
msgid "See set_scan_type"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.read_cif:1
msgid "A wrapper method that simulates the behavior of the old function ase.io.cif.read_cif by using the new generic ase.io.read function."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.read_cif:5
msgid "Somewhere from 3.12 to 3.17 the tag concept was bundled with each Atom object. When reading a CIF file, this is incremented and signifies the atomic species, even though the CIF file do not have specific tags embedded. On reading CIF files we thus force the ASE tag to zero for all Atom elements."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.set_ase:1
msgid "Set the contents of the CifData starting from an ASE atoms object"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.set_ase:3
msgid "the ASE atoms object"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.set_file:1
msgid "Set the file."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.set_file:3
msgid "If the source is set and the MD5 checksum of new file is different from the source, the source has to be deleted."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.set_file:6
msgid "filepath or filelike object of the CIF file to store. Hint: Pass io.BytesIO(b\"my string\") to construct the file directly from a string."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.set_parse_policy:1
msgid "Set the parse policy."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.set_parse_policy:3
msgid "Either 'eager' (parse CIF file on set_file) or 'lazy' (defer parsing until needed)"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.set_scan_type:1
msgid "Set the scan_type for PyCifRW."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.set_scan_type:3
msgid "The 'flex' scan_type of PyCifRW is faster for large CIF files but does not yet support the CIF2 format as of 02/2018. See the CifFile.ReadCif function"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.set_scan_type:7
msgid "Either 'standard' or 'flex' (see _scan_types)"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.set_values:1
msgid "Set internal representation to `values`."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.set_values:3
msgid "Warning: This also writes a new CIF file."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.set_values:5
msgid "PyCifRW CifFile object"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.set_values:7
#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.values:3
#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.restapi.translator.nodes.data.cif.CifDataTranslator.CifData.values:3
msgid "requires PyCifRW module."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.store:1
msgid "Store the node."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.CifData.values:1
#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.restapi.translator.nodes.data.cif.CifDataTranslator.CifData.values:1
msgid "PyCifRW structure, representing the CIF datablocks."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.cif_from_ase:1
msgid "Construct a CIF datablock from the ASE structure. The code is taken from https://wiki.fysik.dtu.dk/ase/ase/io/formatoptions.html#ase.io.cif.write_cif, as the original ASE code contains a bug in printing the Hermann-Mauguin symmetry space group symbol."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.cif_from_ase:7
msgid "ASE \"images\""
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.cif_from_ase:8
msgid "array of CIF datablocks"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.has_pycifrw:1
msgid "True if the PyCifRW module can be imported, False otherwise."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.parse_formula:1
msgid "Parses the Hill formulae. Does not need spaces as separators. Works also for partial occupancies and for chemical groups enclosed in round/square/curly brackets. Elements are counted and a dictionary is returned. e.g.  'C[NH2]3NO3'  -->  {'C': 1, 'N': 4, 'H': 6, 'O': 3}"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.pycifrw_from_cif:1
msgid "Constructs PyCifRW's CifFile from an array of CIF datablocks."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.pycifrw_from_cif:3
msgid "an array of CIF datablocks"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.pycifrw_from_cif:4
msgid "optional dict of lists of CIF tag loops."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.pycifrw_from_cif:5
msgid "optional list of datablock names"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/cif.py:docstring of aiida.orm.nodes.data.cif.pycifrw_from_cif:6
msgid "CifFile"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.orm.nodes.data.data:1
msgid "Module with `Node` sub class `Data` to be used as a base class for data structures."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.orm.nodes.data.data.Data:1
msgid "Bases: :py:class:`~aiida.orm.nodes.node.Node`"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.orm.nodes.data.data.Data:1
msgid "The base class for all Data nodes."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.orm.nodes.data.data.Data:3
msgid "AiiDA Data classes are subclasses of Node and must support multiple inheritance."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.orm.nodes.data.data.Data:5
msgid "Architecture note: Calculation plugins are responsible for converting raw output data from simulation codes to Data nodes. Nodes are responsible for validating their content (see _validate method)."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.orm.nodes.data.data.Data.__copy__:1
msgid "Copying a Data node is not supported, use copy.deepcopy or call Data.clone()."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.orm.nodes.data.data.Data.__deepcopy__:1
msgid "Create a clone of the Data node by piping through to the clone method and return the result."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.orm.nodes.data.data.Data.__deepcopy__:3
#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.orm.nodes.data.data.Data.clone:3
msgid "an unstored clone of this Data node"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.orm.nodes.data.data.Data._exportcontent:1
msgid "Converts a Data node to one (or multiple) files."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.orm.nodes.data.data.Data._exportcontent:3
msgid "Note: Export plugins should return utf8-encoded **bytes**, which can be directly dumped to file."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.orm.nodes.data.data.Data._exportcontent:6
msgid "the extension, uniquely specifying the file format."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.orm.nodes.data.data.Data._exportcontent:8
msgid "(empty by default) Can be used by plugin to infer sensible names for additional files, if necessary.  E.g. if the main file is '../myplot.gnu', the plugin may decide to store the dat file under '../myplot_data.dat'."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.orm.nodes.data.data.Data._exportcontent:13
msgid "other parameters are passed down to the plugin"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.orm.nodes.data.data.Data._exportcontent:14
msgid "a tuple of length 2. The first element is the content of the otuput file. The second is a dictionary (possibly empty) in the format {filename: filecontent} for any additional file that should be produced."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.orm.nodes.data.data.Data._get_converters:1
msgid "Get all implemented converter formats. The convention is to find all _get_object_... methods. Returns a list of strings."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.orm.nodes.data.data.Data._get_exporters:1
msgid "Get all implemented export formats. The convention is to find all _prepare_... methods. Returns a dictionary of method_name: method_function"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.orm.nodes.data.data.Data._get_importers:1
msgid "Get all implemented import formats. The convention is to find all _parse_... methods. Returns a list of strings."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.orm.nodes.data.data.Data.clone:1
msgid "Create a clone of the Data node."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.orm.nodes.data.data.Data.convert:1
msgid "Convert the AiiDA StructureData into another python object"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.orm.nodes.data.data.Data.convert:3
msgid "Specify the output format"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.orm.nodes.data.data.Data.creator:1
#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.restapi.translator.nodes.data.DataTranslator.Data.creator:1
msgid "Return the creator of this node or None if it does not exist."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.orm.nodes.data.data.Data.creator:3
#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.restapi.translator.nodes.data.DataTranslator.Data.creator:3
msgid "the creating node or None"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.orm.nodes.data.data.Data.export:1
msgid "Save a Data object to a file."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.orm.nodes.data.data.Data.export:3
#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.orm.nodes.data.data.Data.importfile:3
msgid "string with file name. Can be an absolute or relative path."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.orm.nodes.data.data.Data.export:4
#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.orm.nodes.data.data.Data.importfile:4
msgid "kind of format to use for the export. If not present, it will try to use the extension of the file name."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.orm.nodes.data.data.Data.export:6
msgid "if set to True, overwrites file found at path. Default=False"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.orm.nodes.data.data.Data.export:7
msgid "additional parameters to be passed to the _exportcontent method"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.orm.nodes.data.data.Data.export:9
msgid "the list of files created"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.orm.nodes.data.data.Data.get_export_formats:1
msgid "Get the list of valid export format strings"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.orm.nodes.data.data.Data.get_export_formats:3
msgid "a list of valid formats"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.orm.nodes.data.data.Data.importfile:1
msgid "Populate a Data object from a file."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.orm.nodes.data.data.Data.importstring:1
msgid "Converts a Data object to other text format."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.orm.nodes.data.data.Data.importstring:3
msgid "a string (the extension) to describe the file format."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.orm.nodes.data.data.Data.importstring:4
msgid "a string with the structure description."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.orm.nodes.data.data.Data.set_source:1
msgid "Sets the dictionary describing the source of Data object."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.orm.nodes.data.data.Data.source:1
#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.restapi.translator.nodes.data.DataTranslator.Data.source:1
msgid "Gets the dictionary describing the source of Data object. Possible fields:"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.orm.nodes.data.data.Data.source:3
#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.restapi.translator.nodes.data.DataTranslator.Data.source:3
msgid "**db_name**: name of the source database."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.orm.nodes.data.data.Data.source:4
#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.restapi.translator.nodes.data.DataTranslator.Data.source:4
msgid "**db_uri**: URI of the source database."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.orm.nodes.data.data.Data.source:5
#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.restapi.translator.nodes.data.DataTranslator.Data.source:5
msgid "**uri**: URI of the object's source. Should be a permanent link."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.orm.nodes.data.data.Data.source:6
#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.restapi.translator.nodes.data.DataTranslator.Data.source:6
msgid "**id**: object's source identifier in the source database."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.orm.nodes.data.data.Data.source:7
#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.restapi.translator.nodes.data.DataTranslator.Data.source:7
msgid "**version**: version of the object's source."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.orm.nodes.data.data.Data.source:8
#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.restapi.translator.nodes.data.DataTranslator.Data.source:8
msgid "**extras**: a dictionary with other fields for source description."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.orm.nodes.data.data.Data.source:9
#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.restapi.translator.nodes.data.DataTranslator.Data.source:9
msgid "**source_md5**: MD5 checksum of object's source."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.orm.nodes.data.data.Data.source:10
#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.restapi.translator.nodes.data.DataTranslator.Data.source:10
msgid "**description**: human-readable free form description of the object's source."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.orm.nodes.data.data.Data.source:11
#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.restapi.translator.nodes.data.DataTranslator.Data.source:11
msgid "**license**: a string with a type of license."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.orm.nodes.data.data.Data.source:13
#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.restapi.translator.nodes.data.DataTranslator.Data.source:13
msgid "some limitations for setting the data source exist, see ``_validate`` method."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.orm.nodes.data.data.Data.source:15
#: ../../../src/aiida/orm/nodes/data/data.py:docstring of aiida.restapi.translator.nodes.data.DataTranslator.Data.source:15
msgid "dictionary describing the source of Data object."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/dict.py:docstring of aiida.orm.nodes.data.dict:1
#: ../../../src/aiida/orm/nodes/data/dict.py:docstring of aiida.orm.nodes.data.dict.Dict:1
msgid "`Data` sub class to represent a dictionary."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/dict.py:docstring of aiida.orm.nodes.data.dict.Dict:3
msgid "The dictionary contents of a `Dict` node are stored in the database as attributes. The dictionary can be initialized through the `dict` argument in the constructor. After construction, values can be retrieved and updated through the item getters and setters, respectively:"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/dict.py:docstring of aiida.orm.nodes.data.dict.Dict:7
msgid "node['key'] = 'value'"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/dict.py:docstring of aiida.orm.nodes.data.dict.Dict:9
msgid "Alternatively, the `dict` property returns an instance of the `AttributeManager` that can be used to get and set values through attribute notation:"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/dict.py:docstring of aiida.orm.nodes.data.dict.Dict:12
msgid "node.dict.key = 'value'"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/dict.py:docstring of aiida.orm.nodes.data.dict.Dict:14
msgid "Note that trying to set dictionary values directly on the node, e.g. `node.key = value`, will not work as intended. It will merely set the `key` attribute on the node instance, but will not be stored in the database. As soon as the node goes out of scope, the value will be lost."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/dict.py:docstring of aiida.orm.nodes.data.dict.Dict:18
msgid "It is also relevant to note here the difference in something being an \"attribute of a node\" (in the sense that it is stored in the \"attribute\" column of the database when the node is stored) and something being an \"attribute of a python object\" (in the sense of being able to modify and access it as if it was a property of the variable, e.g. `node.key = value`). This is true of all types of nodes, but it becomes more relevant for `Dict` nodes where one is constantly manipulating these attributes."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/dict.py:docstring of aiida.orm.nodes.data.dict.Dict:25
msgid "Finally, all dictionary mutations will be forbidden once the node is stored."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/dict.py:docstring of aiida.orm.nodes.data.dict.Dict.__contains__:1
msgid "Return whether the node contains a key."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/dict.py:docstring of aiida.orm.nodes.data.dict.Dict.__init__:1
msgid "Initialise a ``Dict`` node instance."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/dict.py:docstring of aiida.orm.nodes.data.dict.Dict.__init__:3
msgid "Usual rules for attribute names apply, in particular, keys cannot start with an underscore, or a ``ValueError`` will be raised."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/dict.py:docstring of aiida.orm.nodes.data.dict.Dict.__init__:6
msgid "Initial attributes can be changed, deleted or added as long as the node is not stored."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/dict.py:docstring of aiida.orm.nodes.data.dict.Dict.__init__:8
msgid "dictionary to initialise the ``Dict`` node from"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/dict.py:docstring of aiida.orm.nodes.data.dict.Dict.dict:1
msgid "Return an instance of `AttributeManager` that transforms the dictionary into an attribute dict."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/dict.py:docstring of aiida.orm.nodes.data.dict.Dict.dict:3
msgid "this will allow one to do `node.dict.key` as well as `node.dict[key]`."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/dict.py:docstring of aiida.orm.nodes.data.dict.Dict.dict:5
msgid "an instance of the `AttributeResultManager`."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/dict.py:docstring of aiida.orm.nodes.data.dict.Dict.get:1
msgid "Return the value for key if key is in the dictionary, else default."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/dict.py:docstring of aiida.orm.nodes.data.dict.Dict.get:3
msgid "The key whose value to return."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/dict.py:docstring of aiida.orm.nodes.data.dict.Dict.get:4
msgid "Optional default to return in case the key does not exist."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/dict.py:docstring of aiida.orm.nodes.data.dict.Dict.get:5
msgid "The value if the key exists, otherwise the ``default``."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/dict.py:docstring of aiida.orm.nodes.data.dict.Dict.get_dict:1
msgid "Return a dictionary with the parameters currently set."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/dict.py:docstring of aiida.orm.nodes.data.dict.Dict.get_dict:3
msgid "dictionary"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/dict.py:docstring of aiida.orm.nodes.data.dict.Dict.items:1
msgid "Iterator of all items stored in the Dict node."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/dict.py:docstring of aiida.orm.nodes.data.dict.Dict.keys:1
msgid "Iterator of valid keys stored in the Dict object."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/dict.py:docstring of aiida.orm.nodes.data.dict.Dict.keys:3
msgid "iterator over the keys of the current dictionary"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/dict.py:docstring of aiida.orm.nodes.data.dict.Dict.set_dict:1
msgid "Replace the current dictionary with another one."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/dict.py:docstring of aiida.orm.nodes.data.dict.Dict.set_dict:3
msgid "dictionary to set"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/dict.py:docstring of aiida.orm.nodes.data.dict.Dict.update_dict:1
msgid "Update the current dictionary with the keys provided in the dictionary."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/dict.py:docstring of aiida.orm.nodes.data.dict.Dict.update_dict:3
msgid "works exactly as `dict.update()` where new keys are simply added and existing keys are overwritten."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/dict.py:docstring of aiida.orm.nodes.data.dict.Dict.update_dict:5
msgid "a dictionary with the keys to substitute"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/enum.py:docstring of aiida.orm.nodes.data.enum:1
#: ../../../src/aiida/orm/nodes/data/enum.py:docstring of aiida.orm.nodes.data.enum.EnumData:1
msgid "Data plugin that allows to easily wrap an :class:`enum.Enum` member."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/enum.py:docstring of aiida.orm.nodes.data.enum:3
msgid "Nomenclature is taken from Python documentation: https://docs.python.org/3/library/enum.html Given the following example implementation:"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/enum.py:docstring of aiida.orm.nodes.data.enum:13
msgid "The class ``Color`` is an enumeration (or enum). The attributes ``Color.RED`` and ``Color.GREEN`` are enumeration members (or enum members) and are functionally constants. The enum members have names and values: the name of ``Color.RED`` is ``RED`` and the value of ``Color.RED`` is ``1``."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/enum.py:docstring of aiida.orm.nodes.data.enum.EnumData:3
msgid "The enum member is stored in the database by storing the value, name and the identifier (string that represents the class of the enumeration) in the ``KEY_NAME``, ``KEY_VALUE`` and ``KEY_IDENTIFIER`` attribute, respectively. The original enum member can be reconstructured from the (loaded) node through the ``get_member`` method. The enum itself can be retrieved from the ``get_enum`` method. Like a normal enum member, the ``EnumData`` plugin provides the ``name`` and ``value`` properties which return the name and value of the enum member, respectively."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/enum.py:docstring of aiida.orm.nodes.data.enum.EnumData.__eq__:1
msgid "Return whether the other object is equivalent to ourselves."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/enum.py:docstring of aiida.orm.nodes.data.enum.EnumData.__init__:1
msgid "Construct the node for the to enum member that is to be wrapped."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/enum.py:docstring of aiida.orm.nodes.data.enum.EnumData.get_enum:1
msgid "Return the enum class reconstructed from the serialized identifier stored in the database."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/enum.py:docstring of aiida.orm.nodes.data.enum.EnumData.get_enum:3
#: ../../../src/aiida/orm/nodes/data/enum.py:docstring of aiida.orm.nodes.data.enum.EnumData.get_member:7
msgid "if the enum class represented by the stored identifier cannot be imported."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/enum.py:docstring of aiida.orm.nodes.data.enum.EnumData.get_member:1
msgid "Return the enum member reconstructed from the serialized data stored in the database."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/enum.py:docstring of aiida.orm.nodes.data.enum.EnumData.get_member:3
msgid "For the enum member to be successfully reconstructed, the class of course has to still be importable and its implementation should not have changed since the node was stored. That is to say, the value of the member when it was stored, should still be a valid value for the enum class now."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/enum.py:docstring of aiida.orm.nodes.data.enum.EnumData.get_member:8
msgid "if the stored enum member value is no longer valid for the imported enum class."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/enum.py:docstring of aiida.orm.nodes.data.enum.EnumData.name:1
msgid "Return the name of the enum member."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/enum.py:docstring of aiida.orm.nodes.data.enum.EnumData.value:1
msgid "Return the value of the enum member."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/float.py:docstring of aiida.orm.nodes.data.float:1
#: ../../../src/aiida/orm/nodes/data/float.py:docstring of aiida.orm.nodes.data.float.Float:1
msgid "`Data` sub class to represent a float value."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/float.py:docstring of aiida.orm.nodes.data.float.Float:1
#: ../../../src/aiida/orm/nodes/data/int.py:docstring of aiida.orm.nodes.data.int.Int:1
msgid "Bases: :py:class:`~aiida.orm.nodes.data.numeric.NumericType`"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder:1
#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData:1
msgid "`Data` sub class to represent a folder on a file system."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.__init__:1
msgid "Construct a new `FolderData` to which any files and folders can be added."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.__init__:3
msgid "Use the `tree` keyword to simply wrap a directory:"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.__init__:5
msgid "folder = FolderData(tree='/absolute/path/to/directory')"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.__init__:7
msgid "Alternatively, one can construct the node first and then use the various repository methods to add objects:"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.__init__:9
msgid "folder = FolderData() folder.put_object_from_tree('/absolute/path/to/directory') folder.put_object_from_filepath('/absolute/path/to/file.txt') folder.put_object_from_filelike(filelike_object)"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/folder.py:docstring of aiida.orm.nodes.data.folder.FolderData.__init__:14
msgid "absolute path to a folder to wrap"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/int.py:docstring of aiida.orm.nodes.data.int:1
#: ../../../src/aiida/orm/nodes/data/int.py:docstring of aiida.orm.nodes.data.int.Int:1
msgid "`Data` sub class to represent an integer value."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/jsonable.py:docstring of aiida.orm.nodes.data.jsonable:1
#: ../../../src/aiida/orm/nodes/data/jsonable.py:docstring of aiida.orm.nodes.data.jsonable.JsonableData:1
msgid "Data plugin that allows to easily wrap objects that are JSON-able."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/jsonable.py:docstring of aiida.orm.nodes.data.jsonable.JsonableData:3
msgid "Any class that implements the ``as_dict`` method, returning a dictionary that is a JSON serializable representation of the object, can be wrapped and stored by this data plugin."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/jsonable.py:docstring of aiida.orm.nodes.data.jsonable.JsonableData:6
msgid "As an example, take the ``Molecule`` class of the ``pymatgen`` library, which respects the spec described above. To store an instance as a ``JsonableData`` simply pass an instance as an argument to the constructor as follows::"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/jsonable.py:docstring of aiida.orm.nodes.data.jsonable.JsonableData:14
msgid "Since ``Molecule.as_dict`` returns a dictionary that is JSON-serializable, the data plugin will call it and store the dictionary as the attributes of the ``JsonableData`` node in the database."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/jsonable.py:docstring of aiida.orm.nodes.data.jsonable.JsonableData:17
msgid "A JSON-serializable dictionary means a dictionary that when passed to ``json.dumps`` does not except but produces a valid JSON string representation of the dictionary."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/jsonable.py:docstring of aiida.orm.nodes.data.jsonable.JsonableData:20
msgid "If the wrapped class implements a class-method ``from_dict``, the wrapped instance can easily be recovered from a previously stored node that was optionally loaded from the database. The ``from_dict`` method should simply accept a single argument which is the dictionary that is returned by the ``as_dict`` method. If this criteria is satisfied, an instance wrapped and stored in a ``JsonableData`` node can be recovered through the ``obj`` property::"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/jsonable.py:docstring of aiida.orm.nodes.data.jsonable.JsonableData:28
msgid "Of course, this requires that the class of the originally wrapped instance can be imported in the current environment, or an ``ImportError`` will be raised."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/jsonable.py:docstring of aiida.orm.nodes.data.jsonable.JsonableData.__init__:1
msgid "Construct the node for the to be wrapped object."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/jsonable.py:docstring of aiida.orm.nodes.data.jsonable.JsonableData._deserialize_float_constants:1
msgid "Deserialize the contents of a dictionary ``data`` deserializing infinity and NaN string constants."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/jsonable.py:docstring of aiida.orm.nodes.data.jsonable.JsonableData._deserialize_float_constants:3
msgid "The ``data`` dictionary is recursively checked for the ``Infinity``, ``-Infinity`` and ``NaN`` strings, which are the Javascript string equivalents to the Python ``float('inf')``, ``-float('inf')`` and ``float('nan')`` float constants. If one of the strings is encountered, the Python float constant is returned and otherwise the original value is returned."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/jsonable.py:docstring of aiida.orm.nodes.data.jsonable.JsonableData._get_object:1
msgid "Return the cached wrapped object."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/jsonable.py:docstring of aiida.orm.nodes.data.jsonable.JsonableData._get_object:3
msgid "If the object is not yet present in memory, for example if the node was loaded from the database, the object will first be reconstructed from the state stored in the node attributes."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/jsonable.py:docstring of aiida.orm.nodes.data.jsonable.JsonableData.obj:1
msgid "Return the wrapped object."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/jsonable.py:docstring of aiida.orm.nodes.data.jsonable.JsonableData.obj:3
msgid "This property caches the deserialized object, this means that when the node is loaded from the database, the object is deserialized only once and stored in memory as an attribute. Subsequent calls will simply return this cached object and not reload it from the database. This is fine, since nodes that are loaded from the database are by definition stored and therefore immutable, making it safe to assume that the object that is represented can not change. Note, however, that the caching also applies to unstored nodes. That means that manually changing the attributes of an unstored ``JsonableData`` can lead to inconsistencies with the object returned by this property."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/list.py:docstring of aiida.orm.nodes.data.list:1
#: ../../../src/aiida/orm/nodes/data/list.py:docstring of aiida.orm.nodes.data.list.List:1
msgid "`Data` sub class to represent a list."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/list.py:docstring of aiida.orm.nodes.data.list.List:1
msgid "Bases: :py:class:`~aiida.orm.nodes.data.data.Data`, :py:class:`~collections.abc.MutableSequence`"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/list.py:docstring of aiida.orm.nodes.data.list.List.__init__:1
msgid "Initialise a ``List`` node instance."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/list.py:docstring of aiida.orm.nodes.data.list.List.__init__:3
msgid "list to initialise the ``List`` node from"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/list.py:docstring of aiida.orm.nodes.data.list.List._using_list_reference:1
msgid "This function tells the class if we are using a list reference.  This means that calls to self.get_list return a reference rather than a copy of the underlying list and therefore self.set_list need not be called. This knwoledge is essential to make sure this class is performant."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/list.py:docstring of aiida.orm.nodes.data.list.List._using_list_reference:6
msgid "Currently the implementation assumes that if the node needs to be stored then it is using the attributes cache which is a reference."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/list.py:docstring of aiida.orm.nodes.data.list.List._using_list_reference:9
msgid "True if using self.get_list returns a reference to the underlying sequence.  False otherwise."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/list.py:docstring of aiida.orm.nodes.data.list.List.append:1
msgid "S.append(value) -- append value to the end of the sequence"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/list.py:docstring of aiida.orm.nodes.data.list.List.count:1
msgid "Return number of occurrences of value."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/list.py:docstring of aiida.orm.nodes.data.list.List.extend:1
msgid "S.extend(iterable) -- extend sequence by appending elements from the iterable"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/list.py:docstring of aiida.orm.nodes.data.list.List.get_list:1
msgid "Return the contents of this node."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/list.py:docstring of aiida.orm.nodes.data.list.List.index:1
msgid "Return first index of value.."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/list.py:docstring of aiida.orm.nodes.data.list.List.insert:1
msgid "S.insert(index, value) -- insert value before index"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/list.py:docstring of aiida.orm.nodes.data.list.List.pop:1
msgid "Remove and return item at index (default last)."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/list.py:docstring of aiida.orm.nodes.data.list.List.remove:1
msgid "S.remove(value) -- remove first occurrence of value. Raise ValueError if the value is not present."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/list.py:docstring of aiida.orm.nodes.data.list.List.reverse:1
msgid "S.reverse() -- reverse *IN PLACE*"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/list.py:docstring of aiida.orm.nodes.data.list.List.set_list:1
msgid "Set the contents of this node."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/list.py:docstring of aiida.orm.nodes.data.list.List.set_list:3
msgid "the list to set"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/numeric.py:docstring of aiida.orm.nodes.data.numeric:1
msgid "Module for defintion of base `Data` sub class for numeric based data types."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/numeric.py:docstring of aiida.orm.nodes.data.numeric.NumericType:1
msgid "Sub class of Data to store numbers, overloading common operators (``+``, ``*``, ...)."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/numeric.py:docstring of aiida.orm.nodes.data.numeric._left_operator.<locals>.inner:1
#: ../../../src/aiida/orm/nodes/data/numeric.py:docstring of aiida.orm.nodes.data.numeric._right_operator.<locals>.inner:1
msgid "Decorator wrapper."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/numeric.py:docstring of aiida.orm.nodes.data.numeric._left_operator:1
msgid "Function decorator to treat a method as the left operator."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/numeric.py:docstring of aiida.orm.nodes.data.numeric._right_operator:1
msgid "Function decorator to treat a method as the right operator."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/orbital.py:docstring of aiida.orm.nodes.data.orbital:1
msgid "Data plugin to model an atomic orbital."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/orbital.py:docstring of aiida.orm.nodes.data.orbital.OrbitalData:1
msgid "Used for storing collections of orbitals, as well as providing methods for accessing them internally."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/orbital.py:docstring of aiida.orm.nodes.data.orbital.OrbitalData.clear_orbitals:1
msgid "Remove all orbitals that were added to the class Cannot work if OrbitalData has been already stored"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/orbital.py:docstring of aiida.orm.nodes.data.orbital.OrbitalData.get_orbitals:1
msgid "Returns all orbitals by default. If a site is provided, returns all orbitals cooresponding to the location of that site, additional arguments may be provided, which act as filters on the retrieved orbitals."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/orbital.py:docstring of aiida.orm.nodes.data.orbital.OrbitalData.get_orbitals:6
msgid "if provided, returns all orbitals with position of site"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/orbital.py:docstring of aiida.orm.nodes.data.orbital.OrbitalData.get_orbitals:7
msgid "attributes than can filter the set of returned orbitals"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/orbital.py:docstring of aiida.orm.nodes.data.orbital.OrbitalData.get_orbitals:0
msgid "return list_of_outputs"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/orbital.py:docstring of aiida.orm.nodes.data.orbital.OrbitalData.get_orbitals:8
msgid "a list of orbitals"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/orbital.py:docstring of aiida.orm.nodes.data.orbital.OrbitalData.set_orbitals:1
msgid "Sets the orbitals into the database. Uses the orbital's inherent set_orbital_dict method to generate a orbital dict string."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/orbital.py:docstring of aiida.orm.nodes.data.orbital.OrbitalData.set_orbitals:4
msgid "an orbital or list of orbitals to be set"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/singlefile.py:docstring of aiida.orm.nodes.data.singlefile:1
#: ../../../src/aiida/orm/nodes/data/singlefile.py:docstring of aiida.orm.nodes.data.singlefile.SinglefileData:1
msgid "Data class that can be used to store a single file in its repository."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/singlefile.py:docstring of aiida.orm.nodes.data.singlefile.SinglefileData.__init__:3
#: ../../../src/aiida/orm/nodes/data/upf.py:docstring of aiida.orm.nodes.data.upf.UpfData.__init__:3
msgid "an absolute filepath or filelike object whose contents to copy. Hint: Pass io.BytesIO(b\"my string\") to construct the SinglefileData directly from a string."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/singlefile.py:docstring of aiida.orm.nodes.data.singlefile.SinglefileData._validate:1
msgid "Ensure that there is one object stored in the repository, whose key matches value set for `filename` attr."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/singlefile.py:docstring of aiida.orm.nodes.data.singlefile.SinglefileData.as_path:1
msgid "Make the contents of the file available as a normal filepath on the local file system."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/singlefile.py:docstring of aiida.orm.nodes.data.singlefile.SinglefileData.filename:1
msgid "Return the name of the file stored."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/singlefile.py:docstring of aiida.orm.nodes.data.singlefile.SinglefileData.filename:3
msgid "the filename under which the file is stored in the repository"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/singlefile.py:docstring of aiida.orm.nodes.data.singlefile.SinglefileData.from_string:1
msgid "Construct a new instance and set ``content`` as its contents."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/singlefile.py:docstring of aiida.orm.nodes.data.singlefile.SinglefileData.from_string:3
msgid "The content as a string."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/singlefile.py:docstring of aiida.orm.nodes.data.singlefile.SinglefileData.from_string:4
msgid "Specify filename to use (defaults to ``file.txt``)."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/singlefile.py:docstring of aiida.orm.nodes.data.singlefile.SinglefileData.get_content:1
msgid "Return the content of the single file stored for this data node."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/singlefile.py:docstring of aiida.orm.nodes.data.singlefile.SinglefileData.get_content:3
#: ../../../src/aiida/orm/nodes/data/singlefile.py:docstring of aiida.orm.nodes.data.singlefile.SinglefileData.open:4
msgid "the mode with which to open the file handle (default: read mode)"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/singlefile.py:docstring of aiida.orm.nodes.data.singlefile.SinglefileData.get_content:4
msgid "the content of the file as a string or bytes, depending on ``mode``."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/singlefile.py:docstring of aiida.orm.nodes.data.singlefile.SinglefileData.open:1
msgid "Return an open file handle to the content of this data node."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/singlefile.py:docstring of aiida.orm.nodes.data.singlefile.SinglefileData.open:5
msgid "a file handle"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/singlefile.py:docstring of aiida.orm.nodes.data.singlefile.SinglefileData.set_file:1
msgid "Store the content of the file in the node's repository, deleting any other existing objects."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/singlefile.py:docstring of aiida.orm.nodes.data.singlefile.SinglefileData.set_file:3
msgid "an absolute filepath or filelike object whose contents to copy Hint: Pass io.BytesIO(b\"my string\") to construct the file directly from a string."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/str.py:docstring of aiida.orm.nodes.data.str:1
#: ../../../src/aiida/orm/nodes/data/str.py:docstring of aiida.orm.nodes.data.str.Str:1
msgid "`Data` sub class to represent a string value."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure:1
msgid "This module defines the classes for structures and all related functions to operate on them."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.Kind:1
msgid "This class contains the information about the species (kinds) of the system."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.Kind:3
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.Site:3
msgid "It can be a single atom, or an alloy, or even contain vacancies."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.Kind.__init__:1
msgid "Create a site. One can either pass:"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.Kind.__init__:4
msgid "the raw python dictionary that will be converted to a Kind object."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.Kind.__init__:6
msgid "an ase Atom object"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.Kind.__init__:7
msgid "a Kind object (to get a copy)"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.Kind.__init__:9
msgid "Or alternatively the following parameters:"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.Kind.__init__:11
msgid "a single string for the symbol of this site, or a list of symbol strings"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.Kind.__init__:13
msgid "(optional) the weights for each atomic species of this site. If only a single symbol is provided, then this value is optional and the weight is set to 1."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.Kind.__init__:17
msgid "(optional) the mass for this site in atomic mass units. If not provided, the mass is set by the self.reset_mass() function."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.Kind.__init__:20
msgid "a string that uniquely identifies the kind, and that is used to identify the sites."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.Kind.compare_with:1
msgid "Compare with another Kind object to check if they are different."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.Kind.compare_with:3
msgid "This does NOT check the 'type' attribute. Instead, it compares (with reasonable thresholds, where applicable): the mass, and the list of symbols and of weights. Moreover, it compares the ``_internal_tag``, if defined (at the moment, defined automatically only when importing the Kind from ASE, if the atom has a non-zero tag). Note that the _internal_tag is only used while the class is loaded, but is not persisted on the database."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.Kind.compare_with:11
msgid "A tuple with two elements. The first one is True if the two sites are 'equivalent' (same mass, symbols and weights), False otherwise. The second element of the tuple is a string, which is either None (if the first element was True), or contains a 'human-readable' description of the first difference encountered between the two sites."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.Kind.get_raw:1
msgid "Return the raw version of the site, mapped to a suitable dictionary. This is the format that is actually used to store each kind of the structure in the DB."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.Kind.get_raw:5
msgid "a python dictionary with the kind."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.Kind.get_symbols_string:1
msgid "Return a string that tries to match as good as possible the symbols of this kind. If there is only one symbol (no alloy) with 100% occupancy, just returns the symbol name. Otherwise, groups the full string in curly brackets, and try to write also the composition (with 2 precision only)."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.Kind.get_symbols_string:7
msgid "If there is a vacancy (sum of weights<1), we indicate it with the X symbol followed by 1-sum(weights) (still with 2 digits precision, so it can be 0.00)"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.Kind.get_symbols_string:11
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.get_symbols_string:12
msgid "Note the difference with respect to the symbols and the symbol properties!"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.Kind.has_vacancies:1
msgid "Return whether the Kind contains vacancies, i.e. when the sum of the weights is less than one."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.Kind.has_vacancies:3
msgid "the property uses the internal variable `_SUM_THRESHOLD` as a threshold."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.Kind.has_vacancies:5
msgid "boolean, True if the sum of the weights is less than one, False otherwise"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.Kind.is_alloy:1
msgid "Return whether the Kind is an alloy, i.e. contains more than one element"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.Kind.is_alloy:3
msgid "boolean, True if the kind has more than one element, False otherwise."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.Kind.mass:1
msgid "The mass of this species kind."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.Kind.mass:3
msgid "a float"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.Kind.name:1
msgid "Return the name of this kind. The name of a kind is used to identify the species of a site."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.Kind.reset_mass:1
msgid "Reset the mass to the automatic calculated value."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.Kind.reset_mass:3
msgid "The mass can be set manually; by default, if not provided, it is the mass of the constituent atoms, weighted with their weight (after the weight has been normalized to one to take correctly into account vacancies)."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.Kind.reset_mass:8
msgid "This function uses the internal _symbols and _weights values and thus assumes that the values are validated."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.Kind.reset_mass:11
msgid "It sets the mass to None if the sum of weights is zero."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.Kind.set_automatic_kind_name:1
msgid "Set the type to a string obtained with the symbols appended one after the other, without spaces, in alphabetical order; if the site has a vacancy, a X is appended at the end too."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.Kind.set_symbols_and_weights:1
msgid "Set the chemical symbols and the weights for the site."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.Kind.set_symbols_and_weights:3
msgid "Note that the kind name remains unchanged."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.Kind.symbol:1
msgid "If the kind has only one symbol, return it; otherwise, raise a ValueError."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.Kind.symbols:1
msgid "List of symbols for this site. If the site is a single atom, pass a list of one element only, or simply the string for that atom. For alloys, a list of elements."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.Kind.symbols:5
msgid "Note that if you change the list of symbols, the kind name remains unchanged."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.Kind.weights:1
msgid "Weights for this species kind. Refer also to :func:validate_symbols_tuple for the validation rules on the weights."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.Site:1
msgid "This class contains the information about a given site of the system."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.Site.__init__:1
msgid "Create a site."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.Site.__init__:3
msgid "a string that identifies the kind (species) of this site. This has to be found in the list of kinds of the StructureData object. Validation will be done at the StructureData level."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.Site.__init__:7
msgid "the absolute position (three floats) in angstrom"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.Site.get_ase:1
msgid "Return a ase.Atom object for this site."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.Site.get_ase:3
msgid "the list of kinds from the StructureData object."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.Site.get_ase:5
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_ase:8
msgid "If any site is an alloy or has vacancies, a ValueError is raised (from the site.get_ase() routine)."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.Site.get_raw:1
msgid "Return the raw version of the site, mapped to a suitable dictionary. This is the format that is actually used to store each site of the structure in the DB."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.Site.get_raw:5
msgid "a python dictionary with the site."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.Site.kind_name:1
msgid "Return the kind name of this site (a string)."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.Site.kind_name:3
msgid "The type of a site is used to decide whether two sites are identical (same mass, symbols, weights, ...) or not."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.Site.position:1
msgid "Return the position of this site in absolute coordinates, in angstrom."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData:1
msgid "Data class that represents an atomic structure."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData:3
msgid "The data is organized as a collection of sites together with a cell, the boundary conditions (whether they are periodic or not) and other related useful information."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData._adjust_default_cell:1
msgid "If the structure was imported from an xyz file, it lacks a cell. This method will adjust the cell"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData._get_object_ase:1
msgid "Converts :py:class:`StructureData <aiida.orm.nodes.data.structure.StructureData>` to ase.Atoms"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData._get_object_phonopyatoms:1
msgid "Converts StructureData to PhonopyAtoms"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData._get_object_phonopyatoms:3
msgid "a PhonopyAtoms object"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData._get_object_pymatgen:1
msgid "Converts :py:class:`StructureData <aiida.orm.nodes.data.structure.StructureData>` to pymatgen object"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData._get_object_pymatgen:5
msgid "a pymatgen Structure for structures with periodic boundary conditions (in three dimensions) and Molecule otherwise"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData._get_object_pymatgen:8
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_pymatgen:13
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_pymatgen_molecule:3
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_pymatgen_structure:11
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.set_pymatgen:3
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.set_pymatgen_molecule:6
msgid "Requires the pymatgen module (version >= 3.0.13, usage of earlier versions may cause errors)."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData._get_object_pymatgen_molecule:1
msgid "Converts :py:class:`StructureData <aiida.orm.nodes.data.structure.StructureData>` to pymatgen Molecule object"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData._get_object_pymatgen_molecule:5
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_pymatgen_molecule:6
msgid "a pymatgen Molecule object corresponding to this :py:class:`StructureData <aiida.orm.nodes.data.structure.StructureData>` object."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData._get_object_pymatgen_molecule:9
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData._get_object_pymatgen_structure:20
msgid "Requires the pymatgen module (version >= 3.0.13, usage of earlier versions may cause errors)"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData._get_object_pymatgen_structure:1
msgid "Converts :py:class:`StructureData <aiida.orm.nodes.data.structure.StructureData>` to pymatgen Structure object :param add_spin: True to add the spins to the pymatgen structure. Default is False (no spin added)."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData._get_object_pymatgen_structure:7
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_pymatgen:7
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_pymatgen_structure:5
msgid "The spins are set according to the following rule:"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData._get_object_pymatgen_structure:9
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_pymatgen:9
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_pymatgen_structure:7
msgid "if the kind name ends with 1 -> spin=+1"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData._get_object_pymatgen_structure:11
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_pymatgen:11
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_pymatgen_structure:9
msgid "if the kind name ends with 2 -> spin=-1"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData._get_object_pymatgen_structure:13
msgid "a pymatgen Structure object corresponding to this :py:class:`StructureData <aiida.orm.nodes.data.structure.StructureData>` object"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData._get_object_pymatgen_structure:16
msgid "if periodic boundary conditions does not hold in at least one dimension of real space; if there are partial occupancies together with spins (defined by kind names ending with '1' or '2')."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData._parse_xyz:1
msgid "Read the structure from a string of format XYZ."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData._prepare_chemdoodle:1
msgid "Write the given structure to a string of format required by ChemDoodle."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData._prepare_cif:1
msgid "Write the given structure to a string of format CIF."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData._prepare_xsf:1
msgid "Write the given structure to a string of format XSF (for XCrySDen)."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData._prepare_xyz:1
msgid "Write the given structure to a string of format XYZ."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData._validate:1
msgid "Performs some standard validation tests."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.append_atom:1
msgid "Append an atom to the Structure, taking care of creating the corresponding kind."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.append_atom:4
msgid "the ase Atom object from which we want to create a new atom (if present, this must be the only parameter)"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.append_atom:6
msgid "the position of the atom (three numbers in angstrom)"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.append_atom:7
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.append_atom:8
msgid "passed to the constructor of the Kind object."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.append_atom:9
msgid "passed to the constructor of the Kind object. See also the note below."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.append_atom:11
msgid "Note on the 'name' parameter (that is, the name of the kind):"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.append_atom:13
msgid "if specified, no checks are done on existing species. Simply, a new kind with that name is created. If there is a name clash, a check is done: if the kinds are identical, no error is issued; otherwise, an error is issued because you are trying to store two different kinds with the same name."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.append_atom:19
msgid "if not specified, the name is automatically generated. Before adding the kind, a check is done. If other species with the same properties already exist, no new kinds are created, but the site is added to the existing (identical) kind. (Actually, the first kind that is encountered). Otherwise, the name is made unique first, by adding to the string containing the list of chemical symbols a number starting from 1, until an unique name is found"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.append_atom:28
msgid "checks of equality of species are done using the :py:meth:`~aiida.orm.nodes.data.structure.Kind.compare_with` method."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.append_kind:1
msgid "Append a kind to the :py:class:`StructureData <aiida.orm.nodes.data.structure.StructureData>`. It makes a copy of the kind."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.append_kind:5
msgid "the site to append, must be a Kind object."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.append_site:1
msgid "Append a site to the :py:class:`StructureData <aiida.orm.nodes.data.structure.StructureData>`. It makes a copy of the site."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.append_site:5
msgid "the site to append. It must be a Site object."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.cell:1
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.restapi.translator.nodes.data.structure.StructureDataTranslator.StructureData.cell:1
msgid "Returns the cell shape."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.cell:3
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.restapi.translator.nodes.data.structure.StructureDataTranslator.StructureData.cell:3
msgid "a 3x3 list of lists."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.cell_angles:1
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.restapi.translator.nodes.data.structure.StructureDataTranslator.StructureData.cell_angles:1
msgid "Get the angles between the cell lattice vectors in degrees."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.cell_lengths:1
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.restapi.translator.nodes.data.structure.StructureDataTranslator.StructureData.cell_lengths:1
msgid "Get the lengths of cell lattice vectors in angstroms."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.clear_kinds:1
msgid "Removes all kinds for the StructureData object."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.clear_kinds:3
msgid "Also clear all sites!"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.clear_sites:1
msgid "Removes all sites for the StructureData object."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_ase:1
msgid "Get the ASE object. Requires to be able to import ase."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_ase:4
msgid "an ASE object corresponding to this :py:class:`StructureData <aiida.orm.nodes.data.structure.StructureData>` object."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_cell_volume:1
msgid "Returns the three-dimensional cell volume in Angstrom^3."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_cell_volume:3
msgid "Use the `get_dimensionality` method in order to get the area/length of lower-dimensional cells."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_cell_volume:5
msgid "a float."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_cif:1
msgid "Creates :py:class:`aiida.orm.nodes.data.cif.CifData`."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.get_cif:3
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_cif:3
msgid "Renamed from _get_cif"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_cif:6
msgid "specify the converter. Default 'ase'."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.get_structure:6
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_cif:7
msgid "If True, intermediate calculation gets stored in the AiiDA database for record. Default False."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_cif:9
msgid ":py:class:`aiida.orm.nodes.data.cif.CifData` node."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_composition:1
msgid "Returns the chemical composition of this structure as a dictionary, where each key is the kind symbol (e.g. H, Li, Ba), and each value is the number of occurences of that element in this structure."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_composition:6
msgid "Specify the mode of the composition to return. Choose from ``full``, ``reduced`` or ``fractional``. For example, given the structure with formula Ba2Zr2O6, the various modes operate as follows. ``full``: The default, the counts are left unnnormalized. ``reduced``: The counts are renormalized to the greatest common denominator. ``fractional``: The counts are renormalized such that the sum equals 1."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_composition:12
msgid "a dictionary with the composition"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_description:1
msgid "Returns a string with infos retrieved from StructureData node's properties"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_description:3
msgid "the StructureData node"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_description:4
msgid "retsrt: the description string"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_dimensionality:1
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure._get_dimensionality:1
msgid "Return the dimensionality of the structure and its length/surface/volume."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_dimensionality:3
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure._get_dimensionality:3
msgid "Zero-dimensional structures are assigned \"volume\" 0."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_dimensionality:5
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure._get_dimensionality:5
msgid "returns a dictionary with keys \"dim\" (dimensionality integer), \"label\" (dimensionality label) and \"value\" (numerical length/surface/volume)."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_formula:1
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.get_formula:1
msgid "Return a string with the chemical formula."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_formula:3
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.get_formula:4
msgid "a string to specify how to generate the formula, can assume one of the following values:  * 'hill' (default): count the number of atoms of each species,   then use Hill notation, i.e. alphabetical order with C and H   first if one or several C atom(s) is (are) present, e.g.   ``['C','H','H','H','O','C','H','H','H']`` will return ``'C2H6O'``   ``['S','O','O','H','O','H','O']``  will return ``'H2O4S'``   From E. A. Hill, J. Am. Chem. Soc., 22 (8), pp 478-494 (1900)  * 'hill_compact': same as hill but the number of atoms for each   species is divided by the greatest common divisor of all of them, e.g.   ``['C','H','H','H','O','C','H','H','H','O','O','O']``   will return ``'CH3O2'``  * 'reduce': group repeated symbols e.g.   ``['Ba', 'Ti', 'O', 'O', 'O', 'Ba', 'Ti', 'O', 'O', 'O',   'Ba', 'Ti', 'Ti', 'O', 'O', 'O']`` will return ``'BaTiO3BaTiO3BaTi2O3'``  * 'group': will try to group as much as possible parts of the formula   e.g.   ``['Ba', 'Ti', 'O', 'O', 'O', 'Ba', 'Ti', 'O', 'O', 'O',   'Ba', 'Ti', 'Ti', 'O', 'O', 'O']`` will return ``'(BaTiO3)2BaTi2O3'``  * 'count': same as hill (i.e. one just counts the number   of atoms of each species) without the re-ordering (take the   order of the atomic sites), e.g.   ``['Ba', 'Ti', 'O', 'O', 'O','Ba', 'Ti', 'O', 'O', 'O']``   will return ``'Ba2Ti2O6'``  * 'count_compact': same as count but the number of atoms   for each species is divided by the greatest common divisor of   all of them, e.g.   ``['Ba', 'Ti', 'O', 'O', 'O','Ba', 'Ti', 'O', 'O', 'O']``   will return ``'BaTiO3'``"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_formula:3
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.get_formula:4
msgid "a string to specify how to generate the formula, can assume one of the following values:"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_formula:6
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.get_formula:7
msgid "'hill' (default): count the number of atoms of each species, then use Hill notation, i.e. alphabetical order with C and H first if one or several C atom(s) is (are) present, e.g. ``['C','H','H','H','O','C','H','H','H']`` will return ``'C2H6O'`` ``['S','O','O','H','O','H','O']``  will return ``'H2O4S'`` From E. A. Hill, J. Am. Chem. Soc., 22 (8), pp 478-494 (1900)"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_formula:13
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.get_formula:14
msgid "'hill_compact': same as hill but the number of atoms for each species is divided by the greatest common divisor of all of them, e.g. ``['C','H','H','H','O','C','H','H','H','O','O','O']`` will return ``'CH3O2'``"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_formula:18
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.get_formula:19
msgid "'reduce': group repeated symbols e.g. ``['Ba', 'Ti', 'O', 'O', 'O', 'Ba', 'Ti', 'O', 'O', 'O', 'Ba', 'Ti', 'Ti', 'O', 'O', 'O']`` will return ``'BaTiO3BaTiO3BaTi2O3'``"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_formula:22
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.get_formula:23
msgid "'group': will try to group as much as possible parts of the formula e.g. ``['Ba', 'Ti', 'O', 'O', 'O', 'Ba', 'Ti', 'O', 'O', 'O', 'Ba', 'Ti', 'Ti', 'O', 'O', 'O']`` will return ``'(BaTiO3)2BaTi2O3'``"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_formula:27
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.get_formula:28
msgid "'count': same as hill (i.e. one just counts the number of atoms of each species) without the re-ordering (take the order of the atomic sites), e.g. ``['Ba', 'Ti', 'O', 'O', 'O','Ba', 'Ti', 'O', 'O', 'O']`` will return ``'Ba2Ti2O6'``"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_formula:33
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.get_formula:34
msgid "'count_compact': same as count but the number of atoms for each species is divided by the greatest common divisor of all of them, e.g. ``['Ba', 'Ti', 'O', 'O', 'O','Ba', 'Ti', 'O', 'O', 'O']`` will return ``'BaTiO3'``"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_formula:39
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.get_formula:40
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.get_formula_from_symbol_list:10
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.get_formula_group:14
msgid "a string used to concatenate symbols. Default empty."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_formula:41
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.get_formula:42
msgid "a string with the formula"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_formula:43
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.get_formula:44
msgid "in modes reduce, group, count and count_compact, the initial order in which the atoms were appended by the user is used to group and/or order the symbols in the formula"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_kind:1
msgid "Return the kind object associated with the given kind name."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_kind:3
msgid "String, the name of the kind you want to get"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_kind:5
msgid "The Kind object associated with the given kind_name, if a Kind with the given name is present in the structure."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_kind:8
msgid "ValueError if the kind_name is not present."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_kind_names:1
msgid "Return a list of kind names (in the same order of the ``self.kinds`` property, but return the names rather than Kind objects)"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_kind_names:4
msgid "This is NOT necessarily a list of chemical symbols! Use get_symbols_set for chemical symbols"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_kind_names:7
msgid "a list of strings."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_pymatgen:1
msgid "Get pymatgen object. Returns Structure for structures with periodic boundary conditions (in three dimensions) and Molecule otherwise. :param add_spin: True to add the spins to the pymatgen structure. Default is False (no spin added)."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_pymatgen_molecule:1
msgid "Get the pymatgen Molecule object."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_pymatgen_structure:1
msgid "Get the pymatgen Structure object. :param add_spin: True to add the spins to the pymatgen structure. Default is False (no spin added)."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_pymatgen_structure:14
msgid "a pymatgen Structure object corresponding to this :py:class:`StructureData <aiida.orm.nodes.data.structure.StructureData>` object."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_pymatgen_structure:17
msgid "if periodic boundary conditions do not hold in at least one dimension of real space."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_site_kindnames:1
msgid "Return a list with length equal to the number of sites of this structure, where each element of the list is the kind name of the corresponding site."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_site_kindnames:4
msgid "This is NOT necessarily a list of chemical symbols! Use ``[ self.get_kind(s.kind_name).get_symbols_string() for s in self.sites]`` for chemical symbols"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_symbols_set:1
msgid "Return a set containing the names of all elements involved in this structure (i.e., for it joins the list of symbols for each kind k in the structure)."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.get_symbols_set:5
msgid "a set of strings of element names."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.has_vacancies:1
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.restapi.translator.nodes.data.structure.StructureDataTranslator.StructureData.has_vacancies:1
msgid "Return whether the structure has vacancies in the structure."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.has_vacancies:3
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.restapi.translator.nodes.data.structure.StructureDataTranslator.StructureData.has_vacancies:3
msgid "a boolean, True if at least one kind has a vacancy"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.is_alloy:1
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.restapi.translator.nodes.data.structure.StructureDataTranslator.StructureData.is_alloy:1
msgid "Return whether the structure contains any alloy kinds."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.is_alloy:3
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.restapi.translator.nodes.data.structure.StructureDataTranslator.StructureData.is_alloy:3
msgid "a boolean, True if at least one kind is an alloy"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.kinds:1
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.restapi.translator.nodes.data.structure.StructureDataTranslator.StructureData.kinds:1
msgid "Returns a list of kinds."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.pbc:1
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.restapi.translator.nodes.data.structure.StructureDataTranslator.StructureData.pbc:1
msgid "Get the periodic boundary conditions."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.orm.nodes.data.array.kpoints.KpointsData.pbc:3
#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.restapi.translator.nodes.data.kpoints.KpointsDataTranslator.KpointsData.pbc:3
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.pbc:3
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.restapi.translator.nodes.data.structure.StructureDataTranslator.StructureData.pbc:3
msgid "a tuple of three booleans, each one tells if there are periodic boundary conditions for the i-th real-space direction (i=1,2,3)"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.reset_cell:1
msgid "Reset the cell of a structure not yet stored to a new value."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.reset_cell:3
msgid "list specifying the cell vectors"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.reset_cell:6
msgid "ModificationNotAllowed: if object is already stored"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.reset_sites_positions:1
msgid "Replace all the Site positions attached to the Structure"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.reset_sites_positions:3
msgid "list of (3D) positions for every sites."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.reset_sites_positions:5
msgid "if True, allows the possibility of removing a site. currently not implemented."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.reset_sites_positions:8
msgid "if object is stored already"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.reset_sites_positions:9
msgid "if positions are invalid"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.reset_sites_positions:11
msgid "it is assumed that the order of the new_positions is given in the same order of the one it's substituting, i.e. the kind of the site will not be checked."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.set_ase:1
msgid "Load the structure from a ASE object"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.set_cell:1
msgid "Set the cell."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.set_pbc:1
msgid "Set the periodic boundary conditions."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.set_pymatgen:1
msgid "Load the structure from a pymatgen object."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.set_pymatgen_molecule:1
msgid "Load the structure from a pymatgen Molecule object."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.set_pymatgen_molecule:3
msgid "the margin to be added in all directions of the bounding box of the molecule."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.set_pymatgen_structure:1
msgid "Load the structure from a pymatgen Structure object."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.set_pymatgen_structure:3
msgid "periodic boundary conditions are set to True in all three directions."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.set_pymatgen_structure:5
msgid "Requires the pymatgen module (version >= 3.3.5, usage of earlier versions may cause errors)."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.set_pymatgen_structure:8
msgid "if there are partial occupancies together with spins."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.StructureData.sites:1
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.restapi.translator.nodes.data.structure.StructureDataTranslator.StructureData.sites:1
msgid "Returns a list of sites."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure._create_symbols_tuple:1
msgid "Returns a tuple with the symbols provided. If a string is provided, this is converted to a tuple with one single element."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure._create_weights_tuple:1
msgid "Returns a tuple with the weights provided. If a number is provided, this is converted to a tuple with one single element. If None is provided, this is converted to the tuple (1.,)"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure._get_valid_cell:1
msgid "Return the cell in a valid format from a generic input."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure._get_valid_cell:3
msgid "whenever the format is not valid."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure._validate_dimensionality:1
msgid "Check whether the given pbc and cell vectors are consistent."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.ase_refine_cell:1
msgid "Detect the symmetry of the structure, remove symmetric atoms and refine unit cell."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.ase_refine_cell:4
msgid "an ase.atoms.Atoms instance"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.ase_refine_cell:5
msgid "symmetry precision, used by spglib"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.ase_refine_cell:0
msgid "return newase"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.ase_refine_cell:6
msgid "refined cell with reduced set of atoms"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.ase_refine_cell:0
msgid "return symmetry"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.ase_refine_cell:7
msgid "a dictionary describing the symmetry space group"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.atom_kinds_to_html:1
msgid "Construct in html format"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.atom_kinds_to_html:3
msgid "an alloy with 0.5 Ge, 0.4 Si and 0.1 vacancy is represented as Ge<sub>0.5</sub> + Si<sub>0.4</sub> + vacancy<sub>0.1</sub>"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.atom_kinds_to_html:7
#: ../../../src/aiida/schedulers/plugins/direct.py:docstring of aiida.schedulers.plugins.direct.DirectScheduler._get_submit_script_header:5
#: ../../../src/aiida/schedulers/plugins/pbsbaseclasses.py:docstring of aiida.schedulers.plugins.pbsbaseclasses.PbsBaseClass._get_submit_command:4
#: ../../../src/aiida/schedulers/plugins/pbsbaseclasses.py:docstring of aiida.schedulers.plugins.pbsbaseclasses.PbsBaseClass._get_submit_script_header:5
#: ../../../src/aiida/schedulers/plugins/sge.py:docstring of aiida.schedulers.plugins.sge.SgeScheduler._get_submit_command:4
#: ../../../src/aiida/schedulers/plugins/sge.py:docstring of aiida.schedulers.plugins.sge.SgeScheduler._get_submit_script_header:5
#: ../../../src/aiida/schedulers/plugins/slurm.py:docstring of aiida.schedulers.plugins.slurm.SlurmScheduler._get_submit_command:4
#: ../../../src/aiida/schedulers/plugins/slurm.py:docstring of aiida.schedulers.plugins.slurm.SlurmScheduler._get_submit_script_header:5
msgid "Args:"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.atom_kinds_to_html:8
msgid "atom_kind: a string with the name of the atomic kind, as printed by kind.get_symbols_string(), e.g. Ba0.80Ca0.10X0.10"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.atom_kinds_to_html:12
msgid "Returns:"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.atom_kinds_to_html:13
msgid "html code for rendered formula"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.calc_cell_volume:1
msgid "Compute the three-dimensional cell volume in Angstrom^3."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.calc_cell_volume:3
msgid "the cell vectors; the must be a 3x3 list of lists of floats"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.calc_cell_volume:4
msgid "the cell volume."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.create_automatic_kind_name:1
msgid "Create a string obtained with the symbols appended one after the other, without spaces, in alphabetical order; if the site has a vacancy, a X is appended at the end too."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.get_formula:3
msgid "a list of symbols, e.g. ``['H','H','O']``"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.get_formula_from_symbol_list:1
msgid "Return a string with the formula obtained from the list of symbols."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.orm.nodes.data.array.kpoints.KpointsData.set_kpoints:10
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.get_formula_from_symbol_list:4
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.group_symbols:5
msgid "Examples"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.get_formula_from_symbol_list:5
msgid "``[[1,'Ba'],[1,'Ti'],[3,'O']]`` will return ``'BaTiO3'``"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.get_formula_from_symbol_list:6
msgid "``[[2, [ [1, 'Ba'], [1, 'Ti'] ] ]]`` will return ``'(BaTi)2'``"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.get_formula_from_symbol_list:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.group_symbols:0
msgid "param _list"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.get_formula_from_symbol_list:8
msgid "a list of symbols and multiplicities as obtained from the function group_symbols"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.get_formula_from_symbol_list:0
msgid "param separator"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.get_formula_from_symbol_list:0
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.group_symbols:0
msgid "return"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.get_formula_group:1
msgid "Return a string with the chemical formula from a list of chemical symbols. The formula is written in a compact\" way, i.e. trying to group as much as possible parts of the formula."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.get_formula_group:5
msgid "it works for instance very well if structure was obtained from an ASE supercell."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.get_formula_group:8
msgid "Example of result: ``['Ba', 'Ti', 'O', 'O', 'O', 'Ba', 'Ti', 'O', 'O', 'O', 'Ba', 'Ti', 'Ti', 'O', 'O', 'O']`` will return ``'(BaTiO3)2BaTi2O3'``."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.get_formula_group:12
msgid "list of symbols (e.g. ['Ba','Ti','O','O','O'])"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.get_formula_group:15
msgid "a string with the chemical formula for the given structure."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.get_pymatgen_version:1
msgid "string with pymatgen version, None if can not import."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.get_symbols_string:1
msgid "Return a string that tries to match as good as possible the symbols and weights. If there is only one symbol (no alloy) with 100% occupancy, just returns the symbol name. Otherwise, groups the full string in curly brackets, and try to write also the composition (with 2 precision only). If (sum of weights<1), we indicate it with the X symbol followed by 1-sum(weights) (still with 2 digits precision, so it can be 0.00)"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.get_symbols_string:9
msgid "the symbols as obtained from <kind>._symbols"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.get_symbols_string:10
msgid "the weights as obtained from <kind>._weights"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.get_valid_pbc:1
msgid "Return a list of three booleans for the periodic boundary conditions, in a valid format from a generic input."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.get_valid_pbc:4
msgid "if the format is not valid."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.group_symbols:1
msgid "Group a list of symbols to a list containing the number of consecutive identical symbols, and the symbol itself."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.group_symbols:6
msgid "``['Ba','Ti','O','O','O','Ba']`` will return ``[[1,'Ba'],[1,'Ti'],[3,'O'],[1,'Ba']]``"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.group_symbols:9
msgid "``[ [ [1,'Ba'],[1,'Ti'] ],[ [1,'Ba'],[1,'Ti'] ] ]`` will return ``[[2, [ [1, 'Ba'], [1, 'Ti'] ] ]]``"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.group_symbols:12
msgid "a list of elements representing a chemical formula"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.group_symbols:13
msgid "a list of length-2 lists of the form [ multiplicity , element ]"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.has_ase:1
msgid "True if the ase module can be imported, False otherwise."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.has_pymatgen:1
msgid "True if the pymatgen module can be imported, False otherwise."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.has_spglib:1
msgid "True if the spglib module can be imported, False otherwise."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.has_vacancies:1
msgid "Returns True if the sum of the weights is less than one. It uses the internal variable _SUM_THRESHOLD as a threshold. :param weights: the weights :return: a boolean"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.is_ase_atoms:1
msgid "Check if the ase_atoms parameter is actually a ase.Atoms object."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.is_ase_atoms:3
msgid "an object, expected to be an ase.Atoms."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.is_ase_atoms:4
msgid "a boolean."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.is_ase_atoms:6
msgid "Requires the ability to import ase, by doing 'import ase'."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.is_valid_symbol:1
msgid "Validates the chemical symbol name."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.is_valid_symbol:3
msgid "True if the symbol is a valid chemical symbol (with correct capitalization), or the dummy X, False otherwise."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.is_valid_symbol:6
msgid "Recognized symbols are for elements from hydrogen (Z=1) to lawrencium (Z=103). In addition, a dummy element unknown name (Z=0) is supported."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.symop_fract_from_ortho:1
msgid "Creates a matrix for conversion from fractional to orthogonal coordinates."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.symop_fract_from_ortho:4
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.symop_ortho_from_fract:4
msgid "Taken from svn://www.crystallography.net/cod-tools/trunk/lib/perl5/Fractional.pm, revision 850."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.symop_fract_from_ortho:8
#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.symop_ortho_from_fract:8
msgid "array of cell parameters (three lengths and three angles)"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.symop_ortho_from_fract:1
msgid "Creates a matrix for conversion from orthogonal to fractional coordinates."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.validate_symbols_tuple:1
msgid "Used to validate whether the chemical species are valid."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.validate_symbols_tuple:3
msgid "a tuple (or list) with the chemical symbols name."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.validate_symbols_tuple:4
msgid "UnsupportedSpeciesError if any symbol in the tuple is not a valid chemical symbol (with correct capitalization)."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.validate_symbols_tuple:7
msgid "Refer also to the documentation of :func:is_valid_symbol"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.validate_weights_tuple:1
msgid "Validates the weight of the atomic kinds."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.validate_weights_tuple:3
msgid "ValueError if the weights_tuple is not valid."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.validate_weights_tuple:5
msgid "the tuple to validate. It must be a a tuple of floats (as created by :func:_create_weights_tuple)."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.validate_weights_tuple:7
msgid "a float number used as a threshold to check that the sum of the weights is <= 1."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/structure.py:docstring of aiida.orm.nodes.data.structure.validate_weights_tuple:10
msgid "If the sum is less than one, it means that there are vacancies. Each element of the list must be >= 0, and the sum must be <= 1."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/upf.py:docstring of aiida.orm.nodes.data.upf:1
msgid "Module of `Data` sub class to represent a pseudopotential single file in UPF format and related utilities."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/upf.py:docstring of aiida.orm.nodes.data.upf.UpfData:1
msgid "`Data` sub class to represent a pseudopotential single file in UPF format."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/upf.py:docstring of aiida.orm.nodes.data.upf.UpfData._prepare_json:1
msgid "Returns UPF PP in json format."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/upf.py:docstring of aiida.orm.nodes.data.upf.UpfData._prepare_upf:1
msgid "Return UPF content."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/upf.py:docstring of aiida.orm.nodes.data.upf.UpfData._validate:1
msgid "Validate the UPF potential file stored for this node."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/upf.py:docstring of aiida.orm.nodes.data.upf.UpfData.element:1
#: ../../../src/aiida/orm/nodes/data/upf.py:docstring of aiida.restapi.translator.nodes.data.upf.UpfDataTranslator.UpfData.element:1
msgid "Return the element of the UPF pseudopotential."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/upf.py:docstring of aiida.orm.nodes.data.upf.UpfData.element:3
#: ../../../src/aiida/orm/nodes/data/upf.py:docstring of aiida.restapi.translator.nodes.data.upf.UpfDataTranslator.UpfData.element:3
msgid "the element"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/upf.py:docstring of aiida.orm.nodes.data.upf.UpfData.from_md5:1
msgid "Return a list of all `UpfData` that match the given md5 hash."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/upf.py:docstring of aiida.orm.nodes.data.upf.UpfData.from_md5:3
msgid "assumes hash of stored `UpfData` nodes is stored in the `md5` attribute"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/upf.py:docstring of aiida.orm.nodes.data.upf.UpfData.from_md5:5
msgid "the file hash"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/upf.py:docstring of aiida.orm.nodes.data.upf.UpfData.from_md5:6
msgid "list of existing `UpfData` nodes that have the same md5 hash"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/upf.py:docstring of aiida.orm.nodes.data.upf.UpfData.get_or_create:1
msgid "Get the `UpfData` with the same md5 of the given file, or create it if it does not yet exist."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/upf.py:docstring of aiida.orm.nodes.data.upf.UpfData.get_or_create:3
msgid "an absolute filepath on disk"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/upf.py:docstring of aiida.orm.nodes.data.upf.UpfData.get_or_create:4
msgid "if False (default), raise an exception if more than one potential is found. If it is True, instead, use the first available pseudopotential."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/upf.py:docstring of aiida.orm.nodes.data.upf.UpfData.get_or_create:6
msgid "boolean, if false, the `UpfData` if created will not be stored."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/upf.py:docstring of aiida.orm.nodes.data.upf.UpfData.get_or_create:7
msgid "tuple of `UpfData` and boolean indicating whether it was created."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/upf.py:docstring of aiida.orm.nodes.data.upf.UpfData.get_upf_family_names:1
msgid "Get the list of all upf family names to which the pseudo belongs."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/upf.py:docstring of aiida.orm.nodes.data.upf.UpfData.get_upf_group:1
msgid "Return the UPF family group with the given label."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/upf.py:docstring of aiida.orm.nodes.data.upf.UpfData.get_upf_group:3
msgid "the family group label"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/upf.py:docstring of aiida.orm.nodes.data.upf.UpfData.get_upf_group:4
msgid "the `Group` with the given label, if it exists"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/upf.py:docstring of aiida.orm.nodes.data.upf.UpfData.get_upf_groups:1
msgid "Return all names of groups of type UpfFamily, possibly with some filters."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/upf.py:docstring of aiida.orm.nodes.data.upf.UpfData.get_upf_groups:3
msgid "A string or a list of strings. If present, returns only the groups that contains one UPF for every element present in the list. The default is `None`, meaning that all families are returned."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/upf.py:docstring of aiida.orm.nodes.data.upf.UpfData.get_upf_groups:6
msgid "if None (default), return the groups for all users. If defined, it should be either a `User` instance or the user email."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/upf.py:docstring of aiida.orm.nodes.data.upf.UpfData.get_upf_groups:8
msgid "list of `Group` entities of type UPF."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/upf.py:docstring of aiida.orm.nodes.data.upf.UpfData.md5sum:1
#: ../../../src/aiida/orm/nodes/data/upf.py:docstring of aiida.restapi.translator.nodes.data.upf.UpfDataTranslator.UpfData.md5sum:1
msgid "Return the md5 checksum of the UPF pseudopotential file."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/upf.py:docstring of aiida.orm.nodes.data.upf.UpfData.md5sum:3
#: ../../../src/aiida/orm/nodes/data/upf.py:docstring of aiida.restapi.translator.nodes.data.upf.UpfDataTranslator.UpfData.md5sum:3
msgid "the md5 checksum"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/upf.py:docstring of aiida.orm.nodes.data.upf.UpfData.set_file:1
msgid "Store the file in the repository and parse it to set the `element` and `md5` attributes."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/upf.py:docstring of aiida.orm.nodes.data.upf.UpfData.set_file:3
msgid "filepath or filelike object of the UPF potential file to store. Hint: Pass io.BytesIO(b\"my string\") to construct the file directly from a string."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/upf.py:docstring of aiida.orm.nodes.data.upf.UpfData.store:1
msgid "Store the node, reparsing the file so that the md5 and the element are correctly reset."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/upf.py:docstring of aiida.orm.nodes.data.upf.get_pseudos_from_structure:1
msgid "Return a dictionary mapping each kind name of the structure to corresponding `UpfData` from given family."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/upf.py:docstring of aiida.orm.nodes.data.upf.get_pseudos_from_structure:3
msgid "a `StructureData`"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/upf.py:docstring of aiida.orm.nodes.data.upf.get_pseudos_from_structure:4
msgid "the name of a UPF family group"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/upf.py:docstring of aiida.orm.nodes.data.upf.get_pseudos_from_structure:5
msgid "dictionary mapping each structure kind name onto `UpfData` of corresponding element"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/upf.py:docstring of aiida.orm.nodes.data.upf.get_pseudos_from_structure:6
msgid "if more than one UPF for the same element is found in the group."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/upf.py:docstring of aiida.orm.nodes.data.upf.get_pseudos_from_structure:7
msgid "if no UPF for an element in the group is found in the group."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/upf.py:docstring of aiida.orm.nodes.data.upf.parse_upf:1
msgid "Try to get relevant information from the UPF. For the moment, only the element name. Note that even UPF v.2 cannot be parsed with the XML minidom! (e.g. due to the & characters in the human-readable section)."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/upf.py:docstring of aiida.orm.nodes.data.upf.parse_upf:5
msgid "If check_filename is True, raise a ParsingError exception if the filename does not start with the element name."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/upf.py:docstring of aiida.orm.nodes.data.upf.upload_upf_family:1
msgid "Upload a set of UPF files in a given group."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/upf.py:docstring of aiida.orm.nodes.data.upf.upload_upf_family:3
msgid "a path containing all UPF files to be added. Only files ending in .UPF (case-insensitive) are considered."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/upf.py:docstring of aiida.orm.nodes.data.upf.upload_upf_family:5
msgid "the name of the group to create. If it exists and is non-empty, a UniquenessError is raised."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/upf.py:docstring of aiida.orm.nodes.data.upf.upload_upf_family:6
msgid "string to be set as the group description. Overwrites previous descriptions."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/upf.py:docstring of aiida.orm.nodes.data.upf.upload_upf_family:7
msgid "if True, check for the md5 of the files and, if the file already exists in the DB, raises a MultipleObjectsError. If False, simply adds the existing UPFData node to the group."
msgstr ""

#: ../../source/reference/apidoc/aiida.orm.nodes.data.array.rst:2
msgid "aiida.orm.nodes.data.array package"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/__init__.py:docstring of aiida.orm.nodes.data.array:1
msgid "Module with `Node` sub classes for array based data structures."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/array.py:docstring of aiida.orm.nodes.data.array.array:1
msgid "AiiDA ORM data class storing (numpy) arrays"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/array.py:docstring of aiida.orm.nodes.data.array.array.ArrayData:1
msgid "Store a set of arrays on disk (rather than on the database) in an efficient way"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/array.py:docstring of aiida.orm.nodes.data.array.array.ArrayData:3
msgid "Arrays are stored using numpy and therefore this class requires numpy to be installed."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/array.py:docstring of aiida.orm.nodes.data.array.array.ArrayData:5
msgid "Each array is stored within the Node folder as a different .npy file."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/array.py:docstring of aiida.orm.nodes.data.array.array.ArrayData:7
msgid "Before storing, no caching is done: if you perform a :py:meth:`.get_array` call, the array will be re-read from disk. If instead the ArrayData node has already been stored, the array is cached in memory after the first read, and the cached array is used thereafter. If too much RAM memory is used, you can clear the cache with the :py:meth:`.clear_internal_cache` method."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/array.py:docstring of aiida.orm.nodes.data.array.array.ArrayData.__init__:1
#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.__init__:1
msgid "Construct a new instance and set one or multiple numpy arrays."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/array.py:docstring of aiida.orm.nodes.data.array.array.ArrayData.__init__:3
#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.__init__:3
msgid "An optional single numpy array, or dictionary of numpy arrays to store."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/array.py:docstring of aiida.orm.nodes.data.array.array.ArrayData._arraynames_from_files:1
#: ../../../src/aiida/orm/nodes/data/array/array.py:docstring of aiida.orm.nodes.data.array.array.ArrayData.get_arraynames:1
msgid "Return a list of all arrays stored in the node, listing the files (and not relying on the properties)."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/array.py:docstring of aiida.orm.nodes.data.array.array.ArrayData._arraynames_from_properties:1
msgid "Return a list of all arrays stored in the node, listing the attributes starting with the correct prefix."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/array.py:docstring of aiida.orm.nodes.data.array.array.ArrayData._get_array_entries:1
msgid "Return a dictionary with the different array entries."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/array.py:docstring of aiida.orm.nodes.data.array.array.ArrayData._get_array_entries:3
msgid "The idea is that this dictionary contains the array name as a key and the value is the numpy array transformed into a list. This is so that it can be transformed into a json object."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/array.py:docstring of aiida.orm.nodes.data.array.array.ArrayData._prepare_json:1
msgid "Dump the content of the arrays stored in this node into JSON format."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/array.py:docstring of aiida.orm.nodes.data.array.array.ArrayData._prepare_json:3
msgid "if True, includes comments (if it makes sense for the given format)"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/array.py:docstring of aiida.orm.nodes.data.array.array.ArrayData._validate:1
msgid "Check if the list of .npy files stored inside the node and the list of properties match. Just a name check, no check on the size since this would require to reload all arrays and this may take time and memory."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/array.py:docstring of aiida.orm.nodes.data.array.array.ArrayData.clear_internal_cache:1
msgid "Clear the internal memory cache where the arrays are stored after being read from disk (used in order to reduce at minimum the readings from disk). This function is useful if you want to keep the node in memory, but you do not want to waste memory to cache the arrays in RAM."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/array.py:docstring of aiida.orm.nodes.data.array.array.ArrayData.delete_array:1
msgid "Delete an array from the node. Can only be called before storing."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/array.py:docstring of aiida.orm.nodes.data.array.array.ArrayData.delete_array:3
msgid "The name of the array to delete from the node."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/array.py:docstring of aiida.orm.nodes.data.array.array.ArrayData.get_array:1
msgid "Return an array stored in the node"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/array.py:docstring of aiida.orm.nodes.data.array.array.ArrayData.get_array:3
msgid "The name of the array to return. The name can be omitted in case the node contains only a single array, which will be returned in that case. If ``name`` is ``None`` and the node contains multiple arrays or no arrays at all a ``ValueError`` is raised."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/array.py:docstring of aiida.orm.nodes.data.array.array.ArrayData.get_array:6
msgid "If ``name`` is ``None`` and the node contains more than one arrays or no arrays at all."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/array.py:docstring of aiida.orm.nodes.data.array.array.ArrayData.get_arraynames:4
msgid "Renamed from arraynames"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/array.py:docstring of aiida.orm.nodes.data.array.array.ArrayData.get_iterarrays:1
msgid "Iterator that returns tuples (name, array) for each array stored in the node."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/array.py:docstring of aiida.orm.nodes.data.array.array.ArrayData.get_iterarrays:3
msgid "Renamed from iterarrays"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/array.py:docstring of aiida.orm.nodes.data.array.array.ArrayData.get_shape:1
msgid "Return the shape of an array (read from the value cached in the properties for efficiency reasons)."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/array.py:docstring of aiida.orm.nodes.data.array.array.ArrayData.get_shape:4
#: ../../../src/aiida/orm/nodes/data/array/array.py:docstring of aiida.orm.nodes.data.array.array.ArrayData.set_array:6
msgid "The name of the array."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/array.py:docstring of aiida.orm.nodes.data.array.array.ArrayData.set_array:1
msgid "Store a new numpy array inside the node. Possibly overwrite the array if it already existed."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/array.py:docstring of aiida.orm.nodes.data.array.array.ArrayData.set_array:4
msgid "Internally, it stores a name.npy file in numpy format."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/array.py:docstring of aiida.orm.nodes.data.array.array.ArrayData.set_array:7
msgid "The numpy array to store."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/array.py:docstring of aiida.orm.nodes.data.array.array.clean_array:1
msgid "Replacing np.nan and np.inf/-np.inf for Nones."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/array.py:docstring of aiida.orm.nodes.data.array.array.clean_array:3
msgid "The function will also sanitize the array removing ``np.nan`` and ``np.inf`` for ``None`` of this way the resulting JSON is always valid. Both ``np.nan`` and ``np.inf``/``-np.inf`` are set to None to be in accordance with the `ECMA-262 standard <https://www.ecma-international.org/publications-and-standards/standards/ecma-262/>`_."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/array.py:docstring of aiida.orm.nodes.data.array.array.clean_array:9
msgid "input array to be cleaned"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/array.py:docstring of aiida.orm.nodes.data.array.array.clean_array:10
msgid "cleaned list to be serialized"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands:1
msgid "This module defines the classes related to band structures or dispersions in a Brillouin zone, and how to operate on them."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData:1
msgid "Bases: :py:class:`~aiida.orm.nodes.data.array.kpoints.KpointsData`"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData:1
msgid "Class to handle bands data"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData._get_band_segments:1
msgid "Return the band segments."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData._get_bandplot_data:1
msgid "Get data to plot a band structure"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData._get_bandplot_data:3
msgid "if True, distances (for the x-axis) are computed in cartesian coordinates, otherwise they are computed in reciprocal coordinates. cartesian=True will fail if no cell has been set."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData._get_bandplot_data:6
msgid "by default, strings are not prettified. If you want to prettify them, pass a valid prettify_format string (see valid options in the docstring of :py:func:prettify_labels)."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData._get_bandplot_data:9
msgid "by default, strings are not joined. If you pass a string, this is used to join strings that are much closer than a given threshold. The most typical string is the pipe symbol: ``|``."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData._get_bandplot_data:12
msgid "if True, also computes the band split into segments"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData._get_bandplot_data:13
msgid "if present, shift bands so to set the value specified at ``y=0``"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData._get_bandplot_data:14
msgid "a plot_info dictiorary, whose keys are ``x`` (array of distances for the x axis of the plot); ``y`` (array of bands), ``labels`` (list of tuples in the format (float x value of the label, label string), ``band_type_idx`` (array containing an index for each band: if there is only one spin, then it's an array of zeros, of length equal to the number of bands at each point; if there are two spins, then it's an array of zeros or ones depending on the type of spin; the length is always equalt to the total number of bands per kpoint)."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData._get_mpl_body_template:1
msgid "paths of k-points"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData._matplotlib_get_dict:1
msgid "Prepare the data to send to the python-matplotlib plotting script."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData._matplotlib_get_dict:3
#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData._prepare_agr:3
#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData._prepare_agr_batch:8
#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData._prepare_dat_blocks:5
#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData._prepare_dat_multicolumn:5
#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData._prepare_gnuplot:9
#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData._prepare_json:3
msgid "if True, print comments (if it makes sense for the given format)"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData._matplotlib_get_dict:5
#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData._prepare_agr:5
msgid "a dictionary"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData._matplotlib_get_dict:6
#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData._prepare_agr:6
msgid "an offset to be applied to all set numbers (i.e. s0 is replaced by s[offset], s1 by s[offset+1], etc.)"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData._matplotlib_get_dict:8
#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData._prepare_agr:8
msgid "the color number for lines, symbols, error bars and filling (should be less than the parameter MAX_NUM_AGR_COLORS defined below)"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData._matplotlib_get_dict:11
#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData._prepare_agr:15
msgid "the title"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData._matplotlib_get_dict:12
msgid "the legend (applied only to the first of the set)"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData._matplotlib_get_dict:13
msgid "the legend for second-type spins (applied only to the first of the set)"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData._matplotlib_get_dict:15
msgid "the maximum on the y axis (if None, put the maximum of the bands)"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData._matplotlib_get_dict:17
msgid "the minimum on the y axis (if None, put the minimum of the bands)"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData._matplotlib_get_dict:19
#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData._prepare_agr:22
msgid "the new origin of the y axis -> all bands are replaced by bands-y_origin"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData._matplotlib_get_dict:21
#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData._prepare_agr:24
#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData._prepare_agr_batch:10
#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData._prepare_gnuplot:11
msgid "if None, use the default prettify format. Otherwise specify a string with the prettifier to use."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData._matplotlib_get_dict:23
msgid "additional customization variables; only a subset is accepted, see internal variable 'valid_additional_keywords"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData._prepare_agr:1
msgid "Prepare an xmgrace agr file."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData._prepare_agr:11
msgid "the color number for lines, symbols, error bars and filling for the second-type spins (should be less than the parameter MAX_NUM_AGR_COLORS defined below)"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData._prepare_agr:14
msgid "the legend (applied only to the first set)"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData._prepare_agr:16
msgid "the maximum on the y axis (if None, put the maximum of the bands); applied *after* shifting the origin by ``y_origin``"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData._prepare_agr:19
msgid "the minimum on the y axis (if None, put the minimum of the bands); applied *after* shifting the origin by ``y_origin``"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData._prepare_agr_batch:1
msgid "Prepare two files, data and batch, to be plot with xmgrace as: xmgrace -batch file.dat"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData._prepare_agr_batch:4
#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData._prepare_gnuplot:4
msgid "if the user asks to write the main content on a file, this contains the filename. This should be used to infer a good filename for the additional files. In this case, we remove the extension, and add '_data.dat'"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData._prepare_dat_blocks:1
msgid "Format suitable for gnuplot using blocks. Columns with x and y (path and band energy). Several blocks, separated by two empty lines, one per energy band."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData._prepare_dat_multicolumn:1
msgid "Write an N x M matrix. First column is the distance between kpoints, The other columns are the bands. Header contains number of kpoints and the number of bands (commented)."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData._prepare_gnuplot:1
msgid "Prepare an gnuplot script to plot the bands, with the .dat file returned as an independent file."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData._prepare_gnuplot:8
msgid "if specified, add a title to the plot"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData._prepare_json:1
msgid "Prepare a json file in a format compatible with the AiiDA band visualizer"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData._prepare_mpl_pdf:1
#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData._prepare_mpl_png:1
#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData._prepare_mpl_withjson:1
msgid "Prepare a python script using matplotlib to plot the bands, with the JSON returned as an independent file."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData._prepare_mpl_pdf:4
#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData._prepare_mpl_png:4
#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData._prepare_mpl_singlefile:3
#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData._prepare_mpl_withjson:4
msgid "For the possible parameters, see documentation of :py:meth:`~aiida.orm.nodes.data.array.bands.BandsData._matplotlib_get_dict`"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData._prepare_mpl_singlefile:1
msgid "Prepare a python script using matplotlib to plot the bands"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData._set_pbc:1
#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.orm.nodes.data.array.kpoints.KpointsData._set_pbc:1
msgid "Validate the pbc, then store them"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData._validate_bands_occupations:1
msgid "Validate the list of bands and of occupations before storage. Kpoints must be set in advance. Bands and occupations must be convertible into arrays of Nkpoints x Nbands floats or Nspins x Nkpoints x Nbands; Nkpoints must correspond to the number of kpoints."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData.array_labels:1
#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.restapi.translator.nodes.data.array.bands.BandsDataTranslator.BandsData.array_labels:1
msgid "Get the labels associated with the band arrays"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData.get_bands:1
msgid "Returns an array (nkpoints x num_bands or nspins x nkpoints x num_bands) of energies. :param also_occupations: if True, returns also the occupations array. Default = False"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData.set_bands:1
msgid "Set an array of band energies of dimension (nkpoints x nbands). Kpoints must be set in advance. Can contain floats or None. :param bands: a list of nkpoints lists of nbands bands, or a 2D array of shape (nkpoints x nbands), with band energies for each kpoint :param units: optional, energy units :param occupations: optional, a 2D list or array of floats of same shape as bands, with the occupation associated to each band"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData.set_kpointsdata:1
msgid "Load the kpoints from a kpoint object. :param kpointsdata: an instance of KpointsData class"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData.show_mpl:1
msgid "Call a show() command for the band structure using matplotlib. This uses internally the 'mpl_singlefile' format, with empty main_file_name."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData.show_mpl:5
msgid "Other kwargs are passed to self._exportcontent."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.BandsData.units:1
#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.restapi.translator.nodes.data.array.bands.BandsDataTranslator.BandsData.units:1
msgid "Units in which the data in bands were stored. A string"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands._extract_formula:1
msgid "Extract formula from the structure object."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands._extract_formula:3
msgid "list of kinds, e.g. [{'mass': 55.845, 'name': 'Fe', 'symbols': ['Fe'], 'weights': [1.0]}, {'mass': 15.9994, 'name': 'O', 'symbols': ['O'], 'weights': [1.0]}]"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands._extract_formula:5
msgid "list of structure sites e.g. [{'position': [0.0, 0.0, 0.0], 'kind_name': 'Fe'}, {'position': [2.0, 2.0, 2.0], 'kind_name': 'O'}]"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands._extract_formula:7
msgid "a namespace with parsed command line parameters, here only 'element' and 'element_only' are used"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands._extract_formula:10
msgid "a string with formula if the formula is found"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.find_bandgap:1
msgid "Tries to guess whether the bandsdata represent an insulator. This method is meant to be used only for electronic bands (not phonons) By default, it will try to use the occupations to guess the number of electrons and find the Fermi Energy, otherwise, it can be provided explicitely. Also, there is an implicit assumption that the kpoints grid is \"sufficiently\" dense, so that the bandsdata are not missing the intersection between valence and conduction band if present. Use this function with care!"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.find_bandgap:11
msgid "(optional, float) number of electrons in the unit cell"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.find_bandgap:12
msgid "(optional, float) value of the fermi energy."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.find_bandgap:14
msgid "By default, the algorithm uses the occupations array to guess the number of electrons and the occupied bands. This is to be used with care, because the occupations could be smeared so at a non-zero temperature, with the unwanted effect that the conduction bands might be occupied in an insulator. Prefer to pass the number_of_electrons explicitly"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.find_bandgap:21
msgid "Only one between number_electrons and fermi_energy can be specified at the same time."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.find_bandgap:24
msgid "(is_insulator, gap), where is_insulator is a boolean, and gap a float. The gap is None in case of a metal, zero when the homo is equal to the lumo (e.g. in semi-metals)."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.get_bands_and_parents_structure:1
msgid "Search for bands and return bands and the closest structure that is a parent of the instance."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.get_bands_and_parents_structure:3
msgid "A list of sublists, each latter containing (in order):     pk as string, formula as string, creation date, bandsdata-label"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.get_bands_and_parents_structure:4
msgid "A list of sublists, each latter containing (in order):"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.get_bands_and_parents_structure:5
msgid "pk as string, formula as string, creation date, bandsdata-label"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/bands.py:docstring of aiida.orm.nodes.data.array.bands.prepare_header_comment:1
msgid "Prepare the header."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.orm.nodes.data.array.kpoints:1
msgid "Module of the KpointsData class, defining the AiiDA data type for storing lists and meshes of k-points (i.e., points in the reciprocal space of a periodic crystal structure)."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.orm.nodes.data.array.kpoints.KpointsData:1
#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData:1
#: ../../../src/aiida/orm/nodes/data/array/xy.py:docstring of aiida.orm.nodes.data.array.xy.XyData:1
msgid "Bases: :py:class:`~aiida.orm.nodes.data.array.array.ArrayData`"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.orm.nodes.data.array.kpoints.KpointsData:1
msgid "Class to handle array of kpoints in the Brillouin zone. Provide methods to generate either user-defined k-points or path of k-points along symmetry lines. Internally, all k-points are defined in terms of crystal (fractional) coordinates. Cell and lattice vector coordinates are in Angstroms, reciprocal lattice vectors in Angstrom^-1 . :note: The methods setting and using the Bravais lattice info assume the PRIMITIVE unit cell is provided in input to the set_cell or set_cell_from_structure methods."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.orm.nodes.data.array.kpoints.KpointsData._change_reference:1
msgid "Change reference system, from cartesian to crystal coordinates (units of b1,b2,b3) or viceversa. :param kpoints: a list of (3) point coordinates :return kpoints: a list of (3) point coordinates in the new reference"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.orm.nodes.data.array.kpoints.KpointsData._dimension:1
#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.restapi.translator.nodes.data.kpoints.KpointsDataTranslator.KpointsData._dimension:1
msgid "Dimensionality of the structure, found from its pbc (i.e. 1 if it's a 1D structure, 2 if its 2D, 3 if it's 3D ...). :return dimensionality: 0, 1, 2 or 3 :note: will return 3 if pbc has not been set beforehand"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.orm.nodes.data.array.kpoints.KpointsData._set_cell:1
msgid "Validate if 'value' is a allowed crystal unit cell :param value: something compatible with a 3x3 tuple of floats"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.orm.nodes.data.array.kpoints.KpointsData._set_labels:1
msgid "Set label names. Must pass in input a list like: ``[[0,'X'],[34,'L'],... ]``"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.orm.nodes.data.array.kpoints.KpointsData._validate_kpoints_weights:1
msgid "Validate the list of kpoints and of weights before storage. Kpoints and weights must be convertible respectively to an array of N x dimension and N floats"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.orm.nodes.data.array.kpoints.KpointsData.cell:1
#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.restapi.translator.nodes.data.kpoints.KpointsDataTranslator.KpointsData.cell:1
msgid "The crystal unit cell. Rows are the crystal vectors in Angstroms. :return: a 3x3 numpy.array"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.orm.nodes.data.array.kpoints.KpointsData.get_description:1
msgid "Returns a string with infos retrieved from  kpoints node's properties. :param node: :return: retstr"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.orm.nodes.data.array.kpoints.KpointsData.get_kpoints:1
msgid "Return the list of kpoints"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.orm.nodes.data.array.kpoints.KpointsData.get_kpoints:3
msgid "if True, returns also the list of weights. Default = False"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.orm.nodes.data.array.kpoints.KpointsData.get_kpoints:5
msgid "if True, returns points in cartesian coordinates, otherwise, returns in crystal coordinates. Default = False."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.orm.nodes.data.array.kpoints.KpointsData.get_kpoints_mesh:1
msgid "Get the mesh of kpoints."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.orm.nodes.data.array.kpoints.KpointsData.get_kpoints_mesh:3
msgid "default=False. If True, prints the mesh of kpoints as a list"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.orm.nodes.data.array.kpoints.KpointsData.get_kpoints_mesh:5
msgid "if no mesh has been set"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.orm.nodes.data.array.kpoints.KpointsData.get_kpoints_mesh:0
msgid "return mesh,offset"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.orm.nodes.data.array.kpoints.KpointsData.get_kpoints_mesh:6
msgid "(if print_list=False) a list of 3 integers and a list of three floats 0<x<1, representing the mesh and the offset of kpoints"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.orm.nodes.data.array.kpoints.KpointsData.get_kpoints_mesh:0
#: ../../../src/aiida/tools/data/array/kpoints/legacy.py:docstring of aiida.tools.data.array.kpoints.legacy.change_reference:0
msgid "return kpoints"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.orm.nodes.data.array.kpoints.KpointsData.get_kpoints_mesh:8
msgid "(if print_list = True) an explicit list of kpoints coordinates, similar to what returned by get_kpoints()"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.orm.nodes.data.array.kpoints.KpointsData.labels:1
#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.restapi.translator.nodes.data.kpoints.KpointsDataTranslator.KpointsData.labels:1
msgid "Labels associated with the list of kpoints. List of tuples with kpoint index and kpoint name: ``[(0,'G'),(13,'M'),...]``"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.orm.nodes.data.array.kpoints.KpointsData.pbc:1
#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.restapi.translator.nodes.data.kpoints.KpointsDataTranslator.KpointsData.pbc:1
msgid "The periodic boundary conditions along the vectors a1,a2,a3."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.orm.nodes.data.array.kpoints.KpointsData.reciprocal_cell:1
#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.restapi.translator.nodes.data.kpoints.KpointsDataTranslator.KpointsData.reciprocal_cell:1
msgid "Compute reciprocal cell from the internally set cell."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.orm.nodes.data.array.kpoints.KpointsData.reciprocal_cell:3
#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.restapi.translator.nodes.data.kpoints.KpointsDataTranslator.KpointsData.reciprocal_cell:3
msgid "reciprocal cell in units of 1/Angstrom with cell vectors stored as rows. Use e.g. reciprocal_cell[0] to access the first reciprocal cell vector."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.orm.nodes.data.array.kpoints.KpointsData.set_cell:1
msgid "Set a cell to be used for symmetry analysis. To set a cell from an AiiDA structure, use \"set_cell_from_structure\"."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.orm.nodes.data.array.kpoints.KpointsData.set_cell:4
msgid "3x3 matrix of cell vectors. Orientation: each row represent a lattice vector. Units are Angstroms."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.orm.nodes.data.array.kpoints.KpointsData.set_cell:6
msgid "list of 3 booleans, True if in the nth crystal direction the structure is periodic. Default = [True,True,True]"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.orm.nodes.data.array.kpoints.KpointsData.set_cell_from_structure:1
msgid "Set a cell to be used for symmetry analysis from an AiiDA structure. Inherits both the cell and the pbc's. To set manually a cell, use \"set_cell\""
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.orm.nodes.data.array.kpoints.KpointsData.set_cell_from_structure:5
msgid "an instance of StructureData"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.orm.nodes.data.array.kpoints.KpointsData.set_kpoints:1
msgid "Set the list of kpoints. If a mesh has already been stored, raise a ModificationNotAllowed"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.orm.nodes.data.array.kpoints.KpointsData.set_kpoints:3
msgid "a list of kpoints, each kpoint being a list of one, two or three coordinates, depending on self.pbc: if structure is 1D (only one True in self.pbc) one allows singletons or scalars for each k-point, if it's 2D it can be a length-2 list, and in all cases it can be a length-3 list."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.orm.nodes.data.array.kpoints.KpointsData.set_kpoints:12
msgid "[[0.,0.,0.],[0.1,0.1,0.1],...] for 1D, 2D or 3D"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.orm.nodes.data.array.kpoints.KpointsData.set_kpoints:13
msgid "[[0.,0.],[0.1,0.1,],...] for 1D or 2D"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.orm.nodes.data.array.kpoints.KpointsData.set_kpoints:14
msgid "[[0.],[0.1],...] for 1D"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.orm.nodes.data.array.kpoints.KpointsData.set_kpoints:15
msgid "[0., 0.1, ...] for 1D (list of scalars)"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.orm.nodes.data.array.kpoints.KpointsData.set_kpoints:17
msgid "For 0D (all pbc are False), the list can be any of the above or empty - then only Gamma point is set. The value of k for the non-periodic dimension(s) is set by fill_values"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.orm.nodes.data.array.kpoints.KpointsData.set_kpoints:0
msgid "param cartesian"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.orm.nodes.data.array.kpoints.KpointsData.set_kpoints:22
msgid "if True, the coordinates given in input are treated as in cartesian units. If False, the coordinates are crystal, i.e. in units of b1,b2,b3. Default = False"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.orm.nodes.data.array.kpoints.KpointsData.set_kpoints:0
msgid "param labels"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.orm.nodes.data.array.kpoints.KpointsData.set_kpoints:25
msgid "optional, the list of labels to be set for some of the kpoints. See labels for more info"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.orm.nodes.data.array.kpoints.KpointsData.set_kpoints:0
msgid "param weights"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.orm.nodes.data.array.kpoints.KpointsData.set_kpoints:27
msgid "optional, a list of floats with the weight associated to the kpoint list"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.orm.nodes.data.array.kpoints.KpointsData.set_kpoints:0
msgid "param fill_values"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.orm.nodes.data.array.kpoints.KpointsData.set_kpoints:29
msgid "scalar to be set to all non-periodic dimensions (indicated by False in self.pbc), or list of values for each of the non-periodic dimensions."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.orm.nodes.data.array.kpoints.KpointsData.set_kpoints_mesh:1
msgid "Set KpointsData to represent a uniformily spaced mesh of kpoints in the Brillouin zone. This excludes the possibility of set/get kpoints"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.orm.nodes.data.array.kpoints.KpointsData.set_kpoints_mesh:4
msgid "a list of three integers, representing the size of the kpoint mesh along b1,b2,b3."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.orm.nodes.data.array.kpoints.KpointsData.set_kpoints_mesh:6
msgid "(optional) a list of three floats between 0 and 1. [0.,0.,0.] is Gamma centered mesh [0.5,0.5,0.5] is half shifted [1.,1.,1.] by periodicity should be equivalent to [0.,0.,0.] Default = [0.,0.,0.]."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.orm.nodes.data.array.kpoints.KpointsData.set_kpoints_mesh_from_density:1
msgid "Set a kpoints mesh using a kpoints density, expressed as the maximum distance between adjacent points along a reciprocal axis"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.orm.nodes.data.array.kpoints.KpointsData.set_kpoints_mesh_from_density:4
msgid "distance (in 1/Angstrom) between adjacent kpoints, i.e. the number of kpoints along each reciprocal axis i is :math:`|b_i|/distance` where :math:`|b_i|` is the norm of the reciprocal cell vector."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.orm.nodes.data.array.kpoints.KpointsData.set_kpoints_mesh_from_density:8
msgid "(optional) a list of three floats between 0 and 1. [0.,0.,0.] is Gamma centered mesh [0.5,0.5,0.5] is half shifted Default = [0.,0.,0.]."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.orm.nodes.data.array.kpoints.KpointsData.set_kpoints_mesh_from_density:12
msgid "(optional) if True, force each integer in the mesh to be even (except for the non-periodic directions)."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.orm.nodes.data.array.kpoints.KpointsData.set_kpoints_mesh_from_density:15
msgid "a cell should be defined first."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/kpoints.py:docstring of aiida.orm.nodes.data.array.kpoints.KpointsData.set_kpoints_mesh_from_density:16
msgid "the number of kpoints along non-periodic axes is always 1."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/projection.py:docstring of aiida.orm.nodes.data.array.projection:1
msgid "Data plugin to represet arrays of projected wavefunction components."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/projection.py:docstring of aiida.orm.nodes.data.array.projection.ProjectionData:1
msgid "Bases: :py:class:`~aiida.orm.nodes.data.orbital.OrbitalData`, :py:class:`~aiida.orm.nodes.data.array.array.ArrayData`"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/projection.py:docstring of aiida.orm.nodes.data.array.projection.ProjectionData:1
msgid "A class to handle arrays of projected wavefunction data. That is projections of a orbitals, usually an atomic-hydrogen orbital, onto a given bloch wavefunction, the bloch wavefunction being indexed by s, n, and k. E.g. the elements are the projections described as < orbital | Bloch wavefunction (s,n,k) >"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/projection.py:docstring of aiida.orm.nodes.data.array.projection.ProjectionData._check_projections_bands:1
msgid "Checks to make sure that a reference bandsdata is already set, and that projection_array is of the same shape of the bands data"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/projection.py:docstring of aiida.orm.nodes.data.array.projection.ProjectionData._check_projections_bands:4
msgid "nk x nb x nwfc array, to be checked against bands"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/projection.py:docstring of aiida.orm.nodes.data.array.projection.ProjectionData._check_projections_bands:7
msgid "AttributeError if energy is not already set"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/projection.py:docstring of aiida.orm.nodes.data.array.projection.ProjectionData._check_projections_bands:8
msgid "AttributeError if input_array is not of same shape as dos_energy"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/projection.py:docstring of aiida.orm.nodes.data.array.projection.ProjectionData._find_orbitals_and_indices:1
msgid "Finds all the orbitals and their indicies associated with kwargs essential for retrieving the other indexed array parameters"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/projection.py:docstring of aiida.orm.nodes.data.array.projection.ProjectionData._find_orbitals_and_indices:4
msgid "kwargs that can call orbitals as in get_orbitals()"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/projection.py:docstring of aiida.orm.nodes.data.array.projection.ProjectionData._find_orbitals_and_indices:5
msgid "retrieve_indexes, list of indicicies of orbitals corresponding to the kwargs"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/projection.py:docstring of aiida.orm.nodes.data.array.projection.ProjectionData._find_orbitals_and_indices:7
msgid "all_orbitals, list of orbitals to which the indexes correspond"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/projection.py:docstring of aiida.orm.nodes.data.array.projection.ProjectionData._from_index_to_arrayname:1
msgid "Used internally to determine the array names."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/projection.py:docstring of aiida.orm.nodes.data.array.projection.ProjectionData.get_pdos:1
#: ../../../src/aiida/orm/nodes/data/array/projection.py:docstring of aiida.orm.nodes.data.array.projection.ProjectionData.get_projections:1
msgid "Retrieves all the pdos arrays corresponding to the input kwargs"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/projection.py:docstring of aiida.orm.nodes.data.array.projection.ProjectionData.get_pdos:3
#: ../../../src/aiida/orm/nodes/data/array/projection.py:docstring of aiida.orm.nodes.data.array.projection.ProjectionData.get_projections:3
msgid "inputs describing the orbitals associated with the pdos arrays"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/projection.py:docstring of aiida.orm.nodes.data.array.projection.ProjectionData.get_pdos:5
msgid "a list of tuples containing the orbital, energy array and pdos array associated with all orbitals that correspond to kwargs"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/projection.py:docstring of aiida.orm.nodes.data.array.projection.ProjectionData.get_projections:5
msgid "a list of tuples containing the orbital, and projection arrays associated with all orbitals that correspond to kwargs"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/projection.py:docstring of aiida.orm.nodes.data.array.projection.ProjectionData.get_reference_bandsdata:1
msgid "Returns the reference BandsData, using the set uuid via set_reference_bandsdata"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/projection.py:docstring of aiida.orm.nodes.data.array.projection.ProjectionData.get_reference_bandsdata:4
msgid "a BandsData instance"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/projection.py:docstring of aiida.orm.nodes.data.array.projection.ProjectionData.get_reference_bandsdata:5
msgid "if the bandsdata has not been set yet"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/projection.py:docstring of aiida.orm.nodes.data.array.projection.ProjectionData.get_reference_bandsdata:6
msgid "if the bandsdata uuid did not retrieve bandsdata"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/projection.py:docstring of aiida.orm.nodes.data.array.projection.ProjectionData.set_orbitals:1
msgid "This method is inherited from OrbitalData, but is blocked here. If used will raise a NotImplementedError"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/projection.py:docstring of aiida.orm.nodes.data.array.projection.ProjectionData.set_projectiondata:1
msgid "Stores the projwfc_array using the projwfc_label, after validating both."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/projection.py:docstring of aiida.orm.nodes.data.array.projection.ProjectionData.set_projectiondata:3
msgid "list of orbitals, of class orbital data. They should be the ones up on which the projection array corresponds with."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/projection.py:docstring of aiida.orm.nodes.data.array.projection.ProjectionData.set_projectiondata:7
msgid "list of arrays of projections of a atomic wavefunctions onto bloch wavefunctions. Since the projection is for every bloch wavefunction which can be specified by its spin (if used), band, and kpoint the dimensions must be nspin x nbands x nkpoints for the projwfc array. Or nbands x nkpoints if spin is not used."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/projection.py:docstring of aiida.orm.nodes.data.array.projection.ProjectionData.set_projectiondata:15
msgid "list of energy axis for the list_of_pdos"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/projection.py:docstring of aiida.orm.nodes.data.array.projection.ProjectionData.set_projectiondata:17
msgid "a list of projected density of states for the atomic wavefunctions, units in states/eV"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/projection.py:docstring of aiida.orm.nodes.data.array.projection.ProjectionData.set_projectiondata:20
msgid "A list of tags, not supported currently."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/projection.py:docstring of aiida.orm.nodes.data.array.projection.ProjectionData.set_projectiondata:22
msgid "if false, skips checks of whether the bands has been already set, and whether the sizes match. For use in parsers, where the BandsData has not yet been stored and therefore get_reference_bandsdata cannot be called"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/projection.py:docstring of aiida.orm.nodes.data.array.projection.ProjectionData.set_reference_bandsdata:1
msgid "Sets a reference bandsdata, creates a uuid link between this data object and a bandsdata object, must be set before any projection arrays"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/projection.py:docstring of aiida.orm.nodes.data.array.projection.ProjectionData.set_reference_bandsdata:4
msgid "a BandsData instance, a uuid or a pk"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/projection.py:docstring of aiida.orm.nodes.data.array.projection.ProjectionData.set_reference_bandsdata:5
msgid "exceptions.NotExistent if there was no BandsData associated with uuid or pk"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory:1
msgid "AiiDA class to deal with crystal structure trajectories."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData:1
msgid "Stores a trajectory (a sequence of crystal structures with timestamps, and possibly with velocities)."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData._internal_validate:1
msgid "Internal function to validate the type and shape of the arrays. See the documentation of py:meth:`.set_trajectory` for a description of the valid shape and type of the parameters."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData._parse_xyz_pos:1
msgid "Load positions from a XYZ file."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData._parse_xyz_pos:3
msgid "The steps and symbols must be set manually before calling this import function as a consistency measure. Even though the symbols and steps could be extracted from the XYZ file, the data present in the XYZ file may or may not be correct and the same logic would have to be present in the XYZ-velocities function. It was therefore decided not to implement it at all but require it to be set explicitly."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData._parse_xyz_vel:1
msgid "Load velocities from a XYZ file."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData._parse_xyz_vel:3
msgid "The steps and symbols must be set manually before calling this import function as a consistency measure. See also comment for :py:meth:`._parse_xyz_pos`"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData._prepare_cif:1
msgid "Write the given trajectory to a string of format CIF."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData._prepare_xsf:1
msgid "Write the given trajectory to a string of format XSF (for XCrySDen)."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData._validate:1
msgid "Verify that the required arrays are present and that their type and dimension are correct."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.get_cells:1
msgid "Return the array of cells, if it has already been set."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.get_cells:3
#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.get_positions:3
#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.get_stepids:6
#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.get_times:3
#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.symbols:3
msgid "if the trajectory has not been set yet."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.get_cif:1
msgid "Creates :py:class:`aiida.orm.nodes.data.cif.CifData`"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.get_index_from_stepid:1
msgid "Given a value for the stepid (i.e., a value among those of the ``steps`` array), return the array index of that stepid, that can be used in other methods such as :py:meth:`.get_step_data` or :py:meth:`.get_step_structure`."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.get_index_from_stepid:6
msgid "Renamed from get_step_index"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.get_index_from_stepid:9
msgid "Note that this function returns the first index found (i.e. if multiple steps are present with the same value, only the index of the first one is returned)."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.get_index_from_stepid:13
msgid "if no step with the given value is found."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.get_positions:1
msgid "Return the array of positions, if it has already been set."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.get_step_data:1
msgid "Return a tuple with all information concerning the stepid with given index (0 is the first step, 1 the second step and so on). If you know only the step value, use the :py:meth:`.get_index_from_stepid` method to get the corresponding index."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.get_step_data:6
msgid "If no velocities, cells, or times were specified, None is returned as the corresponding element."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.get_step_data:9
msgid "A tuple in the format ``(stepid, time, cell, symbols, positions, velocities)``, where ``stepid`` is an integer, ``time`` is a float, ``cell`` is a :math:`3      imes 3` matrix, ``symbols`` is an array of length ``n``, positions is a :math:`n       imes 3` array, and velocities is either ``None`` or a :math:`n        imes 3` array"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.get_step_data:16
msgid "The index of the step that you want to retrieve, from 0 to ``self.numsteps - 1``."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.get_step_data:18
msgid "if you require an index beyond the limits."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.get_step_data:19
msgid "if you did not store the trajectory yet."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.get_step_structure:1
msgid "Return an AiiDA :py:class:`aiida.orm.nodes.data.structure.StructureData` node (not stored yet!) with the coordinates of the given step, identified by its index. If you know only the step value, use the :py:meth:`.get_index_from_stepid` method to get the corresponding index."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.get_step_structure:6
msgid "The periodic boundary conditions are always set to True."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.get_step_structure:8
msgid "Renamed from step_to_structure"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.get_step_structure:11
#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.get_structure:8
msgid "The index of the step that you want to retrieve, from 0 to ``self.numsteps- 1``."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.get_step_structure:13
#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.get_structure:10
msgid "(Optional) If passed must be a list of :py:class:`aiida.orm.nodes.data.structure.Kind` objects. There must be one kind object for each different string in the ``symbols`` array, with ``kind.name`` set to this string. If this parameter is omitted, the automatic kind generation of AiiDA :py:class:`aiida.orm.nodes.data.structure.StructureData` nodes is used, meaning that the strings in the ``symbols`` array must be valid chemical symbols."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.get_stepids:1
msgid "Return the array of steps, if it has already been set."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.get_stepids:3
msgid "Renamed from get_steps"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.get_structure:18
msgid "(Optional) The cell matrix of the structure. If omitted, the cell will be read from the trajectory, if present, otherwise the default cell of :py:class:`aiida.orm.nodes.data.structure.StructureData` will be used."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.get_times:1
msgid "Return the array of times (in ps), if it has already been set."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.get_velocities:1
msgid "Return the array of velocities, if it has already been set."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.get_velocities:3
msgid "This function (differently from all other ``get_*`` functions, will not raise an exception if the velocities are not set, but rather return ``None`` (both if no trajectory was not set yet, and if it the trajectory was set but no velocities were specified)."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.numsites:1
msgid "Return the number of stored sites, or zero if nothing has been stored yet."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.numsteps:1
msgid "Return the number of stored steps, or zero if nothing has been stored yet."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.set_structurelist:1
msgid "Create trajectory from the list of :py:class:`aiida.orm.nodes.data.structure.StructureData` instances."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.set_structurelist:4
msgid "a list of :py:class:`aiida.orm.nodes.data.structure.StructureData` instances."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.set_structurelist:7
msgid "if symbol lists of supplied structures are different"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.set_trajectory:1
msgid "Store the whole trajectory, after checking that types and dimensions are correct."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.set_trajectory:4
msgid "Parameters ``stepids``, ``cells`` and ``velocities`` are optional variables. If nothing is passed for ``cells`` or ``velocities`` nothing will be stored. However, if no input is given for ``stepids`` a consecutive sequence [0,1,2,...,len(positions)-1] will be assumed."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.set_trajectory:10
msgid "string list with dimension ``n``, where ``n`` is the number of atoms (i.e., sites) in the structure. The same list is used for each step. Normally, the string should be a valid chemical symbol, but actually any unique string works and can be used as the name of the atomic kind (see also the :py:meth:`.get_step_structure()` method)."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.set_trajectory:16
msgid "float array with dimension :math:`s \\times n \\times 3`, where ``s`` is the length of the ``stepids`` array and ``n`` is the length of the ``symbols`` array. Units are angstrom. In particular, ``positions[i,j,k]`` is the ``k``-th component of the ``j``-th atom (or site) in the structure at the time step with index ``i`` (identified by step number ``step[i]`` and with timestamp ``times[i]``)."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.set_trajectory:25
msgid "integer array with dimension ``s``, where ``s`` is the number of steps. Typically represents an internal counter within the code. For instance, if you want to store a trajectory with one step every 10, starting from step 65, the array will be ``[65,75,85,...]``. No checks are done on duplicate elements or on the ordering, but anyway this array should be sorted in ascending order, without duplicate elements. (If not specified, stepids will be set to ``numpy.arange(s)`` by default) It is internally stored as an array named 'steps'."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.set_trajectory:35
msgid "if specified float array with dimension :math:`s \\times 3 \\times 3`, where ``s`` is the length of the ``stepids`` array. Units are angstrom. In particular, ``cells[i,j,k]`` is the ``k``-th component of the ``j``-th cell vector at the time step with index ``i`` (identified by step number ``stepid[i]`` and with timestamp ``times[i]``)."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.set_trajectory:42
msgid "if specified, float array with dimension ``s``, where ``s`` is the length of the ``stepids`` array. Contains the timestamp of each step in picoseconds (ps)."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.set_trajectory:45
msgid "if specified, must be a float array with the same dimensions of the ``positions`` array. The array contains the velocities in the atoms."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.set_trajectory:49
msgid "Choose suitable units for velocities"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.show_mpl_heatmap:1
msgid "Show a heatmap of the trajectory with matplotlib."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.show_mpl_pos:1
msgid "Shows the positions as a function of time, separate for XYZ coordinates"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.show_mpl_pos:3
msgid "The stepsize for the trajectory, set higher than 1 to reduce number of points"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.show_mpl_pos:5
msgid "Time to start from"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.show_mpl_pos:6
msgid "Maximum time"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.show_mpl_pos:7
msgid "A list of atomic symbols that should be displayed. If not specified, all atoms are displayed."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.show_mpl_pos:10
msgid "A list of indices of that atoms that can be displayed. If not specified, all atoms of the correct species are displayed."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.show_mpl_pos:13
msgid "If True, interpreter is not blocked when figure is displayed."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.TrajectoryData.symbols:1
msgid "Return the array of symbols, if it has already been set."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.plot_positions_XYZ:1
msgid "Plot with matplotlib the positions of the coordinates of the atoms over time for a trajectory"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.plot_positions_XYZ:4
msgid "array of times"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.plot_positions_XYZ:5
msgid "array of positions"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.plot_positions_XYZ:6
msgid "list of indices of to show (0, 1, 2 for X, Y, Z)"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.plot_positions_XYZ:7
msgid "list of valid color specifications for matplotlib"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.plot_positions_XYZ:8
msgid "label for this plot to put in the title"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.plot_positions_XYZ:9
msgid "label for the units of positions (for the x label)"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.plot_positions_XYZ:10
msgid "label for the units of times (for the y label)"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.plot_positions_XYZ:11
msgid "passed to plt.show() as ``block=not dont_block``"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.plot_positions_XYZ:12
msgid "if specified, cut the time axis at the specified min value"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.plot_positions_XYZ:13
msgid "if specified, cut the time axis at the specified max value"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/trajectory.py:docstring of aiida.orm.nodes.data.array.trajectory.plot_positions_XYZ:14
msgid "how many labels (t, coord) to put"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/xy.py:docstring of aiida.orm.nodes.data.array.xy:1
msgid "This module defines the classes related to Xy data. That is data that contains collections of y-arrays bound to a single x-array, and the methods to operate on them."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/xy.py:docstring of aiida.orm.nodes.data.array.xy.XyData:1
msgid "A subclass designed to handle arrays that have an \"XY\" relationship to each other. That is there is one array, the X array, and there are several Y arrays, which can be considered functions of X."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/xy.py:docstring of aiida.orm.nodes.data.array.xy.XyData.__init__:1
msgid "Construct a new instance, optionally setting the x and y arrays."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/xy.py:docstring of aiida.orm.nodes.data.array.xy.XyData.__init__:3
msgid "If the ``x_array`` is specified, all other keywords need to be specified as well."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/xy.py:docstring of aiida.orm.nodes.data.array.xy.XyData.__init__:5
msgid "The x array."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/xy.py:docstring of aiida.orm.nodes.data.array.xy.XyData.__init__:6
msgid "The y arrays."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/xy.py:docstring of aiida.orm.nodes.data.array.xy.XyData.__init__:7
msgid "The name of the x array."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/xy.py:docstring of aiida.orm.nodes.data.array.xy.XyData.__init__:8
msgid "The unit of the x array."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/xy.py:docstring of aiida.orm.nodes.data.array.xy.XyData.__init__:9
msgid "The names of the y arrays."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/xy.py:docstring of aiida.orm.nodes.data.array.xy.XyData.__init__:10
msgid "The units of the y arrays."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/xy.py:docstring of aiida.orm.nodes.data.array.xy.XyData._arrayandname_validator:1
msgid "Validates that the array is an numpy.ndarray and that the name is of type str. Raises TypeError or ValueError if this not the case."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/xy.py:docstring of aiida.orm.nodes.data.array.xy.XyData.get_x:1
msgid "Tries to retrieve the x array and x name raises a NotExistent exception if no x array has been set yet. :return x_name: the name set for the x_array :return x_array: the x array set earlier :return x_units: the x units set earlier"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/xy.py:docstring of aiida.orm.nodes.data.array.xy.XyData.get_y:1
msgid "Tries to retrieve the y arrays and the y names, raises a NotExistent exception if they have not been set yet, or cannot be retrieved :return y_names: list of strings naming the y_arrays :return y_arrays: list of y_arrays :return y_units: list of strings giving the units for the y_arrays"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/xy.py:docstring of aiida.orm.nodes.data.array.xy.XyData.set_x:1
msgid "Sets the array and the name for the x values."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/xy.py:docstring of aiida.orm.nodes.data.array.xy.XyData.set_x:3
msgid "A numpy.ndarray, containing only floats"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/xy.py:docstring of aiida.orm.nodes.data.array.xy.XyData.set_x:4
msgid "a string for the x array name"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/xy.py:docstring of aiida.orm.nodes.data.array.xy.XyData.set_x:5
msgid "the units of x"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/xy.py:docstring of aiida.orm.nodes.data.array.xy.XyData.set_y:1
msgid "Set array(s) for the y part of the dataset. Also checks if the x_array has already been set, and that, the shape of the y_arrays agree with the x_array. :param y_arrays: A list of y_arrays, numpy.ndarray :param y_names: A list of strings giving the names of the y_arrays :param y_units: A list of strings giving the units of the y_arrays"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/xy.py:docstring of aiida.orm.nodes.data.array.xy.check_convert_single_to_tuple:1
msgid "Checks if the item is a list or tuple, and converts it to a list if it is not already a list or tuple"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/xy.py:docstring of aiida.orm.nodes.data.array.xy.check_convert_single_to_tuple:4
msgid "an object which may or may not be a list or tuple"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/array/xy.py:docstring of aiida.orm.nodes.data.array.xy.check_convert_single_to_tuple:5
msgid "item_list: the input item unchanged if list or tuple and [item] otherwise"
msgstr ""

#: ../../source/reference/apidoc/aiida.orm.nodes.data.code.rst:2
msgid "aiida.orm.nodes.data.code package"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/__init__.py:docstring of aiida.orm.nodes.data.code:1
msgid "Data plugins that represent an executable code."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract:1
#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode:1
msgid "Abstract data plugin representing an executable code."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.__init__:3
#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.default_calc_job_plugin:3
#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.__init__:3
msgid "The entry point name of the default ``CalcJob`` plugin to use."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.__init__:4
#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.append_text:3
#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.__init__:4
msgid "The text that should be appended to the run line in the job script."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.__init__:5
#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.prepend_text:3
#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.__init__:5
msgid "The text that should be prepended to the run line in the job script."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.__init__:6
#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.__init__:6
msgid "Whether the command line invocation of this code should be escaped with double quotes."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.__init__:7
#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.__init__:7
msgid "Whether the command should be run as an MPI program."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.__init__:8
#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.__init__:8
msgid "Whether to wrap the executable and all its command line parameters into quotes to form a single string. This is required to enable support for Docker with the ``ContainerizedCode``."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.__init__:10
#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.__init__:10
msgid "Whether the code is hidden."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode._get_cli_options:1
#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.get_cli_options:1
#: ../../../src/aiida/orm/nodes/data/code/containerized.py:docstring of aiida.orm.nodes.data.code.containerized.ContainerizedCode._get_cli_options:1
#: ../../../src/aiida/orm/nodes/data/code/installed.py:docstring of aiida.orm.nodes.data.code.installed.InstalledCode._get_cli_options:1
#: ../../../src/aiida/orm/nodes/data/code/portable.py:docstring of aiida.orm.nodes.data.code.portable.PortableCode._get_cli_options:1
msgid "Return the CLI options that would allow to create an instance of this class."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.append_text:1
msgid "Return the text that should be appended to the run line in the job script."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.can_run_on_computer:1
#: ../../../src/aiida/orm/nodes/data/code/installed.py:docstring of aiida.orm.nodes.data.code.installed.InstalledCode.can_run_on_computer:1
#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.can_run_on_computer:1
#: ../../../src/aiida/orm/nodes/data/code/portable.py:docstring of aiida.orm.nodes.data.code.portable.PortableCode.can_run_on_computer:1
msgid "Return whether the code can run on a given computer."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.can_run_on_computer:4
#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.can_run_on_computer:4
msgid "``True`` if the code can run on ``computer``, ``False`` otherwise."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.default_calc_job_plugin:1
msgid "Return the optional default ``CalcJob`` plugin."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.full_label:1
#: ../../../src/aiida/orm/nodes/data/code/installed.py:docstring of aiida.orm.nodes.data.code.installed.InstalledCode.full_label:1
#: ../../../src/aiida/orm/nodes/data/code/portable.py:docstring of aiida.orm.nodes.data.code.portable.PortableCode.full_label:1
msgid "Return the full label of this code."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.full_label:3
#: ../../../src/aiida/orm/nodes/data/code/installed.py:docstring of aiida.orm.nodes.data.code.installed.InstalledCode.full_label:3
#: ../../../src/aiida/orm/nodes/data/code/portable.py:docstring of aiida.orm.nodes.data.code.portable.PortableCode.full_label:3
msgid "The full label can be just the label itself but it can be something else. However, it at the very least has to include the label of the code."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.full_label:6
#: ../../../src/aiida/orm/nodes/data/code/installed.py:docstring of aiida.orm.nodes.data.code.installed.InstalledCode.full_label:6
#: ../../../src/aiida/orm/nodes/data/code/portable.py:docstring of aiida.orm.nodes.data.code.portable.PortableCode.full_label:6
msgid "The full label of the code."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.get_builder:1
msgid "Create and return a new ``ProcessBuilder`` for the ``CalcJob`` class of the plugin configured for this code."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.get_builder:3
msgid "The configured calculation plugin class is defined by the ``default_calc_job_plugin`` property."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.get_builder:5
msgid "it also sets the ``builder.code`` value."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.get_builder:7
msgid "a ``ProcessBuilder`` instance with the ``code`` input already populated with ourselves"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.get_builder:8
msgid "if the specified plugin does not exist."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.get_builder:9
msgid "if no default plugin was specified."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.get_executable:1
#: ../../../src/aiida/orm/nodes/data/code/installed.py:docstring of aiida.orm.nodes.data.code.installed.InstalledCode.get_executable:1
#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.get_executable:1
#: ../../../src/aiida/orm/nodes/data/code/portable.py:docstring of aiida.orm.nodes.data.code.portable.PortableCode.get_executable:1
msgid "Return the executable that the submission script should execute to run the code."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.get_executable:3
#: ../../../src/aiida/orm/nodes/data/code/installed.py:docstring of aiida.orm.nodes.data.code.installed.InstalledCode.get_executable:3
#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.get_executable:3
#: ../../../src/aiida/orm/nodes/data/code/portable.py:docstring of aiida.orm.nodes.data.code.portable.PortableCode.get_executable:3
msgid "The executable to be called in the submission script."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.get_executable_cmdline_params:1
msgid "Return the list of executable with its command line parameters."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.get_executable_cmdline_params:3
msgid "List of command line parameters provided by the ``CalcJob`` plugin."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.get_executable_cmdline_params:4
msgid "List of the executable followed by its command line parameters."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.get_prepend_cmdline_params:1
msgid "Return List of command line parameters to be prepended to the executable in submission line. These command line parameters are typically parameters related to MPI invocations."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.get_prepend_cmdline_params:4
msgid "List of MPI parameters provided by the ``Computer.get_mpirun_command`` method."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.get_prepend_cmdline_params:5
msgid "List of MPI parameters provided by the ``metadata.options.extra_mpirun_params`` input of the ``CalcJob``."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.get_prepend_cmdline_params:7
msgid "List of command line parameters to be prepended to the executable in submission line."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.is_hidden:1
msgid "Return whether the code is hidden."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.is_hidden:3
msgid "``True`` if the code is hidden, ``False`` otherwise, which is also the default."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.label:1
msgid "Return the label."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.label:3
msgid "The label."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.prepend_text:1
msgid "Return the text that should be prepended to the run line in the job script."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.use_double_quotes:1
#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.get_use_double_quotes:1
msgid "Return whether the command line invocation of this code should be escaped with double quotes."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.use_double_quotes:3
msgid "``True`` if to escape with double quotes, ``False`` otherwise."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.validate_working_directory:1
#: ../../../src/aiida/orm/nodes/data/code/portable.py:docstring of aiida.orm.nodes.data.code.portable.PortableCode.validate_working_directory:1
msgid "Validate content of the working directory created by the :class:`~aiida.engine.CalcJob` plugin."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.validate_working_directory:3
#: ../../../src/aiida/orm/nodes/data/code/portable.py:docstring of aiida.orm.nodes.data.code.portable.PortableCode.validate_working_directory:3
msgid "This method will be called by :meth:`~aiida.engine.processes.calcjobs.calcjob.CalcJob.presubmit` when a new calculation job is launched, passing the :class:`~aiida.common.folders.Folder` that was used by the plugin used for the calculation to create the input files for the working directory. This method can be overridden by implementations of the ``AbstractCode`` class that need to validate the contents of that folder."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.validate_working_directory:8
#: ../../../src/aiida/orm/nodes/data/code/portable.py:docstring of aiida.orm.nodes.data.code.portable.PortableCode.validate_working_directory:8
msgid "A sandbox folder that the ``CalcJob`` plugin wrote input files to that will be copied to the working directory for the corresponding calculation job instance."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.validate_working_directory:10
msgid "If the content of the sandbox folder is not valid."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.with_mpi:1
msgid "Return whether the command should be run as an MPI program."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.with_mpi:3
msgid "``True`` if the code should be run as an MPI program, ``False`` if it shouldn't, ``None`` if unknown."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.wrap_cmdline_params:1
msgid "Return whether all command line parameters should be wrapped with double quotes to form a single argument."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.wrap_cmdline_params:3
msgid "..note:: This is required to support certain containerization technologies, such as Docker."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/abstract.py:docstring of aiida.orm.nodes.data.code.abstract.AbstractCode.wrap_cmdline_params:5
msgid "``True`` if command line parameters should be wrapped, ``False`` otherwise."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/containerized.py:docstring of aiida.orm.nodes.data.code.containerized:1
msgid "Data plugin representing an executable code inside a container."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/containerized.py:docstring of aiida.orm.nodes.data.code.containerized:3
msgid "The containerized code allows specifying a container image and the executable filepath within that container that is to be executed when a calculation job is run with this code."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/containerized.py:docstring of aiida.orm.nodes.data.code.containerized.ContainerizedCode:1
msgid "Bases: :py:class:`~aiida.orm.nodes.data.code.installed.InstalledCode`"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/containerized.py:docstring of aiida.orm.nodes.data.code.containerized.ContainerizedCode:1
msgid "Data plugin representing an executable code in container on a remote computer."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/containerized.py:docstring of aiida.orm.nodes.data.code.containerized.ContainerizedCode.__init__:3
#: ../../../src/aiida/orm/nodes/data/code/installed.py:docstring of aiida.orm.nodes.data.code.installed.InstalledCode.__init__:3
msgid "The remote computer on which the executable is located."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/containerized.py:docstring of aiida.orm.nodes.data.code.containerized.ContainerizedCode.__init__:4
#: ../../../src/aiida/orm/nodes/data/code/installed.py:docstring of aiida.orm.nodes.data.code.installed.InstalledCode.__init__:4
msgid "The absolute filepath of the executable on the remote computer."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/containerized.py:docstring of aiida.orm.nodes.data.code.containerized.ContainerizedCode.engine_command:1
msgid "Return the engine command with image as template field of the containerized code."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/containerized.py:docstring of aiida.orm.nodes.data.code.containerized.ContainerizedCode.engine_command:3
msgid "The engine command of the containerized code"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/containerized.py:docstring of aiida.orm.nodes.data.code.containerized.ContainerizedCode.filepath_executable:1
msgid "Return the filepath of the executable that this code represents."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/containerized.py:docstring of aiida.orm.nodes.data.code.containerized.ContainerizedCode.filepath_executable:3
msgid "This is overridden from the base class since the path does not have to be absolute."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/containerized.py:docstring of aiida.orm.nodes.data.code.containerized.ContainerizedCode.filepath_executable:5
msgid "The filepath of the executable."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/containerized.py:docstring of aiida.orm.nodes.data.code.containerized.ContainerizedCode.get_prepend_cmdline_params:1
msgid "Return the list of prepend cmdline params for mpi seeting"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/containerized.py:docstring of aiida.orm.nodes.data.code.containerized.ContainerizedCode.get_prepend_cmdline_params:3
msgid "list of prepend cmdline parameters."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/containerized.py:docstring of aiida.orm.nodes.data.code.containerized.ContainerizedCode.image_name:1
#: ../../../src/aiida/orm/nodes/data/code/containerized.py:docstring of aiida.orm.nodes.data.code.containerized.ContainerizedCode.image_name:3
msgid "The image name of container."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/installed.py:docstring of aiida.orm.nodes.data.code.installed:1
#: ../../../src/aiida/orm/nodes/data/code/installed.py:docstring of aiida.orm.nodes.data.code.installed.InstalledCode:1
msgid "Data plugin representing an executable code on a remote computer."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/installed.py:docstring of aiida.orm.nodes.data.code.installed:3
msgid "This plugin should be used if an executable is pre-installed on a computer. The ``InstalledCode`` represents the code by storing the absolute filepath of the relevant executable and the computer on which it is installed. The computer is represented by an instance of :class:`aiida.orm.computers.Computer`. Each time a :class:`aiida.engine.CalcJob` is run using an ``InstalledCode``, it will run its executable on the associated computer."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/installed.py:docstring of aiida.orm.nodes.data.code.installed.InstalledCode:1
#: ../../../src/aiida/orm/nodes/data/code/portable.py:docstring of aiida.orm.nodes.data.code.portable.PortableCode:1
msgid "Bases: :py:class:`~aiida.orm.nodes.data.code.legacy.Code`"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/installed.py:docstring of aiida.orm.nodes.data.code.installed.InstalledCode._validate:1
msgid "Validate the instance by checking that a computer has been defined."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/installed.py:docstring of aiida.orm.nodes.data.code.installed.InstalledCode._validate:3
#: ../../../src/aiida/orm/nodes/data/code/portable.py:docstring of aiida.orm.nodes.data.code.portable.PortableCode._validate:3
msgid ":raises :class:`aiida.common.exceptions.ValidationError`: If the state of the node is invalid."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/installed.py:docstring of aiida.orm.nodes.data.code.installed.InstalledCode.can_run_on_computer:4
#: ../../../src/aiida/orm/nodes/data/code/portable.py:docstring of aiida.orm.nodes.data.code.portable.PortableCode.can_run_on_computer:6
msgid "``True`` if the provided computer is the same as the one configured for this code."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/installed.py:docstring of aiida.orm.nodes.data.code.installed.InstalledCode.computer:1
msgid "Return the computer of this code."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/installed.py:docstring of aiida.orm.nodes.data.code.installed.InstalledCode.filepath_executable:1
msgid "Return the absolute filepath of the executable that this code represents."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/installed.py:docstring of aiida.orm.nodes.data.code.installed.InstalledCode.filepath_executable:3
msgid "The absolute filepath of the executable."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/installed.py:docstring of aiida.orm.nodes.data.code.installed.InstalledCode.validate_filepath_executable:1
msgid "Validate the ``filepath_executable`` attribute."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/installed.py:docstring of aiida.orm.nodes.data.code.installed.InstalledCode.validate_filepath_executable:3
#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.validate_remote_exec_path:3
msgid "Checks whether the executable exists on the remote computer if a transport can be opened to it. This method is intentionally not called in ``_validate`` as to allow the creation of ``Code`` instances whose computers can not yet be connected to and as to not require the overhead of opening transports in storing a new code."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/installed.py:docstring of aiida.orm.nodes.data.code.installed.InstalledCode.validate_filepath_executable:7
msgid "If the ``filepath_executable`` is not an absolute path, the check is skipped."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/installed.py:docstring of aiida.orm.nodes.data.code.installed.InstalledCode.validate_filepath_executable:9
#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.validate_remote_exec_path:7
msgid "if no transport could be opened or if the defined executable does not exist on the remote computer."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy:1
msgid "Data plugin represeting an executable code to be wrapped and called through a `CalcJob` plugin."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code:1
msgid "Bases: :py:class:`~aiida.orm.nodes.data.code.abstract.AbstractCode`"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code:1
msgid "A code entity. It can either be 'local', or 'remote'."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code:4
msgid "Local code: it is a collection of files/dirs (added using the add_path() method), where one     file is flagged as executable (using the set_local_executable() method)."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code:6
msgid "Remote code: it is a pair (remotecomputer, remotepath_of_executable) set using the     set_remote_computer_exec() method."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code:8
msgid "For both codes, one can set some code to be executed right before or right after the execution of the code, using the set_preexec_code() and set_postexec_code() methods (e.g., the set_preexec_code() can be used to load specific modules required for the code to be run)."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code._set_local:1
msgid "Set the code as a 'local' code, meaning that all the files belonging to the code will be copied to the cluster, and the file set with set_exec_filename will be run."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code._set_local:5
#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code._set_remote:5
msgid "It also deletes the flags related to the local case (if any)"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code._set_remote:1
msgid "Set the code as a 'remote' code, meaning that the code itself has no files attached, but only a location on a remote computer (with an absolute path of the executable on the remote computer)."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.can_run_on:1
msgid "Return True if this code can run on the given computer, False otherwise."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.can_run_on:3
msgid "Local codes can run on any machine; remote codes can run only on the machine on which they reside."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.can_run_on:6
msgid "TODO: add filters to mask the remote machines on which a local code can run."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.full_label:1
#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.restapi.translator.nodes.data.code.CodeTranslator.Code.full_label:1
msgid "Get full label of this code."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.full_label:3
#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.restapi.translator.nodes.data.code.CodeTranslator.Code.full_label:3
msgid "Returns label of the form <code-label>@<computer-name>."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.get:1
msgid "Get a Computer object with given identifier string, that can either be the numeric ID (pk), or the label (and computername) (if unique)."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.get:4
msgid "the numeric ID (pk) for code"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.get:5
#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.get_code_helper:1
msgid "the code label identifying the code to load"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.get:6
#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.get_code_helper:2
msgid "the machine name where code is setup"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.get:8
#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.get_code_helper:4
#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.get_from_string:12
msgid "if no code identified by the given string is found"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.get:9
#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.get_code_helper:5
#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.get_from_string:13
msgid "if the string cannot identify uniquely a code"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.get:10
msgid "if neither a pk nor a label was passed in"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.get_append_text:1
msgid "Return the postexec_code, or an empty string if no post-exec code was defined."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.get_computer_label:1
msgid "Get label of this code's computer."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.get_description:1
msgid "Return a string description of this Code instance."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.get_description:3
msgid "string description of this Code instance"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.get_execname:1
msgid "Return the executable string to be put in the script. For local codes, it is ./LOCAL_EXECUTABLE_NAME For remote codes, it is the absolute path to the executable."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.get_from_string:1
msgid "Get a Computer object with given identifier string in the format label@machinename. See the note below for details on the string detection algorithm."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.get_from_string:5
msgid "the (leftmost) '@' symbol is always used to split code and computername. Therefore do not use '@' in the code name if you want to use this function ('@' in the computer name are instead valid)."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.get_from_string:10
msgid "the code string identifying the code to load"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.get_from_string:15
msgid "if code_string is not of string type"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.get_input_plugin_name:1
msgid "Return the name of the default input plugin (or None if no input plugin was set."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.get_local_executable:1
msgid "Return the local executable."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.get_prepend_text:1
msgid "Return the code that will be put in the scheduler script before the execution, or an empty string if no pre-exec code was defined."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.get_remote_computer:1
msgid "Return the remote computer associated with this code."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.get_remote_exec_path:1
msgid "Return the ``remote_exec_path`` attribute."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.hidden:1
#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.restapi.translator.nodes.data.code.CodeTranslator.Code.hidden:1
msgid "Determines whether the Code is hidden or not"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.hide:1
msgid "Hide the code (prevents from showing it in the verdi code list)"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.is_local:1
msgid "Return True if the code is 'local', False if it is 'remote' (see also documentation of the set_local and set_remote functions)."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.list_for_plugin:1
msgid "Return a list of valid code strings for a given plugin."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.list_for_plugin:3
msgid "The string of the plugin."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.list_for_plugin:4
msgid "if True, return a list of code names, otherwise return the code PKs (integers)."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.list_for_plugin:6
msgid "a list of string, with the code names if labels is True, otherwise a list of integers with the code PKs."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.relabel:1
msgid "Relabel this code."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.relabel:3
msgid "new code label"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.reveal:1
msgid "Reveal the code (allows to show it in the verdi code list) By default, it is revealed"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.set_append_text:1
msgid "Pass a string of code that will be put in the scheduler script after the execution of the code."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.set_files:1
msgid "Given a list of filenames (or a single filename string), add it to the path (all at level zero, i.e. without folders). Therefore, be careful for files with the same name!"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.set_files:0
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.close:0
msgid "todo"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.set_files:5
msgid "decide whether to check if the Code must be a local executable to be able to call this function."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.set_input_plugin_name:1
msgid "Set the name of the default input plugin, to be used for the automatic generation of a new calculation."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.set_local_executable:1
msgid "Set the filename of the local executable. Implicitly set the code as local."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.set_prepend_text:1
msgid "Pass a string of code that will be put in the scheduler script before the execution of the code."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.set_remote_computer_exec:1
msgid "Set the code as remote, and pass the computer on which it resides and the absolute path on that computer."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.set_remote_computer_exec:4
msgid "a tuple (computer, remote_exec_path), where computer is a aiida.orm.Computer and remote_exec_path is the absolute path of the main executable on remote computer."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.set_use_double_quotes:1
msgid "Set whether the command line invocation of this code should be escaped with double quotes."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/legacy.py:docstring of aiida.orm.nodes.data.code.legacy.Code.validate_remote_exec_path:1
msgid "Validate the ``remote_exec_path`` attribute."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/portable.py:docstring of aiida.orm.nodes.data.code.portable:1
#: ../../../src/aiida/orm/nodes/data/code/portable.py:docstring of aiida.orm.nodes.data.code.portable.PortableCode:1
msgid "Data plugin representing an executable code stored in AiiDA's storage."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/portable.py:docstring of aiida.orm.nodes.data.code.portable:3
msgid "This plugin should be used for executables that are not already installed on the target computer, but instead are available on the machine where AiiDA is running. The plugin assumes that the code is self-contained by a single directory containing all the necessary files, including a main executable. When constructing a ``PortableCode``, passing the absolute filepath as ``filepath_files`` will make sure that all the files contained within are uploaded to AiiDA's storage. The ``filepath_executable`` should indicate the filename of the executable within that directory. Each time a :class:`aiida.engine.CalcJob` is run using a ``PortableCode``, the uploaded files will be automatically copied to the working directory on the selected computer and the executable will be run there."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/portable.py:docstring of aiida.orm.nodes.data.code.portable.PortableCode.__init__:3
msgid "If the files necessary for this code are not all located in a single directory or the directory contains files that should not be uploaded, and so the ``filepath_files`` cannot be used. One can use the methods of the :class:`aiida.orm.nodes.repository.NodeRepository` class. This can be accessed through the ``base.repository`` attribute of the instance after it has been constructed. For example::"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/portable.py:docstring of aiida.orm.nodes.data.code.portable.PortableCode.__init__:13
msgid "The relative filepath of the executable within the directory of uploaded files."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/portable.py:docstring of aiida.orm.nodes.data.code.portable.PortableCode.__init__:14
msgid "The filepath to the directory containing all the files of the code."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/portable.py:docstring of aiida.orm.nodes.data.code.portable.PortableCode._validate:1
msgid "Validate the instance by checking that an executable is defined and it is part of the repository files."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/portable.py:docstring of aiida.orm.nodes.data.code.portable.PortableCode.can_run_on_computer:3
msgid "A ``PortableCode`` should be able to be run on any computer in principle."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/portable.py:docstring of aiida.orm.nodes.data.code.portable.PortableCode.filepath_executable:1
msgid "Return the relative filepath of the executable that this code represents."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/portable.py:docstring of aiida.orm.nodes.data.code.portable.PortableCode.filepath_executable:3
msgid "The relative filepath of the executable."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/code/portable.py:docstring of aiida.orm.nodes.data.code.portable.PortableCode.validate_working_directory:10
msgid "The ``CalcJob`` plugin created a file that has the same relative filepath as the executable for this portable code."
msgstr ""

#: ../../source/reference/apidoc/aiida.orm.nodes.data.remote.rst:2
msgid "aiida.orm.nodes.data.remote package"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/remote/__init__.py:docstring of aiida.orm.nodes.data.remote:1
msgid "Module with data plugins that represent remote resources and so effectively are symbolic links."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/remote/base.py:docstring of aiida.orm.nodes.data.remote.base:1
msgid "Data plugin that models a folder on a remote computer."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/remote/base.py:docstring of aiida.orm.nodes.data.remote.base.RemoteData:1
msgid "Store a link to a file or folder on a remote machine."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/remote/base.py:docstring of aiida.orm.nodes.data.remote.base.RemoteData:3
msgid "Remember to pass a computer!"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/remote/base.py:docstring of aiida.orm.nodes.data.remote.base.RemoteData._clean:1
msgid "Remove all content of the remote folder on the remote computer."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/remote/base.py:docstring of aiida.orm.nodes.data.remote.base.RemoteData._clean:3
msgid "When the cleaning operation is successful, the extra with the key ``RemoteData.KEY_EXTRA_CLEANED`` is set."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/remote/base.py:docstring of aiida.orm.nodes.data.remote.base.RemoteData._clean:5
msgid "Provide an optional transport that is already open. If not provided, a transport will be automatically opened, based on the current default user and the computer of this data node. Passing in the transport can be used for efficiency if a great number of nodes need to be cleaned for the same computer. Note that the user should take care that the correct transport is passed."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/remote/base.py:docstring of aiida.orm.nodes.data.remote.base.RemoteData._clean:9
msgid "If the hostname of the provided transport does not match that of the node's computer."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/remote/base.py:docstring of aiida.orm.nodes.data.remote.base.RemoteData.getfile:1
msgid "Connects to the remote folder and retrieves the content of a file."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/remote/base.py:docstring of aiida.orm.nodes.data.remote.base.RemoteData.getfile:3
msgid "The relative path of the file on the remote to retrieve."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/remote/base.py:docstring of aiida.orm.nodes.data.remote.base.RemoteData.getfile:4
msgid "The absolute path of where to store the file on the local machine."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/remote/base.py:docstring of aiida.orm.nodes.data.remote.base.RemoteData.is_cleaned:1
msgid "Return whether the remote folder has been cleaned."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/remote/base.py:docstring of aiida.orm.nodes.data.remote.base.RemoteData.is_empty:1
msgid "Check if remote folder is empty"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/remote/base.py:docstring of aiida.orm.nodes.data.remote.base.RemoteData.listdir:1
#: ../../../src/aiida/orm/nodes/data/remote/base.py:docstring of aiida.orm.nodes.data.remote.base.RemoteData.listdir_withattributes:1
msgid "Connects to the remote folder and lists the directory content."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/remote/base.py:docstring of aiida.orm.nodes.data.remote.base.RemoteData.listdir:3
#: ../../../src/aiida/orm/nodes/data/remote/base.py:docstring of aiida.orm.nodes.data.remote.base.RemoteData.listdir_withattributes:3
msgid "If 'relpath' is specified, lists the content of the given subfolder."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/remote/base.py:docstring of aiida.orm.nodes.data.remote.base.RemoteData.listdir:4
msgid "a flat list of file/directory names (as strings)."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/remote/base.py:docstring of aiida.orm.nodes.data.remote.base.RemoteData.listdir_withattributes:4
msgid "a list of dictionaries, where the documentation is in :py:class:Transport.listdir_withattributes."
msgstr ""

#: ../../source/reference/apidoc/aiida.orm.nodes.data.remote.stash.rst:2
msgid "aiida.orm.nodes.data.remote.stash package"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/remote/stash/__init__.py:docstring of aiida.orm.nodes.data.remote.stash:1
msgid "Module with data plugins that represent files of completed calculations jobs that have been stashed."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/remote/stash/base.py:docstring of aiida.orm.nodes.data.remote.stash.base:1
#: ../../../src/aiida/orm/nodes/data/remote/stash/base.py:docstring of aiida.orm.nodes.data.remote.stash.base.RemoteStashData:1
msgid "Data plugin that models an archived folder on a remote computer."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/remote/stash/base.py:docstring of aiida.orm.nodes.data.remote.stash.base.RemoteStashData:3
msgid "A stashed folder is essentially an instance of ``RemoteData`` that has been archived. Archiving in this context can simply mean copying the content of the folder to another location on the same or another filesystem as long as it is on the same machine. In addition, the folder may have been compressed into a single file for efficiency or even written to tape. The ``stash_mode`` attribute will distinguish how the folder was stashed which will allow the implementation to also `unstash` it and transform it back into a ``RemoteData`` such that it can be used as an input for new ``CalcJobs``."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/remote/stash/base.py:docstring of aiida.orm.nodes.data.remote.stash.base.RemoteStashData:10
msgid "This class is a non-storable base class that merely registers the ``stash_mode`` attribute. Only its subclasses, that actually implement a certain stash mode, can be instantiated and therefore stored. The reason for this design is that because the behavior of the class can change significantly based on the mode employed to stash the files and implementing all these variants in the same class will lead to an unintuitive interface where certain properties or methods of the class will only be available or function properly based on the ``stash_mode``."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/remote/stash/base.py:docstring of aiida.orm.nodes.data.remote.stash.base.RemoteStashData.__init__:1
#: ../../../src/aiida/orm/nodes/data/remote/stash/folder.py:docstring of aiida.orm.nodes.data.remote.stash.folder.RemoteStashFolderData.__init__:1
msgid "Construct a new instance"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/remote/stash/base.py:docstring of aiida.orm.nodes.data.remote.stash.base.RemoteStashData.__init__:3
#: ../../../src/aiida/orm/nodes/data/remote/stash/folder.py:docstring of aiida.orm.nodes.data.remote.stash.folder.RemoteStashFolderData.__init__:3
msgid "the stashing mode with which the data was stashed on the remote."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/remote/stash/base.py:docstring of aiida.orm.nodes.data.remote.stash.base.RemoteStashData.stash_mode:1
msgid "Return the mode with which the data was stashed on the remote."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/remote/stash/base.py:docstring of aiida.orm.nodes.data.remote.stash.base.RemoteStashData.stash_mode:3
msgid "the stash mode."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/remote/stash/folder.py:docstring of aiida.orm.nodes.data.remote.stash.folder:1
msgid "Data plugin that models a stashed folder on a remote computer."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/remote/stash/folder.py:docstring of aiida.orm.nodes.data.remote.stash.folder.RemoteStashFolderData:1
msgid "Bases: :py:class:`~aiida.orm.nodes.data.remote.stash.base.RemoteStashData`"
msgstr ""

#: ../../../src/aiida/orm/nodes/data/remote/stash/folder.py:docstring of aiida.orm.nodes.data.remote.stash.folder.RemoteStashFolderData:1
msgid "Data plugin that models a folder with files of a completed calculation job that has been stashed through a copy."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/remote/stash/folder.py:docstring of aiida.orm.nodes.data.remote.stash.folder.RemoteStashFolderData:3
msgid "This data plugin can and should be used to stash files if and only if the stash mode is `StashMode.COPY`."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/remote/stash/folder.py:docstring of aiida.orm.nodes.data.remote.stash.folder.RemoteStashFolderData.__init__:4
#: ../../../src/aiida/orm/nodes/data/remote/stash/folder.py:docstring of aiida.orm.nodes.data.remote.stash.folder.RemoteStashFolderData.target_basepath:3
msgid "the target basepath."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/remote/stash/folder.py:docstring of aiida.orm.nodes.data.remote.stash.folder.RemoteStashFolderData.__init__:5
#: ../../../src/aiida/orm/nodes/data/remote/stash/folder.py:docstring of aiida.orm.nodes.data.remote.stash.folder.RemoteStashFolderData.source_list:3
msgid "the list of source files."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/remote/stash/folder.py:docstring of aiida.orm.nodes.data.remote.stash.folder.RemoteStashFolderData.source_list:1
msgid "Return the list of source files that were stashed."
msgstr ""

#: ../../../src/aiida/orm/nodes/data/remote/stash/folder.py:docstring of aiida.orm.nodes.data.remote.stash.folder.RemoteStashFolderData.target_basepath:1
msgid "Return the target basepath."
msgstr ""

#: ../../source/reference/apidoc/aiida.orm.nodes.process.rst:2
msgid "aiida.orm.nodes.process package"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/__init__.py:docstring of aiida.orm.nodes.process:1
msgid "Module with `Node` sub classes for processes."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process:1
msgid "Module with `Node` sub class for processes."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode:1
msgid "Bases: :py:class:`~aiida.orm.utils.mixins.Sealable`, :py:class:`~aiida.orm.nodes.node.Node`"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode:1
msgid "Base class for all nodes representing the execution of a process"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode:3
msgid "This class and its subclasses serve as proxies in the database, for actual `Process` instances being run. The `Process` instance in memory will leverage an instance of this class (the exact sub class depends on the sub class of `Process`) to persist important information of its state to the database. This serves as a way for the user to inspect the state of the `Process` during its execution as well as a permanent record of its execution in the provenance graph, after the execution has terminated."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.called:1
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.called:1
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.called:1
msgid "Return a list of nodes that the process called"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.called:3
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.called:3
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.called:3
msgid "list of process nodes called by this process"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.called_descendants:1
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.called_descendants:1
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.called_descendants:1
msgid "Return a list of all nodes that have been called downstream of this process"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.called_descendants:3
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.called_descendants:3
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.called_descendants:3
msgid "This will recursively find all the called processes for this process and its children."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.caller:1
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.caller:1
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.caller:1
msgid "Return the process node that called this process node, or None if it does not have a caller"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.caller:3
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.caller:3
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.caller:3
msgid "process node that called this process node instance or None"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.checkpoint:1
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.checkpoint:1
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.checkpoint:1
msgid "Return the checkpoint bundle set for the process"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.checkpoint:3
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.checkpoint:3
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.checkpoint:3
msgid "checkpoint bundle if it exists, None otherwise"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.delete_checkpoint:1
msgid "Delete the checkpoint bundle set for the process"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.exception:1
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.exception:1
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.exception:1
msgid "Return the exception of the process or None if the process is not excepted."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.exception:3
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.exception:3
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.exception:3
msgid "If the process is marked as excepted yet there is no exception attribute, an empty string will be returned."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.exception:5
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.exception:5
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.exception:5
msgid "the exception message or None"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.exit_code:1
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.exit_code:1
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.exit_code:1
msgid "Return the exit code of the process."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.exit_code:3
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.exit_code:3
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.exit_code:3
msgid "It is reconstituted from the ``exit_status`` and ``exit_message`` attributes if both of those are defined."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.exit_code:5
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.exit_code:5
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.exit_code:5
msgid "The exit code if defined, or ``None``."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.exit_message:1
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.exit_message:1
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.exit_message:1
msgid "Return the exit message of the process"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.exit_message:3
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.exit_message:3
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.exit_message:3
msgid "the exit message"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.exit_status:1
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.exit_status:1
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.exit_status:1
msgid "Return the exit status of the process"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.exit_status:3
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.exit_status:3
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.exit_status:3
msgid "the exit status, an integer exit code or None"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.get_builder_restart:1
msgid "Return a `ProcessBuilder` that is ready to relaunch the process that created this node."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.get_builder_restart:3
msgid "The process class will be set based on the `process_type` of this node and the inputs of the builder will be prepopulated with the inputs registered for this node. This functionality is very useful if a process has completed and you want to relaunch it with slightly different inputs."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.get_builder_restart:7
msgid "`~aiida.engine.processes.builder.ProcessBuilder` instance"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.get_metadata_inputs:1
msgid "Return the mapping of inputs corresponding to ``metadata`` ports that were passed to the process."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.is_excepted:1
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.is_excepted:1
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.is_excepted:1
msgid "Return whether the process has excepted"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.is_excepted:3
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.is_excepted:3
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.is_excepted:3
msgid "Excepted means that during execution of the process, an exception was raised that was not caught."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.is_excepted:5
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.is_excepted:5
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.is_excepted:5
msgid "True if during execution of the process an exception occurred, False otherwise"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.is_failed:1
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.is_failed:1
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.is_failed:1
msgid "Return whether the process has failed"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.is_failed:3
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.is_failed:3
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.is_failed:3
msgid "Failed means that the process terminated nominally but it had a non-zero exit status."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.is_failed:5
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.is_failed:5
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.is_failed:5
msgid "True if the process has failed, False otherwise"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.is_finished:1
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.is_finished:1
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.is_finished:1
msgid "Return whether the process has finished"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.is_finished:3
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.is_finished:3
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.is_finished:3
msgid "Finished means that the process reached a terminal state nominally. Note that this does not necessarily mean successfully, but there were no exceptions and it was not killed."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.is_finished:6
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.is_finished:6
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.is_finished:6
msgid "True if the process has finished, False otherwise"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.is_finished_ok:1
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.is_finished_ok:1
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.is_finished_ok:1
msgid "Return whether the process has finished successfully"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.is_finished_ok:3
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.is_finished_ok:3
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.is_finished_ok:3
msgid "Finished successfully means that it terminated nominally and had a zero exit status."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.is_finished_ok:5
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.is_finished_ok:5
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.is_finished_ok:5
msgid "True if the process has finished successfully, False otherwise"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.is_killed:1
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.is_killed:1
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.is_killed:1
msgid "Return whether the process was killed"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.is_killed:3
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.is_killed:3
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.is_killed:3
msgid "Killed means the process was killed directly by the user or by the calling process being killed."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.is_killed:5
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.is_killed:5
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.is_killed:5
msgid "True if the process was killed, False otherwise"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.is_terminated:1
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.is_terminated:1
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.is_terminated:1
msgid "Return whether the process has terminated"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.is_terminated:3
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.is_terminated:3
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.is_terminated:3
msgid "Terminated means that the process has reached any terminal state."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.is_terminated:5
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.is_terminated:5
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.is_terminated:5
msgid "True if the process has terminated, False otherwise"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.logger:1
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.logger:1
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.logger:1
msgid "Get the logger of the Calculation object, so that it also logs to the DB."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.logger:3
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.logger:3
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.logger:3
msgid "LoggerAdapter object, that works like a logger, but also has the 'extra' embedded"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.pause:1
msgid "Mark the process as paused by setting the corresponding attribute."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.pause:3
msgid "This serves only to reflect that the corresponding Process is paused and so this method should not be called by anyone but the Process instance itself."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.paused:1
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.paused:1
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.paused:1
msgid "Return whether the process is paused"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.paused:3
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.paused:3
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.paused:3
msgid "True if the Calculation is marked as paused, False otherwise"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.process_class:1
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.process_class:1
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.process_class:1
msgid "Return the process class that was used to create this node."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.process_class:3
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.process_class:3
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.process_class:3
msgid "`Process` class"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.process_class:4
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.process_class:4
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.process_class:4
msgid "if no process type is defined, it is an invalid process type string or cannot be resolved to load the corresponding class"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.process_label:1
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.process_label:1
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.process_label:1
msgid "Return the process label"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.process_label:3
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.process_label:3
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.process_label:3
msgid "the process label"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.process_state:1
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.process_state:1
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.process_state:1
msgid "Return the process state"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.process_state:3
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.process_state:3
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.process_state:3
msgid "the process state instance of ProcessState enum"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.process_status:1
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.process_status:1
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.process_status:1
msgid "Return the process status"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.process_status:3
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.process_status:3
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.process_status:3
msgid "The process status is a generic status message e.g. the reason it might be paused or when it is being killed"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.process_status:5
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.resources.ProcessNode.ProcessTranslator.ProcessNode.process_status:5
#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.ProcessNode.process_status:5
msgid "the process status"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.set_checkpoint:1
msgid "Set the checkpoint bundle set for the process"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.set_checkpoint:3
#: ../../../src/aiida/orm/nodes/process/workflow/workchain.py:docstring of aiida.orm.nodes.process.workflow.workchain.WorkChainNode.set_stepper_state_info:3
#: ../../../src/aiida/orm/nodes/process/workflow/workchain.py:docstring of aiida.orm.nodes.process.workflow.workchain.WorkChainNode.stepper_state_info:3
#: ../../../src/aiida/orm/nodes/process/workflow/workchain.py:docstring of aiida.restapi.translator.nodes.process.workflow.workchain.WorkChainTranslator.WorkChainNode.stepper_state_info:3
msgid "string representation of the stepper state info"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.set_exception:1
msgid "Set the exception of the process"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.set_exception:3
msgid "the exception message"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.set_exit_message:1
msgid "Set the exit message of the process, if None nothing will be done"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.set_exit_message:3
msgid "a string message"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.set_exit_status:1
msgid "Set the exit status of the process"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.set_exit_status:3
msgid "an integer exit code or None, which will be interpreted as zero"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.set_metadata_inputs:1
msgid "Set the mapping of inputs corresponding to ``metadata`` ports that were passed to the process."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.set_process_label:1
msgid "Set the process label"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.set_process_label:3
msgid "process label string"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.set_process_state:1
msgid "Set the process state"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.set_process_state:3
msgid "value or instance of ProcessState enum"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.set_process_status:1
msgid "Set the process status"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.set_process_status:3
msgid "The process status is a generic status message e.g. the reason it might be paused or when it is being killed. If status is None, the corresponding attribute will be deleted."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.set_process_status:6
msgid "string process status"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.set_process_type:1
msgid "Set the process type string."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.set_process_type:3
msgid "the process type string identifying the class using this process node as storage."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.unpause:1
msgid "Mark the process as unpaused by removing the corresponding attribute."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNode.unpause:3
msgid "This serves only to reflect that the corresponding Process is unpaused and so this method should not be called by anyone but the Process instance itself."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNodeCaching:1
msgid "Bases: :py:class:`~aiida.orm.nodes.caching.NodeCaching`"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNodeCaching.is_valid_cache:1
msgid "Return whether the node is valid for caching"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNodeCaching.is_valid_cache:3
msgid "True if this process node is valid to be used for caching, False otherwise"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNodeLinks:1
msgid "Bases: :py:class:`~aiida.orm.nodes.links.NodeLinks`"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNodeLinks.validate_incoming:3
msgid "Adding an input link to a `ProcessNode` once it is stored is illegal because this should be taken care of by the engine in one go. If a link is being added after the node is stored, it is most likely not by the engine and it should not be allowed."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNodeLinks.validate_outgoing:3
msgid "Adding an outgoing link from a sealed node is forbidden."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/process.py:docstring of aiida.orm.nodes.process.process.ProcessNodeLinks.validate_outgoing:8
msgid "if the source node (self) is sealed"
msgstr ""

#: ../../source/reference/apidoc/aiida.orm.nodes.process.calculation.rst:2
msgid "aiida.orm.nodes.process.calculation package"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/__init__.py:docstring of aiida.orm.nodes.process.calculation:1
msgid "Module with `Node` sub classes for calculation processes."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcfunction.py:docstring of aiida.orm.nodes.process.calculation.calcfunction:1
msgid "Module with `Node` sub class for calculation function processes."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcfunction.py:docstring of aiida.orm.nodes.process.calculation.calcfunction.CalcFunctionNode:1
msgid "Bases: :py:class:`~aiida.orm.utils.mixins.FunctionCalculationMixin`, :py:class:`~aiida.orm.nodes.process.calculation.calculation.CalculationNode`"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcfunction.py:docstring of aiida.orm.nodes.process.calculation.calcfunction.CalcFunctionNode:1
msgid "ORM class for all nodes representing the execution of a calcfunction."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcfunction.py:docstring of aiida.orm.nodes.process.calculation.calcfunction.CalcFunctionNodeLinks:1
#: ../../../src/aiida/orm/nodes/process/workflow/workflow.py:docstring of aiida.orm.nodes.process.workflow.workflow.WorkflowNodeLinks:1
msgid "Bases: :py:class:`~aiida.orm.nodes.process.process.ProcessNodeLinks`"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcfunction.py:docstring of aiida.orm.nodes.process.calculation.calcfunction.CalcFunctionNodeLinks.validate_outgoing:3
msgid "A calcfunction cannot return Data, so if we receive an outgoing link to a stored Data node, that means the user created a Data node within our function body and stored it themselves or they are returning an input node. The latter use case is reserved for @workfunctions, as they can have RETURN links."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob:1
msgid "Module with `Node` sub class for calculation job processes."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode:1
msgid "Bases: :py:class:`~aiida.orm.nodes.process.calculation.calculation.CalculationNode`"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode:1
msgid "ORM class for all nodes representing the execution of a CalcJob."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode._validate_retrieval_directive:1
msgid "Validate a list or tuple of file retrieval directives."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode._validate_retrieval_directive:3
msgid "a list or tuple of file retrieval directives"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode._validate_retrieval_directive:4
msgid "if the format of the directives is invalid"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.delete_state:1
msgid "Delete the calculation job state attribute if it exists."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.get_authinfo:1
msgid "Return the `AuthInfo` that is configured for the `Computer` set for this node."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.get_authinfo:3
msgid "`AuthInfo`"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.get_description:1
msgid "Return a description of the node based on its properties."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.get_detailed_job_info:1
msgid "Return the detailed job info dictionary."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.get_detailed_job_info:3
msgid "The scheduler is polled for the detailed job info after the job is completed and ready to be retrieved."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.get_detailed_job_info:5
msgid "the dictionary with detailed job info if defined or None"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.get_job_id:1
msgid "Return job id that was assigned to the calculation by the scheduler."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.get_job_id:3
msgid "the string representation of the scheduler job id"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.get_last_job_info:1
msgid "Return the last information asked to the scheduler about the status of the job."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.get_last_job_info:3
msgid "The last job info is updated on every poll of the scheduler, except for the final poll when the job drops from the scheduler's job queue. For completed jobs, the last job info therefore contains the \"second-to-last\" job info that still shows the job as running. Please use :meth:`~aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.get_detailed_job_info` instead."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.get_last_job_info:9
msgid "a `JobInfo` object (that closely resembles a dictionary) or None."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.get_option:1
msgid "Retun the value of an option that was set for this CalcJobNode"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.get_option:3
#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.set_option:3
msgid "the option name"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.get_option:4
msgid "the option value or None"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.get_option:5
#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.set_option:5
msgid "ValueError for unknown option"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.get_options:1
msgid "Return the dictionary of options set for this CalcJobNode"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.get_options:3
msgid "dictionary of the options and their values"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.get_parser_class:1
msgid "Return the output parser object for this calculation or None if no parser is set."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.get_parser_class:3
msgid "a `Parser` class."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.get_parser_class:4
msgid "if the parser entry point can not be resolved."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.get_remote_workdir:1
msgid "Return the path to the remote (on cluster) scratch folder of the calculation."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.get_remote_workdir:3
msgid "a string with the remote path"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.get_retrieve_list:1
msgid "Return the list of files/directories to be retrieved on the cluster after the calculation has completed."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.get_retrieve_list:3
#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.get_retrieve_temporary_list:3
msgid "a list of file directives"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.get_retrieve_temporary_list:1
msgid "Return list of files to be retrieved from the cluster which will be available during parsing."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.get_retrieved_node:1
msgid "Return the retrieved data folder."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.get_retrieved_node:3
msgid "the retrieved FolderData node or None if not found"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.get_scheduler_lastchecktime:1
msgid "Return the time of the last update of the scheduler state by the daemon or None if it was never set."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.get_scheduler_lastchecktime:3
msgid "a datetime object or None"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.get_scheduler_state:1
msgid "Return the status of the calculation according to the cluster scheduler."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.get_scheduler_state:3
msgid "a JobState enum instance."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.get_scheduler_stderr:1
msgid "Return the scheduler stdout output if the calculation has finished and been retrieved, None otherwise."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.get_scheduler_stderr:3
msgid "scheduler stdout output or None"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.get_scheduler_stdout:1
msgid "Return the scheduler stderr output if the calculation has finished and been retrieved, None otherwise."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.get_scheduler_stdout:3
msgid "scheduler stderr output or None"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.get_state:1
msgid "Return the calculation job active sub state."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.get_state:3
msgid "The calculation job state serves to give more granular state information to `CalcJobs`, in addition to the generic process state, while the calculation job is active. The state can take values from the enumeration defined in `aiida.common.datastructures.CalcJobState` and can be used to query for calculation jobs in specific active states."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.get_state:8
msgid "instance of `aiida.common.datastructures.CalcJobState` or `None` if invalid value, or not set"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.get_transport:1
msgid "Return the transport for this calculation."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.get_transport:3
msgid "`Transport` configured with the `AuthInfo` associated to the computer of this node"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.is_imported:1
#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.restapi.resources.CalcJobNode.CalcJobTranslator.CalcJobNode.is_imported:1
#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.restapi.translator.nodes.process.calculation.calcjob.CalcJobTranslator.CalcJobNode.is_imported:1
msgid "Return whether the calculation job was imported instead of being an actual run."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.link_label_retrieved:1
#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.restapi.resources.CalcJobNode.CalcJobTranslator.CalcJobNode.link_label_retrieved:1
#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.restapi.translator.nodes.process.calculation.calcjob.CalcJobTranslator.CalcJobNode.link_label_retrieved:1
msgid "Return the link label used for the retrieved FolderData node."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.res:1
#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.restapi.resources.CalcJobNode.CalcJobTranslator.CalcJobNode.res:1
#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.restapi.translator.nodes.process.calculation.calcjob.CalcJobTranslator.CalcJobNode.res:1
msgid "To be used to get direct access to the parsed parameters."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.res:3
#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.restapi.resources.CalcJobNode.CalcJobTranslator.CalcJobNode.res:3
#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.restapi.translator.nodes.process.calculation.calcjob.CalcJobTranslator.CalcJobNode.res:3
msgid "an instance of the CalcJobResultManager."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.res:5
#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.restapi.resources.CalcJobNode.CalcJobTranslator.CalcJobNode.res:5
#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.restapi.translator.nodes.process.calculation.calcjob.CalcJobTranslator.CalcJobNode.res:5
msgid "a practical example on how it is meant to be used: let's say that there is a key 'energy' in the dictionary of the parsed results which contains a list of floats. The command `calc.res.energy` will return such a list."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.set_detailed_job_info:1
msgid "Set the detailed job info dictionary."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.set_detailed_job_info:3
msgid "a dictionary with metadata with the accounting of a completed job"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.set_job_id:1
msgid "Set the job id that was assigned to the calculation by the scheduler."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.set_job_id:3
msgid "the id will always be stored as a string"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.set_job_id:5
msgid "the id assigned by the scheduler after submission"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.set_last_job_info:1
msgid "Set the last job info."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.set_last_job_info:3
msgid "a `JobInfo` object"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.set_option:1
msgid "Set an option to the given value"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.set_option:4
#: ../../../src/aiida/storage/psql_dos/orm/utils.py:docstring of aiida.storage.psql_dos.orm.utils.ModelWrapper.__setattr__:6
msgid "the value to set"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.set_option:6
msgid "TypeError for values with invalid type"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.set_options:1
msgid "Set the options for this CalcJobNode"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.set_options:3
msgid "dictionary of option and their values to set"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.set_remote_workdir:1
msgid "Set the absolute path to the working directory on the remote computer where the calculation is run."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.set_remote_workdir:3
msgid "absolute filepath to the remote working directory"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.set_retrieve_list:1
msgid "Set the retrieve list."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.set_retrieve_list:3
msgid "This list of directives will instruct the daemon what files to retrieve after the calculation has completed. list or tuple of files or paths that should be retrieved by the daemon."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.set_retrieve_list:6
#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.set_retrieve_temporary_list:6
msgid "list or tuple of with filepath directives"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.set_retrieve_temporary_list:1
msgid "Set the retrieve temporary list."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.set_retrieve_temporary_list:3
msgid "The retrieve temporary list stores files that are retrieved after completion and made available during parsing and are deleted as soon as the parsing has been completed."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.set_scheduler_state:1
msgid "Set the scheduler state."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.set_scheduler_state:3
msgid "an instance of `JobState`"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.set_state:1
msgid "Set the calculation active job state."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.set_state:3
msgid "ValueError if state is invalid"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.tools:1
#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.restapi.resources.CalcJobNode.CalcJobTranslator.CalcJobNode.tools:1
#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.restapi.translator.nodes.process.calculation.calcjob.CalcJobTranslator.CalcJobNode.tools:1
msgid "Return the calculation tools that are registered for the process type associated with this calculation."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.tools:3
#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.restapi.resources.CalcJobNode.CalcJobTranslator.CalcJobNode.tools:3
#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.restapi.translator.nodes.process.calculation.calcjob.CalcJobTranslator.CalcJobNode.tools:3
msgid "If the entry point name stored in the `process_type` of the CalcJobNode has an accompanying entry point in the `aiida.tools.calculations` entry point category, it will attempt to load the entry point and instantiate it passing the node to the constructor. If the entry point does not exist, cannot be resolved or loaded, a warning will be logged and the base CalculationTools class will be instantiated and returned."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNode.tools:8
#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.restapi.resources.CalcJobNode.CalcJobTranslator.CalcJobNode.tools:8
#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.restapi.translator.nodes.process.calculation.calcjob.CalcJobTranslator.CalcJobNode.tools:8
msgid "CalculationTools instance"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNodeCaching:1
msgid "Bases: :py:class:`~aiida.orm.nodes.process.process.ProcessNodeCaching`"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calcjob.py:docstring of aiida.orm.nodes.process.calculation.calcjob.CalcJobNodeCaching._get_objects_to_hash:3
msgid "This method is purposefully overridden from the base `Node` class, because we do not want to include the repository folder in the hash. The reason is that the hash of this node is computed in the `store` method, at which point the input files that will be stored in the repository have not yet been generated. Including these anyway in the computation of the hash would mean that the hash of the node would change as soon as the process has started and the input files have been written to the repository."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calculation.py:docstring of aiida.orm.nodes.process.calculation.calculation:1
msgid "Module with `Node` sub class for calculation processes."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calculation.py:docstring of aiida.orm.nodes.process.calculation.calculation.CalculationNode:1
#: ../../../src/aiida/orm/nodes/process/workflow/workflow.py:docstring of aiida.orm.nodes.process.workflow.workflow.WorkflowNode:1
msgid "Bases: :py:class:`~aiida.orm.nodes.process.process.ProcessNode`"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calculation.py:docstring of aiida.orm.nodes.process.calculation.calculation.CalculationNode:1
msgid "Base class for all nodes representing the execution of a calculation process."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calculation.py:docstring of aiida.orm.nodes.process.calculation.calculation.CalculationNode.inputs:1
msgid "Return an instance of `NodeLinksManager` to manage incoming INPUT_CALC links"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calculation.py:docstring of aiida.orm.nodes.process.calculation.calculation.CalculationNode.inputs:3
msgid "The returned Manager allows you to easily explore the nodes connected to this node via an incoming INPUT_CALC link. The incoming nodes are reachable by their link labels which are attributes of the manager."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calculation.py:docstring of aiida.orm.nodes.process.calculation.calculation.CalculationNode.outputs:1
msgid "Return an instance of `NodeLinksManager` to manage outgoing CREATE links"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/calculation/calculation.py:docstring of aiida.orm.nodes.process.calculation.calculation.CalculationNode.outputs:3
msgid "The returned Manager allows you to easily explore the nodes connected to this node via an outgoing CREATE link. The outgoing nodes are reachable by their link labels which are attributes of the manager."
msgstr ""

#: ../../source/reference/apidoc/aiida.orm.nodes.process.workflow.rst:2
msgid "aiida.orm.nodes.process.workflow package"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/workflow/__init__.py:docstring of aiida.orm.nodes.process.workflow:1
msgid "Module with `Node` sub classes for workflow processes."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/workflow/workchain.py:docstring of aiida.orm.nodes.process.workflow.workchain:1
msgid "Module with `Node` sub class for workchain processes."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/workflow/workchain.py:docstring of aiida.orm.nodes.process.workflow.workchain.WorkChainNode:1
msgid "Bases: :py:class:`~aiida.orm.nodes.process.workflow.workflow.WorkflowNode`"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/workflow/workchain.py:docstring of aiida.orm.nodes.process.workflow.workchain.WorkChainNode:1
msgid "ORM class for all nodes representing the execution of a WorkChain."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/workflow/workchain.py:docstring of aiida.orm.nodes.process.workflow.workchain.WorkChainNode.set_stepper_state_info:1
msgid "Set the stepper state info"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/workflow/workchain.py:docstring of aiida.orm.nodes.process.workflow.workchain.WorkChainNode.stepper_state_info:1
#: ../../../src/aiida/orm/nodes/process/workflow/workchain.py:docstring of aiida.restapi.translator.nodes.process.workflow.workchain.WorkChainTranslator.WorkChainNode.stepper_state_info:1
msgid "Return the stepper state info"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/workflow/workflow.py:docstring of aiida.orm.nodes.process.workflow.workflow:1
msgid "Module with `Node` sub class for workflow processes."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/workflow/workflow.py:docstring of aiida.orm.nodes.process.workflow.workflow.WorkflowNode:1
msgid "Base class for all nodes representing the execution of a workflow process."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/workflow/workflow.py:docstring of aiida.orm.nodes.process.workflow.workflow.WorkflowNode.inputs:1
msgid "Return an instance of `NodeLinksManager` to manage incoming INPUT_WORK links"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/workflow/workflow.py:docstring of aiida.orm.nodes.process.workflow.workflow.WorkflowNode.inputs:3
msgid "The returned Manager allows you to easily explore the nodes connected to this node via an incoming INPUT_WORK link. The incoming nodes are reachable by their link labels which are attributes of the manager."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/workflow/workflow.py:docstring of aiida.orm.nodes.process.workflow.workflow.WorkflowNode.inputs:7
#: ../../../src/aiida/orm/nodes/process/workflow/workflow.py:docstring of aiida.orm.nodes.process.workflow.workflow.WorkflowNode.outputs:7
msgid "`NodeLinksManager`"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/workflow/workflow.py:docstring of aiida.orm.nodes.process.workflow.workflow.WorkflowNode.outputs:1
msgid "Return an instance of `NodeLinksManager` to manage outgoing RETURN links"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/workflow/workflow.py:docstring of aiida.orm.nodes.process.workflow.workflow.WorkflowNode.outputs:3
msgid "The returned Manager allows you to easily explore the nodes connected to this node via an outgoing RETURN link. The outgoing nodes are reachable by their link labels which are attributes of the manager."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/workflow/workflow.py:docstring of aiida.orm.nodes.process.workflow.workflow.WorkflowNodeLinks.validate_outgoing:3
msgid "A workflow cannot 'create' Data, so if we receive an outgoing link to an unstored Data node, that means the user created a Data node within our function body and tries to attach it as an output. This is strictly forbidden and can cause provenance to be lost."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/workflow/workfunction.py:docstring of aiida.orm.nodes.process.workflow.workfunction:1
msgid "Module with `Node` sub class for workflow function processes."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/workflow/workfunction.py:docstring of aiida.orm.nodes.process.workflow.workfunction.WorkFunctionNode:1
msgid "Bases: :py:class:`~aiida.orm.utils.mixins.FunctionCalculationMixin`, :py:class:`~aiida.orm.nodes.process.workflow.workflow.WorkflowNode`"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/workflow/workfunction.py:docstring of aiida.orm.nodes.process.workflow.workfunction.WorkFunctionNode:1
msgid "ORM class for all nodes representing the execution of a workfunction."
msgstr ""

#: ../../../src/aiida/orm/nodes/process/workflow/workfunction.py:docstring of aiida.orm.nodes.process.workflow.workfunction.WorkFunctionNodeLinks:1
msgid "Bases: :py:class:`~aiida.orm.nodes.process.workflow.workflow.WorkflowNodeLinks`"
msgstr ""

#: ../../../src/aiida/orm/nodes/process/workflow/workfunction.py:docstring of aiida.orm.nodes.process.workflow.workfunction.WorkFunctionNodeLinks.validate_outgoing:3
msgid "A workfunction cannot create Data, so if we receive an outgoing RETURN link to an unstored Data node, that means the user created a Data node within our function body and is trying to return it. This use case should be reserved for @calcfunctions, as they can have CREATE links."
msgstr ""

#: ../../source/reference/apidoc/aiida.orm.utils.rst:2
msgid "aiida.orm.utils package"
msgstr ""

#: ../../../src/aiida/orm/utils/__init__.py:docstring of aiida.orm.utils:1
msgid "Utilities related to the ORM."
msgstr ""

#: ../../../src/aiida/orm/utils/calcjob.py:docstring of aiida.orm.utils.calcjob:1
msgid "Utilities to operate on `CalcJobNode` instances."
msgstr ""

#: ../../../src/aiida/orm/utils/calcjob.py:docstring of aiida.orm.utils.calcjob.CalcJobResultManager:1
msgid "Utility class to easily access the contents of the 'default output' node of a `CalcJobNode`."
msgstr ""

#: ../../../src/aiida/orm/utils/calcjob.py:docstring of aiida.orm.utils.calcjob.CalcJobResultManager:3
msgid "A `CalcJob` process can mark one of its outputs as the 'default output'. The default output node will always be returned by the `CalcJob` and will always be a `Dict` node."
msgstr ""

#: ../../../src/aiida/orm/utils/calcjob.py:docstring of aiida.orm.utils.calcjob.CalcJobResultManager:6
msgid "If a `CalcJob` defines such a default output node, this utility class will simplify retrieving the result of said node through the `CalcJobNode` instance produced by the execution of the `CalcJob`."
msgstr ""

#: ../../../src/aiida/orm/utils/calcjob.py:docstring of aiida.orm.utils.calcjob.CalcJobResultManager:9
msgid "The default results are only defined if the `CalcJobNode` has a `process_type` that can be successfully used to load the corresponding `CalcJob` process class *and* if its process spec defines a `default_output_node`. If both these conditions are met, the results are defined as the dictionary contained within the default output node."
msgstr ""

#: ../../../src/aiida/orm/utils/calcjob.py:docstring of aiida.orm.utils.calcjob.CalcJobResultManager.__dir__:1
msgid "Add the keys of the results dictionary such that they can be autocompleted."
msgstr ""

#: ../../../src/aiida/orm/utils/calcjob.py:docstring of aiida.orm.utils.calcjob.CalcJobResultManager.__getattr__:1
#: ../../../src/aiida/orm/utils/calcjob.py:docstring of aiida.orm.utils.calcjob.CalcJobResultManager.__getitem__:1
msgid "Return an attribute from the results dictionary."
msgstr ""

#: ../../../src/aiida/orm/utils/calcjob.py:docstring of aiida.orm.utils.calcjob.CalcJobResultManager.__getattr__:3
#: ../../../src/aiida/orm/utils/calcjob.py:docstring of aiida.orm.utils.calcjob.CalcJobResultManager.__getitem__:3
msgid "name of the result return"
msgstr ""

#: ../../../src/aiida/orm/utils/calcjob.py:docstring of aiida.orm.utils.calcjob.CalcJobResultManager.__getattr__:5
#: ../../../src/aiida/orm/utils/calcjob.py:docstring of aiida.orm.utils.calcjob.CalcJobResultManager.__getitem__:5
msgid "if the results node cannot be retrieved or it does not contain the `name` attribute"
msgstr ""

#: ../../../src/aiida/orm/utils/calcjob.py:docstring of aiida.orm.utils.calcjob.CalcJobResultManager.__init__:1
msgid "Construct an instance of the `CalcJobResultManager`."
msgstr ""

#: ../../../src/aiida/orm/utils/calcjob.py:docstring of aiida.orm.utils.calcjob.CalcJobResultManager.__init__:3
msgid "the `CalcJobNode` instance."
msgstr ""

#: ../../../src/aiida/orm/utils/calcjob.py:docstring of aiida.orm.utils.calcjob.CalcJobResultManager.__iter__:1
msgid "Return an iterator over the keys of the result dictionary."
msgstr ""

#: ../../../src/aiida/orm/utils/calcjob.py:docstring of aiida.orm.utils.calcjob.CalcJobResultManager._load_results:1
msgid "Try to load the results for the `CalcJobNode` of this result manager."
msgstr ""

#: ../../../src/aiida/orm/utils/calcjob.py:docstring of aiida.orm.utils.calcjob.CalcJobResultManager._load_results:3
msgid "if no default output node could be loaded"
msgstr ""

#: ../../../src/aiida/orm/utils/calcjob.py:docstring of aiida.orm.utils.calcjob.CalcJobResultManager.get_results:1
msgid "Return the results dictionary of the default results node of the calculation node."
msgstr ""

#: ../../../src/aiida/orm/utils/calcjob.py:docstring of aiida.orm.utils.calcjob.CalcJobResultManager.get_results:3
msgid "This property will lazily load the dictionary."
msgstr ""

#: ../../../src/aiida/orm/utils/calcjob.py:docstring of aiida.orm.utils.calcjob.CalcJobResultManager.get_results:5
msgid "the dictionary of the default result node"
msgstr ""

#: ../../../src/aiida/orm/utils/calcjob.py:docstring of aiida.orm.utils.calcjob.CalcJobResultManager.node:1
msgid "Return the `CalcJobNode` associated with this result manager instance."
msgstr ""

#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links:1
msgid "Utilities for dealing with links between nodes."
msgstr ""

#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links.LinkManager:1
msgid "Class to convert a list of LinkTriple tuples into an iterator."
msgstr ""

#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links.LinkManager:3
msgid "It defines convenience methods to retrieve certain subsets of LinkTriple while checking for consistency. For example::"
msgstr ""

#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links.LinkManager:10
msgid "The methods `all_nodes` and `all_link_labels` are syntactic sugar wrappers around `all` to get a list of only the incoming nodes or link labels, respectively."
msgstr ""

#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links.LinkManager.__init__:1
msgid "Initialise the collection."
msgstr ""

#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links.LinkManager.__iter__:1
msgid "Return an iterator of LinkTriple instances."
msgstr ""

#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links.LinkManager.__iter__:3
msgid "iterator of LinkTriple instances"
msgstr ""

#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links.LinkManager.__next__:1
#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links.LinkManager.next:1
msgid "Return the next element in the iterator."
msgstr ""

#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links.LinkManager.__next__:3
#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links.LinkManager.next:3
msgid "LinkTriple"
msgstr ""

#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links.LinkManager.all:1
msgid "Return all entries from the list."
msgstr ""

#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links.LinkManager.all:3
msgid "list of LinkTriple instances"
msgstr ""

#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links.LinkManager.all_link_labels:1
msgid "Return a list of all link labels."
msgstr ""

#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links.LinkManager.all_link_labels:3
msgid "list of link labels"
msgstr ""

#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links.LinkManager.all_link_pairs:1
msgid "Return a list of all link pairs."
msgstr ""

#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links.LinkManager.all_link_pairs:3
msgid "list of LinkPair instances"
msgstr ""

#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links.LinkManager.all_nodes:1
msgid "Return a list of all nodes."
msgstr ""

#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links.LinkManager.all_nodes:3
msgid "list of nodes"
msgstr ""

#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links.LinkManager.first:1
msgid "Return the first entry from the iterator."
msgstr ""

#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links.LinkManager.first:3
msgid "LinkTriple instance or None if no entries were matched"
msgstr ""

#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links.LinkManager.get_node_by_label:1
msgid "Return the node from list for given label."
msgstr ""

#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links.LinkManager.get_node_by_label:3
msgid "node that corresponds to the given label"
msgstr ""

#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links.LinkManager.get_node_by_label:4
msgid "if the label is not present among the link_triples"
msgstr ""

#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links.LinkManager.nested:1
msgid "Construct (nested) dictionary of matched nodes that mirrors the original nesting of link namespaces."
msgstr ""

#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links.LinkManager.nested:3
msgid "Process input and output namespaces can be nested, however the link labels that represent them in the database have a flat hierarchy, and so the link labels are flattened representations of the nested namespaces. This function reconstructs the original node nesting based on the flattened links."
msgstr ""

#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links.LinkManager.nested:7
msgid "dictionary of nested namespaces"
msgstr ""

#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links.LinkManager.nested:8
msgid "if there are duplicate link labels in a namespace"
msgstr ""

#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links.LinkManager.one:1
msgid "Return a single entry from the iterator."
msgstr ""

#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links.LinkManager.one:3
msgid "If the iterator contains no or more than one entry, an exception will be raised :return: LinkTriple instance :raises ValueError: if the iterator contains anything but one entry"
msgstr ""

#: ../../../src/aiida/orm/utils/links.py:docstring of namedtuple_LinkPair.LinkPair.__new__:1
msgid "Create new instance of LinkPair(link_type, link_label)"
msgstr ""

#: ../../../src/aiida/orm/utils/links.py:docstring of collections.LinkPair._make:1
msgid "Make a new LinkPair object from a sequence or iterable"
msgstr ""

#: ../../../src/aiida/orm/utils/links.py:docstring of collections.LinkPair._replace:1
msgid "Return a new LinkPair object replacing specified fields with new values"
msgstr ""

#: ../../../src/aiida/orm/utils/links.py:docstring of namedtuple_LinkQuadruple.LinkQuadruple.__new__:1
msgid "Create new instance of LinkQuadruple(source_id, target_id, link_type, link_label)"
msgstr ""

#: ../../../src/aiida/orm/utils/links.py:docstring of collections.LinkQuadruple._make:1
msgid "Make a new LinkQuadruple object from a sequence or iterable"
msgstr ""

#: ../../../src/aiida/orm/utils/links.py:docstring of collections.LinkQuadruple._replace:1
msgid "Return a new LinkQuadruple object replacing specified fields with new values"
msgstr ""

#: ../../../src/aiida/orm/utils/links.py:docstring of namedtuple_LinkTriple.LinkTriple.__new__:1
msgid "Create new instance of LinkTriple(node, link_type, link_label)"
msgstr ""

#: ../../../src/aiida/orm/utils/links.py:docstring of collections.LinkTriple._make:1
msgid "Make a new LinkTriple object from a sequence or iterable"
msgstr ""

#: ../../../src/aiida/orm/utils/links.py:docstring of collections.LinkTriple._replace:1
msgid "Return a new LinkTriple object replacing specified fields with new values"
msgstr ""

#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links.link_triple_exists:1
msgid "Return whether a link with the given type and label exists between the given source and target node."
msgstr ""

#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links.link_triple_exists:3
msgid "node from which the link is outgoing"
msgstr ""

#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links.link_triple_exists:4
msgid "node to which the link is incoming"
msgstr ""

#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links.link_triple_exists:7
msgid "boolean, True if the link triple exists, False otherwise"
msgstr ""

#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links.validate_link:1
msgid "Validate adding a link of the given type and label from a given node to ourself."
msgstr ""

#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links.validate_link:3
msgid "This function will first validate the class types of the inputs and will subsequently validate whether a link of the specified type is allowed at all between the nodes types of the source and target."
msgstr ""

#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links.validate_link:6
msgid "Subsequently, the validity of the \"indegree\" and \"outdegree\" of the proposed link is validated, which means validating that the uniqueness constraints of the incoming links into the target node and the outgoing links from the source node are not violated. In AiiDA's provenance graph each link type has one of the following three types of \"degree\" character::"
msgstr ""

#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links.validate_link:15
msgid "Each degree character has a different unique constraint on its links, here defined for the indegree::"
msgstr ""

#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links.validate_link:25
msgid "The same holds for outdegree, but then it concerns outgoing links from the source node to the target node."
msgstr ""

#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links.validate_link:27
msgid "For illustration purposes, consider the following example provenance graphs that are considered legal, where `WN`, `DN` and `CN` represent a `WorkflowNode`, a `DataNode` and a `CalculationNode`, respectively::"
msgstr ""

#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links.validate_link:42
msgid "In example 1, the link uniqueness constraint is not violated because despite the labels having the same label `a`, their link types, `CALL_CALC` and `INPUT_CALC`, respectively, are different and their `unique_pair` indegree is not violated."
msgstr ""

#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links.validate_link:46
msgid "Similarly, in the second example, the constraint is not violated, because despite both links having the same link type `INPUT_CALC`, the have different labels, so the `unique_pair` indegree of the `INPUT_CALC` is not violated."
msgstr ""

#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links.validate_link:49
msgid "Finally, in the third example, we see two `WorkflowNodes` both returning the same `DataNode` and with the same label. Despite the two incoming links here having both the same type as well as the same label, the uniqueness constraint is not violated, because the indegree for `RETURN` links is `unique_triple` which means that the triple of source node and link type and label should be unique."
msgstr ""

#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links.validate_link:56
msgid "the type of link"
msgstr ""

#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links.validate_link:57
msgid "link label"
msgstr ""

#: ../../../src/aiida/orm/utils/links.py:docstring of aiida.orm.utils.links.validate_link:58
msgid "if `source` or `target` is not a Node instance, or `link_type` is not a `LinkType` enum"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders:1
msgid "Module with `OrmEntityLoader` and its sub classes that simplify loading entities through their identifiers."
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.CalculationEntityLoader:1
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.CodeEntityLoader:1
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.ComputerEntityLoader:1
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.DataEntityLoader:1
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.GroupEntityLoader:1
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.NodeEntityLoader:1
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.ProcessEntityLoader:1
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.WorkflowEntityLoader:1
msgid "Bases: :py:class:`~aiida.orm.utils.loaders.OrmEntityLoader`"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.CalculationEntityLoader:1
msgid "Loader for the `Calculation` entity and sub classes."
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.CalculationEntityLoader._get_query_builder_label_identifier:1
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.CodeEntityLoader._get_query_builder_label_identifier:1
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.ComputerEntityLoader._get_query_builder_label_identifier:1
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.DataEntityLoader._get_query_builder_label_identifier:1
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.GroupEntityLoader._get_query_builder_label_identifier:1
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.NodeEntityLoader._get_query_builder_label_identifier:1
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader._get_query_builder_label_identifier:1
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.ProcessEntityLoader._get_query_builder_label_identifier:1
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.WorkflowEntityLoader._get_query_builder_label_identifier:1
msgid "Return the query builder instance that attempts to map the identifier onto an entity of the orm class, defined for this loader class, interpreting the identifier as a LABEL like identifier"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.CalculationEntityLoader._get_query_builder_label_identifier:4
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.CodeEntityLoader._get_query_builder_label_identifier:4
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.ComputerEntityLoader._get_query_builder_label_identifier:4
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.DataEntityLoader._get_query_builder_label_identifier:4
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.GroupEntityLoader._get_query_builder_label_identifier:4
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.NodeEntityLoader._get_query_builder_label_identifier:4
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader._get_query_builder_label_identifier:4
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.ProcessEntityLoader._get_query_builder_label_identifier:4
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.WorkflowEntityLoader._get_query_builder_label_identifier:4
msgid "the LABEL identifier"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.CalculationEntityLoader._get_query_builder_label_identifier:5
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.CodeEntityLoader._get_query_builder_label_identifier:5
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.ComputerEntityLoader._get_query_builder_label_identifier:5
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.DataEntityLoader._get_query_builder_label_identifier:5
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.GroupEntityLoader._get_query_builder_label_identifier:5
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.NodeEntityLoader._get_query_builder_label_identifier:5
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader._get_query_builder_id_identifier:5
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader._get_query_builder_label_identifier:5
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader._get_query_builder_uuid_identifier:5
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.ProcessEntityLoader._get_query_builder_label_identifier:5
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.WorkflowEntityLoader._get_query_builder_label_identifier:5
msgid "a tuple of orm classes to which the identifier should be mapped"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.CalculationEntityLoader._get_query_builder_label_identifier:6
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.CodeEntityLoader._get_query_builder_label_identifier:6
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.ComputerEntityLoader._get_query_builder_label_identifier:6
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.DataEntityLoader._get_query_builder_label_identifier:6
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.GroupEntityLoader._get_query_builder_label_identifier:6
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.NodeEntityLoader._get_query_builder_label_identifier:6
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader._get_query_builder_label_identifier:6
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader.get_query_builder:8
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.ProcessEntityLoader._get_query_builder_label_identifier:6
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.WorkflowEntityLoader._get_query_builder_label_identifier:6
msgid "the operator to use in the query"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.CalculationEntityLoader._get_query_builder_label_identifier:7
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.CodeEntityLoader._get_query_builder_label_identifier:7
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.ComputerEntityLoader._get_query_builder_label_identifier:7
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.DataEntityLoader._get_query_builder_label_identifier:7
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.GroupEntityLoader._get_query_builder_label_identifier:7
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.NodeEntityLoader._get_query_builder_label_identifier:7
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader._get_query_builder_label_identifier:7
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader.get_query_builder:9
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.ProcessEntityLoader._get_query_builder_label_identifier:7
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.WorkflowEntityLoader._get_query_builder_label_identifier:7
msgid "the property or properties to project for entities matching the query"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.CalculationEntityLoader._get_query_builder_label_identifier:8
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.CodeEntityLoader._get_query_builder_label_identifier:8
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.ComputerEntityLoader._get_query_builder_label_identifier:8
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.DataEntityLoader._get_query_builder_label_identifier:8
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.GroupEntityLoader._get_query_builder_label_identifier:8
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.NodeEntityLoader._get_query_builder_label_identifier:8
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.ProcessEntityLoader._get_query_builder_label_identifier:8
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.WorkflowEntityLoader._get_query_builder_label_identifier:8
msgid "the query builder instance that should retrieve the entity corresponding to the identifier"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.CalculationEntityLoader._get_query_builder_label_identifier:9
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.CodeEntityLoader._get_query_builder_label_identifier:9
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.ComputerEntityLoader._get_query_builder_label_identifier:9
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.DataEntityLoader._get_query_builder_label_identifier:9
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.GroupEntityLoader._get_query_builder_label_identifier:9
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.NodeEntityLoader._get_query_builder_label_identifier:9
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader._get_query_builder_label_identifier:9
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.ProcessEntityLoader._get_query_builder_label_identifier:9
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.WorkflowEntityLoader._get_query_builder_label_identifier:9
msgid "if the identifier is invalid"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.CalculationEntityLoader._get_query_builder_label_identifier:10
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.CodeEntityLoader._get_query_builder_label_identifier:10
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.ComputerEntityLoader._get_query_builder_label_identifier:10
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.DataEntityLoader._get_query_builder_label_identifier:10
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.GroupEntityLoader._get_query_builder_label_identifier:10
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.NodeEntityLoader._get_query_builder_label_identifier:10
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader._get_query_builder_label_identifier:10
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.ProcessEntityLoader._get_query_builder_label_identifier:10
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.WorkflowEntityLoader._get_query_builder_label_identifier:10
msgid "if the orm base class does not support a LABEL like identifier"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.CodeEntityLoader:1
msgid "Loader for the `Code` entity and sub classes."
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.ComputerEntityLoader:1
msgid "Loader for the `Computer` entity and sub classes."
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.DataEntityLoader:1
msgid "Loader for the `Data` entity and sub classes."
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.GroupEntityLoader:1
msgid "Loader for the `Group` entity and sub classes."
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.IdentifierType:1
msgid "The enumeration that defines the three types of identifier that can be used to identify an orm entity. The ID is always an integer, the UUID a base 16 encoded integer with optional dashes and the LABEL can be any string based label or name, the format of which will vary per orm class"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.NodeEntityLoader:1
msgid "Loader for the `Node` entity and sub classes."
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader:1
msgid "Base class for entity loaders."
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader._get_query_builder_id_identifier:1
msgid "Return the query builder instance that attempts to map the identifier onto an entity of the orm class, defined for this loader class, interpreting the identifier as an ID like identifier"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader._get_query_builder_id_identifier:4
msgid "the ID identifier"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader._get_query_builder_id_identifier:6
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader._get_query_builder_label_identifier:8
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader._get_query_builder_uuid_identifier:6
msgid "the query builder instance"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader._get_query_builder_uuid_identifier:1
msgid "Return the query builder instance that attempts to map the identifier onto an entity of the orm class, defined for this loader class, interpreting the identifier as a UUID like identifier"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader._get_query_builder_uuid_identifier:4
msgid "the UUID identifier"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader.get_options:1
msgid "Return the list of entities that match the `incomplete` identifier."
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader.get_options:3
msgid "For the time being only `LABEL` auto-completion is supported so the identifier type is not inferred but hard-coded to be `IdentifierType.LABEL`"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader.get_options:6
msgid "the incomplete identifier"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader.get_options:7
msgid "the field(s) to project for each entity that matches the incomplete identifier"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader.get_options:8
msgid "list of entities matching the incomplete identifier"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader.get_query_builder:1
msgid "Return the query builder instance that attempts to map the identifier onto an entity of the orm class, defined for this loader class, inferring the identifier type if it is not defined."
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader.get_query_builder:4
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader.load_entity:3
msgid "the identifier"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader.get_query_builder:5
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader.load_entity:4
msgid "the type of the identifier"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader.get_query_builder:6
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader.get_query_classes:6
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader.load_entity:5
msgid "an optional tuple of orm classes, that should each be strict sub classes of the base orm class of the loader, that will narrow the queryset"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader.get_query_builder:10
msgid "the query builder instance and a dictionary of used query parameters"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader.get_query_classes:1
msgid "Get the tuple of classes to be used for the entity query. If sub_classes is defined, each class will be validated by verifying that it is a sub class of the loader's orm base class. Validate a tuple of classes if a user passes in a specific one when attempting to load an entity. Each class should be a sub class of the entity loader's orm base class"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader.get_query_classes:8
msgid "the tuple of orm classes to be used for the entity query"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader.get_query_classes:9
msgid "if any of the classes are not a sub class of the entity loader's orm base class"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader.infer_identifier_type:1
msgid "Attempt to automatically distinguish which identifier type is implied for the given value."
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader.infer_identifier_type:3
msgid "The strategy is to first attempt to convert the value to an integer. If successful, it is assumed that the value represents an ID. If that fails, we attempt to interpret the value as a base 16 encoded integer, after having removed any dashes from the string. If that succeeds, it is most likely a UUID. If it seems to be neither an ID nor a UUID, it is assumed to be a LABEL like identifier."
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader.infer_identifier_type:8
msgid "With this approach there is the possibility for ambiguity. Since it is allowed to pass a partial UUID, it is possible that the partial UUID is also a valid ID. Likewise, a LABEL identifier might also be a valid ID, or a valid (partial) UUID. Fortunately, these ambiguities can be solved though:"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader.infer_identifier_type:12
msgid "ID/UUID: can always be solved by passing a partial UUID with at least one dash"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader.infer_identifier_type:13
msgid "ID/LABEL: appending an exclamation point ! to the identifier, will force LABEL interpretation"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader.infer_identifier_type:14
msgid "UUID/LABEL: appending an exclamation point ! to the identifier, will force LABEL interpretation"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader.infer_identifier_type:16
msgid "As one can see, the user will always be able to include at least one dash of the UUID identifier to prevent it from being interpreted as an ID. For the potential ambiguities in LABEL identifiers, we had to introduce a special marker to provide a surefire way of breaking any ambiguity that may arise. Adding an exclamation point will break the normal strategy and the identifier will directly be interpreted as a LABEL identifier."
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader.infer_identifier_type:21
msgid "the value of the identifier"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader.infer_identifier_type:22
msgid "the identifier and identifier type"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader.infer_identifier_type:23
msgid "if the value is an invalid identifier"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader.load_entity:1
msgid "Load an entity that uniquely corresponds to the provided identifier of the identifier type."
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader.load_entity:7
msgid "the loaded entity"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader.load_entity:8
msgid "if the identifier maps onto multiple entities"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.OrmEntityLoader.load_entity:9
msgid "if the identifier maps onto not a single entity"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.ProcessEntityLoader:1
msgid "Loader for the `Process` entity and sub classes."
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.WorkflowEntityLoader:1
msgid "Loader for the `Workflow` entity and sub classes."
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.get_loader:1
msgid "Return the correct OrmEntityLoader for the given orm class."
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.get_loader:3
msgid "the orm class"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.get_loader:4
msgid "a subclass of OrmEntityLoader"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.get_loader:5
msgid "if no OrmEntityLoader subclass can be found for the given orm class"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_code:1
msgid "Load a Code instance by one of its identifiers: pk, uuid or label"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_code:3
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_computer:3
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_entity:3
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_group:3
msgid "If the type of the identifier is unknown simply pass it without a keyword and the loader will attempt to automatically infer the type."
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_code:6
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_entity:6
msgid "pk (integer), uuid (string) or label (string) of a Code"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_code:7
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_entity:7
msgid "pk of a Code"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_code:8
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_entity:8
msgid "uuid of a Code, or the beginning of the uuid"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_code:9
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_entity:9
msgid "label of a Code"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_code:10
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_computer:10
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_entity:10
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_group:10
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_node:8
msgid "an optional tuple of orm classes to narrow the queryset. Each class should be a strict sub class of the ORM class of the given entity loader."
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_code:12
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_computer:12
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_entity:12
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_group:12
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_node:10
msgid "allow to query for a uuid with dashes"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_code:13
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_entity:13
msgid "the Code instance"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_code:14
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_computer:14
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_entity:14
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_group:14
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_node:12
msgid "if none or more than one of the identifiers are supplied"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_code:15
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_computer:15
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_entity:15
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_group:15
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_node:13
msgid "if the provided identifier has the wrong type"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_code:16
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_entity:16
msgid "if no matching Code is found"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_code:17
#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_entity:17
msgid "if more than one Code was found"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_computer:1
msgid "Load a Computer instance by one of its identifiers: pk, uuid or label"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_computer:6
msgid "pk (integer), uuid (string) or label (string) of a Computer"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_computer:7
msgid "pk of a Computer"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_computer:8
msgid "uuid of a Computer, or the beginning of the uuid"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_computer:9
msgid "label of a Computer"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_computer:13
msgid "the Computer instance"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_computer:16
msgid "if no matching Computer is found"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_computer:17
msgid "if more than one Computer was found"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_entity:1
msgid "Load an entity instance by one of its identifiers: pk, uuid or label"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_group:1
msgid "Load a Group instance by one of its identifiers: pk, uuid or label"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_group:6
msgid "pk (integer), uuid (string) or label (string) of a Group"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_group:7
msgid "pk of a Group"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_group:8
msgid "uuid of a Group, or the beginning of the uuid"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_group:9
msgid "label of a Group"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_group:13
msgid "the Group instance"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_group:16
msgid "if no matching Group is found"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_group:17
msgid "if more than one Group was found"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_node:1
msgid "Load a node by one of its identifiers: pk or uuid. If the type of the identifier is unknown simply pass it without a keyword and the loader will attempt to infer the type"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_node:4
msgid "pk (integer) or uuid (string)"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_node:5
msgid "pk of a node"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_node:6
msgid "uuid of a node, or the beginning of the uuid"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_node:7
msgid "label of a Node"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_node:11
msgid "the node instance"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_node:14
msgid "if no matching Node is found"
msgstr ""

#: ../../../src/aiida/orm/utils/loaders.py:docstring of aiida.orm.utils.loaders.load_node:15
msgid "if more than one Node was found"
msgstr ""

#: ../../../src/aiida/orm/utils/log.py:docstring of aiida.orm.utils.log:1
msgid "Module for logging methods/classes that need the ORM."
msgstr ""

#: ../../../src/aiida/orm/utils/log.py:docstring of aiida.orm.utils.log.DBLogHandler:1
msgid "A custom db log handler for writing logs tot he database"
msgstr ""

#: ../../../src/aiida/orm/utils/log.py:docstring of aiida.orm.utils.log.DBLogHandler.emit:1
msgid "Do whatever it takes to actually log the specified logging record."
msgstr ""

#: ../../../src/aiida/orm/utils/log.py:docstring of aiida.orm.utils.log.DBLogHandler.emit:3
msgid "This version is intended to be implemented by subclasses and so raises a NotImplementedError."
msgstr ""

#: ../../../src/aiida/orm/utils/log.py:docstring of aiida.orm.utils.log.create_logger_adapter:1
msgid "Create a logger adapter for the given Node instance."
msgstr ""

#: ../../../src/aiida/orm/utils/log.py:docstring of aiida.orm.utils.log.create_logger_adapter:3
msgid "the logger to adapt"
msgstr ""

#: ../../../src/aiida/orm/utils/log.py:docstring of aiida.orm.utils.log.create_logger_adapter:4
msgid "the node instance to create the adapter for"
msgstr ""

#: ../../../src/aiida/orm/utils/log.py:docstring of aiida.orm.utils.log.create_logger_adapter:5
msgid "the logger adapter"
msgstr ""

#: ../../../src/aiida/orm/utils/log.py:docstring of aiida.orm.utils.log.create_logger_adapter:6
msgid ":class:`logging.LoggerAdapter`"
msgstr ""

#: ../../../src/aiida/orm/utils/log.py:docstring of aiida.orm.utils.log.get_dblogger_extra:1
msgid "Return the additional information necessary to attach any log records to the given node instance."
msgstr ""

#: ../../../src/aiida/orm/utils/managers.py:docstring of aiida.orm.utils.managers:1
msgid "Contain utility classes for \"managers\", i.e., classes that allow to access members of other classes via TAB-completable attributes (e.g. the class underlying `calculation.inputs` to allow to do `calculation.inputs.<label>`)."
msgstr ""

#: ../../../src/aiida/orm/utils/managers.py:docstring of aiida.orm.utils.managers.AttributeManager:1
msgid "An object used internally to return the attributes as a dictionary. This is currently used in :py:class:`~aiida.orm.nodes.data.dict.Dict`, for instance."
msgstr ""

#: ../../../src/aiida/orm/utils/managers.py:docstring of aiida.orm.utils.managers.AttributeManager:5
msgid "Important! It cannot be used to change variables, just to read them. To change values (of unstored nodes), use the proper Node methods."
msgstr ""

#: ../../../src/aiida/orm/utils/managers.py:docstring of aiida.orm.utils.managers.AttributeManager.__dir__:1
msgid "Allow to list the keys of the dictionary"
msgstr ""

#: ../../../src/aiida/orm/utils/managers.py:docstring of aiida.orm.utils.managers.AttributeManager.__getattr__:1
msgid "Interface to get to dictionary values, using the key as an attribute."
msgstr ""

#: ../../../src/aiida/orm/utils/managers.py:docstring of aiida.orm.utils.managers.AttributeManager.__getattr__:3
msgid "it works only for attributes that only contain letters, numbers and underscores, and do not start with a number."
msgstr ""

#: ../../../src/aiida/orm/utils/managers.py:docstring of aiida.orm.utils.managers.AttributeManager.__getattr__:6
#: ../../../src/aiida/orm/utils/managers.py:docstring of aiida.orm.utils.managers.AttributeManager.__getitem__:3
msgid "name of the key whose value is required."
msgstr ""

#: ../../../src/aiida/orm/utils/managers.py:docstring of aiida.orm.utils.managers.AttributeManager.__getitem__:1
msgid "Interface to get to dictionary values as a dictionary."
msgstr ""

#: ../../../src/aiida/orm/utils/managers.py:docstring of aiida.orm.utils.managers.AttributeManager.__init__:1
msgid "the node object."
msgstr ""

#: ../../../src/aiida/orm/utils/managers.py:docstring of aiida.orm.utils.managers.AttributeManager.__iter__:1
msgid "Return the keys as an iterator"
msgstr ""

#: ../../../src/aiida/orm/utils/builders/code.py:docstring of aiida.orm.utils.builders.code.CodeBuilder.__setattr__:1
#: ../../../src/aiida/orm/utils/builders/computer.py:docstring of aiida.orm.utils.builders.computer.ComputerBuilder.__setattr__:1
#: ../../../src/aiida/orm/utils/managers.py:docstring of aiida.orm.utils.managers.AttributeManager.__setattr__:1
msgid "Implement setattr(self, name, value)."
msgstr ""

#: ../../../src/aiida/orm/utils/managers.py:docstring of aiida.orm.utils.managers.AttributeManager._get_dict:1
msgid "Return the internal dictionary"
msgstr ""

#: ../../../src/aiida/orm/utils/managers.py:docstring of aiida.orm.utils.managers.NodeLinksManager:1
msgid "A manager that allows to inspect, with tab-completion, nodes linked to a given one. See an example of its use in `CalculationNode.inputs`."
msgstr ""

#: ../../../src/aiida/orm/utils/managers.py:docstring of aiida.orm.utils.managers.NodeLinksManager.__contains__:1
msgid "Override the operator of the base class to emit deprecation warning if double underscore is used in key."
msgstr ""

#: ../../../src/aiida/orm/utils/managers.py:docstring of aiida.orm.utils.managers.NodeLinksManager.__dir__:1
msgid "Allow to list all valid input links"
msgstr ""

#: ../../../src/aiida/orm/utils/managers.py:docstring of aiida.orm.utils.managers.NodeLinksManager.__getattr__:1
#: ../../../src/aiida/orm/utils/managers.py:docstring of aiida.orm.utils.managers.NodeLinksManager.__getitem__:3
msgid "name of the attribute to be asked to the parser results."
msgstr ""

#: ../../../src/aiida/orm/utils/managers.py:docstring of aiida.orm.utils.managers.NodeLinksManager.__getitem__:1
msgid "Interface to get to the parser results as a dictionary."
msgstr ""

#: ../../../src/aiida/orm/utils/managers.py:docstring of aiida.orm.utils.managers.NodeLinksManager.__init__:1
msgid "Initialise the link manager."
msgstr ""

#: ../../../src/aiida/orm/utils/managers.py:docstring of aiida.orm.utils.managers.NodeLinksManager.__init__:3
msgid "the reference node object"
msgstr ""

#: ../../../src/aiida/orm/utils/managers.py:docstring of aiida.orm.utils.managers.NodeLinksManager.__init__:4
msgid "the link_type to inspect"
msgstr ""

#: ../../../src/aiida/orm/utils/managers.py:docstring of aiida.orm.utils.managers.NodeLinksManager.__init__:5
msgid "if True, inspect incoming links, otherwise inspect outgoing links"
msgstr ""

#: ../../../src/aiida/orm/utils/managers.py:docstring of aiida.orm.utils.managers.NodeLinksManager.__str__:1
msgid "Return a string representation of the manager"
msgstr ""

#: ../../../src/aiida/orm/utils/managers.py:docstring of aiida.orm.utils.managers.NodeLinksManager._construct_attribute_dict:1
msgid "Construct an attribute dict from all links of the node, recreating nested namespaces from flat link labels."
msgstr ""

#: ../../../src/aiida/orm/utils/managers.py:docstring of aiida.orm.utils.managers.NodeLinksManager._construct_attribute_dict:3
msgid "if True, inspect incoming links, otherwise inspect outgoing links."
msgstr ""

#: ../../../src/aiida/orm/utils/managers.py:docstring of aiida.orm.utils.managers.NodeLinksManager._get_keys:1
msgid "Return the valid link labels, used e.g. to make getattr() work"
msgstr ""

#: ../../../src/aiida/orm/utils/managers.py:docstring of aiida.orm.utils.managers.NodeLinksManager._get_node_by_link_label:1
msgid "Return the linked node with a given link label."
msgstr ""

#: ../../../src/aiida/orm/utils/managers.py:docstring of aiida.orm.utils.managers.NodeLinksManager._get_node_by_link_label:3
msgid "Nested namespaces in link labels get represented by double underscores in the database. Up until now, the link manager didn't automatically unroll these again into nested namespaces and so a user was forced to pass the link with double underscores to dereference the corresponding node. For example, when used with the ``inputs`` attribute of a ``ProcessNode`` one had to do:"
msgstr ""

#: ../../../src/aiida/orm/utils/managers.py:docstring of aiida.orm.utils.managers.NodeLinksManager._get_node_by_link_label:8
msgid "node.inputs.nested__sub__namespace"
msgstr ""

#: ../../../src/aiida/orm/utils/managers.py:docstring of aiida.orm.utils.managers.NodeLinksManager._get_node_by_link_label:10
msgid "Now it is possible to do"
msgstr ""

#: ../../../src/aiida/orm/utils/managers.py:docstring of aiida.orm.utils.managers.NodeLinksManager._get_node_by_link_label:12
msgid "node.inputs.nested.sub.namespace"
msgstr ""

#: ../../../src/aiida/orm/utils/managers.py:docstring of aiida.orm.utils.managers.NodeLinksManager._get_node_by_link_label:14
msgid "which is more intuitive since the double underscore replacement is just for the database and the user shouldn't even have to know about it. For compatibility we support the old version a bit longer and it will emit a deprecation warning."
msgstr ""

#: ../../../src/aiida/orm/utils/managers.py:docstring of aiida.orm.utils.managers.NodeLinksManager._get_node_by_link_label:18
msgid "the link label connecting the current node to the node to get."
msgstr ""

#: ../../../src/aiida/orm/utils/mixins.py:docstring of aiida.orm.utils.mixins:1
msgid "Mixin classes for ORM classes."
msgstr ""

#: ../../../src/aiida/orm/utils/mixins.py:docstring of aiida.orm.utils.mixins.FunctionCalculationMixin:1
msgid "This mixin should be used for ProcessNode subclasses that are used to record the execution of a python function. For example the process nodes that are used for a function that was wrapped by the `workfunction` or `calcfunction` function decorators. The `store_source_info` method can then be called with the wrapped function to store information about that function in the calculation node through the inspect module. Various property getters are defined to later retrieve that information from the node"
msgstr ""

#: ../../../src/aiida/orm/utils/mixins.py:docstring of aiida.orm.utils.mixins.FunctionCalculationMixin._set_function_name:1
msgid "Set the function name of the wrapped function."
msgstr ""

#: ../../../src/aiida/orm/utils/mixins.py:docstring of aiida.orm.utils.mixins.FunctionCalculationMixin._set_function_name:3
msgid "the function name"
msgstr ""

#: ../../../src/aiida/orm/utils/mixins.py:docstring of aiida.orm.utils.mixins.FunctionCalculationMixin._set_function_namespace:1
msgid "Set the function namespace of the wrapped function."
msgstr ""

#: ../../../src/aiida/orm/utils/mixins.py:docstring of aiida.orm.utils.mixins.FunctionCalculationMixin._set_function_namespace:3
msgid "the function namespace"
msgstr ""

#: ../../../src/aiida/orm/utils/mixins.py:docstring of aiida.orm.utils.mixins.FunctionCalculationMixin._set_function_number_of_lines:1
msgid "Set the number of lines of the wrapped function in its source file."
msgstr ""

#: ../../../src/aiida/orm/utils/mixins.py:docstring of aiida.orm.utils.mixins.FunctionCalculationMixin._set_function_number_of_lines:3
msgid "the number of lines"
msgstr ""

#: ../../../src/aiida/orm/utils/mixins.py:docstring of aiida.orm.utils.mixins.FunctionCalculationMixin._set_function_starting_line_number:1
msgid "Set the starting line number of the wrapped function in its source file."
msgstr ""

#: ../../../src/aiida/orm/utils/mixins.py:docstring of aiida.orm.utils.mixins.FunctionCalculationMixin._set_function_starting_line_number:3
msgid "the starting line number"
msgstr ""

#: ../../../src/aiida/orm/utils/mixins.py:docstring of aiida.orm.utils.mixins.FunctionCalculationMixin.function_name:1
msgid "Return the function name of the wrapped function."
msgstr ""

#: ../../../src/aiida/orm/utils/mixins.py:docstring of aiida.orm.utils.mixins.FunctionCalculationMixin.function_name:3
msgid "the function name or None"
msgstr ""

#: ../../../src/aiida/orm/utils/mixins.py:docstring of aiida.orm.utils.mixins.FunctionCalculationMixin.function_namespace:1
msgid "Return the function namespace of the wrapped function."
msgstr ""

#: ../../../src/aiida/orm/utils/mixins.py:docstring of aiida.orm.utils.mixins.FunctionCalculationMixin.function_namespace:3
msgid "the function namespace or None"
msgstr ""

#: ../../../src/aiida/orm/utils/mixins.py:docstring of aiida.orm.utils.mixins.FunctionCalculationMixin.function_number_of_lines:1
msgid "Return the number of lines of the wrapped function in its source file."
msgstr ""

#: ../../../src/aiida/orm/utils/mixins.py:docstring of aiida.orm.utils.mixins.FunctionCalculationMixin.function_number_of_lines:3
msgid "the number of lines or None"
msgstr ""

#: ../../../src/aiida/orm/utils/mixins.py:docstring of aiida.orm.utils.mixins.FunctionCalculationMixin.function_starting_line_number:1
msgid "Return the starting line number of the wrapped function in its source file."
msgstr ""

#: ../../../src/aiida/orm/utils/mixins.py:docstring of aiida.orm.utils.mixins.FunctionCalculationMixin.function_starting_line_number:3
msgid "the starting line number or None"
msgstr ""

#: ../../../src/aiida/orm/utils/mixins.py:docstring of aiida.orm.utils.mixins.FunctionCalculationMixin.get_function_source_code:1
msgid "Return the source code of the function stored in the repository."
msgstr ""

#: ../../../src/aiida/orm/utils/mixins.py:docstring of aiida.orm.utils.mixins.FunctionCalculationMixin.get_function_source_code:3
#: ../../../src/aiida/orm/utils/mixins.py:docstring of aiida.orm.utils.mixins.FunctionCalculationMixin.get_source_code_file:3
msgid "If the source code file does not exist, this will return ``None`` instead. This can happen for example when the function was defined in an interactive shell in which case ``store_source_info`` will have failed to retrieve the source code using ``inspect.getsourcefile``."
msgstr ""

#: ../../../src/aiida/orm/utils/mixins.py:docstring of aiida.orm.utils.mixins.FunctionCalculationMixin.get_function_source_code:7
#: ../../../src/aiida/orm/utils/mixins.py:docstring of aiida.orm.utils.mixins.FunctionCalculationMixin.get_source_code_file:7
msgid "The source code of the function or ``None`` if it could not be determined when storing the node."
msgstr ""

#: ../../../src/aiida/orm/utils/mixins.py:docstring of aiida.orm.utils.mixins.FunctionCalculationMixin.get_source_code_file:1
msgid "Return the source code of the file in which the process function was defined."
msgstr ""

#: ../../../src/aiida/orm/utils/mixins.py:docstring of aiida.orm.utils.mixins.FunctionCalculationMixin.get_source_code_function:1
msgid "Return the source code of the function including the decorator."
msgstr ""

#: ../../../src/aiida/orm/utils/mixins.py:docstring of aiida.orm.utils.mixins.FunctionCalculationMixin.get_source_code_function:3
msgid "The source code of the function or ``None`` if not available."
msgstr ""

#: ../../../src/aiida/orm/utils/mixins.py:docstring of aiida.orm.utils.mixins.FunctionCalculationMixin.store_source_info:1
msgid "Retrieve source information about the wrapped function `func` through the inspect module, and store it in the attributes and repository of the node. The function name, namespace and the starting line number in the source file will be stored in the attributes. The source file itself will be copied into the repository"
msgstr ""

#: ../../../src/aiida/orm/utils/mixins.py:docstring of aiida.orm.utils.mixins.FunctionCalculationMixin.store_source_info:6
msgid "the function to inspect and whose information to store in the node"
msgstr ""

#: ../../../src/aiida/orm/utils/mixins.py:docstring of aiida.orm.utils.mixins.Sealable:1
msgid "Mixin to mark a Node as `sealable`."
msgstr ""

#: ../../../src/aiida/orm/utils/mixins.py:docstring of aiida.orm.utils.mixins.Sealable.is_sealed:1
msgid "Returns whether the node is sealed, i.e. whether the sealed attribute has been set to True."
msgstr ""

#: ../../../src/aiida/orm/utils/mixins.py:docstring of aiida.orm.utils.mixins.Sealable.seal:1
msgid "Seal the node by setting the sealed attribute to True."
msgstr ""

#: ../../../src/aiida/orm/utils/node.py:docstring of aiida.orm.utils.node:1
msgid "Utilities to operate on `Node` classes."
msgstr ""

#: ../../../src/aiida/orm/utils/node.py:docstring of aiida.orm.utils.node.AbstractNodeMeta:1
msgid "Bases: :py:class:`~abc.ABCMeta`"
msgstr ""

#: ../../../src/aiida/orm/utils/node.py:docstring of aiida.orm.utils.node.AbstractNodeMeta:1
msgid "Some python black magic to set correctly the logger also in subclasses."
msgstr ""

#: ../../../src/aiida/orm/utils/node.py:docstring of aiida.orm.utils.node.get_query_type_from_type_string:1
msgid "Take the type string of a Node and create the queryable type string"
msgstr ""

#: ../../../src/aiida/orm/utils/node.py:docstring of aiida.orm.utils.node.get_query_type_from_type_string:3
#: ../../../src/aiida/orm/utils/node.py:docstring of aiida.orm.utils.node.is_valid_node_type_string:3
msgid "the plugin_type_string attribute of a Node"
msgstr ""

#: ../../../src/aiida/orm/utils/node.py:docstring of aiida.orm.utils.node.get_query_type_from_type_string:4
msgid "the type string that can be used to query for"
msgstr ""

#: ../../../src/aiida/orm/utils/node.py:docstring of aiida.orm.utils.node.get_type_string_from_class:1
msgid "Given the module and name of a class, determine the orm_class_type string, which codifies the orm class that is to be used. The returned string will always have a terminating period, which is required to query for the string in the database"
msgstr ""

#: ../../../src/aiida/orm/utils/node.py:docstring of aiida.orm.utils.node.get_type_string_from_class:5
#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.get_entry_point_from_class:3
#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.get_entry_point_string_from_class:12
msgid "module of the class"
msgstr ""

#: ../../../src/aiida/orm/utils/node.py:docstring of aiida.orm.utils.node.get_type_string_from_class:6
#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.get_entry_point_from_class:4
#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.get_entry_point_string_from_class:13
msgid "name of the class"
msgstr ""

#: ../../../src/aiida/orm/utils/node.py:docstring of aiida.orm.utils.node.is_valid_node_type_string:1
msgid "Checks whether type string of a Node is valid."
msgstr ""

#: ../../../src/aiida/orm/utils/node.py:docstring of aiida.orm.utils.node.is_valid_node_type_string:4
msgid "True if type string is valid, else false"
msgstr ""

#: ../../../src/aiida/orm/utils/node.py:docstring of aiida.orm.utils.node.load_node_class:1
msgid "Return the `Node` sub class that corresponds to the given type string."
msgstr ""

#: ../../../src/aiida/orm/utils/node.py:docstring of aiida.orm.utils.node.load_node_class:3
msgid "the `type` string of the node"
msgstr ""

#: ../../../src/aiida/orm/utils/node.py:docstring of aiida.orm.utils.node.load_node_class:4
msgid "a sub class of `Node`"
msgstr ""

#: ../../../src/aiida/orm/utils/remote.py:docstring of aiida.orm.utils.remote:1
msgid "Utilities for operations on files on remote computers."
msgstr ""

#: ../../../src/aiida/orm/utils/remote.py:docstring of aiida.orm.utils.remote.clean_remote:1
msgid "Recursively remove a remote folder, with the given absolute path, and all its contents. The path should be made accessible through the transport channel, which should already be open"
msgstr ""

#: ../../../src/aiida/orm/utils/remote.py:docstring of aiida.orm.utils.remote.clean_remote:4
msgid "an open Transport channel"
msgstr ""

#: ../../../src/aiida/orm/utils/remote.py:docstring of aiida.orm.utils.remote.clean_remote:5
msgid "an absolute path on the remote made available through the transport"
msgstr ""

#: ../../../src/aiida/orm/utils/remote.py:docstring of aiida.orm.utils.remote.get_calcjob_remote_paths:1
msgid "Return a mapping of computer uuids to a list of remote paths, for a given set of calcjobs. The set of calcjobs will be determined by a query with filters based on the pks, past_days, older_than, computers and user arguments."
msgstr ""

#: ../../../src/aiida/orm/utils/remote.py:docstring of aiida.orm.utils.remote.get_calcjob_remote_paths:5
msgid "only include calcjobs with a pk in this list"
msgstr ""

#: ../../../src/aiida/orm/utils/remote.py:docstring of aiida.orm.utils.remote.get_calcjob_remote_paths:6
msgid "only include calcjobs created since past_days"
msgstr ""

#: ../../../src/aiida/orm/utils/remote.py:docstring of aiida.orm.utils.remote.get_calcjob_remote_paths:7
msgid "only include calcjobs older than"
msgstr ""

#: ../../../src/aiida/orm/utils/remote.py:docstring of aiida.orm.utils.remote.get_calcjob_remote_paths:8
msgid "only include calcjobs that were ran on these computers"
msgstr ""

#: ../../../src/aiida/orm/utils/remote.py:docstring of aiida.orm.utils.remote.get_calcjob_remote_paths:9
msgid "only include calcjobs of this user"
msgstr ""

#: ../../../src/aiida/orm/utils/remote.py:docstring of aiida.orm.utils.remote.get_calcjob_remote_paths:10
msgid "only select calcjob with this exit_status"
msgstr ""

#: ../../../src/aiida/orm/utils/remote.py:docstring of aiida.orm.utils.remote.get_calcjob_remote_paths:11
msgid "only include calcjobs whose workdir have not been cleaned"
msgstr ""

#: ../../../src/aiida/orm/utils/remote.py:docstring of aiida.orm.utils.remote.get_calcjob_remote_paths:12
msgid "mapping of computer uuid and list of remote folder"
msgstr ""

#: ../../../src/aiida/orm/utils/serialize.py:docstring of aiida.orm.utils.serialize:1
msgid "Serialisation functions for AiiDA types"
msgstr ""

#: ../../../src/aiida/orm/utils/serialize.py:docstring of aiida.orm.utils.serialize:3
msgid "WARNING: Changing the representation of things here may break people's current saved e.g. things like checkpoints and messages in the RabbitMQ queue so do so with caution.  It is fine to add representers for new types though."
msgstr ""

#: ../../../src/aiida/orm/utils/serialize.py:docstring of aiida.orm.utils.serialize.AiiDADumper:1
msgid "Bases: :py:class:`~yaml.dumper.Dumper`"
msgstr ""

#: ../../../src/aiida/orm/utils/serialize.py:docstring of aiida.orm.utils.serialize.AiiDADumper:1
msgid "Custom AiiDA yaml dumper."
msgstr ""

#: ../../../src/aiida/orm/utils/serialize.py:docstring of aiida.orm.utils.serialize.AiiDADumper:3
msgid "Needed so that we don't have to encode each type in the AiiDA graph hierarchy separately using a custom representer."
msgstr ""

#: ../../../src/aiida/orm/utils/serialize.py:docstring of aiida.orm.utils.serialize.AiiDALoader:1
msgid "Bases: :py:class:`~yaml.loader.Loader`"
msgstr ""

#: ../../../src/aiida/orm/utils/serialize.py:docstring of aiida.orm.utils.serialize.AiiDALoader:1
msgid "AiiDA specific yaml loader"
msgstr ""

#: ../../../src/aiida/orm/utils/serialize.py:docstring of aiida.orm.utils.serialize.AiiDALoader:3
msgid "The `AiiDALoader` should only be used on trusted input, since it uses the `yaml.Loader` which is not safe. When importing a shared database, we strip all process node checkpoints to avoid this being a security risk."
msgstr ""

#: ../../../src/aiida/orm/utils/serialize.py:docstring of aiida.orm.utils.serialize.bundle_constructor:1
msgid "Construct an `plumpy.Bundle` from the representation."
msgstr ""

#: ../../../src/aiida/orm/utils/serialize.py:docstring of aiida.orm.utils.serialize.computer_constructor:1
msgid "Load a computer from the yaml representation."
msgstr ""

#: ../../../src/aiida/orm/utils/serialize.py:docstring of aiida.orm.utils.serialize.dataclass_constructor:1
msgid "Construct a dataclass from the serialized representation."
msgstr ""

#: ../../../src/aiida/orm/utils/serialize.py:docstring of aiida.orm.utils.serialize.deserialize_unsafe:1
msgid "Deserialize a yaml dump that represents a serialized data structure."
msgstr ""

#: ../../../src/aiida/orm/utils/serialize.py:docstring of aiida.orm.utils.serialize.deserialize_unsafe:3
msgid "This function should not be used on untrusted input, since it is built upon `yaml.Loader` which is unsafe."
msgstr ""

#: ../../../src/aiida/orm/utils/serialize.py:docstring of aiida.orm.utils.serialize.deserialize_unsafe:5
msgid "a yaml serialized string representation"
msgstr ""

#: ../../../src/aiida/orm/utils/serialize.py:docstring of aiida.orm.utils.serialize.deserialize_unsafe:6
msgid "the deserialized data structure"
msgstr ""

#: ../../../src/aiida/orm/utils/serialize.py:docstring of aiida.orm.utils.serialize.enum_constructor:1
msgid "Construct an enum from the serialized representation."
msgstr ""

#: ../../../src/aiida/orm/utils/serialize.py:docstring of aiida.orm.utils.serialize.group_constructor:1
msgid "Load a group from the yaml representation."
msgstr ""

#: ../../../src/aiida/orm/utils/serialize.py:docstring of aiida.orm.utils.serialize.mapping_constructor:1
msgid "Construct a mapping from the representation."
msgstr ""

#: ../../../src/aiida/orm/utils/serialize.py:docstring of aiida.orm.utils.serialize.node_constructor:1
msgid "Load a node from the yaml representation."
msgstr ""

#: ../../../src/aiida/orm/utils/serialize.py:docstring of aiida.orm.utils.serialize.node_links_manager_constructor:1
msgid "Load a link from the yaml representation."
msgstr ""

#: ../../../src/aiida/orm/utils/serialize.py:docstring of aiida.orm.utils.serialize.represent_bundle:1
msgid "Represent an `plumpy.Bundle` in yaml."
msgstr ""

#: ../../../src/aiida/orm/utils/serialize.py:docstring of aiida.orm.utils.serialize.represent_computer:1
msgid "Represent a computer in yaml."
msgstr ""

#: ../../../src/aiida/orm/utils/serialize.py:docstring of aiida.orm.utils.serialize.represent_dataclass:1
msgid "Represent an arbitrary dataclass in yaml."
msgstr ""

#: ../../../src/aiida/orm/utils/serialize.py:docstring of aiida.orm.utils.serialize.represent_enum:1
msgid "Represent an arbitrary enum in yaml."
msgstr ""

#: ../../../src/aiida/orm/utils/serialize.py:docstring of aiida.orm.utils.serialize.represent_group:1
msgid "Represent a group in yaml."
msgstr ""

#: ../../../src/aiida/orm/utils/serialize.py:docstring of aiida.orm.utils.serialize.represent_mapping:1
msgid "Represent a mapping in yaml."
msgstr ""

#: ../../../src/aiida/orm/utils/serialize.py:docstring of aiida.orm.utils.serialize.represent_node:1
msgid "Represent a node in yaml."
msgstr ""

#: ../../../src/aiida/orm/utils/serialize.py:docstring of aiida.orm.utils.serialize.represent_node_links_manager:1
msgid "Represent a link in yaml."
msgstr ""

#: ../../../src/aiida/orm/utils/serialize.py:docstring of aiida.orm.utils.serialize.serialize:1
msgid "Serialize the given data structure into a yaml dump."
msgstr ""

#: ../../../src/aiida/orm/utils/serialize.py:docstring of aiida.orm.utils.serialize.serialize:3
msgid "The function supports standard data containers such as maps and lists as well as AiiDA nodes which will be serialized into strings, before the whole data structure is dumped into a string using yaml."
msgstr ""

#: ../../../src/aiida/orm/utils/serialize.py:docstring of aiida.orm.utils.serialize.serialize:6
msgid "the general data to serialize"
msgstr ""

#: ../../../src/aiida/orm/utils/serialize.py:docstring of aiida.orm.utils.serialize.serialize:7
msgid "optional encoding for the serialized string"
msgstr ""

#: ../../../src/aiida/orm/utils/serialize.py:docstring of aiida.orm.utils.serialize.serialize:8
msgid "string representation of the serialized data structure or byte array if specific encoding is specified"
msgstr ""

#: ../../source/reference/apidoc/aiida.orm.utils.builders.rst:2
msgid "aiida.orm.utils.builders package"
msgstr ""

#: ../../../src/aiida/orm/utils/builders/code.py:docstring of aiida.orm.utils.builders.code:1
msgid "Manage code objects with lazy loading of the db env"
msgstr ""

#: ../../../src/aiida/orm/utils/builders/code.py:docstring of aiida.orm.utils.builders.code.CodeBuilder:1
msgid "Build a code with validation of attribute combinations"
msgstr ""

#: ../../../src/aiida/orm/utils/builders/code.py:docstring of aiida.orm.utils.builders.code.CodeBuilder.CodeValidationError:1
msgid "A CodeBuilder instance may raise this"
msgstr ""

#: ../../../src/aiida/orm/utils/builders/code.py:docstring of aiida.orm.utils.builders.code.CodeBuilder.CodeValidationError:3
msgid "when asked to instanciate a code with missing or invalid code attributes"
msgstr ""

#: ../../../src/aiida/orm/utils/builders/code.py:docstring of aiida.orm.utils.builders.code.CodeBuilder.CodeValidationError:4
msgid "when asked for a code attibute that has not been set yet"
msgstr ""

#: ../../../src/aiida/orm/utils/builders/code.py:docstring of aiida.orm.utils.builders.code.CodeBuilder.__getattr__:1
msgid "Access code attributes used to build the code"
msgstr ""

#: ../../../src/aiida/orm/utils/builders/code.py:docstring of aiida.orm.utils.builders.code.CodeBuilder._get:1
#: ../../../src/aiida/orm/utils/builders/computer.py:docstring of aiida.orm.utils.builders.computer.ComputerBuilder._get:1
msgid "Return a spec, or None if not defined"
msgstr ""

#: ../../../src/aiida/orm/utils/builders/code.py:docstring of aiida.orm.utils.builders.code.CodeBuilder._get:3
#: ../../../src/aiida/orm/utils/builders/code.py:docstring of aiida.orm.utils.builders.code.CodeBuilder._get_and_count:4
msgid "name of a code spec"
msgstr ""

#: ../../../src/aiida/orm/utils/builders/code.py:docstring of aiida.orm.utils.builders.code.CodeBuilder._get_and_count:1
#: ../../../src/aiida/orm/utils/builders/computer.py:docstring of aiida.orm.utils.builders.computer.ComputerBuilder._get_and_count:1
msgid "Return a spec, or raise if not defined. Moreover, add the key to the 'used' dict."
msgstr ""

#: ../../../src/aiida/orm/utils/builders/code.py:docstring of aiida.orm.utils.builders.code.CodeBuilder._get_and_count:5
#: ../../../src/aiida/orm/utils/builders/computer.py:docstring of aiida.orm.utils.builders.computer.ComputerBuilder._get_and_count:5
msgid "should be a set of keys that you want to track. ``key`` will be added to this set if the value exists in the spec and can be retrieved."
msgstr ""

#: ../../../src/aiida/orm/utils/builders/code.py:docstring of aiida.orm.utils.builders.code.CodeBuilder._set_code_attr:1
msgid "Set a code attribute, if it passes validation."
msgstr ""

#: ../../../src/aiida/orm/utils/builders/code.py:docstring of aiida.orm.utils.builders.code.CodeBuilder._set_code_attr:3
msgid "Checks compatibility with other code attributes."
msgstr ""

#: ../../../src/aiida/orm/utils/builders/code.py:docstring of aiida.orm.utils.builders.code.CodeBuilder.from_code:1
msgid "Create CodeBuilder from existing code instance."
msgstr ""

#: ../../../src/aiida/orm/utils/builders/code.py:docstring of aiida.orm.utils.builders.code.CodeBuilder.from_code:3
msgid "See also :py:func:`~CodeBuilder.get_code_spec`"
msgstr ""

#: ../../../src/aiida/orm/utils/builders/code.py:docstring of aiida.orm.utils.builders.code.CodeBuilder.get_code_spec:1
msgid "Get code attributes from existing code instance."
msgstr ""

#: ../../../src/aiida/orm/utils/builders/code.py:docstring of aiida.orm.utils.builders.code.CodeBuilder.get_code_spec:3
msgid "These attributes can be used to create a new CodeBuilder::"
msgstr ""

#: ../../../src/aiida/orm/utils/builders/code.py:docstring of aiida.orm.utils.builders.code.CodeBuilder.is_local:1
msgid "Analogous to Code.is_local()"
msgstr ""

#: ../../../src/aiida/orm/utils/builders/code.py:docstring of aiida.orm.utils.builders.code.CodeBuilder.new:1
msgid "Build and return a new code instance (not stored)"
msgstr ""

#: ../../../src/aiida/orm/utils/builders/code.py:docstring of aiida.orm.utils.builders.code.CodeBuilder.validate_code_type:1
msgid "Make sure the code type is set correctly"
msgstr ""

#: ../../../src/aiida/orm/utils/builders/code.py:docstring of aiida.orm.utils.builders.code.CodeBuilder.validate_installed:1
msgid "If the code is on-computer, catch invalid store-and-upload attributes"
msgstr ""

#: ../../../src/aiida/orm/utils/builders/code.py:docstring of aiida.orm.utils.builders.code.CodeBuilder.validate_upload:1
msgid "If the code is stored and uploaded, catch invalid on-computer attributes"
msgstr ""

#: ../../../src/aiida/orm/utils/builders/computer.py:docstring of aiida.orm.utils.builders.computer:1
msgid "Manage computer objects with lazy loading of the db env"
msgstr ""

#: ../../../src/aiida/orm/utils/builders/computer.py:docstring of aiida.orm.utils.builders.computer.ComputerBuilder:1
msgid "Build a computer with validation of attribute combinations"
msgstr ""

#: ../../../src/aiida/orm/utils/builders/computer.py:docstring of aiida.orm.utils.builders.computer.ComputerBuilder.ComputerValidationError:1
msgid "A ComputerBuilder instance may raise this."
msgstr ""

#: ../../../src/aiida/orm/utils/builders/computer.py:docstring of aiida.orm.utils.builders.computer.ComputerBuilder.ComputerValidationError:3
msgid "when asked to instanciate a code with missing or invalid computer attributes"
msgstr ""

#: ../../../src/aiida/orm/utils/builders/computer.py:docstring of aiida.orm.utils.builders.computer.ComputerBuilder.ComputerValidationError:4
msgid "when asked for a computer attibute that has not been set yet."
msgstr ""

#: ../../../src/aiida/orm/utils/builders/computer.py:docstring of aiida.orm.utils.builders.computer.ComputerBuilder.__getattr__:1
msgid "Access computer attributes used to build the computer"
msgstr ""

#: ../../../src/aiida/orm/utils/builders/computer.py:docstring of aiida.orm.utils.builders.computer.ComputerBuilder._get:3
#: ../../../src/aiida/orm/utils/builders/computer.py:docstring of aiida.orm.utils.builders.computer.ComputerBuilder._get_and_count:4
msgid "name of a computer spec"
msgstr ""

#: ../../../src/aiida/orm/utils/builders/computer.py:docstring of aiida.orm.utils.builders.computer.ComputerBuilder._set_computer_attr:1
msgid "Set a computer attribute if it passes validation."
msgstr ""

#: ../../../src/aiida/orm/utils/builders/computer.py:docstring of aiida.orm.utils.builders.computer.ComputerBuilder.from_computer:1
msgid "Create ComputerBuilder from existing computer instance."
msgstr ""

#: ../../../src/aiida/orm/utils/builders/computer.py:docstring of aiida.orm.utils.builders.computer.ComputerBuilder.from_computer:3
msgid "See also :py:func:`~ComputerBuilder.get_computer_spec`"
msgstr ""

#: ../../../src/aiida/orm/utils/builders/computer.py:docstring of aiida.orm.utils.builders.computer.ComputerBuilder.get_computer_spec:1
msgid "Get computer attributes from existing computer instance."
msgstr ""

#: ../../../src/aiida/orm/utils/builders/computer.py:docstring of aiida.orm.utils.builders.computer.ComputerBuilder.get_computer_spec:3
msgid "These attributes can be used to create a new ComputerBuilder::"
msgstr ""

#: ../../../src/aiida/orm/utils/builders/computer.py:docstring of aiida.orm.utils.builders.computer.ComputerBuilder.new:1
msgid "Build and return a new computer instance (not stored)"
msgstr ""

#: ../../../src/aiida/orm/utils/builders/computer.py:docstring of aiida.orm.utils.builders.computer.ComputerBuilder.validate:1
msgid "Validate the computer options."
msgstr ""

#: ../../source/reference/apidoc/aiida.parsers.rst:2
msgid "aiida.parsers package"
msgstr ""

#: ../../../src/aiida/parsers/__init__.py:docstring of aiida.parsers:1
msgid "Module for classes and utilities to write parsers for calculation jobs."
msgstr ""

#: ../../../src/aiida/parsers/parser.py:docstring of aiida.parsers.parser:1
msgid "This module implements a generic output plugin, that is general enough to allow the reading of the outputs of a calculation."
msgstr ""

#: ../../../src/aiida/parsers/parser.py:docstring of aiida.parsers.parser.Parser:1
msgid "Base class for a Parser that can parse the outputs produced by a CalcJob process."
msgstr ""

#: ../../../src/aiida/parsers/parser.py:docstring of aiida.parsers.parser.Parser.__init__:1
msgid "Construct the Parser instance."
msgstr ""

#: ../../../src/aiida/parsers/parser.py:docstring of aiida.parsers.parser.Parser.__init__:3
msgid "the `CalcJobNode` that contains the results of the executed `CalcJob` process."
msgstr ""

#: ../../../src/aiida/parsers/parser.py:docstring of aiida.parsers.parser.Parser.exit_codes:1
msgid "Return the exit codes defined for the process class of the node being parsed."
msgstr ""

#: ../../../src/aiida/parsers/parser.py:docstring of aiida.parsers.parser.Parser.get_outputs_for_parsing:1
msgid "Return the dictionary of nodes that should be passed to the `Parser.parse` call."
msgstr ""

#: ../../../src/aiida/parsers/parser.py:docstring of aiida.parsers.parser.Parser.get_outputs_for_parsing:3
msgid "Output nodes can be marked as being required by the `parse` method, by setting the `pass_to_parser` attribute, in the `spec.output` call in the process spec of the `CalcJob`, to True."
msgstr ""

#: ../../../src/aiida/parsers/parser.py:docstring of aiida.parsers.parser.Parser.get_outputs_for_parsing:6
msgid "dictionary of nodes that are required by the `parse` method"
msgstr ""

#: ../../../src/aiida/parsers/parser.py:docstring of aiida.parsers.parser.Parser.logger:1
msgid "Return the logger preconfigured for the calculation node associated with this parser instance."
msgstr ""

#: ../../../src/aiida/parsers/parser.py:docstring of aiida.parsers.parser.Parser.logger:3
msgid "`logging.Logger`"
msgstr ""

#: ../../../src/aiida/parsers/parser.py:docstring of aiida.parsers.parser.Parser.node:1
msgid "Return the node instance"
msgstr ""

#: ../../../src/aiida/parsers/parser.py:docstring of aiida.parsers.parser.Parser.node:3
msgid "the `CalcJobNode` instance"
msgstr ""

#: ../../../src/aiida/parsers/parser.py:docstring of aiida.parsers.parser.Parser.out:1
msgid "Register a node as an output with the given link label."
msgstr ""

#: ../../../src/aiida/parsers/parser.py:docstring of aiida.parsers.parser.Parser.out:3
msgid "the name of the link label"
msgstr ""

#: ../../../src/aiida/parsers/parser.py:docstring of aiida.parsers.parser.Parser.out:4
msgid "the node to register as an output"
msgstr ""

#: ../../../src/aiida/parsers/parser.py:docstring of aiida.parsers.parser.Parser.out:5
msgid "if an output node was already registered with the same link label"
msgstr ""

#: ../../../src/aiida/parsers/parser.py:docstring of aiida.parsers.parser.Parser.outputs:1
msgid "Return the dictionary of outputs that have been registered."
msgstr ""

#: ../../../src/aiida/parsers/parser.py:docstring of aiida.parsers.parser.Parser.outputs:3
msgid "an AttributeDict instance with the registered output nodes"
msgstr ""

#: ../../../src/aiida/parsers/parser.py:docstring of aiida.parsers.parser.Parser.parse:1
#: ../../../src/aiida/parsers/plugins/templatereplacer/parser.py:docstring of aiida.parsers.plugins.templatereplacer.parser.TemplatereplacerParser.parse:1
msgid "Parse the contents of the output files retrieved in the `FolderData`."
msgstr ""

#: ../../../src/aiida/parsers/parser.py:docstring of aiida.parsers.parser.Parser.parse:3
msgid "This method should be implemented in the sub class. Outputs can be registered through the `out` method. After the `parse` call finishes, the runner will automatically link them up to the underlying `CalcJobNode`."
msgstr ""

#: ../../../src/aiida/parsers/parser.py:docstring of aiida.parsers.parser.Parser.parse:6
msgid "output nodes attached to the `CalcJobNode` of the parser instance."
msgstr ""

#: ../../../src/aiida/parsers/parser.py:docstring of aiida.parsers.parser.Parser.parse:7
msgid "an instance of ExitCode or None"
msgstr ""

#: ../../../src/aiida/parsers/parser.py:docstring of aiida.parsers.parser.Parser.parse_from_node:1
msgid "Parse the outputs directly from the `CalcJobNode`."
msgstr ""

#: ../../../src/aiida/parsers/parser.py:docstring of aiida.parsers.parser.Parser.parse_from_node:3
msgid "If `store_provenance` is set to False, a `CalcFunctionNode` will still be generated, but it will not be stored. It's storing method will also be disabled, making it impossible to store, because storing it afterwards would not have the expected effect, as the outputs it produced will not be stored with it."
msgstr ""

#: ../../../src/aiida/parsers/parser.py:docstring of aiida.parsers.parser.Parser.parse_from_node:7
msgid "This method is useful to test parsing in unit tests where a `CalcJobNode` can be mocked without actually having to run a `CalcJob`. It can also be useful to actually re-perform the parsing of a completed `CalcJob` with a different parser."
msgstr ""

#: ../../../src/aiida/parsers/parser.py:docstring of aiida.parsers.parser.Parser.parse_from_node:11
msgid "a `CalcJobNode` instance"
msgstr ""

#: ../../../src/aiida/parsers/parser.py:docstring of aiida.parsers.parser.Parser.parse_from_node:12
msgid "bool, if True will store the parsing as a `CalcFunctionNode` in the provenance"
msgstr ""

#: ../../../src/aiida/parsers/parser.py:docstring of aiida.parsers.parser.Parser.parse_from_node:13
msgid "absolute path to folder with contents of `retrieved_temporary_list`"
msgstr ""

#: ../../../src/aiida/parsers/parser.py:docstring of aiida.parsers.parser.Parser.parse_from_node:14
msgid "a tuple of the parsed results and the `CalcFunctionNode` representing the process of parsing"
msgstr ""

#: ../../source/reference/apidoc/aiida.parsers.plugins.rst:2
msgid "aiida.parsers.plugins package"
msgstr ""

#: ../../source/reference/apidoc/aiida.parsers.plugins.arithmetic.rst:2
msgid "aiida.parsers.plugins.arithmetic package"
msgstr ""

#: ../../../src/aiida/parsers/plugins/arithmetic/add.py:docstring of aiida.parsers.plugins.arithmetic.add:1
#: ../../../src/aiida/parsers/plugins/arithmetic/add.py:docstring of aiida.parsers.plugins.arithmetic.add.ArithmeticAddParser:1
msgid "Parser for an `ArithmeticAddCalculation` job."
msgstr ""

#: ../../../src/aiida/parsers/plugins/arithmetic/add.py:docstring of aiida.parsers.plugins.arithmetic.add.ArithmeticAddParser:1
#: ../../../src/aiida/parsers/plugins/arithmetic/add.py:docstring of aiida.parsers.plugins.arithmetic.add.SimpleArithmeticAddParser:1
#: ../../../src/aiida/parsers/plugins/templatereplacer/parser.py:docstring of aiida.parsers.plugins.templatereplacer.parser.TemplatereplacerParser:1
msgid "Bases: :py:class:`~aiida.parsers.parser.Parser`"
msgstr ""

#: ../../../src/aiida/parsers/plugins/arithmetic/add.py:docstring of aiida.parsers.plugins.arithmetic.add.ArithmeticAddParser.parse:1
#: ../../../src/aiida/parsers/plugins/arithmetic/add.py:docstring of aiida.parsers.plugins.arithmetic.add.SimpleArithmeticAddParser.parse:1
msgid "Parse the contents of the output files stored in the `retrieved` output node."
msgstr ""

#: ../../../src/aiida/parsers/plugins/arithmetic/add.py:docstring of aiida.parsers.plugins.arithmetic.add.SimpleArithmeticAddParser:1
msgid "Simple parser for an `ArithmeticAddCalculation` job (for demonstration purposes only)."
msgstr ""

#: ../../source/reference/apidoc/aiida.parsers.plugins.templatereplacer.rst:2
msgid "aiida.parsers.plugins.templatereplacer package"
msgstr ""

#: ../../../src/aiida/parsers/plugins/templatereplacer/parser.py:docstring of aiida.parsers.plugins.templatereplacer.parser:1
#: ../../../src/aiida/parsers/plugins/templatereplacer/parser.py:docstring of aiida.parsers.plugins.templatereplacer.parser.TemplatereplacerParser:1
msgid "Parser for the `TemplatereplacerCalculation` calculation job."
msgstr ""

#: ../../source/reference/apidoc/aiida.plugins.rst:2
msgid "aiida.plugins package"
msgstr ""

#: ../../../src/aiida/plugins/__init__.py:docstring of aiida.plugins:1
msgid "Classes and functions to load and interact with plugin classes accessible through defined entry points."
msgstr ""

#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point:1
msgid "Module to manage loading entrypoints."
msgstr ""

#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.EntryPointFormat:1
msgid "Enum to distinguish between the various possible entry point string formats. An entry point string is fully qualified by its group and name concatenated by the entry point string separator character. The group in AiiDA has the prefix `aiida.` and the separator character is the colon `:`."
msgstr ""

#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.EntryPointFormat:5
msgid "Under these definitions a potentially valid entry point string may have the following formats:"
msgstr ""

#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.EntryPointFormat:7
msgid "FULL:    prefixed group plus entry point name     aiida.transports:core.ssh"
msgstr ""

#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.EntryPointFormat:8
msgid "PARTIAL: unprefixed group plus entry point name   transports:core.ssh"
msgstr ""

#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.EntryPointFormat:9
msgid "MINIMAL: no group but only entry point name:      core.ssh"
msgstr ""

#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.EntryPointFormat:11
msgid "Note that the MINIMAL format can potentially lead to ambiguity if the name appears in multiple entry point groups."
msgstr ""

#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.convert_potentially_deprecated_entry_point:1
msgid "Check whether the specified entry point is deprecated, in which case print warning and convert to new name."
msgstr ""

#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.convert_potentially_deprecated_entry_point:3
msgid "For `aiida-core==2.0` all existing entry points where properly prefixed with ``core.`` and the old entry points were deprecated. To provide a smooth transition these deprecated entry points are detected in ``get_entry_point``, which is the lowest function that tries to resolve an entry point string, by calling this function."
msgstr ""

#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.convert_potentially_deprecated_entry_point:7
msgid "If the entry point corresponds to a deprecated one, a warning is raised and the new corresponding entry point name is returned."
msgstr ""

#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.convert_potentially_deprecated_entry_point:10
msgid "This method should be removed in ``aiida-core==3.0``."
msgstr ""

#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.eps:1
msgid "Cache around entry_points()"
msgstr ""

#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.eps:3
msgid "This call takes around 50ms! NOTE: For faster lookups, we sort the ``EntryPoints`` alphabetically by the group name so that 'aiida.' groups come up first. Unfortunately, this does not help with the entry_points.select() filter, which will always iterate over all entry points since it looks for possible duplicate entries."
msgstr ""

#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.eps_select:1
msgid "A thin wrapper around entry_points.select() calls, which are expensive so we want to cache them."
msgstr ""

#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.format_entry_point_string:1
msgid "Format an entry point string for a given entry point group and name, based on the specified format"
msgstr ""

#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.format_entry_point_string:3
#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.get_entry_point:3
#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.get_entry_points:3
#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.load_entry_point:3
msgid "the entry point group"
msgstr ""

#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.format_entry_point_string:4
#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.get_entry_point:4
#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.load_entry_point:4
msgid "the name of the entry point"
msgstr ""

#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.format_entry_point_string:5
msgid "the desired output format"
msgstr ""

#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.format_entry_point_string:6
msgid "if fmt is not instance of EntryPointFormat"
msgstr ""

#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.format_entry_point_string:7
msgid "if fmt value is invalid"
msgstr ""

#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.get_entry_point:1
msgid "Return an entry point with a given name within a specific group"
msgstr ""

#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.get_entry_point:5
#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.get_entry_point_from_string:4
msgid "the entry point if it exists else None"
msgstr ""

#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.get_entry_point:6
#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.get_entry_point_from_string:7
#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.load_entry_point:8
#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.load_entry_point_from_string:7
#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.BaseFactory:7
msgid "entry point was not registered"
msgstr ""

#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.get_entry_point_from_class:1
msgid "Given the module and name of a class, attempt to obtain the corresponding entry point if it exists"
msgstr ""

#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.get_entry_point_from_class:5
msgid "a tuple of the corresponding group and entry point or None if not found"
msgstr ""

#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.get_entry_point_from_string:1
msgid "Return an entry point for the given entry point string"
msgstr ""

#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.get_entry_point_from_string:3
#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.get_entry_point_string_format:4
#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.load_entry_point_from_string:3
#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.parse_entry_point_string:3
msgid "the entry point string"
msgstr ""

#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.get_entry_point_from_string:5
#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.load_entry_point:6
#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.load_entry_point_from_string:5
#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.parse_entry_point_string:5
msgid "if the entry_point_string is not a string type"
msgstr ""

#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.get_entry_point_from_string:6
#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.load_entry_point:7
#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.load_entry_point_from_string:6
#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.parse_entry_point_string:6
msgid "if the entry_point_string cannot be split into two parts on the entry point string separator"
msgstr ""

#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.get_entry_point_from_string:8
#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.load_entry_point:9
#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.load_entry_point_from_string:8
#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.BaseFactory:8
msgid "entry point could not be uniquely resolved"
msgstr ""

#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.get_entry_point_groups:1
msgid "Return a list of all the recognized entry point groups"
msgstr ""

#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.get_entry_point_groups:3
msgid "a list of valid entry point groups"
msgstr ""

#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.get_entry_point_names:1
msgid "Return the entry points within a group."
msgstr ""

#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.get_entry_point_string_format:1
msgid "Determine the format of an entry point string. Note that it does not validate the actual entry point string and it may not correspond to any actual entry point. This will only assess the string format"
msgstr ""

#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.get_entry_point_string_format:5
msgid "the entry point type"
msgstr ""

#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.get_entry_point_string_from_class:1
msgid "Given the module and name of a class, attempt to obtain the corresponding entry point if it exists and return the entry point string which will be the entry point group and entry point name concatenated by the entry point string separator"
msgstr ""

#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.get_entry_point_string_from_class:5
msgid "entry_point_string = '{group:}:{entry_point_name:}'"
msgstr ""

#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.get_entry_point_string_from_class:7
msgid "This ensures that given the entry point string, one can load the corresponding class by splitting on the separator, which will give the group and entry point, which should the corresponding factory to uniquely determine and load the class"
msgstr ""

#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.get_entry_point_string_from_class:14
msgid "the corresponding entry point string or None"
msgstr ""

#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.get_entry_points:1
msgid "Return a list of all the entry points within a specific group"
msgstr ""

#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.get_entry_points:4
msgid "a list of entry points"
msgstr ""

#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.is_registered_entry_point:1
msgid "Verify whether the class with the given module and class name is a registered entry point."
msgstr ""

#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.is_registered_entry_point:3
msgid "this function only checks whether the class has a registered entry point. It does explicitly not verify if the corresponding class is also importable. Use `load_entry_point` for this purpose instead."
msgstr ""

#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.is_registered_entry_point:6
msgid "the module of the class"
msgstr ""

#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.is_registered_entry_point:7
msgid "the name of the class"
msgstr ""

#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.is_registered_entry_point:8
msgid "optionally consider only these entry point groups to look for the class"
msgstr ""

#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.is_registered_entry_point:9
msgid "True if the class is a registered entry point, False otherwise."
msgstr ""

#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.is_valid_entry_point_string:1
msgid "Verify whether the given entry point string is a valid one. For the string to be valid means that it is composed of two strings, the entry point group and name, concatenated by the entry point string separator. If that is the case, the group name will be verified to see if it is known. If the group can be retrieved and it is known, the string is considered to be valid. It is invalid otherwise"
msgstr ""

#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.is_valid_entry_point_string:6
msgid "the entry point string, generated by get_entry_point_string_from_class"
msgstr ""

#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.is_valid_entry_point_string:7
msgid "True if the string is considered valid, False otherwise"
msgstr ""

#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.load_entry_point:1
msgid "Load the class registered under the entry point for a given name and group"
msgstr ""

#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.load_entry_point:5
#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.load_entry_point_from_string:4
msgid "class registered at the given entry point"
msgstr ""

#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.load_entry_point:10
#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.load_entry_point_from_string:9
#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.BaseFactory:9
msgid "entry point could not be loaded"
msgstr ""

#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.load_entry_point_from_string:1
msgid "Load the class registered for a given entry point string that determines group and name"
msgstr ""

#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.parse_entry_point:1
msgid "Return an entry point, given its group and spec (as formatted in the setup)"
msgstr ""

#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.parse_entry_point_string:1
msgid "Validate the entry point string and attempt to parse the entry point group and name"
msgstr ""

#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.parse_entry_point_string:4
msgid "the entry point group and name if the string is valid"
msgstr ""

#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.validate_registered_entry_points:1
msgid "Validate all registered entry points by loading them with the corresponding factory."
msgstr ""

#: ../../../src/aiida/plugins/entry_point.py:docstring of aiida.plugins.entry_point.validate_registered_entry_points:3
msgid "if any of the registered entry points cannot be loaded. This can happen if: * The entry point cannot uniquely be resolved * The resource registered at the entry point cannot be imported * The resource's type is incompatible with the entry point group that it is defined in."
msgstr ""

#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories:1
msgid "Definition of factories to load classes from the various plugin groups."
msgstr ""

#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.BaseFactory:1
msgid "Return the plugin class registered under a given entry point group and name."
msgstr ""

#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.BaseFactory:3
msgid "entry point group"
msgstr ""

#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.BaseFactory:4
msgid "entry point name"
msgstr ""

#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.BaseFactory:5
#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.CalculationFactory:4
#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.DataFactory:4
#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.DbImporterFactory:4
#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.GroupFactory:4
#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.OrbitalFactory:4
#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.ParserFactory:4
#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.SchedulerFactory:4
#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.StorageFactory:4
#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.TransportFactory:4
#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.WorkflowFactory:4
msgid "if True, load the matched entry point and return the loaded resource instead of the entry point itself."
msgstr ""

#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.BaseFactory:6
msgid "the plugin class"
msgstr ""

#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.CalcJobImporterFactory:1
msgid "Return the plugin registered under the given entry point."
msgstr ""

#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.CalcJobImporterFactory:3
#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.CalculationFactory:3
#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.DataFactory:3
#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.DbImporterFactory:3
#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.GroupFactory:3
#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.OrbitalFactory:3
#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.ParserFactory:3
#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.SchedulerFactory:3
#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.StorageFactory:3
#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.TransportFactory:3
#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.WorkflowFactory:3
msgid "the entry point name."
msgstr ""

#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.CalcJobImporterFactory:4
msgid "the loaded :class:`~aiida.engine.processes.calcjobs.importer.CalcJobImporter` plugin."
msgstr ""

#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.CalcJobImporterFactory:5
#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.CalculationFactory:6
#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.DataFactory:6
#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.DbImporterFactory:6
#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.GroupFactory:6
#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.OrbitalFactory:6
#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.ParserFactory:6
#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.SchedulerFactory:6
#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.StorageFactory:6
#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.TransportFactory:5
#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.WorkflowFactory:6
msgid "if the type of the loaded entry point is invalid."
msgstr ""

#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.CalculationFactory:1
msgid "Return the `CalcJob` sub class registered under the given entry point."
msgstr ""

#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.CalculationFactory:5
msgid "sub class of :py:class:`~aiida.engine.processes.calcjobs.calcjob.CalcJob`"
msgstr ""

#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.DataFactory:1
msgid "Return the `Data` sub class registered under the given entry point."
msgstr ""

#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.DataFactory:5
msgid "sub class of :py:class:`~aiida.orm.nodes.data.data.Data`"
msgstr ""

#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.DbImporterFactory:1
msgid "Return the `DbImporter` sub class registered under the given entry point."
msgstr ""

#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.DbImporterFactory:5
msgid "sub class of :py:class:`~aiida.tools.dbimporters.baseclasses.DbImporter`"
msgstr ""

#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.GroupFactory:1
msgid "Return the `Group` sub class registered under the given entry point."
msgstr ""

#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.GroupFactory:5
msgid "sub class of :py:class:`~aiida.orm.groups.Group`"
msgstr ""

#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.OrbitalFactory:1
msgid "Return the `Orbital` sub class registered under the given entry point."
msgstr ""

#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.OrbitalFactory:5
msgid "sub class of :py:class:`~aiida.tools.data.orbital.orbital.Orbital`"
msgstr ""

#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.ParserFactory:1
msgid "Return the `Parser` sub class registered under the given entry point."
msgstr ""

#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.ParserFactory:5
msgid "sub class of :py:class:`~aiida.parsers.parser.Parser`"
msgstr ""

#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.SchedulerFactory:1
msgid "Return the `Scheduler` sub class registered under the given entry point."
msgstr ""

#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.SchedulerFactory:5
msgid "sub class of :py:class:`~aiida.schedulers.scheduler.Scheduler`"
msgstr ""

#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.StorageFactory:1
msgid "Return the ``StorageBackend`` sub class registered under the given entry point."
msgstr ""

#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.StorageFactory:5
msgid "sub class of :py:class:`~aiida.orm.implementation.storage_backend.StorageBackend`."
msgstr ""

#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.TransportFactory:1
msgid "Return the `Transport` sub class registered under the given entry point."
msgstr ""

#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.WorkflowFactory:1
msgid "Return the `WorkChain` sub class registered under the given entry point."
msgstr ""

#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.WorkflowFactory:5
msgid "sub class of :py:class:`~aiida.engine.processes.workchains.workchain.WorkChain` or a `workfunction`"
msgstr ""

#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.raise_invalid_type_error:1
msgid "Raise an `InvalidEntryPointTypeError` with formatted message."
msgstr ""

#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.raise_invalid_type_error:3
msgid "name of the entry point"
msgstr ""

#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.raise_invalid_type_error:4
msgid "name of the entry point group"
msgstr ""

#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.raise_invalid_type_error:5
msgid "tuple of valid classes for the given entry point group"
msgstr ""

#: ../../../src/aiida/plugins/factories.py:docstring of aiida.plugins.factories.raise_invalid_type_error:6
msgid "always"
msgstr ""

#: ../../../src/aiida/plugins/utils.py:docstring of aiida.plugins.utils:1
msgid "Utilities dealing with plugins and entry points."
msgstr ""

#: ../../../src/aiida/plugins/utils.py:docstring of aiida.plugins.utils.PluginVersionProvider:1
msgid "Utility class that determines version information about a given plugin resource."
msgstr ""

#: ../../../src/aiida/plugins/utils.py:docstring of aiida.plugins.utils.PluginVersionProvider.get_version_info:1
msgid "Get the version information for a given plugin."
msgstr ""

#: ../../../src/aiida/plugins/utils.py:docstring of aiida.plugins.utils.PluginVersionProvider.get_version_info:5
msgid "This container will keep a cache, so if this method was already called for the given ``plugin`` before for this instance, the result computed at the last invocation will be returned."
msgstr ""

#: ../../../src/aiida/plugins/utils.py:docstring of aiida.plugins.utils.PluginVersionProvider.get_version_info:8
msgid "A class, function, or an entry point string. If the type is string, it will be assumed to be an entry point string and the class will attempt to load it first. It should be a full entry point string, including the entry point group."
msgstr ""

#: ../../../src/aiida/plugins/utils.py:docstring of aiida.plugins.utils.PluginVersionProvider.get_version_info:11
msgid "Dictionary with the `version.core` and optionally `version.plugin` if it could be determined."
msgstr ""

#: ../../../src/aiida/plugins/utils.py:docstring of aiida.plugins.utils.PluginVersionProvider.get_version_info:12
msgid "If ``plugin`` is a string but could not be loaded as a valid entry point."
msgstr ""

#: ../../../src/aiida/plugins/utils.py:docstring of aiida.plugins.utils.PluginVersionProvider.get_version_info:13
msgid "If ``plugin`` (or the resource pointed to it in the case of an entry point) is not a class or a function."
msgstr ""

#: ../../source/reference/apidoc/aiida.repository.rst:2
msgid "aiida.repository package"
msgstr ""

#: ../../../src/aiida/repository/__init__.py:docstring of aiida.repository:1
msgid "Module with resources dealing with the file repository."
msgstr ""

#: ../../../src/aiida/repository/common.py:docstring of aiida.repository.common:1
msgid "Module with resources common to the repository."
msgstr ""

#: ../../../src/aiida/repository/common.py:docstring of aiida.repository.common.File:1
msgid "Data class representing a file object."
msgstr ""

#: ../../../src/aiida/repository/common.py:docstring of aiida.repository.common.File.__eq__:1
msgid "Return whether this instance is equal to another file object instance."
msgstr ""

#: ../../../src/aiida/repository/common.py:docstring of aiida.repository.common.File.__init__:3
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.LazyFile.__init__:3
msgid "The final element of the file path"
msgstr ""

#: ../../../src/aiida/repository/common.py:docstring of aiida.repository.common.File.__init__:4
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.LazyFile.__init__:4
msgid "Identifies whether the File is a file or a directory"
msgstr ""

#: ../../../src/aiida/repository/common.py:docstring of aiida.repository.common.File.__init__:5
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.LazyFile.__init__:5
msgid "A key to map the file to its contents in the backend repository (file only)"
msgstr ""

#: ../../../src/aiida/repository/common.py:docstring of aiida.repository.common.File.__init__:6
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.LazyFile.__init__:6
msgid "Mapping of child names to child Files (directory only)"
msgstr ""

#: ../../../src/aiida/repository/common.py:docstring of aiida.repository.common.File.__init__:8
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.LazyFile.__init__:8
msgid "If a key is defined for a directory, or objects are defined for a file"
msgstr ""

#: ../../../src/aiida/repository/common.py:docstring of aiida.repository.common.File.file_type:1
msgid "Return the file type of the file object."
msgstr ""

#: ../../../src/aiida/repository/common.py:docstring of aiida.repository.common.File.from_serialized:1
msgid "Construct a new instance from a serialized instance."
msgstr ""

#: ../../../src/aiida/repository/common.py:docstring of aiida.repository.common.File.from_serialized:3
msgid "the serialized instance."
msgstr ""

#: ../../../src/aiida/repository/common.py:docstring of aiida.repository.common.File.from_serialized:4
msgid "the reconstructed file object."
msgstr ""

#: ../../../src/aiida/repository/common.py:docstring of aiida.repository.common.File.is_dir:1
msgid "Return whether this instance is a directory object."
msgstr ""

#: ../../../src/aiida/repository/common.py:docstring of aiida.repository.common.File.is_file:1
msgid "Return whether this instance is a file object."
msgstr ""

#: ../../../src/aiida/repository/common.py:docstring of aiida.repository.common.File.key:1
msgid "Return the key of the file object."
msgstr ""

#: ../../../src/aiida/repository/common.py:docstring of aiida.repository.common.File.name:1
msgid "Return the name of the file object."
msgstr ""

#: ../../../src/aiida/repository/common.py:docstring of aiida.repository.common.File.objects:1
msgid "Return the objects of the file object."
msgstr ""

#: ../../../src/aiida/repository/common.py:docstring of aiida.repository.common.File.serialize:1
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.serialize:1
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.serialize_repository:1
msgid "Serialize the metadata into a JSON-serializable format."
msgstr ""

#: ../../../src/aiida/repository/common.py:docstring of aiida.repository.common.File.serialize:3
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.serialize_repository:3
msgid "the serialization format is optimized to reduce the size in bytes."
msgstr ""

#: ../../../src/aiida/repository/common.py:docstring of aiida.repository.common.FileType:1
msgid "Enumeration to represent the type of a file object."
msgstr ""

#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository:1
msgid "Module for the implementation of a file repository."
msgstr ""

#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository:1
msgid "File repository."
msgstr ""

#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository:3
msgid "This class provides an interface to a backend file repository instance, but unlike the backend repository, this class keeps a reference of the virtual file hierarchy. This means that through this interface, a client can create files and directories with a file hierarchy, just as they would on a local file system, except it is completely virtual as the files are stored by the backend which can store them in a completely flat structure. This also means that the internal virtual hierarchy of a ``Repository`` instance does not necessarily represent all the files that are stored by repository backend. The repository exposes a mere subset of all the file objects stored in the backend. This is why object deletion is also implemented as a soft delete, by default, where the files are just removed from the internal virtual hierarchy, but not in the actual backend. This is because those objects can be referenced by other instances."
msgstr ""

#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.__init__:1
msgid "Construct a new instance with empty metadata."
msgstr ""

#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.__init__:3
msgid "instance of repository backend to use to actually store the file objects. By default, an instance of the ``SandboxRepositoryBackend`` will be created."
msgstr ""

#: ../../../src/aiida/repository/backend/disk_object_store.py:docstring of aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend.__str__:1
#: ../../../src/aiida/repository/backend/sandbox.py:docstring of aiida.repository.backend.sandbox.SandboxRepositoryBackend.__str__:1
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.__str__:1
msgid "Return the string representation of this repository."
msgstr ""

#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository._insert_file:1
msgid "Insert a new file object in the object mapping."
msgstr ""

#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository._insert_file:3
msgid "this assumes the path is a valid relative path, so should be checked by the caller."
msgstr ""

#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository._pre_process_path:1
msgid "Validate and convert the path to instance of ``pathlib.PurePosixPath``."
msgstr ""

#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository._pre_process_path:3
msgid "This should be called by every method of this class before doing anything, such that it can safely assume that the path is a ``pathlib.PurePosixPath`` object, which makes path manipulation a lot easier."
msgstr ""

#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository._pre_process_path:6
msgid "the path as a ``pathlib.PurePosixPath`` object or `None`."
msgstr ""

#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository._pre_process_path:7
msgid "if the type of path was not a str nor a ``pathlib.PurePosixPath`` instance."
msgstr ""

#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.backend:1
msgid "Return the current repository backend."
msgstr ""

#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.backend:3
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.set_backend:3
msgid "the repository backend."
msgstr ""

#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.clone:1
msgid "Clone the contents of another repository instance."
msgstr ""

#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.copy_tree:3
msgid "If ``path`` is specified, only its contents are copied, and the relative path with respect to the root is discarded. For example, if ``path`` is ``relative/sub``, the contents of ``sub`` will be copied directly to the target, without the ``relative/sub`` directory."
msgstr ""

#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.copy_tree:9
msgid "if ``target`` is of incorrect type or not absolute."
msgstr ""

#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.copy_tree:10
msgid "if ``path`` does not reference a directory."
msgstr ""

#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.create_directory:1
#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy_to_main.py:docstring of aiida.storage.sqlite_zip.migrations.legacy_to_main._create_directory:1
msgid "Create a new directory with the given path."
msgstr ""

#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.create_directory:3
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.get_directory:3
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.list_object_names:3
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.list_objects:3
#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy_to_main.py:docstring of aiida.storage.sqlite_zip.migrations.legacy_to_main._create_directory:3
msgid "the relative path of the directory."
msgstr ""

#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.create_directory:4
#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy_to_main.py:docstring of aiida.storage.sqlite_zip.migrations.legacy_to_main._create_directory:4
msgid "the created directory."
msgstr ""

#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.delete:1
msgid "Delete the repository."
msgstr ""

#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.delete:3
msgid "This will not just delete the contents of the repository but also the repository itself and all of its assets. For example, if the repository is stored inside a folder on disk, the folder may be deleted."
msgstr ""

#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.delete_object:1
msgid "Soft delete the object from the repository."
msgstr ""

#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.delete_object:3
msgid "can only delete file objects, but not directories."
msgstr ""

#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.delete_object:6
msgid "when true, not only remove the file from the internal mapping but also call through to the ``delete_object`` method of the actual repository backend."
msgstr ""

#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.flatten:1
msgid "Flatten the serialized content of a repository into a mapping of path -> key or None (if folder)."
msgstr ""

#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.flatten:3
msgid "Note, all folders are represented in the flattened output, and their path is suffixed with the delimiter."
msgstr ""

#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.flatten:5
msgid "the serialized content of the repository."
msgstr ""

#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.flatten:6
msgid "the delimiter to use to separate the path elements."
msgstr ""

#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.flatten:7
msgid "dictionary with the flattened content."
msgstr ""

#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.from_serialized:1
msgid "Construct an instance where the metadata is initialized from the serialized content."
msgstr ""

#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.from_serialized:3
msgid "instance of repository backend to use to actually store the file objects."
msgstr ""

#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.get_directory:1
msgid "Return the directory object at the given path."
msgstr ""

#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.get_file:1
msgid "Return the file object at the given path."
msgstr ""

#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.get_file:3
msgid "the relative path of the file object."
msgstr ""

#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.get_file_keys:1
msgid "Return the keys of all file objects contained within this repository."
msgstr ""

#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.get_file_keys:3
msgid "list of keys, which map a file to its content in the backend repository."
msgstr ""

#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.get_object_content:1
msgid "Return the content of a object identified by path."
msgstr ""

#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.has_object:1
msgid "Return whether the repository has an object with the given path."
msgstr ""

#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.has_object:4
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.has_object:4
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.FolderBackendRepository.has_object:4
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.ZipfileBackendRepository.has_object:4
msgid "True if the object exists, False otherwise."
msgstr ""

#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.hash:3
msgid "this will read the content of all file objects contained within the virtual hierarchy into memory."
msgstr ""

#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.initialise:1
#: ../../../src/aiida/repository/backend/disk_object_store.py:docstring of aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend.initialise:1
#: ../../../src/aiida/repository/backend/sandbox.py:docstring of aiida.repository.backend.sandbox.SandboxRepositoryBackend.initialise:1
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.initialise:1
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.NoopRepositoryBackend.initialise:1
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend._RoBackendRepository.initialise:1
msgid "Initialise the repository if it hasn't already been initialised."
msgstr ""

#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.initialise:3
msgid "keyword argument that will be passed to the ``initialise`` call of the backend."
msgstr ""

#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.is_empty:1
msgid "Return whether the repository is empty."
msgstr ""

#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.is_empty:3
msgid "True if the repository contains no file objects."
msgstr ""

#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.is_initialised:1
msgid "Return whether the repository backend has been initialised."
msgstr ""

#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.list_object_names:4
#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.list_objects:4
msgid "a list of `File` named tuples representing the objects present in directory with the given path."
msgstr ""

#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.open:1
msgid "Open a file handle to an object stored under the given path."
msgstr ""

#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.put_object_from_tree:5
msgid "if the filepath is not a string or ``Path``, or is a relative path."
msgstr ""

#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.set_backend:1
msgid "Set the backend for this repository."
msgstr ""

#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.set_backend:4
msgid "if the type of the backend is invalid."
msgstr ""

#: ../../../src/aiida/repository/repository.py:docstring of aiida.repository.repository.Repository.uuid:1
msgid "Return the unique identifier of the repository backend or ``None`` if it doesn't have one."
msgstr ""

#: ../../source/reference/apidoc/aiida.repository.backend.rst:2
msgid "aiida.repository.backend package"
msgstr ""

#: ../../../src/aiida/repository/backend/__init__.py:docstring of aiida.repository.backend:1
msgid "Module for file repository backend implementations."
msgstr ""

#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract:1
#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend:1
msgid "Class that defines the abstract interface for an object repository."
msgstr ""

#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract:3
msgid "The scope of this class is intentionally very narrow. Any backend implementation should merely provide the methods to store binary blobs, or \"objects\", and return a string-based key that unique identifies the object that was just created. This key should then be able to be used to retrieve the bytes of the corresponding object or to delete it."
msgstr ""

#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend:3
msgid "The repository backend only deals with raw bytes, both when creating new objects as well as when returning a stream or the content of an existing object. The encoding and decoding of the byte content should be done by the client upstream. The file repository backend is also not expected to keep any kind of file hierarchy but must be assumed to be a simple flat data store. When files are created in the file object repository, the implementation will return a string-based key with which the content of the stored object can be addressed. This key is guaranteed to be unique and persistent. Persisting the key or mapping it onto a virtual file hierarchy is again up to the client upstream."
msgstr ""

#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.delete_objects:1
#: ../../../src/aiida/repository/backend/disk_object_store.py:docstring of aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend.delete_objects:1
#: ../../../src/aiida/repository/backend/sandbox.py:docstring of aiida.repository.backend.sandbox.SandboxRepositoryBackend.delete_objects:1
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.NoopRepositoryBackend.delete_objects:1
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend._RoBackendRepository.delete_objects:1
msgid "Delete the objects from the repository."
msgstr ""

#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.delete_objects:3
#: ../../../src/aiida/repository/backend/disk_object_store.py:docstring of aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend.delete_objects:3
#: ../../../src/aiida/repository/backend/sandbox.py:docstring of aiida.repository.backend.sandbox.SandboxRepositoryBackend.delete_objects:3
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.NoopRepositoryBackend.delete_objects:3
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend._RoBackendRepository.delete_objects:3
msgid "list of fully qualified identifiers for the objects within the repository."
msgstr ""

#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.delete_objects:4
#: ../../../src/aiida/repository/backend/disk_object_store.py:docstring of aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend.delete_objects:4
#: ../../../src/aiida/repository/backend/sandbox.py:docstring of aiida.repository.backend.sandbox.SandboxRepositoryBackend.delete_objects:4
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.NoopRepositoryBackend.delete_objects:4
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend._RoBackendRepository.delete_objects:4
msgid "if any of the files does not exist."
msgstr ""

#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.delete_objects:5
#: ../../../src/aiida/repository/backend/disk_object_store.py:docstring of aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend.delete_objects:5
#: ../../../src/aiida/repository/backend/sandbox.py:docstring of aiida.repository.backend.sandbox.SandboxRepositoryBackend.delete_objects:5
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.NoopRepositoryBackend.delete_objects:5
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend._RoBackendRepository.delete_objects:5
msgid "if any of the files could not be deleted."
msgstr ""

#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.erase:1
#: ../../../src/aiida/repository/backend/disk_object_store.py:docstring of aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend.erase:1
#: ../../../src/aiida/repository/backend/sandbox.py:docstring of aiida.repository.backend.sandbox.SandboxRepositoryBackend.erase:1
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.NoopRepositoryBackend.erase:1
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend._RoBackendRepository.erase:1
msgid "Delete the repository itself and all its contents."
msgstr ""

#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.erase:3
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.NoopRepositoryBackend.erase:3
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend._RoBackendRepository.erase:3
msgid "This should not merely delete the contents of the repository but any resources it created. For example, if the repository is essentially a folder on disk, the folder itself should also be deleted, not just its contents."
msgstr ""

#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.get_info:1
#: ../../../src/aiida/repository/backend/sandbox.py:docstring of aiida.repository.backend.sandbox.SandboxRepositoryBackend.get_info:1
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.NoopRepositoryBackend.get_info:1
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SandboxShaRepositoryBackend.get_info:1
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend._RoBackendRepository.get_info:1
msgid "Returns relevant information about the content of the repository."
msgstr ""

#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.get_info:3
#: ../../../src/aiida/repository/backend/sandbox.py:docstring of aiida.repository.backend.sandbox.SandboxRepositoryBackend.get_info:3
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.NoopRepositoryBackend.get_info:3
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SandboxShaRepositoryBackend.get_info:3
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend._RoBackendRepository.get_info:3
msgid "flag to enable extra information (detailed=False by default, only returns basic information)."
msgstr ""

#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.get_info:6
#: ../../../src/aiida/repository/backend/sandbox.py:docstring of aiida.repository.backend.sandbox.SandboxRepositoryBackend.get_info:6
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.NoopRepositoryBackend.get_info:6
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SandboxShaRepositoryBackend.get_info:6
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend._RoBackendRepository.get_info:6
msgid "a dictionary with the information."
msgstr ""

#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.get_object_hash:1
#: ../../../src/aiida/repository/backend/disk_object_store.py:docstring of aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend.get_object_hash:1
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SandboxShaRepositoryBackend.get_object_hash:1
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend._RoBackendRepository.get_object_hash:1
msgid "Return the SHA-256 hash of an object stored under the given key."
msgstr ""

#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.get_object_hash:4
#: ../../../src/aiida/repository/backend/disk_object_store.py:docstring of aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend.get_object_hash:4
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SandboxShaRepositoryBackend.get_object_hash:4
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend._RoBackendRepository.get_object_hash:4
msgid "A SHA-256 hash should always be returned, to ensure consistency across different repository implementations."
msgstr ""

#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.has_object:1
#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.has_objects:1
#: ../../../src/aiida/repository/backend/disk_object_store.py:docstring of aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend.has_objects:1
#: ../../../src/aiida/repository/backend/sandbox.py:docstring of aiida.repository.backend.sandbox.SandboxRepositoryBackend.has_objects:1
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.NoopRepositoryBackend.has_objects:1
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.FolderBackendRepository.has_object:1
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.ZipfileBackendRepository.has_object:1
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend._RoBackendRepository.has_objects:1
msgid "Return whether the repository has an object with the given key."
msgstr ""

#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.has_objects:3
#: ../../../src/aiida/repository/backend/disk_object_store.py:docstring of aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend.has_objects:3
#: ../../../src/aiida/repository/backend/sandbox.py:docstring of aiida.repository.backend.sandbox.SandboxRepositoryBackend.has_objects:3
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.NoopRepositoryBackend.has_objects:3
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend._RoBackendRepository.has_objects:3
msgid "list of fully qualified identifiers for objects within the repository."
msgstr ""

#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.has_objects:5
#: ../../../src/aiida/repository/backend/disk_object_store.py:docstring of aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend.has_objects:5
#: ../../../src/aiida/repository/backend/sandbox.py:docstring of aiida.repository.backend.sandbox.SandboxRepositoryBackend.has_objects:5
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.NoopRepositoryBackend.has_objects:5
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend._RoBackendRepository.has_objects:5
msgid "list of logicals, in the same order as the keys provided, with value True if the respective object exists and False otherwise."
msgstr ""

#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.initialise:3
#: ../../../src/aiida/repository/backend/disk_object_store.py:docstring of aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend.initialise:3
#: ../../../src/aiida/repository/backend/sandbox.py:docstring of aiida.repository.backend.sandbox.SandboxRepositoryBackend.initialise:3
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.NoopRepositoryBackend.initialise:3
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend._RoBackendRepository.initialise:3
msgid "parameters for the initialisation."
msgstr ""

#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.is_initialised:1
#: ../../../src/aiida/repository/backend/disk_object_store.py:docstring of aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend.is_initialised:1
#: ../../../src/aiida/repository/backend/sandbox.py:docstring of aiida.repository.backend.sandbox.SandboxRepositoryBackend.is_initialised:1
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.NoopRepositoryBackend.is_initialised:1
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend._RoBackendRepository.is_initialised:1
msgid "Return whether the repository has been initialised."
msgstr ""

#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.iter_object_streams:1
#: ../../../src/aiida/repository/backend/disk_object_store.py:docstring of aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend.iter_object_streams:1
#: ../../../src/aiida/repository/backend/sandbox.py:docstring of aiida.repository.backend.sandbox.SandboxRepositoryBackend.iter_object_streams:1
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.NoopRepositoryBackend.iter_object_streams:1
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend._RoBackendRepository.iter_object_streams:1
msgid "Return an iterator over the (read-only) byte streams of objects identified by key."
msgstr ""

#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.iter_object_streams:3
#: ../../../src/aiida/repository/backend/disk_object_store.py:docstring of aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend.iter_object_streams:3
#: ../../../src/aiida/repository/backend/sandbox.py:docstring of aiida.repository.backend.sandbox.SandboxRepositoryBackend.iter_object_streams:3
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.NoopRepositoryBackend.iter_object_streams:3
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend._RoBackendRepository.iter_object_streams:3
msgid "handles should only be read within the context of this iterator."
msgstr ""

#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.iter_object_streams:5
#: ../../../src/aiida/repository/backend/disk_object_store.py:docstring of aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend.iter_object_streams:5
#: ../../../src/aiida/repository/backend/sandbox.py:docstring of aiida.repository.backend.sandbox.SandboxRepositoryBackend.iter_object_streams:5
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.NoopRepositoryBackend.iter_object_streams:5
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend._RoBackendRepository.iter_object_streams:5
msgid "fully qualified identifiers for the objects within the repository."
msgstr ""

#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.iter_object_streams:6
#: ../../../src/aiida/repository/backend/disk_object_store.py:docstring of aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend.iter_object_streams:6
#: ../../../src/aiida/repository/backend/sandbox.py:docstring of aiida.repository.backend.sandbox.SandboxRepositoryBackend.iter_object_streams:6
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.NoopRepositoryBackend.iter_object_streams:6
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend._RoBackendRepository.iter_object_streams:6
msgid "an iterator over the object byte streams."
msgstr ""

#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.iter_object_streams:8
#: ../../../src/aiida/repository/backend/disk_object_store.py:docstring of aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend.iter_object_streams:8
#: ../../../src/aiida/repository/backend/sandbox.py:docstring of aiida.repository.backend.sandbox.SandboxRepositoryBackend.iter_object_streams:8
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.NoopRepositoryBackend.iter_object_streams:8
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend._RoBackendRepository.iter_object_streams:8
msgid "if a file could not be opened."
msgstr ""

#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.key_format:1
#: ../../../src/aiida/repository/backend/disk_object_store.py:docstring of aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend.key_format:1
#: ../../../src/aiida/repository/backend/sandbox.py:docstring of aiida.repository.backend.sandbox.SandboxRepositoryBackend.key_format:1
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.NoopRepositoryBackend.key_format:1
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SandboxShaRepositoryBackend.key_format:1
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend._RoBackendRepository.key_format:1
msgid "Return the format for the keys of the repository."
msgstr ""

#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.key_format:3
#: ../../../src/aiida/repository/backend/disk_object_store.py:docstring of aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend.key_format:3
#: ../../../src/aiida/repository/backend/sandbox.py:docstring of aiida.repository.backend.sandbox.SandboxRepositoryBackend.key_format:3
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.NoopRepositoryBackend.key_format:3
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SandboxShaRepositoryBackend.key_format:3
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend._RoBackendRepository.key_format:3
msgid "Important for when migrating between backends (e.g. archive -> main), as if they are not equal then it is necessary to re-compute all the `Node.base.repository.metadata` before importing (otherwise they will not match with the repository)."
msgstr ""

#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.list_objects:1
#: ../../../src/aiida/repository/backend/disk_object_store.py:docstring of aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend.list_objects:1
#: ../../../src/aiida/repository/backend/sandbox.py:docstring of aiida.repository.backend.sandbox.SandboxRepositoryBackend.list_objects:1
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.NoopRepositoryBackend.list_objects:1
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.FolderBackendRepository.list_objects:1
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.ZipfileBackendRepository.list_objects:1
msgid "Return iterable that yields all available objects by key."
msgstr ""

#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.list_objects:3
#: ../../../src/aiida/repository/backend/disk_object_store.py:docstring of aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend.list_objects:3
#: ../../../src/aiida/repository/backend/sandbox.py:docstring of aiida.repository.backend.sandbox.SandboxRepositoryBackend.list_objects:3
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.NoopRepositoryBackend.list_objects:3
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.FolderBackendRepository.list_objects:3
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.ZipfileBackendRepository.list_objects:3
msgid "An iterable for all the available object keys."
msgstr ""

#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.maintain:1
#: ../../../src/aiida/repository/backend/disk_object_store.py:docstring of aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend.maintain:1
#: ../../../src/aiida/repository/backend/sandbox.py:docstring of aiida.repository.backend.sandbox.SandboxRepositoryBackend.maintain:1
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.NoopRepositoryBackend.maintain:1
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SandboxShaRepositoryBackend.maintain:1
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend._RoBackendRepository.maintain:1
msgid "Performs maintenance operations."
msgstr ""

#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.maintain:6
#: ../../../src/aiida/repository/backend/sandbox.py:docstring of aiida.repository.backend.sandbox.SandboxRepositoryBackend.maintain:6
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.NoopRepositoryBackend.maintain:6
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SandboxShaRepositoryBackend.maintain:6
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend._RoBackendRepository.maintain:6
msgid "flag to indicate to the backend whether AiiDA is live or not (i.e. if the profile of the backend is currently being used/accessed). The backend is expected then to only allow (and thus set by default) the operations that are safe to perform in this state."
msgstr ""

#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.put_object_from_file:1
msgid "Store a new object with contents of the file located at `filepath` on this file system."
msgstr ""

#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.put_object_from_file:3
msgid "absolute path of file whose contents to copy to the repository."
msgstr ""

#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.put_object_from_file:4
#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.put_object_from_filelike:4
#: ../../../src/aiida/repository/backend/disk_object_store.py:docstring of aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend._put_object_from_filelike:4
#: ../../../src/aiida/repository/backend/sandbox.py:docstring of aiida.repository.backend.sandbox.SandboxRepositoryBackend._put_object_from_filelike:4
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SandboxShaRepositoryBackend._put_object_from_filelike:4
msgid "the generated fully qualified identifier for the object within the repository."
msgstr ""

#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.put_object_from_file:5
#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.put_object_from_filelike:5
#: ../../../src/aiida/repository/backend/disk_object_store.py:docstring of aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend._put_object_from_filelike:5
#: ../../../src/aiida/repository/backend/sandbox.py:docstring of aiida.repository.backend.sandbox.SandboxRepositoryBackend._put_object_from_filelike:5
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SandboxShaRepositoryBackend._put_object_from_filelike:5
msgid "if the handle is not a byte stream."
msgstr ""

#: ../../../src/aiida/repository/backend/abstract.py:docstring of aiida.repository.backend.abstract.AbstractRepositoryBackend.uuid:1
#: ../../../src/aiida/repository/backend/disk_object_store.py:docstring of aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend.uuid:1
#: ../../../src/aiida/repository/backend/sandbox.py:docstring of aiida.repository.backend.sandbox.SandboxRepositoryBackend.uuid:1
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.NoopRepositoryBackend.uuid:1
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend._RoBackendRepository.uuid:1
msgid "Return the unique identifier of the repository."
msgstr ""

#: ../../../src/aiida/repository/backend/disk_object_store.py:docstring of aiida.repository.backend.disk_object_store:1
msgid "Implementation of the ``AbstractRepositoryBackend`` using the ``disk-objectstore`` as the backend."
msgstr ""

#: ../../../src/aiida/repository/backend/disk_object_store.py:docstring of aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend:1
#: ../../../src/aiida/repository/backend/sandbox.py:docstring of aiida.repository.backend.sandbox.SandboxRepositoryBackend:1
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.NoopRepositoryBackend:1
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend._RoBackendRepository:1
msgid "Bases: :py:class:`~aiida.repository.backend.abstract.AbstractRepositoryBackend`"
msgstr ""

#: ../../../src/aiida/repository/backend/disk_object_store.py:docstring of aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend:1
msgid "Implementation of the ``AbstractRepositoryBackend`` using the ``disk-object-store`` as the backend."
msgstr ""

#: ../../../src/aiida/repository/backend/disk_object_store.py:docstring of aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend:3
msgid "For certain methods, the container may create a sessions which should be closed after the operation is done to make sure the connection to the underlying sqlite database is closed. The best way is to accomplish this is by using the container as a context manager, which will automatically call the ``close`` method when it exits which ensures the session being closed. Note that not all methods may open the session and so need closing it, but to be on the safe side, we put every use of the container in a context manager. If no session is created, the ``close`` method is essentially a no-op."
msgstr ""

#: ../../../src/aiida/repository/backend/disk_object_store.py:docstring of aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend.get_info:1
msgid "Return information on configuration and content of the repository."
msgstr ""

#: ../../../src/aiida/repository/backend/disk_object_store.py:docstring of aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend.maintain:3
msgid "if True, will only perform operations that are safe to do while the repository is in use."
msgstr ""

#: ../../../src/aiida/repository/backend/disk_object_store.py:docstring of aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend.maintain:4
msgid "flag for forcing the packing of loose files."
msgstr ""

#: ../../../src/aiida/repository/backend/disk_object_store.py:docstring of aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend.maintain:5
msgid "flag for forcing the re-packing of already packed files."
msgstr ""

#: ../../../src/aiida/repository/backend/disk_object_store.py:docstring of aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend.maintain:6
msgid "flag for forcing the cleaning of soft-deleted files from the repository."
msgstr ""

#: ../../../src/aiida/repository/backend/disk_object_store.py:docstring of aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend.maintain:7
msgid "flag for forcing the vacuuming of the internal database when cleaning the repository."
msgstr ""

#: ../../../src/aiida/repository/backend/disk_object_store.py:docstring of aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend.maintain:8
msgid "flag for compressing the data when packing loose files. Set to ``Compress.AUTO`` if ``True``."
msgstr ""

#: ../../../src/aiida/repository/backend/disk_object_store.py:docstring of aiida.repository.backend.disk_object_store.DiskObjectStoreRepositoryBackend.maintain:9
msgid "a dictionary with information on the operations performed."
msgstr ""

#: ../../../src/aiida/repository/backend/sandbox.py:docstring of aiida.repository.backend.sandbox:1
#: ../../../src/aiida/repository/backend/sandbox.py:docstring of aiida.repository.backend.sandbox.SandboxRepositoryBackend:1
msgid "Implementation of the ``AbstractRepositoryBackend`` using a sandbox folder on disk as the backend."
msgstr ""

#: ../../../src/aiida/repository/backend/sandbox.py:docstring of aiida.repository.backend.sandbox.SandboxRepositoryBackend.__del__:1
msgid "Delete the entire sandbox folder if it was instantiated and still exists."
msgstr ""

#: ../../../src/aiida/repository/backend/sandbox.py:docstring of aiida.repository.backend.sandbox.SandboxRepositoryBackend.__init__:3
msgid "The path to the directory in which the sandbox folder should be created."
msgstr ""

#: ../../../src/aiida/repository/backend/sandbox.py:docstring of aiida.repository.backend.sandbox.SandboxRepositoryBackend.sandbox:1
msgid "Return the sandbox instance of this repository."
msgstr ""

#: ../../../src/aiida/repository/backend/sandbox.py:docstring of aiida.repository.backend.sandbox.SandboxRepositoryBackend.uuid:3
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.NoopRepositoryBackend.uuid:3
msgid "A sandbox folder does not have the concept of a unique identifier and so always returns ``None``."
msgstr ""

#: ../../source/reference/apidoc/aiida.restapi.rst:2
msgid "aiida.restapi package"
msgstr ""

#: ../../../src/aiida/restapi/__init__.py:docstring of aiida.restapi:1
msgid "In this module, AiiDA provides REST API to access different AiiDA nodes stored in database. The REST API is implemented using Flask RESTFul framework."
msgstr ""

#: ../../../src/aiida/restapi/api.py:docstring of aiida.restapi.api:1
msgid "Implementation of RESTful API for AiiDA based on flask and flask_restful."
msgstr ""

#: ../../../src/aiida/restapi/api.py:docstring of aiida.restapi.api:3
msgid "Author: Snehal P. Waychal and Fernando Gargiulo @ Theos, EPFL"
msgstr ""

#: ../../../src/aiida/restapi/api.py:docstring of aiida.restapi.api.AiidaApi:1
msgid "Bases: :py:class:`~flask_restful.Api`"
msgstr ""

#: ../../../src/aiida/restapi/api.py:docstring of aiida.restapi.api.AiidaApi:1
msgid "AiiDA customized version of the flask_restful Api class"
msgstr ""

#: ../../../src/aiida/restapi/api.py:docstring of aiida.restapi.api.AiidaApi.__init__:1
msgid "The need to have a special constructor is to include directly the addition of resources with the parameters required to initialize the resource classes."
msgstr ""

#: ../../../src/aiida/restapi/api.py:docstring of aiida.restapi.api.AiidaApi.__init__:5
msgid "parameters to be passed to the resources for configuration and PREFIX"
msgstr ""

#: ../../../src/aiida/restapi/api.py:docstring of aiida.restapi.api.AiidaApi.handle_error:1
msgid "This method handles the 404 \"URL not found\" exception and return custom message :param e: raised exception :return: list of available endpoints"
msgstr ""

#: ../../../src/aiida/restapi/api.py:docstring of aiida.restapi.api.App:1
msgid "Bases: :py:class:`~flask.app.Flask`"
msgstr ""

#: ../../../src/aiida/restapi/api.py:docstring of aiida.restapi.api.App:1
msgid "Basic Flask App customized for this REST Api purposes"
msgstr ""

#: ../../../src/aiida/restapi/resources.py:docstring of aiida.restapi.resources:1
msgid "Resources for REST API"
msgstr ""

#: ../../../src/aiida/restapi/resources.py:docstring of aiida.restapi.resources.BaseResource:1
#: ../../../src/aiida/restapi/resources.py:docstring of aiida.restapi.resources.ServerInfo:1
msgid "Bases: :py:class:`~flask_restful.Resource`"
msgstr ""

#: ../../../src/aiida/restapi/resources.py:docstring of aiida.restapi.resources.BaseResource:1
msgid "Each derived class will instantiate a different type of translator. This is the only difference in the classes."
msgstr ""

#: ../../../src/aiida/restapi/translator/base.py:docstring of aiida.restapi.translator.base.BaseTranslator:1
msgid "Generic class for translator. It contains the methods required to build a related QueryBuilder object"
msgstr ""

#: ../../../src/aiida/restapi/translator/base.py:docstring of aiida.restapi.translator.base.BaseTranslator.__init__:1
#: ../../../src/aiida/restapi/translator/nodes/node.py:docstring of aiida.restapi.translator.nodes.node.NodeTranslator.__init__:1
msgid "Initialise the parameters. Create the basic query_help"
msgstr ""

#: ../../../src/aiida/restapi/translator/base.py:docstring of aiida.restapi.translator.base.BaseTranslator.__init__:4
msgid "keyword Class (default None but becomes this class): is the class from which one takes the initial values of the attributes. By default is this class so that class atributes are translated into object attributes. In case of inheritance one cane use the same constructore but pass the inheriting class to pass its attributes."
msgstr ""

#: ../../../src/aiida/restapi/translator/base.py:docstring of aiida.restapi.translator.base.BaseTranslator.__repr__:1
msgid "This function is required for the caching system to be able to compare two NodeTranslator objects. Comparison is done on the value returned by __repr__"
msgstr ""

#: ../../../src/aiida/restapi/translator/base.py:docstring of aiida.restapi.translator.base.BaseTranslator.__repr__:4
msgid "representation of NodeTranslator objects. Returns nothing because the inputs of self.get_nodes are sufficient to determine the identity of two queries."
msgstr ""

#: ../../../src/aiida/restapi/translator/base.py:docstring of aiida.restapi.translator.base.BaseTranslator._check_id_validity:1
msgid "Checks whether id corresponds to an object of the expected type, whenever type is a valid column of the database (ex. for nodes, but not for users)"
msgstr ""

#: ../../../src/aiida/restapi/translator/base.py:docstring of aiida.restapi.translator.base.BaseTranslator._check_id_validity:5
msgid "id (or id starting pattern)"
msgstr ""

#: ../../../src/aiida/restapi/translator/base.py:docstring of aiida.restapi.translator.base.BaseTranslator._check_id_validity:7
msgid "True if node_id valid, False if invalid. If True, sets the id filter attribute correctly"
msgstr ""

#: ../../../src/aiida/restapi/translator/base.py:docstring of aiida.restapi.translator.base.BaseTranslator._check_id_validity:10
msgid "if no node is found or id pattern does not identify a unique node"
msgstr ""

#: ../../../src/aiida/restapi/translator/base.py:docstring of aiida.restapi.translator.base.BaseTranslator.count:1
msgid "Count the number of rows returned by the query and set total_count"
msgstr ""

#: ../../../src/aiida/restapi/translator/base.py:docstring of aiida.restapi.translator.base.BaseTranslator.get_default_projections:1
msgid "Method to get default projections of the node :return: self._default_projections"
msgstr ""

#: ../../../src/aiida/restapi/translator/base.py:docstring of aiida.restapi.translator.base.BaseTranslator.get_formatted_result:1
#: ../../../src/aiida/restapi/translator/nodes/node.py:docstring of aiida.restapi.translator.nodes.node.NodeTranslator.get_formatted_result:1
msgid "Runs the query and retrieves results tagged as \"label\"."
msgstr ""

#: ../../../src/aiida/restapi/translator/base.py:docstring of aiida.restapi.translator.base.BaseTranslator.get_formatted_result:3
#: ../../../src/aiida/restapi/translator/nodes/node.py:docstring of aiida.restapi.translator.nodes.node.NodeTranslator.get_formatted_result:3
msgid "the tag of the results to be extracted out of the query rows."
msgstr ""

#: ../../../src/aiida/restapi/translator/base.py:docstring of aiida.restapi.translator.base.BaseTranslator.get_formatted_result:6
#: ../../../src/aiida/restapi/translator/nodes/node.py:docstring of aiida.restapi.translator.nodes.node.NodeTranslator.get_formatted_result:6
msgid "a list of the query results"
msgstr ""

#: ../../../src/aiida/restapi/translator/base.py:docstring of aiida.restapi.translator.base.BaseTranslator.get_projectable_properties:1
msgid "This method is extended in specific translators classes. It returns a dict as follows: dict(fields=projectable_properties, ordering=ordering) where projectable_properties is a dict and ordering is a list"
msgstr ""

#: ../../../src/aiida/restapi/translator/base.py:docstring of aiida.restapi.translator.base.BaseTranslator.get_query_help:1
msgid "return QB json dictionary"
msgstr ""

#: ../../../src/aiida/restapi/translator/base.py:docstring of aiida.restapi.translator.base.BaseTranslator.get_results:1
msgid "Returns either list of nodes or details of single node from database."
msgstr ""

#: ../../../src/aiida/restapi/translator/base.py:docstring of aiida.restapi.translator.base.BaseTranslator.get_results:3
msgid "either list of nodes or details of single node from database"
msgstr ""

#: ../../../src/aiida/restapi/translator/base.py:docstring of aiida.restapi.translator.base.BaseTranslator.get_total_count:1
msgid "Returns the number of rows of the query."
msgstr ""

#: ../../../src/aiida/restapi/translator/base.py:docstring of aiida.restapi.translator.base.BaseTranslator.get_total_count:3
msgid "total_count"
msgstr ""

#: ../../../src/aiida/restapi/translator/base.py:docstring of aiida.restapi.translator.base.BaseTranslator.init_qb:1
msgid "Initialize query builder object by means of _query_help"
msgstr ""

#: ../../../src/aiida/restapi/translator/base.py:docstring of aiida.restapi.translator.base.BaseTranslator.set_default_projections:1
msgid "It calls the set_projections() methods internally to add the default projections in query_help"
msgstr ""

#: ../../../src/aiida/restapi/translator/base.py:docstring of aiida.restapi.translator.base.BaseTranslator.set_default_projections:4
msgid "None"
msgstr ""

#: ../../../src/aiida/restapi/translator/base.py:docstring of aiida.restapi.translator.base.BaseTranslator.set_filters:1
msgid "Add filters in query_help."
msgstr ""

#: ../../../src/aiida/restapi/translator/base.py:docstring of aiida.restapi.translator.base.BaseTranslator.set_filters:3
msgid "it is a dictionary where keys are the tag names given in the path in query_help and their values are the dictionary of filters want to add for that tag name. Format for the Filters dictionary::      filters = {         \"tag1\" : {k1:v1, k2:v2},         \"tag2\" : {k1:v1, k2:v2},     }"
msgstr ""

#: ../../../src/aiida/restapi/translator/base.py:docstring of aiida.restapi.translator.base.BaseTranslator.set_filters:3
msgid "it is a dictionary where keys are the tag names given in the path in query_help and their values are the dictionary of filters want to add for that tag name. Format for the Filters dictionary::"
msgstr ""

#: ../../../src/aiida/restapi/translator/base.py:docstring of aiida.restapi.translator.base.BaseTranslator.set_filters:13
msgid "query_help dict including filters if any."
msgstr ""

#: ../../../src/aiida/restapi/translator/base.py:docstring of aiida.restapi.translator.base.BaseTranslator.set_limit_offset:1
msgid "Sets limits and offset directly to the query_builder object"
msgstr ""

#: ../../../src/aiida/restapi/translator/base.py:docstring of aiida.restapi.translator.base.BaseTranslator.set_order:1
msgid "Add order_by clause in query_help :param orders: dictionary of orders you want to apply on final results :return: None or exception if any."
msgstr ""

#: ../../../src/aiida/restapi/translator/base.py:docstring of aiida.restapi.translator.base.BaseTranslator.set_projections:1
msgid "Add the projections in query_help"
msgstr ""

#: ../../../src/aiida/restapi/translator/base.py:docstring of aiida.restapi.translator.base.BaseTranslator.set_projections:3
msgid "it is a dictionary where keys are the tag names given in the path in query_help and values are the list of the names you want to project in the final output"
msgstr ""

#: ../../../src/aiida/restapi/translator/base.py:docstring of aiida.restapi.translator.base.BaseTranslator.set_projections:6
msgid "updated query_help with projections"
msgstr ""

#: ../../../src/aiida/restapi/translator/base.py:docstring of aiida.restapi.translator.base.BaseTranslator.set_query:1
#: ../../../src/aiida/restapi/translator/nodes/node.py:docstring of aiida.restapi.translator.nodes.node.NodeTranslator.set_query:1
msgid "Adds filters, default projections, order specs to the query_help, and initializes the qb object"
msgstr ""

#: ../../../src/aiida/restapi/translator/base.py:docstring of aiida.restapi.translator.base.BaseTranslator.set_query:4
#: ../../../src/aiida/restapi/translator/nodes/node.py:docstring of aiida.restapi.translator.nodes.node.NodeTranslator.set_query:4
msgid "dictionary with the filters"
msgstr ""

#: ../../../src/aiida/restapi/translator/base.py:docstring of aiida.restapi.translator.base.BaseTranslator.set_query:5
#: ../../../src/aiida/restapi/translator/nodes/node.py:docstring of aiida.restapi.translator.nodes.node.NodeTranslator.set_query:5
msgid "dictionary with the order for each tag"
msgstr ""

#: ../../../src/aiida/restapi/translator/base.py:docstring of aiida.restapi.translator.base.BaseTranslator.set_query:6
#: ../../../src/aiida/restapi/translator/nodes/node.py:docstring of aiida.restapi.translator.nodes.node.NodeTranslator.set_query:6
msgid "dictionary with the projection. It is discarded if query_type=='attributes'/'extras'"
msgstr ""

#: ../../../src/aiida/restapi/translator/base.py:docstring of aiida.restapi.translator.base.BaseTranslator.set_query:8
#: ../../../src/aiida/restapi/translator/nodes/node.py:docstring of aiida.restapi.translator.nodes.node.NodeTranslator.set_query:8
msgid "(string) specify the result or the content (\"attr\")"
msgstr ""

#: ../../../src/aiida/restapi/translator/base.py:docstring of aiida.restapi.translator.base.BaseTranslator.set_query:9
#: ../../../src/aiida/restapi/translator/nodes/node.py:docstring of aiida.restapi.translator.nodes.node.NodeTranslator.set_query:9
msgid "(integer) id of a specific node"
msgstr ""

#: ../../../src/aiida/restapi/translator/base.py:docstring of aiida.restapi.translator.base.BaseTranslator.set_query:10
#: ../../../src/aiida/restapi/translator/nodes/node.py:docstring of aiida.restapi.translator.nodes.node.NodeTranslator.set_query:11
msgid "name of the file to return its content"
msgstr ""

#: ../../../src/aiida/restapi/translator/base.py:docstring of aiida.restapi.translator.base.BaseTranslator.set_query:11
#: ../../../src/aiida/restapi/translator/base.py:docstring of aiida.restapi.translator.base.BaseTranslator.set_query:13
msgid "flag to show attributes in nodes endpoint"
msgstr ""

#: ../../../src/aiida/restapi/translator/base.py:docstring of aiida.restapi.translator.base.BaseTranslator.set_query:12
msgid "list of node attributes to query"
msgstr ""

#: ../../../src/aiida/restapi/translator/base.py:docstring of aiida.restapi.translator.base.BaseTranslator.set_query:14
msgid "list of node extras to query"
msgstr ""

#: ../../../src/aiida/restapi/resources.py:docstring of aiida.restapi.resources.BaseResource.__init__:1
#: ../../../src/aiida/restapi/resources.py:docstring of aiida.restapi.resources.QueryBuilder.__init__:1
msgid "Construct the resource."
msgstr ""

#: ../../../src/aiida/restapi/resources.py:docstring of aiida.restapi.resources.BaseResource._load_and_verify:1
msgid "Load node and verify it is of the required type"
msgstr ""

#: ../../../src/aiida/restapi/resources.py:docstring of aiida.restapi.resources.BaseResource.get:1
msgid "Get method for the resource :param id: node identifier :param page: page no, used for pagination :return: http response"
msgstr ""

#: ../../../src/aiida/restapi/resources.py:docstring of aiida.restapi.resources.BaseResource.load_profile:1
msgid "Load the required profile."
msgstr ""

#: ../../../src/aiida/restapi/resources.py:docstring of aiida.restapi.resources.BaseResource.load_profile:3
msgid "This will load the profile specified by the ``profile`` keyword in the query parameters, and if not specified it will default to the profile defined in the constructor."
msgstr ""

#: ../../docstring of aiida.restapi.resources.BaseResource.methods:1
#: ../../docstring of aiida.restapi.resources.CalcJobNode.methods:1
#: ../../docstring of aiida.restapi.resources.Computer.methods:1
#: ../../docstring of aiida.restapi.resources.Group.methods:1
#: ../../docstring of aiida.restapi.resources.Node.methods:1
#: ../../docstring of aiida.restapi.resources.ProcessNode.methods:1
#: ../../docstring of aiida.restapi.resources.QueryBuilder.methods:1
#: ../../docstring of aiida.restapi.resources.ServerInfo.methods:1
#: ../../docstring of aiida.restapi.resources.User.methods:1
msgid "The methods this view is registered for. Uses the same default (``[\"GET\", \"HEAD\", \"OPTIONS\"]``) as ``route`` and ``add_url_rule`` by default."
msgstr ""

#: ../../../src/aiida/restapi/resources.py:docstring of aiida.restapi.resources.BaseResource.parse_path:1
msgid "Parse the request path."
msgstr ""

#: ../../../src/aiida/restapi/resources.py:docstring of aiida.restapi.resources.BaseResource.parse_query_string:1
msgid "Parse the request query string."
msgstr ""

#: ../../../src/aiida/restapi/resources.py:docstring of aiida.restapi.resources.BaseResource.unquote_request:1
msgid "Unquote and return various parts of the request."
msgstr ""

#: ../../../src/aiida/restapi/resources.py:docstring of aiida.restapi.resources.BaseResource.unquote_request:3
msgid "Tuple of the request path, url, url root and query string."
msgstr ""

#: ../../../src/aiida/restapi/resources.py:docstring of aiida.restapi.resources.CalcJobNode:1
msgid "Bases: :py:class:`~aiida.restapi.resources.ProcessNode`"
msgstr ""

#: ../../../src/aiida/restapi/resources.py:docstring of aiida.restapi.resources.CalcJobNode:1
msgid "Resource for CalcJobNode"
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/process/calculation/calcfunction.py:docstring of aiida.restapi.translator.nodes.process.calculation.calcfunction.CalcFunctionTranslator:1
#: ../../../src/aiida/restapi/translator/nodes/process/calculation/calcjob.py:docstring of aiida.restapi.translator.nodes.process.calculation.calcjob.CalcJobTranslator:1
#: ../../../src/aiida/restapi/translator/nodes/process/workflow/workchain.py:docstring of aiida.restapi.translator.nodes.process.workflow.workchain.WorkChainTranslator:1
#: ../../../src/aiida/restapi/translator/nodes/process/workflow/workfunction.py:docstring of aiida.restapi.translator.nodes.process.workflow.workfunction.WorkFunctionTranslator:1
msgid "Bases: :py:class:`~aiida.restapi.translator.nodes.process.process.ProcessTranslator`"
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/process/calculation/calcjob.py:docstring of aiida.restapi.translator.nodes.process.calculation.calcjob.CalcJobTranslator:1
msgid "Translator relative to resource 'calculations' and aiida class Calculation"
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/process/calculation/calcjob.py:docstring of aiida.restapi.translator.nodes.process.calculation.calcjob.CalcJobTranslator.get_derived_properties:1
msgid "Generic function extended for calcjob. Currently it is not implemented."
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/data/cif.py:docstring of aiida.restapi.translator.nodes.data.cif.CifDataTranslator.get_derived_properties:4
#: ../../../src/aiida/restapi/translator/nodes/data/code.py:docstring of aiida.restapi.translator.nodes.data.code.CodeTranslator.get_derived_properties:4
#: ../../../src/aiida/restapi/translator/nodes/data/upf.py:docstring of aiida.restapi.translator.nodes.data.upf.UpfDataTranslator.get_derived_properties:1
#: ../../../src/aiida/restapi/translator/nodes/node.py:docstring of aiida.restapi.translator.nodes.node.NodeTranslator.get_comments:1
#: ../../../src/aiida/restapi/translator/nodes/node.py:docstring of aiida.restapi.translator.nodes.node.NodeTranslator.get_downloadable_data:6
#: ../../../src/aiida/restapi/translator/nodes/process/calculation/calcfunction.py:docstring of aiida.restapi.translator.nodes.process.calculation.calcfunction.CalcFunctionTranslator.get_derived_properties:4
#: ../../../src/aiida/restapi/translator/nodes/process/calculation/calcjob.py:docstring of aiida.restapi.translator.nodes.process.calculation.calcjob.CalcJobTranslator.get_derived_properties:4
#: ../../../src/aiida/restapi/translator/nodes/process/workflow/workchain.py:docstring of aiida.restapi.translator.nodes.process.workflow.workchain.WorkChainTranslator.get_derived_properties:4
#: ../../../src/aiida/restapi/translator/nodes/process/workflow/workfunction.py:docstring of aiida.restapi.translator.nodes.process.workflow.workfunction.WorkFunctionTranslator.get_derived_properties:4
msgid "node object"
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/data/cif.py:docstring of aiida.restapi.translator.nodes.data.cif.CifDataTranslator.get_derived_properties:5
#: ../../../src/aiida/restapi/translator/nodes/data/code.py:docstring of aiida.restapi.translator.nodes.data.code.CodeTranslator.get_derived_properties:5
#: ../../../src/aiida/restapi/translator/nodes/data/upf.py:docstring of aiida.restapi.translator.nodes.data.upf.UpfDataTranslator.get_derived_properties:2
#: ../../../src/aiida/restapi/translator/nodes/process/calculation/calcfunction.py:docstring of aiida.restapi.translator.nodes.process.calculation.calcfunction.CalcFunctionTranslator.get_derived_properties:5
#: ../../../src/aiida/restapi/translator/nodes/process/calculation/calcjob.py:docstring of aiida.restapi.translator.nodes.process.calculation.calcjob.CalcJobTranslator.get_derived_properties:5
#: ../../../src/aiida/restapi/translator/nodes/process/workflow/workchain.py:docstring of aiida.restapi.translator.nodes.process.workflow.workchain.WorkChainTranslator.get_derived_properties:5
#: ../../../src/aiida/restapi/translator/nodes/process/workflow/workfunction.py:docstring of aiida.restapi.translator.nodes.process.workflow.workfunction.WorkFunctionTranslator.get_derived_properties:5
msgid "empty dict"
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/process/calculation/calcjob.py:docstring of aiida.restapi.translator.nodes.process.calculation.calcjob.CalcJobTranslator.get_input_files:1
msgid "Get the submitted input files for job calculation :param node: aiida node :return: the retrieved input files for job calculation"
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/process/calculation/calcjob.py:docstring of aiida.restapi.translator.nodes.process.calculation.calcjob.CalcJobTranslator.get_output_files:1
msgid "Get the retrieved output files for job calculation :param node: aiida node :return: the retrieved output files for job calculation"
msgstr ""

#: ../../../src/aiida/restapi/resources.py:docstring of aiida.restapi.resources.CalcJobNode.get:1
#: ../../../src/aiida/restapi/resources.py:docstring of aiida.restapi.resources.ProcessNode.get:1
msgid "Get method for the Process resource."
msgstr ""

#: ../../../src/aiida/restapi/resources.py:docstring of aiida.restapi.resources.CalcJobNode.get:3
#: ../../../src/aiida/restapi/resources.py:docstring of aiida.restapi.resources.Node.get:3
#: ../../../src/aiida/restapi/resources.py:docstring of aiida.restapi.resources.ProcessNode.get:3
msgid "node identifier"
msgstr ""

#: ../../../src/aiida/restapi/resources.py:docstring of aiida.restapi.resources.CalcJobNode.get:4
#: ../../../src/aiida/restapi/resources.py:docstring of aiida.restapi.resources.Node.get:5
#: ../../../src/aiida/restapi/resources.py:docstring of aiida.restapi.resources.ProcessNode.get:4
msgid "http response"
msgstr ""

#: ../../../src/aiida/restapi/resources.py:docstring of aiida.restapi.resources.Computer:1
#: ../../../src/aiida/restapi/resources.py:docstring of aiida.restapi.resources.Group:1
#: ../../../src/aiida/restapi/resources.py:docstring of aiida.restapi.resources.Node:1
#: ../../../src/aiida/restapi/resources.py:docstring of aiida.restapi.resources.QueryBuilder:1
#: ../../../src/aiida/restapi/resources.py:docstring of aiida.restapi.resources.User:1
msgid "Bases: :py:class:`~aiida.restapi.resources.BaseResource`"
msgstr ""

#: ../../../src/aiida/restapi/resources.py:docstring of aiida.restapi.resources.Computer:1
msgid "Resource for Computer"
msgstr ""

#: ../../../src/aiida/restapi/translator/computer.py:docstring of aiida.restapi.translator.computer.ComputerTranslator:1
#: ../../../src/aiida/restapi/translator/group.py:docstring of aiida.restapi.translator.group.GroupTranslator:1
#: ../../../src/aiida/restapi/translator/nodes/node.py:docstring of aiida.restapi.translator.nodes.node.NodeTranslator:1
#: ../../../src/aiida/restapi/translator/user.py:docstring of aiida.restapi.translator.user.UserTranslator:1
msgid "Bases: :py:class:`~aiida.restapi.translator.base.BaseTranslator`"
msgstr ""

#: ../../../src/aiida/restapi/translator/computer.py:docstring of aiida.restapi.translator.computer.ComputerTranslator:1
msgid "Translator relative to resource 'computers' and aiida class Computer"
msgstr ""

#: ../../../src/aiida/restapi/translator/computer.py:docstring of aiida.restapi.translator.computer.ComputerTranslator.get_projectable_properties:1
msgid "Get projectable properties specific for Computer :return: dict of projectable properties and column_order list"
msgstr ""

#: ../../../src/aiida/restapi/resources.py:docstring of aiida.restapi.resources.Group:1
msgid "Resource for Group"
msgstr ""

#: ../../../src/aiida/restapi/translator/group.py:docstring of aiida.restapi.translator.group.GroupTranslator:1
msgid "Translator relative to resource 'groups' and aiida class Group"
msgstr ""

#: ../../../src/aiida/restapi/translator/group.py:docstring of aiida.restapi.translator.group.GroupTranslator.get_projectable_properties:1
msgid "Get projectable properties specific for Group :return: dict of projectable properties and column_order list"
msgstr ""

#: ../../../src/aiida/restapi/resources.py:docstring of aiida.restapi.resources.Node:1
msgid "Differs from BaseResource in trans.set_query() mostly because it takes query_type as an input and the presence of additional result types like \"tree\""
msgstr ""

#: ../../../src/aiida/restapi/resources.py:docstring of aiida.restapi.resources.Node.get:1
msgid "Get method for the Node resource."
msgstr ""

#: ../../../src/aiida/restapi/resources.py:docstring of aiida.restapi.resources.Node.get:4
msgid "page no, used for pagination"
msgstr ""

#: ../../../src/aiida/restapi/resources.py:docstring of aiida.restapi.resources.ProcessNode:1
msgid "Bases: :py:class:`~aiida.restapi.resources.Node`"
msgstr ""

#: ../../../src/aiida/restapi/resources.py:docstring of aiida.restapi.resources.ProcessNode:1
msgid "Resource for ProcessNode"
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/data/__init__.py:docstring of aiida.restapi.translator.nodes.data.DataTranslator:1
#: ../../../src/aiida/restapi/translator/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator:1
msgid "Bases: :py:class:`~aiida.restapi.translator.nodes.node.NodeTranslator`"
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/data/__init__.py:docstring of aiida.restapi.translator.nodes.data.DataTranslator:1
#: ../../../src/aiida/restapi/translator/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator:1
msgid "Translator relative to resource 'data' and aiida class `~aiida.orm.nodes.data.data.Data`"
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.get_projectable_properties:1
msgid "Get projectable properties specific for Process nodes :return: dict of projectable properties and column_order list"
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process.ProcessTranslator.get_report:1
msgid "Show the log report for one or multiple processes."
msgstr ""

#: ../../../src/aiida/restapi/resources.py:docstring of aiida.restapi.resources.QueryBuilder:1
msgid "Representation of a QueryBuilder REST API resource (instantiated with a serialised QueryBuilder instance)."
msgstr ""

#: ../../../src/aiida/restapi/resources.py:docstring of aiida.restapi.resources.QueryBuilder:3
msgid "It supports POST requests taking in JSON :py:func:`~aiida.orm.querybuilder.QueryBuilder.as_dict` objects and returning the :py:class:`~aiida.orm.querybuilder.QueryBuilder` result accordingly."
msgstr ""

#: ../../../src/aiida/restapi/resources.py:docstring of aiida.restapi.resources.QueryBuilder.get:1
msgid "Static return to state information about this endpoint."
msgstr ""

#: ../../../src/aiida/restapi/resources.py:docstring of aiida.restapi.resources.QueryBuilder.post:1
msgid "POST method to pass query help JSON."
msgstr ""

#: ../../../src/aiida/restapi/resources.py:docstring of aiida.restapi.resources.QueryBuilder.post:3
msgid "If the posted JSON is not a valid QueryBuilder serialisation, the request will fail with an internal server error."
msgstr ""

#: ../../../src/aiida/restapi/resources.py:docstring of aiida.restapi.resources.QueryBuilder.post:6
msgid "This uses the NodeTranslator in order to best return Nodes according to the general AiiDA REST API data format, while still allowing the return of other AiiDA entities."
msgstr ""

#: ../../../src/aiida/restapi/resources.py:docstring of aiida.restapi.resources.QueryBuilder.post:9
msgid "QueryBuilder result of AiiDA entities in \"standard\" REST API format."
msgstr ""

#: ../../../src/aiida/restapi/resources.py:docstring of aiida.restapi.resources.ServerInfo:1
msgid "Endpoint to return general server info"
msgstr ""

#: ../../../src/aiida/restapi/resources.py:docstring of aiida.restapi.resources.ServerInfo.get:1
msgid "It returns the general info about the REST API :return: returns current AiiDA version defined in aiida/__init__.py"
msgstr ""

#: ../../../src/aiida/restapi/resources.py:docstring of aiida.restapi.resources.User:1
msgid "Resource for User"
msgstr ""

#: ../../../src/aiida/restapi/translator/user.py:docstring of aiida.restapi.translator.user.UserTranslator:1
msgid "Translator relative to resource 'users' and aiida class User"
msgstr ""

#: ../../../src/aiida/restapi/translator/user.py:docstring of aiida.restapi.translator.user.UserTranslator.get_projectable_properties:1
msgid "Get projectable properties specific for User :return: dict of projectable properties and column_order list"
msgstr ""

#: ../../../src/aiida/restapi/run_api.py:docstring of aiida.restapi.run_api:1
msgid "It defines the method with all required parameters to run restapi locally."
msgstr ""

#: ../../../src/aiida/restapi/run_api.py:docstring of aiida.restapi.run_api.configure_api:1
msgid "Configures a flask.Flask instance and returns it."
msgstr ""

#: ../../../src/aiida/restapi/run_api.py:docstring of aiida.restapi.run_api.configure_api:3
#: ../../../src/aiida/restapi/run_api.py:docstring of aiida.restapi.run_api.run_api:3
msgid "Class inheriting from flask app class"
msgstr ""

#: ../../../src/aiida/restapi/run_api.py:docstring of aiida.restapi.run_api.configure_api:5
#: ../../../src/aiida/restapi/run_api.py:docstring of aiida.restapi.run_api.run_api:5
msgid "flask_restful API class to be used to wrap the app"
msgstr ""

#: ../../../src/aiida/restapi/run_api.py:docstring of aiida.restapi.run_api.configure_api:7
msgid "directory containing the config.py configuration file"
msgstr ""

#: ../../../src/aiida/restapi/run_api.py:docstring of aiida.restapi.run_api.configure_api:8
msgid "If true, catch and print internal server errors with full python traceback. Useful during app development."
msgstr ""

#: ../../../src/aiida/restapi/run_api.py:docstring of aiida.restapi.run_api.configure_api:10
msgid "use WSGI profiler middleware for finding bottlenecks in the web application"
msgstr ""

#: ../../../src/aiida/restapi/run_api.py:docstring of aiida.restapi.run_api.configure_api:11
#: ../../../src/aiida/restapi/run_api.py:docstring of aiida.restapi.run_api.run_api:13
msgid "Whether or not to include POST-enabled endpoints (currently only `/querybuilder`)."
msgstr ""

#: ../../../src/aiida/restapi/run_api.py:docstring of aiida.restapi.run_api.configure_api:13
msgid "Flask RESTful API"
msgstr ""

#: ../../../src/aiida/restapi/run_api.py:docstring of aiida.restapi.run_api.configure_api:14
msgid ":py:class:`flask_restful.Api`"
msgstr ""

#: ../../../src/aiida/restapi/run_api.py:docstring of aiida.restapi.run_api.run_api:1
msgid "Takes a flask.Flask instance and runs it."
msgstr ""

#: ../../../src/aiida/restapi/run_api.py:docstring of aiida.restapi.run_api.run_api:7
msgid "hostname to run app on (only when using built-in server)"
msgstr ""

#: ../../../src/aiida/restapi/run_api.py:docstring of aiida.restapi.run_api.run_api:8
msgid "port to run app on (only when using built-in server)"
msgstr ""

#: ../../../src/aiida/restapi/run_api.py:docstring of aiida.restapi.run_api.run_api:9
msgid "directory containing the config.py file used to configure the RESTapi"
msgstr ""

#: ../../../src/aiida/restapi/run_api.py:docstring of aiida.restapi.run_api.run_api:10
msgid "If true, catch and print all inter server errors"
msgstr ""

#: ../../../src/aiida/restapi/run_api.py:docstring of aiida.restapi.run_api.run_api:11
msgid "enable debugging"
msgstr ""

#: ../../../src/aiida/restapi/run_api.py:docstring of aiida.restapi.run_api.run_api:12
msgid "use WSGI profiler middleware for finding bottlenecks in web application"
msgstr ""

#: ../../../src/aiida/restapi/run_api.py:docstring of aiida.restapi.run_api.run_api:15
msgid "tuple (app, api) if hookup==False or runs app if hookup==True"
msgstr ""

#: ../../source/reference/apidoc/aiida.restapi.common.rst:2
msgid "aiida.restapi.common package"
msgstr ""

#: ../../../src/aiida/restapi/common/config.py:docstring of aiida.restapi.common.config:1
msgid "Default configuration for the REST API"
msgstr ""

#: ../../../src/aiida/restapi/common/exceptions.py:docstring of aiida.restapi.common.exceptions:1
msgid "This file contains the exceptions that are raised by the RESTapi at the highest level, namely that of the interaction with the client. Their specificity resides into the fact that they return a message that is embedded into the HTTP response."
msgstr ""

#: ../../../src/aiida/restapi/common/exceptions.py:docstring of aiida.restapi.common.exceptions:7
msgid "Example:"
msgstr ""

#: ../../../src/aiida/restapi/common/exceptions.py:docstring of aiida.restapi.common.exceptions:8
msgid ".../api/v1/nodes/ ... (TODO compete this with an actual example)"
msgstr ""

#: ../../../src/aiida/restapi/common/exceptions.py:docstring of aiida.restapi.common.exceptions:10
msgid "Other errors arising at deeper level, e.g. those raised by the QueryBuilder or internal errors, are not embedded into the HTTP response."
msgstr ""

#: ../../../src/aiida/restapi/common/exceptions.py:docstring of aiida.restapi.common.exceptions.RestFeatureNotAvailable:1
msgid "Bases: :py:class:`~aiida.common.exceptions.FeatureNotAvailable`"
msgstr ""

#: ../../../src/aiida/restapi/common/exceptions.py:docstring of aiida.restapi.common.exceptions.RestFeatureNotAvailable:1
msgid "If endpoint is not emplemented for given node type"
msgstr ""

#: ../../../src/aiida/restapi/common/exceptions.py:docstring of aiida.restapi.common.exceptions.RestInputValidationError:1
msgid "Bases: :py:class:`~aiida.common.exceptions.InputValidationError`"
msgstr ""

#: ../../../src/aiida/restapi/common/exceptions.py:docstring of aiida.restapi.common.exceptions.RestInputValidationError:1
msgid "If inputs passed in query strings are wrong"
msgstr ""

#: ../../../src/aiida/restapi/common/exceptions.py:docstring of aiida.restapi.common.exceptions.RestValidationError:1
msgid "If validation error in code."
msgstr ""

#: ../../../src/aiida/restapi/common/exceptions.py:docstring of aiida.restapi.common.exceptions.RestValidationError:3
msgid "E.g. more than one node available for given uuid"
msgstr ""

#: ../../../src/aiida/restapi/common/identifiers.py:docstring of aiida.restapi.common.identifiers:1
msgid "Utility functions to work with node \"full types\" which are unique node identifiers."
msgstr ""

#: ../../../src/aiida/restapi/common/identifiers.py:docstring of aiida.restapi.common.identifiers:3
msgid "A node's `full_type` is defined as a string that uniquely defines the node type. A valid `full_type` is constructed by concatenating the `node_type` and `process_type` of a node with the `FULL_TYPE_CONCATENATOR`. Each segment of the full type can optionally be terminated by a single `LIKE_OPERATOR_CHARACTER` to indicate that the `node_type` or `process_type` should start with that value but can be followed by any amount of other characters. A full type is invalid if it does not contain exactly one `FULL_TYPE_CONCATENATOR` character. Additionally, each segment can contain at most one occurrence of the `LIKE_OPERATOR_CHARACTER` and it has to be at the end of the segment."
msgstr ""

#: ../../../src/aiida/restapi/common/identifiers.py:docstring of aiida.restapi.common.identifiers:10
msgid "Examples of valid full types:"
msgstr ""

#: ../../../src/aiida/restapi/common/identifiers.py:docstring of aiida.restapi.common.identifiers:12
msgid "'data.bool.Bool.|' 'process.calculation.calcfunction.%|%' 'process.calculation.calcjob.CalcJobNode.|aiida.calculations:arithmetic.add' 'process.calculation.calcfunction.CalcFunctionNode.|aiida.workflows:codtools.primitive_structure_from_cif'"
msgstr ""

#: ../../../src/aiida/restapi/common/identifiers.py:docstring of aiida.restapi.common.identifiers:17
msgid "Examples of invalid full types:"
msgstr ""

#: ../../../src/aiida/restapi/common/identifiers.py:docstring of aiida.restapi.common.identifiers:19
msgid "'data.bool'  # Only a single segment without concatenator 'data.|bool.Bool.|process.'  # More than one concatenator 'process.calculation%.calcfunction.|aiida.calculations:arithmetic.add'  # Like operator not at end of segment 'process.calculation%.calcfunction.%|aiida.calculations:arithmetic.add'  # More than one operator in segment"
msgstr ""

#: ../../../src/aiida/restapi/common/identifiers.py:docstring of aiida.restapi.common.identifiers.Namespace:1
msgid "Namespace that can be used to map the node class hierarchy."
msgstr ""

#: ../../../src/aiida/restapi/common/identifiers.py:docstring of aiida.restapi.common.identifiers.Namespace.__init__:1
msgid "Construct a new node class namespace."
msgstr ""

#: ../../../src/aiida/restapi/common/identifiers.py:docstring of aiida.restapi.common.identifiers.Namespace._infer_full_type:1
msgid "Infer the full type based on the current namespace path and the given full type of the leaf."
msgstr ""

#: ../../../src/aiida/restapi/common/identifiers.py:docstring of aiida.restapi.common.identifiers.Namespace.create_namespace:1
msgid "Create and return a new `Namespace` in this `Namespace`."
msgstr ""

#: ../../../src/aiida/restapi/common/identifiers.py:docstring of aiida.restapi.common.identifiers.Namespace.create_namespace:3
msgid "If the name is namespaced, the sub `Namespaces` will be created recursively, except if one of the namespaces is already occupied at any level by a Port in which case a ValueError will be thrown"
msgstr ""

#: ../../../src/aiida/restapi/common/identifiers.py:docstring of aiida.restapi.common.identifiers.Namespace.create_namespace:6
msgid "name (potentially namespaced) of the port to create and return"
msgstr ""

#: ../../../src/aiida/restapi/common/identifiers.py:docstring of aiida.restapi.common.identifiers.Namespace.create_namespace:7
msgid "constructor arguments that will be used *only* for the construction of the terminal Namespace"
msgstr ""

#: ../../../src/aiida/restapi/common/identifiers.py:docstring of aiida.restapi.common.identifiers.Namespace.create_namespace:8
msgid "Namespace"
msgstr ""

#: ../../../src/aiida/restapi/common/identifiers.py:docstring of aiida.restapi.common.identifiers.Namespace.create_namespace:9
msgid "ValueError if any sub namespace is occupied by a non-Namespace port"
msgstr ""

#: ../../../src/aiida/restapi/common/identifiers.py:docstring of aiida.restapi.common.identifiers.Namespace.get_description:1
msgid "Return a dictionary with a description of the ports this namespace contains."
msgstr ""

#: ../../../src/aiida/restapi/common/identifiers.py:docstring of aiida.restapi.common.identifiers.Namespace.get_description:3
msgid "Nested PortNamespaces will be properly recursed and Ports will print their properties in a list"
msgstr ""

#: ../../../src/aiida/restapi/common/identifiers.py:docstring of aiida.restapi.common.identifiers.Namespace.get_description:5
msgid "a dictionary of descriptions of the Ports contained within this PortNamespace"
msgstr ""

#: ../../../src/aiida/restapi/common/identifiers.py:docstring of aiida.restapi.common.identifiers.construct_full_type:1
msgid "Return the full type, which uniquely identifies any `Node` with the given `node_type` and `process_type`."
msgstr ""

#: ../../../src/aiida/restapi/common/identifiers.py:docstring of aiida.restapi.common.identifiers.construct_full_type:3
msgid "the `node_type` of the `Node`"
msgstr ""

#: ../../../src/aiida/restapi/common/identifiers.py:docstring of aiida.restapi.common.identifiers.construct_full_type:4
msgid "the `process_type` of the `Node`"
msgstr ""

#: ../../../src/aiida/restapi/common/identifiers.py:docstring of aiida.restapi.common.identifiers.construct_full_type:5
msgid "the full type, which is a unique identifier"
msgstr ""

#: ../../../src/aiida/restapi/common/identifiers.py:docstring of aiida.restapi.common.identifiers.get_full_type_filters:1
msgid "Return the `QueryBuilder` filters that will return all `Nodes` identified by the given `full_type`."
msgstr ""

#: ../../../src/aiida/restapi/common/identifiers.py:docstring of aiida.restapi.common.identifiers.get_full_type_filters:3
#: ../../../src/aiida/restapi/common/identifiers.py:docstring of aiida.restapi.common.identifiers.load_entry_point_from_full_type:3
msgid "the `full_type` unique node identifier"
msgstr ""

#: ../../../src/aiida/restapi/common/identifiers.py:docstring of aiida.restapi.common.identifiers.get_full_type_filters:4
msgid "dictionary of filters to be passed for the `filters` keyword in `QueryBuilder.append`"
msgstr ""

#: ../../../src/aiida/restapi/common/identifiers.py:docstring of aiida.restapi.common.identifiers.get_full_type_filters:5
#: ../../../src/aiida/restapi/common/identifiers.py:docstring of aiida.restapi.common.identifiers.load_entry_point_from_full_type:4
#: ../../../src/aiida/restapi/common/identifiers.py:docstring of aiida.restapi.common.identifiers.validate_full_type:4
msgid "if the `full_type` is invalid"
msgstr ""

#: ../../../src/aiida/restapi/common/identifiers.py:docstring of aiida.restapi.common.identifiers.get_full_type_filters:6
#: ../../../src/aiida/restapi/common/identifiers.py:docstring of aiida.restapi.common.identifiers.load_entry_point_from_full_type:5
#: ../../../src/aiida/restapi/common/identifiers.py:docstring of aiida.restapi.common.identifiers.validate_full_type:5
msgid "if the `full_type` is not a string type"
msgstr ""

#: ../../../src/aiida/restapi/common/identifiers.py:docstring of aiida.restapi.common.identifiers.get_node_namespace:1
msgid "Return the full namespace of all available nodes in the current database."
msgstr ""

#: ../../../src/aiida/restapi/common/identifiers.py:docstring of aiida.restapi.common.identifiers.get_node_namespace:3
msgid "complete node `Namespace`"
msgstr ""

#: ../../../src/aiida/restapi/common/identifiers.py:docstring of aiida.restapi.common.identifiers.load_entry_point_from_full_type:1
msgid "Return the loaded entry point for the given `full_type` unique node identifier."
msgstr ""

#: ../../../src/aiida/restapi/common/identifiers.py:docstring of aiida.restapi.common.identifiers.load_entry_point_from_full_type:6
msgid "if the corresponding entry point cannot be loaded"
msgstr ""

#: ../../../src/aiida/restapi/common/identifiers.py:docstring of aiida.restapi.common.identifiers.validate_full_type:1
msgid "Validate that the `full_type` is a valid full type unique node identifier."
msgstr ""

#: ../../../src/aiida/restapi/common/identifiers.py:docstring of aiida.restapi.common.identifiers.validate_full_type:3
msgid "a `Node` full type"
msgstr ""

#: ../../../src/aiida/restapi/common/utils.py:docstring of aiida.restapi.common.utils:1
msgid "Util methods"
msgstr ""

#: ../../../src/aiida/restapi/common/utils.py:docstring of aiida.restapi.common.utils.CustomJSONProvider:1
msgid "Bases: :py:class:`~flask.json.provider.DefaultJSONProvider`"
msgstr ""

#: ../../../src/aiida/restapi/common/utils.py:docstring of aiida.restapi.common.utils.CustomJSONProvider:1
msgid "Custom json encoder for serialization. This has to be provided to the Flask app in order to replace the default encoder."
msgstr ""

#: ../../../src/aiida/restapi/common/utils.py:docstring of aiida.restapi.common.utils.CustomJSONProvider.default:1
msgid "Override serialization of ``DefaultJSONProvider`` for ``datetime`` and ``bytes`` objects."
msgstr ""

#: ../../../src/aiida/restapi/common/utils.py:docstring of aiida.restapi.common.utils.CustomJSONProvider.default:3
msgid "Object e.g. dict, list that will be serialized."
msgstr ""

#: ../../../src/aiida/restapi/common/utils.py:docstring of aiida.restapi.common.utils.CustomJSONProvider.default:4
msgid "Serialized object as a string."
msgstr ""

#: ../../../src/aiida/restapi/common/utils.py:docstring of aiida.restapi.common.utils.Utils:1
msgid "A class that gathers all the utility functions for parsing URI, validating request, pass it to the translator, and building HTTP response"
msgstr ""

#: ../../../src/aiida/restapi/common/utils.py:docstring of aiida.restapi.common.utils.Utils:4
msgid "An istance of Utils has to be included in the api class so that the configuration parameters used to build the api are automatically accessible by the methods of Utils without the need to import them from the config.py file."
msgstr ""

#: ../../../src/aiida/restapi/common/utils.py:docstring of aiida.restapi.common.utils.Utils.__init__:1
msgid "Sets internally the configuration parameters"
msgstr ""

#: ../../../src/aiida/restapi/common/utils.py:docstring of aiida.restapi.common.utils.Utils.build_datetime_filter:1
msgid "This function constructs a filter for a datetime object to be in a certain datetime interval according to the precision."
msgstr ""

#: ../../../src/aiida/restapi/common/utils.py:docstring of aiida.restapi.common.utils.Utils.build_datetime_filter:4
msgid "The interval is [reference_datetime, reference_datetime + delta_time], where delta_time is a function fo the required precision."
msgstr ""

#: ../../../src/aiida/restapi/common/utils.py:docstring of aiida.restapi.common.utils.Utils.build_datetime_filter:7
msgid "This function should be used to replace a datetime filter based on the equality operator that is inehrently \"picky\" because it implies matching two datetime objects down to the microsecond or something, by a \"tolerant\" operator which checks whether the datetime is in an interval."
msgstr ""

#: ../../../src/aiida/restapi/common/utils.py:docstring of aiida.restapi.common.utils.Utils.build_datetime_filter:13
msgid "a suitable entry of the filter dictionary"
msgstr ""

#: ../../../src/aiida/restapi/common/utils.py:docstring of aiida.restapi.common.utils.Utils.build_headers:1
msgid "Construct the header dictionary for an HTTP response. It includes related pages, total count of results (before pagination)."
msgstr ""

#: ../../../src/aiida/restapi/common/utils.py:docstring of aiida.restapi.common.utils.Utils.build_headers:4
msgid "a dictionary defining related pages (first, prev, next, last)"
msgstr ""

#: ../../../src/aiida/restapi/common/utils.py:docstring of aiida.restapi.common.utils.Utils.build_headers:5
msgid "(string) the full url, i.e. the url that the client uses to get Rest resources"
msgstr ""

#: ../../../src/aiida/restapi/common/utils.py:docstring of aiida.restapi.common.utils.Utils.build_response:1
msgid "Build the response"
msgstr ""

#: ../../../src/aiida/restapi/common/utils.py:docstring of aiida.restapi.common.utils.Utils.build_response:3
msgid "status of the response, e.g. 200=OK, 400=bad request"
msgstr ""

#: ../../../src/aiida/restapi/common/utils.py:docstring of aiida.restapi.common.utils.Utils.build_response:4
msgid "dictionary for additional header k,v pairs, e.g. X-total-count=<number of rows resulting from query>"
msgstr ""

#: ../../../src/aiida/restapi/common/utils.py:docstring of aiida.restapi.common.utils.Utils.build_response:6
msgid "a dictionary with the data returned by the Resource"
msgstr ""

#: ../../../src/aiida/restapi/common/utils.py:docstring of aiida.restapi.common.utils.Utils.build_response:8
msgid "a Flask response object"
msgstr ""

#: ../../../src/aiida/restapi/common/utils.py:docstring of aiida.restapi.common.utils.Utils.build_translator_parameters:1
msgid "Takes a list of elements resulting from the parsing the query_string and elaborates them in order to provide translator-compliant instructions"
msgstr ""

#: ../../../src/aiida/restapi/common/utils.py:docstring of aiida.restapi.common.utils.Utils.build_translator_parameters:4
msgid "a (nested) list of elements resulting from parsing the query_string"
msgstr ""

#: ../../../src/aiida/restapi/common/utils.py:docstring of aiida.restapi.common.utils.Utils.build_translator_parameters:5
msgid "the filters in the"
msgstr ""

#: ../../../src/aiida/restapi/common/utils.py:docstring of aiida.restapi.common.utils.Utils.paginate:1
msgid "Calculates limit and offset for the reults of a query, given the page and the number of restuls per page. Moreover, calculates the last available page and raises an exception if the required page exceeds that limit. If number of rows==0, only page 1 exists :param page: integer number of the page that has to be viewed :param perpage: integer defining how many results a page contains :param total_count: the total number of rows retrieved by the query :return: integers: limit, offset, rel_pages"
msgstr ""

#: ../../../src/aiida/restapi/common/utils.py:docstring of aiida.restapi.common.utils.Utils.parse_path:1
msgid "Takes the path and parse it checking its validity. Does not parse \"io\", \"content\" fields. I do not check the validity of the path, since I assume that this is done by the Flask routing methods."
msgstr ""

#: ../../../src/aiida/restapi/common/utils.py:docstring of aiida.restapi.common.utils.Utils.parse_path:5
msgid "the path string"
msgstr ""

#: ../../../src/aiida/restapi/common/utils.py:docstring of aiida.restapi.common.utils.Utils.parse_path:6
msgid "if 'pk' ('uuid') expects an integer (uuid starting pattern)"
msgstr ""

#: ../../../src/aiida/restapi/common/utils.py:docstring of aiida.restapi.common.utils.Utils.parse_path:7
msgid "resource_type (string) page (integer) node_id (string: uuid starting pattern, int: pk) query_type (string))"
msgstr ""

#: ../../../src/aiida/restapi/common/utils.py:docstring of aiida.restapi.common.utils.Utils.parse_query_string:1
msgid "Function that parse the querystring, extracting infos for limit, offset, ordering, filters, attribute and extra projections. :param query_string (as obtained from request.query_string) :return: parsed values for the querykeys"
msgstr ""

#: ../../../src/aiida/restapi/common/utils.py:docstring of aiida.restapi.common.utils.Utils.split_path:1
msgid "entire path contained in flask request"
msgstr ""

#: ../../../src/aiida/restapi/common/utils.py:docstring of aiida.restapi.common.utils.Utils.split_path:2
msgid "list of each element separated by '/'"
msgstr ""

#: ../../../src/aiida/restapi/common/utils.py:docstring of aiida.restapi.common.utils.Utils.strip_api_prefix:1
msgid "Removes the PREFIX from an URL path. PREFIX must be defined in the config.py file::"
msgstr ""

#: ../../../src/aiida/restapi/common/utils.py:docstring of aiida.restapi.common.utils.Utils.strip_api_prefix:8
msgid "the URL path string"
msgstr ""

#: ../../../src/aiida/restapi/common/utils.py:docstring of aiida.restapi.common.utils.Utils.strip_api_prefix:9
msgid "the same URL without the prefix"
msgstr ""

#: ../../../src/aiida/restapi/common/utils.py:docstring of aiida.restapi.common.utils.Utils.validate_request:1
msgid "Performs various checks on the consistency of the request. Add here all the checks that you want to do, except validity of the page number that is done in paginate(). Future additional checks must be added here"
msgstr ""

#: ../../../src/aiida/restapi/common/utils.py:docstring of aiida.restapi.common.utils.close_thread_connection:1
msgid "Close the profile's storage connection, for the current thread."
msgstr ""

#: ../../../src/aiida/restapi/common/utils.py:docstring of aiida.restapi.common.utils.close_thread_connection:3
msgid "This decorator can be used for router endpoints. It is needed due to the server running in threaded mode, i.e., creating a new thread for each incoming request, and leaving connections unreleased."
msgstr ""

#: ../../../src/aiida/restapi/common/utils.py:docstring of aiida.restapi.common.utils.close_thread_connection:7
msgid "Note, this is currently hard-coded to the `PsqlDosBackend` storage backend."
msgstr ""

#: ../../../src/aiida/restapi/common/utils.py:docstring of aiida.restapi.common.utils.list_routes:1
msgid "List available routes"
msgstr ""

#: ../../source/reference/apidoc/aiida.restapi.translator.rst:2
msgid "aiida.restapi.translator package"
msgstr ""

#: ../../../src/aiida/restapi/translator/base.py:docstring of aiida.restapi.translator.base:1
msgid "Base translator class"
msgstr ""

#: ../../../src/aiida/restapi/translator/computer.py:docstring of aiida.restapi.translator.computer:1
msgid "Translator for computer"
msgstr ""

#: ../../../src/aiida/restapi/translator/group.py:docstring of aiida.restapi.translator.group:1
msgid "Translator for group"
msgstr ""

#: ../../../src/aiida/restapi/translator/user.py:docstring of aiida.restapi.translator.user:1
msgid "Translator for user"
msgstr ""

#: ../../source/reference/apidoc/aiida.restapi.translator.nodes.rst:2
msgid "aiida.restapi.translator.nodes package"
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/node.py:docstring of aiida.restapi.translator.nodes.node:1
msgid "Translator for node"
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/node.py:docstring of aiida.restapi.translator.nodes.node.NodeTranslator:1
msgid "Translator relative to resource 'nodes' and aiida class Node"
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/node.py:docstring of aiida.restapi.translator.nodes.node.NodeTranslator._get_content:1
msgid "Used by get_results() in case of endpoint include \"content\" option :return: data: a dictionary containing the results obtained by running the query"
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/node.py:docstring of aiida.restapi.translator.nodes.node.NodeTranslator._get_subclasses:1
msgid "Import all submodules of the package containing the present class. Includes subpackages recursively, if specified."
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/node.py:docstring of aiida.restapi.translator.nodes.node.NodeTranslator._get_subclasses:4
msgid "package/class. If package looks for the classes in submodules. If class, first looks for the package where it is contained"
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/node.py:docstring of aiida.restapi.translator.nodes.node.NodeTranslator._get_subclasses:7
msgid "class of which to look for subclasses"
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/node.py:docstring of aiida.restapi.translator.nodes.node.NodeTranslator._get_subclasses:8
msgid "True/False (go recursively into submodules)"
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/node.py:docstring of aiida.restapi.translator.nodes.node.NodeTranslator.get_all_download_formats:1
msgid "Returns dict of possible node formats for all available node types"
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/node.py:docstring of aiida.restapi.translator.nodes.node.NodeTranslator.get_comments:2
msgid "node comments"
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/node.py:docstring of aiida.restapi.translator.nodes.node.NodeTranslator.get_derived_properties:1
msgid "Generic function to get the derived properties of the node. Actual definition is in child classes as the content to be returned depends on the plugin specific to the resource"
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/node.py:docstring of aiida.restapi.translator.nodes.node.NodeTranslator.get_derived_properties:6
msgid "node object that has to be visualized"
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/node.py:docstring of aiida.restapi.translator.nodes.node.NodeTranslator.get_derived_properties:7
msgid "derived properties of the node"
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/node.py:docstring of aiida.restapi.translator.nodes.node.NodeTranslator.get_derived_properties:9
msgid "If this method is called by Node resource it will look for the type of object and invoke the correct method in the lowest-compatible subclass"
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/node.py:docstring of aiida.restapi.translator.nodes.node.NodeTranslator.get_downloadable_data:1
msgid "Generic function to download file in specified format. Actual definition is in child classes as the content to be returned and its format depends on the download plugin specific to the resource"
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/node.py:docstring of aiida.restapi.translator.nodes.node.NodeTranslator.get_downloadable_data:7
msgid "file extension format"
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/node.py:docstring of aiida.restapi.translator.nodes.node.NodeTranslator.get_downloadable_data:8
msgid "data in selected format to download"
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/node.py:docstring of aiida.restapi.translator.nodes.node.NodeTranslator.get_downloadable_data:10
msgid "If this method is called for a Data node resource it will invoke the get_downloadable_data method in the Data transaltor. Otherwise it raises RestFeatureNotAvailable exception"
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/node.py:docstring of aiida.restapi.translator.nodes.node.NodeTranslator.get_file_content:1
msgid "It reads the file from directory and returns its content."
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/node.py:docstring of aiida.restapi.translator.nodes.node.NodeTranslator.get_file_content:3
msgid "Instead of using \"send_from_directory\" from flask, this method is written because in next aiida releases the file can be stored locally or in object storage."
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/node.py:docstring of aiida.restapi.translator.nodes.node.NodeTranslator.get_file_content:6
msgid "aiida folderData node which contains file"
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/node.py:docstring of aiida.restapi.translator.nodes.node.NodeTranslator.get_file_content:7
msgid "name of the file to return its contents"
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/node.py:docstring of aiida.restapi.translator.nodes.node.NodeTranslator.get_io_tree:1
msgid "Json data to display nodes in tree format :param uuid_pattern: main node uuid :return: json data to display node tree"
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/node.py:docstring of aiida.restapi.translator.nodes.node.NodeTranslator.get_namespace:1
msgid "Return full_types of the nodes"
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/node.py:docstring of aiida.restapi.translator.nodes.node.NodeTranslator.get_projectable_properties:1
msgid "Get projectable properties specific for Node :return: dict of projectable properties and column_order list"
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/node.py:docstring of aiida.restapi.translator.nodes.node.NodeTranslator.get_repo_contents:1
msgid "Every node in AiiDA is having repo folder. This function returns the metadata using get_object() method :param node: node object :param filename: folder or file name (optional) :return: file content in bytes to download"
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/node.py:docstring of aiida.restapi.translator.nodes.node.NodeTranslator.get_repo_list:1
msgid "Every node in AiiDA is having repo folder. This function returns the metadata using list_objects() method :param node: node object :param filename: folder name (optional) :return: folder list"
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/node.py:docstring of aiida.restapi.translator.nodes.node.NodeTranslator.get_results:1
msgid "Returns either a list of nodes or details of single node from database"
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/node.py:docstring of aiida.restapi.translator.nodes.node.NodeTranslator.get_results:3
msgid "either a list of nodes or the details of single node from the database"
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/node.py:docstring of aiida.restapi.translator.nodes.node.NodeTranslator.get_statistics:1
msgid "Return statistics for a given node"
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/node.py:docstring of aiida.restapi.translator.nodes.node.NodeTranslator.set_query:10
msgid "file format to download e.g. cif, xyz"
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/node.py:docstring of aiida.restapi.translator.nodes.node.NodeTranslator.set_query:12
msgid "flag to show attributes for nodes"
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/node.py:docstring of aiida.restapi.translator.nodes.node.NodeTranslator.set_query:13
msgid "list of attributes to query"
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/node.py:docstring of aiida.restapi.translator.nodes.node.NodeTranslator.set_query:14
msgid "flag to show extras for nodes"
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/node.py:docstring of aiida.restapi.translator.nodes.node.NodeTranslator.set_query:15
msgid "list of extras to query"
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/node.py:docstring of aiida.restapi.translator.nodes.node.NodeTranslator.set_query_type:1
msgid "Sets one of the mutually exclusive values for self._result_type and self._content_type."
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/node.py:docstring of aiida.restapi.translator.nodes.node.NodeTranslator.set_query_type:4
msgid ":param query_type:(string) the value assigned to either variable."
msgstr ""

#: ../../source/reference/apidoc/aiida.restapi.translator.nodes.data.rst:2
msgid "aiida.restapi.translator.nodes.data package"
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/data/__init__.py:docstring of aiida.restapi.translator.nodes.data:1
msgid "Translator for data node"
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/data/__init__.py:docstring of aiida.restapi.translator.nodes.data.DataTranslator.get_downloadable_data:1
msgid "Return content in the specified format for download"
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/data/__init__.py:docstring of aiida.restapi.translator.nodes.data.DataTranslator.get_downloadable_data:3
msgid "node representing cif file to be downloaded"
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/data/__init__.py:docstring of aiida.restapi.translator.nodes.data.DataTranslator.get_downloadable_data:4
msgid "export format"
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/data/__init__.py:docstring of aiida.restapi.translator.nodes.data.DataTranslator.get_downloadable_data:5
msgid "content of the node in the specified format for download"
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/data/cif.py:docstring of aiida.restapi.translator.nodes.data.cif:1
msgid "Translator for CifData"
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/data/array/bands.py:docstring of aiida.restapi.translator.nodes.data.array.bands.BandsDataTranslator:1
#: ../../../src/aiida/restapi/translator/nodes/data/cif.py:docstring of aiida.restapi.translator.nodes.data.cif.CifDataTranslator:1
#: ../../../src/aiida/restapi/translator/nodes/data/code.py:docstring of aiida.restapi.translator.nodes.data.code.CodeTranslator:1
#: ../../../src/aiida/restapi/translator/nodes/data/kpoints.py:docstring of aiida.restapi.translator.nodes.data.kpoints.KpointsDataTranslator:1
#: ../../../src/aiida/restapi/translator/nodes/data/structure.py:docstring of aiida.restapi.translator.nodes.data.structure.StructureDataTranslator:1
#: ../../../src/aiida/restapi/translator/nodes/data/upf.py:docstring of aiida.restapi.translator.nodes.data.upf.UpfDataTranslator:1
msgid "Bases: :py:class:`~aiida.restapi.translator.nodes.data.DataTranslator`"
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/data/cif.py:docstring of aiida.restapi.translator.nodes.data.cif.CifDataTranslator:1
msgid "Translator relative to resource 'structures' and aiida class CifData"
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/data/cif.py:docstring of aiida.restapi.translator.nodes.data.cif.CifDataTranslator.get_derived_properties:1
msgid "Generic function extended for cif. Currently it is not implemented."
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/data/code.py:docstring of aiida.restapi.translator.nodes.data.code:1
msgid "Translator for code"
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/data/code.py:docstring of aiida.restapi.translator.nodes.data.code.CodeTranslator:1
msgid "Translator relative to resource 'codes' and aiida class Code"
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/data/code.py:docstring of aiida.restapi.translator.nodes.data.code.CodeTranslator.get_derived_properties:1
msgid "Generic function extended for codes data. Currently it is not implemented."
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/data/kpoints.py:docstring of aiida.restapi.translator.nodes.data.kpoints:1
msgid "Translator for kpoints data"
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/data/kpoints.py:docstring of aiida.restapi.translator.nodes.data.kpoints.KpointsDataTranslator:1
msgid "Translator relative to resource 'kpoints' and aiida class KpointsData"
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/data/array/bands.py:docstring of aiida.restapi.translator.nodes.data.array.bands.BandsDataTranslator.get_derived_properties:1
#: ../../../src/aiida/restapi/translator/nodes/data/kpoints.py:docstring of aiida.restapi.translator.nodes.data.kpoints.KpointsDataTranslator.get_derived_properties:1
msgid "Returns: data in a format required by dr.js to visualize a 2D plot with multiple data series."
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/data/kpoints.py:docstring of aiida.restapi.translator.nodes.data.kpoints.KpointsDataTranslator.get_derived_properties:4
msgid "Strategy: For the time being rely on the function implemented in seekpath to calculate brillouin zone faces, and triangulate them. The other fields of the response are retrieved by ordinary kpointsdata methods, except the logic to create a list of explicit keypoints from the mesh and the cell vectors."
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/data/structure.py:docstring of aiida.restapi.translator.nodes.data.structure:1
msgid "Translator for structure data"
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/data/structure.py:docstring of aiida.restapi.translator.nodes.data.structure.StructureDataTranslator:1
msgid "Translator relative to resource 'structures' and aiida class StructureData"
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/data/structure.py:docstring of aiida.restapi.translator.nodes.data.structure.StructureDataTranslator.get_derived_properties:1
msgid "Returns: derived properties of the structure."
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/data/upf.py:docstring of aiida.restapi.translator.nodes.data.upf:1
msgid "Translator for upf data"
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/data/upf.py:docstring of aiida.restapi.translator.nodes.data.upf.UpfDataTranslator:1
msgid "Translator relative to resource 'upfs' and aiida class UpfData"
msgstr ""

#: ../../source/reference/apidoc/aiida.restapi.translator.nodes.data.array.rst:2
msgid "aiida.restapi.translator.nodes.data.array package"
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/data/array/bands.py:docstring of aiida.restapi.translator.nodes.data.array.bands:1
msgid "Translator for bands data"
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/data/array/bands.py:docstring of aiida.restapi.translator.nodes.data.array.bands.BandsDataTranslator:1
msgid "Translator relative to resource 'bands' and aiida class BandsData"
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/data/array/bands.py:docstring of aiida.restapi.translator.nodes.data.array.bands.BandsDataTranslator.get_derived_properties:4
msgid "Strategy: I take advantage of the export functionality of BandsData objects. The raw export has to be filtered for string escape characters. this is done by decoding the string returned by node._exportcontent."
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/data/array/bands.py:docstring of aiida.restapi.translator.nodes.data.array.bands.BandsDataTranslator.get_derived_properties:8
msgid "TODO: modify the function exportstring (or add another function in BandsData) so that it returns a python object rather than a string."
msgstr ""

#: ../../source/reference/apidoc/aiida.restapi.translator.nodes.process.rst:2
msgid "aiida.restapi.translator.nodes.process package"
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/process/process.py:docstring of aiida.restapi.translator.nodes.process.process:1
msgid "Translator for process node"
msgstr ""

#: ../../source/reference/apidoc/aiida.restapi.translator.nodes.process.calculation.rst:2
msgid "aiida.restapi.translator.nodes.process.calculation package"
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/process/calculation/calcfunction.py:docstring of aiida.restapi.translator.nodes.process.calculation.calcfunction:1
msgid "Translator for calcfunction node"
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/process/calculation/calcfunction.py:docstring of aiida.restapi.translator.nodes.process.calculation.calcfunction.CalcFunctionTranslator:1
#: ../../../src/aiida/restapi/translator/nodes/process/workflow/workfunction.py:docstring of aiida.restapi.translator.nodes.process.workflow.workfunction.WorkFunctionTranslator:1
msgid "Translator relative to resource 'calcfunction' and aiida class Calculation"
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/process/calculation/calcfunction.py:docstring of aiida.restapi.translator.nodes.process.calculation.calcfunction.CalcFunctionTranslator.get_derived_properties:1
msgid "Generic function extended for calcfunction. Currently it is not implemented."
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/process/calculation/calcjob.py:docstring of aiida.restapi.translator.nodes.process.calculation.calcjob:1
msgid "Translator for calcjob node"
msgstr ""

#: ../../source/reference/apidoc/aiida.restapi.translator.nodes.process.workflow.rst:2
msgid "aiida.restapi.translator.nodes.process.workflow package"
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/process/workflow/workchain.py:docstring of aiida.restapi.translator.nodes.process.workflow.workchain:1
msgid "Translator for workchain node"
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/process/workflow/workchain.py:docstring of aiida.restapi.translator.nodes.process.workflow.workchain.WorkChainTranslator:1
msgid "Translator relative to resource 'workchain' and aiida class Process"
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/process/workflow/workchain.py:docstring of aiida.restapi.translator.nodes.process.workflow.workchain.WorkChainTranslator.get_derived_properties:1
msgid "Generic function extended for workchain. Currently it is not implemented."
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/process/workflow/workfunction.py:docstring of aiida.restapi.translator.nodes.process.workflow.workfunction:1
msgid "Translator for workfunction node"
msgstr ""

#: ../../../src/aiida/restapi/translator/nodes/process/workflow/workfunction.py:docstring of aiida.restapi.translator.nodes.process.workflow.workfunction.WorkFunctionTranslator.get_derived_properties:1
msgid "Generic function extended for workfunction. Currently it is not implemented."
msgstr ""

#: ../../source/reference/apidoc/aiida.schedulers.rst:2
msgid "aiida.schedulers package"
msgstr ""

#: ../../../src/aiida/schedulers/__init__.py:docstring of aiida.schedulers:1
msgid "Module for classes and utilities to interact with cluster schedulers."
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures:1
msgid "Data structures used by `Scheduler` instances."
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures:3
msgid "In particular, there is the definition of possible job states (job_states), the data structure to be filled for job submission (JobTemplate), and the data structure that is returned when querying for jobs in the scheduler (JobInfo)."
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobInfo:1
msgid "Contains properties for a job in the queue. Most of the fields are taken from DRMAA v.2."
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobInfo:4
msgid "Note that default fields may be undefined. This is an expected behavior and the application must cope with this case. An example for instance is the exit_status for jobs that have not finished yet; or features not supported by the given scheduler."
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobInfo:9
#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobTemplate:7
msgid "Fields:"
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobInfo:11
msgid "``job_id``: the job ID on the scheduler"
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobInfo:12
msgid "``title``: the job title, as known by the scheduler"
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobInfo:13
msgid "``exit_status``: the exit status of the job as reported by the operating system on the execution host"
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobInfo:15
msgid "``terminating_signal``: the UNIX signal that was responsible for the end of the job."
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobInfo:17
msgid "``annotation``: human-readable description of the reason for the job being in the current state or substate."
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobInfo:19
msgid "``job_state``: the job state (one of those defined in ``aiida.schedulers.datastructures.JobState``)"
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobInfo:21
msgid "``job_substate``: a string with the implementation-specific sub-state"
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobInfo:22
msgid "``allocated_machines``: a list of machines used for the current job. This is a list of :py:class:`aiida.schedulers.datastructures.MachineInfo` objects."
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobInfo:24
msgid "``job_owner``: the job owner as reported by the scheduler"
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobInfo:25
msgid "``num_mpiprocs``: the *total* number of requested MPI procs"
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobInfo:26
msgid "``num_cpus``: the *total* number of requested CPUs (cores) [may be undefined]"
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobInfo:27
msgid "``num_machines``: the number of machines (i.e., nodes), required by the job. If ``allocated_machines`` is not None, this number must be equal to ``len(allocated_machines)``. Otherwise, for schedulers not supporting the retrieval of the full list of allocated machines, this attribute can be used to know at least the number of machines."
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobInfo:32
msgid "``queue_name``: The name of the queue in which the job is queued or running."
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobInfo:34
msgid "``account``: The account/projectid in which the job is queued or running in."
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobInfo:36
msgid "``qos``: The quality of service in which the job is queued or running in."
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobInfo:38
msgid "``wallclock_time_seconds``: the accumulated wallclock time, in seconds"
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobInfo:39
msgid "``requested_wallclock_time_seconds``: the requested wallclock time, in seconds"
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobInfo:41
msgid "``cpu_time``: the accumulated cpu time, in seconds"
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobInfo:42
msgid "``submission_time``: the absolute time at which the job was submitted, of type datetime.datetime"
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobInfo:44
msgid "``dispatch_time``: the absolute time at which the job first entered the 'started' state, of type datetime.datetime"
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobInfo:46
msgid "``finish_time``: the absolute time at which the job first entered the 'finished' state, of type datetime.datetime"
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobInfo._deserialize_date:1
msgid "Deserialise a date :param value: The date vlue :return: The deserialised date"
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobInfo._deserialize_job_state:1
msgid "Return an instance of JobState from the job_state string."
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobInfo._serialize_date:1
msgid "Serialise a data value :param value: The value to serialise :return: The serialised value"
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobInfo._serialize_job_state:1
msgid "Return the serialized value of the JobState instance."
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobInfo.deserialize_field:1
msgid "Deserialise the value of a particular field with a type :param value: The value :param field_type: The field type :return: The deserialised value"
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobInfo.get_dict:1
msgid "Serialise the current data into a dictionary that is JSON-serializable."
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobInfo.get_dict:3
msgid "A dictionary"
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobInfo.load_from_dict:1
msgid "Create a new instance loading the values from serialised data in dictionary form"
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobInfo.load_from_dict:3
msgid "The dictionary with the data to load from"
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobInfo.load_from_serialized:1
msgid "Create a new instance loading the values from JSON-serialised data as a string"
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobInfo.load_from_serialized:3
msgid "The string with the JSON-serialised data to load from"
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobInfo.serialize:1
msgid "Serialize the current data (as obtained by ``self.get_dict()``) into a JSON string."
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobInfo.serialize:3
msgid "A string with serialised representation of the current data."
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobInfo.serialize_field:1
msgid "Serialise a particular field value"
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobInfo.serialize_field:3
msgid "The value to serialise"
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobInfo.serialize_field:4
msgid "The field type"
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobInfo.serialize_field:5
msgid "The serialised value"
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobResource:1
msgid "Data structure to store job resources."
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobResource:3
msgid "Each `Scheduler` implementation must define the `_job_resource_class` attribute to be a subclass of this class. It should at least define the `get_tot_num_mpiprocs` method, plus a constructor to accept its set of variables."
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobResource:6
msgid "Typical attributes are:"
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobResource:8
msgid "``num_machines``"
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobResource:9
msgid "``num_mpiprocs_per_machine``"
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobResource:11
msgid "or (e.g. for SGE)"
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobResource:13
msgid "``tot_num_mpiprocs``"
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobResource:14
msgid "``parallel_env``"
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobResource:16
msgid "The constructor should take care of checking the values. The init should raise only ValueError or TypeError on invalid parameters."
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobResource.accepts_default_memory_per_machine:1
#: ../../../src/aiida/schedulers/plugins/direct.py:docstring of aiida.schedulers.plugins.direct.DirectJobResource.accepts_default_memory_per_machine:1
msgid "Return True if this subclass accepts a `default_memory_per_machine` key, False otherwise."
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobResource.accepts_default_mpiprocs_per_machine:1
#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.NodeNumberJobResource.accepts_default_mpiprocs_per_machine:1
#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.ParEnvJobResource.accepts_default_mpiprocs_per_machine:1
msgid "Return True if this subclass accepts a `default_mpiprocs_per_machine` key, False otherwise."
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobResource.get_tot_num_mpiprocs:1
#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.NodeNumberJobResource.get_tot_num_mpiprocs:1
#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.ParEnvJobResource.get_tot_num_mpiprocs:1
#: ../../../src/aiida/schedulers/plugins/lsf.py:docstring of aiida.schedulers.plugins.lsf.LsfJobResource.get_tot_num_mpiprocs:1
msgid "Return the total number of cpus of this job resource."
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobResource.get_valid_keys:1
#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.NodeNumberJobResource.get_valid_keys:1
msgid "Return a list of valid keys to be passed to the constructor."
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobResource.validate_resources:1
#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.NodeNumberJobResource.validate_resources:1
#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.ParEnvJobResource.validate_resources:1
#: ../../../src/aiida/schedulers/plugins/lsf.py:docstring of aiida.schedulers.plugins.lsf.LsfJobResource.validate_resources:1
#: ../../../src/aiida/schedulers/plugins/pbsbaseclasses.py:docstring of aiida.schedulers.plugins.pbsbaseclasses.PbsJobResource.validate_resources:1
#: ../../../src/aiida/schedulers/plugins/slurm.py:docstring of aiida.schedulers.plugins.slurm.SlurmJobResource.validate_resources:1
#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler.validate_resources:1
msgid "Validate the resources against the job resource class of this scheduler."
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobResource.validate_resources:3
#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.NodeNumberJobResource.validate_resources:3
#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.ParEnvJobResource.validate_resources:3
#: ../../../src/aiida/schedulers/plugins/lsf.py:docstring of aiida.schedulers.plugins.lsf.LsfJobResource.validate_resources:3
#: ../../../src/aiida/schedulers/plugins/pbsbaseclasses.py:docstring of aiida.schedulers.plugins.pbsbaseclasses.PbsJobResource.validate_resources:7
#: ../../../src/aiida/schedulers/plugins/slurm.py:docstring of aiida.schedulers.plugins.slurm.SlurmJobResource.validate_resources:6
msgid "dictionary of values to define the job resources"
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobResource.validate_resources:4
#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.NodeNumberJobResource.__init__:3
#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.NodeNumberJobResource.validate_resources:5
#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.ParEnvJobResource.__init__:4
#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.ParEnvJobResource.validate_resources:5
#: ../../../src/aiida/schedulers/plugins/lsf.py:docstring of aiida.schedulers.plugins.lsf.LsfJobResource.validate_resources:5
#: ../../../src/aiida/schedulers/plugins/pbsbaseclasses.py:docstring of aiida.schedulers.plugins.pbsbaseclasses.PbsJobResource.validate_resources:9
#: ../../../src/aiida/schedulers/plugins/slurm.py:docstring of aiida.schedulers.plugins.slurm.SlurmJobResource.validate_resources:8
#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler.validate_resources:4
msgid "if the resources are invalid or incomplete"
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobResource.validate_resources:5
msgid "optional tuple of parsed resource settings"
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobState:1
msgid "Enumeration of possible scheduler states of a CalcJob."
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobState:3
msgid "There is no FAILED state as every completed job is put in DONE, regardless of success."
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobTemplate:1
msgid "A template for submitting jobs to a scheduler."
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobTemplate:3
msgid "This contains all required information to create the job header."
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobTemplate:5
msgid "The required fields are: working_directory, job_name, num_machines, num_mpiprocs_per_machine, argv."
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobTemplate:9
msgid "``shebang line``: The first line of the submission script"
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobTemplate:10
msgid "``submit_as_hold``: if set, the job will be in a 'hold' status right after the submission"
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobTemplate:12
msgid "``rerunnable``: if the job is rerunnable (boolean)"
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobTemplate:13
msgid "``job_environment``: a dictionary with environment variables to set before the execution of the code."
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobTemplate:15
msgid "``environment_variables_double_quotes``: if set to True, use double quotes instead of single quotes to escape the environment variables specified in ``job_environment``."
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobTemplate:18
msgid "``working_directory``: the working directory for this job. During submission, the transport will first do a 'chdir' to this directory, and then possibly set a scheduler parameter, if this is supported by the scheduler."
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobTemplate:22
msgid "``email``: an email address for sending emails on job events."
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobTemplate:23
msgid "``email_on_started``: if True, ask the scheduler to send an email when the job starts."
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobTemplate:25
msgid "``email_on_terminated``: if True, ask the scheduler to send an email when the job ends. This should also send emails on job failure, when possible."
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobTemplate:28
msgid "``job_name``: the name of this job. The actual name of the job can be different from the one specified here, e.g. if there are unsupported characters, or the name is too long."
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobTemplate:31
msgid "``sched_output_path``: a (relative) file name for the stdout of this job"
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobTemplate:32
msgid "``sched_error_path``: a (relative) file name for the stdout of this job"
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobTemplate:33
msgid "``sched_join_files``: if True, write both stdout and stderr on the same file (the one specified for stdout)"
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobTemplate:35
msgid "``queue_name``: the name of the scheduler queue (sometimes also called partition), on which the job will be submitted."
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobTemplate:37
msgid "``account``: the name of the scheduler account (sometimes also called projectid), on which the job will be submitted."
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobTemplate:39
msgid "``qos``: the quality of service of the scheduler account, on which the job will be submitted."
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobTemplate:41
msgid "``job_resource``: a suitable :py:class:`JobResource` subclass with information on how many nodes and cpus it should use. It must be an instance of the ``aiida.schedulers.Scheduler.job_resource_class`` class. Use the Scheduler.create_job_resource method to create it."
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobTemplate:46
msgid "``num_machines``: how many machines (or nodes) should be used"
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobTemplate:47
msgid "``num_mpiprocs_per_machine``: how many MPI procs should be used on each machine (or node)."
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobTemplate:49
msgid "``priority``: a priority for this job. Should be in the format accepted by the specific scheduler."
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobTemplate:51
msgid "``max_memory_kb``: The maximum amount of memory the job is allowed to allocate ON EACH NODE, in kilobytes"
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobTemplate:53
msgid "``max_wallclock_seconds``: The maximum wall clock time that all processes of a job are allowed to exist, in seconds"
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobTemplate:55
msgid "``custom_scheduler_commands``: a string that will be inserted right after the last scheduler command, and before any other non-scheduler command; useful if some specific flag needs to be added and is not supported by the plugin"
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobTemplate:59
msgid "``prepend_text``: a (possibly multi-line) string to be inserted in the scheduler script before the main execution line"
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobTemplate:61
msgid "``append_text``: a (possibly multi-line) string to be inserted in the scheduler script after the main execution line"
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobTemplate:63
msgid "``import_sys_environment``: import the system environment variables"
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobTemplate:64
msgid "``codes_info``: a list of aiida.scheduler.datastructures.JobTemplateCodeInfo objects. Each contains the information necessary to run a single code. At the moment, it can contain:"
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobTemplate:68
msgid "``cmdline_parameters``: a list of strings with the command line arguments of the program to run. This is the main program to be executed. NOTE: The first one is the executable name. For MPI runs, this will probably be \"mpirun\" or a similar program; this has to be chosen at a upper level."
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobTemplate:73
msgid "``stdin_name``: the (relative) file name to be used as stdin for the program specified with argv."
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobTemplate:75
msgid "``stdout_name``: the (relative) file name to be used as stdout for the program specified with argv."
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobTemplate:77
msgid "``stderr_name``: the (relative) file name to be used as stderr for the program specified with argv."
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobTemplate:79
msgid "``join_files``: if True, stderr is redirected on the same file specified for stdout."
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobTemplate:82
msgid "``codes_run_mode``: sets the run_mode with which the (multiple) codes have to be executed. For example, parallel execution::"
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobTemplate:89
msgid "The serial execution would be without the &'s. Values are given by aiida.common.datastructures.CodeRunMode."
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobTemplateCodeInfo:1
msgid "Data structure to communicate to a `Scheduler` how a code should be run in submit script."
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobTemplateCodeInfo:3
msgid "`Scheduler.get_submit_script` will pass a list of these objects to `Scheduler._get_run_line` which should build up the code execution line based on the parameters specified in this dataclass."
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobTemplateCodeInfo:6
msgid "list of unescaped command line arguments that are to be prepended to the executable."
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobTemplateCodeInfo:7
msgid "list of unescaped command line parameters."
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobTemplateCodeInfo:8
msgid "list of two booleans. If true, use double quotes to escape command line arguments. The first value applies to `prepend_cmdline_params` and the second to `cmdline_params`."
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobTemplateCodeInfo:10
msgid "Boolean, by default ``False``. If set to ``True``, all the command line arguments, which includes the ``cmdline_params`` but also all file descriptor redirections (stdin, stderr and stdoout), should be wrapped in double quotes, turning it into a single command line argument. This is necessary to enable support for certain containerization technologies such as Docker."
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobTemplateCodeInfo:14
msgid "filename of the the stdin file descriptor."
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobTemplateCodeInfo:15
msgid "filename of the the `stdout` file descriptor."
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobTemplateCodeInfo:16
msgid "filename of the the `stderr` file descriptor."
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.JobTemplateCodeInfo:17
msgid "boolean, if true, `stderr` should be redirected to `stdout`."
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.MachineInfo:1
msgid "Similarly to what is defined in the DRMAA v.2 as SlotInfo; this identifies each machine (also called 'node' on some schedulers) on which a job is running, and how many CPUs are being used. (Some of them could be undefined)"
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.MachineInfo:6
msgid "``name``: name of the machine"
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.MachineInfo:7
msgid "``num_cpus``: number of cores used by the job on this machine"
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.MachineInfo:8
msgid "``num_mpiprocs``: number of MPI processes used by the job on this machine"
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.NodeNumberJobResource:1
#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.ParEnvJobResource:1
#: ../../../src/aiida/schedulers/plugins/lsf.py:docstring of aiida.schedulers.plugins.lsf.LsfJobResource:1
msgid "Bases: :py:class:`~aiida.schedulers.datastructures.JobResource`"
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.NodeNumberJobResource:1
msgid "`JobResource` for schedulers that support the specification of a number of nodes and cpus per node."
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.NodeNumberJobResource.__init__:1
msgid "Initialize the job resources from the passed arguments."
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.NodeNumberJobResource.validate_resources:4
#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.ParEnvJobResource.validate_resources:4
#: ../../../src/aiida/schedulers/plugins/lsf.py:docstring of aiida.schedulers.plugins.lsf.LsfJobResource.validate_resources:4
#: ../../../src/aiida/schedulers/plugins/pbsbaseclasses.py:docstring of aiida.schedulers.plugins.pbsbaseclasses.PbsJobResource.validate_resources:8
#: ../../../src/aiida/schedulers/plugins/slurm.py:docstring of aiida.schedulers.plugins.slurm.SlurmJobResource.validate_resources:7
msgid "attribute dictionary with the parsed parameters populated"
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.ParEnvJobResource:1
msgid "`JobResource` for schedulers that support the specification of a parallel environment and number of MPI procs."
msgstr ""

#: ../../../src/aiida/schedulers/datastructures.py:docstring of aiida.schedulers.datastructures.ParEnvJobResource.__init__:1
#: ../../../src/aiida/schedulers/plugins/lsf.py:docstring of aiida.schedulers.plugins.lsf.LsfJobResource.__init__:1
msgid "Initialize the job resources from the passed arguments (the valid keys can be obtained with the function self.get_valid_keys())."
msgstr ""

#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler:1
msgid "Implementation of `Scheduler` base class."
msgstr ""

#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler:1
msgid "Base class for a job scheduler."
msgstr ""

#: ../../../src/aiida/schedulers/plugins/sge.py:docstring of aiida.schedulers.plugins.sge.SgeScheduler._get_detailed_job_info_command:1
#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler._get_detailed_job_info_command:1
msgid "Return the command to run to get detailed information for a given job."
msgstr ""

#: ../../../src/aiida/schedulers/plugins/sge.py:docstring of aiida.schedulers.plugins.sge.SgeScheduler._get_detailed_job_info_command:3
#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler._get_detailed_job_info_command:3
msgid "This is typically called after the job has finished, to retrieve the most detailed information possible about the job. This is done because most schedulers just make finished jobs disappear from the `qstat` command, and instead sometimes it is useful to know some more detailed information about the job exit status, etc."
msgstr ""

#: ../../../src/aiida/schedulers/plugins/sge.py:docstring of aiida.schedulers.plugins.sge.SgeScheduler._get_detailed_job_info_command:7
#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler._get_detailed_job_info_command:7
msgid ":class:`aiida.common.exceptions.FeatureNotAvailable`"
msgstr ""

#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler._get_joblist_command:1
msgid "Return the command to get the most complete description possible of currently active jobs."
msgstr ""

#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler._get_joblist_command:5
msgid "Typically one can pass only either jobs or user, depending on the specific plugin. The choice can be done according to the value returned by `self.get_feature('can_query_by_user')`"
msgstr ""

#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler._get_joblist_command:8
msgid "either None to get a list of all jobs in the machine, or a list of jobs."
msgstr ""

#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler._get_joblist_command:9
msgid "either None, or a string with the username (to show only jobs of the specific user)."
msgstr ""

#: ../../../src/aiida/schedulers/plugins/direct.py:docstring of aiida.schedulers.plugins.direct.DirectScheduler._get_kill_command:1
#: ../../../src/aiida/schedulers/plugins/lsf.py:docstring of aiida.schedulers.plugins.lsf.LsfScheduler._get_kill_command:1
#: ../../../src/aiida/schedulers/plugins/pbsbaseclasses.py:docstring of aiida.schedulers.plugins.pbsbaseclasses.PbsBaseClass._get_kill_command:1
#: ../../../src/aiida/schedulers/plugins/sge.py:docstring of aiida.schedulers.plugins.sge.SgeScheduler._get_kill_command:1
#: ../../../src/aiida/schedulers/plugins/slurm.py:docstring of aiida.schedulers.plugins.slurm.SlurmScheduler._get_kill_command:1
#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler._get_kill_command:1
msgid "Return the command to kill the job with specified jobid."
msgstr ""

#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler._get_run_line:1
msgid "Return a string with the line to execute a specific code with specific arguments."
msgstr ""

#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler._get_run_line:3
msgid "a list of `aiida.scheduler.datastructures.JobTemplateCodeInfo` objects. Each contains the information needed to run the code. I.e. `cmdline_params`, `stdin_name`, `stdout_name`, `stderr_name`, `join_files`. See the documentation of `JobTemplate` and `JobTemplateCodeInfo`."
msgstr ""

#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler._get_run_line:7
msgid "instance of `aiida.common.datastructures.CodeRunMode` contains the information on how to launch the multiple codes."
msgstr ""

#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler._get_run_line:9
msgid "string with format: [executable] [args] {[ < stdin ]} {[ < stdout ]} {[2>&1 | 2> stderr]}"
msgstr ""

#: ../../../src/aiida/schedulers/plugins/direct.py:docstring of aiida.schedulers.plugins.direct.DirectScheduler._get_submit_command:1
#: ../../../src/aiida/schedulers/plugins/lsf.py:docstring of aiida.schedulers.plugins.lsf.LsfScheduler._get_submit_command:1
#: ../../../src/aiida/schedulers/plugins/pbsbaseclasses.py:docstring of aiida.schedulers.plugins.pbsbaseclasses.PbsBaseClass._get_submit_command:1
#: ../../../src/aiida/schedulers/plugins/sge.py:docstring of aiida.schedulers.plugins.sge.SgeScheduler._get_submit_command:1
#: ../../../src/aiida/schedulers/plugins/slurm.py:docstring of aiida.schedulers.plugins.slurm.SlurmScheduler._get_submit_command:1
#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler._get_submit_command:1
msgid "Return the string to execute to submit a given script."
msgstr ""

#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler._get_submit_command:3
msgid "the `submit_script` should already have been bash-escaped"
msgstr ""

#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler._get_submit_command:5
msgid "the path of the submit script relative to the working directory."
msgstr ""

#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler._get_submit_command:6
msgid "the string to execute to submit a given script."
msgstr ""

#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler._get_submit_script_environment_variables:1
msgid "Return the part of the submit script header that defines environment variables."
msgstr ""

#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler._get_submit_script_environment_variables:3
#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler.get_submit_script:3
msgid "a `aiida.schedulers.datastrutures.JobTemplate` instance."
msgstr ""

#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler._get_submit_script_environment_variables:4
msgid "string containing environment variable declarations."
msgstr ""

#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler._get_submit_script_footer:1
msgid "Return the submit script final part, using the parameters from the job template."
msgstr ""

#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler._get_submit_script_footer:3
#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler._get_submit_script_header:3
msgid "a `JobTemplate` instance with relevant parameters set."
msgstr ""

#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler._get_submit_script_footer:4
msgid "string with the submission script footer."
msgstr ""

#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler._get_submit_script_header:1
msgid "Return the submit script header, using the parameters from the job template."
msgstr ""

#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler._get_submit_script_header:4
msgid "string with the submission script header."
msgstr ""

#: ../../../src/aiida/schedulers/plugins/sge.py:docstring of aiida.schedulers.plugins.sge.SgeScheduler._parse_joblist_output:1
#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler._parse_joblist_output:1
msgid "Parse the joblist output as returned by executing the command returned by `_get_joblist_command` method."
msgstr ""

#: ../../../src/aiida/schedulers/plugins/sge.py:docstring of aiida.schedulers.plugins.sge.SgeScheduler._parse_joblist_output:3
#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler._parse_joblist_output:3
msgid "list of `JobInfo` objects, one of each job each with at least its default params implemented."
msgstr ""

#: ../../../src/aiida/schedulers/plugins/direct.py:docstring of aiida.schedulers.plugins.direct.DirectScheduler._parse_kill_output:1
#: ../../../src/aiida/schedulers/plugins/lsf.py:docstring of aiida.schedulers.plugins.lsf.LsfScheduler._parse_kill_output:1
#: ../../../src/aiida/schedulers/plugins/pbsbaseclasses.py:docstring of aiida.schedulers.plugins.pbsbaseclasses.PbsBaseClass._parse_kill_output:1
#: ../../../src/aiida/schedulers/plugins/sge.py:docstring of aiida.schedulers.plugins.sge.SgeScheduler._parse_kill_output:1
#: ../../../src/aiida/schedulers/plugins/slurm.py:docstring of aiida.schedulers.plugins.slurm.SlurmScheduler._parse_kill_output:1
#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler._parse_kill_output:1
msgid "Parse the output of the kill command."
msgstr ""

#: ../../../src/aiida/schedulers/plugins/direct.py:docstring of aiida.schedulers.plugins.direct.DirectScheduler._parse_kill_output:5
#: ../../../src/aiida/schedulers/plugins/lsf.py:docstring of aiida.schedulers.plugins.lsf.LsfScheduler._parse_kill_output:3
#: ../../../src/aiida/schedulers/plugins/pbsbaseclasses.py:docstring of aiida.schedulers.plugins.pbsbaseclasses.PbsBaseClass._parse_kill_output:5
#: ../../../src/aiida/schedulers/plugins/sge.py:docstring of aiida.schedulers.plugins.sge.SgeScheduler._parse_kill_output:5
#: ../../../src/aiida/schedulers/plugins/slurm.py:docstring of aiida.schedulers.plugins.slurm.SlurmScheduler._parse_kill_output:5
#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler._parse_kill_output:3
#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler.kill:9
msgid "True if everything seems ok, False otherwise."
msgstr ""

#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler._parse_submit_output:1
msgid "Parse the output of the submit command returned by calling the `_get_submit_command` command."
msgstr ""

#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler._parse_submit_output:3
msgid "a string with the job ID or an exit code if the submission failed because the submission script is invalid and the job should be terminated."
msgstr ""

#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler.create_job_resource:1
msgid "Create a suitable job resource from the kwargs specified."
msgstr ""

#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler.get_detailed_job_info:1
msgid "Return the detailed job info."
msgstr ""

#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler.get_detailed_job_info:3
msgid "This will be a dictionary with the return value, stderr and stdout content returned by calling the command that is returned by `_get_detailed_job_info_command`."
msgstr ""

#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler.get_detailed_job_info:6
msgid "the job identifier"
msgstr ""

#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler.get_detailed_job_info:7
msgid "dictionary with `retval`, `stdout` and `stderr`."
msgstr ""

#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler.get_jobs:1
msgid "Return the list of currently active jobs."
msgstr ""

#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler.get_jobs:3
msgid "typically, only either jobs or user can be specified. See also comments in `_get_joblist_command`."
msgstr ""

#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler.get_jobs:5
msgid "a list of jobs to check; only these are checked"
msgstr ""

#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler.get_jobs:6
msgid "a string with a user: only jobs of this user are checked"
msgstr ""

#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler.get_jobs:7
msgid "if False (default), a list of JobInfo objects is returned. If True, a dictionary is returned, having as key the job_id and as value the JobInfo object."
msgstr ""

#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler.get_jobs:9
msgid "list of active jobs"
msgstr ""

#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler.get_short_doc:1
msgid "Return the first non-empty line of the class docstring, if available."
msgstr ""

#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler.get_submit_script:1
msgid "Return the submit script as a string."
msgstr ""

#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler.get_submit_script:5
msgid "The plugin returns something like"
msgstr ""

#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler.get_submit_script:7
msgid "#!/bin/bash <- this shebang line is configurable to some extent scheduler_dependent stuff to choose numnodes, numcores, walltime, ... prepend_computer [also from calcinfo, joined with the following?] prepend_code [from calcinfo] output of _get_script_main_content postpend_code postpend_computer"
msgstr ""

#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler.kill:1
msgid "Kill a remote job and parse the return value of the scheduler to check if the command succeeded."
msgstr ""

#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler.kill:3
msgid "..note::"
msgstr ""

#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler.kill:8
msgid "the job ID to be killed"
msgstr ""

#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler.logger:1
msgid "Return the internal logger."
msgstr ""

#: ../../../src/aiida/schedulers/plugins/slurm.py:docstring of aiida.schedulers.plugins.slurm.SlurmScheduler.parse_output:1
#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler.parse_output:1
msgid "Parse the output of the scheduler."
msgstr ""

#: ../../../src/aiida/schedulers/plugins/slurm.py:docstring of aiida.schedulers.plugins.slurm.SlurmScheduler.parse_output:3
#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler.parse_output:3
msgid "dictionary with the output returned by the `Scheduler.get_detailed_job_info` command. This should contain the keys `retval`, `stdout` and `stderr` corresponding to the return value, stdout and stderr returned by the accounting command executed for a specific job id."
msgstr ""

#: ../../../src/aiida/schedulers/plugins/slurm.py:docstring of aiida.schedulers.plugins.slurm.SlurmScheduler.parse_output:6
#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler.parse_output:6
msgid "string with the output written by the scheduler to stdout."
msgstr ""

#: ../../../src/aiida/schedulers/plugins/slurm.py:docstring of aiida.schedulers.plugins.slurm.SlurmScheduler.parse_output:7
#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler.parse_output:7
msgid "string with the output written by the scheduler to stderr."
msgstr ""

#: ../../../src/aiida/schedulers/plugins/slurm.py:docstring of aiida.schedulers.plugins.slurm.SlurmScheduler.parse_output:8
#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler.parse_output:8
msgid "None or an instance of :class:`aiida.engine.processes.exit_code.ExitCode`."
msgstr ""

#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler.preprocess_resources:1
msgid "Pre process the resources."
msgstr ""

#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler.preprocess_resources:3
msgid "Add the `num_mpiprocs_per_machine` key to the `resources` if it is not already defined and it cannot be deduced from the `num_machines` and `tot_num_mpiprocs` being defined. The value is also not added if the job resource class of this scheduler does not accept the `num_mpiprocs_per_machine` keyword. Note that the changes are made in place to the `resources` argument passed."
msgstr ""

#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler.set_transport:1
msgid "Set the transport to be used to query the machine or to submit scripts."
msgstr ""

#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler.set_transport:3
msgid "This class assumes that the transport is open and active."
msgstr ""

#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler.submit_from_script:1
msgid "Submit the submission script to the scheduler."
msgstr ""

#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler.submit_from_script:3
msgid "return a string with the job ID in a valid format to be used for querying."
msgstr ""

#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler.transport:1
msgid "Return the transport set for this scheduler."
msgstr ""

#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.Scheduler.validate_resources:3
msgid "keyword arguments to define the job resources"
msgstr ""

#: ../../../src/aiida/schedulers/scheduler.py:docstring of aiida.schedulers.scheduler.SchedulerParsingError:1
msgid "Bases: :py:class:`~aiida.schedulers.scheduler.SchedulerError`"
msgstr ""

#: ../../source/reference/apidoc/aiida.schedulers.plugins.rst:2
msgid "aiida.schedulers.plugins package"
msgstr ""

#: ../../../src/aiida/schedulers/plugins/direct.py:docstring of aiida.schedulers.plugins.direct:1
msgid "Plugin for direct execution."
msgstr ""

#: ../../../src/aiida/schedulers/plugins/direct.py:docstring of aiida.schedulers.plugins.direct.DirectJobResource:1
#: ../../../src/aiida/schedulers/plugins/pbsbaseclasses.py:docstring of aiida.schedulers.plugins.pbsbaseclasses.PbsJobResource:1
#: ../../../src/aiida/schedulers/plugins/slurm.py:docstring of aiida.schedulers.plugins.slurm.SlurmJobResource:1
msgid "Bases: :py:class:`~aiida.schedulers.datastructures.NodeNumberJobResource`"
msgstr ""

#: ../../../src/aiida/schedulers/plugins/direct.py:docstring of aiida.schedulers.plugins.direct.DirectJobResource:1
msgid "An implementation of JobResource for the direct excution bypassing schedulers."
msgstr ""

#: ../../../src/aiida/schedulers/plugins/direct.py:docstring of aiida.schedulers.plugins.direct.DirectScheduler:1
#: ../../../src/aiida/schedulers/plugins/lsf.py:docstring of aiida.schedulers.plugins.lsf.LsfScheduler:1
#: ../../../src/aiida/schedulers/plugins/pbsbaseclasses.py:docstring of aiida.schedulers.plugins.pbsbaseclasses.PbsBaseClass:1
#: ../../../src/aiida/schedulers/plugins/sge.py:docstring of aiida.schedulers.plugins.sge.SgeScheduler:1
#: ../../../src/aiida/schedulers/plugins/slurm.py:docstring of aiida.schedulers.plugins.slurm.SlurmScheduler:1
msgid "Bases: :py:class:`~aiida.schedulers.scheduler.Scheduler`"
msgstr ""

#: ../../../src/aiida/schedulers/plugins/direct.py:docstring of aiida.schedulers.plugins.direct.DirectScheduler:1
msgid "Support for the direct execution bypassing schedulers."
msgstr ""

#: ../../../src/aiida/schedulers/plugins/direct.py:docstring of aiida.schedulers.plugins.direct.DirectScheduler._convert_time:1
#: ../../../src/aiida/schedulers/plugins/pbsbaseclasses.py:docstring of aiida.schedulers.plugins.pbsbaseclasses.PbsBaseClass._convert_time:1
msgid "Convert a string in the format HH:MM:SS to a number of seconds."
msgstr ""

#: ../../../src/aiida/schedulers/plugins/direct.py:docstring of aiida.schedulers.plugins.direct.DirectScheduler._get_joblist_command:1
#: ../../../src/aiida/schedulers/plugins/lsf.py:docstring of aiida.schedulers.plugins.lsf.LsfScheduler._get_joblist_command:1
#: ../../../src/aiida/schedulers/plugins/pbsbaseclasses.py:docstring of aiida.schedulers.plugins.pbsbaseclasses.PbsBaseClass._get_joblist_command:1
#: ../../../src/aiida/schedulers/plugins/sge.py:docstring of aiida.schedulers.plugins.sge.SgeScheduler._get_joblist_command:1
#: ../../../src/aiida/schedulers/plugins/slurm.py:docstring of aiida.schedulers.plugins.slurm.SlurmScheduler._get_joblist_command:1
msgid "The command to report full information on existing jobs."
msgstr ""

#: ../../../src/aiida/schedulers/plugins/direct.py:docstring of aiida.schedulers.plugins.direct.DirectScheduler._get_joblist_command:3
#: ../../../src/aiida/schedulers/plugins/pbsbaseclasses.py:docstring of aiida.schedulers.plugins.pbsbaseclasses.PbsBaseClass._get_joblist_command:3
#: ../../../src/aiida/schedulers/plugins/sge.py:docstring of aiida.schedulers.plugins.sge.SgeScheduler._get_joblist_command:4
msgid "TODO: in the case of job arrays, decide what to do (i.e., if we want"
msgstr ""

#: ../../../src/aiida/schedulers/plugins/direct.py:docstring of aiida.schedulers.plugins.direct.DirectScheduler._get_joblist_command:4
#: ../../../src/aiida/schedulers/plugins/pbsbaseclasses.py:docstring of aiida.schedulers.plugins.pbsbaseclasses.PbsBaseClass._get_joblist_command:4
#: ../../../src/aiida/schedulers/plugins/sge.py:docstring of aiida.schedulers.plugins.sge.SgeScheduler._get_joblist_command:4
msgid "to pass the -t options to list each subjob)."
msgstr ""

#: ../../../src/aiida/schedulers/plugins/direct.py:docstring of aiida.schedulers.plugins.direct.DirectScheduler._get_submit_command:3
msgid "One needs to redirect stdout and stderr to /dev/null otherwise the daemon remains hanging for the script to run"
msgstr ""

#: ../../../src/aiida/schedulers/plugins/direct.py:docstring of aiida.schedulers.plugins.direct.DirectScheduler._get_submit_command:6
#: ../../../src/aiida/schedulers/plugins/lsf.py:docstring of aiida.schedulers.plugins.lsf.LsfScheduler._get_submit_command:3
msgid "the path of the submit script relative to the working directory. IMPORTANT: submit_script should be already escaped."
msgstr ""

#: ../../../src/aiida/schedulers/plugins/direct.py:docstring of aiida.schedulers.plugins.direct.DirectScheduler._get_submit_script_header:1
#: ../../../src/aiida/schedulers/plugins/pbsbaseclasses.py:docstring of aiida.schedulers.plugins.pbsbaseclasses.PbsBaseClass._get_submit_script_header:1
#: ../../../src/aiida/schedulers/plugins/sge.py:docstring of aiida.schedulers.plugins.sge.SgeScheduler._get_submit_script_header:1
#: ../../../src/aiida/schedulers/plugins/slurm.py:docstring of aiida.schedulers.plugins.slurm.SlurmScheduler._get_submit_script_header:1
msgid "Return the submit script header, using the parameters from the job_tmpl."
msgstr ""

#: ../../../src/aiida/schedulers/plugins/direct.py:docstring of aiida.schedulers.plugins.direct.DirectScheduler._get_submit_script_header:6
#: ../../../src/aiida/schedulers/plugins/pbsbaseclasses.py:docstring of aiida.schedulers.plugins.pbsbaseclasses.PbsBaseClass._get_submit_script_header:6
#: ../../../src/aiida/schedulers/plugins/sge.py:docstring of aiida.schedulers.plugins.sge.SgeScheduler._get_submit_script_header:6
#: ../../../src/aiida/schedulers/plugins/slurm.py:docstring of aiida.schedulers.plugins.slurm.SlurmScheduler._get_submit_script_header:6
msgid "job_tmpl: an JobTemplate instance with relevant parameters set."
msgstr ""

#: ../../../src/aiida/schedulers/plugins/direct.py:docstring of aiida.schedulers.plugins.direct.DirectScheduler._parse_joblist_output:1
#: ../../../src/aiida/schedulers/plugins/pbsbaseclasses.py:docstring of aiida.schedulers.plugins.pbsbaseclasses.PbsBaseClass._parse_joblist_output:1
msgid "Parse the queue output string, as returned by executing the command returned by _get_joblist_command command (qstat -f)."
msgstr ""

#: ../../../src/aiida/schedulers/plugins/direct.py:docstring of aiida.schedulers.plugins.direct.DirectScheduler._parse_joblist_output:4
#: ../../../src/aiida/schedulers/plugins/lsf.py:docstring of aiida.schedulers.plugins.lsf.LsfScheduler._parse_joblist_output:7
#: ../../../src/aiida/schedulers/plugins/pbsbaseclasses.py:docstring of aiida.schedulers.plugins.pbsbaseclasses.PbsBaseClass._parse_joblist_output:4
#: ../../../src/aiida/schedulers/plugins/slurm.py:docstring of aiida.schedulers.plugins.slurm.SlurmScheduler._parse_joblist_output:7
msgid "Return a list of JobInfo objects, one of each job, each relevant parameters implemented."
msgstr ""

#: ../../../src/aiida/schedulers/plugins/direct.py:docstring of aiida.schedulers.plugins.direct.DirectScheduler._parse_joblist_output:7
msgid "depending on the scheduler configuration, finished jobs may either appear here, or not. This function will only return one element for each job find in the qstat output; missing jobs (for whatever reason) simply will not appear here."
msgstr ""

#: ../../../src/aiida/schedulers/plugins/direct.py:docstring of aiida.schedulers.plugins.direct.DirectScheduler._parse_kill_output:3
#: ../../../src/aiida/schedulers/plugins/direct.py:docstring of aiida.schedulers.plugins.direct.DirectScheduler._parse_submit_output:4
#: ../../../src/aiida/schedulers/plugins/lsf.py:docstring of aiida.schedulers.plugins.lsf.LsfScheduler._parse_submit_output:4
#: ../../../src/aiida/schedulers/plugins/pbsbaseclasses.py:docstring of aiida.schedulers.plugins.pbsbaseclasses.PbsBaseClass._parse_kill_output:3
#: ../../../src/aiida/schedulers/plugins/pbsbaseclasses.py:docstring of aiida.schedulers.plugins.pbsbaseclasses.PbsBaseClass._parse_submit_output:4
#: ../../../src/aiida/schedulers/plugins/sge.py:docstring of aiida.schedulers.plugins.sge.SgeScheduler._parse_kill_output:3
#: ../../../src/aiida/schedulers/plugins/sge.py:docstring of aiida.schedulers.plugins.sge.SgeScheduler._parse_submit_output:4
#: ../../../src/aiida/schedulers/plugins/slurm.py:docstring of aiida.schedulers.plugins.slurm.SlurmScheduler._parse_kill_output:3
#: ../../../src/aiida/schedulers/plugins/slurm.py:docstring of aiida.schedulers.plugins.slurm.SlurmScheduler._parse_submit_output:4
msgid "To be implemented by the plugin."
msgstr ""

#: ../../../src/aiida/schedulers/plugins/direct.py:docstring of aiida.schedulers.plugins.direct.DirectScheduler._parse_submit_output:1
#: ../../../src/aiida/schedulers/plugins/lsf.py:docstring of aiida.schedulers.plugins.lsf.LsfScheduler._parse_submit_output:1
#: ../../../src/aiida/schedulers/plugins/pbsbaseclasses.py:docstring of aiida.schedulers.plugins.pbsbaseclasses.PbsBaseClass._parse_submit_output:1
#: ../../../src/aiida/schedulers/plugins/sge.py:docstring of aiida.schedulers.plugins.sge.SgeScheduler._parse_submit_output:1
#: ../../../src/aiida/schedulers/plugins/slurm.py:docstring of aiida.schedulers.plugins.slurm.SlurmScheduler._parse_submit_output:1
msgid "Parse the output of the submit command, as returned by executing the command returned by _get_submit_command command."
msgstr ""

#: ../../../src/aiida/schedulers/plugins/direct.py:docstring of aiida.schedulers.plugins.direct.DirectScheduler._parse_submit_output:6
#: ../../../src/aiida/schedulers/plugins/lsf.py:docstring of aiida.schedulers.plugins.lsf.LsfScheduler._parse_submit_output:6
#: ../../../src/aiida/schedulers/plugins/pbsbaseclasses.py:docstring of aiida.schedulers.plugins.pbsbaseclasses.PbsBaseClass._parse_submit_output:6
#: ../../../src/aiida/schedulers/plugins/sge.py:docstring of aiida.schedulers.plugins.sge.SgeScheduler._parse_submit_output:6
#: ../../../src/aiida/schedulers/plugins/slurm.py:docstring of aiida.schedulers.plugins.slurm.SlurmScheduler._parse_submit_output:6
msgid "Return a string with the JobID."
msgstr ""

#: ../../../src/aiida/schedulers/plugins/direct.py:docstring of aiida.schedulers.plugins.direct.DirectScheduler.get_jobs:1
msgid "Overrides original method from DirectScheduler in order to list missing processes as DONE."
msgstr ""

#: ../../../src/aiida/schedulers/plugins/lsf.py:docstring of aiida.schedulers.plugins.lsf:1
msgid "Plugin for LSF. This has been tested on the CERN lxplus cluster (LSF 9.1.3)"
msgstr ""

#: ../../../src/aiida/schedulers/plugins/lsf.py:docstring of aiida.schedulers.plugins.lsf.LsfJobResource:1
msgid "An implementation of JobResource for LSF, that supports the OPTIONAL specification of a parallel environment (a string) + the total number of processors."
msgstr ""

#: ../../../src/aiida/schedulers/plugins/lsf.py:docstring of aiida.schedulers.plugins.lsf.LsfJobResource:5
msgid "'parallel_env' should contain a string of the form \"host1 host2! hostgroupA! host3 host4\" where the \"!\" symbol indicates the first execution host candidates. Other hosts are added only if the number of processors asked is more than those of the first execution host. See https://www-01.ibm.com/support/knowledgecenter/SSETD4_9.1.2/lsf_command_ref/bsub.1.dita?lang=en for more details about the parallel environment definition (the -m option of bsub)."
msgstr ""

#: ../../../src/aiida/schedulers/plugins/lsf.py:docstring of aiida.schedulers.plugins.lsf.LsfJobResource.__init__:4
#: ../../../src/aiida/schedulers/plugins/lsf.py:docstring of aiida.schedulers.plugins.lsf.LsfJobResource.__init__:5
msgid "on invalid parameters."
msgstr ""

#: ../../../src/aiida/schedulers/plugins/lsf.py:docstring of aiida.schedulers.plugins.lsf.LsfJobResource.__init__:6
msgid "if default_mpiprocs_per_machine was set for this computer, since LsfJobResource cannot accept this parameter."
msgstr ""

#: ../../../src/aiida/schedulers/plugins/lsf.py:docstring of aiida.schedulers.plugins.lsf.LsfJobResource.accepts_default_mpiprocs_per_machine:1
msgid "Return True if this JobResource accepts a 'default_mpiprocs_per_machine' key, False otherwise."
msgstr ""

#: ../../../src/aiida/schedulers/plugins/lsf.py:docstring of aiida.schedulers.plugins.lsf.LsfScheduler:1
msgid "Support for the IBM LSF scheduler 'https://www-01.ibm.com/support/knowledgecenter/SSETD4_9.1.2/lsf_welcome.html'"
msgstr ""

#: ../../../src/aiida/schedulers/plugins/lsf.py:docstring of aiida.schedulers.plugins.lsf.LsfScheduler._get_detailed_job_info_command:1
#: ../../../src/aiida/schedulers/plugins/pbsbaseclasses.py:docstring of aiida.schedulers.plugins.pbsbaseclasses.PbsBaseClass._get_detailed_job_info_command:1
#: ../../../src/aiida/schedulers/plugins/slurm.py:docstring of aiida.schedulers.plugins.slurm.SlurmScheduler._get_detailed_job_info_command:1
msgid "Return the command to run to get the detailed information on a job, even after the job has finished."
msgstr ""

#: ../../../src/aiida/schedulers/plugins/lsf.py:docstring of aiida.schedulers.plugins.lsf.LsfScheduler._get_detailed_job_info_command:4
#: ../../../src/aiida/schedulers/plugins/pbsbaseclasses.py:docstring of aiida.schedulers.plugins.pbsbaseclasses.PbsBaseClass._get_detailed_job_info_command:4
msgid "The output text is just retrieved, and returned for logging purposes."
msgstr ""

#: ../../../src/aiida/schedulers/plugins/lsf.py:docstring of aiida.schedulers.plugins.lsf.LsfScheduler._get_joblist_command:3
msgid "Separates the fields with the _field_separator string order: jobnum, state, walltime, queue[=partition], user, numnodes, numcores, title"
msgstr ""

#: ../../../src/aiida/schedulers/plugins/lsf.py:docstring of aiida.schedulers.plugins.lsf.LsfScheduler._get_submit_script_footer:1
msgid "Return the submit script final part, using the parameters from the job_tmpl."
msgstr ""

#: ../../../src/aiida/schedulers/plugins/lsf.py:docstring of aiida.schedulers.plugins.lsf.LsfScheduler._get_submit_script_footer:4
msgid "a JobTemplate instance with relevant parameters set."
msgstr ""

#: ../../../src/aiida/schedulers/plugins/lsf.py:docstring of aiida.schedulers.plugins.lsf.LsfScheduler._get_submit_script_header:1
msgid "Return the submit script header, using the parameters from the job_tmpl. See the following manual https://www-01.ibm.com/support/knowledgecenter/SSETD4_9.1.2/lsf_command_ref/bsub.1.dita?lang=en for more details about the possible options to bsub, in particular for the parallel environment definition (with the -m option)."
msgstr ""

#: ../../../src/aiida/schedulers/plugins/lsf.py:docstring of aiida.schedulers.plugins.lsf.LsfScheduler._get_submit_script_header:7
msgid "an JobTemplate instance with relevant parameters set."
msgstr ""

#: ../../../src/aiida/schedulers/plugins/lsf.py:docstring of aiida.schedulers.plugins.lsf.LsfScheduler._parse_joblist_output:1
#: ../../../src/aiida/schedulers/plugins/slurm.py:docstring of aiida.schedulers.plugins.slurm.SlurmScheduler._parse_joblist_output:1
msgid "Parse the queue output string, as returned by executing the command returned by _get_joblist_command command, that is here implemented as a list of lines, one for each job, with _field_separator as separator. The order is described in the _get_joblist_command function."
msgstr ""

#: ../../../src/aiida/schedulers/plugins/lsf.py:docstring of aiida.schedulers.plugins.lsf.LsfScheduler._parse_joblist_output:13
#: ../../../src/aiida/schedulers/plugins/pbsbaseclasses.py:docstring of aiida.schedulers.plugins.pbsbaseclasses.PbsBaseClass._parse_joblist_output:10
#: ../../../src/aiida/schedulers/plugins/slurm.py:docstring of aiida.schedulers.plugins.slurm.SlurmScheduler._parse_joblist_output:13
msgid "Note: depending on the scheduler configuration, finished jobs may"
msgstr ""

#: ../../../src/aiida/schedulers/plugins/lsf.py:docstring of aiida.schedulers.plugins.lsf.LsfScheduler._parse_joblist_output:11
#: ../../../src/aiida/schedulers/plugins/pbsbaseclasses.py:docstring of aiida.schedulers.plugins.pbsbaseclasses.PbsBaseClass._parse_joblist_output:8
#: ../../../src/aiida/schedulers/plugins/slurm.py:docstring of aiida.schedulers.plugins.slurm.SlurmScheduler._parse_joblist_output:11
msgid "either appear here, or not. This function will only return one element for each job find in the qstat output; missing jobs (for whatever reason) simply will not appear here."
msgstr ""

#: ../../../src/aiida/schedulers/plugins/lsf.py:docstring of aiida.schedulers.plugins.lsf.LsfScheduler._parse_time_string:1
msgid "Parse a time string and returns a datetime object. Example format: 'Feb  2 07:39' or 'Feb  2 07:39 L'"
msgstr ""

#: ../../../src/aiida/schedulers/plugins/pbsbaseclasses.py:docstring of aiida.schedulers.plugins.pbsbaseclasses:1
msgid "Base classes for PBSPro and PBS/Torque plugins."
msgstr ""

#: ../../../src/aiida/schedulers/plugins/pbsbaseclasses.py:docstring of aiida.schedulers.plugins.pbsbaseclasses.PbsBaseClass:1
msgid "Base class with support for the PBSPro scheduler (http://www.pbsworks.com/) and for PBS and Torque (http://www.adaptivecomputing.com/products/open-source/torque/)."
msgstr ""

#: ../../../src/aiida/schedulers/plugins/pbsbaseclasses.py:docstring of aiida.schedulers.plugins.pbsbaseclasses.PbsBaseClass:5
msgid "Only a few properties need to be redefined, see examples of the pbspro and torque plugins"
msgstr ""

#: ../../../src/aiida/schedulers/plugins/pbsbaseclasses.py:docstring of aiida.schedulers.plugins.pbsbaseclasses.PbsBaseClass._get_resource_lines:1
msgid "Return a set a list of lines (possibly empty) with the header lines relative to:"
msgstr ""

#: ../../../src/aiida/schedulers/plugins/pbsbaseclasses.py:docstring of aiida.schedulers.plugins.pbsbaseclasses.PbsBaseClass._get_resource_lines:4
msgid "num_machines"
msgstr ""

#: ../../../src/aiida/schedulers/plugins/pbsbaseclasses.py:docstring of aiida.schedulers.plugins.pbsbaseclasses.PbsBaseClass._get_resource_lines:5
msgid "num_mpiprocs_per_machine"
msgstr ""

#: ../../../src/aiida/schedulers/plugins/pbsbaseclasses.py:docstring of aiida.schedulers.plugins.pbsbaseclasses.PbsBaseClass._get_resource_lines:6
msgid "num_cores_per_machine"
msgstr ""

#: ../../../src/aiida/schedulers/plugins/pbsbaseclasses.py:docstring of aiida.schedulers.plugins.pbsbaseclasses.PbsBaseClass._get_resource_lines:7
msgid "max_memory_kb"
msgstr ""

#: ../../../src/aiida/schedulers/plugins/pbsbaseclasses.py:docstring of aiida.schedulers.plugins.pbsbaseclasses.PbsBaseClass._get_resource_lines:8
msgid "max_wallclock_seconds"
msgstr ""

#: ../../../src/aiida/schedulers/plugins/pbsbaseclasses.py:docstring of aiida.schedulers.plugins.pbsbaseclasses.PbsBaseClass._get_resource_lines:10
msgid "This is done in an external function because it may change in different subclasses."
msgstr ""

#: ../../../src/aiida/schedulers/plugins/pbsbaseclasses.py:docstring of aiida.schedulers.plugins.pbsbaseclasses.PbsBaseClass._get_submit_command:6
#: ../../../src/aiida/schedulers/plugins/sge.py:docstring of aiida.schedulers.plugins.sge.SgeScheduler._get_submit_command:6
#: ../../../src/aiida/schedulers/plugins/slurm.py:docstring of aiida.schedulers.plugins.slurm.SlurmScheduler._get_submit_command:6
msgid "submit_script: the path of the submit script relative to the working"
msgstr ""

#: ../../../src/aiida/schedulers/plugins/pbsbaseclasses.py:docstring of aiida.schedulers.plugins.pbsbaseclasses.PbsBaseClass._get_submit_command:6
#: ../../../src/aiida/schedulers/plugins/sge.py:docstring of aiida.schedulers.plugins.sge.SgeScheduler._get_submit_command:6
#: ../../../src/aiida/schedulers/plugins/slurm.py:docstring of aiida.schedulers.plugins.slurm.SlurmScheduler._get_submit_command:6
msgid "directory. IMPORTANT: submit_script should be already escaped."
msgstr ""

#: ../../../src/aiida/schedulers/plugins/pbsbaseclasses.py:docstring of aiida.schedulers.plugins.pbsbaseclasses.PbsBaseClass._get_submit_script_header:8
#: ../../../src/aiida/schedulers/plugins/sge.py:docstring of aiida.schedulers.plugins.sge.SgeScheduler._get_submit_script_header:8
#: ../../../src/aiida/schedulers/plugins/slurm.py:docstring of aiida.schedulers.plugins.slurm.SlurmScheduler._get_submit_script_header:8
msgid "TODO: truncate the title if too long"
msgstr ""

#: ../../../src/aiida/schedulers/plugins/pbsbaseclasses.py:docstring of aiida.schedulers.plugins.pbsbaseclasses.PbsBaseClass._parse_time_string:1
#: ../../../src/aiida/schedulers/plugins/slurm.py:docstring of aiida.schedulers.plugins.slurm.SlurmScheduler._parse_time_string:1
msgid "Parse a time string in the format returned from qstat -f and returns a datetime object."
msgstr ""

#: ../../../src/aiida/schedulers/plugins/pbsbaseclasses.py:docstring of aiida.schedulers.plugins.pbsbaseclasses.PbsJobResource:1
msgid "Class for PBS job resources."
msgstr ""

#: ../../../src/aiida/schedulers/plugins/pbsbaseclasses.py:docstring of aiida.schedulers.plugins.pbsbaseclasses.PbsJobResource.validate_resources:3
msgid "This extends the base class validator and calculates the `num_cores_per_machine` fields to pass to PBSlike schedulers. Checks that `num_cores_per_machine` is a multiple of `num_cores_per_mpiproc` and/or `num_mpiprocs_per_machine`."
msgstr ""

#: ../../../src/aiida/schedulers/plugins/pbspro.py:docstring of aiida.schedulers.plugins.pbspro:1
msgid "Plugin for PBSPro. This has been tested on PBSPro v. 12."
msgstr ""

#: ../../../src/aiida/schedulers/plugins/pbspro.py:docstring of aiida.schedulers.plugins.pbspro.PbsproScheduler:1
#: ../../../src/aiida/schedulers/plugins/torque.py:docstring of aiida.schedulers.plugins.torque.TorqueScheduler:1
msgid "Bases: :py:class:`~aiida.schedulers.plugins.pbsbaseclasses.PbsBaseClass`"
msgstr ""

#: ../../../src/aiida/schedulers/plugins/pbspro.py:docstring of aiida.schedulers.plugins.pbspro.PbsproScheduler:1
msgid "Subclass to support the PBSPro scheduler (http://www.pbsworks.com/)."
msgstr ""

#: ../../../src/aiida/schedulers/plugins/pbspro.py:docstring of aiida.schedulers.plugins.pbspro.PbsproScheduler:4
#: ../../../src/aiida/schedulers/plugins/torque.py:docstring of aiida.schedulers.plugins.torque.TorqueScheduler:3
msgid "I redefine only what needs to change from the base class"
msgstr ""

#: ../../../src/aiida/schedulers/plugins/pbspro.py:docstring of aiida.schedulers.plugins.pbspro.PbsproScheduler._get_resource_lines:1
#: ../../../src/aiida/schedulers/plugins/torque.py:docstring of aiida.schedulers.plugins.torque.TorqueScheduler._get_resource_lines:1
msgid "Return the lines for machines, memory and wallclock relative to pbspro."
msgstr ""

#: ../../../src/aiida/schedulers/plugins/sge.py:docstring of aiida.schedulers.plugins.sge:1
msgid "Plugin for SGE. This has been tested on GE 6.2u3."
msgstr ""

#: ../../../src/aiida/schedulers/plugins/sge.py:docstring of aiida.schedulers.plugins.sge:4
msgid "Plugin originally written by Marco Dorigo. Email: marco(DOT)dorigo(AT)rub(DOT)de"
msgstr ""

#: ../../../src/aiida/schedulers/plugins/sge.py:docstring of aiida.schedulers.plugins.sge.SgeJobResource:1
msgid "Bases: :py:class:`~aiida.schedulers.datastructures.ParEnvJobResource`"
msgstr ""

#: ../../../src/aiida/schedulers/plugins/sge.py:docstring of aiida.schedulers.plugins.sge.SgeScheduler:1
msgid "Support for the Sun Grid Engine scheduler and its variants/forks (Son of Grid Engine, Oracle Grid Engine, ...)"
msgstr ""

#: ../../../src/aiida/schedulers/plugins/sge.py:docstring of aiida.schedulers.plugins.sge.SgeScheduler._get_joblist_command:6
msgid "!!!ALL COPIED FROM PBSPRO!!! TODO: understand if it is worth escaping the username, or rather leave it unescaped to allow to pass $USER"
msgstr ""

#: ../../../src/aiida/schedulers/plugins/sge.py:docstring of aiida.schedulers.plugins.sge.SgeScheduler._parse_time_string:1
msgid "Parse a time string in the format returned from qstat -xml -ext and returns a datetime object. Example format: 2013-06-13T11:53:11"
msgstr ""

#: ../../../src/aiida/schedulers/plugins/slurm.py:docstring of aiida.schedulers.plugins.slurm:1
msgid "Plugin for SLURM. This has been tested on SLURM 14.03.7 on the CSCS.ch machines."
msgstr ""

#: ../../../src/aiida/schedulers/plugins/slurm.py:docstring of aiida.schedulers.plugins.slurm.SlurmJobResource:1
msgid "Class for SLURM job resources."
msgstr ""

#: ../../../src/aiida/schedulers/plugins/slurm.py:docstring of aiida.schedulers.plugins.slurm.SlurmJobResource.validate_resources:3
msgid "This extends the base class validator to check that the `num_cores_per_machine` are a multiple of `num_cores_per_mpiproc` and/or `num_mpiprocs_per_machine`."
msgstr ""

#: ../../../src/aiida/schedulers/plugins/slurm.py:docstring of aiida.schedulers.plugins.slurm.SlurmScheduler:1
msgid "Support for the SLURM scheduler (http://slurm.schedmd.com/)."
msgstr ""

#: ../../../src/aiida/schedulers/plugins/slurm.py:docstring of aiida.schedulers.plugins.slurm.SlurmScheduler._convert_time:1
msgid "Convert a string in the format DD-HH:MM:SS to a number of seconds."
msgstr ""

#: ../../../src/aiida/schedulers/plugins/slurm.py:docstring of aiida.schedulers.plugins.slurm.SlurmScheduler._get_detailed_job_info_command:4
msgid "The output text is just retrieved, and returned for logging purposes. --parsable split the fields with a pipe (|), adding a pipe also at the end."
msgstr ""

#: ../../../src/aiida/schedulers/plugins/slurm.py:docstring of aiida.schedulers.plugins.slurm.SlurmScheduler._get_joblist_command:3
msgid "Separate the fields with the _field_separator string order: jobnum, state, walltime, queue[=partition], user, numnodes, numcores, title"
msgstr ""

#: ../../../src/aiida/schedulers/plugins/slurm.py:docstring of aiida.schedulers.plugins.slurm.SlurmScheduler.parse_output:9
msgid "if the passed arguments have incorrect type or value."
msgstr ""

#: ../../../src/aiida/schedulers/plugins/torque.py:docstring of aiida.schedulers.plugins.torque:1
msgid "Plugin for PBS/Torque. This has been tested on Torque v.2.4.16 (from Ubuntu)."
msgstr ""

#: ../../../src/aiida/schedulers/plugins/torque.py:docstring of aiida.schedulers.plugins.torque.TorqueScheduler:1
msgid "Subclass to support the Torque scheduler.."
msgstr ""

#: ../../source/reference/apidoc/aiida.sphinxext.rst:2
msgid "aiida.sphinxext package"
msgstr ""

#: ../../../src/aiida/sphinxext/__init__.py:docstring of aiida.sphinxext:1
msgid "Defines reStructuredText directives to simplify documenting AiiDA and its plugins."
msgstr ""

#: ../../../src/aiida/sphinxext/__init__.py:docstring of aiida.sphinxext.setup:1
msgid "Setup function to add the extension classes / nodes to Sphinx."
msgstr ""

#: ../../../src/aiida/sphinxext/calcjob.py:docstring of aiida.sphinxext.calcjob:1
msgid "Defines an rst directive to auto-document AiiDA calculation job."
msgstr ""

#: ../../../src/aiida/sphinxext/calcjob.py:docstring of aiida.sphinxext.calcjob.AiidaCalcJobDirective:1
#: ../../../src/aiida/sphinxext/workchain.py:docstring of aiida.sphinxext.workchain.AiidaWorkchainDirective:1
msgid "Bases: :py:class:`~aiida.sphinxext.process.AiidaProcessDirective`"
msgstr ""

#: ../../../src/aiida/sphinxext/calcjob.py:docstring of aiida.sphinxext.calcjob.AiidaCalcJobDocumenter:1
#: ../../../src/aiida/sphinxext/workchain.py:docstring of aiida.sphinxext.workchain.AiidaWorkChainDocumenter:1
msgid "Bases: :py:class:`~aiida.sphinxext.process.AiidaProcessDocumenter`"
msgstr ""

#: ../../../src/aiida/sphinxext/calcjob.py:docstring of aiida.sphinxext.calcjob.AiidaCalcJobDocumenter:1
msgid "Sphinx Documenter for AiiDA CalcJobs."
msgstr ""

#: ../../../src/aiida/sphinxext/calcjob.py:docstring of aiida.sphinxext.calcjob.AiidaCalcJobDocumenter.can_document_member:1
#: ../../../src/aiida/sphinxext/process.py:docstring of aiida.sphinxext.process.AiidaProcessDocumenter.can_document_member:1
#: ../../../src/aiida/sphinxext/workchain.py:docstring of aiida.sphinxext.workchain.AiidaWorkChainDocumenter.can_document_member:1
msgid "Called to see if a member can be documented by this Documenter."
msgstr ""

#: ../../docstring of aiida.sphinxext.calcjob.AiidaCalcJobDocumenter.objtype:1
#: ../../docstring of aiida.sphinxext.process.AiidaProcessDocumenter.objtype:1
#: ../../docstring of aiida.sphinxext.workchain.AiidaWorkChainDocumenter.objtype:1
msgid "name by which the directive is called (auto...) and the default generated directive name"
msgstr ""

#: ../../docstring of aiida.sphinxext.calcjob.AiidaCalcJobDocumenter.priority:1
#: ../../docstring of aiida.sphinxext.process.AiidaProcessDocumenter.priority:1
#: ../../docstring of aiida.sphinxext.workchain.AiidaWorkChainDocumenter.priority:1
msgid "priority if multiple documenters return True from can_document_member"
msgstr ""

#: ../../../src/aiida/sphinxext/process.py:docstring of aiida.sphinxext.process:1
msgid "Defines an rst directive to auto-document AiiDA processes."
msgstr ""

#: ../../../src/aiida/sphinxext/process.py:docstring of aiida.sphinxext.process.AiidaProcessDirective:1
msgid "Bases: :py:class:`~sphinx.util.docutils.SphinxDirective`"
msgstr ""

#: ../../../src/aiida/sphinxext/process.py:docstring of aiida.sphinxext.process.AiidaProcessDirective:1
msgid "Directive to auto-document AiiDA processes."
msgstr ""

#: ../../../src/aiida/sphinxext/process.py:docstring of aiida.sphinxext.process.AiidaProcessDirective.build_content:1
msgid "Returns the main content (docstring, inputs, outputs) of the documentation."
msgstr ""

#: ../../../src/aiida/sphinxext/process.py:docstring of aiida.sphinxext.process.AiidaProcessDirective.build_doctree:1
msgid "Returns a doctree for a given port namespace, including a title."
msgstr ""

#: ../../../src/aiida/sphinxext/process.py:docstring of aiida.sphinxext.process.AiidaProcessDirective.build_node_tree:1
msgid "Returns the docutils node tree."
msgstr ""

#: ../../../src/aiida/sphinxext/process.py:docstring of aiida.sphinxext.process.AiidaProcessDirective.build_outline_doctree:1
msgid "Build the doctree for a spec outline."
msgstr ""

#: ../../../src/aiida/sphinxext/process.py:docstring of aiida.sphinxext.process.AiidaProcessDirective.build_outline_lines:1
msgid "Return a list of lines which describe the process outline."
msgstr ""

#: ../../../src/aiida/sphinxext/process.py:docstring of aiida.sphinxext.process.AiidaProcessDirective.build_port_content:1
msgid "Build the content that describes a single port."
msgstr ""

#: ../../../src/aiida/sphinxext/process.py:docstring of aiida.sphinxext.process.AiidaProcessDirective.build_portnamespace_doctree:1
msgid "Builds the doctree for a port namespace."
msgstr ""

#: ../../../src/aiida/sphinxext/process.py:docstring of aiida.sphinxext.process.AiidaProcessDirective.build_signature:1
msgid "Returns the signature of the process."
msgstr ""

#: ../../docstring of aiida.sphinxext.process.AiidaProcessDirective.final_argument_whitespace:1
msgid "May the final argument contain whitespace?"
msgstr ""

#: ../../../src/aiida/sphinxext/process.py:docstring of aiida.sphinxext.process.AiidaProcessDirective.format_valid_types:1
msgid "Format valid types."
msgstr ""

#: ../../docstring of aiida.sphinxext.process.AiidaProcessDirective.has_content:1
msgid "May the directive have content?"
msgstr ""

#: ../../../src/aiida/sphinxext/process.py:docstring of aiida.sphinxext.process.AiidaProcessDirective.initialize:1
msgid "Set internal attributes of the class."
msgstr ""

#: ../../../src/aiida/sphinxext/process.py:docstring of aiida.sphinxext.process.AiidaProcessDirective.initialize:3
msgid "Includes importing the process class."
msgstr ""

#: ../../docstring of aiida.sphinxext.process.AiidaProcessDirective.option_spec:1
msgid "Mapping of option names to validator functions."
msgstr ""

#: ../../docstring of aiida.sphinxext.process.AiidaProcessDirective.optional_arguments:1
msgid "Number of optional arguments after the required arguments."
msgstr ""

#: ../../docstring of aiida.sphinxext.process.AiidaProcessDirective.required_arguments:1
msgid "Number of required directive arguments."
msgstr ""

#: ../../../src/aiida/sphinxext/process.py:docstring of aiida.sphinxext.process.AiidaProcessDocumenter:1
msgid "Bases: :py:class:`~sphinx.ext.autodoc.ClassDocumenter`"
msgstr ""

#: ../../../src/aiida/sphinxext/process.py:docstring of aiida.sphinxext.process.AiidaProcessDocumenter:1
msgid "Sphinx Documenter class for AiiDA Processes."
msgstr ""

#: ../../../src/aiida/sphinxext/workchain.py:docstring of aiida.sphinxext.workchain:1
msgid "Defines an rst directive to auto-document AiiDA workchains."
msgstr ""

#: ../../../src/aiida/sphinxext/workchain.py:docstring of aiida.sphinxext.workchain.AiidaWorkChainDocumenter:1
msgid "Sphinx Documenter class for AiiDA WorkChains."
msgstr ""

#: ../../source/reference/apidoc/aiida.storage.rst:2
msgid "aiida.storage package"
msgstr ""

#: ../../../src/aiida/storage/__init__.py:docstring of aiida.storage:1
msgid "Module for implementations of database backends."
msgstr ""

#: ../../../src/aiida/storage/log.py:docstring of aiida.storage.log:1
msgid "Initialize the storage logger."
msgstr ""

#: ../../source/reference/apidoc/aiida.storage.psql_dos.rst:2
msgid "aiida.storage.psql\\_dos package"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/__init__.py:docstring of aiida.storage.psql_dos:1
msgid "Module with implementation of the storage backend using PostGreSQL and the disk-objectstore."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/alembic_cli.py:docstring of aiida.storage.psql_dos.alembic_cli:1
msgid "Simple wrapper around the alembic command line tool that first loads an AiiDA profile."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/alembic_cli.py:docstring of aiida.storage.psql_dos.alembic_cli.AlembicRunner:1
msgid "Wrapper around the alembic command line tool that first loads an AiiDA profile."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/alembic_cli.py:docstring of aiida.storage.psql_dos.alembic_cli.AlembicRunner.execute_alembic_command:1
msgid "Execute an Alembic CLI command."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/alembic_cli.py:docstring of aiida.storage.psql_dos.alembic_cli.AlembicRunner.execute_alembic_command:3
msgid "the sub command name"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/alembic_cli.py:docstring of aiida.storage.psql_dos.alembic_cli.AlembicRunner.execute_alembic_command:4
msgid "parameters to pass to the command"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend:1
msgid "SqlAlchemy implementation of `aiida.orm.implementation.backends.Backend`."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend:1
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend:1
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend:1
msgid "Bases: :py:class:`~aiida.orm.implementation.storage_backend.StorageBackend`"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend:1
msgid "An AiiDA storage backend that stores data in a PostgreSQL database and disk-objectstore repository."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend:3
msgid "Note, there were originally two such backends, `sqlalchemy` and `django`. The `django` backend was removed, to consolidate access to this storage."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.Configuration:1
#: ../../../src/aiida/storage/sqlite_dos/backend.py:docstring of aiida.storage.sqlite_dos.backend.SqliteDosStorage.Configuration:1
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.Configuration:1
msgid "Model describing required information to configure an instance of the storage."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend._get_mapper_from_entity:1
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend._get_mapper_from_entity:1
msgid "Return the Sqlalchemy mapper and fields corresponding to the given entity."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend._get_mapper_from_entity:3
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend._get_mapper_from_entity:3
msgid "if True, the fields returned will include the primary key"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend._initialise_session:1
#: ../../../src/aiida/storage/sqlite_dos/backend.py:docstring of aiida.storage.sqlite_dos.backend.SqliteDosStorage._initialise_session:1
msgid "Initialise the SQLAlchemy session factory."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend._initialise_session:3
#: ../../../src/aiida/storage/sqlite_dos/backend.py:docstring of aiida.storage.sqlite_dos.backend.SqliteDosStorage._initialise_session:3
msgid "Only one session factory is ever associated with a given class instance, i.e. once the instance is closed, it cannot be reopened."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend._initialise_session:6
#: ../../../src/aiida/storage/sqlite_dos/backend.py:docstring of aiida.storage.sqlite_dos.backend.SqliteDosStorage._initialise_session:6
msgid "The session factory, returns a session that is bound to the current thread. Multi-thread support is currently required by the REST API. Although, in the future, we may want to move the multi-thread handling to higher in the AiiDA stack."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.delete:3
msgid "Also delete the database user. This is ``False`` by default because the user may be used by other databases."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.get_backend_entity:1
msgid "Return the backend entity that corresponds to the given Model instance"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.get_backend_entity:3
msgid "the ORM model instance to promote to a backend instance"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.get_backend_entity:4
msgid "the backend entity corresponding to the given model"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.get_session:1
msgid "Return an SQLAlchemy session bound to the current thread."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.get_unreferenced_keyset:1
msgid "Returns the keyset of objects that exist in the repository but are not tracked by AiiDA."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.get_unreferenced_keyset:3
msgid "This should be all the soft-deleted files."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.get_unreferenced_keyset:5
msgid "toggle for a check that raises if there are references in the database with no actual object in the underlying repository."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.get_unreferenced_keyset:9
msgid "a set with all the objects in the underlying repository that are not referenced in the database."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.transaction:1
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.transaction:1
msgid "Open a transaction to be used as a context manager."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.PsqlDosBackend.transaction:3
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.transaction:3
msgid "If there is an exception within the context then the changes will be rolled back and the state will be as before entering. Transactions can be nested."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/backend.py:docstring of aiida.storage.psql_dos.backend.get_filepath_container:1
msgid "Return the filepath of the disk-object store container."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator:1
msgid "Schema validation and migration utilities."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator:3
msgid "This code interacts directly with the database, outside of the ORM, taking a `Profile` as input for the connection configuration."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator:6
msgid "This code should only be accessed via the storage backend class, not directly!"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator:1
msgid "Class for validating and migrating `psql_dos` storage instances."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator:3
msgid "This class should only be accessed via the storage backend class (apart from for test purposes)"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator._alembic_config:1
#: ../../../src/aiida/storage/sqlite_zip/migrator.py:docstring of aiida.storage.sqlite_zip.migrator._alembic_config:1
msgid "Return an instance of an Alembic `Config`."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator._alembic_connect:1
#: ../../../src/aiida/storage/sqlite_zip/migrator.py:docstring of aiida.storage.sqlite_zip.migrator._alembic_connect:1
msgid "Context manager to return an instance of an Alembic configuration."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator._alembic_connect:3
#: ../../../src/aiida/storage/sqlite_zip/migrator.py:docstring of aiida.storage.sqlite_zip.migrator._alembic_connect:3
msgid "The profiles's database connection is added in the `attributes` property, through which it can then also be retrieved, also in the `env.py` file, which is run when the database is migrated."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator._alembic_script:1
#: ../../../src/aiida/storage/sqlite_zip/migrator.py:docstring of aiida.storage.sqlite_zip.migrator._alembic_script:1
msgid "Return an instance of an Alembic `ScriptDirectory`."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator._migration_context:1
#: ../../../src/aiida/storage/sqlite_zip/migrator.py:docstring of aiida.storage.sqlite_zip.migrator._migration_context:1
msgid "Context manager to return an instance of an Alembic migration context."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator._migration_context:3
#: ../../../src/aiida/storage/sqlite_zip/migrator.py:docstring of aiida.storage.sqlite_zip.migrator._migration_context:3
msgid "This migration context will have been configured with the current database connection, which allows this context to be used to inspect the contents of the database, such as the current revision."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator.close:1
msgid "Close the connection if it was opened and dispose of the engine."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator.connection:1
msgid "Return the connection to the database."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator.connection:3
msgid "Will automatically create the engine and open an connection if not already opened in a previous call."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator.connection:5
msgid "Open connection to the database."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator.connection:6
msgid ":class:`aiida.common.exceptions.UnreachableStorage` if connecting to the database fails."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator.delete_all_tables:1
msgid "Delete all tables of the current database schema."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator.delete_all_tables:3
msgid "The tables are determined dynamically through reflection of the current schema version. Any other tables in the database that are not part of the schema should remain unaffected."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator.delete_all_tables:6
msgid "Optional list of table names that should not be deleted."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator.get_container:1
#: ../../../src/aiida/storage/sqlite_dos/backend.py:docstring of aiida.storage.sqlite_dos.backend.SqliteDosMigrator.get_container:1
msgid "Return the disk-object store container."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator.get_container:3
#: ../../../src/aiida/storage/sqlite_dos/backend.py:docstring of aiida.storage.sqlite_dos.backend.SqliteDosMigrator.get_container:3
msgid "The disk-object store container configured for the repository path of the current profile."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator.get_current_table:1
msgid "Return a table instantiated at the correct migration."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator.get_current_table:3
msgid "Note that this is obtained by inspecting the database and not by looking into the models file. So, special methods possibly defined in the models files/classes are not present."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator.get_repository_uuid:1
msgid "Return the UUID of the repository."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator.get_repository_uuid:3
msgid "The repository UUID."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator.get_repository_uuid:4
msgid ":class:`~aiida.common.exceptions.UnreachableStorage` if the UUID cannot be retrieved, which probably means that the repository is not initialised."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator.get_schema_version_head:1
#: ../../../src/aiida/storage/sqlite_zip/migrator.py:docstring of aiida.storage.sqlite_zip.migrator.get_schema_version_head:1
msgid "Return the head schema version for this storage, i.e. the latest schema this storage can be migrated to."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator.get_schema_version_profile:1
msgid "Return the schema version of the backend instance for this profile."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator.get_schema_version_profile:3
msgid "Note, the version will be None if the database is empty or is a legacy django database."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator.get_schema_versions:1
#: ../../../src/aiida/storage/sqlite_zip/migrator.py:docstring of aiida.storage.sqlite_zip.migrator.list_versions:1
msgid "Return all available schema versions (oldest to latest)."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator.get_schema_versions:3
msgid "schema version -> description"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator.initialise_database:1
#: ../../../src/aiida/storage/sqlite_dos/backend.py:docstring of aiida.storage.sqlite_dos.backend.SqliteDosMigrator.initialise_database:1
msgid "Initialise the database."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator.initialise_database:3
#: ../../../src/aiida/storage/sqlite_dos/backend.py:docstring of aiida.storage.sqlite_dos.backend.SqliteDosMigrator.initialise_database:3
msgid "This assumes that the database has no schema whatsoever and so the initial schema is created directly from the models at the current head version without migrating through all of them one by one."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator.initialise_repository:1
msgid "Initialise the repository."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator.is_database_initialised:1
msgid "Return whether the database is initialised."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator.is_database_initialised:3
msgid "This is the case if it contains the table that holds the schema version for alembic or Django."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator.is_database_initialised:5
msgid "``True`` if the database is initialised, ``False`` otherwise."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator.is_initialised:1
msgid "Return whether the storage is initialised."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator.is_initialised:3
msgid "This is the case if both the database and the repository are initialised."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator.is_initialised:5
msgid "``True`` if the storage is initialised, ``False`` otherwise."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator.is_repository_initialised:1
msgid "Return whether the repository is initialised."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator.is_repository_initialised:3
msgid "``True`` if the repository is initialised, ``False`` otherwise."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator.migrate:1
msgid "Migrate the storage for this profile to the head version."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator.migrate:3
msgid ":class:`~aiida.common.exceptions.UnreachableStorage` if the storage cannot be accessed."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator.migrate_down:1
msgid "Migrate the database down to a specific version."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator.migrate_down:3
#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator.migrate_up:3
msgid "string with schema version to migrate to"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator.migrate_up:1
msgid "Migrate the database up to a specific version."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator.reset_database:1
msgid "Reset the database by deleting all content from all tables."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator.reset_database:3
msgid "This will also destroy the settings table and so in order to use it again, it will have to be reinitialised."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator.reset_repository:1
msgid "Reset the repository by deleting all of its contents."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator.reset_repository:3
msgid "This will also destroy the configuration and so in order to use it again, it will have to be reinitialised."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator.session:1
msgid "Context manager to return a session for the database."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator.validate_storage:1
msgid "Validate that the storage for this profile"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator.validate_storage:3
msgid "That the database schema is at the head version, i.e. is compatible with the code API."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator.validate_storage:4
msgid "That the repository ID is equal to the UUID set in the database"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator.validate_storage:6
msgid ":class:`aiida.common.exceptions.UnreachableStorage` if the storage cannot be connected to"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator.validate_storage:7
#: ../../../src/aiida/storage/sqlite_zip/migrator.py:docstring of aiida.storage.sqlite_zip.migrator.validate_storage:6
msgid ":class:`aiida.common.exceptions.IncompatibleStorageSchema` if the storage is not compatible with the code API."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrator.py:docstring of aiida.storage.psql_dos.migrator.PsqlDosMigrator.validate_storage:9
msgid ":class:`aiida.common.exceptions.CorruptStorage` if the repository ID is not equal to the UUID set in thedatabase."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/utils.py:docstring of aiida.storage.psql_dos.utils:1
msgid "Utility functions specific to the SqlAlchemy backend."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/utils.py:docstring of aiida.storage.psql_dos.utils.PsqlConfig:1
msgid "Configuration to connect to a PostgreSQL database."
msgstr ""

#: ../../docstring of aiida.storage.psql_dos.utils.PsqlConfig.engine_kwargs:1
msgid "keyword argument that will be passed on to the SQLAlchemy engine."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/utils.py:docstring of aiida.storage.psql_dos.utils.create_scoped_session_factory:1
msgid "Create scoped SQLAlchemy session factory"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/utils.py:docstring of aiida.storage.psql_dos.utils.create_sqlalchemy_engine:1
msgid "Create SQLAlchemy engine (to be used for QueryBuilder queries)"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/utils.py:docstring of aiida.storage.psql_dos.utils.create_sqlalchemy_engine:3
msgid "keyword arguments that will be passed on to `sqlalchemy.create_engine`. See https://docs.sqlalchemy.org/en/13/core/engines.html?highlight=create_engine#sqlalchemy.create_engine for more info."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/utils.py:docstring of aiida.storage.psql_dos.utils.flag_modified:1
msgid "Wrapper around `sqlalchemy.orm.attributes.flag_modified` to correctly dereference utils.ModelWrapper"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/utils.py:docstring of aiida.storage.psql_dos.utils.flag_modified:3
msgid "Since SqlAlchemy 1.2.12 (and maybe earlier but not in 1.0.19) the flag_modified function will check that the key is actually present in the instance or it will except. If we pass a model instance, wrapped in the ModelWrapper the call will raise an InvalidRequestError. In this function that wraps the flag_modified of SqlAlchemy, we derefence the model instance if the passed instance is actually wrapped in the ModelWrapper."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/utils.py:docstring of aiida.storage.psql_dos.utils.get_pg_tc:1
msgid "Return the transitive closure table template"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/utils.py:docstring of aiida.storage.psql_dos.utils.install_tc:1
msgid "Install the transitive closure table with SqlAlchemy."
msgstr ""

#: ../../source/reference/apidoc/aiida.storage.psql_dos.migrations.rst:2
msgid "aiida.storage.psql\\_dos.migrations package"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/env.py:docstring of aiida.storage.psql_dos.migrations.env:1
#: ../../../src/aiida/storage/sqlite_zip/migrations/env.py:docstring of aiida.storage.sqlite_zip.migrations.env:1
msgid "Upper level SQLAlchemy migration funcitons."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/env.py:docstring of aiida.storage.psql_dos.migrations.env.run_migrations_online:1
#: ../../../src/aiida/storage/sqlite_zip/migrations/env.py:docstring of aiida.storage.sqlite_zip.migrations.env.run_migrations_online:1
msgid "Run migrations in 'online' mode."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/env.py:docstring of aiida.storage.psql_dos.migrations.env.run_migrations_online:3
#: ../../../src/aiida/storage/sqlite_zip/migrations/env.py:docstring of aiida.storage.sqlite_zip.migrations.env.run_migrations_online:3
msgid "The connection should have been passed to the config, which we use to configue the migration context."
msgstr ""

#: ../../source/reference/apidoc/aiida.storage.psql_dos.migrations.utils.rst:2
msgid "aiida.storage.psql\\_dos.migrations.utils package"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/__init__.py:docstring of aiida.storage.psql_dos.migrations.utils:1
msgid "Utilities to perform the migrations."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/calc_state.py:docstring of aiida.storage.psql_dos.migrations.utils.calc_state:1
msgid "Data structures for mapping legacy `JobCalculation` data to new process attributes."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/calc_state.py:docstring of namedtuple_StateMapping.StateMapping.__new__:1
msgid "Create new instance of StateMapping(state, process_state, exit_status, process_status)"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/calc_state.py:docstring of collections.StateMapping._make:1
msgid "Make a new StateMapping object from a sequence or iterable"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/calc_state.py:docstring of collections.StateMapping._replace:1
msgid "Return a new StateMapping object replacing specified fields with new values"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/create_dbattribute.py:docstring of aiida.storage.psql_dos.migrations.utils.create_dbattribute:1
#: ../../../src/aiida/storage/psql_dos/migrations/utils/create_dbattribute.py:docstring of aiida.storage.psql_dos.migrations.utils.create_dbattribute.create_rows:1
msgid "Create an old style node attribute/extra, via the `db_dbattribute`/`db_dbextra` tables."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/create_dbattribute.py:docstring of aiida.storage.psql_dos.migrations.utils.create_dbattribute:3
msgid "Adapted from: `aiida/backends/djsite/db/migrations/__init__.py`"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/create_dbattribute.py:docstring of aiida.storage.psql_dos.migrations.utils.create_dbattribute.create_rows:3
msgid "No hits are done on the DB, in particular no check is done on the existence of the given nodes."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/create_dbattribute.py:docstring of aiida.storage.psql_dos.migrations.utils.create_dbattribute.create_rows:6
msgid "a string with the key to create (can contain the separator self._sep if this is a sub-attribute: indeed, this function calls itself recursively)"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/create_dbattribute.py:docstring of aiida.storage.psql_dos.migrations.utils.create_dbattribute.create_rows:9
msgid "the value to store (a basic data type or a list or a dict)"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/create_dbattribute.py:docstring of aiida.storage.psql_dos.migrations.utils.create_dbattribute.create_rows:10
msgid "the node id to store the attribute/extra"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/create_dbattribute.py:docstring of aiida.storage.psql_dos.migrations.utils.create_dbattribute.create_rows:12
msgid "A list of column name -> value dictionaries, with which to instantiate database rows"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/dblog_update.py:docstring of aiida.storage.psql_dos.migrations.utils.dblog_update:1
msgid "Shared function for django_0024 and sqlalchemy ea2f50e7f615"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/dblog_update.py:docstring of aiida.storage.psql_dos.migrations.utils.dblog_update.export_and_clean_workflow_logs:1
msgid "Export the logs records that correspond to legacy workflows and to unknown entities (place them to files and remove them from the DbLog table)."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/dblog_update.py:docstring of aiida.storage.psql_dos.migrations.utils.dblog_update.get_legacy_workflow_log_number:1
msgid "Get the number of the log records that correspond to legacy workflows"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/dblog_update.py:docstring of aiida.storage.psql_dos.migrations.utils.dblog_update.get_logs_with_no_nodes_number:1
msgid "Get the number of the log records that correspond to nodes that were deleted"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/dblog_update.py:docstring of aiida.storage.psql_dos.migrations.utils.dblog_update.get_serialized_legacy_workflow_logs:1
msgid "Get the serialized log records that correspond to legacy workflows"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/dblog_update.py:docstring of aiida.storage.psql_dos.migrations.utils.dblog_update.get_serialized_logs_with_no_nodes:1
msgid "Get the serialized log records that correspond to nodes that were deleted"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/dblog_update.py:docstring of aiida.storage.psql_dos.migrations.utils.dblog_update.get_serialized_unknown_entity_logs:1
msgid "Get the serialized log records that correspond to unknown entities"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/dblog_update.py:docstring of aiida.storage.psql_dos.migrations.utils.dblog_update.get_unknown_entity_log_number:1
msgid "Get the number of the log records that correspond to unknown entities"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/dblog_update.py:docstring of aiida.storage.psql_dos.migrations.utils.dblog_update.set_new_uuid:1
msgid "Set new and distinct UUIDs to all the logs"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/duplicate_uuids.py:docstring of aiida.storage.psql_dos.migrations.utils.duplicate_uuids:1
msgid "Generic functions to verify the integrity of the database and optionally apply patches to fix problems."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/duplicate_uuids.py:docstring of aiida.storage.psql_dos.migrations.utils.duplicate_uuids._get_duplicate_uuids:1
#: ../../../src/aiida/storage/psql_dos/migrations/utils/duplicate_uuids.py:docstring of aiida.storage.psql_dos.migrations.utils.duplicate_uuids.verify_uuid_uniqueness:1
msgid "Check whether database table contains rows with duplicate UUIDS."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/integrity.py:docstring of aiida.storage.psql_dos.migrations.utils.integrity:1
msgid "Methods to validate the database integrity and fix violations."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/integrity.py:docstring of aiida.storage.psql_dos.migrations.utils.integrity.drop_hashes:1
msgid "Drop hashes of nodes."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/integrity.py:docstring of aiida.storage.psql_dos.migrations.utils.integrity.drop_hashes:3
msgid "Print warning only if the DB actually contains nodes."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/integrity.py:docstring of aiida.storage.psql_dos.migrations.utils.integrity.drop_hashes:5
msgid "The key in the extras used to store the hash at the time of this migration."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/integrity.py:docstring of aiida.storage.psql_dos.migrations.utils.integrity.drop_hashes:6
msgid "Optional entry point string of a node type to narrow the subset of nodes to reset. The value should be a complete entry point string, e.g., ``aiida.node:process.calculation.calcjob`` to drop the hash of all ``CalcJobNode`` rows."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/integrity.py:docstring of aiida.storage.psql_dos.migrations.utils.integrity.infer_calculation_entry_point:1
msgid "Try to infer a calculation entry point name for all the calculation type strings that are found in the database."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/integrity.py:docstring of aiida.storage.psql_dos.migrations.utils.integrity.infer_calculation_entry_point:3
msgid "Before the plugin system was introduced, the `type` column of the node table was a string based on the base node type with the module path and class name appended. For example, for the `PwCalculation` class, which was a sub class of `JobCalculation`, would get `calculation.job.quantumespresso.pw.PwCalculation.` as its `type` string. At this point, the `JobCalculation` also still fullfilled the role of both the `Process` class as well as the `Node` class. In the migration for `v1.0.0`, this had to be migrated, where the `type` became that of the actual node i.e. `node.process.calculation.calcjob.CalcJobNode.` which would lose the information of which actual sub class it represented. This information should be stored in the `process_type` column, where the value is the name of the entry point of that calculation class."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/integrity.py:docstring of aiida.storage.psql_dos.migrations.utils.integrity.infer_calculation_entry_point:12
msgid "This function will, for a given set of calculation type strings of pre v1.0.0, try to map them on the known entry points for the calculation category. This is the union of those entry points registered at the AiiDA registry (see the mapping above) and those available in the environment in which this function is ran."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/integrity.py:docstring of aiida.storage.psql_dos.migrations.utils.integrity.infer_calculation_entry_point:16
msgid "If a type string cannot be mapped onto an entry point name, a fallback `process_type` string will be generated which is based on part of the old `type` string. For example, `calculation.job.unknown.UnknownCalculation.` would get the process type string `~unknown.UnknownCalculation`."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/integrity.py:docstring of aiida.storage.psql_dos.migrations.utils.integrity.infer_calculation_entry_point:20
msgid "The function will return a mapping of type strings onto their inferred process type strings."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/integrity.py:docstring of aiida.storage.psql_dos.migrations.utils.integrity.infer_calculation_entry_point:22
msgid "a set of type strings whose entry point is to be inferred"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/integrity.py:docstring of aiida.storage.psql_dos.migrations.utils.integrity.infer_calculation_entry_point:23
msgid "a mapping of current node type string to the inferred entry point name"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/integrity.py:docstring of aiida.storage.psql_dos.migrations.utils.integrity.write_database_integrity_violation:1
msgid "Emit a integrity violation warning and write the violating records to a log file in the current directory"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/integrity.py:docstring of aiida.storage.psql_dos.migrations.utils.integrity.write_database_integrity_violation:3
msgid "a list of tuples representing the violating records"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/integrity.py:docstring of aiida.storage.psql_dos.migrations.utils.integrity.write_database_integrity_violation:4
msgid "a tuple of strings that will be used as a header for the log file. Should have the same length as each tuple in the results list."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/integrity.py:docstring of aiida.storage.psql_dos.migrations.utils.integrity.write_database_integrity_violation:6
msgid "a human readable message detailing the reason of the integrity violation"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/integrity.py:docstring of aiida.storage.psql_dos.migrations.utils.integrity.write_database_integrity_violation:7
msgid "an optional human readable message detailing a performed action, if any"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/legacy_workflows.py:docstring of aiida.storage.psql_dos.migrations.utils.legacy_workflows:1
msgid "Utilities for removing legacy workflows."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/legacy_workflows.py:docstring of aiida.storage.psql_dos.migrations.utils.legacy_workflows.export_workflow_data:1
msgid "Export existing legacy workflow data to a JSON file."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/legacy_workflows.py:docstring of aiida.storage.psql_dos.migrations.utils.legacy_workflows.json_serializer:1
msgid "JSON serializer for objects not serializable by default json code"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/migrate_repository.py:docstring of aiida.storage.psql_dos.migrations.utils.migrate_repository:1
msgid "\"Migrate the file repository to the new disk object store based implementation."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/migrate_repository.py:docstring of aiida.storage.psql_dos.migrations.utils.migrate_repository.migrate_repository:1
#: ../../../src/aiida/storage/sqlite_zip/migrations/versions/main_0000_initial.py:docstring of aiida.storage.sqlite_zip.migrations.versions.main_0000_initial.upgrade:1
#: ../../../src/aiida/storage/sqlite_zip/migrations/versions/main_0001.py:docstring of aiida.storage.sqlite_zip.migrations.versions.main_0001.upgrade:1
msgid "Migrations for the upgrade."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/parity.py:docstring of aiida.storage.psql_dos.migrations.utils.parity:1
msgid "Utilities for synchronizing the django and sqlalchemy schema."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/parity.py:docstring of aiida.storage.psql_dos.migrations.utils.parity.synchronize_schemas:1
msgid "This function is used by the final migration step, of django/sqlalchemy branches, to synchronize their schemas."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/parity.py:docstring of aiida.storage.psql_dos.migrations.utils.parity.synchronize_schemas:3
msgid "Remove and recreate all (non-unique) indexes, with standard names and postgresql ops."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/parity.py:docstring of aiida.storage.psql_dos.migrations.utils.parity.synchronize_schemas:4
msgid "Remove and recreate all unique constraints, with standard names."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/parity.py:docstring of aiida.storage.psql_dos.migrations.utils.parity.synchronize_schemas:5
msgid "Remove and recreate all foreign key constraints, with standard names and other rules."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/parity.py:docstring of aiida.storage.psql_dos.migrations.utils.parity.synchronize_schemas:7
msgid "Schema naming conventions are defined ``aiida/storage/sqlalchemy/models/base.py::naming_convention``."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/parity.py:docstring of aiida.storage.psql_dos.migrations.utils.parity.synchronize_schemas:9
msgid "Note we assume here that (a) all primary keys are already correct, and (b) there are no check constraints."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/provenance_redesign.py:docstring of aiida.storage.psql_dos.migrations.utils.provenance_redesign:1
msgid "SQL statements to detect invalid/understood links for the provenance redesign migration."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/provenance_redesign.py:docstring of aiida.storage.psql_dos.migrations.utils.provenance_redesign.detect_unexpected_links:1
msgid "Scan the database for any links that are unexpected."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/provenance_redesign.py:docstring of aiida.storage.psql_dos.migrations.utils.provenance_redesign.detect_unexpected_links:3
msgid "The checks will verify that there are no outgoing `call` or `return` links from calculation nodes and that if a workflow node has a `create` link, it has at least an accompanying return link to the same data node, or it has a `call` link to a calculation node that takes the created data node as input."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/provenance_redesign.py:docstring of aiida.storage.psql_dos.migrations.utils.provenance_redesign.migrate_infer_calculation_entry_point:1
msgid "Set the process type for calculation nodes by inferring it from their type string."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/reflect.py:docstring of aiida.storage.psql_dos.migrations.utils.reflect:1
msgid "Utility for performing schema migrations, via reflection of the current database."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/reflect.py:docstring of aiida.storage.psql_dos.migrations.utils.reflect.ReflectMigrations:1
msgid "Perform schema migrations, via reflection of the current database."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/reflect.py:docstring of aiida.storage.psql_dos.migrations.utils.reflect.ReflectMigrations:3
msgid "In django, it is not possible to explicitly specify constraints/indexes and their names, instead they are implicitly created by internal \"auto-generation\" code (as opposed to sqlalchemy, where one can explicitly specify the names). For a specific django version, this auto-generation code is deterministic, however, over time it has changed. So is not possible to know declaratively exactly what constraints/indexes are present on a users database, withtout knowing the exact django version that created it (and run migrations). Therefore, we need to reflect the database's schema, to determine what is present on the database, to know what to drop."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/reflect.py:docstring of aiida.storage.psql_dos.migrations.utils.reflect.ReflectMigrations.drop_all_foreign_keys:1
msgid "Drop all foreign keys set for this table."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/reflect.py:docstring of aiida.storage.psql_dos.migrations.utils.reflect.ReflectMigrations.drop_all_indexes:1
msgid "Drop all non-unique indexes set for this table."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/reflect.py:docstring of aiida.storage.psql_dos.migrations.utils.reflect.ReflectMigrations.drop_all_unique_constraints:1
msgid "Drop all unique constraints set for this table."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/reflect.py:docstring of aiida.storage.psql_dos.migrations.utils.reflect.ReflectMigrations.drop_foreign_keys:1
msgid "Drop all foreign keys set for this column name group and referring column set."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/reflect.py:docstring of aiida.storage.psql_dos.migrations.utils.reflect.ReflectMigrations.drop_indexes:1
msgid "Drop all indexes set for this column name group."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/reflect.py:docstring of aiida.storage.psql_dos.migrations.utils.reflect.ReflectMigrations.drop_unique_constraints:1
msgid "Drop all unique constraints set for this column name group."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/reflect.py:docstring of aiida.storage.psql_dos.migrations.utils.reflect.ReflectMigrations.replace_foreign_key:1
msgid "Create foreign key, dropping any existing foreign key with the same constraints."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/reflect.py:docstring of aiida.storage.psql_dos.migrations.utils.reflect.ReflectMigrations.replace_index:1
msgid "Create index, dropping any existing index with the same table+columns."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/reflect.py:docstring of aiida.storage.psql_dos.migrations.utils.reflect.ReflectMigrations.replace_unique_constraint:1
msgid "Create unique constraint, dropping any existing unique constraint with the same table+columns."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/reflect.py:docstring of aiida.storage.psql_dos.migrations.utils.reflect.ReflectMigrations.reset_cache:1
msgid "Reset the inspector cache."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils:1
msgid "Various utils that should be used during migrations and migrations tests because the AiiDA ORM cannot be used."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.LazyFile:1
msgid "Bases: :py:class:`~aiida.repository.common.File`"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.LazyFile:1
msgid "Subclass of `File` where `key` also allows `LazyOpener` in addition to a string."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.LazyFile:3
msgid "This subclass is necessary because the migration will be storing instances of `LazyOpener` as the `key` which should normally only be a string. This subclass updates the `key` type check to allow this."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.MigrationRepository:1
msgid "Bases: :py:class:`~aiida.repository.repository.Repository`"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.MigrationRepository:1
msgid "Subclass of `Repository` that uses `LazyFile` instead of `File` as its file class."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.NoopRepositoryBackend:1
msgid "Implementation of the ``AbstractRepositoryBackend`` where all write operations are no-ops."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.NoopRepositoryBackend:3
msgid "This repository backend is used to use the ``Repository`` interface to build repository metadata but instead of actually writing the content of the current repository to disk elsewhere, it will simply open a lazy file opener. In a subsequent step, all these streams are passed to the new Disk Object Store that will write their content directly to pack files for optimal efficiency."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.delete_numpy_array_from_repository:1
msgid "Delete the numpy array with a given name from the repository corresponding to a node with a given uuid."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.delete_numpy_array_from_repository:3
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.get_numpy_array_absolute_path:3
msgid "the UUID of the node"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.delete_numpy_array_from_repository:4
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.get_numpy_array_absolute_path:4
msgid "the name of the numpy array"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.dumps_json:1
msgid "Transforms all datetime object into isoformat and then returns the JSON."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.ensure_repository_folder_created:1
msgid "Make sure that the repository sub folder for the node with the given UUID exists or create it."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.ensure_repository_folder_created:3
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.get_node_repository_sub_folder:3
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.put_object_from_string:3
msgid "UUID of the node"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.get_node_repository_dirpaths:1
msgid "Return a mapping of node UUIDs onto the path to their current repository folder in the old repository."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.get_node_repository_dirpaths:3
msgid "the absolute path of the base folder of the old file repository."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.get_node_repository_dirpaths:4
msgid "optional shard to define which first shard level to check. If `None`, all shard levels are checked."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.get_node_repository_dirpaths:5
msgid "dictionary of node UUID onto absolute filepath and list of node repo missing one of the two known sub folders, ``path`` or ``raw_input``, which is unexpected."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.get_node_repository_dirpaths:7
msgid "if the repository contains node folders that contain both the `path` and `raw_input` subdirectories, which should never happen."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.get_node_repository_sub_folder:1
msgid "Return the absolute path to the sub folder `path` within the repository of the node with the given UUID."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.get_node_repository_sub_folder:4
msgid "absolute path to node repository folder, i.e `/some/path/repository/node/12/ab/c123134-a123/path`"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.get_numpy_array_absolute_path:1
msgid "Return the absolute path of a numpy array with the given name in the repository of the node with the given uuid."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.get_numpy_array_absolute_path:5
msgid "the absolute path of the numpy array file"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.get_repository_object:1
msgid "Return the content of an object stored in the disk object store repository for the given hashkey."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.load_numpy_array_from_repository:1
msgid "Load and return a numpy array from the repository folder of a node."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.load_numpy_array_from_repository:3
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.store_numpy_array_in_repository:3
msgid "the node UUID"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.load_numpy_array_from_repository:4
#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.store_numpy_array_in_repository:4
msgid "the name under which to store the array"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.load_numpy_array_from_repository:5
msgid "the numpy array"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.migrate_legacy_repository:1
msgid "Migrate the legacy file repository to the new disk object store and return mapping of repository metadata."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.migrate_legacy_repository:3
msgid "this method assumes that the new disk object store container has been initialized."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.migrate_legacy_repository:5
msgid "The format of the return value will be a dictionary where the keys are the UUIDs of the nodes whose repository folder has contents have been migrated to the disk object store. The values are the repository metadata that contain the keys for the generated files with which the files in the disk object store can be retrieved. The format of the repository metadata follows exactly that of what is generated normally by the ORM."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.migrate_legacy_repository:10
msgid "This implementation consciously uses the ``Repository`` interface in order to not have to rewrite the logic that builds the nested repository metadata based on the contents of a folder on disk. The advantage is that in this way it is guarantee that the exact same repository metadata is generated as it would have during normal operation. However, if the ``Repository`` interface or its implementation ever changes, it is possible that this solution will have to be adapted and the significant parts of the implementation will have to be copy pasted here."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.migrate_legacy_repository:16
msgid "mapping of node UUIDs onto the new repository metadata."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.put_object_from_string:1
msgid "Write a file with the given content in the repository sub folder of the given node."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.put_object_from_string:4
msgid "name to use for the file"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.put_object_from_string:5
msgid "the content to write to the file"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.recursive_datetime_to_isoformat:1
msgid "Convert all datetime objects in the given value to string representations in ISO format."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.recursive_datetime_to_isoformat:3
msgid "a mapping, sequence or single value optionally containing datetime objects"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.store_numpy_array_in_repository:1
msgid "Store a numpy array in the repository folder of a node."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/migrations/utils/utils.py:docstring of aiida.storage.psql_dos.migrations.utils.utils.store_numpy_array_in_repository:5
msgid "the numpy array to store"
msgstr ""

#: ../../source/reference/apidoc/aiida.storage.psql_dos.models.rst:2
msgid "aiida.storage.psql\\_dos.models package"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/models/__init__.py:docstring of aiida.storage.psql_dos.models:1
msgid "Module to define the database models for the SqlAlchemy backend."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/models/authinfo.py:docstring of aiida.storage.psql_dos.models.authinfo:1
msgid "Module to manage authentification information for the SQLA backend."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/models/authinfo.py:docstring of aiida.storage.psql_dos.models.authinfo.DbAuthInfo:1
#: ../../../src/aiida/storage/psql_dos/models/comment.py:docstring of aiida.storage.psql_dos.models.comment.DbComment:1
#: ../../../src/aiida/storage/psql_dos/models/computer.py:docstring of aiida.storage.psql_dos.models.computer.DbComputer:1
#: ../../../src/aiida/storage/psql_dos/models/group.py:docstring of aiida.storage.psql_dos.models.group.DbGroup:1
#: ../../../src/aiida/storage/psql_dos/models/group.py:docstring of aiida.storage.psql_dos.models.group.DbGroupNode:1
#: ../../../src/aiida/storage/psql_dos/models/log.py:docstring of aiida.storage.psql_dos.models.log.DbLog:1
#: ../../../src/aiida/storage/psql_dos/models/node.py:docstring of aiida.storage.psql_dos.models.node.DbLink:1
#: ../../../src/aiida/storage/psql_dos/models/node.py:docstring of aiida.storage.psql_dos.models.node.DbNode:1
#: ../../../src/aiida/storage/psql_dos/models/settings.py:docstring of aiida.storage.psql_dos.models.settings.DbSetting:1
#: ../../../src/aiida/storage/psql_dos/models/user.py:docstring of aiida.storage.psql_dos.models.user.DbUser:1
msgid "Bases: :py:class:`~sqlalchemy.orm.decl_api.Model`"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/models/authinfo.py:docstring of aiida.storage.psql_dos.models.authinfo.DbAuthInfo:1
#: ../../../src/aiida/storage/sqlite_zip/models.py:docstring of aiida.storage.sqlite_zip.models.DbAuthInfo:1
msgid "Database model to store data for :py:class:`aiida.orm.AuthInfo`, and keep computer authentication data, per user."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/models/authinfo.py:docstring of aiida.storage.psql_dos.models.authinfo.DbAuthInfo:3
#: ../../../src/aiida/storage/sqlite_zip/models.py:docstring of aiida.storage.sqlite_zip.models.DbAuthInfo:3
msgid "Specifications are user-specific of how to submit jobs in the computer. The model also has an ``enabled`` logical switch that indicates whether the device is available for use or not. This last one can be set and unset by the user."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/models/authinfo.py:docstring of sqlalchemy.orm.instrumentation.__init__:1
#: ../../../src/aiida/storage/psql_dos/models/comment.py:docstring of sqlalchemy.orm.instrumentation.__init__:1
#: ../../../src/aiida/storage/psql_dos/models/computer.py:docstring of sqlalchemy.orm.instrumentation.__init__:1
#: ../../../src/aiida/storage/psql_dos/models/group.py:docstring of sqlalchemy.orm.instrumentation.__init__:1
#: ../../../src/aiida/storage/psql_dos/models/log.py:docstring of sqlalchemy.orm.instrumentation.__init__:1
#: ../../../src/aiida/storage/psql_dos/models/node.py:docstring of sqlalchemy.orm.instrumentation.__init__:1
#: ../../../src/aiida/storage/psql_dos/models/settings.py:docstring of sqlalchemy.orm.instrumentation.__init__:1
#: ../../../src/aiida/storage/psql_dos/models/user.py:docstring of sqlalchemy.orm.instrumentation.__init__:1
#: ../../../src/aiida/storage/sqlite_zip/migrations/v1_db_schema.py:docstring of sqlalchemy.orm.instrumentation.__init__:1
#: ../../../src/aiida/storage/sqlite_zip/models.py:docstring of sqlalchemy.orm.instrumentation.__init__:1
msgid "A simple constructor that allows initialization from kwargs."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/models/authinfo.py:docstring of sqlalchemy.orm.instrumentation.__init__:3
#: ../../../src/aiida/storage/psql_dos/models/comment.py:docstring of sqlalchemy.orm.instrumentation.__init__:3
#: ../../../src/aiida/storage/psql_dos/models/computer.py:docstring of sqlalchemy.orm.instrumentation.__init__:3
#: ../../../src/aiida/storage/psql_dos/models/group.py:docstring of sqlalchemy.orm.instrumentation.__init__:3
#: ../../../src/aiida/storage/psql_dos/models/log.py:docstring of sqlalchemy.orm.instrumentation.__init__:3
#: ../../../src/aiida/storage/psql_dos/models/node.py:docstring of sqlalchemy.orm.instrumentation.__init__:3
#: ../../../src/aiida/storage/psql_dos/models/settings.py:docstring of sqlalchemy.orm.instrumentation.__init__:3
#: ../../../src/aiida/storage/psql_dos/models/user.py:docstring of sqlalchemy.orm.instrumentation.__init__:3
#: ../../../src/aiida/storage/sqlite_zip/migrations/v1_db_schema.py:docstring of sqlalchemy.orm.instrumentation.__init__:3
#: ../../../src/aiida/storage/sqlite_zip/models.py:docstring of sqlalchemy.orm.instrumentation.__init__:3
msgid "Sets attributes on the constructed instance using the names and values in ``kwargs``."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/models/authinfo.py:docstring of sqlalchemy.orm.instrumentation.__init__:6
#: ../../../src/aiida/storage/psql_dos/models/comment.py:docstring of sqlalchemy.orm.instrumentation.__init__:6
#: ../../../src/aiida/storage/psql_dos/models/computer.py:docstring of sqlalchemy.orm.instrumentation.__init__:6
#: ../../../src/aiida/storage/psql_dos/models/group.py:docstring of sqlalchemy.orm.instrumentation.__init__:6
#: ../../../src/aiida/storage/psql_dos/models/log.py:docstring of sqlalchemy.orm.instrumentation.__init__:6
#: ../../../src/aiida/storage/psql_dos/models/node.py:docstring of sqlalchemy.orm.instrumentation.__init__:6
#: ../../../src/aiida/storage/psql_dos/models/settings.py:docstring of sqlalchemy.orm.instrumentation.__init__:6
#: ../../../src/aiida/storage/psql_dos/models/user.py:docstring of sqlalchemy.orm.instrumentation.__init__:6
#: ../../../src/aiida/storage/sqlite_zip/migrations/v1_db_schema.py:docstring of sqlalchemy.orm.instrumentation.__init__:6
#: ../../../src/aiida/storage/sqlite_zip/models.py:docstring of sqlalchemy.orm.instrumentation.__init__:6
msgid "Only keys that are present as attributes of the instance's class are allowed. These could be, for example, any mapped columns or relationships."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/models/base.py:docstring of aiida.storage.psql_dos.models.base:1
msgid "Base SQLAlchemy models."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/models/base.py:docstring of aiida.storage.psql_dos.models.base.Model:1
msgid "Base ORM model."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/models/base.py:docstring of aiida.storage.psql_dos.models.base.Model.__repr__:1
#: ../../../src/aiida/storage/sqlite_zip/models.py:docstring of aiida.storage.sqlite_zip.models.SqliteModel.__repr__:1
msgid "Return a representation of the row columns"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/models/base.py:docstring of aiida.storage.psql_dos.models.base.get_orm_metadata:1
msgid "Return the populated metadata object."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/models/base.py:docstring of aiida.storage.psql_dos.models.base.instant_defaults_listener:1
msgid "Loop over the columns of the target model instance and populate defaults."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/models/base.py:docstring of aiida.storage.psql_dos.models.base.instant_defaults_listener:3
msgid "SqlAlchemy does not set default values for table columns upon construction of a new instance, but will only do so when storing the instance. Any attributes that do not have a value but have a defined default, will be populated with this default. This does mean however, that before the instance is stored, these attributes are undefined, for example the UUID."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/models/base.py:docstring of aiida.storage.psql_dos.models.base.instant_defaults_listener:9
msgid "This should be used as: https://docs.sqlalchemy.org/en/14/orm/events.html#sqlalchemy.orm.InstanceEvents.init"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/models/comment.py:docstring of aiida.storage.psql_dos.models.comment:1
msgid "Module to manage comments for the SQLA backend."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/models/comment.py:docstring of aiida.storage.psql_dos.models.comment.DbComment:1
#: ../../../src/aiida/storage/sqlite_zip/models.py:docstring of aiida.storage.sqlite_zip.models.DbComment:1
msgid "Database model to store data for :py:class:`aiida.orm.Comment`."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/models/comment.py:docstring of aiida.storage.psql_dos.models.comment.DbComment:3
#: ../../../src/aiida/storage/sqlite_zip/models.py:docstring of aiida.storage.sqlite_zip.models.DbComment:3
msgid "Comments can be attach to the nodes by the users."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/models/computer.py:docstring of aiida.storage.psql_dos.models.computer:1
#: ../../../src/aiida/storage/psql_dos/models/group.py:docstring of aiida.storage.psql_dos.models.group:1
msgid "Module to manage computers for the SQLA backend."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/models/computer.py:docstring of aiida.storage.psql_dos.models.computer.DbComputer:1
#: ../../../src/aiida/storage/sqlite_zip/models.py:docstring of aiida.storage.sqlite_zip.models.DbComputer:1
msgid "Database model to store data for :py:class:`aiida.orm.Computer`."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/models/computer.py:docstring of aiida.storage.psql_dos.models.computer.DbComputer:3
#: ../../../src/aiida/storage/sqlite_zip/models.py:docstring of aiida.storage.sqlite_zip.models.DbComputer:3
msgid "Computers represent (and contain the information of) the physical hardware resources available. Nodes can be associated with computers if they are remote codes, remote folders, or processes that had run remotely."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/models/computer.py:docstring of aiida.storage.psql_dos.models.computer.DbComputer:6
#: ../../../src/aiida/storage/sqlite_zip/models.py:docstring of aiida.storage.sqlite_zip.models.DbComputer:6
msgid "Computers are identified within AiiDA by their ``label`` (and thus it must be unique for each one in the database), whereas the ``hostname`` is the label that identifies the computer within the network from which one can access it."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/models/computer.py:docstring of aiida.storage.psql_dos.models.computer.DbComputer:9
#: ../../../src/aiida/storage/sqlite_zip/models.py:docstring of aiida.storage.sqlite_zip.models.DbComputer:9
msgid "The ``scheduler_type`` column contains the information of the scheduler (and plugin) that the computer uses to manage jobs, whereas the ``transport_type`` the information of the transport (and plugin) required to copy files and communicate to and from the computer. The ``metadata`` contains some general settings for these communication and management protocols."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/models/group.py:docstring of aiida.storage.psql_dos.models.group.DbGroup:1
#: ../../../src/aiida/storage/sqlite_zip/models.py:docstring of aiida.storage.sqlite_zip.models.DbGroup:1
msgid "Database model to store :py:class:`aiida.orm.Group` data."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/models/group.py:docstring of aiida.storage.psql_dos.models.group.DbGroup:3
#: ../../../src/aiida/storage/sqlite_zip/models.py:docstring of aiida.storage.sqlite_zip.models.DbGroup:3
msgid "A group may contain many different nodes, but also each node can be included in different groups."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/models/group.py:docstring of aiida.storage.psql_dos.models.group.DbGroup:5
#: ../../../src/aiida/storage/sqlite_zip/models.py:docstring of aiida.storage.sqlite_zip.models.DbGroup:5
msgid "Users will typically identify and handle groups by using their ``label`` (which, unlike the ``labels`` in other models, must be unique). Groups also have a ``type``, which serves to identify what plugin is being instanced, and the ``extras`` property for users to set any relevant information."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/models/group.py:docstring of aiida.storage.psql_dos.models.group.DbGroupNode:1
msgid "Database model to store group-to-nodes relations."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/models/log.py:docstring of aiida.storage.psql_dos.models.log:1
msgid "Module to manage logs for the SQLA backend."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/models/log.py:docstring of aiida.storage.psql_dos.models.log.DbLog:1
#: ../../../src/aiida/storage/sqlite_zip/models.py:docstring of aiida.storage.sqlite_zip.models.DbLog:1
msgid "Database model to data for :py:class:`aiida.orm.Log`, corresponding to :py:class:`aiida.orm.ProcessNode`."
msgstr ""

#: ../../docstring of aiida.storage.psql_dos.models.log.DbLog.levelname:1
#: ../../docstring of aiida.storage.sqlite_zip.models.DbLog.levelname:1
msgid "How critical the message is"
msgstr ""

#: ../../docstring of aiida.storage.psql_dos.models.log.DbLog.loggername:1
#: ../../docstring of aiida.storage.sqlite_zip.models.DbLog.loggername:1
msgid "What process recorded the message"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/models/node.py:docstring of aiida.storage.psql_dos.models.node:1
msgid "Module to manage nodes for the SQLA backend."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/models/node.py:docstring of aiida.storage.psql_dos.models.node.DbLink:1
#: ../../../src/aiida/storage/sqlite_zip/models.py:docstring of aiida.storage.sqlite_zip.models.DbLink:1
msgid "Database model to store links between :py:class:`aiida.orm.Node`."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/models/node.py:docstring of aiida.storage.psql_dos.models.node.DbLink:3
#: ../../../src/aiida/storage/sqlite_zip/models.py:docstring of aiida.storage.sqlite_zip.models.DbLink:3
msgid "Each entry in this table contains not only the ``id`` information of the two nodes that are linked, but also some extra properties of the link themselves. This includes the ``type`` of the link (see the :ref:`topics:provenance:concepts` section for all possible types) as well as a ``label`` which is more specific and typically determined by the procedure generating the process node that links the data nodes."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/models/node.py:docstring of aiida.storage.psql_dos.models.node.DbNode:1
#: ../../../src/aiida/storage/sqlite_zip/models.py:docstring of aiida.storage.sqlite_zip.models.DbNode:1
msgid "Database model to store data for :py:class:`aiida.orm.Node`."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/models/node.py:docstring of aiida.storage.psql_dos.models.node.DbNode:3
#: ../../../src/aiida/storage/sqlite_zip/models.py:docstring of aiida.storage.sqlite_zip.models.DbNode:3
msgid "Each node can be categorized according to its ``node_type``, which indicates what kind of data or process node it is. Additionally, process nodes also have a ``process_type`` that further indicates what is the specific plugin it uses."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/models/node.py:docstring of aiida.storage.psql_dos.models.node.DbNode:7
#: ../../../src/aiida/storage/sqlite_zip/models.py:docstring of aiida.storage.sqlite_zip.models.DbNode:7
msgid "Nodes can also store two kind of properties:"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/models/node.py:docstring of aiida.storage.psql_dos.models.node.DbNode:9
#: ../../../src/aiida/storage/sqlite_zip/models.py:docstring of aiida.storage.sqlite_zip.models.DbNode:9
msgid "``attributes`` are determined by the ``node_type``, and are set before storing the node and can't be modified afterwards."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/models/node.py:docstring of aiida.storage.psql_dos.models.node.DbNode:11
#: ../../../src/aiida/storage/sqlite_zip/models.py:docstring of aiida.storage.sqlite_zip.models.DbNode:11
msgid "``extras``, on the other hand, can be added and removed after the node has been stored and are usually set by the user."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/models/node.py:docstring of aiida.storage.psql_dos.models.node.DbNode.__str__:1
msgid "Get string object out of DbNode object."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/models/node.py:docstring of aiida.storage.psql_dos.models.node.DbNode.get_simple_name:1
msgid "Return a string with the last part of the type name."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/models/node.py:docstring of aiida.storage.psql_dos.models.node.DbNode.get_simple_name:3
msgid "If the type is empty, use 'Node'. If the type is invalid, return the content of the input variable ``invalid_result``."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/models/node.py:docstring of aiida.storage.psql_dos.models.node.DbNode.get_simple_name:7
msgid "The value to be returned if the node type is not recognized."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/models/settings.py:docstring of aiida.storage.psql_dos.models.settings:1
msgid "Module to manage node settings for the SQLA backend."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/models/settings.py:docstring of aiida.storage.psql_dos.models.settings.DbSetting:1
msgid "Database model to store global settings."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/models/user.py:docstring of aiida.storage.psql_dos.models.user:1
msgid "Module to manage users for the SQLA backend."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/models/user.py:docstring of aiida.storage.psql_dos.models.user.DbUser:1
#: ../../../src/aiida/storage/sqlite_zip/models.py:docstring of aiida.storage.sqlite_zip.models.DbUser:1
msgid "Database model to store data for :py:class:`aiida.orm.User`."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/models/user.py:docstring of aiida.storage.psql_dos.models.user.DbUser:3
#: ../../../src/aiida/storage/sqlite_zip/models.py:docstring of aiida.storage.sqlite_zip.models.DbUser:3
msgid "Every node that is created has a single user as its author."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/models/user.py:docstring of aiida.storage.psql_dos.models.user.DbUser:5
#: ../../../src/aiida/storage/sqlite_zip/models.py:docstring of aiida.storage.sqlite_zip.models.DbUser:5
msgid "The user information consists of the most basic personal contact details."
msgstr ""

#: ../../source/reference/apidoc/aiida.storage.psql_dos.orm.rst:2
msgid "aiida.storage.psql\\_dos.orm package"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/__init__.py:docstring of aiida.storage.psql_dos.orm:1
msgid "Implementation of ORM backend entities."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/authinfos.py:docstring of aiida.storage.psql_dos.orm.authinfos:1
msgid "Module for the SqlAlchemy backend implementation of the `AuthInfo` ORM class."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/authinfos.py:docstring of aiida.storage.psql_dos.orm.authinfos.SqlaAuthInfo:1
msgid "Bases: :py:class:`~aiida.storage.psql_dos.orm.entities.SqlaModelEntity`\\ [:py:class:`~aiida.storage.psql_dos.models.authinfo.DbAuthInfo`], :py:class:`~aiida.orm.implementation.authinfos.BackendAuthInfo`"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/authinfos.py:docstring of aiida.storage.psql_dos.orm.authinfos.SqlaAuthInfo:1
msgid "SqlAlchemy backend implementation for the `AuthInfo` ORM class."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/authinfos.py:docstring of aiida.storage.psql_dos.orm.authinfos.SqlaAuthInfo.__init__:3
msgid "a :class:`aiida.orm.implementation.computers.BackendComputer` instance"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/authinfos.py:docstring of aiida.storage.psql_dos.orm.authinfos.SqlaAuthInfo.__init__:4
msgid "a :class:`aiida.orm.implementation.users.BackendUser` instance"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/authinfos.py:docstring of aiida.storage.psql_dos.orm.authinfos.SqlaAuthInfo.__init__:5
msgid "an :class:`aiida.orm.implementation.authinfos.BackendAuthInfo` instance"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/authinfos.py:docstring of aiida.storage.psql_dos.orm.authinfos.SqlaAuthInfo.computer:3
msgid ":class:`aiida.orm.implementation.computers.BackendComputer`"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/authinfos.py:docstring of aiida.storage.psql_dos.orm.authinfos.SqlaAuthInfo.id:1
#: ../../../src/aiida/storage/psql_dos/orm/computers.py:docstring of aiida.storage.psql_dos.orm.computers.SqlaComputer.id:1
#: ../../../src/aiida/storage/psql_dos/orm/entities.py:docstring of aiida.storage.psql_dos.orm.entities.SqlaModelEntity.id:1
msgid "Get the id of this entity"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/authinfos.py:docstring of aiida.storage.psql_dos.orm.authinfos.SqlaAuthInfo.user:3
msgid ":class:`aiida.orm.implementation.users.BackendUser`"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/authinfos.py:docstring of aiida.storage.psql_dos.orm.authinfos.SqlaAuthInfoCollection:1
msgid "Bases: :py:class:`~aiida.orm.implementation.authinfos.BackendAuthInfoCollection`"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/authinfos.py:docstring of aiida.storage.psql_dos.orm.authinfos.SqlaAuthInfoCollection:1
msgid "The collection of SqlAlchemy backend `AuthInfo` entries."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/comments.py:docstring of aiida.storage.psql_dos.orm.comments:1
msgid "SQLA implementations for the Comment entity and collection."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/comments.py:docstring of aiida.storage.psql_dos.orm.comments.SqlaComment:1
msgid "Bases: :py:class:`~aiida.storage.psql_dos.orm.entities.SqlaModelEntity`\\ [:py:class:`~aiida.storage.psql_dos.models.comment.DbComment`], :py:class:`~aiida.orm.implementation.comments.BackendComment`"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/comments.py:docstring of aiida.storage.psql_dos.orm.comments.SqlaComment:1
msgid "Comment implementation for Sqla."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/comments.py:docstring of aiida.storage.psql_dos.orm.comments.SqlaComment.__init__:1
msgid "Construct a SqlaComment."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/comments.py:docstring of aiida.storage.psql_dos.orm.comments.SqlaComment.__init__:6
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.__init__:9
msgid "The creation time as datetime object"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/comments.py:docstring of aiida.storage.psql_dos.orm.comments.SqlaComment.__init__:7
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.__init__:10
msgid "The modification time as datetime object"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/comments.py:docstring of aiida.storage.psql_dos.orm.comments.SqlaComment.store:1
msgid "Can only store if both the node and user are stored as well."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/comments.py:docstring of aiida.storage.psql_dos.orm.comments.SqlaCommentCollection:1
msgid "Bases: :py:class:`~aiida.orm.implementation.comments.BackendCommentCollection`"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/comments.py:docstring of aiida.storage.psql_dos.orm.comments.SqlaCommentCollection:1
msgid "SqlAlchemy implementation for the CommentCollection."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/computers.py:docstring of aiida.storage.psql_dos.orm.computers:1
msgid "SqlAlchemy implementations for the `Computer` entity and collection."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/computers.py:docstring of aiida.storage.psql_dos.orm.computers.SqlaComputer:1
msgid "Bases: :py:class:`~aiida.storage.psql_dos.orm.entities.SqlaModelEntity`\\ [:py:class:`~aiida.storage.psql_dos.models.computer.DbComputer`], :py:class:`~aiida.orm.implementation.computers.BackendComputer`"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/computers.py:docstring of aiida.storage.psql_dos.orm.computers.SqlaComputer:1
msgid "SqlAlchemy implementation for `BackendComputer`."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/computers.py:docstring of aiida.storage.psql_dos.orm.computers.SqlaComputer.copy:1
msgid "Create an unstored clone of an already stored `Computer`."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/computers.py:docstring of aiida.storage.psql_dos.orm.computers.SqlaComputer.is_stored:1
#: ../../../src/aiida/storage/psql_dos/orm/entities.py:docstring of aiida.storage.psql_dos.orm.entities.SqlaModelEntity.is_stored:1
#: ../../../src/aiida/storage/psql_dos/orm/groups.py:docstring of aiida.storage.psql_dos.orm.groups.SqlaGroup.is_stored:1
msgid "Is this entity stored?"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/computers.py:docstring of aiida.storage.psql_dos.orm.computers.SqlaComputer.store:1
msgid "Store the `Computer` instance."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/computers.py:docstring of aiida.storage.psql_dos.orm.computers.SqlaComputerCollection:1
msgid "Bases: :py:class:`~aiida.orm.implementation.computers.BackendComputerCollection`"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/computers.py:docstring of aiida.storage.psql_dos.orm.computers.SqlaComputerCollection:1
msgid "Collection of `Computer` instances."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/convert.py:docstring of aiida.storage.psql_dos.orm.convert:1
msgid "Module to get the backend instance from the Models instance"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/convert.py:docstring of aiida.storage.psql_dos.orm.convert._:1
msgid "Convert a dblink to the backend entity"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/convert.py:docstring of aiida.storage.psql_dos.orm.convert.get_backend_entity:1
msgid "Default get_backend_entity"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/entities.py:docstring of aiida.storage.psql_dos.orm.entities:1
msgid "Classes and methods for Django specific backend entities"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/entities.py:docstring of aiida.storage.psql_dos.orm.entities.SqlaModelEntity:1
msgid "Bases: :py:class:`~typing.Generic`\\ [:py:obj:`~aiida.storage.psql_dos.orm.entities.ModelType`]"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/entities.py:docstring of aiida.storage.psql_dos.orm.entities.SqlaModelEntity:1
msgid "A mixin that adds some common SQLA backend entity methods"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/entities.py:docstring of aiida.storage.psql_dos.orm.entities.SqlaModelEntity._class_check:1
#: ../../../src/aiida/storage/sqlite_zip/orm.py:docstring of aiida.storage.sqlite_zip.orm.SqliteEntityOverride._class_check:1
msgid "Assert that the class is correctly configured"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/entities.py:docstring of aiida.storage.psql_dos.orm.entities.SqlaModelEntity.bare_model:1
msgid "Return the underlying SQLA ORM model for this entity."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/entities.py:docstring of aiida.storage.psql_dos.orm.entities.SqlaModelEntity.bare_model:3
msgid "Getting/setting attributes on this model bypasses AiiDA's internal update/flush mechanisms."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/entities.py:docstring of aiida.storage.psql_dos.orm.entities.SqlaModelEntity.from_dbmodel:1
#: ../../../src/aiida/storage/sqlite_zip/orm.py:docstring of aiida.storage.sqlite_zip.orm.SqliteEntityOverride.from_dbmodel:1
msgid "Create an AiiDA Entity from the corresponding SQLA ORM model and storage backend"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/entities.py:docstring of aiida.storage.psql_dos.orm.entities.SqlaModelEntity.from_dbmodel:3
#: ../../../src/aiida/storage/sqlite_zip/orm.py:docstring of aiida.storage.sqlite_zip.orm.SqliteEntityOverride.from_dbmodel:3
msgid "the SQLAlchemy model to create the entity from"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/entities.py:docstring of aiida.storage.psql_dos.orm.entities.SqlaModelEntity.from_dbmodel:4
#: ../../../src/aiida/storage/sqlite_zip/orm.py:docstring of aiida.storage.sqlite_zip.orm.SqliteEntityOverride.from_dbmodel:4
msgid "the corresponding storage backend"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/entities.py:docstring of aiida.storage.psql_dos.orm.entities.SqlaModelEntity.from_dbmodel:5
#: ../../../src/aiida/storage/sqlite_zip/orm.py:docstring of aiida.storage.sqlite_zip.orm.SqliteEntityOverride.from_dbmodel:5
msgid "the AiiDA entity"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/entities.py:docstring of aiida.storage.psql_dos.orm.entities.SqlaModelEntity.model:1
msgid "Return an ORM model that correctly updates and flushes the data when getting or setting a field."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/entities.py:docstring of aiida.storage.psql_dos.orm.entities.SqlaModelEntity.store:1
#: ../../../src/aiida/storage/psql_dos/orm/groups.py:docstring of aiida.storage.psql_dos.orm.groups.SqlaGroup.store:1
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.store:1
msgid "Store this entity"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/entities.py:docstring of aiida.storage.psql_dos.orm.entities.SqlaModelEntity.store:3
#: ../../../src/aiida/storage/psql_dos/orm/groups.py:docstring of aiida.storage.psql_dos.orm.groups.SqlaGroup.store:3
#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.store:3
msgid "the entity itself"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/extras_mixin.py:docstring of aiida.storage.psql_dos.orm.extras_mixin:1
#: ../../../src/aiida/storage/psql_dos/orm/extras_mixin.py:docstring of aiida.storage.psql_dos.orm.extras_mixin.ExtrasMixin:1
msgid "Mixin class for SQL implementations of ``extras``."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/groups.py:docstring of aiida.storage.psql_dos.orm.groups:1
msgid "SQLA groups"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/groups.py:docstring of aiida.storage.psql_dos.orm.groups.SqlaGroup:1
msgid "Bases: :py:class:`~aiida.storage.psql_dos.orm.entities.SqlaModelEntity`\\ [:py:class:`~aiida.storage.psql_dos.models.group.DbGroup`], :py:class:`~aiida.storage.psql_dos.orm.extras_mixin.ExtrasMixin`, :py:class:`~aiida.orm.implementation.groups.BackendGroup`"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/groups.py:docstring of aiida.storage.psql_dos.orm.groups.SqlaGroup:1
msgid "The SQLAlchemy Group object"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/groups.py:docstring of aiida.storage.psql_dos.orm.groups.SqlaGroup.__init__:1
msgid "Construct a new SQLA group"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/groups.py:docstring of aiida.storage.psql_dos.orm.groups.SqlaGroup.__init__:3
msgid "the backend to use"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/groups.py:docstring of aiida.storage.psql_dos.orm.groups.SqlaGroup.__init__:4
msgid "the group label"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/groups.py:docstring of aiida.storage.psql_dos.orm.groups.SqlaGroup.__init__:5
msgid "the owner of the group"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/groups.py:docstring of aiida.storage.psql_dos.orm.groups.SqlaGroup.__init__:6
msgid "an optional group description"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/groups.py:docstring of aiida.storage.psql_dos.orm.groups.SqlaGroup.__init__:7
msgid "an optional type for the group to contain"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/groups.py:docstring of aiida.storage.psql_dos.orm.groups.SqlaGroup.add_nodes:5
#: ../../../src/aiida/storage/psql_dos/orm/groups.py:docstring of aiida.storage.psql_dos.orm.groups.SqlaGroup.remove_nodes:5
msgid "a list of `BackendNode` instance to be added to this group"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/groups.py:docstring of aiida.storage.psql_dos.orm.groups.SqlaGroup.add_nodes:7
msgid "skip_orm: When the flag is on, the SQLA ORM is skipped and SQLA is used to create a direct SQL INSERT statement to the group-node relationship table (to improve speed)."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/groups.py:docstring of aiida.storage.psql_dos.orm.groups.SqlaGroup.nodes:1
msgid "Get an iterator to all the nodes in the group"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/groups.py:docstring of aiida.storage.psql_dos.orm.groups.SqlaGroup.remove_nodes:1
msgid "Remove a node or a set of nodes from the group."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/groups.py:docstring of aiida.storage.psql_dos.orm.groups.SqlaGroup.remove_nodes:6
msgid "skip_orm: When the flag is set to `True`, the SQLA ORM is skipped and SQLA is used to create a direct SQL DELETE statement to the group-node relationship table in order to improve speed."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/groups.py:docstring of aiida.storage.psql_dos.orm.groups.SqlaGroupCollection:1
msgid "Bases: :py:class:`~aiida.orm.implementation.groups.BackendGroupCollection`"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/groups.py:docstring of aiida.storage.psql_dos.orm.groups.SqlaGroupCollection:1
msgid "The SLQA collection of groups"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/logs.py:docstring of aiida.storage.psql_dos.orm.logs:1
msgid "SQLA Log and LogCollection module"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/logs.py:docstring of aiida.storage.psql_dos.orm.logs.SqlaLog:1
msgid "Bases: :py:class:`~aiida.storage.psql_dos.orm.entities.SqlaModelEntity`\\ [:py:class:`~aiida.storage.psql_dos.models.log.DbLog`], :py:class:`~aiida.orm.implementation.logs.BackendLog`"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/logs.py:docstring of aiida.storage.psql_dos.orm.logs.SqlaLog:1
msgid "SQLA Log backend entity"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/logs.py:docstring of aiida.storage.psql_dos.orm.logs.SqlaLog.uuid:1
msgid "Get the string representation of the UUID of the log entry"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/logs.py:docstring of aiida.storage.psql_dos.orm.logs.SqlaLogCollection:1
msgid "Bases: :py:class:`~aiida.orm.implementation.logs.BackendLogCollection`"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/logs.py:docstring of aiida.storage.psql_dos.orm.logs.SqlaLogCollection:1
msgid "The SQLA collection for logs"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes:1
msgid "SqlAlchemy implementation of the `BackendNode` and `BackendNodeCollection` classes."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode:1
msgid "Bases: :py:class:`~aiida.storage.psql_dos.orm.entities.SqlaModelEntity`\\ [:py:class:`~aiida.storage.psql_dos.models.node.DbNode`], :py:class:`~aiida.storage.psql_dos.orm.extras_mixin.ExtrasMixin`, :py:class:`~aiida.orm.implementation.nodes.BackendNode`"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode:1
#: ../../../src/aiida/storage/sqlite_zip/orm.py:docstring of aiida.storage.sqlite_zip.orm.SqliteNode:1
msgid "SQLA Node backend entity"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.__init__:1
msgid "Construct a new `BackendNode` instance wrapping a new `DbNode` instance."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.__init__:4
msgid "the node type string"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.__init__:5
msgid "associated `BackendUser`"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.__init__:6
msgid "associated `BackendComputer`"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.__init__:7
msgid "string label"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode.__init__:8
msgid "string description"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNode._add_link:1
msgid "Add a single link"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNodeCollection:1
msgid "Bases: :py:class:`~aiida.orm.implementation.nodes.BackendNodeCollection`"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/nodes.py:docstring of aiida.storage.psql_dos.orm.nodes.SqlaNodeCollection:1
msgid "The collection of Node entries."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/users.py:docstring of aiida.storage.psql_dos.orm.users:1
#: ../../../src/aiida/storage/psql_dos/orm/users.py:docstring of aiida.storage.psql_dos.orm.users.SqlaUser:1
msgid "SQLA user"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/users.py:docstring of aiida.storage.psql_dos.orm.users.SqlaUser:1
msgid "Bases: :py:class:`~aiida.storage.psql_dos.orm.entities.SqlaModelEntity`\\ [:py:class:`~aiida.storage.psql_dos.models.user.DbUser`], :py:class:`~aiida.orm.implementation.users.BackendUser`"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/users.py:docstring of aiida.storage.psql_dos.orm.users.SqlaUserCollection:1
msgid "Bases: :py:class:`~aiida.orm.implementation.users.BackendUserCollection`"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/users.py:docstring of aiida.storage.psql_dos.orm.users.SqlaUserCollection:1
msgid "Collection of SQLA Users"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/users.py:docstring of aiida.storage.psql_dos.orm.users.SqlaUserCollection.create:1
msgid "Create a user with the provided email address"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/utils.py:docstring of aiida.storage.psql_dos.orm.utils:1
msgid "Utilities for the implementation of the SqlAlchemy backend."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/utils.py:docstring of aiida.storage.psql_dos.orm.utils.ModelWrapper:1
msgid "Wrap an SQLA ORM model and AiiDA storage backend instance together, to correctly update and flush the data model when getting or setting a field."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/utils.py:docstring of aiida.storage.psql_dos.orm.utils.ModelWrapper:4
msgid "The ORM model represents a row in a database table, with a given schema, and its attributes represent the fields (a.k.a. columns) of the table. When an ORM model instance is created, it does not have any association with a particular database, i.e. it is \"unsaved\". At this point, its attributes can be freely retrieved or set."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/utils.py:docstring of aiida.storage.psql_dos.orm.utils.ModelWrapper:10
msgid "When the ORM model instance is saved, it is associated with the database configured for the backend instance, by adding it to the backend instances's session (i.e. its connection with the database). At this point:"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/utils.py:docstring of aiida.storage.psql_dos.orm.utils.ModelWrapper:14
msgid "Whenever we retrieve a field of the model instance, unless we know it to be immutable, we first ensure that the field represents the latest value in the database (e.g. in case the database has been externally updated)."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/utils.py:docstring of aiida.storage.psql_dos.orm.utils.ModelWrapper:18
msgid "Whenever we set a field of the model instance, unless we know it to be immutable, we flush the change to the database."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/utils.py:docstring of aiida.storage.psql_dos.orm.utils.ModelWrapper.__getattr__:1
msgid "Get an attribute of the model instance."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/utils.py:docstring of aiida.storage.psql_dos.orm.utils.ModelWrapper.__getattr__:3
msgid "If the model is saved in the database, the item corresponds to a mutable model field and the current scope is not in an open database connection, then the field's value is first refreshed from the database."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/utils.py:docstring of aiida.storage.psql_dos.orm.utils.ModelWrapper.__getattr__:6
#: ../../../src/aiida/storage/psql_dos/orm/utils.py:docstring of aiida.storage.psql_dos.orm.utils.ModelWrapper.__setattr__:5
msgid "the name of the model field"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/utils.py:docstring of aiida.storage.psql_dos.orm.utils.ModelWrapper.__getattr__:7
msgid "the value of the model's attribute"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/utils.py:docstring of aiida.storage.psql_dos.orm.utils.ModelWrapper.__init__:1
msgid "Construct the ModelWrapper."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/utils.py:docstring of aiida.storage.psql_dos.orm.utils.ModelWrapper.__init__:3
msgid "the ORM model instance to wrap"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/utils.py:docstring of aiida.storage.psql_dos.orm.utils.ModelWrapper.__init__:4
msgid "the storage backend instance"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/utils.py:docstring of aiida.storage.psql_dos.orm.utils.ModelWrapper.__setattr__:1
msgid "Set the attribute on the model instance."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/utils.py:docstring of aiida.storage.psql_dos.orm.utils.ModelWrapper.__setattr__:3
msgid "If the field being set is a mutable model field and the model is saved, the changes are flushed."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/utils.py:docstring of aiida.storage.psql_dos.orm.utils.ModelWrapper._ensure_model_uptodate:1
msgid "Refresh all fields of the wrapped model instance by fetching the current state of the database instance."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/utils.py:docstring of aiida.storage.psql_dos.orm.utils.ModelWrapper._ensure_model_uptodate:3
msgid "optionally refresh only these fields, if `None` all fields are refreshed."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/utils.py:docstring of aiida.storage.psql_dos.orm.utils.ModelWrapper._flush:1
msgid "Flush the fields of the model to the database."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/utils.py:docstring of aiida.storage.psql_dos.orm.utils.ModelWrapper._flush:3
msgid "If the wrapped model is not actually saved in the database yet, this method is a no-op."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/utils.py:docstring of aiida.storage.psql_dos.orm.utils.ModelWrapper._flush:5
msgid "the model fields whose current value to flush to the database"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/utils.py:docstring of aiida.storage.psql_dos.orm.utils.ModelWrapper._in_transaction:1
msgid "Return whether the current scope is within an open database transaction."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/utils.py:docstring of aiida.storage.psql_dos.orm.utils.ModelWrapper._in_transaction:3
msgid "boolean, True if currently in open transaction, False otherwise."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/utils.py:docstring of aiida.storage.psql_dos.orm.utils.ModelWrapper._is_model_field:1
msgid "Return whether the field is a field of the model."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/utils.py:docstring of aiida.storage.psql_dos.orm.utils.ModelWrapper._is_model_field:3
msgid "boolean, True if the field is a model field, False otherwise."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/utils.py:docstring of aiida.storage.psql_dos.orm.utils.ModelWrapper._is_mutable_model_field:1
msgid "Return whether the field is a mutable field of the model."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/utils.py:docstring of aiida.storage.psql_dos.orm.utils.ModelWrapper._is_mutable_model_field:3
msgid "boolean, True if the field is a model field and is not in the `IMMUTABLE_MODEL_FIELDS` set."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/utils.py:docstring of aiida.storage.psql_dos.orm.utils.ModelWrapper.is_saved:1
msgid "Return whether the wrapped model instance is saved in the database."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/utils.py:docstring of aiida.storage.psql_dos.orm.utils.ModelWrapper.is_saved:3
msgid "boolean, True if the model is saved in the database, False otherwise"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/utils.py:docstring of aiida.storage.psql_dos.orm.utils.ModelWrapper.save:1
msgid "Store the model instance."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/utils.py:docstring of aiida.storage.psql_dos.orm.utils.ModelWrapper.save:3
msgid "If one is currently in a transaction, this method is a no-op."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/utils.py:docstring of aiida.storage.psql_dos.orm.utils.ModelWrapper.save:5
msgid "if a database integrity error is raised during the save."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/utils.py:docstring of aiida.storage.psql_dos.orm.utils.ModelWrapper.session:1
msgid "Return the session of the storage backend instance."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/utils.py:docstring of aiida.storage.psql_dos.orm.utils.disable_expire_on_commit:1
msgid "Context manager that disables expire_on_commit and restores the original value on exit"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/utils.py:docstring of aiida.storage.psql_dos.orm.utils.disable_expire_on_commit:3
msgid "The SQLA session"
msgstr ""

#: ../../source/reference/apidoc/aiida.storage.psql_dos.orm.querybuilder.rst:2
msgid "aiida.storage.psql\\_dos.orm.querybuilder package"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/__init__.py:docstring of aiida.storage.psql_dos.orm.querybuilder:1
msgid "Implementation of QueryBuilder backend."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner:1
msgid "A module containing the logic for creating joined queries."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.SqlaJoiner:1
msgid "A class containing the logic for SQLAlchemy entities joining entities."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.SqlaJoiner.__init__:1
msgid "Initialise the class"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.SqlaJoiner._entity_join_map:1
msgid "Map relationship type keywords to functions The first level defines the entity which has been passed to the qb.append function, and the second defines the relationship with respect to a given tag."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.SqlaJoiner._join_authinfo_user:1
#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.SqlaJoiner._join_comment_node:1
#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.SqlaJoiner._join_comment_user:1
msgid "An aliased comment"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.SqlaJoiner._join_authinfo_user:2
#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.SqlaJoiner._join_comment_user:2
msgid "aliased user"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.SqlaJoiner._join_comment_node:2
#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.SqlaJoiner._join_log_node:2
msgid "aliased node"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.SqlaJoiner._join_computer_authinfo:1
#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.SqlaJoiner._join_user_authinfo:1
#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.SqlaJoiner._join_user_node:1
msgid "the aliased user you want to join to"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.SqlaJoiner._join_computer_authinfo:2
#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.SqlaJoiner._join_user_authinfo:2
#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.SqlaJoiner._join_user_node:2
msgid "the (aliased) node or group in the DB to join with"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.SqlaJoiner._join_computer_node:1
msgid "the (aliased) computer entity"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.SqlaJoiner._join_computer_node:2
msgid "the (aliased) node entity"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.SqlaJoiner._join_group_node:1
msgid "The (aliased) ORMclass that is a group in the database"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.SqlaJoiner._join_group_node:4
msgid "The (aliased) ORMClass that is a node and member of the group"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.SqlaJoiner._join_group_node:7
msgid "**joined_entity** and **entity_to_join** are joined via the table_groups_nodes table. from **joined_entity** as group to **enitity_to_join** as node. (**enitity_to_join** is *with_group* **joined_entity**)"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.SqlaJoiner._join_group_user:1
msgid "An aliased dbgroup"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.SqlaJoiner._join_group_user:2
msgid "aliased dbuser"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.SqlaJoiner._join_log_node:1
msgid "An aliased log"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.SqlaJoiner._join_node_ancestors_recursive:1
msgid "Joining ancestors using the recursive functionality :TODO: Move the filters to be done inside the recursive query (for example on depth) :TODO: Pass an option to also show the path, if this is wanted."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.SqlaJoiner._join_node_comment:1
#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.SqlaJoiner._join_node_log:1
msgid "An aliased node"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.SqlaJoiner._join_node_comment:2
#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.SqlaJoiner._join_user_comment:2
msgid "aliased comment"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.SqlaJoiner._join_node_computer:1
msgid "An entity that can use a computer (eg a node)"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.SqlaJoiner._join_node_computer:2
msgid "aliased dbcomputer entity"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.SqlaJoiner._join_node_descendants_recursive:1
msgid "Joining descendants using the recursive functionality :TODO: Move the filters to be done inside the recursive query (for example on depth) :TODO: Pass an option to also show the path, if this is wanted."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.SqlaJoiner._join_node_group:1
msgid "The (aliased) node in the database"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.SqlaJoiner._join_node_group:2
msgid "The (aliased) Group"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.SqlaJoiner._join_node_group:4
msgid "**joined_entity** and **entity_to_join** are joined via the table_groups_nodes table. from **joined_entity** as node to **enitity_to_join** as group. (**enitity_to_join** is a group *with_node* **joined_entity**)"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.SqlaJoiner._join_node_inputs:1
msgid "The (aliased) ORMclass that is an output"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.SqlaJoiner._join_node_inputs:2
msgid "The (aliased) ORMClass that is an input."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.SqlaJoiner._join_node_inputs:4
msgid "**joined_entity** and **entity_to_join** are joined with a link from **joined_entity** as output to **enitity_to_join** as input (**enitity_to_join** is *with_outgoing* **joined_entity**)"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.SqlaJoiner._join_node_log:2
msgid "aliased log"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.SqlaJoiner._join_node_outputs:1
msgid "The (aliased) ORMclass that is an input"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.SqlaJoiner._join_node_outputs:2
msgid "The (aliased) ORMClass that is an output."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.SqlaJoiner._join_node_outputs:4
msgid "**joined_entity** and **entity_to_join** are joined with a link from **joined_entity** as input to **enitity_to_join** as output (**enitity_to_join** is *with_incoming* **joined_entity**)"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.SqlaJoiner._join_node_user:1
msgid "the aliased node"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.SqlaJoiner._join_node_user:2
msgid "the aliased user to join to that node"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.SqlaJoiner._join_user_comment:1
#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.SqlaJoiner._join_user_group:1
msgid "An aliased user"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.SqlaJoiner._join_user_group:2
msgid "aliased group"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner.SqlaJoiner.get_join_func:1
msgid "Return the function to join two entities"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner._EntityMapper:1
msgid "Mapping of implemented entity types."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner._check_dbentities:1
msgid "Type check for entities"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner._check_dbentities:3
msgid "A tuple of the aliased class passed as joined_entity and the ormclass that was expected"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner._check_dbentities:6
msgid "A tuple of the aliased class passed as entity_to_join and the ormclass that was expected"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/joiner.py:docstring of aiida.storage.psql_dos.orm.querybuilder.joiner._check_dbentities:9
msgid "The relationship between the two entities to make the Exception comprehensible"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main:1
msgid "Sqla query builder implementation"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.BuiltQuery:1
msgid "A class to store the query and the corresponding projections."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder:1
msgid "Bases: :py:class:`~aiida.orm.implementation.querybuilder.BackendQueryBuilder`"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder:1
msgid "QueryBuilder to use with SQLAlchemy-backend and schema defined in backends.sqlalchemy.models"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder._build:1
msgid "Build the query and return."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder._create_order_by:1
msgid "Build the order_by parameter of the query."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder._get_projectable_entity:1
#: ../../../src/aiida/storage/sqlite_zip/orm.py:docstring of aiida.storage.sqlite_zip.orm.SqliteQueryBuilder._get_projectable_entity:1
msgid "Return projectable entity for a given alias and column name."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder.analyze_query:1
msgid "Analyze the query and return the result as a string."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder.as_sql:1
msgid "Return the SQL query as a string."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder.build_filters:1
msgid "Recurse through the filter specification and apply filter operations."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder.build_filters:3
msgid "The alias of the ORM class the filter will be applied on"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder.build_filters:4
msgid "the specification of the filter"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder.build_filters:6
msgid "an sqlalchemy expression."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder.get_filter_expr:1
msgid "Applies a filter on the alias given."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder.get_filter_expr:3
msgid "Expects the alias of the ORM-class on which to filter, and filter_spec. Filter_spec contains the specification on the filter. Expects:"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder.get_filter_expr:7
msgid "The operator to apply, see below for further details"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder.get_filter_expr:8
msgid "The value for the right side of the expression, the value you want to compare with."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder.get_filter_expr:12
msgid "The path leading to the value"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder.get_filter_expr:14
msgid "Whether the value is in a json-column, or in an attribute like table."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder.get_filter_expr:17
msgid "Implemented and valid operators:"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder.get_filter_expr:19
msgid "for any type: *   ==  (compare single value, eg: '==':5.0) *   in    (compare whether in list, eg: 'in':[5, 6, 34]"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder.get_filter_expr:25
msgid "for floats and integers:"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder.get_filter_expr:23
msgid ">"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder.get_filter_expr:24
msgid "<"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder.get_filter_expr:25
msgid "<="
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder.get_filter_expr:26
msgid ">="
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder.get_filter_expr:38
msgid "for strings:"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder.get_filter_expr:28
msgid "like  (case - sensitive), for example 'like':'node.calc.%'  will match node.calc.relax and node.calc.RELAX and node.calc. but not node.CALC.relax"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder.get_filter_expr:32
msgid "ilike (case - unsensitive) will also match node.CaLc.relax in the above example"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder.get_filter_expr:36
msgid "The character % is a reserved special character in SQL, and acts as a wildcard. If you specifically want to capture a ``%`` in the string, use: ``_%``"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder.get_filter_expr:40
msgid "for arrays and dictionaries (only for the SQLAlchemy implementation):"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder.get_filter_expr:43
msgid "contains: pass a list with all the items that the array should contain, or that should be among the keys, eg: 'contains': ['N', 'H'])"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder.get_filter_expr:46
msgid "has_key: pass an element that the list has to contain or that has to be a key, eg: 'has_key':'N')"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder.get_filter_expr:52
msgid "for arrays only (SQLAlchemy version):"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder.get_filter_expr:50
msgid "of_length"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder.get_filter_expr:51
msgid "longer"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder.get_filter_expr:52
msgid "shorter"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder.get_filter_expr:54
msgid "All the above filters invoke a negation of the expression if preceded by **~**::"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder.get_filter_expr_from_column:1
#: ../../../src/aiida/storage/sqlite_zip/orm.py:docstring of aiida.storage.sqlite_zip.orm.SqliteQueryBuilder.get_filter_expr_from_column:1
msgid "A method that returns an valid SQLAlchemy expression."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder.get_filter_expr_from_column:3
#: ../../../src/aiida/storage/sqlite_zip/orm.py:docstring of aiida.storage.sqlite_zip.orm.SqliteQueryBuilder.get_filter_expr_from_column:3
msgid "The operator provided by the user ('==',  '>', ...)"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder.get_filter_expr_from_column:4
#: ../../../src/aiida/storage/sqlite_zip/orm.py:docstring of aiida.storage.sqlite_zip.orm.SqliteQueryBuilder.get_filter_expr_from_column:4
msgid "The value to compare with, e.g. (5.0, 'foo', ['a','b'])"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder.get_filter_expr_from_column:5
#: ../../../src/aiida/storage/sqlite_zip/orm.py:docstring of aiida.storage.sqlite_zip.orm.SqliteQueryBuilder.get_filter_expr_from_column:5
msgid "an instance of sqlalchemy.orm.attributes.InstrumentedAttribute or"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder.get_filter_expr_from_jsonb:1
msgid "Return a filter expression"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder.get_query:1
msgid "Return the built query."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder.get_query:3
msgid "To avoid unnecessary re-builds of the query, the hashed dictionary representation of this instance is compared to the last query returned, which is cached by its hash."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder.get_session:1
msgid "Get the connection to the database"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder.query_session:1
msgid "Yield the built query, ensuring the session is closed on an exception."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder.to_backend:1
msgid "Convert results to return backend specific objects."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder.to_backend:3
msgid "convert `DbModel` instances to `BackendEntity` instances."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder.to_backend:4
msgid "convert UUIDs to strings"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder.to_backend:6
msgid "the result returned by the query"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder.to_backend:8
msgid ":returns:backend compatible instance"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main._create_projections:1
msgid "Build the projections for a given tag."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main._create_projections:3
msgid "the tag of the node for which to build the projections"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main._create_projections:4
msgid "the number of previous projections"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main._create_projections:5
msgid "the list of projections to build, if None, use the projections specified in the query"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main._get_projection:1
msgid "An alias for an ormclass"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main._get_projection:2
msgid "User specification of what to project. Appends to query's entities what the user wants to project (have returned by the query)"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main._get_projection:6
msgid "Cast the value to a different type"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main._get_projection:7
msgid "Apply a function to the projection"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main._get_projection:9
msgid "The projection"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.compile_query:1
msgid "Compile the query to the SQL executable."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.compile_query:0
msgid "params literal_binds"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.generate_joins:1
msgid "Generate the joins for the query."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.generate_projections:1
msgid "Generate the projections for the query."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.get_column:1
msgid "Return the column for a given projection."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.get_column_names:1
msgid "Given the backend specific alias, return the column names that correspond to the aliased table."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.get_corresponding_properties:1
msgid "This method returns a list of updated properties for a given list of properties. If there is no update for the property, the given property is returned in the list."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.get_corresponding_property:1
msgid "This method returns an updated property for a given a property. If there is no update for the property, the given property is returned."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.get_table_name:1
msgid "Returns the table name given an Aliased class"
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.modify_expansions:1
msgid "Modify names of projections if `**` was specified."
msgstr ""

#: ../../../src/aiida/storage/psql_dos/orm/querybuilder/main.py:docstring of aiida.storage.psql_dos.orm.querybuilder.main.modify_expansions:3
msgid "This is important for the schema having attributes in a different table. In SQLA, the metadata should be changed to _metadata to be in-line with the database schema"
msgstr ""

#: ../../source/reference/apidoc/aiida.storage.sqlite_dos.rst:2
msgid "aiida.storage.sqlite\\_dos package"
msgstr ""

#: ../../../src/aiida/storage/sqlite_dos/__init__.py:docstring of aiida.storage.sqlite_dos:1
#: ../../../src/aiida/storage/sqlite_dos/backend.py:docstring of aiida.storage.sqlite_dos.backend:1
#: ../../../src/aiida/storage/sqlite_dos/backend.py:docstring of aiida.storage.sqlite_dos.backend.SqliteDosMigrator:1
msgid "Storage implementation using Sqlite database and disk-objectstore container."
msgstr ""

#: ../../../src/aiida/storage/sqlite_dos/backend.py:docstring of aiida.storage.sqlite_dos.backend.SqliteDosMigrator:1
msgid "Bases: :py:class:`~aiida.storage.psql_dos.migrator.PsqlDosMigrator`"
msgstr ""

#: ../../../src/aiida/storage/sqlite_dos/backend.py:docstring of aiida.storage.sqlite_dos.backend.SqliteDosMigrator:3
msgid "This storage backend is not recommended for use in production. The sqlite database is not the most performant and it does not support all the ``QueryBuilder`` functionality that is supported by the ``core.psql_dos`` storage backend. This storage is ideally suited for use cases that want to test or demo AiiDA as it requires no server but just a folder on the local filesystem."
msgstr ""

#: ../../../src/aiida/storage/sqlite_dos/backend.py:docstring of aiida.storage.sqlite_dos.backend.SqliteDosStorage:1
msgid "Bases: :py:class:`~aiida.storage.psql_dos.backend.PsqlDosBackend`"
msgstr ""

#: ../../../src/aiida/storage/sqlite_dos/backend.py:docstring of aiida.storage.sqlite_dos.backend.SqliteDosStorage:1
msgid "A lightweight backend intended for demos and testing."
msgstr ""

#: ../../../src/aiida/storage/sqlite_dos/backend.py:docstring of aiida.storage.sqlite_dos.backend.SqliteDosStorage:3
msgid "This backend implementation uses an Sqlite database and"
msgstr ""

#: ../../../src/aiida/storage/sqlite_dos/backend.py:docstring of aiida.storage.sqlite_dos.backend.SqliteDosStorage.Configuration.filepath_is_absolute:1
msgid "Return the resolved and absolute filepath."
msgstr ""

#: ../../../src/aiida/storage/sqlite_dos/backend.py:docstring of aiida.storage.sqlite_dos.backend.SqliteDosStorage.get_backend_entity:1
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.get_backend_entity:1
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.get_backend_entity:1
msgid "Return the backend entity that corresponds to the given Model instance."
msgstr ""

#: ../../source/reference/apidoc/aiida.storage.sqlite_temp.rst:2
msgid "aiida.storage.sqlite\\_temp package"
msgstr ""

#: ../../../src/aiida/storage/sqlite_temp/__init__.py:docstring of aiida.storage.sqlite_temp:1
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend:1
msgid "A temporary backend, using an in-memory sqlite database."
msgstr ""

#: ../../../src/aiida/storage/sqlite_temp/__init__.py:docstring of aiida.storage.sqlite_temp:3
#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend:3
msgid "This backend is intended for testing and demonstration purposes. Whenever it is instantiated, it creates a fresh storage backend, and destroys it when it is garbage collected."
msgstr ""

#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend:1
msgid "Definition of the ``SqliteTempBackend`` backend."
msgstr ""

#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SandboxShaRepositoryBackend:1
msgid "Bases: :py:class:`~aiida.repository.backend.sandbox.SandboxRepositoryBackend`"
msgstr ""

#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SandboxShaRepositoryBackend:1
msgid "A sandbox repository backend that uses the sha256 of the file as the key."
msgstr ""

#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SandboxShaRepositoryBackend:3
msgid "This allows for compatibility with the archive format (i.e. `SqliteZipBackend`). Which allows for temporary profiles to be exported and imported."
msgstr ""

#: ../../docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.cli_exposed:1
msgid "Ensure this plugin is not exposed in ``verdi profile setup``."
msgstr ""

#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.create_profile:1
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.create_profile:1
msgid "Create a new profile instance for this backend, from the path to the zip file."
msgstr ""

#: ../../../src/aiida/storage/sqlite_temp/backend.py:docstring of aiida.storage.sqlite_temp.backend.SqliteTempBackend.get_session:1
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.get_session:1
msgid "Return an SQLAlchemy session."
msgstr ""

#: ../../source/reference/apidoc/aiida.storage.sqlite_zip.rst:2
msgid "aiida.storage.sqlite\\_zip package"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/__init__.py:docstring of aiida.storage.sqlite_zip:1
msgid "Module with implementation of the storage backend, using an SQLite database and repository files, within a zipfile."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/__init__.py:docstring of aiida.storage.sqlite_zip:4
#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/main.py:docstring of aiida.tools.archive.implementations.sqlite_zip.main.ArchiveFormatSqlZip:3
msgid "The content of the zip file is::"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/__init__.py:docstring of aiida.storage.sqlite_zip:14
msgid "For quick access, the metadata (such as the version) is stored in a `metadata.json` file, at the \"top\" of the zip file, with the sqlite database, just below it, then the repository files. Repository files are named by their SHA256 content hash."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/__init__.py:docstring of aiida.storage.sqlite_zip:18
msgid "This storage method is primarily intended for the AiiDA archive, as a read-only storage method. This is because sqlite and zip are not suitable for concurrent write access."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/__init__.py:docstring of aiida.storage.sqlite_zip:22
msgid "The archive format originally used a JSON file to store the database, and these revisions are handled by the `version_profile` and `migrate` backend methods."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend:1
msgid "The table models are dynamically generated from the sqlalchemy backend models."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.FolderBackendRepository:1
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.ZipfileBackendRepository:1
msgid "Bases: :py:class:`~aiida.storage.sqlite_zip.backend._RoBackendRepository`"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.FolderBackendRepository:1
msgid "A read-only backend for a folder."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.FolderBackendRepository:3
msgid "The folder should contain repository files, named by the sha256 hash of the file contents."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend:1
msgid "A read-only backend for a sqlite/zip format."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend:3
msgid "The storage format uses an SQLite database and repository files, within a folder or zipfile."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend:5
msgid "The content of the folder/zipfile should be::"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.Configuration.filepath_exists_and_is_absolute:1
msgid "Validate the filepath exists and return the resolved and absolute filepath."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.close:1
msgid "Close the backend"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.initialise:1
msgid "Initialise an instance of the ``SqliteZipBackend`` storage backend."
msgstr ""

#: ../../docstring of aiida.storage.sqlite_zip.backend.SqliteZipBackend.read_only:1
msgid "This plugin is read only and data cannot be created or mutated."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.ZipfileBackendRepository:1
msgid "A read-only backend for a zip file."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.ZipfileBackendRepository:3
msgid "The zip file should contain repository files with the key format: ``repo/<sha256 hash>``, i.e. files named by the sha256 hash of the file contents, inside a ``repo`` directory."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.ZipfileBackendRepository.__init__:1
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend._RoBackendRepository.__init__:1
msgid "Initialise the repository backend."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.ZipfileBackendRepository.__init__:3
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend._RoBackendRepository.__init__:3
msgid "the path to the zip file"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.ZipfileBackendRepository._zipfile:1
msgid "Return the open zip file."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend.ZipfileBackendRepository.close:1
#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend._RoBackendRepository.close:1
msgid "Close the repository."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/backend.py:docstring of aiida.storage.sqlite_zip.backend._RoBackendRepository:1
msgid "A backend abstract for a read-only folder or zip file."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrator.py:docstring of aiida.storage.sqlite_zip.migrator:1
msgid "Versioning and migration implementation for the sqlite_zip format."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrator.py:docstring of aiida.storage.sqlite_zip.migrator._perform_legacy_migrations:1
msgid "Perform legacy migrations from the current version to the desired version."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrator.py:docstring of aiida.storage.sqlite_zip.migrator._perform_legacy_migrations:3
msgid "Legacy archives use the old ``data.json`` format for storing the database. These migrations simply manipulate the metadata and data in-place."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrator.py:docstring of aiida.storage.sqlite_zip.migrator._perform_legacy_migrations:6
msgid "current version of the archive"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrator.py:docstring of aiida.storage.sqlite_zip.migrator._perform_legacy_migrations:7
#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveFormatAbstract.migrate:5
msgid "version to migrate to"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy_to_main.py:docstring of aiida.storage.sqlite_zip.migrations.legacy_to_main.perform_v1_migration:8
#: ../../../src/aiida/storage/sqlite_zip/migrator.py:docstring of aiida.storage.sqlite_zip.migrator._perform_legacy_migrations:8
msgid "the metadata to migrate"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy_to_main.py:docstring of aiida.storage.sqlite_zip.migrations.legacy_to_main.perform_v1_migration:9
#: ../../../src/aiida/storage/sqlite_zip/migrator.py:docstring of aiida.storage.sqlite_zip.migrator._perform_legacy_migrations:9
msgid "the data to migrate"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrator.py:docstring of aiida.storage.sqlite_zip.migrator._perform_legacy_migrations:10
msgid "the new version of the archive"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrator.py:docstring of aiida.storage.sqlite_zip.migrator._read_json:1
msgid "Read a JSON file from the archive."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrator.py:docstring of aiida.storage.sqlite_zip.migrator.migrate:1
msgid "Migrate an `sqlite_zip` storage file to a specific version."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrator.py:docstring of aiida.storage.sqlite_zip.migrator.migrate:3
msgid "Historically, this format could be a zip or a tar file, contained the database as a bespoke JSON format, and the repository files in the \"legacy\" per-node format. For these versions, we first migrate the JSON database to the final legacy schema, then we convert this file to the SQLite database, whilst sequentially migrating the repository files."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrator.py:docstring of aiida.storage.sqlite_zip.migrator.migrate:8
msgid "Once any legacy migrations have been performed, we can then migrate the SQLite database to the final schema, using alembic."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrator.py:docstring of aiida.storage.sqlite_zip.migrator.migrate:11
msgid "Note that, to minimise disk space usage, we never fully extract/uncompress the input file (except when migrating from a legacy tar file, whereby we cannot extract individual files):"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrator.py:docstring of aiida.storage.sqlite_zip.migrator.migrate:14
msgid "The sqlite database is extracted to a temporary location and migrated"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrator.py:docstring of aiida.storage.sqlite_zip.migrator.migrate:15
msgid "A new zip file is opened, within a temporary folder"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrator.py:docstring of aiida.storage.sqlite_zip.migrator.migrate:16
msgid "The repository files are \"streamed\" directly between the input file and the new zip file"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrator.py:docstring of aiida.storage.sqlite_zip.migrator.migrate:17
msgid "The sqlite database and metadata JSON are written to the new zip file"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrator.py:docstring of aiida.storage.sqlite_zip.migrator.migrate:18
msgid "The new zip file is closed (which writes its final central directory)"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrator.py:docstring of aiida.storage.sqlite_zip.migrator.migrate:19
msgid "The new zip file is moved to the output location, removing any existing file if `force=True`"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrator.py:docstring of aiida.storage.sqlite_zip.migrator.migrate:21
msgid "Path to the file"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrator.py:docstring of aiida.storage.sqlite_zip.migrator.migrate:22
msgid "Path to output the migrated file"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrator.py:docstring of aiida.storage.sqlite_zip.migrator.migrate:23
msgid "Target version"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrator.py:docstring of aiida.storage.sqlite_zip.migrator.migrate:24
msgid "If True, overwrite the output file if it exists"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrator.py:docstring of aiida.storage.sqlite_zip.migrator.migrate:25
msgid "Compression level for the output file"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrator.py:docstring of aiida.storage.sqlite_zip.migrator.validate_storage:1
msgid "Validate that the storage is at the head version."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrator.py:docstring of aiida.storage.sqlite_zip.migrator.validate_storage:3
msgid ":class:`aiida.common.exceptions.UnreachableStorage` if the file does not exist"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrator.py:docstring of aiida.storage.sqlite_zip.migrator.validate_storage:4
msgid ":class:`aiida.common.exceptions.CorruptStorage` if the version cannot be read from the storage."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/models.py:docstring of aiida.storage.sqlite_zip.models:1
msgid "This module contains the SQLAlchemy models for the SQLite backend."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/models.py:docstring of aiida.storage.sqlite_zip.models:3
msgid "These models are intended to be identical to those of the `psql_dos` backend, except for changes to the database specific types:"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/models.py:docstring of aiida.storage.sqlite_zip.models:6
msgid "UUID -> CHAR(32)"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/models.py:docstring of aiida.storage.sqlite_zip.models:7
msgid "DateTime -> TZDateTime"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/models.py:docstring of aiida.storage.sqlite_zip.models:8
msgid "JSONB -> JSON"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/models.py:docstring of aiida.storage.sqlite_zip.models:10
msgid "Also, `varchar_pattern_ops` indexes are not possible in sqlite."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/models.py:docstring of aiida.storage.sqlite_zip.models.DbAuthInfo:1
#: ../../../src/aiida/storage/sqlite_zip/models.py:docstring of aiida.storage.sqlite_zip.models.DbComment:1
#: ../../../src/aiida/storage/sqlite_zip/models.py:docstring of aiida.storage.sqlite_zip.models.DbComputer:1
#: ../../../src/aiida/storage/sqlite_zip/models.py:docstring of aiida.storage.sqlite_zip.models.DbGroup:1
#: ../../../src/aiida/storage/sqlite_zip/models.py:docstring of aiida.storage.sqlite_zip.models.DbLink:1
#: ../../../src/aiida/storage/sqlite_zip/models.py:docstring of aiida.storage.sqlite_zip.models.DbLog:1
#: ../../../src/aiida/storage/sqlite_zip/models.py:docstring of aiida.storage.sqlite_zip.models.DbNode:1
#: ../../../src/aiida/storage/sqlite_zip/models.py:docstring of aiida.storage.sqlite_zip.models.DbUser:1
msgid "Bases: :py:class:`~sqlalchemy.orm.decl_api.SqliteModel`"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/models.py:docstring of aiida.storage.sqlite_zip.models.SqliteModel:1
msgid "Represent a row in an sqlite database table"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/models.py:docstring of aiida.storage.sqlite_zip.models.TZDateTime:1
msgid "Bases: :py:class:`~sqlalchemy.sql.type_api.TypeDecorator`"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/models.py:docstring of aiida.storage.sqlite_zip.models.TZDateTime:1
msgid "A timezone naive UTC ``DateTime`` implementation for SQLite."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/models.py:docstring of aiida.storage.sqlite_zip.models.TZDateTime:3
msgid "see: https://docs.sqlalchemy.org/en/14/core/custom_types.html#store-timezone-aware-timestamps-as-timezone-naive-utc"
msgstr ""

#: ../../docstring of aiida.storage.sqlite_zip.models.TZDateTime.cache_ok:1
msgid "Indicate if statements using this :class:`.ExternalType` are \"safe to cache\"."
msgstr ""

#: ../../docstring of aiida.storage.sqlite_zip.models.TZDateTime.cache_ok:4
msgid "The default value ``None`` will emit a warning and then not allow caching of a statement which includes this type.   Set to ``False`` to disable statements using this type from being cached at all without a warning. When set to ``True``, the object's class and selected elements from its state will be used as part of the cache key.  For example, using a :class:`.TypeDecorator`::"
msgstr ""

#: ../../docstring of aiida.storage.sqlite_zip.models.TZDateTime.cache_ok:20
msgid "The cache key for the above type would be equivalent to::"
msgstr ""

#: ../../docstring of aiida.storage.sqlite_zip.models.TZDateTime.cache_ok:25
msgid "The caching scheme will extract attributes from the type that correspond to the names of parameters in the ``__init__()`` method.  Above, the \"choices\" attribute becomes part of the cache key but \"internal_only\" does not, because there is no parameter named \"internal_only\"."
msgstr ""

#: ../../docstring of aiida.storage.sqlite_zip.models.TZDateTime.cache_ok:30
msgid "The requirements for cacheable elements is that they are hashable and also that they indicate the same SQL rendered for expressions using this type every time for a given cache value."
msgstr ""

#: ../../docstring of aiida.storage.sqlite_zip.models.TZDateTime.cache_ok:34
msgid "To accommodate for datatypes that refer to unhashable structures such as dictionaries, sets and lists, these objects can be made \"cacheable\" by assigning hashable structures to the attributes whose names correspond with the names of the arguments.  For example, a datatype which accepts a dictionary of lookup values may publish this as a sorted series of tuples.   Given a previously un-cacheable type as::"
msgstr ""

#: ../../docstring of aiida.storage.sqlite_zip.models.TZDateTime.cache_ok:58
msgid "Where \"lookup\" is a dictionary.  The type will not be able to generate a cache key::"
msgstr ""

#: ../../docstring of aiida.storage.sqlite_zip.models.TZDateTime.cache_ok:69
msgid "If we **did** set up such a cache key, it wouldn't be usable. We would get a tuple structure that contains a dictionary inside of it, which cannot itself be used as a key in a \"cache dictionary\" such as SQLAlchemy's statement cache, since Python dictionaries aren't hashable::"
msgstr ""

#: ../../docstring of aiida.storage.sqlite_zip.models.TZDateTime.cache_ok:88
msgid "The type may be made cacheable by assigning a sorted tuple of tuples to the \".lookup\" attribute::"
msgstr ""

#: ../../docstring of aiida.storage.sqlite_zip.models.TZDateTime.cache_ok:119
msgid "Where above, the cache key for ``LookupType({\"a\": 10, \"b\": 20})`` will be::"
msgstr ""

#: ../../docstring of aiida.storage.sqlite_zip.models.TZDateTime.cache_ok:124
msgid "- added the ``cache_ok`` flag to allow some configurability of caching for :class:`.TypeDecorator` classes."
msgstr ""

#: ../../docstring of aiida.storage.sqlite_zip.models.TZDateTime.cache_ok:127
msgid "- added the :class:`.ExternalType` mixin which generalizes the ``cache_ok`` flag to both the :class:`.TypeDecorator` and :class:`.UserDefinedType` classes."
msgstr ""

#: ../../docstring of aiida.storage.sqlite_zip.models.TZDateTime.cache_ok:133
msgid ":ref:`sql_caching`"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/models.py:docstring of aiida.storage.sqlite_zip.models.TZDateTime.process_bind_param:1
msgid "Process before writing to database."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/models.py:docstring of aiida.storage.sqlite_zip.models.TZDateTime.process_result_value:1
msgid "Process when returning from database."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/models.py:docstring of aiida.storage.sqlite_zip.models.create_orm_cls:1
msgid "Create an ORM class from an existing table in the declarative meta"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/models.py:docstring of aiida.storage.sqlite_zip.models.get_model_from_entity:1
msgid "Return the Sqlalchemy model and column names corresponding to the given entity."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/models.py:docstring of aiida.storage.sqlite_zip.models.pg_to_sqlite:1
msgid "Convert a model intended for PostGreSQL to one compatible with SQLite"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/orm.py:docstring of aiida.storage.sqlite_zip.orm:1
msgid "This module contains the AiiDA backend ORM classes for the SQLite backend."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/orm.py:docstring of aiida.storage.sqlite_zip.orm:3
msgid "It re-uses the classes already defined in ``psql_dos`` backend (for PostGresQL), but redefines the SQLAlchemy models to the SQLite compatible ones."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/orm.py:docstring of aiida.storage.sqlite_zip.orm.SqliteAuthInfo:1
msgid "Bases: :py:class:`~aiida.storage.sqlite_zip.orm.SqliteEntityOverride`, :py:class:`~aiida.storage.psql_dos.orm.authinfos.SqlaAuthInfo`"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/orm.py:docstring of aiida.storage.sqlite_zip.orm.SqliteAuthInfoCollection:1
msgid "Bases: :py:class:`~aiida.storage.psql_dos.orm.authinfos.SqlaAuthInfoCollection`"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/orm.py:docstring of aiida.storage.sqlite_zip.orm.SqliteComment:1
msgid "Bases: :py:class:`~aiida.storage.sqlite_zip.orm.SqliteEntityOverride`, :py:class:`~aiida.storage.psql_dos.orm.comments.SqlaComment`"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/orm.py:docstring of aiida.storage.sqlite_zip.orm.SqliteCommentCollection:1
msgid "Bases: :py:class:`~aiida.storage.psql_dos.orm.comments.SqlaCommentCollection`"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/orm.py:docstring of aiida.storage.sqlite_zip.orm.SqliteComputer:1
msgid "Bases: :py:class:`~aiida.storage.sqlite_zip.orm.SqliteEntityOverride`, :py:class:`~aiida.storage.psql_dos.orm.computers.SqlaComputer`"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/orm.py:docstring of aiida.storage.sqlite_zip.orm.SqliteComputerCollection:1
msgid "Bases: :py:class:`~aiida.storage.psql_dos.orm.computers.SqlaComputerCollection`"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/orm.py:docstring of aiida.storage.sqlite_zip.orm.SqliteEntityOverride:1
msgid "Overrides type-checking of psql_dos ``Entity``."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/orm.py:docstring of aiida.storage.sqlite_zip.orm.SqliteGroup:1
msgid "Bases: :py:class:`~aiida.storage.sqlite_zip.orm.SqliteEntityOverride`, :py:class:`~aiida.storage.psql_dos.orm.groups.SqlaGroup`"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/orm.py:docstring of aiida.storage.sqlite_zip.orm.SqliteGroupCollection:1
msgid "Bases: :py:class:`~aiida.storage.psql_dos.orm.groups.SqlaGroupCollection`"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/orm.py:docstring of aiida.storage.sqlite_zip.orm.SqliteLog:1
msgid "Bases: :py:class:`~aiida.storage.sqlite_zip.orm.SqliteEntityOverride`, :py:class:`~aiida.storage.psql_dos.orm.logs.SqlaLog`"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/orm.py:docstring of aiida.storage.sqlite_zip.orm.SqliteLogCollection:1
msgid "Bases: :py:class:`~aiida.storage.psql_dos.orm.logs.SqlaLogCollection`"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/orm.py:docstring of aiida.storage.sqlite_zip.orm.SqliteNode:1
msgid "Bases: :py:class:`~aiida.storage.sqlite_zip.orm.SqliteEntityOverride`, :py:class:`~aiida.storage.psql_dos.orm.nodes.SqlaNode`"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/orm.py:docstring of aiida.storage.sqlite_zip.orm.SqliteNodeCollection:1
msgid "Bases: :py:class:`~aiida.storage.psql_dos.orm.nodes.SqlaNodeCollection`"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/orm.py:docstring of aiida.storage.sqlite_zip.orm.SqliteQueryBuilder:1
msgid "Bases: :py:class:`~aiida.storage.psql_dos.orm.querybuilder.main.SqlaQueryBuilder`"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/orm.py:docstring of aiida.storage.sqlite_zip.orm.SqliteQueryBuilder:1
msgid "QueryBuilder to use with SQLAlchemy-backend, adapted for SQLite."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/orm.py:docstring of aiida.storage.sqlite_zip.orm.SqliteQueryBuilder.get_filter_expr_from_jsonb:1
msgid "Return a filter expression."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/orm.py:docstring of aiida.storage.sqlite_zip.orm.SqliteQueryBuilder.get_filter_expr_from_jsonb:3
msgid "See: https://www.sqlite.org/json1.html"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/orm.py:docstring of aiida.storage.sqlite_zip.orm.SqliteUser:1
msgid "Bases: :py:class:`~aiida.storage.sqlite_zip.orm.SqliteEntityOverride`, :py:class:`~aiida.storage.psql_dos.orm.users.SqlaUser`"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/orm.py:docstring of aiida.storage.sqlite_zip.orm.SqliteUserCollection:1
msgid "Bases: :py:class:`~aiida.storage.psql_dos.orm.users.SqlaUserCollection`"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/utils.py:docstring of aiida.storage.sqlite_zip.utils:1
msgid "Utilities for this backend."
msgstr ""

#: ../../docstring of aiida.storage.sqlite_zip.utils.DB_FILENAME:1
msgid "The filename of the SQLite database."
msgstr ""

#: ../../docstring of aiida.storage.sqlite_zip.utils.META_FILENAME:1
msgid "The filename containing meta information about the storage instance."
msgstr ""

#: ../../docstring of aiida.storage.sqlite_zip.utils.REPO_FOLDER:1
msgid "The name of the folder containing the repository files."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/utils.py:docstring of aiida.storage.sqlite_zip.utils.ReadOnlyError:1
msgid "Raised when a write operation is called on a read-only archive."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/utils.py:docstring of aiida.storage.sqlite_zip.utils.create_sqla_engine:1
msgid "Create a new engine instance."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/utils.py:docstring of aiida.storage.sqlite_zip.utils.extract_metadata:1
msgid "Extract the metadata dictionary from the archive."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/utils.py:docstring of aiida.storage.sqlite_zip.utils.extract_metadata:3
#: ../../../src/aiida/storage/sqlite_zip/utils.py:docstring of aiida.storage.sqlite_zip.utils.read_version:6
msgid "the maximum number of records to search for the metadata file in a zip file."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/utils.py:docstring of aiida.storage.sqlite_zip.utils.read_version:1
msgid "Read the version of the storage instance from the path."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/utils.py:docstring of aiida.storage.sqlite_zip.utils.read_version:3
msgid "This is intended to work for all versions of the storage format."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/utils.py:docstring of aiida.storage.sqlite_zip.utils.read_version:5
msgid "path to storage instance, either a folder, zip file or tar file."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/utils.py:docstring of aiida.storage.sqlite_zip.utils.read_version:8
msgid "``UnreachableStorage`` if a version cannot be read from the file"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/utils.py:docstring of aiida.storage.sqlite_zip.utils.sqlite_case_sensitive_like:1
msgid "Enforce case sensitive like operations (off by default)."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/utils.py:docstring of aiida.storage.sqlite_zip.utils.sqlite_case_sensitive_like:3
msgid "See: https://www.sqlite.org/pragma.html#pragma_case_sensitive_like"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/utils.py:docstring of aiida.storage.sqlite_zip.utils.sqlite_enforce_foreign_keys:1
msgid "Enforce foreign key constraints, when using sqlite backend (off by default)."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/utils.py:docstring of aiida.storage.sqlite_zip.utils.sqlite_enforce_foreign_keys:3
msgid "See: https://www.sqlite.org/pragma.html#pragma_foreign_keys"
msgstr ""

#: ../../source/reference/apidoc/aiida.storage.sqlite_zip.migrations.rst:2
msgid "aiida.storage.sqlite\\_zip.migrations package"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy_to_main.py:docstring of aiida.storage.sqlite_zip.migrations.legacy_to_main:1
msgid "Migration from the \"legacy\" JSON format, to an sqlite database, and node uuid based repository to hash based."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy_to_main.py:docstring of aiida.storage.sqlite_zip.migrations.legacy_to_main._create_repo_metadata:1
msgid "Create the repository metadata."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy_to_main.py:docstring of aiida.storage.sqlite_zip.migrations.legacy_to_main._create_repo_metadata:3
msgid "list of (path, hashkey) tuples"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy_to_main.py:docstring of aiida.storage.sqlite_zip.migrations.legacy_to_main._iter_entity_fields:1
msgid "Iterate through entity fields."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy_to_main.py:docstring of aiida.storage.sqlite_zip.migrations.legacy_to_main._json_to_sqlite:1
msgid "Convert a JSON archive format to SQLite."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy_to_main.py:docstring of aiida.storage.sqlite_zip.migrations.legacy_to_main.perform_v1_migration:1
msgid "Perform the repository and JSON to SQLite migration."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy_to_main.py:docstring of aiida.storage.sqlite_zip.migrations.legacy_to_main.perform_v1_migration:3
msgid "Iterate though the repository paths in the archive"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy_to_main.py:docstring of aiida.storage.sqlite_zip.migrations.legacy_to_main.perform_v1_migration:4
msgid "If a file, hash its contents and, if not already present, stream it to the new archive"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy_to_main.py:docstring of aiida.storage.sqlite_zip.migrations.legacy_to_main.perform_v1_migration:5
msgid "Store a mapping of the node UUIDs to a list of (path, hashkey or None if a directory) tuples"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy_to_main.py:docstring of aiida.storage.sqlite_zip.migrations.legacy_to_main.perform_v1_migration:7
msgid "the input path to the old archive"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy_to_main.py:docstring of aiida.storage.sqlite_zip.migrations.legacy_to_main.perform_v1_migration:11
msgid ":returns:the path to the sqlite database file"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/utils.py:docstring of aiida.storage.sqlite_zip.migrations.utils:1
msgid "Common variables"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/utils.py:docstring of aiida.storage.sqlite_zip.migrations.utils.copy_tar_to_zip:1
msgid "Create a new zip file from an existing tar file."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/utils.py:docstring of aiida.storage.sqlite_zip.migrations.utils.copy_tar_to_zip:3
msgid "The tar file is first extracted to a temporary directory, and then the new zip file is created, with the ``path_callback`` allowing for per path modifications. The new zip file is first created in a temporary directory, and then moved to the desired location."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/utils.py:docstring of aiida.storage.sqlite_zip.migrations.utils.copy_tar_to_zip:7
#: ../../../src/aiida/storage/sqlite_zip/migrations/utils.py:docstring of aiida.storage.sqlite_zip.migrations.utils.copy_zip_to_zip:7
msgid "the path to the existing archive"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/utils.py:docstring of aiida.storage.sqlite_zip.migrations.utils.copy_tar_to_zip:8
#: ../../../src/aiida/storage/sqlite_zip/migrations/utils.py:docstring of aiida.storage.sqlite_zip.migrations.utils.copy_zip_to_zip:8
msgid "the path to output the new archive"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/utils.py:docstring of aiida.storage.sqlite_zip.migrations.utils.copy_tar_to_zip:9
#: ../../../src/aiida/storage/sqlite_zip/migrations/utils.py:docstring of aiida.storage.sqlite_zip.migrations.utils.copy_zip_to_zip:9
msgid "a callback that is called for each path in the archive: ``(inpath, outpath) -> handled`` If handled is ``True``, the path is assumed to already have been copied to the new zip file."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/utils.py:docstring of aiida.storage.sqlite_zip.migrations.utils.copy_tar_to_zip:11
#: ../../../src/aiida/storage/sqlite_zip/migrations/utils.py:docstring of aiida.storage.sqlite_zip.migrations.utils.copy_zip_to_zip:11
msgid "the default compression level to use for the new zip file"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/utils.py:docstring of aiida.storage.sqlite_zip.migrations.utils.copy_tar_to_zip:12
#: ../../../src/aiida/storage/sqlite_zip/migrations/utils.py:docstring of aiida.storage.sqlite_zip.migrations.utils.copy_zip_to_zip:12
msgid "whether to overwrite the output file if it already exists"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/utils.py:docstring of aiida.storage.sqlite_zip.migrations.utils.copy_tar_to_zip:13
#: ../../../src/aiida/storage/sqlite_zip/migrations/utils.py:docstring of aiida.storage.sqlite_zip.migrations.utils.copy_zip_to_zip:13
msgid "the title of the progress bar"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/utils.py:docstring of aiida.storage.sqlite_zip.migrations.utils.copy_tar_to_zip:14
#: ../../../src/aiida/storage/sqlite_zip/migrations/utils.py:docstring of aiida.storage.sqlite_zip.migrations.utils.copy_zip_to_zip:14
msgid "``ZipInfo`` for these file names will be written first to the zip central directory. This allows for faster reading of these files, with ``archive_path.read_file_in_zip``."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/utils.py:docstring of aiida.storage.sqlite_zip.migrations.utils.copy_zip_to_zip:1
msgid "Create a new zip file from an existing zip file."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/utils.py:docstring of aiida.storage.sqlite_zip.migrations.utils.copy_zip_to_zip:3
msgid "All files/folders are streamed directly to the new zip file, with the ``path_callback`` allowing for per path modifications. The new zip file is first created in a temporary directory, and then moved to the desired location."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/utils.py:docstring of aiida.storage.sqlite_zip.migrations.utils.update_metadata:1
msgid "Update the metadata with a new version number and a notification of the conversion that was executed."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v04_to_v05.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v04_to_v05.remove_fields:3
#: ../../../src/aiida/storage/sqlite_zip/migrations/utils.py:docstring of aiida.storage.sqlite_zip.migrations.utils.update_metadata:3
#: ../../../src/aiida/storage/sqlite_zip/migrations/utils.py:docstring of aiida.storage.sqlite_zip.migrations.utils.verify_metadata_version:5
msgid "the content of an export archive metadata.json file"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/utils.py:docstring of aiida.storage.sqlite_zip.migrations.utils.update_metadata:4
msgid "string version number that the updated metadata should get"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/utils.py:docstring of aiida.storage.sqlite_zip.migrations.utils.verify_metadata_version:1
msgid "Utility function to verify that the metadata has the correct version number."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/utils.py:docstring of aiida.storage.sqlite_zip.migrations.utils.verify_metadata_version:3
msgid "If no version number is passed, it will just extract the version number and return it."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/utils.py:docstring of aiida.storage.sqlite_zip.migrations.utils.verify_metadata_version:6
msgid "string version number that the metadata is expected to have"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/v1_db_schema.py:docstring of aiida.storage.sqlite_zip.migrations.v1_db_schema:1
msgid "This is the sqlite DB schema, coresponding to the `main_0000` revision of the `sqlite_zip` backend, see: `versions/main_0000_initial.py`"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/v1_db_schema.py:docstring of aiida.storage.sqlite_zip.migrations.v1_db_schema:4
msgid "For normal operation of the archive, we auto-generate the schema from the models in ``aiida.storage.psql_dos.models``. However, when migrating an archive from the old format, we require a fixed revision of the schema."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/v1_db_schema.py:docstring of aiida.storage.sqlite_zip.migrations.v1_db_schema:8
msgid "The only difference between the PostGreSQL schema and SQLite one, is the replacement of ``JSONB`` with ``JSON``, and ``UUID`` with ``CHAR(32)``."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/v1_db_schema.py:docstring of aiida.storage.sqlite_zip.migrations.v1_db_schema.DbAuthInfo:1
#: ../../../src/aiida/storage/sqlite_zip/migrations/v1_db_schema.py:docstring of aiida.storage.sqlite_zip.migrations.v1_db_schema.DbComment:1
#: ../../../src/aiida/storage/sqlite_zip/migrations/v1_db_schema.py:docstring of aiida.storage.sqlite_zip.migrations.v1_db_schema.DbComputer:1
#: ../../../src/aiida/storage/sqlite_zip/migrations/v1_db_schema.py:docstring of aiida.storage.sqlite_zip.migrations.v1_db_schema.DbGroup:1
#: ../../../src/aiida/storage/sqlite_zip/migrations/v1_db_schema.py:docstring of aiida.storage.sqlite_zip.migrations.v1_db_schema.DbGroupNodes:1
#: ../../../src/aiida/storage/sqlite_zip/migrations/v1_db_schema.py:docstring of aiida.storage.sqlite_zip.migrations.v1_db_schema.DbLink:1
#: ../../../src/aiida/storage/sqlite_zip/migrations/v1_db_schema.py:docstring of aiida.storage.sqlite_zip.migrations.v1_db_schema.DbLog:1
#: ../../../src/aiida/storage/sqlite_zip/migrations/v1_db_schema.py:docstring of aiida.storage.sqlite_zip.migrations.v1_db_schema.DbNode:1
#: ../../../src/aiida/storage/sqlite_zip/migrations/v1_db_schema.py:docstring of aiida.storage.sqlite_zip.migrations.v1_db_schema.DbUser:1
msgid "Bases: :py:class:`~sqlalchemy.orm.decl_api.Base`"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/v1_db_schema.py:docstring of aiida.storage.sqlite_zip.migrations.v1_db_schema.DbAuthInfo:1
msgid "Class that keeps the authentication data."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/v1_db_schema.py:docstring of aiida.storage.sqlite_zip.migrations.v1_db_schema.DbComment:1
msgid "Class to store comments."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/v1_db_schema.py:docstring of aiida.storage.sqlite_zip.migrations.v1_db_schema.DbComputer:1
msgid "Class to store computers."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/v1_db_schema.py:docstring of aiida.storage.sqlite_zip.migrations.v1_db_schema.DbGroup:1
msgid "Class to store groups."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/v1_db_schema.py:docstring of aiida.storage.sqlite_zip.migrations.v1_db_schema.DbGroupNodes:1
msgid "Class to store join table for group -> nodes."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/v1_db_schema.py:docstring of aiida.storage.sqlite_zip.migrations.v1_db_schema.DbLink:1
msgid "Class to store links between nodes."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/v1_db_schema.py:docstring of aiida.storage.sqlite_zip.migrations.v1_db_schema.DbLog:1
msgid "Class to store logs."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/v1_db_schema.py:docstring of aiida.storage.sqlite_zip.migrations.v1_db_schema.DbNode:1
msgid "Class to store nodes."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/v1_db_schema.py:docstring of aiida.storage.sqlite_zip.migrations.v1_db_schema.DbUser:1
msgid "Class to store users."
msgstr ""

#: ../../source/reference/apidoc/aiida.storage.sqlite_zip.migrations.legacy.rst:2
msgid "aiida.storage.sqlite\\_zip.migrations.legacy package"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/__init__.py:docstring of aiida.storage.sqlite_zip.migrations.legacy:1
msgid "Legacy migrations, using the old ``data.json`` format for storing the database."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/__init__.py:docstring of aiida.storage.sqlite_zip.migrations.legacy:4
msgid "These migrations simply manipulate the metadata and data in-place."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v04_to_v05.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v04_to_v05:1
msgid "Migration from v0.4 to v0.5, used by `verdi export migrate` command."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v04_to_v05.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v04_to_v05:3
#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v05_to_v06.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v05_to_v06:3
#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v06_to_v07.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v06_to_v07:3
#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v07_to_v08.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v07_to_v08:3
#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v08_to_v09.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v08_to_v09:3
msgid "The migration steps are named similarly to the database migrations for Django and SQLAlchemy. In the description of each migration, a revision number is given, which refers to the Django migrations. The individual Django database migrations may be found at:"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v04_to_v05.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v04_to_v05:7
#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v05_to_v06.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v05_to_v06:7
#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v06_to_v07.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v06_to_v07:7
#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v07_to_v08.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v07_to_v08:7
#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v08_to_v09.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v08_to_v09:7
msgid "`aiida.storage.djsite.db.migrations.00XX_<migration-name>.py`"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v04_to_v05.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v04_to_v05:9
#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v05_to_v06.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v05_to_v06:9
#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v06_to_v07.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v06_to_v07:9
#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v07_to_v08.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v07_to_v08:9
#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v08_to_v09.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v08_to_v09:9
msgid "Where XX are the numbers in the migrations' documentation: REV. 1.0.XX And migration-name is the name of the particular migration. The individual SQLAlchemy database migrations may be found at:"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v04_to_v05.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v04_to_v05:13
#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v05_to_v06.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v05_to_v06:13
#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v06_to_v07.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v06_to_v07:13
#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v07_to_v08.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v07_to_v08:13
#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v08_to_v09.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v08_to_v09:13
msgid "`aiida.storage.psql_dos.migrations.versions.<id>_<migration-name>.py`"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v04_to_v05.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v04_to_v05:15
#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v05_to_v06.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v05_to_v06:15
#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v06_to_v07.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v06_to_v07:15
#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v07_to_v08.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v07_to_v08:15
#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v08_to_v09.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v08_to_v09:15
msgid "Where id is a SQLA id and migration-name is the name of the particular migration."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v04_to_v05.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v04_to_v05.migrate_v4_to_v5:1
msgid "Migration of archive files from v0.4 to v0.5"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v04_to_v05.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v04_to_v05.migrate_v4_to_v5:3
msgid "This is from migration 0034 (drop_node_columns_nodeversion_public) and onwards"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v04_to_v05.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v04_to_v05.migration_drop_computer_transport_params:1
msgid "Apply migration 0036 - REV. 1.0.36 Drop the column `transport_params` from the `Computer` model"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v04_to_v05.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v04_to_v05.migration_drop_node_columns_nodeversion_public:1
msgid "Apply migration 0034 - REV. 1.0.34 Drop the columns `nodeversion` and `public` from the `Node` model"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v04_to_v05.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v04_to_v05.remove_fields:1
msgid "Remove fields under entities from data.json and metadata.json."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v04_to_v05.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v04_to_v05.remove_fields:4
msgid "the content of an export archive data.json file"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v04_to_v05.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v04_to_v05.remove_fields:5
msgid "list of ORM entities"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v04_to_v05.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v04_to_v05.remove_fields:6
msgid "list of fields to be removed from the export archive files"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v05_to_v06.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v05_to_v06:1
msgid "Migration from v0.5 to v0.6, used by `verdi export migrate` command."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v05_to_v06.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v05_to_v06.migrate_deserialized_datetime:1
msgid "Deserialize datetime strings from export archives, meaning to reattach the UTC timezone information."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v05_to_v06.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v05_to_v06.migrate_v5_to_v6:1
msgid "Migration of archive files from v0.5 to v0.6"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v05_to_v06.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v05_to_v06.migration_migrate_legacy_job_calculation_data:1
msgid "Apply migration 0038 - REV. 1.0.38"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v05_to_v06.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v05_to_v06.migration_migrate_legacy_job_calculation_data:3
msgid "Migrates legacy `JobCalculation` data to the new process system. Essentially old `JobCalculation` nodes, which have already been migrated to `CalcJobNodes`, are missing important attributes `process_state`, `exit_status` and `process_status`. These are inferred from the old `state` attribute, which is then discarded as its values have been deprecated."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v05_to_v06.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v05_to_v06.migration_serialize_datetime_objects:1
msgid "Apply migration 0037 - REV. 1.0.37"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v05_to_v06.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v05_to_v06.migration_serialize_datetime_objects:3
msgid "Migrates the node `attributes` and `extras` from the EAV schema to JSONB columns. Since JSON does not support datetime objects, and the EAV did, existing datetime objects have to be serialized to strings. Just like the database migration they were serialized to the standard ISO format, except that they were first converted to UTC timezone and then the stored without a timezone reference. Since existing datetimes in the attributes and extras in the database were timezone aware and have been migrated to an ISO format string *including* the timezone information we should now add the same timezone information to datetime attributes and extras in existing export archives. All that one needs to do for this is to append the `+00:00` suffix, which signifies the UTC timezone."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v05_to_v06.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v05_to_v06.migration_serialize_datetime_objects:11
msgid "Since the datetime objects were the only types being serialized in the attributes and extras, after the reinstating of the timeonze information, there is no longer a need for the de/serialization dictionaries for each node, stored in `node_attributes_conversion` and `node_extras_conversion`, respectively. They are no longer added to new archives and so they can and should be removed from existing archives, reducing the size enormously."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v06_to_v07.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v06_to_v07:1
msgid "Migration from v0.6 to v0.7, used by `verdi export migrate` command."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v06_to_v07.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v06_to_v07.data_migration_legacy_process_attributes:1
msgid "Apply migration 0040 - REV. 1.0.40 Data migration for some legacy process attributes."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v06_to_v07.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v06_to_v07.data_migration_legacy_process_attributes:4
msgid "Attribute keys that are renamed:"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v06_to_v07.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v06_to_v07.data_migration_legacy_process_attributes:6
msgid "`_sealed` -> `sealed`"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v06_to_v07.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v06_to_v07.data_migration_legacy_process_attributes:8
msgid "Attribute keys that are removed entirely:"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v06_to_v07.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v06_to_v07.data_migration_legacy_process_attributes:10
msgid "`_finished`"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v06_to_v07.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v06_to_v07.data_migration_legacy_process_attributes:11
msgid "`_failed`"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v06_to_v07.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v06_to_v07.data_migration_legacy_process_attributes:12
msgid "`_aborted`"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v06_to_v07.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v06_to_v07.data_migration_legacy_process_attributes:13
msgid "`_do_abort`"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v06_to_v07.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v06_to_v07.data_migration_legacy_process_attributes:15
msgid "Finally, after these first migrations, any remaining process nodes are screened for the existence of the `process_state` attribute. If they have it, it is checked whether the state is active or not, if not, the `sealed` attribute is created and set to `True`."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v06_to_v07.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v06_to_v07.data_migration_legacy_process_attributes:19
msgid "if a Node, found to have attributes, cannot be found in the list of exported entities."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v06_to_v07.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v06_to_v07.data_migration_legacy_process_attributes:21
msgid "if the 'sealed' attribute does not exist and the ProcessNode is in an active state, i.e. `process_state` is one of ('created', 'running', 'waiting'). A log-file, listing all illegal ProcessNodes, will be produced in the current directory."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v06_to_v07.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v06_to_v07.migrate_v6_to_v7:1
msgid "Migration of archive files from v0.6 to v0.7"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v06_to_v07.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v06_to_v07.remove_attribute_link_metadata:1
msgid "Remove Attribute and Link from metadata.json This is not a database migration, but purely to do with the import/export schema."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v06_to_v07.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v06_to_v07.remove_attribute_link_metadata:4
msgid "The \"entities\" ATTRIBUTE_ENTITY_NAME and LINK_ENTITY_NAME were introduced in v0.3 or v0.4 of the import/export schema. However, they were never used - or the usage has been reverted. They will be removed from metadata.json, slightly simplifying the import functions as well."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v07_to_v08.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v07_to_v08:1
msgid "Migration from v0.7 to v0.8, used by `verdi export migrate` command."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v07_to_v08.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v07_to_v08.migrate_v7_to_v8:1
msgid "Migration of archive files from v0.7 to v0.8."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v07_to_v08.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v07_to_v08.migration_default_link_label:1
msgid "Apply migration 0043 - REV. 1.0.43"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v07_to_v08.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v07_to_v08.migration_default_link_label:3
msgid "Rename all link labels `_return` to `result`."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v08_to_v09.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v08_to_v09:1
msgid "Migration from v0.8 to v0.9, used by `verdi export migrate` command."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v08_to_v09.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v08_to_v09.migrate_v8_to_v9:1
msgid "Migration of archive files from v0.8 to v0.9."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v08_to_v09.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v08_to_v09.migration_dbgroup_type_string:1
msgid "Apply migration 0044 - REV. 1.0.44"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v08_to_v09.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v08_to_v09.migration_dbgroup_type_string:3
msgid "Rename the `type_string` columns of all `Group` instances."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v09_to_v10.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v09_to_v10:1
msgid "Migration from v0.9 to v0.10, used by `verdi export migrate` command."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v09_to_v10.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v09_to_v10.migrate_v9_to_v10:1
msgid "Migration of archive files from v0.9 to v0.10."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v10_to_v11.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v10_to_v11:1
msgid "Migration from v0.10 to v0.11, used by ``verdi archive migrate`` command."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v10_to_v11.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v10_to_v11:3
msgid "This migration applies the name change of the ``Computer`` attribute ``name`` to ``label``."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v10_to_v11.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v10_to_v11.migrate_v10_to_v11:1
msgid "Migration of export files from v0.10 to v0.11."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v11_to_v12.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v11_to_v12:1
msgid "Migration from v0.11 to v0.12, used by ``verdi archive migrate`` command."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v11_to_v12.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v11_to_v12:3
msgid "This migration is necessary after the `core.` prefix was added to entry points shipped with `aiida-core`."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v11_to_v12.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v11_to_v12.migrate_v11_to_v12:1
msgid "Migration of export files from v0.11 to v0.12."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v12_to_v13.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v12_to_v13:1
msgid "Migration from v0.12 to v0.13, used by ``verdi archive migrate`` command."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v12_to_v13.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v12_to_v13:3
msgid "This migration is necessary after the v0.11 to v0.12 migration did not add the core prefix to transport entry points."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/legacy/v12_to_v13.py:docstring of aiida.storage.sqlite_zip.migrations.legacy.v12_to_v13.migrate_v12_to_v13:1
msgid "Migration of export files from v0.12 to v0.13."
msgstr ""

#: ../../source/reference/apidoc/aiida.storage.sqlite_zip.migrations.versions.rst:2
msgid "aiida.storage.sqlite\\_zip.migrations.versions package"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/versions/main_0000_initial.py:docstring of aiida.storage.sqlite_zip.migrations.versions.main_0000_initial:1
msgid "Initial main branch schema"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/versions/main_0000_initial.py:docstring of aiida.storage.sqlite_zip.migrations.versions.main_0000_initial:3
msgid "This schema is mainly equivalent to the `main_0001` schema of the `psql_dos` backend. The difference are:"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/versions/main_0000_initial.py:docstring of aiida.storage.sqlite_zip.migrations.versions.main_0000_initial:6
msgid "Data types: the replacement of ``JSONB`` with ``JSON``, and ``UUID`` with ``CHAR(32)``."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/versions/main_0000_initial.py:docstring of aiida.storage.sqlite_zip.migrations.versions.main_0000_initial:7
msgid "Some more fields are nullable, to allow migrations from legacy to main. The nullable fields are then filled with default values, and set to non-nullable, in subsequent migrations."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/versions/main_0000_initial.py:docstring of aiida.storage.sqlite_zip.migrations.versions.main_0000_initial:10
msgid "Revision ID: main_0000 Revises: Create Date: 2021-02-02"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/versions/main_0000_initial.py:docstring of aiida.storage.sqlite_zip.migrations.versions.main_0000_initial.downgrade:1
#: ../../../src/aiida/storage/sqlite_zip/migrations/versions/main_0001.py:docstring of aiida.storage.sqlite_zip.migrations.versions.main_0001.downgrade:1
msgid "Migrations for the downgrade."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/versions/main_0000a_replace_nulls.py:docstring of aiida.storage.sqlite_zip.migrations.versions.main_0000a_replace_nulls:1
msgid "Replace null values with defaults"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/versions/main_0000a_replace_nulls.py:docstring of aiida.storage.sqlite_zip.migrations.versions.main_0000a_replace_nulls:3
msgid "Revision ID: main_0000a Revises: main_0000 Create Date: 2022-03-04"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/versions/main_0000a_replace_nulls.py:docstring of aiida.storage.sqlite_zip.migrations.versions.main_0000a_replace_nulls.downgrade:1
#: ../../../src/aiida/storage/sqlite_zip/migrations/versions/main_0000b_non_nullable.py:docstring of aiida.storage.sqlite_zip.migrations.versions.main_0000b_non_nullable.downgrade:1
msgid "Downgrade database schema."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/versions/main_0000a_replace_nulls.py:docstring of aiida.storage.sqlite_zip.migrations.versions.main_0000a_replace_nulls.upgrade:1
msgid "Convert null values to default values."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/versions/main_0000a_replace_nulls.py:docstring of aiida.storage.sqlite_zip.migrations.versions.main_0000a_replace_nulls.upgrade:3
msgid "This migration is performed in preparation for the next migration, which will make these fields non-nullable."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/versions/main_0000b_non_nullable.py:docstring of aiida.storage.sqlite_zip.migrations.versions.main_0000b_non_nullable:1
msgid "Alter columns to be non-nullable (to bring inline with psql_dos main_0001)."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/versions/main_0000b_non_nullable.py:docstring of aiida.storage.sqlite_zip.migrations.versions.main_0000b_non_nullable:3
msgid "Revision ID: main_0000b Revises: main_0000a Create Date: 2022-03-04"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/versions/main_0000b_non_nullable.py:docstring of aiida.storage.sqlite_zip.migrations.versions.main_0000b_non_nullable.upgrade:1
msgid "Upgrade database schema."
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/versions/main_0001.py:docstring of aiida.storage.sqlite_zip.migrations.versions.main_0001:1
msgid "Bring schema inline with psql_dos main_0001"
msgstr ""

#: ../../../src/aiida/storage/sqlite_zip/migrations/versions/main_0001.py:docstring of aiida.storage.sqlite_zip.migrations.versions.main_0001:3
msgid "Revision ID: main_0001 Revises: Create Date: 2021-02-02"
msgstr ""

#: ../../source/reference/apidoc/aiida.tools.rst:2
msgid "aiida.tools package"
msgstr ""

#: ../../../src/aiida/tools/__init__.py:docstring of aiida.tools:1
msgid "Tools to operate on AiiDA ORM class instances"
msgstr ""

#: ../../../src/aiida/tools/__init__.py:docstring of aiida.tools:3
msgid "What functionality should go directly in the ORM class in `aiida.orm` and what in `aiida.tools`?"
msgstr ""

#: ../../../src/aiida/tools/__init__.py:docstring of aiida.tools:5
msgid "The ORM class should define basic functions to set and get data from the object"
msgstr ""

#: ../../../src/aiida/tools/__init__.py:docstring of aiida.tools:7
msgid "More advanced functionality to operate on the ORM class instances can be placed in `aiida.tools`"
msgstr ""

#: ../../../src/aiida/tools/__init__.py:docstring of aiida.tools:7
msgid "to prevent the ORM namespace from getting too cluttered."
msgstr ""

#: ../../source/reference/apidoc/aiida.tools.archive.rst:2
msgid "aiida.tools.archive package"
msgstr ""

#: ../../../src/aiida/tools/archive/__init__.py:docstring of aiida.tools.archive:1
msgid "The AiiDA archive allows export/import, of subsets of the provenance graph, to a single file"
msgstr ""

#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract:1
msgid "Abstraction for an archive file format."
msgstr ""

#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveFormatAbstract:1
msgid "Abstract class for an archive format."
msgstr ""

#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveFormatAbstract.key_format:1
#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/main.py:docstring of aiida.tools.archive.implementations.sqlite_zip.main.ArchiveFormatSqlZip.key_format:1
msgid "Return the format of repository keys."
msgstr ""

#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveFormatAbstract.latest_version:1
#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/main.py:docstring of aiida.tools.archive.implementations.sqlite_zip.main.ArchiveFormatSqlZip.latest_version:1
msgid "Return the latest schema version of the archive format."
msgstr ""

#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveFormatAbstract.migrate:1
#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/main.py:docstring of aiida.tools.archive.implementations.sqlite_zip.main.ArchiveFormatSqlZip.migrate:1
msgid "Migrate an archive to a specific version."
msgstr ""

#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveFormatAbstract.migrate:3
msgid "input archive path"
msgstr ""

#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveFormatAbstract.migrate:4
msgid "output archive path"
msgstr ""

#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveFormatAbstract.migrate:6
msgid "allow overwrite of existing output archive path"
msgstr ""

#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveFormatAbstract.migrate:7
#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveFormatAbstract.open:5
#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/main.py:docstring of aiida.tools.archive.implementations.sqlite_zip.main.ArchiveFormatSqlZip.open:5
msgid "default level of compression to use for writing (integer from 0 to 9)"
msgstr ""

#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveFormatAbstract.open:1
#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/main.py:docstring of aiida.tools.archive.implementations.sqlite_zip.main.ArchiveFormatSqlZip.open:1
msgid "Open an archive (latest version only)."
msgstr ""

#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveFormatAbstract.open:3
#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveFormatAbstract.read_version:5
#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveReaderAbstract.__init__:3
#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveWriterAbstract.__init__:3
#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/main.py:docstring of aiida.tools.archive.implementations.sqlite_zip.main.ArchiveFormatSqlZip.migrate:3
#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/main.py:docstring of aiida.tools.archive.implementations.sqlite_zip.main.ArchiveFormatSqlZip.open:3
#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/main.py:docstring of aiida.tools.archive.implementations.sqlite_zip.main.ArchiveFormatSqlZip.read_version:5
#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/reader.py:docstring of aiida.tools.archive.implementations.sqlite_zip.reader.ArchiveReaderSqlZip.__init__:3
#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/writer.py:docstring of aiida.tools.archive.implementations.sqlite_zip.writer.ArchiveWriterSqlZip.__init__:3
msgid "archive path"
msgstr ""

#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveFormatAbstract.open:4
#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/main.py:docstring of aiida.tools.archive.implementations.sqlite_zip.main.ArchiveFormatSqlZip.open:4
msgid "open mode: 'r' (read), 'x' (exclusive write), 'w' (write) or 'a' (append)"
msgstr ""

#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveFormatAbstract.open:7
#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/main.py:docstring of aiida.tools.archive.implementations.sqlite_zip.main.ArchiveFormatSqlZip.open:7
msgid "Note, in write mode, the writer is responsible for writing the format version."
msgstr ""

#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveFormatAbstract.read_version:1
#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/main.py:docstring of aiida.tools.archive.implementations.sqlite_zip.main.ArchiveFormatSqlZip.read_version:1
msgid "Read the version of the archive from a file."
msgstr ""

#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveFormatAbstract.read_version:3
#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/main.py:docstring of aiida.tools.archive.implementations.sqlite_zip.main.ArchiveFormatSqlZip.read_version:3
msgid "This method should account for reading all versions of the archive format."
msgstr ""

#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveFormatAbstract.read_version:7
#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/main.py:docstring of aiida.tools.archive.implementations.sqlite_zip.main.ArchiveFormatSqlZip.read_version:7
msgid "``UnreachableStorage`` if the file does not exist"
msgstr ""

#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveFormatAbstract.read_version:8
#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/main.py:docstring of aiida.tools.archive.implementations.sqlite_zip.main.ArchiveFormatSqlZip.read_version:8
msgid "``CorruptStorage`` if a version cannot be read from the archive"
msgstr ""

#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveReaderAbstract:1
msgid "Reader of an archive, that will be used as a context manager."
msgstr ""

#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveReaderAbstract.__enter__:1
#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/reader.py:docstring of aiida.tools.archive.implementations.sqlite_zip.reader.ArchiveReaderSqlZip.__enter__:1
msgid "Start reading from the archive."
msgstr ""

#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveReaderAbstract.__exit__:1
#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveWriterAbstract.__exit__:1
msgid "Finalise the archive."
msgstr ""

#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveReaderAbstract.__init__:1
#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/reader.py:docstring of aiida.tools.archive.implementations.sqlite_zip.reader.ArchiveReaderSqlZip.__init__:1
msgid "Initialise the reader."
msgstr ""

#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveReaderAbstract.get:1
msgid "Return the entity for the given filters."
msgstr ""

#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveReaderAbstract.get:7
msgid "The type of the front-end entity"
msgstr ""

#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveReaderAbstract.get_backend:1
#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/reader.py:docstring of aiida.tools.archive.implementations.sqlite_zip.reader.ArchiveReaderSqlZip.get_backend:1
msgid "Return a 'read-only' backend for the archive."
msgstr ""

#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveReaderAbstract.get_metadata:1
#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/reader.py:docstring of aiida.tools.archive.implementations.sqlite_zip.reader.ArchiveReaderSqlZip.get_metadata:1
msgid "Return the top-level metadata."
msgstr ""

#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveReaderAbstract.get_metadata:3
#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/reader.py:docstring of aiida.tools.archive.implementations.sqlite_zip.reader.ArchiveReaderSqlZip.get_metadata:3
msgid "``CorruptStorage`` if the top-level metadata cannot be read from the archive"
msgstr ""

#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveReaderAbstract.graph:1
msgid "Return a provenance graph generator for the archive."
msgstr ""

#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveReaderAbstract.path:1
#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveWriterAbstract.path:1
msgid "Return the path to the archive."
msgstr ""

#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveReaderAbstract.querybuilder:1
msgid "Return a ``QueryBuilder`` instance, initialised with the archive backend."
msgstr ""

#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveWriterAbstract:1
msgid "Writer of an archive, that will be used as a context manager."
msgstr ""

#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveWriterAbstract.__enter__:1
msgid "Start writing to the archive."
msgstr ""

#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveWriterAbstract.__init__:1
#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/writer.py:docstring of aiida.tools.archive.implementations.sqlite_zip.writer.ArchiveWriterSqlZip.__init__:1
msgid "Initialise the writer."
msgstr ""

#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveWriterAbstract.__init__:4
#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/writer.py:docstring of aiida.tools.archive.implementations.sqlite_zip.writer.ArchiveWriterSqlZip.__init__:4
msgid "mode to open the archive in: 'x' (exclusive), 'w' (write) or 'a' (append)"
msgstr ""

#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveWriterAbstract.__init__:5
#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/writer.py:docstring of aiida.tools.archive.implementations.sqlite_zip.writer.ArchiveWriterSqlZip.__init__:5
msgid "default level of compression to use (integer from 0 to 9)"
msgstr ""

#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveWriterAbstract.bulk_insert:1
#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/writer.py:docstring of aiida.tools.archive.implementations.sqlite_zip.writer.ArchiveWriterSqlZip.bulk_insert:1
msgid "Add multiple rows of entity data to the archive."
msgstr ""

#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveWriterAbstract.bulk_insert:6
#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/writer.py:docstring of aiida.tools.archive.implementations.sqlite_zip.writer.ArchiveWriterSqlZip.bulk_insert:6
msgid "If ``False``, assert that each row contains all fields, otherwise, allow default values for missing fields."
msgstr ""

#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveWriterAbstract.compression:1
msgid "Return the compression level."
msgstr ""

#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveWriterAbstract.delete_object:1
#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/writer.py:docstring of aiida.tools.archive.implementations.sqlite_zip.writer.ArchiveAppenderSqlZip.delete_object:1
#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/writer.py:docstring of aiida.tools.archive.implementations.sqlite_zip.writer.ArchiveWriterSqlZip.delete_object:1
msgid "Delete the object from the archive."
msgstr ""

#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveWriterAbstract.mode:1
msgid "Return the mode of the archive."
msgstr ""

#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveWriterAbstract.put_object:1
#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/writer.py:docstring of aiida.tools.archive.implementations.sqlite_zip.writer.ArchiveWriterSqlZip.put_object:1
msgid "Add an object to the archive."
msgstr ""

#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveWriterAbstract.put_object:3
#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/writer.py:docstring of aiida.tools.archive.implementations.sqlite_zip.writer.ArchiveWriterSqlZip.put_object:3
msgid "byte stream to read the object from"
msgstr ""

#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveWriterAbstract.put_object:4
#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/writer.py:docstring of aiida.tools.archive.implementations.sqlite_zip.writer.ArchiveWriterSqlZip.put_object:4
msgid "Number of bytes to buffer when read/writing"
msgstr ""

#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveWriterAbstract.put_object:5
#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/writer.py:docstring of aiida.tools.archive.implementations.sqlite_zip.writer.ArchiveWriterSqlZip.put_object:5
msgid "key to use for the object (if None will be auto-generated)"
msgstr ""

#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveWriterAbstract.put_object:6
#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/writer.py:docstring of aiida.tools.archive.implementations.sqlite_zip.writer.ArchiveWriterSqlZip.put_object:6
msgid "the key of the object"
msgstr ""

#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.ArchiveWriterAbstract.update_metadata:1
#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/writer.py:docstring of aiida.tools.archive.implementations.sqlite_zip.writer.ArchiveWriterSqlZip.update_metadata:1
msgid "Add key, values to the top-level metadata."
msgstr ""

#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.get_format:1
msgid "Get the archive format instance."
msgstr ""

#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.get_format:3
msgid "name of the archive format"
msgstr ""

#: ../../../src/aiida/tools/archive/abstract.py:docstring of aiida.tools.archive.abstract.get_format:4
msgid "archive format instance"
msgstr ""

#: ../../../src/aiida/tools/archive/common.py:docstring of aiida.tools.archive.common:1
msgid "Shared resources for the archive."
msgstr ""

#: ../../../src/aiida/tools/archive/common.py:docstring of aiida.tools.archive.common.HTMLGetLinksParser:1
msgid "Bases: :py:class:`~html.parser.HTMLParser`"
msgstr ""

#: ../../../src/aiida/tools/archive/common.py:docstring of aiida.tools.archive.common.HTMLGetLinksParser:1
msgid "If a filter_extension is passed, only links with extension matching the given one will be returned."
msgstr ""

#: ../../../src/aiida/tools/archive/common.py:docstring of aiida.tools.archive.common.HTMLGetLinksParser.__init__:1
msgid "Initialize and reset this instance."
msgstr ""

#: ../../../src/aiida/tools/archive/common.py:docstring of aiida.tools.archive.common.HTMLGetLinksParser.__init__:3
msgid "If convert_charrefs is True (the default), all character references are automatically converted to the corresponding Unicode characters."
msgstr ""

#: ../../../src/aiida/tools/archive/common.py:docstring of aiida.tools.archive.common.HTMLGetLinksParser.get_links:1
msgid "Return the links that were found during the parsing phase."
msgstr ""

#: ../../../src/aiida/tools/archive/common.py:docstring of aiida.tools.archive.common.HTMLGetLinksParser.handle_starttag:1
msgid "Store the urls encountered, if they match the request."
msgstr ""

#: ../../../src/aiida/tools/archive/common.py:docstring of aiida.tools.archive.common.batch_iter:1
msgid "Yield an iterable in batches of a set number of items."
msgstr ""

#: ../../../src/aiida/tools/archive/common.py:docstring of aiida.tools.archive.common.batch_iter:3
msgid "Note, the final yield may be less than this size."
msgstr ""

#: ../../../src/aiida/tools/archive/common.py:docstring of aiida.tools.archive.common.batch_iter:5
msgid "a transform to apply to each item"
msgstr ""

#: ../../../src/aiida/tools/archive/common.py:docstring of aiida.tools.archive.common.batch_iter:6
msgid "(number of items, list of items)"
msgstr ""

#: ../../../src/aiida/tools/archive/common.py:docstring of aiida.tools.archive.common.get_valid_import_links:1
msgid "Open the given URL, parse the HTML and return a list of valid links where the link file has a .aiida extension."
msgstr ""

#: ../../../src/aiida/tools/archive/create.py:docstring of aiida.tools.archive.create:1
msgid "Create an AiiDA archive."
msgstr ""

#: ../../../src/aiida/tools/archive/create.py:docstring of aiida.tools.archive.create:3
msgid "The archive is a subset of the provenance graph, stored in a single file."
msgstr ""

#: ../../../src/aiida/tools/archive/create.py:docstring of aiida.tools.archive.create._check_node_licenses:1
msgid "Check the nodes to be archived for disallowed licences."
msgstr ""

#: ../../../src/aiida/tools/archive/create.py:docstring of aiida.tools.archive.create._check_unsealed_nodes:1
msgid "Check no process nodes are unsealed, i.e. all processes have completed."
msgstr ""

#: ../../../src/aiida/tools/archive/create.py:docstring of aiida.tools.archive.create._collect_all_entities:1
msgid "Collect all entities."
msgstr ""

#: ../../../src/aiida/tools/archive/create.py:docstring of aiida.tools.archive.create._collect_all_entities:3
#: ../../../src/aiida/tools/archive/create.py:docstring of aiida.tools.archive.create._collect_required_entities:3
msgid "(group_id_to_node_id, link_data) and updates entity_ids"
msgstr ""

#: ../../../src/aiida/tools/archive/create.py:docstring of aiida.tools.archive.create._collect_required_entities:1
msgid "Collect required entities, given a set of starting entities and provenance graph traversal rules."
msgstr ""

#: ../../../src/aiida/tools/archive/create.py:docstring of aiida.tools.archive.create._stream_repo_files:1
msgid "Collect all repository object keys from the nodes, then stream the files to the archive."
msgstr ""

#: ../../../src/aiida/tools/archive/create.py:docstring of aiida.tools.archive.create.create_archive:1
msgid "Export AiiDA data to an archive file."
msgstr ""

#: ../../../src/aiida/tools/archive/create.py:docstring of aiida.tools.archive.create.create_archive:3
msgid "The export follows the following logic:"
msgstr ""

#: ../../../src/aiida/tools/archive/create.py:docstring of aiida.tools.archive.create.create_archive:5
msgid "First gather all entity primary keys (per type) that needs to be exported. This need to proceed in the \"reverse\" order of relationships:"
msgstr ""

#: ../../../src/aiida/tools/archive/create.py:docstring of aiida.tools.archive.create.create_archive:8
msgid "groups: input groups"
msgstr ""

#: ../../../src/aiida/tools/archive/create.py:docstring of aiida.tools.archive.create.create_archive:9
msgid "group_to_nodes: from nodes in groups"
msgstr ""

#: ../../../src/aiida/tools/archive/create.py:docstring of aiida.tools.archive.create.create_archive:10
msgid "nodes & links: from graph_traversal(input nodes & group_to_nodes)"
msgstr ""

#: ../../../src/aiida/tools/archive/create.py:docstring of aiida.tools.archive.create.create_archive:11
msgid "computers: from input computers & computers of nodes"
msgstr ""

#: ../../../src/aiida/tools/archive/create.py:docstring of aiida.tools.archive.create.create_archive:12
msgid "authinfos: from authinfos of computers"
msgstr ""

#: ../../../src/aiida/tools/archive/create.py:docstring of aiida.tools.archive.create.create_archive:13
msgid "comments: from comments of nodes"
msgstr ""

#: ../../../src/aiida/tools/archive/create.py:docstring of aiida.tools.archive.create.create_archive:14
msgid "logs: from logs of nodes"
msgstr ""

#: ../../../src/aiida/tools/archive/create.py:docstring of aiida.tools.archive.create.create_archive:15
msgid "users: from users of nodes, groups, comments & authinfos"
msgstr ""

#: ../../../src/aiida/tools/archive/create.py:docstring of aiida.tools.archive.create.create_archive:17
msgid "Now stream the full entities (per type) to the archive writer, in the order of relationships:"
msgstr ""

#: ../../source/reference/rest_api.rst:1259
#: ../../source/reference/rest_api.rst:1262
#: ../../source/reference/rest_api.rst:1274
#: ../../source/reference/rest_api.rst:1280
#: ../../../src/aiida/tools/archive/create.py:docstring of aiida.tools.archive.create.create_archive:20
msgid "users"
msgstr ""

#: ../../source/reference/rest_api.rst:1268
#: ../../source/reference/rest_api.rst:1286
#: ../../source/reference/rest_api.rst:1292
#: ../../source/reference/rest_api.rst:1295
#: ../../../src/aiida/tools/archive/create.py:docstring of aiida.tools.archive.create.create_archive:21
msgid "computers"
msgstr ""

#: ../../../src/aiida/tools/archive/create.py:docstring of aiida.tools.archive.create.create_archive:22
msgid "authinfos"
msgstr ""

#: ../../source/reference/rest_api.rst:1298
#: ../../source/reference/rest_api.rst:1301
#: ../../../src/aiida/tools/archive/create.py:docstring of aiida.tools.archive.create.create_archive:23
msgid "groups"
msgstr ""

#: ../../source/reference/rest_api.rst:1250
#: ../../source/reference/rest_api.rst:1253
#: ../../source/reference/rest_api.rst:1265
#: ../../source/reference/rest_api.rst:1283
#: ../../source/reference/rest_api.rst:1289
#: ../../../src/aiida/tools/archive/create.py:docstring of aiida.tools.archive.create.create_archive:24
msgid "nodes"
msgstr ""

#: ../../../src/aiida/tools/archive/create.py:docstring of aiida.tools.archive.create.create_archive:25
msgid "comments"
msgstr ""

#: ../../../src/aiida/tools/archive/create.py:docstring of aiida.tools.archive.create.create_archive:26
msgid "logs"
msgstr ""

#: ../../../src/aiida/tools/archive/create.py:docstring of aiida.tools.archive.create.create_archive:27
msgid "group_to_nodes"
msgstr ""

#: ../../../src/aiida/tools/archive/create.py:docstring of aiida.tools.archive.create.create_archive:28
msgid "links"
msgstr ""

#: ../../../src/aiida/tools/archive/create.py:docstring of aiida.tools.archive.create.create_archive:30
msgid "Finally stream the repository files, for the exported nodes, to the archive writer."
msgstr ""

#: ../../../src/aiida/tools/archive/create.py:docstring of aiida.tools.archive.create.create_archive:33
msgid "Note, the logging level and progress reporter should be set externally, for example::"
msgstr ""

#: ../../../src/aiida/tools/archive/create.py:docstring of aiida.tools.archive.create.create_archive:41
msgid "If ``None``, import all entities, or a list of entity instances that can include Computers, Groups, and Nodes."
msgstr ""

#: ../../../src/aiida/tools/archive/create.py:docstring of aiida.tools.archive.create.create_archive:44
msgid "the filename (possibly including the absolute path) of the file on which to export."
msgstr ""

#: ../../../src/aiida/tools/archive/create.py:docstring of aiida.tools.archive.create.create_archive:47
msgid "if True, overwrite the output file without asking, if it exists. If False, raise an :py:class:`~aiida.tools.archive.exceptions.ArchiveExportError` if the output file already exists."
msgstr ""

#: ../../../src/aiida/tools/archive/create.py:docstring of aiida.tools.archive.create.create_archive:52
#: ../../../src/aiida/tools/archive/create.py:docstring of aiida.tools.archive.create.create_archive:57
msgid "List or function. If a list, then checks whether all licenses of Data nodes are in the list. If a function, then calls function for licenses of Data nodes expecting True if license is allowed, False otherwise."
msgstr ""

#: ../../../src/aiida/tools/archive/create.py:docstring of aiida.tools.archive.create.create_archive:62
msgid "In-/exclude export of comments for given node(s) in ``entities``. Default: True, *include* comments in export (as well as relevant users)."
msgstr ""

#: ../../../src/aiida/tools/archive/create.py:docstring of aiida.tools.archive.create.create_archive:65
msgid "In-/exclude export of logs for given node(s) in ``entities``. Default: True, *include* logs in export."
msgstr ""

#: ../../../src/aiida/tools/archive/create.py:docstring of aiida.tools.archive.create.create_archive:68
msgid "Remove checkpoint keys from process node attributes. These contain serialized code and can cause security issues."
msgstr ""

#: ../../../src/aiida/tools/archive/create.py:docstring of aiida.tools.archive.create.create_archive:71
msgid "level of compression to use (integer from 0 to 9)"
msgstr ""

#: ../../../src/aiida/tools/archive/create.py:docstring of aiida.tools.archive.create.create_archive:73
msgid "batch database query results in sub-collections to reduce memory usage"
msgstr ""

#: ../../../src/aiida/tools/archive/create.py:docstring of aiida.tools.archive.create.create_archive:75
#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports.import_archive:25
msgid "if True, do not write to file"
msgstr ""

#: ../../../src/aiida/tools/archive/create.py:docstring of aiida.tools.archive.create.create_archive:77
msgid "the backend to export from. If not specified, the default backend is used."
msgstr ""

#: ../../../src/aiida/tools/archive/create.py:docstring of aiida.tools.archive.create.create_archive:79
#: ../../../src/aiida/tools/graph/deletions.py:docstring of aiida.tools.graph.deletions.delete_group_nodes:29
#: ../../../src/aiida/tools/graph/graph_traversers.py:docstring of aiida.tools.graph.graph_traversers.get_nodes_delete:13
msgid "graph traversal rules. See :const:`aiida.common.links.GraphTraversalRules` what rule names are toggleable and what the defaults are."
msgstr ""

#: ../../../src/aiida/tools/archive/create.py:docstring of aiida.tools.archive.create.create_archive:82
msgid "if there are any internal errors when exporting."
msgstr ""

#: ../../../src/aiida/tools/archive/create.py:docstring of aiida.tools.archive.create.create_archive:84
msgid "if any node is licensed under forbidden license."
msgstr ""

#: ../../../src/aiida/tools/archive/create.py:docstring of aiida.tools.archive.create.get_init_summary:1
msgid "Get summary for archive initialisation"
msgstr ""

#: ../../../src/aiida/tools/archive/exceptions.py:docstring of aiida.tools.archive.exceptions:1
msgid "Module that defines the exceptions thrown by AiiDA's archive module."
msgstr ""

#: ../../../src/aiida/tools/archive/exceptions.py:docstring of aiida.tools.archive.exceptions:3
msgid "Note: In order to not override the built-in `ImportError`,"
msgstr ""

#: ../../../src/aiida/tools/archive/exceptions.py:docstring of aiida.tools.archive.exceptions:4
msgid "both `ImportError` and `ExportError` are prefixed with `Archive`."
msgstr ""

#: ../../../src/aiida/tools/archive/exceptions.py:docstring of aiida.tools.archive.exceptions.ArchiveExportError:1
#: ../../../src/aiida/tools/archive/exceptions.py:docstring of aiida.tools.archive.exceptions.ArchiveImportError:1
msgid "Bases: :py:class:`~aiida.tools.archive.exceptions.ExportImportException`"
msgstr ""

#: ../../../src/aiida/tools/archive/exceptions.py:docstring of aiida.tools.archive.exceptions.ArchiveExportError:1
msgid "Base class for all AiiDA export exceptions."
msgstr ""

#: ../../../src/aiida/tools/archive/exceptions.py:docstring of aiida.tools.archive.exceptions.ArchiveImportError:1
msgid "Base class for all AiiDA import exceptions."
msgstr ""

#: ../../../src/aiida/tools/archive/exceptions.py:docstring of aiida.tools.archive.exceptions.ExportImportException:1
msgid "Base class for all AiiDA export/import module exceptions."
msgstr ""

#: ../../../src/aiida/tools/archive/exceptions.py:docstring of aiida.tools.archive.exceptions.ExportValidationError:1
msgid "Bases: :py:class:`~aiida.tools.archive.exceptions.ArchiveExportError`"
msgstr ""

#: ../../../src/aiida/tools/archive/exceptions.py:docstring of aiida.tools.archive.exceptions.ExportValidationError:1
msgid "Raised when validation fails during export, e.g. for non-sealed ``ProcessNode`` s."
msgstr ""

#: ../../../src/aiida/tools/archive/exceptions.py:docstring of aiida.tools.archive.exceptions.ImportTestRun:1
#: ../../../src/aiida/tools/archive/exceptions.py:docstring of aiida.tools.archive.exceptions.ImportUniquenessError:1
#: ../../../src/aiida/tools/archive/exceptions.py:docstring of aiida.tools.archive.exceptions.ImportValidationError:1
msgid "Bases: :py:class:`~aiida.tools.archive.exceptions.ArchiveImportError`"
msgstr ""

#: ../../../src/aiida/tools/archive/exceptions.py:docstring of aiida.tools.archive.exceptions.ImportTestRun:1
msgid "Raised during an import, before the transaction is commited."
msgstr ""

#: ../../../src/aiida/tools/archive/exceptions.py:docstring of aiida.tools.archive.exceptions.ImportUniquenessError:1
msgid "Raised when the user tries to violate a uniqueness constraint."
msgstr ""

#: ../../../src/aiida/tools/archive/exceptions.py:docstring of aiida.tools.archive.exceptions.ImportUniquenessError:3
msgid "Similar to :py:class:`~aiida.common.exceptions.UniquenessError`."
msgstr ""

#: ../../../src/aiida/tools/archive/exceptions.py:docstring of aiida.tools.archive.exceptions.ImportValidationError:1
msgid "Raised when validation fails during import, e.g. for parameter types and values."
msgstr ""

#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports:1
msgid "Import an archive."
msgstr ""

#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports.CommentTransform:1
msgid "Callable to transform a Comment DB row, between the source archive and target backend."
msgstr ""

#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports.CommentTransform.__call__:1
#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports.GroupTransform.__call__:1
#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports.NodeTransform.__call__:1
msgid "Perform the transform."
msgstr ""

#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports.GroupTransform:1
msgid "Callable to transform a Group DB row, between the source archive and target backend."
msgstr ""

#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports.NodeTransform:1
msgid "Callable to transform a Node DB row, between the source archive and target backend."
msgstr ""

#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports.QueryParams:1
msgid "Parameters for executing backend queries."
msgstr ""

#: ../../docstring of aiida.tools.archive.imports.QueryParams.batch_size:1
msgid "Batch size for streaming database rows."
msgstr ""

#: ../../docstring of aiida.tools.archive.imports.QueryParams.filter_size:1
msgid "Maximum number of parameters allowed in a single query filter."
msgstr ""

#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports._add_files_to_repo:1
msgid "Add the new files to the repository."
msgstr ""

#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports._add_new_entities:1
msgid "Add new entities to the output backend and update the mapping of unique field -> id."
msgstr ""

#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports._get_new_object_keys:1
msgid "Return the object keys that need to be added to the backend."
msgstr ""

#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports._import_authinfos:1
#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports._import_logs:1
msgid "Import logs from one backend to another."
msgstr ""

#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports._import_authinfos:3
#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports._import_computers:3
#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports._import_logs:3
#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports._import_nodes:3
#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports._import_users:3
msgid "mapping of input backend id to output backend id"
msgstr ""

#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports._import_comments:1
msgid "Import comments from one backend to another."
msgstr ""

#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports._import_comments:3
msgid "mapping of archive id to backend id"
msgstr ""

#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports._import_computers:1
msgid "Import computers from one backend to another."
msgstr ""

#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports._import_groups:1
msgid "Import groups from the input backend, and add group -> node records."
msgstr ""

#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports._import_groups:3
msgid "Set of labels"
msgstr ""

#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports._import_links:1
msgid "Import links from one backend to another."
msgstr ""

#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports._import_nodes:1
msgid "Import nodes from one backend to another."
msgstr ""

#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports._import_users:1
msgid "Import users from one backend to another."
msgstr ""

#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports._make_import_group:1
msgid "Make an import group containing all imported nodes."
msgstr ""

#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports._make_import_group:3
msgid "Use an existing group"
msgstr ""

#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports._make_import_group:4
msgid "All existing group labels on the backend"
msgstr ""

#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports._make_import_group:5
msgid "node pks to add to the group"
msgstr ""

#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports._make_import_group:7
msgid "The id of the group"
msgstr ""

#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports._merge_node_extras:1
msgid "Merge extras from the input backend with the ones in the output backend."
msgstr ""

#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports._merge_node_extras:3
msgid "mapping of uuid to output backend id"
msgstr ""

#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports._merge_node_extras:4
msgid "tuple of merge modes for extras"
msgstr ""

#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports.import_archive:1
msgid "Import an archive into the AiiDA backend."
msgstr ""

#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports.import_archive:3
msgid "the path to the archive"
msgstr ""

#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports.import_archive:4
msgid "The class for interacting with the archive"
msgstr ""

#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports.import_archive:5
msgid "Maximum size of parameters allowed in a single query filter"
msgstr ""

#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports.import_archive:6
msgid "Batch size for streaming database rows"
msgstr ""

#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports.import_archive:7
msgid "Keep extras on new nodes (except private aiida keys), else strip"
msgstr ""

#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports.import_archive:8
msgid "Rules for merging extras into existing nodes. The first letter acts on extras that are present in the original node and not present in the imported node. Can be either: 'k' (keep it) or 'n' (do not keep it). The second letter acts on the imported extras that are not present in the original node. Can be either: 'c' (create it) or 'n' (do not create it). The third letter defines what to do in case of a name collision. Can be either: 'l' (leave the old value), 'u' (update with a new value), 'd' (delete the extra)"
msgstr ""

#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports.import_archive:22
msgid "Add all imported nodes to the specified group, or an automatically created one"
msgstr ""

#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports.import_archive:23
msgid "Group wherein all imported Nodes will be placed. If None, one will be auto-generated."
msgstr ""

#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports.import_archive:26
msgid "the backend to import to. If not specified, the default backend is used."
msgstr ""

#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports.import_archive:28
msgid "Primary Key of the import Group"
msgstr ""

#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports.import_archive:30
msgid "if the provided archive cannot be read."
msgstr ""

#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports.import_archive:31
msgid "if the archive version is not at head."
msgstr ""

#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports.import_archive:32
msgid "if invalid entities are found in the archive."
msgstr ""

#: ../../../src/aiida/tools/archive/imports.py:docstring of aiida.tools.archive.imports.import_archive:33
msgid "if a new unique entity can not be created."
msgstr ""

#: ../../source/reference/apidoc/aiida.tools.archive.implementations.rst:2
msgid "aiida.tools.archive.implementations package"
msgstr ""

#: ../../../src/aiida/tools/archive/implementations/__init__.py:docstring of aiida.tools.archive.implementations:1
msgid "Concrete implementations of an archive file format."
msgstr ""

#: ../../source/reference/apidoc/aiida.tools.archive.implementations.sqlite_zip.rst:2
msgid "aiida.tools.archive.implementations.sqlite\\_zip package"
msgstr ""

#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/__init__.py:docstring of aiida.tools.archive.implementations.sqlite_zip:1
msgid "SQLite implementations of an archive file format."
msgstr ""

#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/main.py:docstring of aiida.tools.archive.implementations.sqlite_zip.main:1
msgid "The file format implementation"
msgstr ""

#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/main.py:docstring of aiida.tools.archive.implementations.sqlite_zip.main.ArchiveFormatSqlZip:1
msgid "Bases: :py:class:`~aiida.tools.archive.abstract.ArchiveFormatAbstract`"
msgstr ""

#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/main.py:docstring of aiida.tools.archive.implementations.sqlite_zip.main.ArchiveFormatSqlZip:1
msgid "Archive format, which uses a zip file, containing an SQLite database."
msgstr ""

#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/main.py:docstring of aiida.tools.archive.implementations.sqlite_zip.main.ArchiveFormatSqlZip:11
msgid "Repository files are named by their SHA256 content hash."
msgstr ""

#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/reader.py:docstring of aiida.tools.archive.implementations.sqlite_zip.reader:1
msgid "AiiDA archive reader implementation."
msgstr ""

#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/reader.py:docstring of aiida.tools.archive.implementations.sqlite_zip.reader.ArchiveReaderSqlZip:1
msgid "Bases: :py:class:`~aiida.tools.archive.abstract.ArchiveReaderAbstract`"
msgstr ""

#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/reader.py:docstring of aiida.tools.archive.implementations.sqlite_zip.reader.ArchiveReaderSqlZip:1
msgid "An archive reader for the SQLite format."
msgstr ""

#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/reader.py:docstring of aiida.tools.archive.implementations.sqlite_zip.reader.ArchiveReaderSqlZip.__exit__:1
msgid "Close the archive backend."
msgstr ""

#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/writer.py:docstring of aiida.tools.archive.implementations.sqlite_zip.writer:1
#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/writer.py:docstring of aiida.tools.archive.implementations.sqlite_zip.writer.ArchiveWriterSqlZip:1
msgid "AiiDA archive writer implementation."
msgstr ""

#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/writer.py:docstring of aiida.tools.archive.implementations.sqlite_zip.writer.ArchiveAppenderSqlZip:1
msgid "Bases: :py:class:`~aiida.tools.archive.implementations.sqlite_zip.writer.ArchiveWriterSqlZip`"
msgstr ""

#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/writer.py:docstring of aiida.tools.archive.implementations.sqlite_zip.writer.ArchiveAppenderSqlZip:1
msgid "AiiDA archive appender implementation."
msgstr ""

#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/writer.py:docstring of aiida.tools.archive.implementations.sqlite_zip.writer.ArchiveAppenderSqlZip.__enter__:1
msgid "Start appending to the archive"
msgstr ""

#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/writer.py:docstring of aiida.tools.archive.implementations.sqlite_zip.writer.ArchiveAppenderSqlZip.__exit__:1
#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/writer.py:docstring of aiida.tools.archive.implementations.sqlite_zip.writer.ArchiveWriterSqlZip.__exit__:1
msgid "Finalise the archive"
msgstr ""

#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/writer.py:docstring of aiida.tools.archive.implementations.sqlite_zip.writer.ArchiveAppenderSqlZip._copy_old_zip_files:1
msgid "Copy the old archive content to the new one (omitting any amended or deleted files)"
msgstr ""

#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/writer.py:docstring of aiida.tools.archive.implementations.sqlite_zip.writer.ArchiveWriterSqlZip:1
msgid "Bases: :py:class:`~aiida.tools.archive.abstract.ArchiveWriterAbstract`"
msgstr ""

#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/writer.py:docstring of aiida.tools.archive.implementations.sqlite_zip.writer.ArchiveWriterSqlZip.__enter__:1
msgid "Start writing to the archive"
msgstr ""

#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/writer.py:docstring of aiida.tools.archive.implementations.sqlite_zip.writer.ArchiveWriterSqlZip._stream_binary:1
msgid "Add a binary stream to the archive."
msgstr ""

#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/writer.py:docstring of aiida.tools.archive.implementations.sqlite_zip.writer.ArchiveWriterSqlZip._stream_binary:3
msgid "Number of bytes to buffer"
msgstr ""

#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/writer.py:docstring of aiida.tools.archive.implementations.sqlite_zip.writer.ArchiveWriterSqlZip._stream_binary:4
msgid "Override global compression level"
msgstr ""

#: ../../../src/aiida/tools/archive/implementations/sqlite_zip/writer.py:docstring of aiida.tools.archive.implementations.sqlite_zip.writer.ArchiveWriterSqlZip._stream_binary:5
msgid "A binary meta comment about the object"
msgstr ""

#: ../../source/reference/apidoc/aiida.tools.calculations.rst:2
msgid "aiida.tools.calculations package"
msgstr ""

#: ../../../src/aiida/tools/calculations/__init__.py:docstring of aiida.tools.calculations:1
msgid "Calculation tool plugins for Calculation classes."
msgstr ""

#: ../../../src/aiida/tools/calculations/base.py:docstring of aiida.tools.calculations.base:1
msgid "Base class for CalculationTools"
msgstr ""

#: ../../../src/aiida/tools/calculations/base.py:docstring of aiida.tools.calculations.base:3
msgid "Sub-classes can be registered in the `aiida.tools.calculations` category to enable the `CalcJobNode` class from being able to find the tools plugin, load it and expose it through the `tools` property of the `CalcJobNode`."
msgstr ""

#: ../../../src/aiida/tools/calculations/base.py:docstring of aiida.tools.calculations.base.CalculationTools:1
msgid "Base class for CalculationTools."
msgstr ""

#: ../../source/reference/apidoc/aiida.tools.data.rst:2
msgid "aiida.tools.data package"
msgstr ""

#: ../../../src/aiida/tools/data/__init__.py:docstring of aiida.tools.data:1
msgid "Tool for handling data."
msgstr ""

#: ../../../src/aiida/tools/data/cif.py:docstring of aiida.tools.data.cif:1
msgid "Tools to operate on `CifData` nodes."
msgstr ""

#: ../../../src/aiida/tools/data/cif.py:docstring of aiida.tools.data.cif.InvalidOccupationsError:1
msgid "An exception that will be raised if pymatgen fails to parse the structure from a cif because some site occupancies exceed the occupancy tolerance. This often happens for structures that have attached species, such as hydrogen, and specify a placeholder position for it, leading to occupancies greater than one. Pymatgen only issues a warning in this case and simply does not return a structure"
msgstr ""

#: ../../../src/aiida/tools/data/cif.py:docstring of aiida.tools.data.cif._get_aiida_structure_ase_inline:1
msgid "Creates :py:class:`aiida.orm.nodes.data.structure.StructureData` using ASE."
msgstr ""

#: ../../../src/aiida/tools/data/cif.py:docstring of aiida.tools.data.cif._get_aiida_structure_ase_inline:3
msgid "unable to correctly import structures of alloys."
msgstr ""

#: ../../../src/aiida/tools/data/cif.py:docstring of aiida.tools.data.cif._get_aiida_structure_pymatgen_inline:1
msgid "Creates :py:class:`aiida.orm.nodes.data.structure.StructureData` using pymatgen."
msgstr ""

#: ../../../src/aiida/tools/data/cif.py:docstring of aiida.tools.data.cif._get_aiida_structure_pymatgen_inline:3
msgid "If total occupancy of a site is between 1 and occupancy_tolerance, the occupancies will be scaled down to 1."
msgstr ""

#: ../../../src/aiida/tools/data/cif.py:docstring of aiida.tools.data.cif._get_aiida_structure_pymatgen_inline:5
msgid "This tolerance is used to determine if two sites are sitting in the same position, in which case they will be combined to a single disordered site. Defaults to 1e-4."
msgstr ""

#: ../../../src/aiida/tools/data/cif.py:docstring of aiida.tools.data.cif._get_aiida_structure_pymatgen_inline:8
msgid "requires pymatgen module."
msgstr ""

#: ../../../src/aiida/tools/data/cif.py:docstring of aiida.tools.data.cif.refine_inline:1
msgid "Refine (reduce) the cell of :py:class:`aiida.orm.nodes.data.cif.CifData`, find and remove symmetrically equivalent atoms."
msgstr ""

#: ../../../src/aiida/tools/data/cif.py:docstring of aiida.tools.data.cif.refine_inline:4
msgid "a :py:class:`aiida.orm.nodes.data.cif.CifData` instance."
msgstr ""

#: ../../../src/aiida/tools/data/cif.py:docstring of aiida.tools.data.cif.refine_inline:5
msgid "dict with :py:class:`aiida.orm.nodes.data.cif.CifData`"
msgstr ""

#: ../../../src/aiida/tools/data/cif.py:docstring of aiida.tools.data.cif.refine_inline:7
msgid "can be used as inline calculation."
msgstr ""

#: ../../../src/aiida/tools/data/cif.py:docstring of aiida.tools.data.cif.symop_string_from_symop_matrix_tr:1
msgid "Construct a CIF representation of symmetry operator plus translation. See International Tables for Crystallography Vol. A. (2002) for definition."
msgstr ""

#: ../../../src/aiida/tools/data/cif.py:docstring of aiida.tools.data.cif.symop_string_from_symop_matrix_tr:5
msgid "3x3 matrix, representing the symmetry operator"
msgstr ""

#: ../../../src/aiida/tools/data/cif.py:docstring of aiida.tools.data.cif.symop_string_from_symop_matrix_tr:6
msgid "translation vector of length 3 (default 0)"
msgstr ""

#: ../../../src/aiida/tools/data/cif.py:docstring of aiida.tools.data.cif.symop_string_from_symop_matrix_tr:7
msgid "epsilon parameter for fuzzy comparison x == 0"
msgstr ""

#: ../../../src/aiida/tools/data/cif.py:docstring of aiida.tools.data.cif.symop_string_from_symop_matrix_tr:8
msgid "CIF representation of symmetry operator"
msgstr ""

#: ../../../src/aiida/tools/data/structure.py:docstring of aiida.tools.data.structure:1
msgid "Various utilities to deal with StructureData instances or create new ones (e.g. convert format to/from SPGLIB, create a StructureData from a different format, ...)"
msgstr ""

#: ../../../src/aiida/tools/data/structure.py:docstring of aiida.tools.data.structure._get_cif_ase_inline:1
msgid "Creates :py:class:`aiida.orm.nodes.data.cif.CifData` using ASE."
msgstr ""

#: ../../../src/aiida/tools/data/structure.py:docstring of aiida.tools.data.structure.spglib_tuple_to_structure:1
msgid "Convert a tuple of the format (cell, scaled_positions, element_numbers) to an AiiDA structure."
msgstr ""

#: ../../../src/aiida/tools/data/structure.py:docstring of aiida.tools.data.structure.spglib_tuple_to_structure:3
msgid "Unless the element_numbers are identical to the Z number of the atoms, you should pass both kind_info and kinds, with the same format as returned by get_tuple_from_aiida_structure."
msgstr ""

#: ../../../src/aiida/tools/data/structure.py:docstring of aiida.tools.data.structure.spglib_tuple_to_structure:7
msgid "the structure in format (structure_tuple, kind_info)"
msgstr ""

#: ../../../src/aiida/tools/data/structure.py:docstring of aiida.tools.data.structure.spglib_tuple_to_structure:8
msgid "a dictionary mapping the kind_names to the numbers used in element_numbers. If not provided, assumes {element_name: element_Z}"
msgstr ""

#: ../../../src/aiida/tools/data/structure.py:docstring of aiida.tools.data.structure.spglib_tuple_to_structure:10
msgid "a list of the kinds of the structure."
msgstr ""

#: ../../../src/aiida/tools/data/structure.py:docstring of aiida.tools.data.structure.structure_to_spglib_tuple:1
msgid "Convert an AiiDA structure to a tuple of the format (cell, scaled_positions, element_numbers)."
msgstr ""

#: ../../../src/aiida/tools/data/structure.py:docstring of aiida.tools.data.structure.structure_to_spglib_tuple:3
msgid "the AiiDA structure"
msgstr ""

#: ../../../src/aiida/tools/data/structure.py:docstring of aiida.tools.data.structure.structure_to_spglib_tuple:4
msgid "(structure_tuple, kind_info, kinds) where structure_tuple is a tuple of format (cell, scaled_positions, element_numbers); kind_info is a dictionary mapping the kind_names to the numbers used in element_numbers. When possible, it uses the Z number of the element, otherwise it uses numbers > 1000; kinds is a list of the kinds of the structure."
msgstr ""

#: ../../../src/aiida/tools/data/structure.py:docstring of aiida.tools.data.structure.xyz_parser_iterator:1
msgid "Yields a tuple `(natoms, comment, atomiter)`for each frame in a XYZ file where `atomiter` is an iterator yielding a nested tuple `(symbol, (x, y, z))` for each entry."
msgstr ""

#: ../../../src/aiida/tools/data/structure.py:docstring of aiida.tools.data.structure.xyz_parser_iterator:5
msgid "a string containing XYZ-structured text"
msgstr ""

#: ../../source/reference/apidoc/aiida.tools.data.array.rst:2
msgid "aiida.tools.data.array package"
msgstr ""

#: ../../../src/aiida/tools/data/array/__init__.py:docstring of aiida.tools.data.array:1
msgid "Tools for manipulating array data classes."
msgstr ""

#: ../../../src/aiida/tools/data/array/trajectory.py:docstring of aiida.tools.data.array.trajectory:1
msgid "Tools to operate on `TrajectoryData` nodes."
msgstr ""

#: ../../../src/aiida/tools/data/array/trajectory.py:docstring of aiida.tools.data.array.trajectory._get_aiida_structure_inline:1
msgid "CalcFunction to extract a :py:class:`aiida.orm.nodes.data.structure.StructureData` from a `TrajectoryData`."
msgstr ""

#: ../../../src/aiida/tools/data/array/trajectory.py:docstring of aiida.tools.data.array.trajectory._get_aiida_structure_inline:4
msgid "A dictionary whose key-value pairs are passed as additional kwargs to the :py:meth:``TrajectoryData.get_step_structure`` method."
msgstr ""

#: ../../source/reference/apidoc/aiida.tools.data.array.kpoints.rst:2
msgid "aiida.tools.data.array.kpoints package"
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/__init__.py:docstring of aiida.tools.data.array.kpoints:1
#: ../../../src/aiida/tools/data/array/kpoints/main.py:docstring of aiida.tools.data.array.kpoints.main:1
msgid "Various utilities to deal with KpointsData instances or create new ones (e.g. band paths, kpoints from a parsed input text file, ...)"
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/legacy.py:docstring of aiida.tools.data.array.kpoints.legacy:1
msgid "Tool to automatically determine k-points for a given structure using legacy custom implementation."
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/legacy.py:docstring of aiida.tools.data.array.kpoints.legacy.analyze_cell:1
msgid "A function executed by the __init__ or by set_cell. If a cell is set, properties like a1, a2, a3, cosalpha, reciprocal_cell are set as well, although they are not stored in the DB. :note: units are Angstrom for the cell parameters, 1/Angstrom for the reciprocal cell parameters."
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/legacy.py:docstring of aiida.tools.data.array.kpoints.legacy.change_reference:1
msgid "Change reference system, from cartesian to crystal coordinates (units of b1,b2,b3) or viceversa."
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/legacy.py:docstring of aiida.tools.data.array.kpoints.legacy.change_reference:3
msgid "a 3x3 array representing the cell lattice vectors in reciprocal space"
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/legacy.py:docstring of aiida.tools.data.array.kpoints.legacy.change_reference:4
msgid "a list of (3) point coordinates"
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/legacy.py:docstring of aiida.tools.data.array.kpoints.legacy.change_reference:5
msgid "a list of (3) point coordinates in the new reference"
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/legacy.py:docstring of aiida.tools.data.array.kpoints.legacy.find_bravais_info:1
msgid "Finds the Bravais lattice of the cell passed in input to the Kpoint class :note: We assume that the cell given by the cell property is the primitive unit cell."
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/legacy.py:docstring of aiida.tools.data.array.kpoints.legacy.find_bravais_info:5
#: ../../../src/aiida/tools/data/array/kpoints/legacy.py:docstring of aiida.tools.data.array.kpoints.legacy.get_kpoints_path:3
msgid "in 3D, this implementation expects that the structure is already standardized according to the Setyawan paper. If this is not the case, the kpoints and band structure returned will be incorrect. The only case that is dealt correctly by the library is the case when axes are swapped, where the library correctly takes this swapping/rotation into account to assign kpoint labels and coordinates."
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/legacy.py:docstring of aiida.tools.data.array.kpoints.legacy.find_bravais_info:12
#: ../../../src/aiida/tools/data/array/kpoints/legacy.py:docstring of aiida.tools.data.array.kpoints.legacy.get_explicit_kpoints_path:15
#: ../../../src/aiida/tools/data/array/kpoints/legacy.py:docstring of aiida.tools.data.array.kpoints.legacy.get_kpoints_path:15
msgid "3x3 array representing the structure cell lattice vectors"
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/legacy.py:docstring of aiida.tools.data.array.kpoints.legacy.find_bravais_info:13
msgid "3-dimensional array of booleans signifying the periodic boundary conditions along each lattice vector passed in value as cartesian coordinates. Default: False."
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/legacy.py:docstring of aiida.tools.data.array.kpoints.legacy.find_bravais_info:16
#: ../../../src/aiida/tools/data/array/kpoints/legacy.py:docstring of aiida.tools.data.array.kpoints.legacy.get_explicit_kpoints_path:26
msgid "threshold on lengths comparison, used to get the bravais lattice info. It has to be used if the user wants to be sure the right symmetries are recognized."
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/legacy.py:docstring of aiida.tools.data.array.kpoints.legacy.find_bravais_info:19
#: ../../../src/aiida/tools/data/array/kpoints/legacy.py:docstring of aiida.tools.data.array.kpoints.legacy.get_explicit_kpoints_path:29
msgid "threshold on angles comparison, used to get the bravais lattice info. It has to be used if the user wants to be sure the right symmetries are recognized."
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/legacy.py:docstring of aiida.tools.data.array.kpoints.legacy.find_bravais_info:22
msgid "a dictionary, with keys short_name, extended_name, index (index of the Bravais lattice), and sometimes variation (name of the variation of the Bravais lattice) and extra (a dictionary with extra parameters used by the get_kpoints_path method)"
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/legacy.py:docstring of aiida.tools.data.array.kpoints.legacy.get_explicit_kpoints_path:1
msgid "Set a path of kpoints in the Brillouin zone."
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/legacy.py:docstring of aiida.tools.data.array.kpoints.legacy.get_explicit_kpoints_path:3
msgid "description of the path, in various possible formats.  None: automatically sets all irreducible high symmetry paths. Requires that a cell was set  or::    [('G','M'), (...), ...]   [('G','M',30), (...), ...]   [('G',(0,0,0),'M',(1,1,1)), (...), ...]   [('G',(0,0,0),'M',(1,1,1),30), (...), ...]"
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/legacy.py:docstring of aiida.tools.data.array.kpoints.legacy.get_explicit_kpoints_path:3
msgid "description of the path, in various possible formats."
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/legacy.py:docstring of aiida.tools.data.array.kpoints.legacy.get_explicit_kpoints_path:5
msgid "None: automatically sets all irreducible high symmetry paths. Requires that a cell was set"
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/legacy.py:docstring of aiida.tools.data.array.kpoints.legacy.get_explicit_kpoints_path:16
#: ../../../src/aiida/tools/data/array/kpoints/legacy.py:docstring of aiida.tools.data.array.kpoints.legacy.get_kpoints_path:16
msgid "3-dimensional array of booleans signifying the periodic boundary conditions along each lattice vector"
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/legacy.py:docstring of aiida.tools.data.array.kpoints.legacy.get_explicit_kpoints_path:18
msgid "parameter controlling the distance between kpoints. Distance is given in crystal coordinates, i.e. the distance is computed in the space of b1,b2,b3. The distance set will be the closest possible to this value, compatible with the requirement of putting equispaced points between two special points (since extrema are included)."
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/legacy.py:docstring of aiida.tools.data.array.kpoints.legacy.get_explicit_kpoints_path:24
msgid "if set to true, reads the coordinates eventually passed in value as cartesian coordinates. Default: False."
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/legacy.py:docstring of aiida.tools.data.array.kpoints.legacy.get_explicit_kpoints_path:33
msgid "point_coordinates, path, bravais_info, explicit_kpoints, labels"
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/legacy.py:docstring of aiida.tools.data.array.kpoints.legacy.get_kpoints_path:1
msgid "Get the special point and path of a given structure."
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/legacy.py:docstring of aiida.tools.data.array.kpoints.legacy.get_kpoints_path:9
msgid "In 2D, coordinates are based on the paper: R. Ramirez and M. C. Bohm,  Int. J. Quant. Chem., XXX, pp. 391-411 (1986)"
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/legacy.py:docstring of aiida.tools.data.array.kpoints.legacy.get_kpoints_path:12
msgid "In 3D, coordinates are based on the paper: W. Setyawan, S. Curtarolo, Comp. Mat. Sci. 49, 299 (2010)"
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/legacy.py:docstring of aiida.tools.data.array.kpoints.legacy.get_kpoints_path:18
msgid "If true, returns points in cartesian coordinates. Crystal coordinates otherwise. Default=False"
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/legacy.py:docstring of aiida.tools.data.array.kpoints.legacy.get_kpoints_path:20
#: ../../../src/aiida/tools/data/array/kpoints/main.py:docstring of aiida.tools.data.array.kpoints.main._legacy_get_explicit_kpoints_path:9
#: ../../../src/aiida/tools/data/array/kpoints/main.py:docstring of aiida.tools.data.array.kpoints.main._legacy_get_kpoints_path:5
msgid "threshold on lengths comparison, used to get the bravais lattice info"
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/legacy.py:docstring of aiida.tools.data.array.kpoints.legacy.get_kpoints_path:22
#: ../../../src/aiida/tools/data/array/kpoints/main.py:docstring of aiida.tools.data.array.kpoints.main._legacy_get_explicit_kpoints_path:10
#: ../../../src/aiida/tools/data/array/kpoints/main.py:docstring of aiida.tools.data.array.kpoints.main._legacy_get_kpoints_path:6
msgid "threshold on angles comparison, used to get the bravais lattice info"
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/legacy.py:docstring of aiida.tools.data.array.kpoints.legacy.get_kpoints_path:0
msgid "return special_points,path"
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/legacy.py:docstring of aiida.tools.data.array.kpoints.legacy.get_kpoints_path:24
msgid "special_points: a dictionary of point_name:point_coords key,values."
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/legacy.py:docstring of aiida.tools.data.array.kpoints.legacy.get_kpoints_path:27
msgid "path: the suggested path which goes through all high symmetry lines. A list of lists for all path segments. e.g. ``[('G','X'),('X','M'),...]`` It's not necessarily a continuous line."
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/legacy.py:docstring of aiida.tools.data.array.kpoints.legacy.get_kpoints_path:31
msgid "We assume that the cell given by the cell property is the primitive unit cell"
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/main.py:docstring of aiida.tools.data.array.kpoints.main._legacy_get_explicit_kpoints_path:1
msgid "Call the get_explicit_kpoints_path of the legacy implementation"
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/main.py:docstring of aiida.tools.data.array.kpoints.main._legacy_get_explicit_kpoints_path:3
#: ../../../src/aiida/tools/data/array/kpoints/main.py:docstring of aiida.tools.data.array.kpoints.main._legacy_get_kpoints_path:3
#: ../../../src/aiida/tools/data/array/kpoints/main.py:docstring of aiida.tools.data.array.kpoints.main._seekpath_get_explicit_kpoints_path:3
#: ../../../src/aiida/tools/data/array/kpoints/main.py:docstring of aiida.tools.data.array.kpoints.main._seekpath_get_kpoints_path:3
#: ../../../src/aiida/tools/data/array/kpoints/main.py:docstring of aiida.tools.data.array.kpoints.main.get_explicit_kpoints_path:20
#: ../../../src/aiida/tools/data/array/kpoints/main.py:docstring of aiida.tools.data.array.kpoints.main.get_kpoints_path:19
msgid "a StructureData node"
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/main.py:docstring of aiida.tools.data.array.kpoints.main._legacy_get_explicit_kpoints_path:4
msgid "parameter controlling the distance between kpoints. Distance is given in crystal coordinates, i.e. the distance is computed in the space of b1, b2, b3. The distance set will be the closest possible to this value, compatible with the requirement of putting equispaced points between two special points (since extrema are included)."
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/main.py:docstring of aiida.tools.data.array.kpoints.main._legacy_get_explicit_kpoints_path:8
#: ../../../src/aiida/tools/data/array/kpoints/main.py:docstring of aiida.tools.data.array.kpoints.main._legacy_get_kpoints_path:4
msgid "if set to true, reads the coordinates eventually passed in value as cartesian coordinates"
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/main.py:docstring of aiida.tools.data.array.kpoints.main._legacy_get_kpoints_path:1
msgid "Call the get_kpoints_path of the legacy implementation"
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/main.py:docstring of aiida.tools.data.array.kpoints.main._seekpath_get_explicit_kpoints_path:1
msgid "Call the get_explicit_kpoints_path wrapper function for Seekpath"
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/main.py:docstring of aiida.tools.data.array.kpoints.main._seekpath_get_explicit_kpoints_path:4
#: ../../../src/aiida/tools/data/array/kpoints/main.py:docstring of aiida.tools.data.array.kpoints.main._seekpath_get_kpoints_path:4
msgid "if False, and the group has no inversion symmetry, additional lines are returned"
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/main.py:docstring of aiida.tools.data.array.kpoints.main._seekpath_get_explicit_kpoints_path:6
msgid "a reference target distance between neighboring k-points in the path, in units of 1/ang. The actual value will be as close as possible to this value, to have an integer number of points in each path"
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/main.py:docstring of aiida.tools.data.array.kpoints.main._seekpath_get_explicit_kpoints_path:10
#: ../../../src/aiida/tools/data/array/kpoints/main.py:docstring of aiida.tools.data.array.kpoints.main._seekpath_get_kpoints_path:6
msgid "choose the reference publication that defines the special points and paths. Currently, the following value is implemented:  - ``hpkot``: HPKOT paper:   Y. Hinuma, G. Pizzi, Y. Kumagai, F. Oba, I. Tanaka, Band structure   diagram paths based on crystallography, Comp. Mat. Sci. 128, 140 (2017).   DOI: 10.1016/j.commatsci.2016.10.015"
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/main.py:docstring of aiida.tools.data.array.kpoints.main._seekpath_get_explicit_kpoints_path:10
#: ../../../src/aiida/tools/data/array/kpoints/main.py:docstring of aiida.tools.data.array.kpoints.main._seekpath_get_kpoints_path:6
msgid "choose the reference publication that defines the special points and paths. Currently, the following value is implemented:"
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/main.py:docstring of aiida.tools.data.array.kpoints.main._seekpath_get_explicit_kpoints_path:13
#: ../../../src/aiida/tools/data/array/kpoints/main.py:docstring of aiida.tools.data.array.kpoints.main._seekpath_get_kpoints_path:9
msgid "``hpkot``: HPKOT paper: Y. Hinuma, G. Pizzi, Y. Kumagai, F. Oba, I. Tanaka, Band structure diagram paths based on crystallography, Comp. Mat. Sci. 128, 140 (2017). DOI: 10.1016/j.commatsci.2016.10.015"
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/main.py:docstring of aiida.tools.data.array.kpoints.main._seekpath_get_explicit_kpoints_path:17
#: ../../../src/aiida/tools/data/array/kpoints/main.py:docstring of aiida.tools.data.array.kpoints.main._seekpath_get_kpoints_path:13
msgid "the threshold to use to verify if we are in and edge case (e.g., a tetragonal cell, but ``a==c``). For instance, in the tI lattice, if ``abs(a-c) < threshold``, a :py:exc:`~seekpath.hpkot.EdgeCaseWarning` is issued. Note that depending on the bravais lattice, the meaning of the threshold is different (angle, length, ...)"
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/main.py:docstring of aiida.tools.data.array.kpoints.main._seekpath_get_explicit_kpoints_path:23
#: ../../../src/aiida/tools/data/array/kpoints/main.py:docstring of aiida.tools.data.array.kpoints.main._seekpath_get_kpoints_path:19
msgid "the symmetry precision used internally by SPGLIB"
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/main.py:docstring of aiida.tools.data.array.kpoints.main._seekpath_get_explicit_kpoints_path:24
#: ../../../src/aiida/tools/data/array/kpoints/main.py:docstring of aiida.tools.data.array.kpoints.main._seekpath_get_kpoints_path:20
msgid "the angle_tolerance used internally by SPGLIB"
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/main.py:docstring of aiida.tools.data.array.kpoints.main._seekpath_get_kpoints_path:1
msgid "Call the get_kpoints_path wrapper function for Seekpath"
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/main.py:docstring of aiida.tools.data.array.kpoints.main.get_explicit_kpoints_path:1
#: ../../../src/aiida/tools/data/array/kpoints/main.py:docstring of aiida.tools.data.array.kpoints.main.get_kpoints_path:1
msgid "Returns a dictionary whose contents depend on the method but includes at least the following keys"
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/main.py:docstring of aiida.tools.data.array.kpoints.main.get_explicit_kpoints_path:3
#: ../../../src/aiida/tools/data/array/kpoints/main.py:docstring of aiida.tools.data.array.kpoints.main.get_kpoints_path:3
msgid "parameters: Dict node"
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/main.py:docstring of aiida.tools.data.array.kpoints.main.get_explicit_kpoints_path:4
msgid "explicit_kpoints: KpointsData node with explicit kpoints path"
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/main.py:docstring of aiida.tools.data.array.kpoints.main.get_explicit_kpoints_path:6
#: ../../../src/aiida/tools/data/array/kpoints/main.py:docstring of aiida.tools.data.array.kpoints.main.get_kpoints_path:5
msgid "The contents of the parameters depends on the method but contains at least the keys"
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/main.py:docstring of aiida.tools.data.array.kpoints.main.get_explicit_kpoints_path:8
#: ../../../src/aiida/tools/data/array/kpoints/main.py:docstring of aiida.tools.data.array.kpoints.main.get_kpoints_path:7
msgid "'point_coords': a dictionary with 'kpoints-label': [float coordinates]"
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/main.py:docstring of aiida.tools.data.array.kpoints.main.get_explicit_kpoints_path:10
#: ../../../src/aiida/tools/data/array/kpoints/main.py:docstring of aiida.tools.data.array.kpoints.main.get_kpoints_path:9
msgid "'path': a list of length-2 tuples, with the labels of the starting"
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/main.py:docstring of aiida.tools.data.array.kpoints.main.get_explicit_kpoints_path:10
#: ../../../src/aiida/tools/data/array/kpoints/main.py:docstring of aiida.tools.data.array.kpoints.main.get_kpoints_path:9
msgid "and ending point of each label section"
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/main.py:docstring of aiida.tools.data.array.kpoints.main.get_explicit_kpoints_path:12
#: ../../../src/aiida/tools/data/array/kpoints/main.py:docstring of aiida.tools.data.array.kpoints.main.get_kpoints_path:11
msgid "The 'seekpath' method which is the default also returns the following additional nodes"
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/main.py:docstring of aiida.tools.data.array.kpoints.main.get_explicit_kpoints_path:14
#: ../../../src/aiida/tools/data/array/kpoints/main.py:docstring of aiida.tools.data.array.kpoints.main.get_kpoints_path:13
msgid "primitive_structure: StructureData with the primitive cell"
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/main.py:docstring of aiida.tools.data.array.kpoints.main.get_explicit_kpoints_path:15
#: ../../../src/aiida/tools/data/array/kpoints/main.py:docstring of aiida.tools.data.array.kpoints.main.get_kpoints_path:14
msgid "conv_structure: StructureData with the conventional cell"
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/main.py:docstring of aiida.tools.data.array.kpoints.main.get_explicit_kpoints_path:17
#: ../../../src/aiida/tools/data/array/kpoints/main.py:docstring of aiida.tools.data.array.kpoints.main.get_kpoints_path:16
msgid "Note that the generated kpoints for the seekpath method only apply on the returned primitive_structure and not on the input structure that was provided"
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/main.py:docstring of aiida.tools.data.array.kpoints.main.get_explicit_kpoints_path:21
#: ../../../src/aiida/tools/data/array/kpoints/main.py:docstring of aiida.tools.data.array.kpoints.main.get_kpoints_path:20
msgid "the method to use for kpoint generation, options are 'seekpath' and 'legacy'. It is strongly advised to use the default 'seekpath' as the 'legacy' implementation is known to have bugs for certain structure cells"
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/main.py:docstring of aiida.tools.data.array.kpoints.main.get_explicit_kpoints_path:24
#: ../../../src/aiida/tools/data/array/kpoints/main.py:docstring of aiida.tools.data.array.kpoints.main.get_kpoints_path:23
msgid "optional keyword arguments that depend on the selected method"
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/main.py:docstring of aiida.tools.data.array.kpoints.main.get_explicit_kpoints_path:25
#: ../../../src/aiida/tools/data/array/kpoints/main.py:docstring of aiida.tools.data.array.kpoints.main.get_kpoints_path:24
msgid "dictionary as described above in the docstring"
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/seekpath.py:docstring of aiida.tools.data.array.kpoints.seekpath:1
msgid "Tool to automatically determine k-points for a given structure using SeeK-path."
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/seekpath.py:docstring of aiida.tools.data.array.kpoints.seekpath.get_explicit_kpoints_path:1
msgid "Return the kpoint path for band structure (in scaled and absolute coordinates), given a crystal structure, using the paths proposed in the various publications (see description of the 'recipe' input parameter). The parameters are the same as get get_explicit_k_path in __init__, but here all structures are input and returned as AiiDA structures rather than tuples, and similarly k-points-related information as a AiiDA KpointsData class."
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/seekpath.py:docstring of aiida.tools.data.array.kpoints.seekpath.get_explicit_kpoints_path:9
msgid "The AiiDA StructureData for which we want to obtain the suggested path."
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/seekpath.py:docstring of aiida.tools.data.array.kpoints.seekpath.get_explicit_kpoints_path:12
msgid "A dictionary whose key-value pairs are passed as additional kwargs to the ``seekpath.get_explicit_k_path`` function."
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/seekpath.py:docstring of aiida.tools.data.array.kpoints.seekpath.get_explicit_kpoints_path:15
msgid "A dictionary with four nodes:  - ``explicit_kpoints``: a KpointsData with the (explicit) kpoints   (with labels set).  - ``parameters``: a Dict, whose content is   the same dictionary as returned by the ``seekpath.get_explicit_k_path`` function   (see `seekpath documentation <https://seekpath.readthedocs.io/>`_),   except that:    - ``conv_lattice``, ``conv_positions``, ``conv_types``     are removed and replaced by the ``conv_structure`` output node    - ``primitive_lattice``, ``primitive_positions``, ``primitive_types``     are removed and replaced by the `primitive_structure` output node    - ``reciprocal_primitive_lattice``, ``explicit_kpoints_abs``,     ``explicit_kpoints_rel`` and ``explicit_kpoints_labels`` are removed     and replaced by the ``explicit_kpoints`` output node  - ``primitive_structure``: A StructureData with the primitive structure  - ``conv_structure``: A StructureData with the primitive structure"
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/seekpath.py:docstring of aiida.tools.data.array.kpoints.seekpath.get_explicit_kpoints_path:15
msgid "A dictionary with four nodes:"
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/seekpath.py:docstring of aiida.tools.data.array.kpoints.seekpath.get_explicit_kpoints_path:17
msgid "``explicit_kpoints``: a KpointsData with the (explicit) kpoints (with labels set)."
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/seekpath.py:docstring of aiida.tools.data.array.kpoints.seekpath.get_explicit_kpoints_path:20
msgid "``parameters``: a Dict, whose content is the same dictionary as returned by the ``seekpath.get_explicit_k_path`` function (see `seekpath documentation <https://seekpath.readthedocs.io/>`_), except that:"
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/seekpath.py:docstring of aiida.tools.data.array.kpoints.seekpath.get_explicit_kpoints_path:25
#: ../../../src/aiida/tools/data/array/kpoints/seekpath.py:docstring of aiida.tools.data.array.kpoints.seekpath.get_kpoints_path:24
msgid "``conv_lattice``, ``conv_positions``, ``conv_types`` are removed and replaced by the ``conv_structure`` output node"
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/seekpath.py:docstring of aiida.tools.data.array.kpoints.seekpath.get_explicit_kpoints_path:28
msgid "``primitive_lattice``, ``primitive_positions``, ``primitive_types`` are removed and replaced by the `primitive_structure` output node"
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/seekpath.py:docstring of aiida.tools.data.array.kpoints.seekpath.get_explicit_kpoints_path:31
msgid "``reciprocal_primitive_lattice``, ``explicit_kpoints_abs``, ``explicit_kpoints_rel`` and ``explicit_kpoints_labels`` are removed and replaced by the ``explicit_kpoints`` output node"
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/seekpath.py:docstring of aiida.tools.data.array.kpoints.seekpath.get_explicit_kpoints_path:35
#: ../../../src/aiida/tools/data/array/kpoints/seekpath.py:docstring of aiida.tools.data.array.kpoints.seekpath.get_kpoints_path:30
msgid "``primitive_structure``: A StructureData with the primitive structure"
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/seekpath.py:docstring of aiida.tools.data.array.kpoints.seekpath.get_explicit_kpoints_path:37
#: ../../../src/aiida/tools/data/array/kpoints/seekpath.py:docstring of aiida.tools.data.array.kpoints.seekpath.get_kpoints_path:32
msgid "``conv_structure``: A StructureData with the primitive structure"
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/seekpath.py:docstring of aiida.tools.data.array.kpoints.seekpath.get_kpoints_path:1
msgid "Return the kpoint path information for band structure given a crystal structure, using the paths from the chosen recipe/reference. The parameters are the same as get get_path in __init__, but here all structures are input and returned as AiiDA structures rather than tuples."
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/seekpath.py:docstring of aiida.tools.data.array.kpoints.seekpath.get_kpoints_path:8
msgid "If you use this module, please cite the paper of the corresponding recipe (see documentation of seekpath)."
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/seekpath.py:docstring of aiida.tools.data.array.kpoints.seekpath.get_kpoints_path:11
msgid "The crystal structure for which we want to obtain the suggested path. It should be an AiiDA StructureData object."
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/seekpath.py:docstring of aiida.tools.data.array.kpoints.seekpath.get_kpoints_path:14
msgid "A dictionary whose key-value pairs are passed as additional kwargs to the ``seekpath.get_path`` function."
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/seekpath.py:docstring of aiida.tools.data.array.kpoints.seekpath.get_kpoints_path:17
msgid "A dictionary with three nodes:  - ``parameters``: a Dict, whose content is   the same dictionary as returned by the ``seekpath.get_path`` function   (see `seekpath documentation <https://seekpath.readthedocs.io/>`_),   except that:    - ``conv_lattice``, ``conv_positions``, ``conv_types``     are removed and replaced by the ``conv_structure`` output node    - ``primitive_lattice``, ``primitive_positions``, ``primitive_types``     are removed and replaced by the ``primitive_structure`` output node  - ``primitive_structure``: A StructureData with the primitive structure  - ``conv_structure``: A StructureData with the primitive structure"
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/seekpath.py:docstring of aiida.tools.data.array.kpoints.seekpath.get_kpoints_path:17
msgid "A dictionary with three nodes:"
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/seekpath.py:docstring of aiida.tools.data.array.kpoints.seekpath.get_kpoints_path:19
msgid "``parameters``: a Dict, whose content is the same dictionary as returned by the ``seekpath.get_path`` function (see `seekpath documentation <https://seekpath.readthedocs.io/>`_), except that:"
msgstr ""

#: ../../../src/aiida/tools/data/array/kpoints/seekpath.py:docstring of aiida.tools.data.array.kpoints.seekpath.get_kpoints_path:27
msgid "``primitive_lattice``, ``primitive_positions``, ``primitive_types`` are removed and replaced by the ``primitive_structure`` output node"
msgstr ""

#: ../../source/reference/apidoc/aiida.tools.data.orbital.rst:2
msgid "aiida.tools.data.orbital package"
msgstr ""

#: ../../../src/aiida/tools/data/orbital/__init__.py:docstring of aiida.tools.data.orbital:1
msgid "Module for classes and methods that represents molecular orbitals."
msgstr ""

#: ../../../src/aiida/tools/data/orbital/orbital.py:docstring of aiida.tools.data.orbital.orbital:1
msgid "Classes for describing atomic orbitals."
msgstr ""

#: ../../../src/aiida/tools/data/orbital/orbital.py:docstring of aiida.tools.data.orbital.orbital:3
msgid "Contains general Orbital class. For subclasses of Orbital, see submodules."
msgstr ""

#: ../../../src/aiida/tools/data/orbital/orbital.py:docstring of aiida.tools.data.orbital.orbital.Orbital:1
msgid "Base class for Orbitals. Can handle certain basic fields, their setting and validation. More complex Orbital objects should then inherit from this class"
msgstr ""

#: ../../../src/aiida/tools/data/orbital/orbital.py:docstring of aiida.tools.data.orbital.orbital.Orbital:5
msgid "the absolute position (three floats) units in angstrom"
msgstr ""

#: ../../../src/aiida/tools/data/orbital/orbital.py:docstring of aiida.tools.data.orbital.orbital.Orbital:6
msgid "x,y,z unit vector defining polar angle theta in spherical coordinates unitless"
msgstr ""

#: ../../../src/aiida/tools/data/orbital/orbital.py:docstring of aiida.tools.data.orbital.orbital.Orbital:8
msgid "x,y,z unit vector defining azimuthal angle phi in spherical coordinates unitless"
msgstr ""

#: ../../../src/aiida/tools/data/orbital/orbital.py:docstring of aiida.tools.data.orbital.orbital.Orbital:10
msgid "x,y,z unit vector defining the spin orientation unitless"
msgstr ""

#: ../../../src/aiida/tools/data/orbital/orbital.py:docstring of aiida.tools.data.orbital.orbital.Orbital:12
msgid "Float controls the radial term in orbital equation units are reciprocal Angstrom."
msgstr ""

#: ../../../src/aiida/tools/data/orbital/orbital.py:docstring of aiida.tools.data.orbital.orbital.Orbital._validate_keys:1
msgid "Checks all the input_dict and tries to validate them, to ensure that they have been properly set raises Exceptions indicating any problems that should arise during the validation"
msgstr ""

#: ../../../src/aiida/tools/data/orbital/orbital.py:docstring of aiida.tools.data.orbital.orbital.Orbital._validate_keys:5
msgid "a dictionary of inputs"
msgstr ""

#: ../../../src/aiida/tools/data/orbital/orbital.py:docstring of aiida.tools.data.orbital.orbital.Orbital._validate_keys:6
msgid "input_dict: the original dictionary with all validated kyes now removed"
msgstr ""

#: ../../../src/aiida/tools/data/orbital/orbital.py:docstring of aiida.tools.data.orbital.orbital.Orbital._validate_keys:8
msgid "validated_dict: a dictionary containing all the input keys which have now been validated."
msgstr ""

#: ../../../src/aiida/tools/data/orbital/orbital.py:docstring of aiida.tools.data.orbital.orbital.Orbital.get_orbital_dict:1
msgid "Returns the internal keys as a dictionary"
msgstr ""

#: ../../../src/aiida/tools/data/orbital/orbital.py:docstring of aiida.tools.data.orbital.orbital.Orbital.set_orbital_dict:1
msgid "Sets the orbital_dict, which can vary depending on the particular implementation of this base class."
msgstr ""

#: ../../../src/aiida/tools/data/orbital/orbital.py:docstring of aiida.tools.data.orbital.orbital.Orbital.set_orbital_dict:4
msgid "the initialization dictionary"
msgstr ""

#: ../../../src/aiida/tools/data/orbital/orbital.py:docstring of aiida.tools.data.orbital.orbital.validate_float:1
msgid "Validate that the value is a float"
msgstr ""

#: ../../../src/aiida/tools/data/orbital/orbital.py:docstring of aiida.tools.data.orbital.orbital.validate_float_or_none:1
msgid "Validate that the value is a float or is None"
msgstr ""

#: ../../../src/aiida/tools/data/orbital/orbital.py:docstring of aiida.tools.data.orbital.orbital.validate_int:1
msgid "Validate that the value is an int"
msgstr ""

#: ../../../src/aiida/tools/data/orbital/orbital.py:docstring of aiida.tools.data.orbital.orbital.validate_int_or_none:1
msgid "Validate that the value is a int or is None"
msgstr ""

#: ../../../src/aiida/tools/data/orbital/orbital.py:docstring of aiida.tools.data.orbital.orbital.validate_len3_list:1
msgid "Validate that the value is a list of three floats"
msgstr ""

#: ../../../src/aiida/tools/data/orbital/orbital.py:docstring of aiida.tools.data.orbital.orbital.validate_len3_list_or_none:1
msgid "Validate that the value is a list of three floats or is None"
msgstr ""

#: ../../../src/aiida/tools/data/orbital/realhydrogen.py:docstring of aiida.tools.data.orbital.realhydrogen:1
msgid "A module defining hydrogen-like orbitals that are real valued (rather than complex-valued)."
msgstr ""

#: ../../../src/aiida/tools/data/orbital/realhydrogen.py:docstring of aiida.tools.data.orbital.realhydrogen.RealhydrogenOrbital:1
msgid "Bases: :py:class:`~aiida.tools.data.orbital.orbital.Orbital`"
msgstr ""

#: ../../../src/aiida/tools/data/orbital/realhydrogen.py:docstring of aiida.tools.data.orbital.realhydrogen.RealhydrogenOrbital:1
msgid "Orbitals for hydrogen, largely follows the conventions used by wannier90 Object to handle the generation of real hydrogen orbitals and their hybrids, has methods for producing s, p, d, f, and sp, sp2, sp3, sp3d, sp3d2 hybrids. This method does not deal with the cannonical hydrogen orbitals which contain imaginary components."
msgstr ""

#: ../../../src/aiida/tools/data/orbital/realhydrogen.py:docstring of aiida.tools.data.orbital.realhydrogen.RealhydrogenOrbital:7
msgid "The orbitals described here are chiefly concerned with the symmetric aspects of the oribitals without the context of space. Therefore diffusitivity, position and atomic labels should be handled in the OrbitalData class."
msgstr ""

#: ../../../src/aiida/tools/data/orbital/realhydrogen.py:docstring of aiida.tools.data.orbital.realhydrogen.RealhydrogenOrbital:12
msgid "Following the notation of table 3.1, 3.2 of Wannier90 user guide (which can be downloaded from http://www.wannier.org/support/) A brief description of what is meant by each of these labels:"
msgstr ""

#: ../../../src/aiida/tools/data/orbital/realhydrogen.py:docstring of aiida.tools.data.orbital.realhydrogen.RealhydrogenOrbital:16
msgid "the number of radial nodes (or inflections) if no radial nodes are supplied, defaults to 0"
msgstr ""

#: ../../../src/aiida/tools/data/orbital/realhydrogen.py:docstring of aiida.tools.data.orbital.realhydrogen.RealhydrogenOrbital:18
msgid "Angular quantum number, using real orbitals"
msgstr ""

#: ../../../src/aiida/tools/data/orbital/realhydrogen.py:docstring of aiida.tools.data.orbital.realhydrogen.RealhydrogenOrbital:19
msgid "Magnetic quantum number, using real orbitals"
msgstr ""

#: ../../../src/aiida/tools/data/orbital/realhydrogen.py:docstring of aiida.tools.data.orbital.realhydrogen.RealhydrogenOrbital:20
msgid "spin, up (1) down (-1) or unspecified (0)"
msgstr ""

#: ../../../src/aiida/tools/data/orbital/realhydrogen.py:docstring of aiida.tools.data.orbital.realhydrogen.RealhydrogenOrbital:22
msgid "The conventions regarding L and M correpsond to those used in wannier90 for all L greater than 0 the orbital is not hyrbridized see table 3.1 and for L less than 0 the orbital is hybridized see table 3.2. M then indexes all the possible orbitals from 0 to 2L for L > 0 and from 0 to (-L) for L < 0."
msgstr ""

#: ../../../src/aiida/tools/data/orbital/realhydrogen.py:docstring of aiida.tools.data.orbital.realhydrogen.RealhydrogenOrbital._validate_keys:1
msgid "Validates the keys otherwise raise ValidationError. Does basic validation from the parent followed by validations for the quantum numbers. Raises exceptions should the input_dict fail the valiation or if it contains any unsupported keywords."
msgstr ""

#: ../../../src/aiida/tools/data/orbital/realhydrogen.py:docstring of aiida.tools.data.orbital.realhydrogen.RealhydrogenOrbital._validate_keys:6
msgid "the dictionary of keys to be validated"
msgstr ""

#: ../../../src/aiida/tools/data/orbital/realhydrogen.py:docstring of aiida.tools.data.orbital.realhydrogen.RealhydrogenOrbital._validate_keys:0
msgid "return validated_dict"
msgstr ""

#: ../../../src/aiida/tools/data/orbital/realhydrogen.py:docstring of aiida.tools.data.orbital.realhydrogen.RealhydrogenOrbital._validate_keys:7
msgid "a validated dictionary"
msgstr ""

#: ../../../src/aiida/tools/data/orbital/realhydrogen.py:docstring of aiida.tools.data.orbital.realhydrogen.RealhydrogenOrbital.get_name_from_quantum_numbers:1
msgid "Returns the orbital_name correponding to the angular_momentum alone, or to both angular_number with magnetic_number. For example using angular_momentum=1 and magnetic_number=1 will return \"Px\""
msgstr ""

#: ../../../src/aiida/tools/data/orbital/realhydrogen.py:docstring of aiida.tools.data.orbital.realhydrogen.RealhydrogenOrbital.get_quantum_numbers_from_name:1
msgid "Returns all the angular and magnetic numbers corresponding to name. For example, using \"P\" as name will return all quantum numbers associated with a \"P\" orbital, while \"Px\" will return only one set of quantum numbers, the ones associated with \"Px\""
msgstr ""

#: ../../../src/aiida/tools/data/orbital/realhydrogen.py:docstring of aiida.tools.data.orbital.realhydrogen.validate_kind_name:1
msgid "Validate the value of the kind_name"
msgstr ""

#: ../../../src/aiida/tools/data/orbital/realhydrogen.py:docstring of aiida.tools.data.orbital.realhydrogen.validate_l:1
msgid "Validate the value of the angular momentum"
msgstr ""

#: ../../../src/aiida/tools/data/orbital/realhydrogen.py:docstring of aiida.tools.data.orbital.realhydrogen.validate_m:1
msgid "Validate the value of the magnetic number"
msgstr ""

#: ../../../src/aiida/tools/data/orbital/realhydrogen.py:docstring of aiida.tools.data.orbital.realhydrogen.validate_n:1
msgid "Validate the value of the number of radial nodes"
msgstr ""

#: ../../../src/aiida/tools/data/orbital/realhydrogen.py:docstring of aiida.tools.data.orbital.realhydrogen.validate_spin:1
msgid "Validate the value of the spin"
msgstr ""

#: ../../source/reference/apidoc/aiida.tools.dbexporters.rst:2
msgid "aiida.tools.dbexporters package"
msgstr ""

#: ../../source/reference/apidoc/aiida.tools.dbimporters.rst:2
msgid "aiida.tools.dbimporters package"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/__init__.py:docstring of aiida.tools.dbimporters:1
#: ../../../src/aiida/tools/dbimporters/plugins/__init__.py:docstring of aiida.tools.dbimporters.plugins:1
msgid "Module for plugins to import data from external databases into an AiiDA database."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses:1
#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbImporter:1
msgid "Base class implementation for an external database importer."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.CifEntry:1
#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.UpfEntry:1
#: ../../../src/aiida/tools/dbimporters/plugins/mpds.py:docstring of aiida.tools.dbimporters.plugins.mpds.MpdsEntry:1
msgid "Bases: :py:class:`~aiida.tools.dbimporters.baseclasses.DbEntry`"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.CifEntry:1
msgid "Represents an entry from the structure database (COD, ICSD, ...)."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.CifEntry.cif:1
#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.CifEntry.get_raw_cif:1
msgid "Returns raw contents of a CIF file as string."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.CifEntry.get_aiida_structure:1
msgid "AiiDA structure corresponding to the CIF file."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.CifEntry.get_ase_structure:1
msgid "Returns ASE representation of the CIF."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.CifEntry.get_ase_structure:3
msgid "To be removed, as it is duplicated in :py:class:`aiida.orm.nodes.data.cif.CifData`."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.CifEntry.get_cif_node:1
msgid "Creates a CIF node, that can be used in AiiDA workflow."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.CifEntry.get_cif_node:3
msgid ":py:class:`aiida.orm.nodes.data.cif.CifData` object"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.CifEntry.get_parsed_cif:1
msgid "Returns data structure, representing the CIF file. Can be created using PyCIFRW or any other open-source parser."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.CifEntry.get_parsed_cif:4
msgid "list of lists"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.CifEntry.get_raw_cif:3
msgid "contents of a file as string"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbEntry:1
msgid "Represents an entry from external database."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbEntry.__init__:1
msgid "Sets the basic parameters for the database entry:"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbEntry.__init__:3
msgid "name of the source database"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbEntry.__init__:4
msgid "URI of the source database"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbEntry.__init__:5
msgid "structure identifyer in the database"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbEntry.__init__:6
msgid "version of the database"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbEntry.__init__:7
msgid "a dictionary with some extra parameters (e.g. database ID number)"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbEntry.__init__:9
msgid "URI of the structure (should be permanent)"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbEntry.contents:1
msgid "Returns raw contents of a file as string."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbImporter.get_supported_keywords:1
#: ../../../src/aiida/tools/dbimporters/plugins/cod.py:docstring of aiida.tools.dbimporters.plugins.cod.CodDbImporter.get_supported_keywords:1
#: ../../../src/aiida/tools/dbimporters/plugins/mpod.py:docstring of aiida.tools.dbimporters.plugins.mpod.MpodDbImporter.get_supported_keywords:1
#: ../../../src/aiida/tools/dbimporters/plugins/nninc.py:docstring of aiida.tools.dbimporters.plugins.nninc.NnincDbImporter.get_supported_keywords:1
#: ../../../src/aiida/tools/dbimporters/plugins/oqmd.py:docstring of aiida.tools.dbimporters.plugins.oqmd.OqmdDbImporter.get_supported_keywords:1
msgid "Returns the list of all supported query keywords."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbImporter.get_supported_keywords:3
#: ../../../src/aiida/tools/dbimporters/plugins/cod.py:docstring of aiida.tools.dbimporters.plugins.cod.CodDbImporter.get_supported_keywords:3
#: ../../../src/aiida/tools/dbimporters/plugins/materialsproject.py:docstring of aiida.tools.dbimporters.plugins.materialsproject.MaterialsProjectImporter.get_supported_keywords:3
#: ../../../src/aiida/tools/dbimporters/plugins/mpds.py:docstring of aiida.tools.dbimporters.plugins.mpds.MpdsDbImporter.get_supported_keywords:3
#: ../../../src/aiida/tools/dbimporters/plugins/mpod.py:docstring of aiida.tools.dbimporters.plugins.mpod.MpodDbImporter.get_supported_keywords:3
#: ../../../src/aiida/tools/dbimporters/plugins/nninc.py:docstring of aiida.tools.dbimporters.plugins.nninc.NnincDbImporter.get_supported_keywords:3
#: ../../../src/aiida/tools/dbimporters/plugins/oqmd.py:docstring of aiida.tools.dbimporters.plugins.oqmd.OqmdDbImporter.get_supported_keywords:3
msgid "list of strings"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbImporter.query:1
msgid "Method to query the database."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbImporter.query:3
msgid "database-specific entry identificator"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbImporter.query:4
msgid "element name from periodic table of elements"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbImporter.query:5
msgid "number of different elements"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbImporter.query:6
msgid "name of mineral"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbImporter.query:7
msgid "chemical name of substance"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbImporter.query:8
msgid "chemical formula"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbImporter.query:9
msgid "volume of the unit cell in cubic angstroms"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbImporter.query:10
msgid "symmetry space group symbol in Hermann-Mauguin notation"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbImporter.query:12
msgid "symmetry space group symbol in Hall notation"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbImporter.query:14
#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbImporter.query:15
#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbImporter.query:16
msgid "length of lattice vector in angstroms"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbImporter.query:17
#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbImporter.query:18
#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbImporter.query:19
msgid "angles between lattice vectors in degrees"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbImporter.query:20
msgid "number of the formula units in the unit cell"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbImporter.query:21
msgid "temperature in kelvins at which the unit-cell parameters were measured"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbImporter.query:23
msgid "pressure in kPa at which the unit-cell parameters were measured"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbImporter.query:25
msgid "mean temperature in kelvins at which the intensities were measured"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbImporter.query:27
msgid "mean pressure in kPa at which the intensities were measured"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbImporter.query:29
msgid "authors of the publication"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbImporter.query:30
msgid "name of the journal"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbImporter.query:31
msgid "title of the publication"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbImporter.query:32
msgid "year of the publication"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbImporter.query:33
msgid "journal volume of the publication"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbImporter.query:34
msgid "journal issue of the publication"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbImporter.query:35
msgid "first page of the publication"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbImporter.query:36
msgid "last page of the publication"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbImporter.query:37
msgid "digital object identifyer (DOI), refering to the publication"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbImporter.query:40
msgid "if search using given keyword is not implemented."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbImporter.setup_db:1
msgid "Sets the database parameters. The method should reconnect to the database using updated parameters, if already connected."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbSearchResults:1
msgid "Base class for database results."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbSearchResults:3
msgid "All classes, inheriting this one and overriding ``at()``, are able to benefit from having functions ``__iter__``, ``__len__`` and ``__getitem__``."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbSearchResults.DbSearchResultsIterator:1
msgid "Iterator for search results."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbSearchResults.DbSearchResultsIterator.__next__:1
msgid "Return the next entry in the iterator."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbSearchResults.__iter__:1
msgid "Instances of :py:class:`aiida.tools.dbimporters.baseclasses.DbSearchResults` can be used as iterators."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbSearchResults._get_source_dict:1
#: ../../../src/aiida/tools/dbimporters/plugins/cod.py:docstring of aiida.tools.dbimporters.plugins.cod.CodSearchResults._get_source_dict:1
#: ../../../src/aiida/tools/dbimporters/plugins/mpod.py:docstring of aiida.tools.dbimporters.plugins.mpod.MpodSearchResults._get_source_dict:1
#: ../../../src/aiida/tools/dbimporters/plugins/nninc.py:docstring of aiida.tools.dbimporters.plugins.nninc.NnincSearchResults._get_source_dict:1
#: ../../../src/aiida/tools/dbimporters/plugins/oqmd.py:docstring of aiida.tools.dbimporters.plugins.oqmd.OqmdSearchResults._get_source_dict:1
msgid "Returns a dictionary, which is passed as kwargs to the created DbEntry instance, describing the source of the entry."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbSearchResults._get_source_dict:4
#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbSearchResults._get_url:3
#: ../../../src/aiida/tools/dbimporters/plugins/cod.py:docstring of aiida.tools.dbimporters.plugins.cod.CodSearchResults._get_source_dict:4
#: ../../../src/aiida/tools/dbimporters/plugins/cod.py:docstring of aiida.tools.dbimporters.plugins.cod.CodSearchResults._get_url:3
#: ../../../src/aiida/tools/dbimporters/plugins/mpod.py:docstring of aiida.tools.dbimporters.plugins.mpod.MpodSearchResults._get_source_dict:4
#: ../../../src/aiida/tools/dbimporters/plugins/mpod.py:docstring of aiida.tools.dbimporters.plugins.mpod.MpodSearchResults._get_url:3
#: ../../../src/aiida/tools/dbimporters/plugins/nninc.py:docstring of aiida.tools.dbimporters.plugins.nninc.NnincSearchResults._get_source_dict:4
#: ../../../src/aiida/tools/dbimporters/plugins/nninc.py:docstring of aiida.tools.dbimporters.plugins.nninc.NnincSearchResults._get_url:3
#: ../../../src/aiida/tools/dbimporters/plugins/oqmd.py:docstring of aiida.tools.dbimporters.plugins.oqmd.OqmdSearchResults._get_source_dict:4
#: ../../../src/aiida/tools/dbimporters/plugins/oqmd.py:docstring of aiida.tools.dbimporters.plugins.oqmd.OqmdSearchResults._get_url:3
#: ../../../src/aiida/tools/dbimporters/plugins/pcod.py:docstring of aiida.tools.dbimporters.plugins.pcod.PcodSearchResults._get_url:3
msgid "dictionary, describing an entry in the results."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbSearchResults._get_url:1
#: ../../../src/aiida/tools/dbimporters/plugins/cod.py:docstring of aiida.tools.dbimporters.plugins.cod.CodSearchResults._get_url:1
#: ../../../src/aiida/tools/dbimporters/plugins/mpod.py:docstring of aiida.tools.dbimporters.plugins.mpod.MpodSearchResults._get_url:1
#: ../../../src/aiida/tools/dbimporters/plugins/nninc.py:docstring of aiida.tools.dbimporters.plugins.nninc.NnincSearchResults._get_url:1
#: ../../../src/aiida/tools/dbimporters/plugins/oqmd.py:docstring of aiida.tools.dbimporters.plugins.oqmd.OqmdSearchResults._get_url:1
#: ../../../src/aiida/tools/dbimporters/plugins/pcod.py:docstring of aiida.tools.dbimporters.plugins.pcod.PcodSearchResults._get_url:1
msgid "Returns an URL of an entry CIF file."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbSearchResults.at:1
msgid "Returns ``position``-th result as :py:class:`aiida.tools.dbimporters.baseclasses.DbEntry`."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbSearchResults.at:4
msgid "zero-based index of a result."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbSearchResults.at:6
msgid "if ``position`` is out of bounds."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbSearchResults.fetch_all:1
msgid "Returns all query results as an array of :py:class:`aiida.tools.dbimporters.baseclasses.DbEntry`."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbSearchResults.next:1
msgid "Returns the next result of the query (instance of :py:class:`aiida.tools.dbimporters.baseclasses.DbEntry`)."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.DbSearchResults.next:4
msgid "when the end of result array is reached."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.UpfEntry:1
msgid "Represents an entry from the pseudopotential database."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.UpfEntry.get_upf_node:1
msgid "Creates an UPF node, that can be used in AiiDA workflow."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/baseclasses.py:docstring of aiida.tools.dbimporters.baseclasses.UpfEntry.get_upf_node:3
msgid ":py:class:`aiida.orm.nodes.data.upf.UpfData` object"
msgstr ""

#: ../../source/reference/apidoc/aiida.tools.dbimporters.plugins.rst:2
msgid "aiida.tools.dbimporters.plugins package"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/cod.py:docstring of aiida.tools.dbimporters.plugins.cod:1
msgid "\"Implementation of `DbImporter` for the COD database."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/cod.py:docstring of aiida.tools.dbimporters.plugins.cod.CodDbImporter:1
#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.IcsdDbImporter:1
#: ../../../src/aiida/tools/dbimporters/plugins/materialsproject.py:docstring of aiida.tools.dbimporters.plugins.materialsproject.MaterialsProjectImporter:1
#: ../../../src/aiida/tools/dbimporters/plugins/mpds.py:docstring of aiida.tools.dbimporters.plugins.mpds.MpdsDbImporter:1
#: ../../../src/aiida/tools/dbimporters/plugins/mpod.py:docstring of aiida.tools.dbimporters.plugins.mpod.MpodDbImporter:1
#: ../../../src/aiida/tools/dbimporters/plugins/nninc.py:docstring of aiida.tools.dbimporters.plugins.nninc.NnincDbImporter:1
#: ../../../src/aiida/tools/dbimporters/plugins/oqmd.py:docstring of aiida.tools.dbimporters.plugins.oqmd.OqmdDbImporter:1
msgid "Bases: :py:class:`~aiida.tools.dbimporters.baseclasses.DbImporter`"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/cod.py:docstring of aiida.tools.dbimporters.plugins.cod.CodDbImporter:1
msgid "Database importer for Crystallography Open Database."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/cod.py:docstring of aiida.tools.dbimporters.plugins.cod.CodDbImporter._angle_clause:1
msgid "Returns SQL query predicate for querying lattice angles."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/cod.py:docstring of aiida.tools.dbimporters.plugins.cod.CodDbImporter._composition_clause:1
msgid "Returns SQL query predicate for querying elements in formula fields."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/cod.py:docstring of aiida.tools.dbimporters.plugins.cod.CodDbImporter._connect_db:1
msgid "Connects to the MySQL database for performing searches."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/cod.py:docstring of aiida.tools.dbimporters.plugins.cod.CodDbImporter._disconnect_db:1
msgid "Closes connection to the MySQL database."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/cod.py:docstring of aiida.tools.dbimporters.plugins.cod.CodDbImporter._double_clause:1
msgid "Returns SQL query predicate for querying double-valued fields."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/cod.py:docstring of aiida.tools.dbimporters.plugins.cod.CodDbImporter._formula_clause:1
msgid "Returns SQL query predicate for querying formula fields."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/cod.py:docstring of aiida.tools.dbimporters.plugins.cod.CodDbImporter._int_clause:1
msgid "Returns SQL query predicate for querying integer fields."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/cod.py:docstring of aiida.tools.dbimporters.plugins.cod.CodDbImporter._length_clause:1
msgid "Returns SQL query predicate for querying lattice vector lengths."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/cod.py:docstring of aiida.tools.dbimporters.plugins.cod.CodDbImporter._pressure_clause:1
msgid "Returns SQL query predicate for querying pressure."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/cod.py:docstring of aiida.tools.dbimporters.plugins.cod.CodDbImporter._str_exact_clause:1
msgid "Returns SQL query predicate for querying string fields."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/cod.py:docstring of aiida.tools.dbimporters.plugins.cod.CodDbImporter._str_exact_or_none_clause:1
msgid "Returns SQL query predicate for querying string fields, allowing to use Python's \"None\" in addition."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/cod.py:docstring of aiida.tools.dbimporters.plugins.cod.CodDbImporter._str_fuzzy_clause:1
msgid "Returns SQL query predicate for fuzzy querying of string fields."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/cod.py:docstring of aiida.tools.dbimporters.plugins.cod.CodDbImporter._temperature_clause:1
msgid "Returns SQL query predicate for querying temperature."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/cod.py:docstring of aiida.tools.dbimporters.plugins.cod.CodDbImporter._volume_clause:1
msgid "Returns SQL query predicate for querying unit cell volume."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/cod.py:docstring of aiida.tools.dbimporters.plugins.cod.CodDbImporter.query:1
msgid "Performs a query on the COD database using ``keyword = value`` pairs, specified in ``kwargs``."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/cod.py:docstring of aiida.tools.dbimporters.plugins.cod.CodDbImporter.query:4
msgid "an instance of :py:class:`aiida.tools.dbimporters.plugins.cod.CodSearchResults`."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/cod.py:docstring of aiida.tools.dbimporters.plugins.cod.CodDbImporter.query_sql:1
msgid "Forms a SQL query for querying the COD database using ``keyword = value`` pairs, specified in ``kwargs``."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/cod.py:docstring of aiida.tools.dbimporters.plugins.cod.CodDbImporter.query_sql:4
#: ../../../src/aiida/tools/dbimporters/plugins/pcod.py:docstring of aiida.tools.dbimporters.plugins.pcod.PcodDbImporter.query_sql:4
msgid "string containing a SQL statement."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/cod.py:docstring of aiida.tools.dbimporters.plugins.cod.CodDbImporter.setup_db:1
#: ../../../src/aiida/tools/dbimporters/plugins/mpod.py:docstring of aiida.tools.dbimporters.plugins.mpod.MpodDbImporter.setup_db:1
#: ../../../src/aiida/tools/dbimporters/plugins/nninc.py:docstring of aiida.tools.dbimporters.plugins.nninc.NnincDbImporter.setup_db:1
#: ../../../src/aiida/tools/dbimporters/plugins/oqmd.py:docstring of aiida.tools.dbimporters.plugins.oqmd.OqmdDbImporter.setup_db:1
msgid "Changes the database connection details."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/cod.py:docstring of aiida.tools.dbimporters.plugins.cod.CodEntry:1
#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.IcsdEntry:1
#: ../../../src/aiida/tools/dbimporters/plugins/materialsproject.py:docstring of aiida.tools.dbimporters.plugins.materialsproject.MaterialsProjectCifEntry:1
#: ../../../src/aiida/tools/dbimporters/plugins/mpod.py:docstring of aiida.tools.dbimporters.plugins.mpod.MpodEntry:1
#: ../../../src/aiida/tools/dbimporters/plugins/oqmd.py:docstring of aiida.tools.dbimporters.plugins.oqmd.OqmdEntry:1
msgid "Bases: :py:class:`~aiida.tools.dbimporters.baseclasses.CifEntry`"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/cod.py:docstring of aiida.tools.dbimporters.plugins.cod.CodEntry:1
msgid "Represents an entry from COD."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/cod.py:docstring of aiida.tools.dbimporters.plugins.cod.CodEntry.__init__:1
msgid "Creates an instance of :py:class:`aiida.tools.dbimporters.plugins.cod.CodEntry`, related to the supplied URI."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/cod.py:docstring of aiida.tools.dbimporters.plugins.cod.CodSearchResults:1
#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.IcsdSearchResults:1
#: ../../../src/aiida/tools/dbimporters/plugins/materialsproject.py:docstring of aiida.tools.dbimporters.plugins.materialsproject.MaterialsProjectSearchResults:1
#: ../../../src/aiida/tools/dbimporters/plugins/mpds.py:docstring of aiida.tools.dbimporters.plugins.mpds.MpdsSearchResults:1
#: ../../../src/aiida/tools/dbimporters/plugins/mpod.py:docstring of aiida.tools.dbimporters.plugins.mpod.MpodSearchResults:1
#: ../../../src/aiida/tools/dbimporters/plugins/nninc.py:docstring of aiida.tools.dbimporters.plugins.nninc.NnincSearchResults:1
#: ../../../src/aiida/tools/dbimporters/plugins/oqmd.py:docstring of aiida.tools.dbimporters.plugins.oqmd.OqmdSearchResults:1
msgid "Bases: :py:class:`~aiida.tools.dbimporters.baseclasses.DbSearchResults`"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/cod.py:docstring of aiida.tools.dbimporters.plugins.cod.CodSearchResults:1
msgid "Results of the search, performed on COD."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd:1
msgid "Implementation of `DbImporter` for the ICSD database."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd:3
msgid "Note: The implementation in this file is not compatible with the recent versions of ICSD, which are built with Apache Lucene and Tomcat. Older ICSD versions are supported, which included a MySQL database and a php-based web interface. The last confirmed compatible version was released in 2020."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.CifFileErrorExp:1
#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.NoResultsWebExp:1
msgid "Bases: :py:class:`~aiida.tools.dbimporters.plugins.icsd.IcsdImporterExp`"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.CifFileErrorExp:1
msgid "Raised when the author loop is missing in a CIF file."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.IcsdDbImporter:1
msgid "Importer for the Inorganic Crystal Structure Database, short ICSD, provided by FIZ Karlsruhe. It allows to run queries and analyse all the results."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.IcsdDbImporter:4
msgid "Server URL, the web page of the database. It is required in order to have access to the full database. I t should contain both the protocol and the domain name and end with a slash, as in::    server = \"http://ICSDSERVER.com/\""
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.IcsdDbImporter:4
msgid "Server URL, the web page of the database. It is required in order to have access to the full database. I t should contain both the protocol and the domain name and end with a slash, as in::"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.IcsdDbImporter:11
msgid "part of URL which is added between query and and the server URL (default: ``index.php?``). only needed for web page query"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.IcsdDbImporter:13
msgid "boolean, decides whether the mysql database is queried (default: True). If False, the query results are obtained through the web page query, which is restricted to a maximum of 1000 results per query."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.IcsdDbImporter:18
msgid "icsd comes with a full (default: ``icsd``) and a demo database (``icsdd``). This parameter allows the user to switch to the demo database for testing purposes, if the access rights to the full database are not granted."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.IcsdDbImporter:23
msgid "MySQL database host. If the MySQL database is hosted on a different machine, use  \"127.0.0.1\" as host, and open a SSH tunnel to the host using::      ssh -L 3306:localhost:3306 username@hostname.com  or (if e.g. you get an URLError with Errno 111 (Connection refused) upon querying)::      ssh -L 3306:localhost:3306 -L 8010:localhost:80 username@hostname.com"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.IcsdDbImporter:23
msgid "MySQL database host. If the MySQL database is hosted on a different machine, use  \"127.0.0.1\" as host, and open a SSH tunnel to the host using::"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.IcsdDbImporter:29
msgid "or (if e.g. you get an URLError with Errno 111 (Connection refused) upon querying)::"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.IcsdDbImporter:34
msgid "mysql database username (default: dba)"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.IcsdDbImporter:35
msgid "mysql database password (default: sql)"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.IcsdDbImporter:36
msgid "name of the database (default: icsd)"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.IcsdDbImporter:37
msgid "Port to access the mysql database (default: 3306)"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.IcsdDbImporter._angle_clause:1
msgid "Return SQL query predicate for querying lattice angles."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.IcsdDbImporter._composition_clause:1
msgid "Return SQL query predicate for querying elements in formula fields."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.IcsdDbImporter._crystal_system_clause:1
msgid "Return SQL query predicate for querying crystal_system."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.IcsdDbImporter._density_clause:1
msgid "Return SQL query predicate for querying density."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.IcsdDbImporter._double_clause:1
msgid "Return SQL query predicate for querying double-valued fields."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.IcsdDbImporter._formula_clause:1
msgid "Return SQL query predicate for querying formula fields."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.IcsdDbImporter._int_clause:1
msgid "Return SQL query predicate for querying integer fields :param key: Database keyword :param alias: Query parameter name :param values: Corresponding values from query :return: SQL query predicate"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.IcsdDbImporter._length_clause:1
msgid "Return SQL query predicate for querying lattice vector lengths."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.IcsdDbImporter._parse_all:1
msgid "Convert numbers, strings, lists into strings. :param key: query parameter :param values: corresponding values :return retval: string"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.IcsdDbImporter._parse_mineral:1
msgid "Convert mineral_name and chemical_name into right format. :param key: query parameter :param values: corresponding values :return retval: string"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.IcsdDbImporter._parse_number:1
msgid "Convert int into string. :param key: query parameter :param values: corresponding values :return retval: string"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.IcsdDbImporter._parse_system:1
msgid "Return crystal system in the right format. :param key: query parameter :param values: corresponding values :return retval: string"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.IcsdDbImporter._parse_volume:1
msgid "Convert volume, cell parameter and angle queries into right format. :param key: query parameter :param values: corresponding values :return retval: string"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.IcsdDbImporter._pressure_clause:1
msgid "Return SQL query predicate for querying pressure."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.IcsdDbImporter._query_sql_db:1
msgid "Perform a query on Icsd mysql database using ``keyword = value`` pairs, specified in ``kwargs``. Returns an instance of IcsdSearchResults. :param kwargs: A list of ``keyword = [values]`` pairs :return: IcsdSearchResults"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.IcsdDbImporter._queryweb:1
msgid "Perform a query on the Icsd web database using ``keyword = value`` pairs, specified in ``kwargs``. Returns an instance of IcsdSearchResults. :note: Web search has a maximum result number fixed at 1000. :param kwargs: A list of ``keyword = [values]`` pairs :return: IcsdSearchResults"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.IcsdDbImporter._str_exact_clause:1
msgid "Return SQL query predicate for querying string fields."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.IcsdDbImporter._str_fuzzy_clause:1
msgid "Return SQL query predicate for fuzzy querying of string fields."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.IcsdDbImporter._temperature_clause:1
msgid "Return SQL query predicate for querying temperature."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.IcsdDbImporter._volume_clause:1
msgid "Return SQL query predicate for querying unit cell volume."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.IcsdDbImporter.get_supported_keywords:1
msgid "List of all supported query keywords."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.IcsdDbImporter.query:1
msgid "Depending on the db_parameters, the mysql database or the web page are queried. Valid parameters are found using IcsdDbImporter.get_supported_keywords()."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.IcsdDbImporter.query:4
msgid "A list of ''keyword = [values]'' pairs."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.IcsdDbImporter.setup_db:1
msgid "Change the database connection details. At least the host server has to be defined."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.IcsdDbImporter.setup_db:4
msgid "db_parameters for the mysql database connection (host, user, passwd, db, port)"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.IcsdEntry:1
msgid "Represent an entry from Icsd."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.IcsdEntry:4
msgid "Before July 2nd 2015, source['id'] contained icsd.IDNUM (internal icsd id number) and source['extras']['cif_nr'] the cif number (icsd.COLL_CODE)."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.IcsdEntry:7
msgid "After July 2nd 2015, source['id'] has been replaced by the cif number and source['extras']['idnum'] is icsd.IDNUM ."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.IcsdEntry.__init__:1
msgid "Create an instance of IcsdEntry, related to the supplied URI."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.IcsdEntry.contents:1
msgid "Returns raw contents of a file as string. This overrides the DbEntry implementation because the ICSD php backend returns the contents of the CIF in ISO-8859-1 encoding. However, the PyCifRW library (and most other sensible applications), expects UTF-8. Therefore, we decode the original CIF data to unicode and encode it in the UTF-8 format"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.IcsdEntry.get_ase_structure:1
msgid "ASE structure corresponding to the cif file."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.IcsdImporterExp:1
msgid "Base class for ICSD exceptions."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.IcsdSearchResults:1
msgid "Result manager for the query performed on ICSD."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.IcsdSearchResults:3
msgid "mysql query or webpage query"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.IcsdSearchResults:4
msgid "database parameter setup during the initialisation of the IcsdDbImporter."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.IcsdSearchResults._connect_db:1
msgid "Connect to the MySQL database for performing searches."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.IcsdSearchResults._disconnect_db:1
msgid "Close connection to the MySQL database."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.IcsdSearchResults.at:1
msgid "Return ``position``-th result as IcsdEntry."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.IcsdSearchResults.next:1
msgid "Return next result as IcsdEntry."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.IcsdSearchResults.query_db_version:1
msgid "Query the version of the icsd database (last row of RELEASE_TAGS)."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.IcsdSearchResults.query_page:1
msgid "Query the mysql or web page database, depending on the db_parameters. Store the number_of_results, cif file number and the corresponding icsd number."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.IcsdSearchResults.query_page:4
msgid "Additionally, for the mysql case, determine if the origin of the structure is theoretical. This information is stored in the `icsd_remarks` mysql table. If the crystal has either \"THE\" or \"ZTHE\" tags, then it's classified as theoretical."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.IcsdSearchResults.query_page:8
msgid "Icsd uses its own number system, different from the CIF file numbers."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.IcsdSearchResults.results:1
msgid "Return the list of results"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.NoResultsWebExp:1
msgid "Raised when a webpage query returns no results."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.correct_cif:1
msgid "Correct the format of the CIF files. At the moment, it only fixes missing quotes in the authors field (``ase.read.io`` only works if the author names are quoted, if not an AssertionError is raised)."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.correct_cif:6
msgid "A string containing the content of the CIF file."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/icsd.py:docstring of aiida.tools.dbimporters.plugins.icsd.correct_cif:7
msgid "a string containing the corrected CIF file."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/materialsproject.py:docstring of aiida.tools.dbimporters.plugins.materialsproject:1
msgid "\"Implementation of `DbImporter` for the Materials Project database."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/materialsproject.py:docstring of aiida.tools.dbimporters.plugins.materialsproject.MaterialsProjectCifEntry:1
msgid "A Materials Project entry class which extends the DbEntry class with a CifEntry class."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/materialsproject.py:docstring of aiida.tools.dbimporters.plugins.materialsproject.MaterialsProjectCifEntry.__init__:1
#: ../../../src/aiida/tools/dbimporters/plugins/mpds.py:docstring of aiida.tools.dbimporters.plugins.mpds.MpdsCifEntry.__init__:1
msgid "The DbSearchResults base class instantiates a new DbEntry by explicitly passing the url of the entry as an argument. In this case it is the same as the 'uri' value that is already contained in the source dictionary so we just copy it"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/materialsproject.py:docstring of aiida.tools.dbimporters.plugins.materialsproject.MaterialsProjectImporter:1
msgid "Database importer for the Materials Project."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/materialsproject.py:docstring of aiida.tools.dbimporters.plugins.materialsproject.MaterialsProjectImporter.__init__:1
msgid "Instantiate the MaterialsProjectImporter by setting up the Materials API (MAPI) connection details."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/materialsproject.py:docstring of aiida.tools.dbimporters.plugins.materialsproject.MaterialsProjectImporter._find:1
#: ../../../src/aiida/tools/dbimporters/plugins/mpds.py:docstring of aiida.tools.dbimporters.plugins.mpds.MpdsDbImporter.find:1
msgid "Query the database with a given dictionary of query parameters"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/materialsproject.py:docstring of aiida.tools.dbimporters.plugins.materialsproject.MaterialsProjectImporter._find:3
#: ../../../src/aiida/tools/dbimporters/plugins/materialsproject.py:docstring of aiida.tools.dbimporters.plugins.materialsproject.MaterialsProjectImporter.query:3
#: ../../../src/aiida/tools/dbimporters/plugins/mpds.py:docstring of aiida.tools.dbimporters.plugins.mpds.MpdsDbImporter.find:3
#: ../../../src/aiida/tools/dbimporters/plugins/mpds.py:docstring of aiida.tools.dbimporters.plugins.mpds.MpdsDbImporter.query:3
#: ../../../src/aiida/tools/dbimporters/plugins/mpds.py:docstring of aiida.tools.dbimporters.plugins.mpds.StructuresCollection.find:3
msgid "a dictionary with the query parameters"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/materialsproject.py:docstring of aiida.tools.dbimporters.plugins.materialsproject.MaterialsProjectImporter._verify_api_key:1
msgid "Verify the supplied API key by issuing a request to Materials Project."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/materialsproject.py:docstring of aiida.tools.dbimporters.plugins.materialsproject.MaterialsProjectImporter.api_key:1
#: ../../../src/aiida/tools/dbimporters/plugins/mpds.py:docstring of aiida.tools.dbimporters.plugins.mpds.MpdsDbImporter.api_key:1
msgid "Return the API key configured for the importer"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/materialsproject.py:docstring of aiida.tools.dbimporters.plugins.materialsproject.MaterialsProjectImporter.get_supported_keywords:1
#: ../../../src/aiida/tools/dbimporters/plugins/mpds.py:docstring of aiida.tools.dbimporters.plugins.mpds.MpdsDbImporter.get_supported_keywords:1
msgid "Returns the list of all supported query keywords"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/materialsproject.py:docstring of aiida.tools.dbimporters.plugins.materialsproject.MaterialsProjectImporter.properties:1
msgid "Return the properties that will be queried"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/materialsproject.py:docstring of aiida.tools.dbimporters.plugins.materialsproject.MaterialsProjectImporter.query:1
msgid "Query the database with a given dictionary of query parameters for a given properties"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/materialsproject.py:docstring of aiida.tools.dbimporters.plugins.materialsproject.MaterialsProjectImporter.query:4
msgid "the properties to query"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/materialsproject.py:docstring of aiida.tools.dbimporters.plugins.materialsproject.MaterialsProjectImporter.setup_db:1
msgid "Setup the required parameters to the REST API"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/materialsproject.py:docstring of aiida.tools.dbimporters.plugins.materialsproject.MaterialsProjectSearchResults:1
msgid "A collection of MaterialsProjectEntry query result entries."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/materialsproject.py:docstring of aiida.tools.dbimporters.plugins.materialsproject.MaterialsProjectSearchResults:3
#: ../../../src/aiida/tools/dbimporters/plugins/materialsproject.py:docstring of aiida.tools.dbimporters.plugins.materialsproject.MaterialsProjectSearchResults._get_source_dict:3
#: ../../../src/aiida/tools/dbimporters/plugins/materialsproject.py:docstring of aiida.tools.dbimporters.plugins.materialsproject.MaterialsProjectSearchResults._get_url:3
#: ../../../src/aiida/tools/dbimporters/plugins/mpds.py:docstring of aiida.tools.dbimporters.plugins.mpds.MpdsSearchResults._get_source_dict:3
#: ../../../src/aiida/tools/dbimporters/plugins/mpds.py:docstring of aiida.tools.dbimporters.plugins.mpds.MpdsSearchResults._get_url:3
msgid "query result entry dictionary"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/materialsproject.py:docstring of aiida.tools.dbimporters.plugins.materialsproject.MaterialsProjectSearchResults:0
msgid "return_class"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/materialsproject.py:docstring of aiida.tools.dbimporters.plugins.materialsproject.MaterialsProjectSearchResults:4
msgid "the class associated with each"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/materialsproject.py:docstring of aiida.tools.dbimporters.plugins.materialsproject.MaterialsProjectSearchResults._get_source_dict:1
msgid "Return the source information dictionary of an Materials Project query result entry"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/materialsproject.py:docstring of aiida.tools.dbimporters.plugins.materialsproject.MaterialsProjectSearchResults._get_url:1
#: ../../../src/aiida/tools/dbimporters/plugins/mpds.py:docstring of aiida.tools.dbimporters.plugins.mpds.MpdsSearchResults._get_url:1
msgid "Return the permanent URI of the result entry"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/mpds.py:docstring of aiida.tools.dbimporters.plugins.mpds:1
msgid "\"Implementation of `DbImporter` for the MPDS database."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/mpds.py:docstring of aiida.tools.dbimporters.plugins.mpds.MpdsCifEntry:1
msgid "Bases: :py:class:`~aiida.tools.dbimporters.baseclasses.CifEntry`, :py:class:`~aiida.tools.dbimporters.plugins.mpds.MpdsEntry`"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/mpds.py:docstring of aiida.tools.dbimporters.plugins.mpds.MpdsCifEntry:1
msgid "An extension of the MpdsEntry class with the CifEntry class, which will treat the contents property through the URI as a cif file"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/mpds.py:docstring of aiida.tools.dbimporters.plugins.mpds.MpdsDbImporter:1
msgid "Database importer for the Materials Platform for Data Science (MPDS)"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/mpds.py:docstring of aiida.tools.dbimporters.plugins.mpds.MpdsDbImporter.__init__:1
msgid "Instantiate the MpdsDbImporter by setting up the API connection details"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/mpds.py:docstring of aiida.tools.dbimporters.plugins.mpds.MpdsDbImporter.__init__:3
#: ../../../src/aiida/tools/dbimporters/plugins/mpds.py:docstring of aiida.tools.dbimporters.plugins.mpds.MpdsDbImporter.setup_db:3
msgid "the full base url of the REST API endpoint"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/mpds.py:docstring of aiida.tools.dbimporters.plugins.mpds.MpdsDbImporter.__init__:4
#: ../../../src/aiida/tools/dbimporters/plugins/mpds.py:docstring of aiida.tools.dbimporters.plugins.mpds.MpdsDbImporter.setup_db:4
msgid "the API key to be used for HTTP requests"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/mpds.py:docstring of aiida.tools.dbimporters.plugins.mpds.MpdsDbImporter.collection:1
msgid "Return the collection that will be queried"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/mpds.py:docstring of aiida.tools.dbimporters.plugins.mpds.MpdsDbImporter.get:1
msgid "Perform a GET request to the REST API using the kwargs as request parameters The url and API key will be used that were set upon construction"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/mpds.py:docstring of aiida.tools.dbimporters.plugins.mpds.MpdsDbImporter.get:4
msgid "the format of the response, 'cif' or json' (default)"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/mpds.py:docstring of aiida.tools.dbimporters.plugins.mpds.MpdsDbImporter.get:5
msgid "parameters for the GET request"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/mpds.py:docstring of aiida.tools.dbimporters.plugins.mpds.MpdsDbImporter.get_id_from_cif:1
msgid "Extract the entry id from the string formatted cif response of the MPDS API"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/mpds.py:docstring of aiida.tools.dbimporters.plugins.mpds.MpdsDbImporter.get_id_from_cif:3
msgid "string representation of the cif file"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/mpds.py:docstring of aiida.tools.dbimporters.plugins.mpds.MpdsDbImporter.get_id_from_cif:4
msgid "entry id of the cif file or None if could not be found"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/mpds.py:docstring of aiida.tools.dbimporters.plugins.mpds.MpdsDbImporter.get_response_content:1
msgid "Analyze the response of an HTTP GET request, verify that the response code is OK and return the json loaded response text"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/mpds.py:docstring of aiida.tools.dbimporters.plugins.mpds.MpdsDbImporter.get_response_content:4
msgid "HTTP response"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/mpds.py:docstring of aiida.tools.dbimporters.plugins.mpds.MpdsDbImporter.get_response_content:5
msgid "HTTP response is not 200"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/mpds.py:docstring of aiida.tools.dbimporters.plugins.mpds.MpdsDbImporter.get_response_content:6
msgid "HTTP response 200 contained non zero error message"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/mpds.py:docstring of aiida.tools.dbimporters.plugins.mpds.MpdsDbImporter.pagesize:1
msgid "Return the pagesize set for the importer"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/mpds.py:docstring of aiida.tools.dbimporters.plugins.mpds.MpdsDbImporter.query:1
msgid "Query the database with a given dictionary of query parameters for a given collection"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/mpds.py:docstring of aiida.tools.dbimporters.plugins.mpds.MpdsDbImporter.query:4
msgid "the collection to query"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/mpds.py:docstring of aiida.tools.dbimporters.plugins.mpds.MpdsDbImporter.setup_db:1
msgid "Setup the required parameters for HTTP requests to the REST API"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/mpds.py:docstring of aiida.tools.dbimporters.plugins.mpds.MpdsDbImporter.structures:1
msgid "Access the structures collection in the MPDS"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/mpds.py:docstring of aiida.tools.dbimporters.plugins.mpds.MpdsDbImporter.url:1
msgid "Return the base url configured for the importer"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/mpds.py:docstring of aiida.tools.dbimporters.plugins.mpds.MpdsEntry:1
msgid "Represents an MPDS database entry"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/mpds.py:docstring of aiida.tools.dbimporters.plugins.mpds.MpdsEntry.__init__:1
msgid "Set the class license from the source dictionary"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/mpds.py:docstring of aiida.tools.dbimporters.plugins.mpds.MpdsSearchResults:1
msgid "Collection of MpdsEntry query result entries."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/mpds.py:docstring of aiida.tools.dbimporters.plugins.mpds.MpdsSearchResults._get_source_dict:1
msgid "Return the source information dictionary of an MPDS query result entry"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/mpds.py:docstring of aiida.tools.dbimporters.plugins.mpds.StructuresCollection:1
msgid "Collection of structures."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/mpds.py:docstring of aiida.tools.dbimporters.plugins.mpds.StructuresCollection.engine:1
msgid "Return the query engine"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/mpds.py:docstring of aiida.tools.dbimporters.plugins.mpds.StructuresCollection.find:1
msgid "Query the structures collection with a given dictionary of query parameters"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/mpod.py:docstring of aiida.tools.dbimporters.plugins.mpod:1
msgid "\"Implementation of `DbImporter` for the MPOD database."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/mpod.py:docstring of aiida.tools.dbimporters.plugins.mpod.MpodDbImporter:1
msgid "Database importer for Material Properties Open Database."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/mpod.py:docstring of aiida.tools.dbimporters.plugins.mpod.MpodDbImporter._str_clause:1
#: ../../../src/aiida/tools/dbimporters/plugins/nninc.py:docstring of aiida.tools.dbimporters.plugins.nninc.NnincDbImporter._str_clause:1
#: ../../../src/aiida/tools/dbimporters/plugins/oqmd.py:docstring of aiida.tools.dbimporters.plugins.oqmd.OqmdDbImporter._str_clause:1
msgid "Returns part of HTTP GET query for querying string fields."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/mpod.py:docstring of aiida.tools.dbimporters.plugins.mpod.MpodDbImporter.query:1
msgid "Performs a query on the MPOD database using ``keyword = value`` pairs, specified in ``kwargs``."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/mpod.py:docstring of aiida.tools.dbimporters.plugins.mpod.MpodDbImporter.query:4
msgid "an instance of :py:class:`aiida.tools.dbimporters.plugins.mpod.MpodSearchResults`."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/mpod.py:docstring of aiida.tools.dbimporters.plugins.mpod.MpodDbImporter.query_get:1
msgid "Forms a HTTP GET query for querying the MPOD database. May return more than one query in case an intersection is needed."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/mpod.py:docstring of aiida.tools.dbimporters.plugins.mpod.MpodDbImporter.query_get:4
msgid "a list containing strings for HTTP GET statement."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/mpod.py:docstring of aiida.tools.dbimporters.plugins.mpod.MpodEntry:1
msgid "Represents an entry from MPOD."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/mpod.py:docstring of aiida.tools.dbimporters.plugins.mpod.MpodEntry.__init__:1
msgid "Creates an instance of :py:class:`aiida.tools.dbimporters.plugins.mpod.MpodEntry`, related to the supplied URI."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/mpod.py:docstring of aiida.tools.dbimporters.plugins.mpod.MpodSearchResults:1
msgid "Results of the search, performed on MPOD."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/nninc.py:docstring of aiida.tools.dbimporters.plugins.nninc:1
msgid "\"Implementation of `DbImporter` for the NNIN/C database."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/nninc.py:docstring of aiida.tools.dbimporters.plugins.nninc.NnincDbImporter:1
msgid "Database importer for NNIN/C Pseudopotential Virtual Vault."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/nninc.py:docstring of aiida.tools.dbimporters.plugins.nninc.NnincDbImporter.query:1
msgid "Performs a query on the NNIN/C Pseudopotential Virtual Vault using ``keyword = value`` pairs, specified in ``kwargs``."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/nninc.py:docstring of aiida.tools.dbimporters.plugins.nninc.NnincDbImporter.query:4
msgid "an instance of :py:class:`aiida.tools.dbimporters.plugins.nninc.NnincSearchResults`."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/nninc.py:docstring of aiida.tools.dbimporters.plugins.nninc.NnincDbImporter.query_get:1
msgid "Forms a HTTP GET query for querying the NNIN/C Pseudopotential Virtual Vault."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/nninc.py:docstring of aiida.tools.dbimporters.plugins.nninc.NnincDbImporter.query_get:4
msgid "a string with HTTP GET statement."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/nninc.py:docstring of aiida.tools.dbimporters.plugins.nninc.NnincEntry:1
msgid "Bases: :py:class:`~aiida.tools.dbimporters.baseclasses.UpfEntry`"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/nninc.py:docstring of aiida.tools.dbimporters.plugins.nninc.NnincEntry:1
msgid "Represents an entry from NNIN/C Pseudopotential Virtual Vault."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/nninc.py:docstring of aiida.tools.dbimporters.plugins.nninc.NnincEntry.__init__:1
msgid "Creates an instance of :py:class:`aiida.tools.dbimporters.plugins.nninc.NnincEntry`, related to the supplied URI."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/nninc.py:docstring of aiida.tools.dbimporters.plugins.nninc.NnincSearchResults:1
msgid "Results of the search, performed on NNIN/C Pseudopotential Virtual Vault."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/oqmd.py:docstring of aiida.tools.dbimporters.plugins.oqmd:1
msgid "\"Implementation of `DbImporter` for the OQMD database."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/oqmd.py:docstring of aiida.tools.dbimporters.plugins.oqmd.OqmdDbImporter:1
msgid "Database importer for Open Quantum Materials Database."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/oqmd.py:docstring of aiida.tools.dbimporters.plugins.oqmd.OqmdDbImporter.query:1
msgid "Performs a query on the OQMD database using ``keyword = value`` pairs, specified in ``kwargs``."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/oqmd.py:docstring of aiida.tools.dbimporters.plugins.oqmd.OqmdDbImporter.query:4
msgid "an instance of :py:class:`aiida.tools.dbimporters.plugins.oqmd.OqmdSearchResults`."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/oqmd.py:docstring of aiida.tools.dbimporters.plugins.oqmd.OqmdDbImporter.query_get:1
msgid "Forms a HTTP GET query for querying the OQMD database."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/oqmd.py:docstring of aiida.tools.dbimporters.plugins.oqmd.OqmdDbImporter.query_get:3
msgid "a strings for HTTP GET statement."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/oqmd.py:docstring of aiida.tools.dbimporters.plugins.oqmd.OqmdEntry:1
msgid "Represents an entry from OQMD."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/oqmd.py:docstring of aiida.tools.dbimporters.plugins.oqmd.OqmdEntry.__init__:1
msgid "Creates an instance of :py:class:`aiida.tools.dbimporters.plugins.oqmd.OqmdEntry`, related to the supplied URI."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/oqmd.py:docstring of aiida.tools.dbimporters.plugins.oqmd.OqmdSearchResults:1
msgid "Results of the search, performed on OQMD."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/pcod.py:docstring of aiida.tools.dbimporters.plugins.pcod:1
msgid "\"Implementation of `DbImporter` for the PCOD database."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/pcod.py:docstring of aiida.tools.dbimporters.plugins.pcod.PcodDbImporter:1
#: ../../../src/aiida/tools/dbimporters/plugins/tcod.py:docstring of aiida.tools.dbimporters.plugins.tcod.TcodDbImporter:1
msgid "Bases: :py:class:`~aiida.tools.dbimporters.plugins.cod.CodDbImporter`"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/pcod.py:docstring of aiida.tools.dbimporters.plugins.pcod.PcodDbImporter:1
msgid "Database importer for Predicted Crystallography Open Database."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/pcod.py:docstring of aiida.tools.dbimporters.plugins.pcod.PcodDbImporter.query:1
msgid "Performs a query on the PCOD database using ``keyword = value`` pairs, specified in ``kwargs``."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/pcod.py:docstring of aiida.tools.dbimporters.plugins.pcod.PcodDbImporter.query:4
msgid "an instance of :py:class:`aiida.tools.dbimporters.plugins.pcod.PcodSearchResults`."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/pcod.py:docstring of aiida.tools.dbimporters.plugins.pcod.PcodDbImporter.query_sql:1
msgid "Forms a SQL query for querying the PCOD database using ``keyword = value`` pairs, specified in ``kwargs``."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/pcod.py:docstring of aiida.tools.dbimporters.plugins.pcod.PcodEntry:1
#: ../../../src/aiida/tools/dbimporters/plugins/tcod.py:docstring of aiida.tools.dbimporters.plugins.tcod.TcodEntry:1
msgid "Bases: :py:class:`~aiida.tools.dbimporters.plugins.cod.CodEntry`"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/pcod.py:docstring of aiida.tools.dbimporters.plugins.pcod.PcodEntry:1
msgid "Represents an entry from PCOD."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/pcod.py:docstring of aiida.tools.dbimporters.plugins.pcod.PcodEntry.__init__:1
msgid "Creates an instance of :py:class:`aiida.tools.dbimporters.plugins.pcod.PcodEntry`, related to the supplied URI."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/pcod.py:docstring of aiida.tools.dbimporters.plugins.pcod.PcodSearchResults:1
#: ../../../src/aiida/tools/dbimporters/plugins/tcod.py:docstring of aiida.tools.dbimporters.plugins.tcod.TcodSearchResults:1
msgid "Bases: :py:class:`~aiida.tools.dbimporters.plugins.cod.CodSearchResults`"
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/pcod.py:docstring of aiida.tools.dbimporters.plugins.pcod.PcodSearchResults:1
msgid "Results of the search, performed on PCOD."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/tcod.py:docstring of aiida.tools.dbimporters.plugins.tcod:1
msgid "\"Implementation of `DbImporter` for the TCOD database."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/tcod.py:docstring of aiida.tools.dbimporters.plugins.tcod.TcodDbImporter:1
msgid "Database importer for Theoretical Crystallography Open Database."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/tcod.py:docstring of aiida.tools.dbimporters.plugins.tcod.TcodDbImporter.query:1
msgid "Performs a query on the TCOD database using ``keyword = value`` pairs, specified in ``kwargs``."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/tcod.py:docstring of aiida.tools.dbimporters.plugins.tcod.TcodDbImporter.query:4
msgid "an instance of :py:class:`aiida.tools.dbimporters.plugins.tcod.TcodSearchResults`."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/tcod.py:docstring of aiida.tools.dbimporters.plugins.tcod.TcodEntry:1
msgid "Represents an entry from TCOD."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/tcod.py:docstring of aiida.tools.dbimporters.plugins.tcod.TcodEntry.__init__:1
msgid "Creates an instance of :py:class:`aiida.tools.dbimporters.plugins.tcod.TcodEntry`, related to the supplied URI."
msgstr ""

#: ../../../src/aiida/tools/dbimporters/plugins/tcod.py:docstring of aiida.tools.dbimporters.plugins.tcod.TcodSearchResults:1
msgid "Results of the search, performed on TCOD."
msgstr ""

#: ../../source/reference/apidoc/aiida.tools.graph.rst:2
msgid "aiida.tools.graph package"
msgstr ""

#: ../../../src/aiida/tools/graph/__init__.py:docstring of aiida.tools.graph:1
msgid "Provides tools for traversing the provenance graph."
msgstr ""

#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities:1
msgid "Entities for the AiiDA Graph Explorer utility"
msgstr ""

#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.AbstractSetContainer:1
msgid "Abstract Class"
msgstr ""

#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.AbstractSetContainer:3
msgid "This class defines a set that can be speciaized to contain either nodes (either AiiDA nodes or Aiida groups) or edges (AiiDA links, or records of the connections between groups and nodes). Instances of this class reference a subset of entities in a database via a unique identifier. There are also a few operators defined, for simplicity, to do set-additions (unions) and deletions. The underlying Python-class is **set**, which means that adding an instance to an AiidaEntitySet that is already contained by it will not create a duplicate."
msgstr ""

#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.AbstractSetContainer.__add__:1
msgid "Addition (return = self + other): defined as the set union"
msgstr ""

#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.AbstractSetContainer.__iadd__:1
msgid "Addition inplace (self += other)"
msgstr ""

#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.AbstractSetContainer.__init__:1
#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.AiidaEntitySet.__init__:1
#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.Basket.__init__:1
#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.DirectedEdgeSet.__init__:1
#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.Operation.__init__:1
#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.QueryRule.__init__:1
#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.ReplaceRule.__init__:1
#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.RuleSaveWalkers.__init__:1
#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.RuleSequence.__init__:1
#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.RuleSetWalkers.__init__:1
msgid "Initialization method"
msgstr ""

#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.AbstractSetContainer.__isub__:1
msgid "Subtraction inplace (self -= other)"
msgstr ""

#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.AbstractSetContainer.__ne__:1
#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.Basket.__ne__:1
msgid "Return self!=value."
msgstr ""

#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.AbstractSetContainer.__sub__:1
msgid "Subtraction (return = self - other): defined as the set-difference"
msgstr ""

#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.AbstractSetContainer._check_input_for_set:1
#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.AbstractSetContainer._check_self_and_other:1
#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.AiidaEntitySet._check_input_for_set:1
#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.AiidaEntitySet._check_self_and_other:1
#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.DirectedEdgeSet._check_input_for_set:1
#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.DirectedEdgeSet._check_self_and_other:1
msgid "Utility function"
msgstr ""

#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.AbstractSetContainer._check_input_for_set:3
#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.AiidaEntitySet._check_input_for_set:3
#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.DirectedEdgeSet._check_input_for_set:3
msgid "When provinding input keys for the internal set, this utility function will check and process the input accordingly."
msgstr ""

#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.AbstractSetContainer._check_input_for_set:6
#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.AiidaEntitySet._check_input_for_set:6
#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.DirectedEdgeSet._check_input_for_set:6
msgid "input argument for the keyset (must be either an AiiDA instance of node or group, or an identifier of the type used by the container)."
msgstr ""

#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.AbstractSetContainer._check_self_and_other:3
#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.AiidaEntitySet._check_self_and_other:3
#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.DirectedEdgeSet._check_self_and_other:3
msgid "When called, will check whether self and other instance are compatible. (i.e. if they contain the same AiiDA class, same identifiers, length of tuples, etc)"
msgstr ""

#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.AbstractSetContainer._check_self_and_other:8
#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.AiidaEntitySet._check_self_and_other:8
#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.DirectedEdgeSet._check_self_and_other:8
msgid "the other entity to check for compatibility."
msgstr ""

#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.AbstractSetContainer.add_entities:1
msgid "Add new entitities to the existing set of self."
msgstr ""

#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.AbstractSetContainer.add_entities:3
msgid "an iterable of new entities to add."
msgstr ""

#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.AbstractSetContainer.additional_identifiers:1
msgid "Additional identifiers for the entities"
msgstr ""

#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.AbstractSetContainer.copy:1
msgid "Create new instance with the same defining attributes and the same keyset."
msgstr ""

#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.AbstractSetContainer.empty:1
msgid "Resets the contained set to be an empty set"
msgstr ""

#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.AbstractSetContainer.get_template:1
#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.AiidaEntitySet.get_template:1
#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.DirectedEdgeSet.get_template:1
msgid "Create new instance with the same defining attributes."
msgstr ""

#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.AbstractSetContainer.keyset:1
msgid "Set containing the keys of the entities"
msgstr ""

#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.AbstractSetContainer.set_entities:1
msgid "Replaces contained set with the new entities."
msgstr ""

#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.AbstractSetContainer.set_entities:3
msgid "entities which will replace the ones contained by the EntitySet. Must be an AiiDA instance (Node or Group) or an appropriate identifier (ID)."
msgstr ""

#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.AiidaEntitySet:1
#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.DirectedEdgeSet:1
msgid "Bases: :py:class:`~aiida.tools.graph.age_entities.AbstractSetContainer`"
msgstr ""

#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.AiidaEntitySet:1
#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.DirectedEdgeSet:1
msgid "Extension of AbstractSetContainer"
msgstr ""

#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.AiidaEntitySet:3
msgid "This class is used to store `graph nodes` (aidda nodes or aiida groups)."
msgstr ""

#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.AiidaEntitySet.__init__:3
#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.DirectedEdgeSet.__init__:5
msgid "a valid AiiDA ORM class (Node or Group supported)."
msgstr ""

#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.AiidaEntitySet.aiida_cls:1
msgid "Class of nodes contained in the entity set (node or group)"
msgstr ""

#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.AiidaEntitySet.identifier:1
msgid "Identifier used for the nodes or groups (currently always id)"
msgstr ""

#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.AiidaEntitySet.identifier_type:1
msgid "Type of identifier for the node or group (for id is int)"
msgstr ""

#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.Basket:1
msgid "Container for several instances of :py:class:`aiida.tools.graph.age_entities.AiidaEntitySet` ."
msgstr ""

#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.Basket:4
msgid "In the current implementation, it contains one EntitySet for Nodes and one for Groups, and one EdgeSet for Node-Node edges (links) and one for Group-Node connections."
msgstr ""

#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.Basket.__init__:3
msgid "During initialization of the basket, both the sets of nodes and the set of groups can be provided as one of the following: an AiidaEntitySet with the respective type (node or group) or a list/set/tuple with the ids of the respective node or group."
msgstr ""

#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.Basket.__init__:8
msgid "AiiDA nodes provided in an acceptable way."
msgstr ""

#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.Basket.__init__:9
msgid "AiiDA groups provided in an acceptable way."
msgstr ""

#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.Basket.__repr__:1
msgid "Return string representation."
msgstr ""

#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.Basket.copy:1
msgid "Create new instance with the same defining attributes and content."
msgstr ""

#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.Basket.dict:1
msgid "All sets in the basket returned as a dictionary. This includes the keys 'nodes', 'groups', 'nodes_nodes' and 'nodes_groups'."
msgstr ""

#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.Basket.empty:1
msgid "Empty every subset from its content"
msgstr ""

#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.Basket.get_template:1
msgid "Create new nasket with the same defining attributes for its internal containers."
msgstr ""

#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.Basket.groups:1
msgid "Set of groups stored in the basket"
msgstr ""

#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.Basket.nodes:1
msgid "Set of nodes stored in the basket"
msgstr ""

#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.Basket.sets:1
msgid "All sets in the basket returned as an ordered list. The order is: 'groups', 'groups_nodes', 'nodes', 'nodes_nodes'."
msgstr ""

#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.DirectedEdgeSet:3
msgid "This class is used to store `graph edges` (aidda nodes or aiida groups)."
msgstr ""

#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.DirectedEdgeSet.__init__:3
msgid "The classes that the link connects must be provided."
msgstr ""

#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.DirectedEdgeSet.__init__:6
msgid "a valid AiiDA ORM class (Node supported)."
msgstr ""

#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.DirectedEdgeSet.aiida_cls_from:1
msgid "The class of nodes which the edge points from"
msgstr ""

#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.DirectedEdgeSet.aiida_cls_to:1
msgid "The class of nodes which the edge points to"
msgstr ""

#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.DirectedEdgeSet.edge_identifiers:1
msgid "The identifiers for the edges"
msgstr ""

#: ../../../src/aiida/tools/graph/age_entities.py:docstring of aiida.tools.graph.age_entities.DirectedEdgeSet.edge_namedtuple:1
msgid "The namedtuple type used for the edges` identifiers"
msgstr ""

#: ../../../src/aiida/tools/graph/age_entities.py:docstring of namedtuple_GroupNodeEdge.GroupNodeEdge.__new__:1
msgid "Create new instance of GroupNodeEdge(node_id, group_id)"
msgstr ""

#: ../../../src/aiida/tools/graph/age_entities.py:docstring of collections.GroupNodeEdge._make:1
msgid "Make a new GroupNodeEdge object from a sequence or iterable"
msgstr ""

#: ../../../src/aiida/tools/graph/age_entities.py:docstring of collections.GroupNodeEdge._replace:1
msgid "Return a new GroupNodeEdge object replacing specified fields with new values"
msgstr ""

#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules:1
msgid "Rules for the AiiDA Graph Explorer utility"
msgstr ""

#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.Operation:1
msgid "Base class for all AGE explorer classes"
msgstr ""

#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.Operation.__init__:3
#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.RuleSequence.__init__:3
msgid "maximum number of iterations to perform."
msgstr ""

#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.Operation.__init__:4
#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.RuleSequence.__init__:4
msgid "if True, will also track and return the edges traversed."
msgstr ""

#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.Operation.iterations_done:1
msgid "Number of iterations performed"
msgstr ""

#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.Operation.run:1
#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.QueryRule.run:1
#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.ReplaceRule.run:1
#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.RuleSaveWalkers.run:1
#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.RuleSequence.run:1
#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.RuleSetWalkers.run:1
#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.UpdateRule.run:1
msgid "Takes the operational_set and overwrites it with the set of nodes that results from applying the rule (this might or not include the initial set of nodes as well depending on the rule)."
msgstr ""

#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.Operation.run:6
#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.QueryRule.run:6
#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.ReplaceRule.run:6
#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.RuleSaveWalkers.run:6
#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.RuleSequence.run:6
#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.RuleSetWalkers.run:6
#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.UpdateRule.run:6
msgid "initital set of nodes to be overwritten by the rule."
msgstr ""

#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.Operation.set_max_iterations:1
msgid "Sets the max iterations"
msgstr ""

#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.QueryRule:1
#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.RuleSaveWalkers:1
#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.RuleSequence:1
#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.RuleSetWalkers:1
msgid "Bases: :py:class:`~aiida.tools.graph.age_rules.Operation`"
msgstr ""

#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.QueryRule:1
msgid "Parent class for every rule that implements a query."
msgstr ""

#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.QueryRule:3
msgid "QueryRules take a generic QueryBuilder instance and a set of starting nodes and then perform successive iterations of that query, each one from the set of nodes that the previous one found. Depending on the class of rule used the final result will be either the whole set of nodes traversed (UpdateRule), or only the final set of nodes found in the last iteration of the query (ReplaceRule)."
msgstr ""

#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.QueryRule.__init__:3
#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.ReplaceRule.__init__:3
msgid "an instance of the QueryBuilder class from which to take the procedure for traversal"
msgstr ""

#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.QueryRule.__init__:5
#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.ReplaceRule.__init__:5
msgid "the number of iterations to run this query on (must be a finite number for ReplaceRules)"
msgstr ""

#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.QueryRule.__init__:7
#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.ReplaceRule.__init__:7
msgid "whether to track which edges are traversed and store them"
msgstr ""

#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.QueryRule._init_run:1
msgid "Initialization Utility method"
msgstr ""

#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.QueryRule._init_run:3
msgid "This method initializes a run. It initializes the accumulator_set in order for it to only contain the operational_set, and to be of the same kind. This function modifies the its QueryBuilder instance to give the right results."
msgstr ""

#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.QueryRule._init_run:7
msgid "input with which to initialize the accumulator_set."
msgstr ""

#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.QueryRule._load_results:1
msgid "Single application of the rules to the operational set"
msgstr ""

#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.QueryRule._load_results:3
msgid "where the new results will be loaded (it will be first emptied of all previous content). There is no returned value for this method."
msgstr ""

#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.QueryRule._load_results:6
msgid "where the results originate from (walkers)"
msgstr ""

#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.QueryRule.set_edge_keys:1
msgid "Set the edge keys that are use to classify the edges during the run of this query."
msgstr ""

#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.QueryRule.set_edge_keys:3
msgid "a list of projections on the edge itself, or a tuple that specifies (tag, project) if the projection is not on the edge"
msgstr ""

#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.QueryRule.set_edge_keys:7
msgid "Example: For node-to-node graph traversals, it is often convenient to save the information on the links::"
msgstr ""

#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.ReplaceRule:1
#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.UpdateRule:1
msgid "Bases: :py:class:`~aiida.tools.graph.age_rules.QueryRule`"
msgstr ""

#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.ReplaceRule:1
msgid "The ReplaceRule does not accumulate results, but just sets the operational_set to new results. Therefore it can only function using a finite number of iterations, since it does not keep track of which nodes where visited already (otherwise, if it was following a cycle, it would run indefinitely)."
msgstr ""

#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.RuleSaveWalkers:1
msgid "Save the Walkers:"
msgstr ""

#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.RuleSaveWalkers:3
msgid "When initialized, this rule will save a pointer to an external stash variable. When run, this stash will be emptied and a given operational_set will be saved there instead."
msgstr ""

#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.RuleSaveWalkers.__init__:3
msgid "external variable in which to save the operational_set"
msgstr ""

#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.RuleSequence:1
msgid "Rule for concatenation"
msgstr ""

#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.RuleSequence:3
msgid "Rule Sequence is used to concatenate a series of rules together. Concatenating querybuilders in a single rule its not enough because one might want to stash results to perform two independent operations in the starting set instead of a second operation from the results of the first (see RuleSetWalkers and RuleSaveWalkers)."
msgstr ""

#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.RuleSequence.empty_accumulator:1
msgid "Empties the accumulator set"
msgstr ""

#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.RuleSequence.empty_visits:1
msgid "Empties the visits set"
msgstr ""

#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.RuleSequence.set_accumulator:1
msgid "Set the accumulator set"
msgstr ""

#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.RuleSequence.set_visits:1
msgid "Set the visits set"
msgstr ""

#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.RuleSetWalkers:1
msgid "Set the Walkers:"
msgstr ""

#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.RuleSetWalkers:3
msgid "When initialized, this rule will save a pointer to an external stash variable. When run, the given operational_set will be emptied and the stash will be loaded in it."
msgstr ""

#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.RuleSetWalkers.__init__:3
msgid "external variable from which to load into the operational_set"
msgstr ""

#: ../../../src/aiida/tools/graph/age_rules.py:docstring of aiida.tools.graph.age_rules.UpdateRule:1
msgid "The UpdateRule will accumulate every node visited and return it as a set of nodes (and thus, without duplication). It can be used requesting both a finite number of iterations or an infinite number of iterations (in which case it will stop once no new nodes are added to the accumulation set)."
msgstr ""

#: ../../../src/aiida/tools/graph/deletions.py:docstring of aiida.tools.graph.deletions:1
msgid "Functions to delete entities from the database, preserving provenance integrity."
msgstr ""

#: ../../../src/aiida/tools/graph/deletions.py:docstring of aiida.tools.graph.deletions.delete_group_nodes:1
msgid "Delete nodes contained in a list of groups (not the groups themselves!)."
msgstr ""

#: ../../../src/aiida/tools/graph/deletions.py:docstring of aiida.tools.graph.deletions.delete_group_nodes:3
msgid "This command will delete not only the nodes, but also the ones that are linked to these and should be also deleted in order to keep a consistent provenance according to the rules explained in the concepts section of the documentation. In summary:"
msgstr ""

#: ../../../src/aiida/tools/graph/deletions.py:docstring of aiida.tools.graph.deletions.delete_group_nodes:8
#: ../../../src/aiida/tools/graph/deletions.py:docstring of aiida.tools.graph.deletions.delete_nodes:8
msgid "If a DATA node is deleted, any process nodes linked to it will also be deleted."
msgstr ""

#: ../../../src/aiida/tools/graph/deletions.py:docstring of aiida.tools.graph.deletions.delete_group_nodes:10
#: ../../../src/aiida/tools/graph/deletions.py:docstring of aiida.tools.graph.deletions.delete_nodes:10
msgid "2. If a CALC node is deleted, any incoming WORK node (callers) will be deleted as well whereas any incoming DATA node (inputs) will be kept. Outgoing DATA nodes (outputs) will be deleted by default but this can be disabled."
msgstr ""

#: ../../../src/aiida/tools/graph/deletions.py:docstring of aiida.tools.graph.deletions.delete_group_nodes:14
#: ../../../src/aiida/tools/graph/deletions.py:docstring of aiida.tools.graph.deletions.delete_nodes:14
msgid "3. If a WORK node is deleted, any incoming WORK node (callers) will be deleted as well, but all DATA nodes will be kept. Outgoing WORK or CALC nodes will be kept by default, but deletion of either of both kind of connected nodes can be enabled."
msgstr ""

#: ../../../src/aiida/tools/graph/deletions.py:docstring of aiida.tools.graph.deletions.delete_group_nodes:18
#: ../../../src/aiida/tools/graph/deletions.py:docstring of aiida.tools.graph.deletions.delete_nodes:18
msgid "These rules are 'recursive', so if a CALC node is deleted, then its output DATA nodes will be deleted as well, and then any CALC node that may have those as inputs, and so on."
msgstr ""

#: ../../../src/aiida/tools/graph/deletions.py:docstring of aiida.tools.graph.deletions.delete_group_nodes:22
msgid "a list of the groups"
msgstr ""

#: ../../../src/aiida/tools/graph/deletions.py:docstring of aiida.tools.graph.deletions.delete_group_nodes:24
#: ../../../src/aiida/tools/graph/deletions.py:docstring of aiida.tools.graph.deletions.delete_nodes:25
msgid "If True, return the pks to delete without deleting anything. If False, delete the pks without confirmation If callable, a function that return True/False, based on the pks, e.g. ``dry_run=lambda pks: True``"
msgstr ""

#: ../../../src/aiida/tools/graph/deletions.py:docstring of aiida.tools.graph.deletions.delete_group_nodes:32
msgid "(node pks to delete, whether they were deleted)"
msgstr ""

#: ../../../src/aiida/tools/graph/deletions.py:docstring of aiida.tools.graph.deletions.delete_nodes:1
msgid "Delete nodes given a list of \"starting\" PKs."
msgstr ""

#: ../../../src/aiida/tools/graph/deletions.py:docstring of aiida.tools.graph.deletions.delete_nodes:3
msgid "This command will delete not only the specified nodes, but also the ones that are linked to these and should be also deleted in order to keep a consistent provenance according to the rules explained in the Topics - Provenance section of the documentation. In summary:"
msgstr ""

#: ../../../src/aiida/tools/graph/deletions.py:docstring of aiida.tools.graph.deletions.delete_nodes:22
msgid "a list of starting PKs of the nodes to delete (the full set will be based on the traversal rules)"
msgstr ""

#: ../../../src/aiida/tools/graph/deletions.py:docstring of aiida.tools.graph.deletions.delete_nodes:30
msgid "graph traversal rules. See :const:`aiida.common.links.GraphTraversalRules` for what rule names are toggleable and what the defaults are."
msgstr ""

#: ../../../src/aiida/tools/graph/deletions.py:docstring of aiida.tools.graph.deletions.delete_nodes:34
msgid "(pks to delete, whether they were deleted)"
msgstr ""

#: ../../../src/aiida/tools/graph/graph_traversers.py:docstring of aiida.tools.graph.graph_traversers:1
msgid "Module for functions to traverse AiiDA graphs."
msgstr ""

#: ../../../src/aiida/tools/graph/graph_traversers.py:docstring of aiida.tools.graph.graph_traversers.get_nodes_delete:1
msgid "This function will return the set of all nodes that can be connected to a list of initial nodes through any sequence of specified authorized links and directions for deletion."
msgstr ""

#: ../../../src/aiida/tools/graph/graph_traversers.py:docstring of aiida.tools.graph.graph_traversers.get_nodes_delete:5
#: ../../../src/aiida/tools/graph/graph_traversers.py:docstring of aiida.tools.graph.graph_traversers.get_nodes_export:6
#: ../../../src/aiida/tools/graph/graph_traversers.py:docstring of aiida.tools.graph.graph_traversers.traverse_graph:5
msgid "Contains the (valid) pks of the starting nodes."
msgstr ""

#: ../../../src/aiida/tools/graph/graph_traversers.py:docstring of aiida.tools.graph.graph_traversers.get_nodes_delete:7
#: ../../../src/aiida/tools/graph/graph_traversers.py:docstring of aiida.tools.graph.graph_traversers.get_nodes_export:8
#: ../../../src/aiida/tools/graph/graph_traversers.py:docstring of aiida.tools.graph.graph_traversers.traverse_graph:11
msgid "Pass True to also return the links between all nodes (found + initial)."
msgstr ""

#: ../../../src/aiida/tools/graph/graph_traversers.py:docstring of aiida.tools.graph.graph_traversers.get_nodes_delete:10
msgid "A callback to handle missing starting_pks or if None raise NotExistent For example to ignore them: ``missing_callback=lambda missing_pks: None``"
msgstr ""

#: ../../../src/aiida/tools/graph/graph_traversers.py:docstring of aiida.tools.graph.graph_traversers.get_nodes_export:1
msgid "This function will return the set of all nodes that can be connected to a list of initial nodes through any sequence of specified authorized links and directions for export. This will also return the links and the traversal rules parsed."
msgstr ""

#: ../../../src/aiida/tools/graph/graph_traversers.py:docstring of aiida.tools.graph.graph_traversers.get_nodes_export:11
#: ../../../src/aiida/tools/graph/graph_traversers.py:docstring of aiida.tools.graph.graph_traversers.validate_traversal_rules:5
msgid "will traverse INPUT_CALC links in the forward direction."
msgstr ""

#: ../../../src/aiida/tools/graph/graph_traversers.py:docstring of aiida.tools.graph.graph_traversers.get_nodes_export:12
#: ../../../src/aiida/tools/graph/graph_traversers.py:docstring of aiida.tools.graph.graph_traversers.validate_traversal_rules:8
msgid "will traverse CREATE links in the backward direction."
msgstr ""

#: ../../../src/aiida/tools/graph/graph_traversers.py:docstring of aiida.tools.graph.graph_traversers.get_nodes_export:13
#: ../../../src/aiida/tools/graph/graph_traversers.py:docstring of aiida.tools.graph.graph_traversers.validate_traversal_rules:10
msgid "will traverse RETURN links in the backward direction."
msgstr ""

#: ../../../src/aiida/tools/graph/graph_traversers.py:docstring of aiida.tools.graph.graph_traversers.get_nodes_export:14
#: ../../../src/aiida/tools/graph/graph_traversers.py:docstring of aiida.tools.graph.graph_traversers.validate_traversal_rules:11
msgid "will traverse INPUT_WORK links in the forward direction."
msgstr ""

#: ../../../src/aiida/tools/graph/graph_traversers.py:docstring of aiida.tools.graph.graph_traversers.get_nodes_export:15
#: ../../../src/aiida/tools/graph/graph_traversers.py:docstring of aiida.tools.graph.graph_traversers.validate_traversal_rules:14
msgid "will traverse CALL_CALC links in the backward direction."
msgstr ""

#: ../../../src/aiida/tools/graph/graph_traversers.py:docstring of aiida.tools.graph.graph_traversers.get_nodes_export:16
#: ../../../src/aiida/tools/graph/graph_traversers.py:docstring of aiida.tools.graph.graph_traversers.validate_traversal_rules:16
msgid "will traverse CALL_WORK links in the backward direction."
msgstr ""

#: ../../../src/aiida/tools/graph/graph_traversers.py:docstring of aiida.tools.graph.graph_traversers.traverse_graph:1
msgid "This function will return the set of all nodes that can be connected to a list of initial nodes through any sequence of specified links. Optionally, it may also return the links that connect these nodes."
msgstr ""

#: ../../../src/aiida/tools/graph/graph_traversers.py:docstring of aiida.tools.graph.graph_traversers.traverse_graph:7
msgid "The number of iterations to apply the set of rules (a value of 'None' will iterate until no new nodes are added)."
msgstr ""

#: ../../../src/aiida/tools/graph/graph_traversers.py:docstring of aiida.tools.graph.graph_traversers.traverse_graph:13
msgid "List with all the links that should be traversed in the forward direction."
msgstr ""

#: ../../../src/aiida/tools/graph/graph_traversers.py:docstring of aiida.tools.graph.graph_traversers.traverse_graph:14
msgid "List with all the links that should be traversed in the backward direction."
msgstr ""

#: ../../../src/aiida/tools/graph/graph_traversers.py:docstring of aiida.tools.graph.graph_traversers.traverse_graph:16
msgid "A callback to handle missing starting_pks or if None raise NotExistent"
msgstr ""

#: ../../../src/aiida/tools/graph/graph_traversers.py:docstring of aiida.tools.graph.graph_traversers.validate_traversal_rules:1
msgid "Validates the keywords with a ruleset template and returns a parsed dictionary ready to be used."
msgstr ""

#: ../../../src/aiida/tools/graph/graph_traversers.py:docstring of aiida.tools.graph.graph_traversers.validate_traversal_rules:4
msgid "Ruleset template used to validate the set of rules."
msgstr ""

#: ../../../src/aiida/tools/graph/graph_traversers.py:docstring of aiida.tools.graph.graph_traversers.validate_traversal_rules:6
msgid "will traverse INPUT_CALC links in the backward direction."
msgstr ""

#: ../../../src/aiida/tools/graph/graph_traversers.py:docstring of aiida.tools.graph.graph_traversers.validate_traversal_rules:7
msgid "will traverse CREATE links in the forward direction."
msgstr ""

#: ../../../src/aiida/tools/graph/graph_traversers.py:docstring of aiida.tools.graph.graph_traversers.validate_traversal_rules:9
msgid "will traverse RETURN links in the forward direction."
msgstr ""

#: ../../../src/aiida/tools/graph/graph_traversers.py:docstring of aiida.tools.graph.graph_traversers.validate_traversal_rules:12
msgid "will traverse INPUT_WORK links in the backward direction."
msgstr ""

#: ../../../src/aiida/tools/graph/graph_traversers.py:docstring of aiida.tools.graph.graph_traversers.validate_traversal_rules:13
msgid "will traverse CALL_CALC links in the forward direction."
msgstr ""

#: ../../../src/aiida/tools/graph/graph_traversers.py:docstring of aiida.tools.graph.graph_traversers.validate_traversal_rules:15
msgid "will traverse CALL_WORK links in the forward direction."
msgstr ""

#: ../../source/reference/apidoc/aiida.tools.groups.rst:2
msgid "aiida.tools.groups package"
msgstr ""

#: ../../../src/aiida/tools/groups/__init__.py:docstring of aiida.tools.groups:1
msgid "Provides tools for interacting with AiiDA Groups."
msgstr ""

#: ../../../src/aiida/tools/groups/paths.py:docstring of aiida.tools.groups.paths:1
msgid "Provides functionality for managing large numbers of AiiDA Groups, via label delimitation."
msgstr ""

#: ../../../src/aiida/tools/groups/paths.py:docstring of aiida.tools.groups.paths.GroupAttr:1
msgid "A class to provide attribute access to a ``GroupPath`` children."
msgstr ""

#: ../../../src/aiida/tools/groups/paths.py:docstring of aiida.tools.groups.paths.GroupAttr:3
msgid "The only public attributes on this class are dynamically created from the ``GroupPath`` child keys. NOTE: any child keys that do not conform to an acceptable (public) attribute string will be ignored. The ``GroupPath`` can be retrieved *via* a function call, e.g.::"
msgstr ""

#: ../../../src/aiida/tools/groups/paths.py:docstring of aiida.tools.groups.paths.GroupAttr.__call__:1
msgid "Return the ``GroupPath``."
msgstr ""

#: ../../../src/aiida/tools/groups/paths.py:docstring of aiida.tools.groups.paths.GroupAttr.__dir__:1
msgid "Return a list of available attributes."
msgstr ""

#: ../../../src/aiida/tools/groups/paths.py:docstring of aiida.tools.groups.paths.GroupAttr.__getattr__:1
msgid "Return the requested attribute name."
msgstr ""

#: ../../../src/aiida/tools/groups/paths.py:docstring of aiida.tools.groups.paths.GroupAttr.__init__:1
msgid "Instantiate the ``GroupPath``, and a mapping of its children."
msgstr ""

#: ../../../src/aiida/tools/groups/paths.py:docstring of aiida.tools.groups.paths.GroupAttr.__repr__:1
#: ../../../src/aiida/tools/groups/paths.py:docstring of aiida.tools.groups.paths.GroupPath.__repr__:1
msgid "Represent the instantiated class."
msgstr ""

#: ../../../src/aiida/tools/groups/paths.py:docstring of aiida.tools.groups.paths.GroupNotFoundError:1
msgid "An exception raised when a path does not have an associated group."
msgstr ""

#: ../../../src/aiida/tools/groups/paths.py:docstring of aiida.tools.groups.paths.GroupNotUniqueError:1
#: ../../../src/aiida/tools/groups/paths.py:docstring of aiida.tools.groups.paths.NoGroupsInPathError:1
msgid "An exception raised when a path has multiple associated groups."
msgstr ""

#: ../../../src/aiida/tools/groups/paths.py:docstring of aiida.tools.groups.paths.GroupPath:1
msgid "A class to provide label delimited access to groups."
msgstr ""

#: ../../../src/aiida/tools/groups/paths.py:docstring of aiida.tools.groups.paths.GroupPath:3
msgid "See tests for usage examples."
msgstr ""

#: ../../../src/aiida/tools/groups/paths.py:docstring of aiida.tools.groups.paths.GroupPath.__contains__:1
msgid "Return whether a child exists for this key."
msgstr ""

#: ../../../src/aiida/tools/groups/paths.py:docstring of aiida.tools.groups.paths.GroupPath.__eq__:1
msgid "Compare equality of path and ``Group`` subclass to another ``GroupPath`` object."
msgstr ""

#: ../../../src/aiida/tools/groups/paths.py:docstring of functools._ge_from_lt:1
msgid "Return a >= b.  Computed by @total_ordering from (not a < b)."
msgstr ""

#: ../../../src/aiida/tools/groups/paths.py:docstring of aiida.tools.groups.paths.GroupPath.__getitem__:1
#: ../../../src/aiida/tools/groups/paths.py:docstring of aiida.tools.groups.paths.GroupPath.__truediv__:1
msgid "Return a child ``GroupPath``, with a new path formed by appending ``path`` to the current path."
msgstr ""

#: ../../../src/aiida/tools/groups/paths.py:docstring of functools._gt_from_lt:1
msgid "Return a > b.  Computed by @total_ordering from (not a < b) and (a != b)."
msgstr ""

#: ../../../src/aiida/tools/groups/paths.py:docstring of aiida.tools.groups.paths.GroupPath.__init__:1
msgid "Instantiate the class."
msgstr ""

#: ../../../src/aiida/tools/groups/paths.py:docstring of aiida.tools.groups.paths.GroupPath.__init__:3
msgid "The initial path of the group."
msgstr ""

#: ../../../src/aiida/tools/groups/paths.py:docstring of aiida.tools.groups.paths.GroupPath.__init__:4
msgid "The subclass of `Group` to operate on."
msgstr ""

#: ../../../src/aiida/tools/groups/paths.py:docstring of aiida.tools.groups.paths.GroupPath.__init__:5
msgid "Issue a warning, when iterating children, if a child path is invalid."
msgstr ""

#: ../../../src/aiida/tools/groups/paths.py:docstring of aiida.tools.groups.paths.GroupPath.__iter__:1
#: ../../../src/aiida/tools/groups/paths.py:docstring of aiida.tools.groups.paths.GroupPath.children:1
msgid "Iterate through all (direct) children of this path."
msgstr ""

#: ../../../src/aiida/tools/groups/paths.py:docstring of functools._le_from_lt:1
msgid "Return a <= b.  Computed by @total_ordering from (a < b) or (a == b)."
msgstr ""

#: ../../../src/aiida/tools/groups/paths.py:docstring of aiida.tools.groups.paths.GroupPath.__len__:1
msgid "Return the number of children for this path."
msgstr ""

#: ../../../src/aiida/tools/groups/paths.py:docstring of aiida.tools.groups.paths.GroupPath.__lt__:1
msgid "Compare less-than operator of path and ``Group`` subclass to another ``GroupPath`` object."
msgstr ""

#: ../../../src/aiida/tools/groups/paths.py:docstring of aiida.tools.groups.paths.GroupPath._validate_path:1
msgid "Validate the supplied path."
msgstr ""

#: ../../../src/aiida/tools/groups/paths.py:docstring of aiida.tools.groups.paths.GroupPath.browse:1
msgid "Return a ``GroupAttr`` instance, for attribute access to children."
msgstr ""

#: ../../../src/aiida/tools/groups/paths.py:docstring of aiida.tools.groups.paths.GroupPath.cls:1
msgid "Return the cls used to query for and instantiate a ``Group`` with."
msgstr ""

#: ../../../src/aiida/tools/groups/paths.py:docstring of aiida.tools.groups.paths.GroupPath.delete_group:1
msgid "Delete the concrete group associated with this path."
msgstr ""

#: ../../../src/aiida/tools/groups/paths.py:docstring of aiida.tools.groups.paths.GroupPath.delete_group:3
msgid "GroupNotFoundError, GroupNotUniqueError"
msgstr ""

#: ../../../src/aiida/tools/groups/paths.py:docstring of aiida.tools.groups.paths.GroupPath.delimiter:1
msgid "Return the delimiter used to split path into components."
msgstr ""

#: ../../../src/aiida/tools/groups/paths.py:docstring of aiida.tools.groups.paths.GroupPath.get_group:1
msgid "Return the concrete group associated with this path."
msgstr ""

#: ../../../src/aiida/tools/groups/paths.py:docstring of aiida.tools.groups.paths.GroupPath.get_or_create_group:1
msgid "Return the concrete group associated with this path or, create it, if it does not already exist."
msgstr ""

#: ../../../src/aiida/tools/groups/paths.py:docstring of aiida.tools.groups.paths.GroupPath.group_ids:1
msgid "Return all the UUID associated with this GroupPath."
msgstr ""

#: ../../../src/aiida/tools/groups/paths.py:docstring of aiida.tools.groups.paths.GroupPath.group_ids:3
msgid "and empty list, if no group associated with this label, or can be multiple if cls was None"
msgstr ""

#: ../../../src/aiida/tools/groups/paths.py:docstring of aiida.tools.groups.paths.GroupPath.group_ids:6
msgid "This is an efficient method for checking existence, which does not require the (slow) loading of the ORM entity."
msgstr ""

#: ../../../src/aiida/tools/groups/paths.py:docstring of aiida.tools.groups.paths.GroupPath.is_virtual:1
msgid "Return whether there is one or more concrete groups associated with this path."
msgstr ""

#: ../../../src/aiida/tools/groups/paths.py:docstring of aiida.tools.groups.paths.GroupPath.key:1
msgid "Return the final component of the the path."
msgstr ""

#: ../../../src/aiida/tools/groups/paths.py:docstring of aiida.tools.groups.paths.GroupPath.parent:1
msgid "Return the parent path."
msgstr ""

#: ../../../src/aiida/tools/groups/paths.py:docstring of aiida.tools.groups.paths.GroupPath.path:1
msgid "Return the path string."
msgstr ""

#: ../../../src/aiida/tools/groups/paths.py:docstring of aiida.tools.groups.paths.GroupPath.path_list:1
msgid "Return a list of the path components."
msgstr ""

#: ../../../src/aiida/tools/groups/paths.py:docstring of aiida.tools.groups.paths.GroupPath.walk:1
msgid "Recursively iterate through all children of this path."
msgstr ""

#: ../../../src/aiida/tools/groups/paths.py:docstring of aiida.tools.groups.paths.GroupPath.walk_nodes:1
msgid "Recursively iterate through all nodes of this path and its children."
msgstr ""

#: ../../../src/aiida/tools/groups/paths.py:docstring of aiida.tools.groups.paths.GroupPath.walk_nodes:3
msgid "filters to apply to the node query"
msgstr ""

#: ../../../src/aiida/tools/groups/paths.py:docstring of aiida.tools.groups.paths.GroupPath.walk_nodes:4
msgid "return only nodes of a certain class (or list of classes)"
msgstr ""

#: ../../../src/aiida/tools/groups/paths.py:docstring of aiida.tools.groups.paths.GroupPath.walk_nodes:5
msgid "The size of the batches to ask the backend to batch results in subcollections. You can optimize the speed of the query by tuning this parameter. Be aware though that is only safe if no commit will take place during this transaction."
msgstr ""

#: ../../../src/aiida/tools/groups/paths.py:docstring of aiida.tools.groups.paths.InvalidPath:1
msgid "An exception to indicate that a path is not valid."
msgstr ""

#: ../../../src/aiida/tools/groups/paths.py:docstring of namedtuple_WalkNodeResult.WalkNodeResult.__new__:1
msgid "Create new instance of WalkNodeResult(group_path, node)"
msgstr ""

#: ../../../src/aiida/tools/groups/paths.py:docstring of collections.WalkNodeResult._make:1
msgid "Make a new WalkNodeResult object from a sequence or iterable"
msgstr ""

#: ../../../src/aiida/tools/groups/paths.py:docstring of collections.WalkNodeResult._replace:1
msgid "Return a new WalkNodeResult object replacing specified fields with new values"
msgstr ""

#: ../../source/reference/apidoc/aiida.tools.ipython.rst:2
msgid "aiida.tools.ipython package"
msgstr ""

#: ../../../src/aiida/tools/ipython/aiida_magic_register.py:docstring of aiida.tools.ipython.aiida_magic_register:1
msgid "File to be executed by IPython in order to register the line magic %aiida"
msgstr ""

#: ../../../src/aiida/tools/ipython/aiida_magic_register.py:docstring of aiida.tools.ipython.aiida_magic_register:3
msgid "This file can be put into the startup folder in order to have the line magic available at startup. The start up folder is usually at ``.ipython/profile_default/startup/``"
msgstr ""

#: ../../../src/aiida/tools/ipython/ipython_magics.py:docstring of aiida.tools.ipython.ipython_magics:1
msgid "An IPython extension that provides a magic command to load basic aiida commands."
msgstr ""

#: ../../../src/aiida/tools/ipython/ipython_magics.py:docstring of aiida.tools.ipython.ipython_magics:4
msgid "This makes it much easier to start."
msgstr ""

#: ../../../src/aiida/tools/ipython/ipython_magics.py:docstring of aiida.tools.ipython.ipython_magics:6
msgid "Produces output in:"
msgstr ""

#: ../../../src/aiida/tools/ipython/ipython_magics.py:docstring of aiida.tools.ipython.ipython_magics:8
msgid "Plaintext (IPython [qt]console)"
msgstr ""

#: ../../../src/aiida/tools/ipython/ipython_magics.py:docstring of aiida.tools.ipython.ipython_magics:9
msgid "HTML (IPython notebook, ``nbconvert --to html``, ``--to slides``)"
msgstr ""

#: ../../../src/aiida/tools/ipython/ipython_magics.py:docstring of aiida.tools.ipython.ipython_magics:10
msgid "JSON (IPython notebook ``.ipynb`` files)"
msgstr ""

#: ../../../src/aiida/tools/ipython/ipython_magics.py:docstring of aiida.tools.ipython.ipython_magics:11
msgid "LaTeX (e.g. ``ipython nbconvert example.ipynb --to LaTeX --post PDF``)"
msgstr ""

#: ../../../src/aiida/tools/ipython/ipython_magics.py:docstring of aiida.tools.ipython.ipython_magics:14
msgid "Notes on how to load it at start: https://ipython.org/ipython-doc/3/config/intro.html"
msgstr ""

#: ../../../src/aiida/tools/ipython/ipython_magics.py:docstring of aiida.tools.ipython.ipython_magics:18
msgid "Usage"
msgstr ""

#: ../../../src/aiida/tools/ipython/ipython_magics.py:docstring of aiida.tools.ipython.ipython_magics.AiiDALoaderMagics:1
msgid "Bases: :py:class:`~IPython.core.magic.Magics`"
msgstr ""

#: ../../../src/aiida/tools/ipython/ipython_magics.py:docstring of aiida.tools.ipython.ipython_magics.AiiDALoaderMagics:1
msgid "AiiDA magic loader."
msgstr ""

#: ../../../src/aiida/tools/ipython/ipython_magics.py:docstring of aiida.tools.ipython.ipython_magics.AiiDALoaderMagics._repr_html_:1
msgid "Output in HTML format."
msgstr ""

#: ../../../src/aiida/tools/ipython/ipython_magics.py:docstring of aiida.tools.ipython.ipython_magics.AiiDALoaderMagics._repr_json_:1
msgid "Output in JSON format."
msgstr ""

#: ../../../src/aiida/tools/ipython/ipython_magics.py:docstring of aiida.tools.ipython.ipython_magics.AiiDALoaderMagics._repr_latex_:1
msgid "Output in LaTeX format."
msgstr ""

#: ../../../src/aiida/tools/ipython/ipython_magics.py:docstring of aiida.tools.ipython.ipython_magics.AiiDALoaderMagics._repr_pretty_:1
msgid "Output in text format."
msgstr ""

#: ../../../src/aiida/tools/ipython/ipython_magics.py:docstring of aiida.tools.ipython.ipython_magics.AiiDALoaderMagics.aiida:1
msgid "Load AiiDA in ipython (checking if it was already loaded), and inserts in the namespace the main AiiDA classes (the same that are loaded in ``verdi shell``."
msgstr ""

#: ../../../src/aiida/tools/ipython/ipython_magics.py:docstring of aiida.tools.ipython.ipython_magics.AiiDALoaderMagics.aiida:9
msgid "implement parameters, e.g. for the profile to load."
msgstr ""

#: ../../../src/aiida/tools/ipython/ipython_magics.py:docstring of aiida.tools.ipython.ipython_magics.AiiDALoaderMagics.verdi:1
msgid "Run the AiiDA command line tool, using the currently loaded configuration and profile."
msgstr ""

#: ../../../src/aiida/tools/ipython/ipython_magics.py:docstring of aiida.tools.ipython.ipython_magics.AiiDALoaderMagics.verdi:3
msgid "Invoking ``verdi`` normally through the command line follows a different code path, compared to calling it directly from within an active Python interpreter. Some of those code paths we actually need here, and others can actually cause problems:"
msgstr ""

#: ../../../src/aiida/tools/ipython/ipython_magics.py:docstring of aiida.tools.ipython.ipython_magics.AiiDALoaderMagics.verdi:7
msgid "The ``VerdiCommandGroup`` group ensures that the context ``obj`` is set with the loaded ``Config`` and ``Profile``, but this is not done in this manual call, so we have to built it ourselves and pass it in with the ``obj`` keyword."
msgstr ""

#: ../../../src/aiida/tools/ipython/ipython_magics.py:docstring of aiida.tools.ipython.ipython_magics.AiiDALoaderMagics.verdi:10
msgid "We cannot call the ``aiida.cmdline.commands.cmd_verdi.verdi`` command directly, as that will invoke the ``aiida.cmdline.parameters.types.profile.ProfileParamType`` parameter used for the ``-p/--profile`` option that is defined on the ``verdi`` command. This will attempt to load the default profile, but here a profile has actually already been loaded. In principle, reloading a profile should not be a problem, but this magic is often used in demo notebooks where a temporary profile was created and loaded, which is not properly added to the config file (since it is temporary) and so loading the profile would fail. The solution is to not call the top-level ``verdi`` command, but the subcommand, which is the first parameter in the command line arguments defined by the ``line`` argument."
msgstr ""

#: ../../../src/aiida/tools/ipython/ipython_magics.py:docstring of aiida.tools.ipython.ipython_magics.add_to_ns:1
msgid "Add a new variable with name ``name`` and value ``obj`` to the namespace ``local_ns``, optionally showing a warning if we are hiding an existing variable."
msgstr ""

#: ../../../src/aiida/tools/ipython/ipython_magics.py:docstring of aiida.tools.ipython.ipython_magics.add_to_ns:5
msgid "implement the warning."
msgstr ""

#: ../../../src/aiida/tools/ipython/ipython_magics.py:docstring of aiida.tools.ipython.ipython_magics.load_ipython_extension:1
#: ../../../src/aiida/tools/ipython/ipython_magics.py:docstring of aiida.tools.ipython.ipython_magics.register_ipython_extension:1
msgid "Registers the %aiida IPython extension."
msgstr ""

#: ../../../src/aiida/tools/ipython/ipython_magics.py:docstring of aiida.tools.ipython.ipython_magics.load_ipython_extension:3
msgid "Use :py:func:`~aiida.tools.ipython.ipython_magics.register_ipython_extension` instead."
msgstr ""

#: ../../../src/aiida/tools/ipython/ipython_magics.py:docstring of aiida.tools.ipython.ipython_magics.register_ipython_extension:3
msgid "The %aiida IPython extension provides the same environment as the `verdi shell`."
msgstr ""

#: ../../../src/aiida/tools/ipython/ipython_magics.py:docstring of aiida.tools.ipython.ipython_magics.register_ipython_extension:5
msgid "InteractiveShell instance. If omitted, the global InteractiveShell is used."
msgstr ""

#: ../../source/reference/apidoc/aiida.tools.query.rst:2
msgid "aiida.tools.query package"
msgstr ""

#: ../../../src/aiida/tools/query/calculation.py:docstring of aiida.tools.query.calculation:1
msgid "Utility module with a factory of standard ``QueryBuilder`` instances for ``CalculationNodes``."
msgstr ""

#: ../../../src/aiida/tools/query/calculation.py:docstring of aiida.tools.query.calculation.CalculationQueryBuilder:1
msgid "Utility class to construct a QueryBuilder instance for Calculation nodes and project the query set."
msgstr ""

#: ../../../src/aiida/tools/query/calculation.py:docstring of aiida.tools.query.calculation.CalculationQueryBuilder.get_filters:1
msgid "Return a set of QueryBuilder filters based on typical command line options."
msgstr ""

#: ../../../src/aiida/tools/query/calculation.py:docstring of aiida.tools.query.calculation.CalculationQueryBuilder.get_filters:3
msgid "A tuple of node classes to filter for (must be sub classes of Calculation)."
msgstr ""

#: ../../../src/aiida/tools/query/calculation.py:docstring of aiida.tools.query.calculation.CalculationQueryBuilder.get_filters:4
msgid "Boolean to negate filtering for process state."
msgstr ""

#: ../../../src/aiida/tools/query/calculation.py:docstring of aiida.tools.query.calculation.CalculationQueryBuilder.get_filters:5
msgid "Filter for this process state attribute."
msgstr ""

#: ../../../src/aiida/tools/query/calculation.py:docstring of aiida.tools.query.calculation.CalculationQueryBuilder.get_filters:6
msgid "Filter for this process label attribute."
msgstr ""

#: ../../../src/aiida/tools/query/calculation.py:docstring of aiida.tools.query.calculation.CalculationQueryBuilder.get_filters:8
msgid "Filter for this exit status."
msgstr ""

#: ../../../src/aiida/tools/query/calculation.py:docstring of aiida.tools.query.calculation.CalculationQueryBuilder.get_filters:9
msgid "Boolean to filter only failed processes."
msgstr ""

#: ../../../src/aiida/tools/query/calculation.py:docstring of aiida.tools.query.calculation.CalculationQueryBuilder.get_filters:10
msgid "Dictionary of filters suitable for a QueryBuilder.append() call."
msgstr ""

#: ../../../src/aiida/tools/query/calculation.py:docstring of aiida.tools.query.calculation.CalculationQueryBuilder.get_projected:1
msgid "Project the query set for the given set of projections."
msgstr ""

#: ../../../src/aiida/tools/query/calculation.py:docstring of aiida.tools.query.calculation.CalculationQueryBuilder.get_query_set:1
msgid "Return the query set of calculations for the given filters and query parameters."
msgstr ""

#: ../../../src/aiida/tools/query/calculation.py:docstring of aiida.tools.query.calculation.CalculationQueryBuilder.get_query_set:3
msgid "A mapping of relationships to join on, e.g. {'with_node': Group} to join on a Group. The keys in this dictionary should be the keyword used in the `append` method of the `QueryBuilder` to join the entity on that is defined as the value."
msgstr ""

#: ../../../src/aiida/tools/query/calculation.py:docstring of aiida.tools.query.calculation.CalculationQueryBuilder.get_query_set:6
msgid "Rules to filter query results with."
msgstr ""

#: ../../../src/aiida/tools/query/calculation.py:docstring of aiida.tools.query.calculation.CalculationQueryBuilder.get_query_set:7
msgid "Order the query set by this criterion."
msgstr ""

#: ../../../src/aiida/tools/query/calculation.py:docstring of aiida.tools.query.calculation.CalculationQueryBuilder.get_query_set:8
msgid "Only include entries from the last past days."
msgstr ""

#: ../../../src/aiida/tools/query/calculation.py:docstring of aiida.tools.query.calculation.CalculationQueryBuilder.get_query_set:9
msgid "Limit the query set to this number of entries."
msgstr ""

#: ../../../src/aiida/tools/query/calculation.py:docstring of aiida.tools.query.calculation.CalculationQueryBuilder.get_query_set:10
msgid "The query set, a list of dictionaries."
msgstr ""

#: ../../../src/aiida/tools/query/formatting.py:docstring of aiida.tools.query.formatting:1
msgid "Utility module with simple functions to format variables into strings for outputting as text."
msgstr ""

#: ../../../src/aiida/tools/query/formatting.py:docstring of aiida.tools.query.formatting.format_process_state:1
msgid "Return a string formatted representation of the given process state."
msgstr ""

#: ../../../src/aiida/tools/query/formatting.py:docstring of aiida.tools.query.formatting.format_process_state:3
#: ../../../src/aiida/tools/query/formatting.py:docstring of aiida.tools.query.formatting.format_state:3
msgid "The process state."
msgstr ""

#: ../../../src/aiida/tools/query/formatting.py:docstring of aiida.tools.query.formatting.format_process_state:4
msgid "String representation of process state."
msgstr ""

#: ../../../src/aiida/tools/query/formatting.py:docstring of aiida.tools.query.formatting.format_relative_time:1
msgid "Return a string formatted timedelta of the given datetime with respect to the current datetime."
msgstr ""

#: ../../../src/aiida/tools/query/formatting.py:docstring of aiida.tools.query.formatting.format_relative_time:3
msgid "The datetime to format."
msgstr ""

#: ../../../src/aiida/tools/query/formatting.py:docstring of aiida.tools.query.formatting.format_relative_time:4
msgid "String representation of the relative time since the given datetime."
msgstr ""

#: ../../../src/aiida/tools/query/formatting.py:docstring of aiida.tools.query.formatting.format_sealed:1
msgid "Return a string formatted representation of a node's sealed status."
msgstr ""

#: ../../../src/aiida/tools/query/formatting.py:docstring of aiida.tools.query.formatting.format_sealed:3
msgid "The value for the sealed attribute of the node."
msgstr ""

#: ../../../src/aiida/tools/query/formatting.py:docstring of aiida.tools.query.formatting.format_sealed:4
msgid "String representation of seal status."
msgstr ""

#: ../../../src/aiida/tools/query/formatting.py:docstring of aiida.tools.query.formatting.format_state:1
msgid "Return a string formatted representation of a process' state which consists of its process state and exit status."
msgstr ""

#: ../../../src/aiida/tools/query/formatting.py:docstring of aiida.tools.query.formatting.format_state:4
msgid "Whether the process is paused."
msgstr ""

#: ../../../src/aiida/tools/query/formatting.py:docstring of aiida.tools.query.formatting.format_state:5
msgid "The process' exit status."
msgstr ""

#: ../../../src/aiida/tools/query/formatting.py:docstring of aiida.tools.query.formatting.format_state:6
msgid "String representation of the process' state."
msgstr ""

#: ../../../src/aiida/tools/query/mapping.py:docstring of aiida.tools.query.mapping:1
msgid "Utility module with mapper objects that map database entities projections on attributes and labels."
msgstr ""

#: ../../../src/aiida/tools/query/mapping.py:docstring of aiida.tools.query.mapping.CalculationProjectionMapper:1
msgid "Bases: :py:class:`~aiida.tools.query.mapping.ProjectionMapper`"
msgstr ""

#: ../../../src/aiida/tools/query/mapping.py:docstring of aiida.tools.query.mapping.CalculationProjectionMapper:1
msgid "The CLI projection mapper for Calculation derived entities."
msgstr ""

#: ../../../src/aiida/tools/query/mapping.py:docstring of aiida.tools.query.mapping.CalculationProjectionMapper.__init__:1
#: ../../../src/aiida/tools/query/mapping.py:docstring of aiida.tools.query.mapping.ProjectionMapper.__init__:1
msgid "Construct new instance."
msgstr ""

#: ../../../src/aiida/tools/query/mapping.py:docstring of aiida.tools.query.mapping.ProjectionMapper:1
msgid "Class to map projection names from the CLI to entity labels, attributes and formatters."
msgstr ""

#: ../../../src/aiida/tools/query/mapping.py:docstring of aiida.tools.query.mapping.ProjectionMapper:3
msgid "The command line interface will often have to display database entities and their attributes. The names of the attributes exposed on the CLI do not always match one-to-one with the attributes in the ORM and often they need to be formatted for the screen in some way. Additionally, for commands that display lists of entries, often a header needs to be printed with a label for each attribute, which also are not necessarily identical."
msgstr ""

#: ../../../src/aiida/tools/query/mapping.py:docstring of aiida.tools.query.mapping.ProjectionMapper:8
msgid "For any given entity, the CLI typically exposes a set of projections, which are the keywords to reference certain attributes. This mapper class serves to map these projections onto the corresponding label and attribute names, as well as formatter functions to format the attribute values into strings, suitable to be printed by the CLI."
msgstr ""

#: ../../source/reference/apidoc/aiida.tools.visualization.rst:2
msgid "aiida.tools.visualization package"
msgstr ""

#: ../../../src/aiida/tools/visualization/__init__.py:docstring of aiida.tools.visualization:1
msgid "Provides tools for visualization of the provenance graph."
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph:1
msgid "provides functionality to create graphs of the AiiDa data providence, *via* graphviz."
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph:1
msgid "A class to create graphviz graphs of the AiiDA node provenance."
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.__init__:1
msgid "A class to create graphviz graphs of the AiiDA node provenance"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.__init__:3
msgid "Nodes and edges, are cached, so that they are only created once"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.__init__:5
msgid "the graphviz engine, e.g. dot, circo"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.__init__:6
msgid "attributes for the graphviz graph"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.__init__:7
msgid "styles which will be added to all nodes. Note this will override any builtin attributes"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.__init__:9
msgid "styles which will be added to all edges. Note this will override any builtin attributes"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.__init__:11
msgid "if True, the note text will include node dependant sub-labels"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.__init__:12
msgid "callable mapping LinkType to graphviz style dict; link_style_fn(link_type, add_label, add_type) -> dict"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.__init__:14
msgid "callable mapping nodes to a graphviz style dict; node_sublabel_fn(node) -> dict"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.__init__:16
msgid "callable mapping data node to a sublabel (e.g. specifying some attribute values) node_sublabel_fn(node) -> str"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.__init__:18
msgid "the type of identifier to within the node text"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph._convert_link_types:1
msgid "Convert link types, which may be strings, to a member of LinkType"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph._load_node:1
msgid "Load a node (if not already loaded)"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph._load_node:3
#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.add_edge:3
#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.add_edge:4
#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.add_incoming:3
#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.add_node:3
#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.add_origin_to_targets:3
#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.recurse_ancestors:4
#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.recurse_descendants:4
msgid "node or node pk/uuid"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.add_edge:1
#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.add_node:1
msgid "Add single node to the graph"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.add_edge:5
msgid "defining the relationship between the nodes"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.add_edge:6
msgid "graphviz style parameters"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.add_edge:7
msgid "whether to overwrite existing edge"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.add_incoming:1
msgid "Add nodes and edges for incoming links to a node"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.add_incoming:4
#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.add_outgoing:4
msgid "filter by link types"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.add_incoming:5
#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.add_origin_to_targets:9
#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.add_origins_to_targets:10
#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.add_outgoing:5
#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.recurse_ancestors:7
#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.recurse_descendants:7
msgid "label edges with the link 'label', 'type' or 'both'"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.add_incoming:6
#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.add_outgoing:6
msgid "whether to return a list of nodes, or list of node pks"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.add_incoming:7
#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.add_outgoing:7
msgid "list of nodes or node pks"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.add_node:4
msgid "graphviz style parameters that will override default values"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.add_node:5
msgid "whether to overwrite an existing node"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.add_origin_to_targets:1
msgid "Add nodes and edges from an origin node to all nodes of a target node class."
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.add_origin_to_targets:4
#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.add_origins_to_targets:4
msgid "target node class"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.add_origin_to_targets:5
msgid "filters for query of target nodes"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.add_origin_to_targets:6
#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.add_origins_to_targets:7
msgid "Include incoming links for all target nodes"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.add_origin_to_targets:7
#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.add_origins_to_targets:8
msgid "Include outgoing links for all target nodes"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.add_origin_to_targets:8
#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.add_origins_to_targets:9
#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.recurse_ancestors:8
#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.recurse_descendants:8
msgid "node style map for origin node"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.add_origins_to_targets:1
msgid "Add nodes and edges from all nodes of an origin class to all node of a target node class."
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.add_origins_to_targets:3
msgid "origin node class"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.add_origins_to_targets:5
msgid "filters for origin nodes"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.add_origins_to_targets:6
msgid "filters for target nodes"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.add_outgoing:1
msgid "Add nodes and edges for outgoing links to a node"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.add_outgoing:3
msgid "node or node pk"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.backend:1
msgid "The backend used to create the graph"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.edges:1
msgid "Return a copy of the edges"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.graphviz:1
msgid "Return a copy of the graphviz.Digraph"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.nodes:1
msgid "Return a copy of the nodes"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.recurse_ancestors:1
msgid "Add nodes and edges from an origin recursively, following incoming links"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.recurse_ancestors:5
#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.recurse_descendants:5
msgid "if not None, stop after travelling a certain depth into the graph"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.recurse_ancestors:6
#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.recurse_descendants:6
msgid "filter by subset of link types"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.recurse_ancestors:9
msgid "include outgoing links for all processes"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.recurse_ancestors:10
msgid "class label (as displayed in the graph, e.g. 'StructureData', 'FolderData', etc.) to be highlight and other nodes are decolorized"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.recurse_descendants:1
msgid "Add nodes and edges from an origin recursively, following outgoing links"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.recurse_descendants:9
msgid "include incoming links for all processes"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.Graph.recurse_descendants:10
msgid "target class in exported graph expected to be highlight and other nodes are decolorized"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.LinkStyleFunc:1
msgid "Protocol for a link style function"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph._add_graphviz_edge:1
msgid "Add graphviz edge between two nodes"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph._add_graphviz_edge:3
msgid "the graphviz.DiGraph to add the edge to"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph._add_graphviz_edge:4
msgid "the head node"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph._add_graphviz_edge:5
msgid "the tail node"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph._add_graphviz_edge:6
msgid "the graphviz style"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph._add_graphviz_node:1
msgid "Create a node in the graph"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph._add_graphviz_node:3
msgid "The first line of the node text is always '<node.name> (<node.pk>)'. Then, if ``include_sublabels=True``, subsequent lines are added, which are node type dependant."
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph._add_graphviz_node:7
msgid "the graphviz.Digraph to add the node to"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph._add_graphviz_node:8
msgid "the node to add"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph._add_graphviz_node:9
msgid "callable mapping a node instance to a dictionary defining the graphviz node style"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph._add_graphviz_node:10
msgid "callable mapping a node instance to a sub-label for the node text"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph._add_graphviz_node:11
msgid "style dictionary, whose keys will override the final computed style"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph._add_graphviz_node:12
msgid "whether to include the sublabels for nodes"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph._add_graphviz_node:13
msgid "the type of identifier to use for node labels"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph._add_graphviz_node:15
msgid "Nodes are styled based on the node type"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph._add_graphviz_node:17
msgid "For subclasses of Data, the ``class_node_type`` attribute is used for mapping to type specific styles"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph._add_graphviz_node:20
msgid "For subclasses of ProcessNode, we choose styles to distinguish between types, and also color the nodes for successful/failed processes"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph._default_ignore_node_styles:1
msgid "Return the default style for ignored nodes."
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph._default_origin_node_styles:1
msgid "Return the default style for origin nodes."
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph._get_node_label:1
msgid "Return a label text of node and the return format is '<NodeType> (<id>)'."
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.default_link_styles:1
msgid "Map link_pair to a graphviz edge style"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.default_link_styles:3
msgid "a LinkPair attribute"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.default_link_styles:4
msgid "include link label"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.default_link_styles:5
msgid "include link type"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.default_node_styles:1
msgid "Map a node to a graphviz node style"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.default_node_styles:3
#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.default_node_sublabels:4
#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.pstate_node_styles:3
msgid "the node to map"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.default_node_sublabels:1
msgid "Function mapping nodes to a sub-label (e.g. specifying some attribute values)"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.get_node_id_label:1
msgid "Return an identifier str for the node"
msgstr ""

#: ../../../src/aiida/tools/visualization/graph.py:docstring of aiida.tools.visualization.graph.pstate_node_styles:1
msgid "Map a process node to a graphviz node style"
msgstr ""

#: ../../source/reference/apidoc/aiida.transports.rst:2
msgid "aiida.transports package"
msgstr ""

#: ../../../src/aiida/transports/__init__.py:docstring of aiida.transports:1
msgid "Module for classes and utilities to define transports to other machines."
msgstr ""

#: ../../../src/aiida/transports/cli.py:docstring of aiida.transports.cli:1
msgid "Common cli utilities for transport plugins."
msgstr ""

#: ../../../src/aiida/transports/cli.py:docstring of aiida.transports.cli.common_params:1
msgid "Decorate a command function with common click parameters for all transport plugins."
msgstr ""

#: ../../../src/aiida/transports/cli.py:docstring of aiida.transports.cli.configure_computer_main:1
msgid "Configure a computer via the CLI."
msgstr ""

#: ../../../src/aiida/transports/cli.py:docstring of aiida.transports.cli.create_configure_cmd:1
msgid "Create verdi computer configure subcommand for a transport type."
msgstr ""

#: ../../../src/aiida/transports/cli.py:docstring of aiida.transports.cli.create_option:1
msgid "Create a click option from a name and partial specs as used in transport auth_options."
msgstr ""

#: ../../../src/aiida/transports/cli.py:docstring of aiida.transports.cli.interactive_default:1
msgid "Create a contextual_default value callback for an auth_param key."
msgstr ""

#: ../../../src/aiida/transports/cli.py:docstring of aiida.transports.cli.interactive_default:3
msgid "the name of the option."
msgstr ""

#: ../../../src/aiida/transports/cli.py:docstring of aiida.transports.cli.interactive_default:4
msgid "indicates whether this option should provide a default also in non-interactive mode. If False, the option will raise `MissingParameter` if no explicit value is specified when the command is called in non-interactive mode."
msgstr ""

#: ../../../src/aiida/transports/cli.py:docstring of aiida.transports.cli.match_comp_transport:1
msgid "Check the computer argument against the transport type."
msgstr ""

#: ../../../src/aiida/transports/cli.py:docstring of aiida.transports.cli.transport_option_default:1
msgid "Determine the default value for an auth_param key."
msgstr ""

#: ../../../src/aiida/transports/cli.py:docstring of aiida.transports.cli.transport_options:1
msgid "Decorate a command with all options for a computer configure subcommand for transport_type."
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport:1
msgid "Transport interface."
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport:1
msgid "Abstract class for a generic transport (ssh, local, ...) contains the set of minimal methods."
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.__enter__:1
msgid "For transports that require opening a connection, opens all required channels (used in 'with' statements)."
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.__enter__:4
msgid "This object can be used in nested `with` statements and the connection will only be opened once and closed when the final `with` scope finishes e.g.::"
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.__exit__:1
msgid "Closes connections, if needed (used in 'with' statements)."
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.__init__:1
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.__init__:1
msgid "__init__ method of the Transport base class."
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.__init__:3
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.__init__:3
msgid "(optional, default self._DEFAULT_SAFE_OPEN_INTERVAL) Minimum time interval in seconds between opening new connections."
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.__init__:5
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.__init__:5
msgid "(optional, default True) if False, do not use a login shell when executing command"
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport._exec_command_internal:1
msgid "Execute the command on the shell, similarly to os.system."
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport._exec_command_internal:3
msgid "Enforce the execution to be run from the cwd (as given by self.getcwd), if this is not None."
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport._exec_command_internal:6
msgid "If possible, use the higher-level exec_command_wait function."
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport._exec_command_internal:9
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.exec_command_wait_bytes:8
msgid "execute the command given as a string"
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport._exec_command_internal:10
msgid "stdin, stdout, stderr and the session, when this exists                  (can be None)."
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport._get_safe_interval_suggestion_string:1
msgid "Return as a suggestion the default safe interval of this Transport class."
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport._get_safe_interval_suggestion_string:3
msgid "This is used to provide a default in ``verdi computer configure``."
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport._get_allow_agent_suggestion_string:1
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport._get_compress_suggestion_string:1
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport._get_gss_auth_suggestion_string:1
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport._get_gss_deleg_creds_suggestion_string:1
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport._get_gss_host_suggestion_string:1
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport._get_gss_kex_suggestion_string:1
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport._get_key_filename_suggestion_string:1
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport._get_key_policy_suggestion_string:1
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport._get_load_system_host_keys_suggestion_string:1
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport._get_look_for_keys_suggestion_string:1
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport._get_port_suggestion_string:1
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport._get_proxy_command_suggestion_string:1
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport._get_timeout_suggestion_string:1
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport._get_username_suggestion_string:1
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport._get_use_login_shell_suggestion_string:1
msgid "Return a suggestion for the specific field."
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport._gotocomputer_string:1
msgid "Command executed when goto computer."
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.chdir:1
msgid "Change directory to 'path'"
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.chdir:3
msgid "path to change working directory into."
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.chdir:4
msgid "IOError, if the requested path does not exist"
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.chmod:1
msgid "Change permissions of a path."
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.chmod:3
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.chmod:3
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.get_attribute:17
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.get_mode:3
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.isfile:3
msgid "path to file"
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.chmod:4
msgid "new permissions"
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.chown:1
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.chown:1
msgid "Change the owner (uid) and group (gid) of a file. As with python's os.chown function, you must pass both arguments, so if you only want to change one, use stat first to retrieve the current owner and group."
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.chown:6
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.chown:6
msgid "path to the file to change the owner and group of"
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.chown:7
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.chown:7
msgid "new owner's uid"
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.chown:8
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.chown:8
msgid "new group id"
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.close:1
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.close:1
msgid "Closes the local transport channel"
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.copy:1
msgid "Copy a file or a directory from remote source to remote destination (On the same remote machine)"
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.copyfile:4
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.copytree:4
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.copy:4
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.copyfile:4
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.copytree:4
msgid "path of the remote source directory / file"
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.copyfile:5
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.copytree:5
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.copy:5
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.copyfile:5
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.copytree:5
msgid "path of the remote destination directory / file"
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.copyfile:6
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.copyfile:6
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.copytree:6
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.copy:6
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.copyfile:6
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.copytree:6
msgid "if True copy the contents of any symlinks found, otherwise copy the symlinks themselves"
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.copy:7
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.copy:9
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.copy:8
msgid "if True copy directories recursively, otherwise only copy the specified file(s)"
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.copy:11
msgid "IOError, if one of src or dst does not exist"
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.copy_from_remote_to_remote:1
#: ../../../src/aiida/transports/util.py:docstring of aiida.transports.util.copy_from_remote_to_remote:1
msgid "Copy files or folders from a remote computer to another remote computer."
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.copy_from_remote_to_remote:3
#: ../../../src/aiida/transports/util.py:docstring of aiida.transports.util.copy_from_remote_to_remote:4
msgid "transport to be used for the destination computer"
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.copy_from_remote_to_remote:4
#: ../../../src/aiida/transports/util.py:docstring of aiida.transports.util.copy_from_remote_to_remote:5
msgid "path to the remote source directory / file"
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.copy_from_remote_to_remote:5
#: ../../../src/aiida/transports/util.py:docstring of aiida.transports.util.copy_from_remote_to_remote:6
msgid "path to the remote destination directory / file"
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.copy_from_remote_to_remote:6
msgid "keyword parameters passed to the call to transportdestination.put, except for 'dereference' that is passed to self.get"
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.copy_from_remote_to_remote:9
msgid "the keyword 'dereference' SHOULD be set to False for the final put (onto the destination), while it can be set to the value given in kwargs for the get from the source. In that way, a symbolic link would never be followed in the final copy to the remote destination. That way we could avoid getting unknown (potentially malicious) files into the destination computer. HOWEVER, since dereference=False is currently NOT supported by all plugins, we still force it to True for the final put."
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.copy_from_remote_to_remote:18
msgid "the supported keys in kwargs are callback, dereference, overwrite and ignore_nonexisting."
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.copyfile:1
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.copyfile:1
msgid "Copy a file from remote source to remote destination (On the same remote machine)"
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.copyfile:9
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.copytree:9
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.copyfile:9
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.copytree:9
msgid "if one of src or dst does not exist"
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.copytree:1
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.copytree:1
msgid "Copy a folder from remote source to remote destination (On the same remote machine)"
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.exec_command_wait_bytes:1
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.exec_command_wait_bytes:1
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.exec_command_wait:1
msgid "Executes the specified command and waits for it to finish."
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.exec_command_wait:3
msgid "this function also decodes the bytes received into a string with the specified encoding, which is set to be ``utf-8`` by default (for backward-compatibility with earlier versions) of AiiDA. Use this method only if you are sure that you are getting a properly encoded string; otherwise, use the ``exec_command_wait_bytes`` method that returns the undecoded byte stream."
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.exec_command_wait:9
msgid "additional kwargs are passed to the ``exec_command_wait_bytes`` function, that might use them depending on the plugin."
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.exec_command_wait_bytes:3
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.exec_command_wait_bytes:3
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.exec_command_wait:12
msgid "the command to execute"
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.exec_command_wait_bytes:4
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.exec_command_wait:13
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.exec_command_wait_bytes:9
msgid "(optional,default=None) can be a string or a file-like object."
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.exec_command_wait:14
msgid "the encoding to use to decode the byte stream received from the remote command execution."
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.exec_command_wait:16
msgid "a tuple with (return_value, stdout, stderr) where stdout and stderr are both strings, decoded with the specified encoding."
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.exec_command_wait_bytes:1
msgid "Execute the command on the shell, waits for it to finish, and return the retcode, the stdout and the stderr as bytes."
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.exec_command_wait_bytes:4
msgid "Enforce the execution to be run from the pwd (as given by self.getcwd), if this is not None."
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.exec_command_wait_bytes:6
msgid "The command implementation can have some additional plugin-specific kwargs."
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.exec_command_wait_bytes:10
msgid "a tuple: the retcode (int), stdout (bytes) and stderr (bytes)."
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.get:1
msgid "Retrieve a file or folder from remote source to local destination dst must be an absolute path (src not necessarily)"
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.get:4
msgid "(str) remote_folder_path"
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.get:5
msgid "(str) local_folder_path"
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.get_attribute:1
msgid "Return an object FixedFieldsAttributeDict for file in a given path, as defined in aiida.common.extendeddicts Each attribute object consists in a dictionary with the following keys:"
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.get_attribute:5
msgid "st_size: size of files, in bytes"
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.get_attribute:7
msgid "st_uid: user id of owner"
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.get_attribute:9
msgid "st_gid: group id of owner"
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.get_attribute:11
msgid "st_mode: protection bits"
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.get_attribute:13
msgid "st_atime: time of most recent access"
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.get_attribute:15
msgid "st_mtime: time of most recent modification"
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.get_attribute:18
msgid "object FixedFieldsAttributeDict"
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.get_mode:1
msgid "Return the portion of the file's mode that can be set by chmod()."
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.get_mode:4
msgid "the portion of the file's mode that can be set by chmod()"
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.get_safe_open_interval:1
msgid "Get an interval (in seconds) that suggests how long the user should wait between consecutive calls to open the transport.  This can be used as a way to get the user to not swamp a limited number of connections, etc. However it is just advisory."
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.get_safe_open_interval:6
msgid "If returns 0, it is taken that there are no reasons to limit the frequency of open calls."
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.get_safe_open_interval:9
msgid "In the main class, it returns a default value (>0 for safety), set in the _DEFAULT_SAFE_OPEN_INTERVAL attribute of the class. Plugins should override it."
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.get_safe_open_interval:12
msgid "The safe interval between calling open, in seconds"
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.get_short_doc:1
msgid "Return the first non-empty line of the class docstring, if available"
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.get_valid_auth_params:1
msgid "Return the internal list of valid auth_params"
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.getcwd:1
msgid "Get working directory"
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.getcwd:3
msgid "a string identifying the current working directory"
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.getfile:1
msgid "Retrieve a file from remote source to local destination dst must be an absolute path (src not necessarily)"
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.getfile:4
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.gettree:4
msgid "remote_folder_path"
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.getfile:5
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.gettree:5
msgid "local_folder_path"
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.gettree:1
msgid "Retrieve a folder recursively from remote source to local destination dst must be an absolute path (src not necessarily)"
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.glob:1
msgid "Return a list of paths matching a pathname pattern."
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.glob:3
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.iglob:3
msgid "The pattern may contain simple shell-style wildcards a la fnmatch."
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.glob0:1
msgid "Wrap basename i a list if it is empty or if dirname/basename is an existing path, else return empty list."
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.glob1:1
msgid "Match subpaths of dirname against pattern."
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.gotocomputer_command:1
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.gotocomputer_command:1
msgid "Return a string to be run using os.system in order to connect via the transport to the remote directory."
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.gotocomputer_command:4
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.gotocomputer_command:4
msgid "Expected behaviors:"
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.gotocomputer_command:6
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.gotocomputer_command:6
msgid "A new bash session is opened"
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.gotocomputer_command:7
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.gotocomputer_command:8
msgid "A reasonable error message is produced if the folder does not exist"
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.gotocomputer_command:9
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.gotocomputer_command:10
msgid "the full path of the remote directory"
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.iglob:1
msgid "Return an iterator which yields the paths matching a pathname pattern."
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.isdir:1
msgid "True if path is an existing directory."
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.isdir:3
msgid "path to directory"
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.isdir:4
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.isfile:4
msgid "boolean"
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.isfile:1
msgid "Return True if path is an existing file."
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.listdir:1
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.listdir_withattributes:1
msgid "Return a list of the names of the entries in the given path. The list is in arbitrary order. It does not include the special entries '.' and '..' even if they are present in the directory."
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.listdir:5
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.listdir_withattributes:5
msgid "path to list (default to '.')"
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.listdir:6
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.listdir_withattributes:6
msgid "if used, listdir returns a list of files matching filters in Unix style. Unix only."
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.listdir_withattributes:8
msgid "a list of dictionaries, one per entry. The schema of the dictionary is the following::      {        'name': String,        'attributes': FileAttributeObject,        'isdir': Bool     }  where 'name' is the file or folder directory, and any other information is metadata (if the file is a folder, a directory, ...). 'attributes' behaves as the output of transport.get_attribute(); isdir is a boolean indicating if the object is a directory or not."
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.listdir_withattributes:8
msgid "a list of dictionaries, one per entry. The schema of the dictionary is the following::"
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.listdir_withattributes:18
msgid "where 'name' is the file or folder directory, and any other information is metadata (if the file is a folder, a directory, ...). 'attributes' behaves as the output of transport.get_attribute(); isdir is a boolean indicating if the object is a directory or not."
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.logger:1
msgid "Return the internal logger. If you have set extra parameters using set_logger_extra(), a suitable LoggerAdapter instance is created, bringing with itself also the extras."
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.makedirs:1
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.makedirs:1
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.makedirs:1
msgid "Super-mkdir; create a leaf directory and all intermediate ones. Works like mkdir, except that any intermediate path segment (not just the rightmost) will be created if it does not exist."
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.makedirs:5
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.makedirs:5
msgid "directory to create"
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.makedirs:6
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.makedirs:6
msgid "if set to true, it doesn't give any error if the leaf directory does already exist"
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.makedirs:9
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.mkdir:7
msgid "OSError, if directory at path already exists"
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.mkdir:1
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.mkdir:1
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.mkdir:1
msgid "Create a folder (directory) named path."
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.mkdir:3
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.mkdir:3
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.mkdir:3
msgid "name of the folder to create"
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.mkdir:4
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.mkdir:4
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.mkdir:4
msgid "if True, does not give any error if the directory already exists"
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.normalize:1
msgid "Return the normalized path (on the server) of a given path. This can be used to quickly resolve symbolic links or determine what the server is considering to be the \"current folder\"."
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.normalize:5
msgid "path to be normalized"
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.normalize:7
msgid "if the path can't be resolved on the server"
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.open:1
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.open:1
msgid "Opens a local transport channel"
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.path_exists:1
msgid "Returns True if path exists, False otherwise."
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.put:1
msgid "Put a file or a directory from local src to remote dst. src must be an absolute path (dst not necessarily)) Redirects to putfile and puttree."
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.put:5
msgid "absolute path to local source"
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.put:6
msgid "path to remote destination"
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.putfile:1
msgid "Put a file from local src to remote dst. src must be an absolute path (dst not necessarily))"
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.put:4
#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.putfile:4
#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.puttree:4
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.putfile:4
msgid "absolute path to local file"
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.copy:5
#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.copyfile:5
#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.copytree:5
#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.put:5
#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.putfile:5
#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.puttree:5
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.putfile:5
msgid "path to remote file"
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.puttree:1
msgid "Put a folder recursively from local src to remote dst. src must be an absolute path (dst not necessarily))"
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.puttree:4
msgid "absolute path to local folder"
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.puttree:5
msgid "path to remote folder"
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.remove:1
msgid "Remove the file at the given path. This only works on files; for removing folders (directories), use rmdir."
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.remove:4
msgid "path to file to remove"
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.remove:6
msgid "if the path is a directory"
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.rename:1
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.rename:1
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.rename:1
msgid "Rename a file or folder from oldpath to newpath."
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.rename:3
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.rename:3
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.rename:3
msgid "existing name of the file or folder"
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.rename:4
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.rename:4
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.rename:4
msgid "new name for the file or folder"
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.rename:6
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.rename:6
msgid "if oldpath/newpath is not found"
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.rename:7
msgid "if oldpath/newpath is not a valid string"
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.rmdir:1
msgid "Remove the folder named path. This works only for empty folders. For recursive remove, use rmtree."
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.rmdir:4
msgid "absolute path to the folder to remove"
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.rmtree:1
msgid "Remove recursively the content at path"
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.rmtree:3
msgid "absolute path to remove"
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.set_logger_extra:1
msgid "Pass the data that should be passed automatically to self.logger as 'extra' keyword. This is typically useful if you pass data obtained using get_dblogger_extra in aiida.orm.utils.log, to automatically log also to the DbLog table."
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.set_logger_extra:6
msgid "data that you want to pass as extra to the self.logger. To write to DbLog, it should be created by the aiida.orm.utils.log.get_dblogger_extra function. Pass None if you do not want to have extras passed."
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.symlink:1
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.symlink:1
msgid "Create a symbolic link between the remote source and the remote destination."
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.symlink:4
msgid "remote source"
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.symlink:5
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.symlink:5
#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.symlink:5
msgid "remote destination"
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.whoami:1
msgid "Get the remote username"
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.Transport.whoami:3
msgid "list of username (str), retval (int), stderr (str)"
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.TransportInternalError:1
msgid "Raised if there is a transport error that is raised to an internal error (e.g. a transport method called without opening the channel first)."
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.validate_positive_number:1
msgid "Validate that the number passed to this parameter is a positive number."
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.validate_positive_number:3
msgid "the `click.Context`"
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.validate_positive_number:4
msgid "the parameter"
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.validate_positive_number:5
msgid "the value passed for the parameter"
msgstr ""

#: ../../../src/aiida/transports/transport.py:docstring of aiida.transports.transport.validate_positive_number:6
msgid "if the value is not a positive number"
msgstr ""

#: ../../../src/aiida/transports/util.py:docstring of aiida.transports.util:1
msgid "General utilities for Transport classes."
msgstr ""

#: ../../../src/aiida/transports/util.py:docstring of aiida.transports.util.FileAttribute:1
msgid "Bases: :py:class:`~aiida.common.extendeddicts.FixedFieldsAttributeDict`"
msgstr ""

#: ../../../src/aiida/transports/util.py:docstring of aiida.transports.util.FileAttribute:1
msgid "A class, resembling a dictionary, to describe the attributes of a file, that is returned by get_attribute(). Possible keys: st_size, st_uid, st_gid, st_mode, st_atime, st_mtime"
msgstr ""

#: ../../../src/aiida/transports/util.py:docstring of aiida.transports.util._DetachedProxyCommand:1
msgid "Bases: :py:class:`~paramiko.proxy.ProxyCommand`"
msgstr ""

#: ../../../src/aiida/transports/util.py:docstring of aiida.transports.util._DetachedProxyCommand:1
msgid "Modifies paramiko's ProxyCommand by launching the process in a separate process group."
msgstr ""

#: ../../../src/aiida/transports/util.py:docstring of aiida.transports.util._DetachedProxyCommand.__init__:1
msgid "Create a new CommandProxy instance. The instance created by this class can be passed as an argument to the `.Transport` class."
msgstr ""

#: ../../../src/aiida/transports/util.py:docstring of aiida.transports.util._DetachedProxyCommand.__init__:4
msgid "the command that should be executed and used as the proxy."
msgstr ""

#: ../../../src/aiida/transports/util.py:docstring of aiida.transports.util.copy_from_remote_to_remote:3
msgid "transport to be used for the source computer"
msgstr ""

#: ../../../src/aiida/transports/util.py:docstring of aiida.transports.util.copy_from_remote_to_remote:7
msgid "keyword parameters passed to the final put, except for 'dereference' that is passed to the initial get"
msgstr ""

#: ../../../src/aiida/transports/util.py:docstring of aiida.transports.util.copy_from_remote_to_remote:10
msgid "it uses the method transportsource.copy_from_remote_to_remote"
msgstr ""

#: ../../source/reference/apidoc/aiida.transports.plugins.rst:2
msgid "aiida.transports.plugins package"
msgstr ""

#: ../../../src/aiida/transports/plugins/__init__.py:docstring of aiida.transports.plugins:1
msgid "Plugins for the transport."
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local:1
msgid "Local transport"
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport:1
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport:1
msgid "Bases: :py:class:`~aiida.transports.transport.Transport`"
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport:1
msgid "Support copy and command execution on the same host on which AiiDA is running via direct file copy and execution commands."
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport:4
msgid "Note that the environment variables are copied from the submitting process, so you might need to clean it with a ``prepend_text``. For example, the AiiDA daemon sets a ``PYTHONPATH``, so you might want to add ``unset PYTHONPATH`` if you plan on running calculations that use Python."
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.__str__:1
msgid "Return a description as a string."
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport._exec_command_internal:1
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport._exec_command_internal:1
msgid "Executes the specified command in bash login shell."
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport._exec_command_internal:3
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport._exec_command_internal:3
msgid "Before the command is executed, changes directory to the current working directory as returned by self.getcwd()."
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport._exec_command_internal:6
msgid "For executing commands and waiting for them to finish, use exec_command_wait. Otherwise, to end the process, use the proc.wait() method."
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport._exec_command_internal:10
msgid "The subprocess is set to have a different process group than the main process, so that it is shielded from signals sent to the parent."
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport._exec_command_internal:13
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport._exec_command_internal:9
msgid "the command to execute. The command is assumed to be already escaped using :py:func:`aiida.common.escaping.escape_for_bash`."
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport._exec_command_internal:16
msgid "a tuple with (stdin, stdout, stderr, proc), where stdin, stdout and stderr behave as file-like objects, proc is the process object as returned by the subprocess.Popen() class."
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport._local_listdir:1
msgid "Act on the local folder, for the rest, same as listdir."
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport._os_path_split_asunder:1
msgid "Used by makedirs, Takes path (a str) and returns a list deconcatenating the path."
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.chdir:1
msgid "Changes directory to path, emulated internally. :param path: path to cd into :raise OSError: if the directory does not have read attributes."
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.chmod:1
msgid "Changes permission bits of object at path :param path: path to modify :param mode: permission bits"
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.chmod:5
msgid "if path does not exist."
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.close:3
#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.open:3
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.close:5
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.open:7
msgid "if the channel is already open"
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.copy:1
msgid "Copies a file or a folder from 'remote' remotesource to 'remote' remotedestination. Automatically redirects to copyfile or copytree."
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.copy:4
#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.copyfile:4
#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.copytree:4
#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.get:5
#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.getfile:4
#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.gettree:4
msgid "path to local file"
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.copy:6
#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.copytree:6
msgid "follow symbolic links. Default = False"
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.copy:10
msgid "if 'remote' remotesource or remotedestinationis not valid"
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.copy:11
#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.copyfile:9
#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.copytree:9
msgid "if remotesource does not exist"
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.copyfile:1
msgid "Copies a file from 'remote' remotesource to 'remote' remotedestination."
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.copyfile:8
#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.copytree:8
msgid "if 'remote' remotesource or remotedestination is not valid"
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.copytree:1
msgid "Copies a folder from 'remote' remotesource to 'remote' remotedestination."
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.curdir:1
msgid "Returns the _internal_dir, if the channel is open. If possible, use getcwd() instead!"
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.exec_command_wait_bytes:5
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.exec_command_wait_bytes:10
msgid "a tuple with (return_value, stdout, stderr) where stdout and stderr are both bytes and the return_value is an int."
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.get:1
msgid "Copies a folder or a file recursively from 'remote' remotepath to 'local' localpath. Automatically redirects to getfile or gettree."
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.get:6
#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.getfile:5
#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.gettree:5
msgid "absolute path to remote file"
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.get:7
msgid "follow symbolic links default = True"
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.get:9
msgid "if True overwrites localpath default = False"
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.get:12
#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.gettree:9
msgid "if 'remote' remotepath is not valid"
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.get:13
#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.gettree:10
msgid "if 'local' localpath is not valid"
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.get_attribute:1
msgid "Returns an object FileAttribute, as specified in aiida.transports. :param path: the path of the given file."
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.getcwd:1
msgid "Returns the current working directory, emulated by the transport"
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.getfile:1
msgid "Copies a file recursively from 'remote' remotepath to 'local' localpath."
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.getfile:6
#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.gettree:7
msgid "if True overwrites localpath. Default = False"
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.getfile:9
msgid ":raise IOError if 'remote' remotepath is not valid or not found :raise ValueError: if 'local' localpath is not valid :raise OSError: if unintentionally overwriting"
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.gettree:1
msgid "Copies a folder recursively from 'remote' remotepath to 'local' localpath."
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.gettree:6
#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.puttree:6
msgid "follow symbolic links. Default = True"
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.gettree:11
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.getfile:9
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.gettree:13
msgid "if unintentionally overwriting"
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.isdir:1
msgid "Checks if 'path' is a directory. :return: a boolean"
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.isfile:1
msgid "Checks if object at path is a file. Returns a boolean."
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.listdir:1
msgid "a list containing the names of the entries in the directory."
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.listdir:2
msgid "default ='.'"
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.listdir:3
msgid "if set, returns the list of files matching pattern. Unix only. (Use to emulate ls * for example)"
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.makedirs:9
msgid "If the directory already exists and is not ignore_existing"
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.mkdir:7
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.makedirs:13
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.mkdir:7
msgid "If the directory already exists."
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.normalize:1
msgid "Normalizes path, eliminating double slashes, etc.. :param path: path to normalize"
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.path_exists:1
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.path_exists:1
msgid "Check if path exists"
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.put:1
msgid "Copies a file or a folder from localpath to remotepath. Automatically redirects to putfile or puttree."
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.put:6
msgid "if True follows symbolic links. Default = True"
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.put:8
#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.puttree:8
msgid "if True overwrites remotepath. Default = False"
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.put:11
#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.putfile:9
#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.puttree:11
msgid "if remotepath is not valid"
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.put:12
#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.putfile:10
#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.puttree:12
msgid "if localpath is not valid"
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.putfile:1
msgid "Copies a file from localpath to remotepath. Automatically redirects to putfile or puttree."
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.putfile:6
msgid "if True overwrites remotepath Default = False"
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.putfile:11
#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.puttree:13
msgid "if localpath does not exist"
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.puttree:1
msgid "Copies a folder recursively from localpath to remotepath. Automatically redirects to putfile or puttree."
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.remove:1
msgid "Removes a file at position path."
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.rename:6
msgid "if src/dst is not found"
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.rename:7
msgid "if src/dst is not a valid string"
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.rmdir:1
msgid "Removes a folder at location path. :param path: path to remove"
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.rmtree:1
msgid "Remove tree as rm -r would do"
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.rmtree:3
msgid "a string to path"
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.symlink:1
msgid "Create a symbolic link between the remote source and the remote remotedestination"
msgstr ""

#: ../../../src/aiida/transports/plugins/local.py:docstring of aiida.transports.plugins.local.LocalTransport.symlink:4
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.symlink:4
msgid "remote source. Can contain a pattern."
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh:1
msgid "Plugin for transport over SSH (and SFTP for file transfer)."
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport:1
msgid "Support connection, command execution and data transfer to remote computers via SSH+SFTP."
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.__init__:1
msgid "Initialize the SshTransport class."
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.__init__:3
msgid "the machine to connect to"
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.__init__:4
msgid "(optional, default False) if False, do not load the system host keys"
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.__init__:6
msgid "(optional, default = paramiko.RejectPolicy()) the policy to use for unknown keys"
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.__init__:9
msgid "Other parameters valid for the ssh connect function (see the self._valid_connect_params list) are passed to the connect function (as port, username, password, ...); taken from the accepted paramiko.SSHClient.connect() params."
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.__str__:1
msgid "Return a useful string."
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport._close_proxies:1
msgid "Close all proxy connections (proxy_jump and proxy_command)"
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport._exec_command_internal:6
msgid "For executing commands and waiting for them to finish, use exec_command_wait."
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport._exec_command_internal:11
msgid "(default False) if True, combine stdout and stderr on the same buffer (i.e., stdout). Note: If combine_stderr is True, stderr will always be empty."
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport._exec_command_internal:14
msgid "same meaning of the one used by paramiko."
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport._exec_command_internal:16
msgid "a tuple with (stdin, stdout, stderr, channel), where stdin, stdout and stderr behave as file-like objects, plus the methods provided by paramiko, and channel is a paramiko.Channel object."
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport._exec_cp:1
msgid "Execute the ``cp`` command on the remote machine."
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport._get_proxy_jump_suggestion_string:1
msgid "Return an empty suggestion since Paramiko does not parse ProxyJump from the SSH config."
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport._get_timeout_suggestion_string:3
msgid "Provide 60s as a default timeout for connections."
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport._local_listdir:1
msgid "Acts on the local folder, for the rest, same as listdir"
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport._os_path_split_asunder:1
msgid "Used by makedirs. Takes path (a str) and returns a list deconcatenating the path"
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport._symlink:1
msgid "Wrap SFTP symlink call without breaking API"
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport._symlink:3
msgid "source of link"
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport._symlink:4
msgid "link to create"
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.chdir:1
msgid "Change directory of the SFTP session. Emulated internally by paramiko."
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.chdir:3
msgid "Differently from paramiko, if you pass None to chdir, nothing happens and the cwd is unchanged."
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.chmod:1
msgid "Change permissions to path"
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.chmod:4
msgid "new permission bits (integer)"
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.chown:1
msgid "Change owner permissions of a file."
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.chown:3
msgid "For now, this is not implemented for the SSH transport."
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.close:1
msgid "Close the SFTP channel, and the SSHClient."
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.close:3
msgid "correctly manage exceptions"
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.copy:1
msgid "Copy a file or a directory from remote source to remote destination. Flags used: ``-r``: recursive copy; ``-f``: force, makes the command non interactive; ``-L`` follows symbolic links"
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.copy:5
msgid "file to copy from"
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.copy:6
msgid "file to copy to"
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.copy:7
msgid "if True, copy content instead of copying the symlinks only Default = False."
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.copy:11
msgid "if the cp execution failed."
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.copy:13
msgid "setting dereference equal to True could cause infinite loops."
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.exec_command_wait_bytes:6
msgid "(optional, default=False) see docstring of self._exec_command_internal()"
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.exec_command_wait_bytes:8
msgid "same meaning of paramiko."
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.get:1
msgid "Get a file or folder from remote to local. Redirects to getfile or gettree."
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.get:4
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.getfile:3
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.gettree:3
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.put:5
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.putfile:4
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.puttree:6
msgid "a remote path"
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.get:5
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.getfile:4
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.gettree:4
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.put:4
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.putfile:3
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.puttree:5
msgid "an (absolute) local path"
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.get:6
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.gettree:5
msgid "follow symbolic links. Default = True (default behaviour in paramiko). False is not implemented."
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.get:9
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.getfile:5
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.gettree:8
msgid "if True overwrites files and folders. Default = False"
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.get:12
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.getfile:8
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.gettree:11
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.put:11
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.putfile:8
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.puttree:12
msgid "if local path is invalid"
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.get:13
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.gettree:12
msgid "if the remotepath is not found"
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.get_attribute:1
msgid "Returns the object Fileattribute, specified in aiida.transports Receives in input the path of a given file."
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.getcwd:1
msgid "Return the current working directory for this SFTP session, as emulated by paramiko. If no directory has been set with chdir, this method will return None. But in __enter__ this is set explicitly, so this should never happen within this class."
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.getfile:1
msgid "Get a file from remote to local."
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.gettree:1
msgid "Get a folder recursively from remote to local."
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.gotocomputer_command:1
msgid "Specific gotocomputer string to connect to a given remote computer via ssh and directly go to the calculation folder."
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.isdir:1
msgid "Return True if the given path is a directory, False otherwise. Return False also if the path does not exist."
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.isfile:1
msgid "Return True if the given path is a file, False otherwise. Return False also if the path does not exist."
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.listdir:1
msgid "Get the list of files at path."
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.listdir:3
msgid "default = '.'"
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.listdir:4
msgid "returns the list of files matching pattern. Unix only. (Use to emulate ``ls *`` for example)"
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.lstat:1
msgid "Retrieve information about a file on the remote system, without following symbolic links (shortcuts). This otherwise behaves exactly the same as `stat`."
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.lstat:5
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.stat:8
msgid "the filename to stat"
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.lstat:7
#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.stat:10
msgid "a `paramiko.sftp_attr.SFTPAttributes` object containing attributes about the given file."
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.makedirs:5
msgid "NOTE: since os.path.split uses the separators as the host system (that could be windows), I assume the remote computer is Linux-based and use '/' as separators!"
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.makedirs:9
msgid "directory to create (string)"
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.makedirs:10
msgid "if set to true, it doesn't give any error if the leaf directory does already exist (bool)"
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.normalize:1
msgid "Returns the normalized path (removing double slashes, etc...)"
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.open:1
msgid "Open a SSHClient to the machine possibly using the parameters given in the __init__."
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.open:4
msgid "Also opens a sftp channel, ready to be used. The current working directory is set explicitly, so it is not None."
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.put:1
msgid "Put a file or a folder from local to remote. Redirects to putfile or puttree."
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.put:6
msgid "follow symbolic links (boolean). Default = True (default behaviour in paramiko). False is not implemented."
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.put:8
msgid "if True overwrites files and folders (boolean). Default = False."
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.put:12
msgid "if the localpath does not exist"
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.putfile:1
msgid "Put a file from local to remote."
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.putfile:5
msgid "if True overwrites files and folders (boolean). Default = True."
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.putfile:9
msgid "if the localpath does not exist, or unintentionally overwriting"
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.puttree:1
msgid "Put a folder recursively from local to remote."
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.puttree:3
msgid "By default, overwrite."
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.puttree:7
msgid "follow symbolic links (boolean) Default = True (default behaviour in paramiko). False is not implemented."
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.puttree:9
msgid "if True overwrites files and folders (boolean). Default = True"
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.puttree:13
msgid "if the localpath does not exist, or trying to overwrite"
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.puttree:14
msgid "if remotepath is invalid"
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.puttree:16
msgid "setting dereference equal to True could cause infinite loops. see os.walk() documentation"
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.remove:1
msgid "Remove a single file at 'path'"
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.rename:7
msgid "if sroldpathc/newpath is not a valid string"
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.rmdir:1
msgid "Remove the folder named 'path' if empty."
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.rmtree:1
msgid "Remove a file or a directory at path, recursively Flags used: -r: recursive copy; -f: force, makes the command non interactive;"
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.rmtree:4
msgid "remote path to delete"
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.rmtree:6
msgid "if the rm execution failed."
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.SshTransport.stat:1
msgid "Retrieve information about a file on the remote system.  The return value is an object whose attributes correspond to the attributes of Python's ``stat`` structure as returned by ``os.stat``, except that it contains fewer fields. The fields supported are: ``st_mode``, ``st_size``, ``st_uid``, ``st_gid``, ``st_atime``, and ``st_mtime``."
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.convert_to_bool:1
msgid "Convert a string passed in the CLI to a valid bool."
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.convert_to_bool:3
msgid "the parsed bool value."
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.convert_to_bool:4
msgid "If the value is not parsable as a bool"
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.parse_sshconfig:1
msgid "Return the ssh configuration for a given computer name."
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.parse_sshconfig:3
msgid "This parses the ``.ssh/config`` file in the home directory and returns the part of configuration of the given computer name."
msgstr ""

#: ../../../src/aiida/transports/plugins/ssh.py:docstring of aiida.transports.plugins.ssh.parse_sshconfig:6
msgid "the computer name for which we want the configuration."
msgstr ""

#: ../../source/reference/apidoc/aiida.workflows.rst:2
msgid "aiida.workflows package"
msgstr ""

#: ../../source/reference/apidoc/aiida.workflows.arithmetic.rst:2
msgid "aiida.workflows.arithmetic package"
msgstr ""

#: ../../../src/aiida/workflows/arithmetic/add_multiply.py:docstring of aiida.workflows.arithmetic.add_multiply:1
msgid "Basic calcfunction-based workflows for demonstration purposes."
msgstr ""

#: ../../../src/aiida/workflows/arithmetic/add_multiply.py:docstring of aiida.workflows.arithmetic.add_multiply.add_multiply:1
msgid "Add two numbers and multiply it with a third."
msgstr ""

#: ../../../src/aiida/workflows/arithmetic/multiply_add.py:docstring of aiida.workflows.arithmetic.multiply_add:1
msgid "Implementation of the MultiplyAddWorkChain for testing and demonstration purposes."
msgstr ""

#: ../../../src/aiida/workflows/arithmetic/multiply_add.py:docstring of aiida.workflows.arithmetic.multiply_add.MultiplyAddWorkChain:1
msgid "WorkChain to multiply two numbers and add a third, for testing and demonstration purposes."
msgstr ""

#: ../../../src/aiida/workflows/arithmetic/multiply_add.py:docstring of aiida.workflows.arithmetic.multiply_add.MultiplyAddWorkChain.add:1
msgid "Add two numbers using the `ArithmeticAddCalculation` calculation job plugin."
msgstr ""

#: ../../../src/aiida/workflows/arithmetic/multiply_add.py:docstring of aiida.workflows.arithmetic.multiply_add.MultiplyAddWorkChain.define:1
msgid "Specify inputs and outputs."
msgstr ""

#: ../../../src/aiida/workflows/arithmetic/multiply_add.py:docstring of aiida.workflows.arithmetic.multiply_add.MultiplyAddWorkChain.multiply:1
msgid "Multiply two integers."
msgstr ""

#: ../../../src/aiida/workflows/arithmetic/multiply_add.py:docstring of aiida.workflows.arithmetic.multiply_add.MultiplyAddWorkChain.result:1
msgid "Add the result to the outputs."
msgstr ""

#: ../../../src/aiida/workflows/arithmetic/multiply_add.py:docstring of aiida.workflows.arithmetic.multiply_add.MultiplyAddWorkChain.validate_result:1
msgid "Make sure the result is not negative."
msgstr ""

#: ../../source/reference/command_line.rst:5
msgid "AiiDA Command Line"
msgstr ""

#: ../../source/reference/command_line.rst:10
msgid "Commands"
msgstr ""

#: ../../source/reference/command_line.rst:11
msgid "Below is a list with all available subcommands."
msgstr ""

#: ../../source/reference/command_line.rst:16
msgid "``verdi archive``"
msgstr ""

#: ../../source/reference/command_line.rst:38
msgid "``verdi calcjob``"
msgstr ""

#: ../../source/reference/command_line.rst:63
msgid "``verdi code``"
msgstr ""

#: ../../source/reference/command_line.rst:91
msgid "``verdi computer``"
msgstr ""

#: ../../source/reference/command_line.rst:118
msgid "``verdi config``"
msgstr ""

#: ../../source/reference/command_line.rst:142
msgid "``verdi daemon``"
msgstr ""

#: ../../source/reference/command_line.rst:167
msgid "``verdi data``"
msgstr ""

#: ../../source/reference/command_line.rst:184
msgid "``verdi database``"
msgstr ""

#: ../../source/reference/command_line.rst:207
msgid "``verdi devel``"
msgstr ""

#: ../../source/reference/command_line.rst:230
msgid "``verdi group``"
msgstr ""

#: ../../source/reference/command_line.rst:258
msgid "``verdi help``"
msgstr ""

#: ../../source/reference/command_line.rst:273
msgid "``verdi node``"
msgstr ""

#: ../../source/reference/command_line.rst:300
msgid "``verdi plugin``"
msgstr ""

#: ../../source/reference/command_line.rst:318
msgid "``verdi process``"
msgstr ""

#: ../../source/reference/command_line.rst:345
msgid "``verdi profile``"
msgstr ""

#: ../../source/reference/command_line.rst:367
msgid "``verdi quicksetup``"
msgstr ""

#: ../../source/reference/command_line.rst:420
msgid "``verdi restapi``"
msgstr ""

#: ../../source/reference/command_line.rst:444
msgid "``verdi run``"
msgstr ""

#: ../../source/reference/command_line.rst:468
msgid "``verdi setup``"
msgstr ""

#: ../../source/reference/command_line.rst:520
msgid "``verdi shell``"
msgstr ""

#: ../../source/reference/command_line.rst:540
msgid "``verdi status``"
msgstr ""

#: ../../source/reference/command_line.rst:557
msgid "``verdi storage``"
msgstr ""

#: ../../source/reference/command_line.rst:579
msgid "``verdi tui``"
msgstr ""

#: ../../source/reference/command_line.rst:594
msgid "``verdi user``"
msgstr ""

#: ../../source/reference/index.rst:3
msgid "Reference"
msgstr ""

#: ../../source/reference/rest_api.rst:5
msgid "AiiDA REST API"
msgstr ""

#: ../../source/reference/rest_api.rst:7
msgid "AiiDA's `RESTful <https://en.wikipedia.org/wiki/Representational_state_transfer>`_ `API <https://en.wikipedia.org/wiki/Application_programming_interface>`_ is implemented using the `Flask RESTful framework <https://flask-restful.readthedocs.io/en/latest/>`_ and returns responses in `JSON <https://www.json.org/json-en.html>`_ format."
msgstr ""

#: ../../source/reference/rest_api.rst:9
msgid "To use AiiDA's REST API, you must install this component during the AiiDA installation:"
msgstr ""

#: ../../source/reference/rest_api.rst:15
msgid "Then, the REST service can be started with:"
msgstr ""

#: ../../source/reference/rest_api.rst:21
msgid "See :ref:`here <reference:command-line:verdi-restapi>` for more details."
msgstr ""

#: ../../source/reference/rest_api.rst:26
msgid "Available endpoints and responses"
msgstr ""

#: ../../source/reference/rest_api.rst:28
msgid "In order to obtain a list of all available endpoints, query the API base URL or the `/server/endpoints` endpoint::"
msgstr ""

#: ../../source/reference/rest_api.rst:33
msgid "The HTTP response of the REST API consists of a status code, a header, and a JSON object."
msgstr ""

#: ../../source/reference/rest_api.rst:35
msgid "Possible status codes are:"
msgstr ""

#: ../../source/reference/rest_api.rst:37
msgid "200 for successful requests."
msgstr ""

#: ../../source/reference/rest_api.rst:38
msgid "400 for bad requests. The JSON object contains an error message describing the issue with the request."
msgstr ""

#: ../../source/reference/rest_api.rst:40
msgid "500 for a generic internal server error. The JSON object contains a generic error message."
msgstr ""

#: ../../source/reference/rest_api.rst:42
msgid "404 for invalid URL. The request does not match any resource, and no JSON is returned."
msgstr ""

#: ../../source/reference/rest_api.rst:45
msgid "The header is a standard HTTP response header with the additional custom fields"
msgstr ""

#: ../../source/reference/rest_api.rst:47
msgid "``X-Total-Counts`` and"
msgstr ""

#: ../../source/reference/rest_api.rst:48
msgid "``Link`` (only if paginated results are required, see the Pagination section)."
msgstr ""

#: ../../source/reference/rest_api.rst:50
msgid "The ``data`` field of the JSON object contains the main payload returned by the API. The JSON object further contains information on the request in the ``method``, ``url``, ``url_root``, ``path``, ``query_string``, and ``resource_type`` fields."
msgstr ""

#: ../../source/reference/rest_api.rst:56
msgid "Nodes"
msgstr ""

#: ../../source/reference/rest_api.rst:58
msgid "Get a list of |Node| objects."
msgstr ""

#: ../../source/reference/rest_api.rst:60
#: ../../source/reference/rest_api.rst:108
#: ../../source/reference/rest_api.rst:160
#: ../../source/reference/rest_api.rst:189
#: ../../source/reference/rest_api.rst:241
#: ../../source/reference/rest_api.rst:278
#: ../../source/reference/rest_api.rst:330
#: ../../source/reference/rest_api.rst:367
#: ../../source/reference/rest_api.rst:406
#: ../../source/reference/rest_api.rst:435
#: ../../source/reference/rest_api.rst:465
#: ../../source/reference/rest_api.rst:491
#: ../../source/reference/rest_api.rst:519
#: ../../source/reference/rest_api.rst:544
#: ../../source/reference/rest_api.rst:590
#: ../../source/reference/rest_api.rst:605
#: ../../source/reference/rest_api.rst:622
#: ../../source/reference/rest_api.rst:650
#: ../../source/reference/rest_api.rst:694
#: ../../source/reference/rest_api.rst:748
#: ../../source/reference/rest_api.rst:787
#: ../../source/reference/rest_api.rst:825
#: ../../source/reference/rest_api.rst:860
#: ../../source/reference/rest_api.rst:904
#: ../../source/reference/rest_api.rst:940
msgid "REST URL::"
msgstr ""

#: ../../source/reference/rest_api.rst:64
#: ../../source/reference/rest_api.rst:112
#: ../../source/reference/rest_api.rst:164
#: ../../source/reference/rest_api.rst:193
#: ../../source/reference/rest_api.rst:245
#: ../../source/reference/rest_api.rst:282
#: ../../source/reference/rest_api.rst:334
#: ../../source/reference/rest_api.rst:371
#: ../../source/reference/rest_api.rst:410
#: ../../source/reference/rest_api.rst:439
#: ../../source/reference/rest_api.rst:469
#: ../../source/reference/rest_api.rst:495
#: ../../source/reference/rest_api.rst:523
#: ../../source/reference/rest_api.rst:548
#: ../../source/reference/rest_api.rst:594
#: ../../source/reference/rest_api.rst:609
#: ../../source/reference/rest_api.rst:626
#: ../../source/reference/rest_api.rst:654
#: ../../source/reference/rest_api.rst:698
#: ../../source/reference/rest_api.rst:752
#: ../../source/reference/rest_api.rst:791
#: ../../source/reference/rest_api.rst:829
#: ../../source/reference/rest_api.rst:864
#: ../../source/reference/rest_api.rst:908
#: ../../source/reference/rest_api.rst:944
msgid "Description:"
msgstr ""

#: ../../source/reference/rest_api.rst:66
msgid "Returns the list of two |Node| objects (``limit=2``) starting from 9th row (``offset=8``) of the database table and the list will be ordered by ``id`` in descending order."
msgstr ""

#: ../../source/reference/rest_api.rst:68
#: ../../source/reference/rest_api.rst:117
#: ../../source/reference/rest_api.rst:168
#: ../../source/reference/rest_api.rst:197
#: ../../source/reference/rest_api.rst:249
#: ../../source/reference/rest_api.rst:286
#: ../../source/reference/rest_api.rst:338
#: ../../source/reference/rest_api.rst:375
#: ../../source/reference/rest_api.rst:414
#: ../../source/reference/rest_api.rst:443
#: ../../source/reference/rest_api.rst:473
#: ../../source/reference/rest_api.rst:499
#: ../../source/reference/rest_api.rst:527
#: ../../source/reference/rest_api.rst:552
#: ../../source/reference/rest_api.rst:598
#: ../../source/reference/rest_api.rst:613
#: ../../source/reference/rest_api.rst:630
#: ../../source/reference/rest_api.rst:658
#: ../../source/reference/rest_api.rst:703
#: ../../source/reference/rest_api.rst:756
#: ../../source/reference/rest_api.rst:795
#: ../../source/reference/rest_api.rst:833
#: ../../source/reference/rest_api.rst:868
#: ../../source/reference/rest_api.rst:912
msgid "Response::"
msgstr ""

#: ../../source/reference/rest_api.rst:106
msgid "Get a list of all nodes with attribute called ``pbc1``:"
msgstr ""

#: ../../source/reference/rest_api.rst:114
msgid "Returns the list of |Node| objects. Every node object contains value of attribute called ``pbc1`` if present otherwise ``null``."
msgstr ""

#: ../../source/reference/rest_api.rst:158
msgid "Get a list of all available |Node| types from the database."
msgstr ""

#: ../../source/reference/rest_api.rst:166
msgid "Returns the list of full_types from database."
msgstr ""

#: ../../source/reference/rest_api.rst:187
msgid "Get a list of all available download formats."
msgstr ""

#: ../../source/reference/rest_api.rst:195
msgid "Returns the list of available download formats."
msgstr ""

#: ../../source/reference/rest_api.rst:239
msgid "Get the details of a single |Node| object."
msgstr ""

#: ../../source/reference/rest_api.rst:247
msgid "Returns the details of the |Node| object with ``uuid=\"12f95e1c...\"``."
msgstr ""

#: ../../source/reference/rest_api.rst:276
msgid "Get the list of incoming of a specific |Node|."
msgstr ""

#: ../../source/reference/rest_api.rst:284
msgid "Returns the list of the first two input nodes (``limit=2``) of the |Node| object with ``uuid=\"de83b#...\"``."
msgstr ""

#: ../../source/reference/rest_api.rst:328
msgid "Filter the incoming/outgoing of a |Node| by their full type."
msgstr ""

#: ../../source/reference/rest_api.rst:336
msgid "Returns the list of the *dict* incoming nodes of the |Node| object with ``uuid=\"de83b1...\"``."
msgstr ""

#: ../../source/reference/rest_api.rst:373
msgid "Returns the list of the *dict* outgoing nodes of the |Node| object with ``uuid=\"de83b1...\"``."
msgstr ""

#: ../../source/reference/rest_api.rst:404
msgid "Getting the list of the attributes/extras of a specific |Node|."
msgstr ""

#: ../../source/reference/rest_api.rst:412
msgid "Returns the list of all attributes of the |Node| object with ``uuid=\"ffe11...\"``."
msgstr ""

#: ../../source/reference/rest_api.rst:441
msgid "Returns the list of all the extras of the |Node| object with ``uuid=\"ffe11...\"``."
msgstr ""

#: ../../source/reference/rest_api.rst:463
msgid "Getting a user-defined list of attributes/extras of a specific |Node|."
msgstr ""

#: ../../source/reference/rest_api.rst:471
msgid "Returns a list of the attributes ``append_text`` and ``is_local`` of the |Node| object with ``uuid=\"ffe11...\"``."
msgstr ""

#: ../../source/reference/rest_api.rst:497
msgid "Returns a list of the extras ``trialBool`` and ``trialInt`` of the |Node| object with ``uuid=\"ffe11...\"``."
msgstr ""

#: ../../source/reference/rest_api.rst:517
msgid "Get comments of specific |Node|."
msgstr ""

#: ../../source/reference/rest_api.rst:525
msgid "Returns comments of the given |Node|."
msgstr ""

#: ../../source/reference/rest_api.rst:542
msgid "Get list of all the files/directories from the repository of a specific |Node|."
msgstr ""

#: ../../source/reference/rest_api.rst:550
msgid "Returns a list of all the files/directories from node repository"
msgstr ""

#: ../../source/reference/rest_api.rst:588
msgid "Download a file from the repository of a |Node|."
msgstr ""

#: ../../source/reference/rest_api.rst:596
msgid "Downloads the file ``aiida.in`` from node repository"
msgstr ""

#: ../../source/reference/rest_api.rst:615
msgid "There are specific download formats (check ``nodes/download_formats`` endpoint) available to download different types of nodes."
msgstr ""

#: ../../source/reference/rest_api.rst:603
msgid "This endpoint is used to download file in given format."
msgstr ""

#: ../../source/reference/rest_api.rst:611
msgid "Downloads structure node of uuid=fafdsf in ``xsf`` format"
msgstr ""

#: ../../source/reference/rest_api.rst:620
msgid "Get the report of a |ProcessNode|."
msgstr ""

#: ../../source/reference/rest_api.rst:628
msgid "Returns report of process of ``uuid=\"8b95cd85-....\"``"
msgstr ""

#: ../../source/reference/rest_api.rst:646
msgid "CalcJobs"
msgstr ""

#: ../../source/reference/rest_api.rst:648
msgid "Get a list of input or output files of given |CalcJobNode|."
msgstr ""

#: ../../source/reference/rest_api.rst:656
msgid "Returns a list of all input files of given |CalcJobNode| of ``uuid=\"sffs241j-....\"``"
msgstr ""

#: ../../source/reference/rest_api.rst:690
msgid "Computers"
msgstr ""

#: ../../source/reference/rest_api.rst:692
msgid "Get a list of |Computer| objects."
msgstr ""

#: ../../source/reference/rest_api.rst:700
msgid "Returns the list of three |Computer| objects (``limit=3``) starting from the 3rd row (``offset=2``) of the database table. The list will be ordered by ascending values of ``id``."
msgstr ""

#: ../../source/reference/rest_api.rst:746
msgid "Get details of a single |Computer| object:"
msgstr ""

#: ../../source/reference/rest_api.rst:754
msgid "Returns the details of the |Computer| object ``uuid=\"5d490d77-638d...\"``."
msgstr ""

#: ../../source/reference/rest_api.rst:783
msgid "Users"
msgstr ""

#: ../../source/reference/rest_api.rst:785
msgid "Getting a list of the |User| s"
msgstr ""

#: ../../source/reference/rest_api.rst:793
msgid "Returns a list of all the |User| objects."
msgstr ""

#: ../../source/reference/rest_api.rst:823
msgid "Getting a list of |User| s whose first name starts with a given string"
msgstr ""

#: ../../source/reference/rest_api.rst:831
msgid "Returns a lists of the |User| objects whose first name starts with ``\"aii\"``, regardless the case of the characters."
msgstr ""

#: ../../source/reference/rest_api.rst:856
msgid "Groups"
msgstr ""

#: ../../source/reference/rest_api.rst:858
msgid "Getting a list of |Group| s"
msgstr ""

#: ../../source/reference/rest_api.rst:866
msgid "Returns the list of ten |Group| objects (``limit=10``) starting from the 1st row of the database table (``offset=0``) and the list will be ordered by ``user_id`` in descending order."
msgstr ""

#: ../../source/reference/rest_api.rst:902
msgid "Getting the details of a specific group"
msgstr ""

#: ../../source/reference/rest_api.rst:910
msgid "Returns the details of the |Group| object with ``uuid=\"a6e5b...\"``."
msgstr ""

#: ../../source/reference/rest_api.rst:938
msgid "Querybuilder"
msgstr ""

#: ../../source/reference/rest_api.rst:946
msgid "Posts a query to the database. The content of the query is passed in a attached JSON file."
msgstr ""

#: ../../source/reference/rest_api.rst:948
msgid "To use this endpoint, you need a http operator that allows to pass attachments. We will demonstrate two options, the `HTTPie <https://httpie.io/>`_ (to use in the terminal) and the python library `Requests <https://requests.readthedocs.io/en/latest/>`_ (to use in python)."
msgstr ""

#: ../../source/reference/rest_api.rst:951
msgid "Option 1: HTTPie"
msgstr ""

#: ../../source/reference/rest_api.rst:953
msgid "Install `HTTPie <https://httpie.io/>`_ by typing in the terminal:"
msgstr ""

#: ../../source/reference/rest_api.rst:959
msgid "Then execute the REST API call with"
msgstr ""

#: ../../source/reference/rest_api.rst:965
msgid "where ``my_query.json`` is the file containing the query dictionary of in the json format."
msgstr ""

#: ../../source/reference/rest_api.rst:967
msgid "Response:"
msgstr ""

#: ../../source/reference/rest_api.rst:1058
msgid "The easiest way to construct the query json file is by using the :ref:`QueryBuilder <topics:database:advancedquery>` from AiiDA as we will demonstrate next. Open a ``verdi shell`` section:"
msgstr ""

#: ../../source/reference/rest_api.rst:1065
msgid "Build your query and save it in a file:"
msgstr ""

#: ../../source/reference/rest_api.rst:1081
msgid "Check the content of the ``my_query.json``:"
msgstr ""

#: ../../source/reference/rest_api.rst:1111
msgid "Option 2: Resquests library (all python approach)"
msgstr ""

#: ../../source/reference/rest_api.rst:1113
msgid "Here is a short example on how to do it in python:"
msgstr ""

#: ../../source/reference/rest_api.rst:1132
msgid "One should then have the same response as before."
msgstr ""

#: ../../source/reference/rest_api.rst:1138
msgid "Pagination"
msgstr ""

#: ../../source/reference/rest_api.rst:1140
msgid "Pages of 20 results each are accessed by appending ``/page/2`` (2nd page) to the URL path. The page limit can be controlled via the ``perpage=(PERPAGE)`` query string (maximum page limit is 400). Examples::"
msgstr ""

#: ../../source/reference/rest_api.rst:1148
msgid "If no page number is specified, the system redirects the request to page 1. When pagination is used, the **header** of the response contains two more non-empty fields:"
msgstr ""

#: ../../source/reference/rest_api.rst:1151
msgid "``X-Total-Counts`` (custom field): the total number of results returned by the query, i.e. the sum of the results of all pages."
msgstr ""

#: ../../source/reference/rest_api.rst:1152
msgid "``Links``: links to the first, previous, next, and last page. Suppose that you send a request whose results fill 8 pages. Then the value of the ``Links`` field would look like::"
msgstr ""

#: ../../source/reference/rest_api.rst:1160
msgid "Besides pagination, the number of results can also be controlled using the ``limit`` and ``offset`` filters, see :ref:`below <reference:rest-api:filtering:unique>`."
msgstr ""

#: ../../source/reference/rest_api.rst:1166
msgid "Filtering results"
msgstr ""

#: ../../source/reference/rest_api.rst:1168
msgid "The filter query string is formed by one or more **fields**, separated by the special character ``&``."
msgstr ""

#: ../../source/reference/rest_api.rst:1170
msgid "Each field has the form (``key``)(``operator``)(``value``)."
msgstr ""

#: ../../source/reference/rest_api.rst:1172
msgid "Fields can only contain alphanumeric characters plus ``_``, and the first character cannot be a number (similar to Python variable names)."
msgstr ""

#: ../../source/reference/rest_api.rst:1173
msgid "In the following *id* is a synonym for the *PK* used in other sections of the documentation."
msgstr ""

#: ../../source/reference/rest_api.rst:1178
msgid "Filter keys"
msgstr ""

#: ../../source/reference/rest_api.rst:1180
msgid "Unique filters can be specified only once in a query string. All of them must be followed by the operator ``=``."
msgstr ""

#: ../../source/reference/rest_api.rst:1183
msgid "Unique filters"
msgstr ""

#: ../../source/reference/rest_api.rst:1186
#: ../../source/reference/rest_api.rst:1244
msgid "Filter key"
msgstr ""

#: ../../source/reference/rest_api.rst:1187
#: ../../source/reference/rest_api.rst:1429
msgid "Description"
msgstr ""

#: ../../source/reference/rest_api.rst:1189
msgid "``limit``"
msgstr ""

#: ../../source/reference/rest_api.rst:1190
msgid "Number of results (integer)."
msgstr ""

#: ../../source/reference/rest_api.rst:1192
msgid "``offset``"
msgstr ""

#: ../../source/reference/rest_api.rst:1193
msgid "Skips the first ``offset`` results (integer)."
msgstr ""

#: ../../source/reference/rest_api.rst:1195
msgid "``perpage``"
msgstr ""

#: ../../source/reference/rest_api.rst:1196
msgid "How many results to show per page (integer)."
msgstr ""

#: ../../source/reference/rest_api.rst:1198
msgid "``orderby``"
msgstr ""

#: ../../source/reference/rest_api.rst:1199
msgid "``+<property>`` for ascending order and ``-<property>`` for descending order (``<property`` defaults to ascending). Ascending (descending) order for strings corresponds to alphabetical (reverse-alphabetical) order, whereas for datetime objects it corresponds to chronological (reverse-chronological) order. Examples::"
msgstr ""

#: ../../source/reference/rest_api.rst:1207
msgid "``attributes_filter``"
msgstr ""

#: ../../source/reference/rest_api.rst:1208
msgid "A comma-separated list of attributes to return. Use together with ``attributes=true``. Available in the endpoints ``/contents/attributes`` and ``/nodes``. Example::"
msgstr ""

#: ../../source/reference/rest_api.rst:1215
msgid "``extras_filter``"
msgstr ""

#: ../../source/reference/rest_api.rst:1216
msgid "Similar to ``attributes_filter`` but for extras. It is used in the endpoints ``/contents/extras`` and ``/nodes``."
msgstr ""

#: ../../source/reference/rest_api.rst:1218
#: ../../source/reference/rest_api.rst:1248
msgid "``attributes``"
msgstr ""

#: ../../source/reference/rest_api.rst:1219
msgid "Pass ``true`` in order to return attributes in the ``/nodes`` endpoint (excluded by default)."
msgstr ""

#: ../../source/reference/rest_api.rst:1221
msgid "``extras``"
msgstr ""

#: ../../source/reference/rest_api.rst:1222
msgid "Pass ``true`` in order to return extras in the ``/nodes`` endpoint (excluded by default)."
msgstr ""

#: ../../source/reference/rest_api.rst:1224
msgid "``download_format``"
msgstr ""

#: ../../source/reference/rest_api.rst:1225
msgid "to specify download format in ``/download`` endpoint."
msgstr ""

#: ../../source/reference/rest_api.rst:1227
msgid "``download``"
msgstr ""

#: ../../source/reference/rest_api.rst:1228
msgid "in ``/download`` endpoint, if ``download=false`` it displays the content in the browser instead of downloading a file."
msgstr ""

#: ../../source/reference/rest_api.rst:1230
msgid "``filename``"
msgstr ""

#: ../../source/reference/rest_api.rst:1231
msgid "this filter is used to pass file name in ``/repo/list`` and ``/repo/contents`` endpoint."
msgstr ""

#: ../../source/reference/rest_api.rst:1233
msgid "``tree_in_limit``"
msgstr ""

#: ../../source/reference/rest_api.rst:1234
msgid "specifies the limit on tree incoming nodes."
msgstr ""

#: ../../source/reference/rest_api.rst:1236
msgid "``tree_out_limit``"
msgstr ""

#: ../../source/reference/rest_api.rst:1237
msgid "specifies the limit on tree outgoing nodes."
msgstr ""

#: ../../source/reference/rest_api.rst:1239
msgid "Regular filters can be compounded, requiring all specified filters to apply."
msgstr ""

#: ../../source/reference/rest_api.rst:1241
msgid "Regular filters"
msgstr ""

#: ../../source/reference/rest_api.rst:1245
#: ../../source/reference/rest_api.rst:1428
msgid "Value type"
msgstr ""

#: ../../source/reference/rest_api.rst:1246
msgid "Supported resources"
msgstr ""

#: ../../source/reference/rest_api.rst:1249
#: ../../source/reference/rest_api.rst:1255
#: ../../source/reference/rest_api.rst:1258
#: ../../source/reference/rest_api.rst:1261
#: ../../source/reference/rest_api.rst:1264
#: ../../source/reference/rest_api.rst:1267
#: ../../source/reference/rest_api.rst:1273
#: ../../source/reference/rest_api.rst:1276
#: ../../source/reference/rest_api.rst:1279
#: ../../source/reference/rest_api.rst:1285
#: ../../source/reference/rest_api.rst:1288
#: ../../source/reference/rest_api.rst:1291
#: ../../source/reference/rest_api.rst:1294
#: ../../source/reference/rest_api.rst:1297
#: ../../source/reference/rest_api.rst:1303
msgid "string"
msgstr ""

#: ../../source/reference/rest_api.rst:1251
msgid "``ctime``"
msgstr ""

#: ../../source/reference/rest_api.rst:1252
#: ../../source/reference/rest_api.rst:1282
msgid "datetime"
msgstr ""

#: ../../source/reference/rest_api.rst:1254
msgid "``description``"
msgstr ""

#: ../../source/reference/rest_api.rst:1256
#: ../../source/reference/rest_api.rst:1304
msgid "computers, groups, nodes"
msgstr ""

#: ../../source/reference/rest_api.rst:1257
msgid "``email`` \\*"
msgstr ""

#: ../../source/reference/rest_api.rst:1260
msgid "``first_name``"
msgstr ""

#: ../../source/reference/rest_api.rst:1263
msgid "``full_type``"
msgstr ""

#: ../../source/reference/rest_api.rst:1266
msgid "``hostname``"
msgstr ""

#: ../../source/reference/rest_api.rst:1269
msgid "``id``"
msgstr ""

#: ../../source/reference/rest_api.rst:1270
#: ../../source/reference/rest_api.rst:1300
msgid "integer"
msgstr ""

#: ../../source/reference/rest_api.rst:1271
msgid "users, computers, groups, nodes"
msgstr ""

#: ../../source/reference/rest_api.rst:1272
msgid "``institution``"
msgstr ""

#: ../../source/reference/rest_api.rst:1275
msgid "``label``"
msgstr ""

#: ../../source/reference/rest_api.rst:1277
msgid "groups, nodes"
msgstr ""

#: ../../source/reference/rest_api.rst:1278
msgid "``last_name``"
msgstr ""

#: ../../source/reference/rest_api.rst:1281
msgid "``mtime``"
msgstr ""

#: ../../source/reference/rest_api.rst:1284
msgid "``name``"
msgstr ""

#: ../../source/reference/rest_api.rst:1287
msgid "``node_type``"
msgstr ""

#: ../../source/reference/rest_api.rst:1290
msgid "``scheduler_type``"
msgstr ""

#: ../../source/reference/rest_api.rst:1293
msgid "``transport_type``"
msgstr ""

#: ../../source/reference/rest_api.rst:1296
msgid "``type_string``"
msgstr ""

#: ../../source/reference/rest_api.rst:1299
msgid "``user_id``"
msgstr ""

#: ../../source/reference/rest_api.rst:1302
msgid "``uuid``"
msgstr ""

#: ../../source/reference/rest_api.rst:1307
msgid "\\* Key filtered out in response of the ``/users/`` endpoint privacy reasons."
msgstr ""

#: ../../source/reference/rest_api.rst:1309
msgid "Node types are specified by a string that defines their position in the AiiDA source tree, ending with a dot. Examples:"
msgstr ""

#: ../../source/reference/rest_api.rst:1312
msgid "``node_type=\"data.core.code.Code.\"`` selects only objects of type |Code|."
msgstr ""

#: ../../source/reference/rest_api.rst:1313
msgid "``node_type=\"data.core.remote.RemoteData.\"`` selects only objects of type :py:class:`~aiida.orm.RemoteData`."
msgstr ""

#: ../../source/reference/rest_api.rst:1315
msgid "When using the *links/incoming* (*links/outgoing*) endpoints in combination with one or more filters, the filters are applied to the incoming (outgoing) nodes of the selected *id*. For example, the request::"
msgstr ""

#: ../../source/reference/rest_api.rst:1320
msgid "would first search for the outgoing of the node with *uuid* starting with \"a67fba41\" and then select only those nodes of full_type *data.core.core.dict.Dict.|*."
msgstr ""

#: ../../source/reference/rest_api.rst:1325
#: ../../source/reference/rest_api.rst:1331
msgid "Filter operators"
msgstr ""

#: ../../source/reference/rest_api.rst:1327
msgid "The operators supported by a specific filter key are uniquely determined by the value type associated with that key."
msgstr ""

#: ../../source/reference/rest_api.rst:1329
msgid "For example, a key that requires a boolean value admits only the identity operator ``=``, whereas an integer value enables the usage of the comparison operators ``=``, ``<``, ``<=``, ``>``, ``>=`` plus the membership operator ``=in=``:"
msgstr ""

#: ../../source/reference/rest_api.rst:1334
msgid "Operator"
msgstr ""

#: ../../source/reference/rest_api.rst:1335
msgid "Meaning"
msgstr ""

#: ../../source/reference/rest_api.rst:1336
msgid "Accepted value types"
msgstr ""

#: ../../source/reference/rest_api.rst:1337
msgid "``=``"
msgstr ""

#: ../../source/reference/rest_api.rst:1338
msgid "identity"
msgstr ""

#: ../../source/reference/rest_api.rst:1339
msgid "integers, strings, bool, datetime"
msgstr ""

#: ../../source/reference/rest_api.rst:1340
msgid "``>``"
msgstr ""

#: ../../source/reference/rest_api.rst:1341
msgid "greater than"
msgstr ""

#: ../../source/reference/rest_api.rst:1342
#: ../../source/reference/rest_api.rst:1345
#: ../../source/reference/rest_api.rst:1348
#: ../../source/reference/rest_api.rst:1351
#: ../../source/reference/rest_api.rst:1360
msgid "integers, strings, datetime"
msgstr ""

#: ../../source/reference/rest_api.rst:1343
msgid "``<``"
msgstr ""

#: ../../source/reference/rest_api.rst:1344
msgid "less than"
msgstr ""

#: ../../source/reference/rest_api.rst:1346
msgid "``>=``"
msgstr ""

#: ../../source/reference/rest_api.rst:1347
msgid "greater than or equal to"
msgstr ""

#: ../../source/reference/rest_api.rst:1349
msgid "``<=``"
msgstr ""

#: ../../source/reference/rest_api.rst:1350
msgid "less than or equal to"
msgstr ""

#: ../../source/reference/rest_api.rst:1352
msgid "``=like=``"
msgstr ""

#: ../../source/reference/rest_api.rst:1353
msgid "pattern matching"
msgstr ""

#: ../../source/reference/rest_api.rst:1354
#: ../../source/reference/rest_api.rst:1357
msgid "strings"
msgstr ""

#: ../../source/reference/rest_api.rst:1355
msgid "``=ilike=``"
msgstr ""

#: ../../source/reference/rest_api.rst:1356
msgid "case-insensitive pattern matching"
msgstr ""

#: ../../source/reference/rest_api.rst:1358
msgid "``=in=``"
msgstr ""

#: ../../source/reference/rest_api.rst:1359
msgid "identity with one element of a list"
msgstr ""

#: ../../source/reference/rest_api.rst:1364
msgid "Pattern matching"
msgstr ""

#: ../../source/reference/rest_api.rst:1366
msgid "The pattern matching operators ``=like=`` and ``=ilike=`` must be followed by the pattern definition, namely, a string where two characters assume special meaning:"
msgstr ""

#: ../../source/reference/rest_api.rst:1368
msgid "``%`` is used to replace an arbitrary sequence of characters, including no characters."
msgstr ""

#: ../../source/reference/rest_api.rst:1369
msgid "``_`` is used to replace one or zero characters."
msgstr ""

#: ../../source/reference/rest_api.rst:1371
msgid "When special characters are required verbatim, escape them by pre-pending a backslash ``\\``."
msgstr ""

#: ../../source/reference/rest_api.rst:1373
msgid "Pattern matching with ``=like=`` and ``=ilike=``"
msgstr ""

#: ../../source/reference/rest_api.rst:1376
msgid "Filter"
msgstr ""

#: ../../source/reference/rest_api.rst:1377
msgid "Matches"
msgstr ""

#: ../../source/reference/rest_api.rst:1378
msgid "Doesn't match"
msgstr ""

#: ../../source/reference/rest_api.rst:1379
msgid "``name=like=\"a%d_\"``"
msgstr ""

#: ../../source/reference/rest_api.rst:1380
#: ../../source/reference/rest_api.rst:1387
#: ../../source/reference/rest_api.rst:1389
msgid "\"aiida\""
msgstr ""

#: ../../source/reference/rest_api.rst:1381
msgid "\"AiiDA\""
msgstr ""

#: ../../source/reference/rest_api.rst:1382
msgid "``name=ilike=\"a%d_\"``"
msgstr ""

#: ../../source/reference/rest_api.rst:1383
msgid "\"aiida\", \"AiiDA\""
msgstr ""

#: ../../source/reference/rest_api.rst:1385
msgid "``name=like=\"a_d_\"``"
msgstr ""

#: ../../source/reference/rest_api.rst:1388
msgid "``name=like=\"aii%d_a\"``"
msgstr ""

#: ../../source/reference/rest_api.rst:1391
msgid "``uuid=like=\"cdfd48%\"``"
msgstr ""

#: ../../source/reference/rest_api.rst:1392
msgid "\"cdfd48f9-7ed2-4969-ba06-09c752b83d2\""
msgstr ""

#: ../../source/reference/rest_api.rst:1394
msgid "``description=like=\"This calculation is %\\% useful\"``"
msgstr ""

#: ../../source/reference/rest_api.rst:1395
msgid "\"This calculation is 100% useful\""
msgstr ""

#: ../../source/reference/rest_api.rst:1399
msgid "Membership"
msgstr ""

#: ../../source/reference/rest_api.rst:1401
msgid "The membership operator ``=in=`` has to be followed by a comma-separated list of values of the same type. The condition is fulfilled if the column value of an object is an element of the list."
msgstr ""

#: ../../source/reference/rest_api.rst:1404
msgid "Examples::"
msgstr ""

#: ../../source/reference/rest_api.rst:1410
msgid "Comparison"
msgstr ""

#: ../../source/reference/rest_api.rst:1412
msgid "The comparison operators ``<``, ``>``, ``<=``, ``>=`` assume natural ordering for integers, (case-insensitive) alphabetical ordering for strings, and chronological ordering for datetime values."
msgstr ""

#: ../../source/reference/rest_api.rst:1414
msgid "Examples:"
msgstr ""

#: ../../source/reference/rest_api.rst:1416
msgid "``http://localhost:5000/api/v4/nodes?id>578`` selects the nodes having an id larger than 578."
msgstr ""

#: ../../source/reference/rest_api.rst:1417
msgid "``http://localhost:5000/api/v4/users/?last_name<=\"m\"`` selects only the users whose last name begins with a character in the range [a-m]."
msgstr ""

#: ../../source/reference/rest_api.rst:1421
#: ../../source/reference/rest_api.rst:1425
msgid "Filter value types"
msgstr ""

#: ../../source/reference/rest_api.rst:1423
msgid "Filter values should be specified as follows:"
msgstr ""

#: ../../source/reference/rest_api.rst:1431
msgid "``bool``"
msgstr ""

#: ../../source/reference/rest_api.rst:1432
msgid "Either ``true`` or ``false`` (lower case)."
msgstr ""

#: ../../source/reference/rest_api.rst:1434
msgid "``datetime``"
msgstr ""

#: ../../source/reference/rest_api.rst:1436
msgid "Datetime objects expressed in the format ``(DATE)T(TIME)(SHIFT)`` where ``(SHIFT)`` is the time difference with respect to the UTC time. This is required to avoid any problem arising from comparing datetime values expressed in different time zones. The formats of each field are:"
msgstr ""

#: ../../source/reference/rest_api.rst:1440
msgid "``YYYY-MM-DD`` for ``(DATE)`` (mandatory)."
msgstr ""

#: ../../source/reference/rest_api.rst:1441
msgid "``HH:MM:SS`` for ``(TIME)`` (optional). The formats ``HH`` and ``HH:MM`` are supported too."
msgstr ""

#: ../../source/reference/rest_api.rst:1442
msgid "``+/-HH:MM`` for ``(SHIFT)`` (optional, if present requires ``(TIME)`` to be specified). The format ``+/-HH`` is allowed too. If no shift is specified UTC time is assumed. The shift format follows the general convention that eastern (western) shifts are positive (negative). The API is unaware of daylight saving times so the user is required to adjust the shift to take them into account."
msgstr ""

#: ../../source/reference/rest_api.rst:1447
msgid "This format is ``ISO-8601`` compliant. Note that date and time fields have to be separated by the character ``T``. Examples::"
msgstr ""

#: ../../source/reference/rest_api.rst:1455
msgid "``integer``"
msgstr ""

#: ../../source/reference/rest_api.rst:1456
msgid "Positive integer numbers."
msgstr ""

#: ../../source/reference/rest_api.rst:1458
msgid "``string``"
msgstr ""

#: ../../source/reference/rest_api.rst:1459
msgid "Text enclosed in double quotes. If the string contains double quotes those have to be escaped as ``\"\"`` (two double quotes). Note that in the unlikely occurrence of a sequence of double quotes you will have to escape it by writing twice as many double quotes."
msgstr ""
