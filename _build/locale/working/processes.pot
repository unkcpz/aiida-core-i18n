# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2019, ECOLE POLYTECHNIQUE FEDERALE DE LAUSANNE (Theory and Simulation of Materials (THEOS) and National Centre for Computational Design and Discovery of Novel Materials (NCCR MARVEL)), Switzerland and ROBERT BOSCH LLC, USA. All rights reserved
# This file is distributed under the same license as the AiiDA package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: AiiDA 1.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-05-15 13:38+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../source/working/processes.rst:5
msgid "Processes"
msgstr ""

#: ../../source/working/processes.rst:7
msgid "Before you start working with processes, make sure you have read and understood the :ref:`basic concept<concepts_processes>`. This section will explain the aspects of working with processes that apply to all the various types of processes. Details that only pertain to a specific sub type of process, will be documented in their respective sections:"
msgstr ""

#: ../../source/working/processes.rst:11
msgid ":ref:`calculation functions<working_calcfunctions>`"
msgstr ""

#: ../../source/working/processes.rst:12
msgid ":ref:`calculation jobs<working_calcjobs>`"
msgstr ""

#: ../../source/working/processes.rst:13
msgid ":ref:`work functions<working_workfunctions>`"
msgstr ""

#: ../../source/working/processes.rst:14
msgid ":ref:`work chains<working_workchains>`"
msgstr ""

#: ../../source/working/processes.rst:16
msgid "Since all of these are types of processes, everything that will be explained in this section, will apply to each and everyone of them. That makes it very useful to read and understand this section well, as the concepts apply so broadly. However, for the same reason, at times this section may feel a bit abstract. It may therefore be advisable to start reading a section on one of the more specific processes listed above first, to get a more concrete example, and then simply refer back here for a more extensive explanation of the details."
msgstr ""

#: ../../source/working/processes.rst:25
msgid "Defining processes"
msgstr ""

#: ../../source/working/processes.rst:30
msgid "Process specification"
msgstr ""

#: ../../source/working/processes.rst:31
msgid "How a process defines the inputs that it requires or can optionally take, depends on the process type. The inputs of :py:class:`~aiida.engine.processes.calcjobs.calcjob.CalcJob` and :py:class:`~aiida.engine.processes.workchains.workchain.WorkChain` are given by the :py:class:`~aiida.engine.processes.process_spec.ProcessSpec` class, which is defined though  the :py:meth:`~aiida.engine.processes.process.Process.define` method. For process functions, the :py:class:`~aiida.engine.processes.process_spec.ProcessSpec` is dynamically generated by the engine from the signature of the decorated function. Therefore, to determine what inputs a process takes, one simply has to look at the process specification in the ``define`` method or the function signature. For the :py:class:`~aiida.engine.processes.calcjobs.calcjob.CalcJob` and :py:class:`~aiida.engine.processes.workchains.workchain.WorkChain` there is also the concept of the :ref:`process builder<working_processes_builder>`, which will allow one to inspect the inputs with tab-completion and help strings in the shell."
msgstr ""

#: ../../source/working/processes.rst:37
msgid "The three most important attributes of the :py:class:`~aiida.engine.processes.process_spec.ProcessSpec` are:"
msgstr ""

#: ../../source/working/processes.rst:39
msgid "``inputs``"
msgstr ""

#: ../../source/working/processes.rst:40
msgid "``outputs``"
msgstr ""

#: ../../source/working/processes.rst:41
msgid "``exit_codes``"
msgstr ""

#: ../../source/working/processes.rst:43
msgid "Through these attributes, one can define what inputs a process takes, what outputs it will produce and what potential exit codes it can return in case of errors. Just by looking at a process specification then, one will know exactly *what* will happen, just not *how* it will happen. The ``inputs`` and ``outputs`` attributes are *namespaces* that contain so called *ports*, each one of which represents a specific input or output. The namespaces can be arbitrarily nested with ports and so are called *port namespaces*. The port and port namespace are implemented by the :py:class:`~plumpy.Port` and :py:class:`~aiida.engine.processes.ports.PortNamespace` class, respectively."
msgstr ""

#: ../../source/working/processes.rst:53
msgid "Ports and Port namespaces"
msgstr ""

#: ../../source/working/processes.rst:54
msgid "To define an input for a process specification, we only need to add a port to the ``inputs`` port namespace, as follows:"
msgstr ""

#: ../../source/working/processes.rst:61
msgid "The ``input`` method, will create an instance of :py:class:`~aiida.engine.processes.ports.InputPort`, a sub class of the base :py:class:`~plumpy.Port`, and will add it to the ``inputs`` port namespace of the spec. Creating an output is just as easy, but one should use the :py:meth:`~plumpy.ProcessSpec.output` method instead:"
msgstr ""

#: ../../source/working/processes.rst:69
msgid "This will cause an instance of :py:class:`~aiida.engine.processes.ports.OutputPort`, also a sub class of the base :py:class:`~plumpy.Port`, to be created and to be added to the ``outputs`` specifcation attribute. Recall, that the ``inputs`` and ``output`` are instances of a :py:class:`~aiida.engine.processes.ports.PortNamespace`, which means that they can contain any port. But the :py:class:`~aiida.engine.processes.ports.PortNamespace` itself is also a port itself, so it can be added to another port namespace, allowing one to create nested port namespaces. Creating a new namespace in for example the inputs namespace is as simple as:"
msgstr ""

#: ../../source/working/processes.rst:79
msgid "This will create a new ``PortNamespace`` named ``namespace`` in the ``inputs`` namespace of the spec. You can create arbitrarily nested namespaces in one statement, by separating them with a ``.`` as shown here:"
msgstr ""

#: ../../source/working/processes.rst:87
msgid "This command will result in the ``PortNamespace`` name ``namespace`` to be nested inside another ``PortNamespace`` called ``nested``."
msgstr ""

#: ../../source/working/processes.rst:91
msgid "Because the period is reserved to denote different nested namespaces, it cannot be used in the name of terminal input and output ports as that could be misinterpreted later as a port nested in a namespace."
msgstr ""

#: ../../source/working/processes.rst:93
msgid "Graphically, this can be visualized as a nested dictionary and will look like the following:"
msgstr ""

#: ../../source/working/processes.rst:103
msgid "The ``outputs`` attribute of the ``ProcessSpec`` is also a ``PortNamespace`` just as the ``inputs``, with the only different that it will create ``OutputPort`` instead of ``InputPort`` instances. Therefore the same concept of nesting through ``PortNamespaces`` applies to the outputs of a ``ProcessSpec``."
msgstr ""

#: ../../source/working/processes.rst:110
msgid "Validation and defaults"
msgstr ""

#: ../../source/working/processes.rst:111
msgid "In the previous section, we saw that the ``ProcessSpec`` uses the ``PortNamespace``, ``InputPort`` and ``OutputPort`` to define the inputs and outputs structure of the ``Process``. The underlying concept that allows this nesting of ports is that the ``PortNamespace``, ``InputPort`` and ``OutputPort``, are all a subclass of :py:class:`~plumpy.ports.Port`. And as different subclasses of the same class, they have more properties and attributes in common, for example related to the concept of validation and default values. All three have the following attributes (with the exception of the ``OutputPort`` not having a ``default`` attribute):"
msgstr ""

#: ../../source/working/processes.rst:116
msgid "``default``"
msgstr ""

#: ../../source/working/processes.rst:117
msgid "``required``"
msgstr ""

#: ../../source/working/processes.rst:118
msgid "``valid_type``"
msgstr ""

#: ../../source/working/processes.rst:119
msgid "``validator``"
msgstr ""

#: ../../source/working/processes.rst:121
msgid "These attributes can all be set upon construction of the port or after the fact, as long as the spec has not been sealed, which means that they can be altered without limit as long as it is within the ``define`` method of the corresponding ``Process``. An example input port that explicitly sets all these attributes is the following:"
msgstr ""

#: ../../source/working/processes.rst:128
msgid "Here we define an input named ``positive_number`` that is not required, if a value is not explicitly passed, the default ``Int(1)`` will be used and if a value *is* passed, it should be of type ``Int`` or ``Float`` and it should be valid according to the ``is_number_positive`` validator. Note that the validator is nothing more than a free function which takes a single argument, being the value that is to be validated and should return ``True`` if that value is valid or ``False`` otherwise, for example:"
msgstr ""

#: ../../source/working/processes.rst:136
msgid "The ``valid_type`` can define a single type, or a tuple of valid types."
msgstr ""

#: ../../source/working/processes.rst:140
msgid "Note that by default all ports are required, but specifying a default value implies that the input is not required and as such specifying ``required=False`` is not necessary in that case. It was added to the example above simply for clarity."
msgstr ""

#: ../../source/working/processes.rst:143
msgid "The validation of input or output values with respect to the specification of the corresponding port, happens at the instantiation of the process and when it is finalized, respectively. If the inputs are invalid, a corresponding exception will be thrown and the process instantiation will fail. When the outputs fail to be validated, likewise an exception will be thrown and the process state will be set to ``Excepted``."
msgstr ""

#: ../../source/working/processes.rst:151
msgid "Dynamic namespaces"
msgstr ""

#: ../../source/working/processes.rst:152
msgid "In the previous section we described the various attributes related to validation and claimed that all the port variants share those attributes, yet we only discussed the ``InputPort`` and ``OutputPort`` explicitly. The statement, however, is still correct and the ``PortNamespace`` has the same attributes. You might then wonder what the meaning is of a ``valid_type`` or ``default`` for a ``PortNamespace`` if all it does is contain ``InputPorts``, ``OutputPorts`` or other ``PortNamespaces``. The answer to this question lies in the ``PortNamespace`` attribute ``dynamic``."
msgstr ""

#: ../../source/working/processes.rst:157
msgid "Often when designing the specification of a ``Process``, we cannot know exactly which inputs we want to be able to pass to the process. However, with the concept of the ``InputPort`` and ``OutputPort`` one *does* need to know exactly, how many value one expects at least, as they do have to be defined. This is where the ``dynamic`` attribute of the ``PortNamespace`` comes in. By default this is set to ``False``, but by setting it to ``True``, one indicates that that namespace can take a number of values that is unknown at the time of definition of the specification. This now explains the meaning of the ``valid_type``, ``validator`` and ``default`` attributes in the context of the ``PortNamespace``. If you do mark a namespace as dynamic, you may still want to limit the set of values that are acceptable, which you can do by specifying the valid type and or validator. The values that will eventually be passed to the port namespace will then be validated according to these rules exactly as a value for a regular input port would be."
msgstr ""

#: ../../source/working/processes.rst:169
msgid "Non storable inputs"
msgstr ""

#: ../../source/working/processes.rst:170
msgid "In principle, the only valid types for inputs and outputs should be instances of a :py:class:`~aiida.orm.nodes.data.data.Data` node, or one of its sub classes, as that is the only data type that can be recorded in the provenance graph as an input or output of a process. However, there are cases where you might want to pass an input to a process, whose provenance you do not care about and therefore would want to pass a non-database storable type anyway."
msgstr ""

#: ../../source/working/processes.rst:175
msgid "AiiDA allows you to break the provenance as to be not too restrictive, but always tries to urge you and guide you in a direction to keep the provenance. There are legitimate reasons to break it regardless, but make sure you think about the implications and whether you are really willing to lose the information."
msgstr ""

#: ../../source/working/processes.rst:178
msgid "For this situation, the ``InputPort`` has the attribute ``non_db``. By default this is set to ``False``, but by setting it to ``True`` the port is marked that the values that are passed to it should not be stored as a node in the provenance graph and linked to the process node. This allows one to pass any normal value that one would also be able to pass to a normal function."
msgstr ""

#: ../../source/working/processes.rst:186
msgid "Automatic input serialization"
msgstr ""

#: ../../source/working/processes.rst:188
msgid "Quite often, inputs which are given as python data types need to be cast to the corresponding AiiDA type before passing them to a process. Doing this manually can be cumbersome, so you can define a function when defining the process specification, which does the conversion automatically. This function, passed as ``serializer`` parameter to ``spec.input``, is invoked if the given input is *not* already an AiiDA type."
msgstr ""

#: ../../source/working/processes.rst:192
msgid "For inputs which are stored in the database (``non_db=False``), the serialization function should return an AiiDA data type. For ``non_db`` inputs, the function must be idempotent because it might be applied more than once."
msgstr ""

#: ../../source/working/processes.rst:195
msgid "The following example work chain takes three inputs ``a``, ``b``, ``c``, and simply returns the given inputs. The :func:`aiida.orm.nodes.data.base.to_aiida_type` function is used as serialization function."
msgstr ""

#: ../../source/working/processes.rst:200
msgid "This work chain can now be called with native Python types, which will automatically converted to AiiDA types by the :func:`aiida.orm.nodes.data.base.to_aiida_type` function. Note that the module which defines the corresponding AiiDA type must be loaded for it to be recognized by :func:`aiida.orm.nodes.data.base.to_aiida_type`."
msgstr ""

#: ../../source/working/processes.rst:205
msgid "Of course, you can also use the serialization feature to perform a more complex serialization of the inputs."
msgstr ""

#: ../../source/working/processes.rst:211
msgid "Exit codes"
msgstr ""

#: ../../source/working/processes.rst:212
msgid "Any ``Process`` most likely will have one or multiple expected failure modes. To clearly communicate to the caller what went wrong, the ``Process`` supports setting its ``exit_status``. This ``exit_status``, a positive integer, is an attribute of the process node and by convention, when it is zero means the process was successful, whereas any other value indicates failure. This concept of an exit code, with a positive integer as the exit status, `is a common concept in programming <https://shapeshed.com/unix-exit-codes/>`_ and a standard way for programs to communicate the result of their execution."
msgstr ""

#: ../../source/working/processes.rst:217
msgid "Potential exit codes for the ``Process`` can be defined through the ``ProcessSpec``, just like inputs and ouputs. Any exit code consists of a positive non-zero integer, a string label to reference it and a more detailed description of the problem that triggers the exit code. Consider the following example:"
msgstr ""

#: ../../source/working/processes.rst:226
msgid "This defines an exit code for the ``Process`` with exit status ``418`` and exit message ``the work chain had an identity crisis``. The string ``ERROR_I_AM_A_TEAPOT`` is a label that the developer can use to reference this particular exit code somewhere in the ``Process`` code itself."
msgstr ""

#: ../../source/working/processes.rst:229
msgid "Whenever a ``Process`` exits through a particular error code, the caller will be able to introspect it through the ``exit_status`` and ``exit_message`` attributes of the node. Assume for example that we ran a ``Process`` that threw the exit code described above, the caller would be able to do the following:"
msgstr ""

#: ../../source/working/processes.rst:240
msgid "This is useful, because the caller can now programmatically, based on the ``exit_status``, decide how to proceed. This is an infinitely more robust way of communcating specific errors to a non-human then parsing text based logs or reports. Additionally, The exit codes make it also very easy to query for failed processes with specific error codes."
msgstr ""

#: ../../source/working/processes.rst:248
msgid "Process metadata"
msgstr ""

#: ../../source/working/processes.rst:250
msgid "Each process, in addition to the normal inputs defined through its process specifcation, can take optional 'metadata'. These metadata differ from inputs in the sense that they are not nodes that will show up as inputs in the provenance graph of the executed process. Rather, these are inputs that slightly modify the behavior of the process or allow to set attributes on the process node that represents its execution. The following metadata inputs are available for *all* process classes:"
msgstr ""

#: ../../source/working/processes.rst:255
msgid "``label``: will set the label on the ``ProcessNode``"
msgstr ""

#: ../../source/working/processes.rst:256
msgid "``description``: will set the description on the ``ProcessNode``"
msgstr ""

#: ../../source/working/processes.rst:257
msgid "``store_provenance``: boolean flag, by default ``True``, that when set to ``False``, will ensure that the execution of the process **is not** stored in the provenance graph"
msgstr ""

#: ../../source/working/processes.rst:259
msgid "Sub classes of the :py:class:`~aiida.engine.processes.process.Process` class can specify further metadata inputs, refer to their specific documentation for details. To pass any of these metadata options to a process, simply pass them in a dictionary under the key ``metadata`` in the inputs when launching the process. How a process can be launched is explained the following section."
msgstr ""

#: ../../source/working/processes.rst:267
msgid "Launching processes"
msgstr ""

#: ../../source/working/processes.rst:268
msgid "Any process can be launched by 'running' or 'submitting' it. Running means to run the process in the current python interpreter in a blocking way, whereas submitting means to send it to a daemon worker over RabbitMQ. For long running processes, such as calculation jobs or complex workflows, it is best advised to submit to the daemon. This has the added benefit that it will directly return control to your interpreter and allow the daemon to save intermediate progress during checkpoints and reload the process from those if it has to restart. Running processes can be useful for trivial computational tasks, such as simple calcfunctions or workfunctions, or for debugging and testing purposes."
msgstr ""

#: ../../source/working/processes.rst:278
msgid "Process launch"
msgstr ""

#: ../../source/working/processes.rst:280
msgid "To launch a process, one can use the free functions that can be imported from the :py:mod:`aiida.engine` module. There are four different functions:"
msgstr ""

#: ../../source/working/processes.rst:283
msgid ":py:func:`~aiida.engine.launch.run`"
msgstr ""

#: ../../source/working/processes.rst:284
msgid ":py:func:`~aiida.engine.launch.run_get_node`"
msgstr ""

#: ../../source/working/processes.rst:285
msgid ":py:func:`~aiida.engine.launch.run_get_pk`"
msgstr ""

#: ../../source/working/processes.rst:286
msgid ":py:func:`~aiida.engine.launch.submit`"
msgstr ""

#: ../../source/working/processes.rst:288
msgid "As the name suggest, the first three will 'run' the process and the latter will 'submit' it to the daemon. Running means that the process will be executed in the same interpreter in which it is launched, blocking the interpreter, until the process is terminated. Submitting to the daemon, in contrast, means that the process will be sent to the daemon for execution, and the interpreter is released straight away."
msgstr ""

#: ../../source/working/processes.rst:292
msgid "All functions have the exact same interface ``launch(process, **inputs)`` where:"
msgstr ""

#: ../../source/working/processes.rst:294
msgid "``process`` is the process class or process function to launch"
msgstr ""

#: ../../source/working/processes.rst:295
msgid "``inputs`` are the inputs as keyword arguments to pass to the process."
msgstr ""

#: ../../source/working/processes.rst:297
msgid "What inputs can be passed depends on the exact process class that is to be launched. For example, when we want to run an instance of the :py:class:`~aiida.calculations.plugins.arithmetic.add.ArithmeticAddCalculation` process, which takes two :py:class:`~aiida.orm.nodes.data.int.Int` nodes as inputs under the name ``x`` and ``y`` [#f1]_, we would do the following:"
msgstr ""

#: ../../source/working/processes.rst:303
msgid "The function will submit the calculation to the daemon and immediately return control to the interpreter, returning the node that is used to represent the process in the provenance graph."
msgstr ""

#: ../../source/working/processes.rst:306
msgid "Process functions, i.e. python functions decorated with the ``calcfunction`` or ``workfunction`` decorators, **cannot be submitted** but can only be run."
msgstr ""

#: ../../source/working/processes.rst:308
msgid "The ``run`` function is called identically:"
msgstr ""

#: ../../source/working/processes.rst:313
msgid "except that it does not submit the process to the daemon, but executes it in the current interpreter, blocking it until the process is terminated. The return value of the ``run`` function is also **not** the node that represents the executed process, but the results returned by the process, which is a dictionary of the nodes that were produced as outputs. If you would still like to have the process node or the pk of the process node you can use one of the following variants:"
msgstr ""

#: ../../source/working/processes.rst:320
msgid "Finally, the :py:func:`~aiida.engine.launch.run` launcher has two attributes ``get_node`` and ``get_pk`` that are simple proxies to the :py:func:`~aiida.engine.launch.run_get_node` and :py:func:`~aiida.engine.launch.run_get_pk` methods. This is a handy shortcut, as now you can choose to use any of the three variants with just a single import:"
msgstr ""

#: ../../source/working/processes.rst:326
msgid "If you want to launch a process class that takes a lot more inputs, often it is useful to define them in a dictionary and use the python syntax ``**`` that automatically expands it into keyword argument and value pairs. The examples used above would look like the following:"
msgstr ""

#: ../../source/working/processes.rst:332
msgid "Process functions, i.e. :ref:`calculation functions<concepts_calcfunctions>` and :ref:`work functions<concepts_workfunctions>`, can be launched like any other process as explained above, with the only exception that they **cannot be submitted**. In addition to this limitation, process functions have two additional methods of being launched:"
msgstr ""

#: ../../source/working/processes.rst:335
msgid "Simply *calling* the function"
msgstr ""

#: ../../source/working/processes.rst:336
msgid "Using the internal run method attributes"
msgstr ""

#: ../../source/working/processes.rst:338
msgid "Using a calculation function to add two numbers as an example, these two methods look like the following:"
msgstr ""

#: ../../source/working/processes.rst:347
msgid "Process builder"
msgstr ""

#: ../../source/working/processes.rst:348
msgid "As explained in a :ref:`previous section<working_processes_spec>`, the inputs for a :py:class:`~aiida.engine.processes.calcjobs.calcjob.CalcJob` and :py:class:`~aiida.engine.processes.workchains.workchain.WorkChain` are defined in the :py:meth:`~aiida.engine.processes.process.Process.define` method. To know then what inputs they take, one would have to read the implementation, which can be annoying if you are not a developer. To simplify this process, these two process classes provide a utility called the 'process builder'. The process builder is essentially a tool that helps you build the inputs for the specific process class that you want to run. To get a *builder* for a particular ``CalcJob`` or a ``WorkChain`` implementation, all you need is the class itself, which can be loaded through the :py:class:`~aiida.plugins.factories.CalculationFactory` and :py:class:`~aiida.plugins.factories.WorkflowFactory`, respectively. Let's take the :py:class:`~aiida.calculations.plugins.arithmetic.add.ArithmeticAddCalculation` as an example::"
msgstr ""

#: ../../source/working/processes.rst:358
msgid "The string ``arithmetic.add`` is the entry point of the ``ArithmeticAddCalculation`` and passing it to the ``CalculationFactory`` will return the corresponding class. Calling the ``get_builder`` method on that class will return an instance of the :py:class:`~aiida.engine.processes.builder.ProcessBuilder` class that is tailored for the ``ArithmeticAddCalculation``. The builder will help you in defining the inputs that the ``ArithmeticAddCalculation`` requires and has a few handy tools to simplify this process."
msgstr ""

#: ../../source/working/processes.rst:362
msgid "To find out which inputs the builder exposes, you can simply use tab completion. In an interactive python shell, by simply typing ``builder.`` and hitting the tab key, a complete list of all the available inputs will be shown. Each input of the builder can also show additional information about what sort of input it expects. In an interactive shell, you can get this information to display as follows::"
msgstr ""

#: ../../source/working/processes.rst:377
msgid "In the ``Docstring`` you will see a ``help`` string that contains more detailed information about the input port. Additionally, it will display a ``valid_type``, which when defined shows which data types are expected. If a default value has been defined, that will also be displayed. The ``non_db`` attribute defines whether that particular input will be stored as a proper input node in the database, if the process is submitted."
msgstr ""

#: ../../source/working/processes.rst:382
msgid "Defining an input through the builder is as simple as assigning a value to the attribute. The following example shows how to set the ``parameters`` input, as well as the ``description`` and ``label`` metadata inputs::"
msgstr ""

#: ../../source/working/processes.rst:390
msgid "If you evaluate the ``builder`` instance, simply by typing the variable name and hitting enter, the current values of the builder's inputs will be displayed::"
msgstr ""

#: ../../source/working/processes.rst:403
msgid "In this example, you can see the value that we just set for the ``description`` and the ``label``. In addition, it will also show any namespaces, as the inputs of processes support nested namespaces, such as the ``metadata.options`` namespace in this example. Note that nested namespaces are also all autocompleted, and you can traverse them recursively with tab-completion."
msgstr ""

#: ../../source/working/processes.rst:407
msgid "All that remains is to fill in all the required inputs and we are ready to launch the process builder. When all the inputs have been defined for the builder, it can be used to actually launch the ``Process``. The process can be launched by passing the builder to any of the free functions :py:mod:`~aiida.engine.launch` module, just as you would do a normal process as :ref:`described above<working_processes_launching>`, i.e.:"
msgstr ""

#: ../../source/working/processes.rst:414
msgid "Note that the process builder is in principle designed to be used in an interactive shell, as there is where the tab-completion and automatic input documentation really shines. However, it is perfectly possible to use the same builder in scripts where you simply use it as an input container, instead of a plain python dictionary."
msgstr ""

#: ../../source/working/processes.rst:421
msgid "Monitoring processes"
msgstr ""

#: ../../source/working/processes.rst:422
msgid "When you have launched a process, you may want to investigate its status, progression and the results. The :ref:`verdi<verdi_overview>` command line tool provides various commands to do just this."
msgstr ""

#: ../../source/working/processes.rst:429
msgid "verdi process list"
msgstr ""

#: ../../source/working/processes.rst:430
msgid "Your first point of entry will be the ``verdi`` command ``verdi process list``. This command will print a list of all active processes through the ``ProcessNode`` stored in the database that it uses to represent its execution. A typical example may look something like the following:"
msgstr ""

#: ../../source/working/processes.rst:444
msgid "The 'State' column is a concatenation of the ``process_state`` and the ``exit_status`` of the ``ProcessNode``. By default, the command will only show active items, i.e. ``ProcessNodes`` that have not yet reached a terminal state. If you want to also show the nodes in a terminal states, you can use the ``-a`` flag and call ``verdi process list -a``:"
msgstr ""

#: ../../source/working/processes.rst:460
msgid "For more information on the meaning of the 'state' column, please refer to the documentation of the :ref:`process state <concepts_process_state>`. The ``-S`` flag let's you query for specific process states, i.e. issuing ``verdi process list -S created`` will return:"
msgstr ""

#: ../../source/working/processes.rst:472
msgid "To query for a specific exit status, one can use ``verdi process list -E 0``:"
msgstr ""

#: ../../source/working/processes.rst:484
msgid "This simple tool should give you a good idea of the current status of running processes and the status of terminated ones. For a complete list of all the available options, please refer to the documentation of :ref:`verdi process<verdi_process>`."
msgstr ""

#: ../../source/working/processes.rst:487
msgid "If you are looking for information about a specific process node, the following three commands are at your disposal:"
msgstr ""

#: ../../source/working/processes.rst:489
msgid "``verdi process report`` gives a list of the log messages attached to the process"
msgstr ""

#: ../../source/working/processes.rst:490
msgid "``verdi process status`` print the call hierarchy of the process and status of all its nodes"
msgstr ""

#: ../../source/working/processes.rst:491
msgid "``verdi process show`` print details about the status, inputs, outputs, callers and callees of the process"
msgstr ""

#: ../../source/working/processes.rst:493
msgid "In the following sections, we will explain briefly how the commands work. For the purpose of example, we will show the output of the commands for a completed ``PwBaseWorkChain`` from the ``aiida-quantumespresso`` plugin, which simply calls a ``PwCalculation``."
msgstr ""

#: ../../source/working/processes.rst:500
msgid "verdi process report"
msgstr ""

#: ../../source/working/processes.rst:501
msgid "The developer of a process can attach log messages to the node of a process through the :py:meth:`~aiida.engine.processes.process.Process.report` method. The ``verdi process report`` command will display all the log messages in chronological order:"
msgstr ""

#: ../../source/working/processes.rst:511
msgid "The log message will include a timestamp followed by the level of the log, which is always ``REPORT``. The second block has the format ``pk|class name|function name`` detailing information about, in this case, the work chain itself and the step in which the message was fired. Finally, the message itself is displayed. Of course how many messages are logged and how useful they are is up to the process developer. In general they can be very useful for a user to understand what has happened during the execution of the process, however, one has to realize that each entry is stored in the database, so overuse can unnecessarily bloat the database."
msgstr ""

#: ../../source/working/processes.rst:521
msgid "verdi process status"
msgstr ""

#: ../../source/working/processes.rst:522
msgid "This command is most useful for ``WorkChain`` instances, but also works for ``CalcJobs``. One of the more powerful aspect of work chains, is that they can call ``CalcJobs`` and other ``WorkChains`` to create a nested call hierarchy. If you want to inspect the status of a work chain and all the children that it called, ``verdi process status`` is the go-to tool. An example output is the following:"
msgstr ""

#: ../../source/working/processes.rst:532
msgid "The command prints a tree representation of the hierarchical call structure, that recurses all the way down. In this example, there is just a single ``PwBaseWorkChain`` which called a ``PwCalculation``, which is indicated by it being indented one level. In addition to the call tree, each node also shows its current process state and for work chains at which step in the outline it is. This tool can be very useful to inspect while a work chain is running at which step in the outline it currently is, as well as the status of all the children calculations it called."
msgstr ""

#: ../../source/working/processes.rst:541
msgid "verdi process show"
msgstr ""

#: ../../source/working/processes.rst:542
msgid "Finally, there is a command that displays detailed information about the ``ProcessNode``, such as its inputs, outputs and the optional other processes it called and or was called by. An example output for a ``PwBaseWorkChain`` would look like the following:"
msgstr ""

#: ../../source/working/processes.rst:586
msgid "This overview should give you all the information if you want to inspect a process' inputs and outputs in closer detail as it provides you their pk's."
msgstr ""

#: ../../source/working/processes.rst:592
msgid "Manipulating processes"
msgstr ""

#: ../../source/working/processes.rst:593
msgid "To understand how one can manipulate running processes, one has to understand the principles of the :ref:`process/node distinction<concepts_process_node_distinction>` and a :ref:`process' lifetime<concepts_process_lifetime>` first, so be sure to have read those sections first."
msgstr ""

#: ../../source/working/processes.rst:599
msgid "verdi process pause/play/kill"
msgstr ""

#: ../../source/working/processes.rst:600
msgid "The ``verdi`` command line interface provides three commands to interact with 'live' processes."
msgstr ""

#: ../../source/working/processes.rst:602
msgid "``verdi process pause``"
msgstr ""

#: ../../source/working/processes.rst:603
msgid "``verdi process play``"
msgstr ""

#: ../../source/working/processes.rst:604
msgid "``verdi process kill``"
msgstr ""

#: ../../source/working/processes.rst:606
msgid "The first pauses a process temporarily, the second resumes any paused processes and the third one permanently kills them. The sub command names might seem to tell you this already and it might look like that is all there is to know, but the functionality underneath is quite complicated and deserves additional explanation nonetheless."
msgstr ""

#: ../../source/working/processes.rst:609
msgid "As the section on :ref:`the distinction between the process and the node<concepts_process_node_distinction>` explained, manipulating a process means interacting with the live process instance that lives in the memory of the runner that is running it. By definition, these runners will always run in a different system process then the one from which you want to interact, because otherwise, you would *be* the runner, given that there can only be a single runner in an interpreter and if it is running, the interpreter would be blocked from performing any other operations. This means that in order to interact with the live process, one has to interact with another interpreter running in a different system process. This is once again facilitated by the RabbitMQ message broker. When a runner starts to run a process, it will also add listeners for incoming messages that are being sent for that specific process over RabbitMQ."
msgstr ""

#: ../../source/working/processes.rst:617
msgid "This does not just apply to daemon runners, but also normal runners. That is to say that if you were to launch a process in a local runner, that interpreter will be blocked, but it will still setup the listeners for that process on RabbitMQ. This means that you can manipulate the process from another terminal, just as if you would do with a process that is being run by a daemon runner."
msgstr ""

#: ../../source/working/processes.rst:621
msgid "In the case of 'pause', 'play' and 'kill', one is sending what is called a Remote Procedure Call (RPC) over RabbitMQ. The RPC will include the process identifier for which the action is intended and RabbitMQ will send it to whoever registered itself to be listening for that specific process, in this case the runner that is running the process. This immediately reveals a potential problem: the RPC will fall on deaf ears if there is no one listening, which can have multiple causes. For example, as explained in the section on a :ref:`process' lifetime<concepts_process_lifetime>`, this can be the case for a submitted process, where the corresponding task is still queued, as all available process slots are occupied. But even if the task *were* to be with a runner, it might be too busy to respond to the RPC and the process appears to be unreachable. Whenever a process is unreachable for an RPC, the command will return an error:"
msgstr ""

#: ../../source/working/processes.rst:632
msgid "Depending on the cause of the process being unreachable, the problem may resolve itself automatically over time and one can try again at a later time, as for example in the case of the runner being too busy to respond. However, to prevent this from happening, the runner has been designed to have the communication happen over a separate thread and to schedule callbacks for any necessary actions on the main thread, which performs all the heavy lifting. This should make occurrences of the runner being too busy to respond very rare. If you think the The problem is, however, there is unfortunately no way of telling what the actual problem is for the process not being reachable. The problem will manifest itself identically if the runner just could not respond in time or if the task has accidentally been lost forever due to a bug, even though these are two completely separate situations."
msgstr ""

#: ../../source/working/processes.rst:639
msgid "This brings us to another potential unintuitive aspect of interacting with processes. The previous paragraph already mentioned it in passing, but when a remote procedure call is sent, it first needs to be answered by the responsible runner, if applicable, but it will not *directly execute* the call. This is because the call will be incoming on the communcation thread who is not allowed to have direct access to the process instance, but instead it will schedule a callback on the main thread who can perform the action. The callback will however not necessarily be executed directly, as there may be other actions waiting to be performed. So when you pause, play or kill a process, you are not doing so directly, but rather you are *scheduling* a request to do so. If the runner has successfully received the request and scheduled the callback, the command will therefore show something like the following:"
msgstr ""

#: ../../source/working/processes.rst:650
msgid "The 'scheduled' indicates that the actual killing might not necessarily have happened just yet. This means that even after having called ``verdi process kill`` and getting the success message, the corresponding process may still be listed as active in the output of ``verdi process list``."
msgstr ""

#: ../../source/working/processes.rst:653
msgid "By default, the ``pause``, ``play`` and ``kill`` commands will only ask for the confirmation of the runner that the request has been scheduled and not actually wait for the command to have been executed. This is because, as explained, the actual action being performed might not be instantaneous as the runner may be busy working with other processes, which would mean that the command would block for a long time. If you want to send multiple requests to a lot of processes in one go, this would be ineffective, as each one would have to wait for the previous one to be completed. To change the default and actually wait for the action to be completed and await its response, you can use the ``--wait`` flag. If you know that your daemon runners may be experiencing a heavy load, you can also increase the time that the command waits before timing out, with the ``-t/--timeout`` flag."
msgstr ""

#: ../../source/working/processes.rst:661
msgid "Footnotes"
msgstr ""

#: ../../source/working/processes.rst:662
msgid "Note that the :py:class:`~aiida.calculations.plugins.arithmetic.add.ArithmeticAddCalculation` process class also takes a ``code`` as input, but that has been omitted for the purposes of the example."
msgstr ""

