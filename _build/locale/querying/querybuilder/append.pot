# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2019, ECOLE POLYTECHNIQUE FEDERALE DE LAUSANNE (Theory and Simulation of Materials (THEOS) and National Centre for Computational Design and Discovery of Novel Materials (NCCR MARVEL)), Switzerland and ROBERT BOSCH LLC, USA. All rights reserved
# This file is distributed under the same license as the AiiDA package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: AiiDA 1.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-05-15 13:38+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../source/querying/querybuilder/append.rst:4
msgid "The appender method"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:7
msgid "Selecting entities"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:9
msgid "Let's suppose you want to query for calculation nodes in your database::"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:16
msgid "Calculations are more tricky than Data, since they have both a run-time ``Process`` that steers them and a ``Node`` that stores their metadata in the database. The QueryBuilder allows you to pass either the ``Node`` class (e.g. ``CalcJobNode``) or the ``Process`` class (e.g. ``CalcJob``, ``PwCalculation``), which will automatically apply the correct filters for the type of calculation."
msgstr ""

#: ../../source/querying/querybuilder/append.rst:22
msgid "If you are interested in instances of different classes, you can also pass a tuple, list or set of classes. However, they have to be of the same ORM-type (e.g. all have to be subclasses of Node)::"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:31
msgid "Retrieving results"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:33
msgid "Let's suppose that's what we want to query for (all job calculations in the database). The question is how to get the results from the query::"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:56
msgid "Generators are useful if you have to retrieve a very large (>10000) number of results. This will retrieve the data in batches, and you can start working with the data before the query has completely finished. Be aware that if using generators, you should never commit (store) anything while iterating. The query is still going on, and might be compromised by new data in the database."
msgstr ""

#: ../../source/querying/querybuilder/append.rst:64
msgid "Filtering"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:67
msgid "Since we now know how to set an entity, we can start to filter by properties of that entity. Suppose we do not want to all CalcJobNodes, but only the ones in state 'FINISHED'::"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:79
msgid "How, can we have multiple filters? Suppose you are interested in all calculations in your database that are in state 'FINISHED' and were created in the last *n* days::"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:99
msgid "Let's go through the above example. We have instantiated QueryBuilder instance. We appended to its path a CalcJobNode (a remote calculation), and specified that we are only interested in  calculations that have finished **and** that were created in the last *n* days."
msgstr ""

#: ../../source/querying/querybuilder/append.rst:105
msgid "What if we want calculations that have finished **or** were created in the last *n* days::"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:120
msgid "If we had written *and* instead of *or*, we would have created the exact same query as in the first query, because *and* is the default behavior if you attach several filters. What if you want calculation in state 'FINISHED' or 'RETRIEVING'? This will be the next example::"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:135
msgid "In order to negate a filter, that is to apply the not operator, precede the filter keyword with an exclamation mark. So, to ask for all calculations that are not in 'FINISHED' or 'RETRIEVING'::"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:149
msgid "The above rule applies strictly! You check a non-equality with !==, since this is the equality operator (==) with a negation prepended."
msgstr ""

#: ../../source/querying/querybuilder/append.rst:152
msgid "This is a list of all implemented operators:"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:155
#: ../../source/querying/querybuilder/append.rst:185
msgid "**Operator**"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:155
#: ../../source/querying/querybuilder/append.rst:185
msgid "**Datatype**"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:155
#: ../../source/querying/querybuilder/append.rst:185
msgid "**Example**"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:155
#: ../../source/querying/querybuilder/append.rst:185
msgid "Explanation"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:157
msgid "=="
msgstr ""

#: ../../source/querying/querybuilder/append.rst:157
#: ../../source/querying/querybuilder/append.rst:159
msgid "All"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:157
msgid "'id':{'==':123}"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:157
msgid "Checks equality"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:159
msgid "in"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:159
msgid "'name':{'in':['foo', 'bar']}"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:159
msgid "equal to any element"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:161
msgid ">,<,<=,>="
msgstr ""

#: ../../source/querying/querybuilder/append.rst:161
msgid "floats, integers, dates"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:161
msgid "'ctime':{'<':datetime(2016, 03, 03)}"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:161
msgid "lower/greater (equal)"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:165
msgid "like"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:165
#: ../../source/querying/querybuilder/append.rst:170
msgid "Strings"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:165
msgid "'name':{'like':'lovely_calc%'}"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:165
msgid "substring (% and _ are wildcards. To use % and _ as part of the string prepend it with \\\\)"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:170
msgid "ilike"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:170
msgid "'name':{'ilike':'loVely_Calc%'}"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:170
msgid "case insensitive 'like'"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:172
msgid "or"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:172
#: ../../source/querying/querybuilder/append.rst:175
msgid "list of expressions"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:172
msgid "'id':{'or':[{'<':12}, {'==':199}]}"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:175
msgid "and"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:175
msgid "'id':{'and':[{'<':12}, {'>':1 }]}"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:179
msgid "There are also some advanced operators:"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:187
msgid "has_key"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:187
msgid "dicts"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:0
msgid "'attributes.mykey':{'has_key': 'foo'}"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:0
msgid "'extras':{'has_key': 'my_extra'}"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:187
msgid "Check that a dictionary (typically stored in the attributes or in the extras) has a given key. This can also be used to check if a given attribute or extra exists."
msgstr ""

#: ../../source/querying/querybuilder/append.rst:194
msgid "of_type"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:194
msgid "any"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:0
msgid "'attributes.mykey':{'of_type': 'bool'}"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:194
msgid "Check that an attribute or an extra is of a given type. Valid types are: ``object`` (meaning a dictionary), ``array`` (meaning a list), ``string``, ``number`` (both for integers and floats), ``boolean`` or ``null``) **(currently implemented only in the SQLA backend)**"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:204
msgid "of_length"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:204
#: ../../source/querying/querybuilder/append.rst:210
#: ../../source/querying/querybuilder/append.rst:217
#: ../../source/querying/querybuilder/append.rst:224
msgid "lists"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:0
msgid "'attributes.mylist': {'of_length': 4}"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:204
msgid "Check that a list (typically stored in the attributes or in the extras) has a given length **(currently implemented only in the SQLA backend)**"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:210
msgid "shorter"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:0
msgid "'attributes.mylist': {'shorter': 4}"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:210
msgid "Check that a list (typically stored in the attributes or in the extras) has a length shorter than the specified value **(currently implemented only in the SQLA backend)**"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:217
msgid "longer"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:0
msgid "'attributes.mylist': {'longer': 4}"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:217
msgid "Check that a list (typically stored in the attributes or in the extras) has a length longer than the specified value **(currently implemented only in the SQLA backend)**"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:224
msgid "contains"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:0
msgid "'attributes.mykey': {'contains': ['a','b']}"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:224
msgid "Check that a list (typically stored in the attributes or in the extras) contains some specific elements or values **(currently implemented only in the SQLA backend)**"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:233
msgid "This showed you how to 'filter' by properties of a node. So far we can do that for a single a single node in the database."
msgstr ""

#: ../../source/querying/querybuilder/append.rst:238
msgid "Joining entities"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:240
msgid "But we sometimes need to query relationships in graph-like database. Let's join a node to its output, e.g. StructureData and CalcJobNode (as output)::"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:247
msgid "In above example we are querying structures and calculations, with the predicate that the calculation is an output of the structure (the same as saying that the structure is an input to the calculation) In the above example, we have first appended StructureData to the path. So that we can refer to that vertice later, we *tag* it with a unique keyword of our choice, which can be used only once. When we append another vertice to the path, we specify the relationship to a previous entity by using one of the keywords in the above table and as a value the tag of the vertice that it has a relationship with. There are several relationships that entities in Aiida can have:"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:258
msgid "**Entity from**"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:258
msgid "**Entity to**"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:258
msgid "**Relationship**"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:258
msgid "**Deprecated Relationship**"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:258
msgid "**Explanation**"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:260
#: ../../source/querying/querybuilder/append.rst:260
#: ../../source/querying/querybuilder/append.rst:262
#: ../../source/querying/querybuilder/append.rst:262
#: ../../source/querying/querybuilder/append.rst:264
#: ../../source/querying/querybuilder/append.rst:264
#: ../../source/querying/querybuilder/append.rst:266
#: ../../source/querying/querybuilder/append.rst:266
#: ../../source/querying/querybuilder/append.rst:268
#: ../../source/querying/querybuilder/append.rst:270
#: ../../source/querying/querybuilder/append.rst:272
#: ../../source/querying/querybuilder/append.rst:274
#: ../../source/querying/querybuilder/append.rst:276
#: ../../source/querying/querybuilder/append.rst:278
#: ../../source/querying/querybuilder/append.rst:284
#: ../../source/querying/querybuilder/append.rst:289
msgid "Node"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:260
msgid "*with_outgoing*"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:260
msgid "*input_of*"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:260
msgid "One node as input of another node"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:262
msgid "*with_incoming*"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:262
msgid "*output_of*"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:262
msgid "One node as output of another node"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:264
msgid "*with_descendants*"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:264
msgid "*ancestor_of*"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:264
msgid "One node as the ancestor of another node (Path)"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:266
msgid "*with_ancestors*"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:266
msgid "*descendant_of*"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:266
msgid "One node as descendant of another node (Path)"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:268
#: ../../source/querying/querybuilder/append.rst:270
#: ../../source/querying/querybuilder/append.rst:280
#: ../../source/querying/querybuilder/append.rst:282
msgid "Group"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:268
#: ../../source/querying/querybuilder/append.rst:272
#: ../../source/querying/querybuilder/append.rst:276
#: ../../source/querying/querybuilder/append.rst:284
msgid "*with_node*"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:268
msgid "*group_of*"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:268
msgid "The group of a node"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:270
#: ../../source/querying/querybuilder/append.rst:282
msgid "*with_group*"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:270
msgid "*member_of*"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:270
msgid "The node is a member of a group"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:272
#: ../../source/querying/querybuilder/append.rst:274
msgid "Computer"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:272
msgid "*computer_of*"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:272
msgid "The computer of a node"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:274
msgid "*with_computer*"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:274
msgid "*has_computer*"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:274
msgid "The node of a computer"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:276
#: ../../source/querying/querybuilder/append.rst:278
#: ../../source/querying/querybuilder/append.rst:280
#: ../../source/querying/querybuilder/append.rst:282
#: ../../source/querying/querybuilder/append.rst:291
#: ../../source/querying/querybuilder/append.rst:293
msgid "User"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:276
msgid "*creator_of*"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:276
msgid "The creator of a node is a user"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:278
#: ../../source/querying/querybuilder/append.rst:280
#: ../../source/querying/querybuilder/append.rst:291
msgid "*with_user*"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:278
msgid "*created_by*"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:278
#: ../../source/querying/querybuilder/append.rst:280
#: ../../source/querying/querybuilder/append.rst:282
msgid "The node was created by a user"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:280
msgid "*belongs_to*"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:282
msgid "*owner_of*"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:284
msgid "Log"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:284
msgid "The log of a node"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:286
msgid "Log Node"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:286
msgid "Node Comment"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:286
msgid "*with_log* *with_node*"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:286
msgid "The node has a log The comment of a node"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:289
#: ../../source/querying/querybuilder/append.rst:291
#: ../../source/querying/querybuilder/append.rst:293
msgid "Comment"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:289
#: ../../source/querying/querybuilder/append.rst:293
msgid "*with_comment*"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:289
msgid "The node has a comment"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:291
msgid "The comment was created by a user"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:293
msgid "The creator of a comment is a user"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:297
msgid "Some more examples::"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:320
msgid "The above QueryBuilder will join a structure to all its descendants via the transitive closure table."
msgstr ""

#: ../../source/querying/querybuilder/append.rst:326
msgid "Defining the projections"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:328
msgid "But what will the query return exactly? If you try any of the examples, you will find that the instances of the last appended vertice appear! That is the default behavior if nothing else was specified. We usually do not want everything returned because it might lead to a big overhead. You need to specify what you want to return using the keyword *project*."
msgstr ""

#: ../../source/querying/querybuilder/append.rst:334
msgid "Let's stick to the previous example::"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:350
msgid "In the above example, executing the query returns the type and the id of all Node that are descendants of the structure::"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:382
msgid "results in the following output::"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:405
msgid "Asking only for the properties that you are interested in can result in much faster queries. If you want the Aiida-ORM instance, add '*' to your list of projections::"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:436
#: ../../source/querying/querybuilder/append.rst:474
msgid "Output::"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:460
msgid "Be aware that, for consistency, QueryBuilder.all / iterall always returns a list of lists, and first always a list, even if you project on one entity!"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:465
msgid "If you are not sure which keys to ask for, you can project with '**', and the QueryBuilder instance will return all column properties::"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:494
msgid "Attributes and extras"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:496
msgid "You should know by now that you can define additional properties of nodes in the *attributes* and the *extras* of a node. There will be many cases where you will either want to filter or project on those entities. The following example gives us a PwCalculation where the cutoff for the wavefunctions has a value above 30.0 Ry::"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:515
msgid "The above examples filters by a certain attribute. Notice how you expand into the dictionary using the dot (.). That works the same for the extras."
msgstr ""

#: ../../source/querying/querybuilder/append.rst:520
msgid "Comparisons in the attributes (extras) are also implicitly done by type."
msgstr ""

#: ../../source/querying/querybuilder/append.rst:522
msgid "Filtering or projecting on lists works similar to dictionaries. You expand into the list using the dot (.) and afterwards adding the list-index. The example below filters KpointsData by the first index in the mesh of KpointsData=instance, and returns that same index in the list::"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:533
msgid "Let's do a last example. You are familiar with the Quantum Espresso PWscf tutorial? Great, because this will be our use case here. (If not, you can find it on the `documentation of the aiida-quantumespresso package <http://aiida-quantumespresso.readthedocs.io/en/latest/user_guide/get_started/examples/pw_tutorial.html>`_. We will query for calculations that were done on a certain structure (*mystructure*), that fulfill certain requirements, such as a cutoff above 30.0. In our case, we have a structure (an instance of StructureData) and an instance of Dict that are both inputs to a PwCalculation. You need to tell the QueryBuilder that::"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:564
msgid "Cheats"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:567
msgid "A few cheats to save some typing:"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:569
msgid "The default edge specification, if no keyword is provided, is always *with_incoming* the previous vertice."
msgstr ""

#: ../../source/querying/querybuilder/append.rst:571
msgid "Equality filters ('==') can be shortened, as will be shown below."
msgstr ""

#: ../../source/querying/querybuilder/append.rst:572
msgid "Tags are not necessary, you can simply use the class as a label. This works as long as the same Aiida-class is not used again"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:575
msgid "A shorter version of the previous example::"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:594
msgid "Advanced usage"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:596
msgid "Let's proceed to some more advanced stuff. If you've understood everything so far you're in good shape to query the database, so you can skip the rest if you want."
msgstr ""

#: ../../source/querying/querybuilder/append.rst:700
msgid "Working with edges"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:702
msgid "Another feature that had to be added are projections, filters and labels on the edges of the graphs, that is to say links or paths between nodes. It works the same way, just that the keyword is preceeded by '*link*'. Let's take the above example, but put a filter on the label of the link and project the link label::"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:723
msgid "Ordering results"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:726
msgid "You can also order by properties of the node, although ordering by attributes or extras is not implemented yet. Assuming you want to order the above example by the time of the calculations::"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:745
msgid "Limiting the number of results"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:747
msgid "You can also limit the number of rows returned with the method *limit*::"
msgstr ""

#: ../../source/querying/querybuilder/append.rst:766
msgid "The above query returns the latest 10 calculation that produced a final energy above -5.0."
msgstr ""

